problem_link,problem_id,problem_idx,short_id,contest_number,problem_name,problem_statement,problem_solution,problem_input,problem_output,problem_tags,problem_dificulty,file_name,editorial_link,problem_editorial
https://codeforces.com//contest/887/problem/B,132441,B,887B,887,B. Cubes for Masha,Absent minded Masha got set of cubes for her birthday At each of 6 faces of each cube there is exactly one digit from 0 to 9 Masha became interested what is the largest natural such she can make using her new cubes all integers from 1 to To make a number Masha can rotate her cubes and put them in a row After that she looks at upper faces of cubes from left to right and reads the number The number can t contain leading zeros It s not required to use all cubes to build a number Pay attention Masha can t make digit 6 from digit 9 and vice versa using cube rotations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair < int , int >\n#define pipii pair < int , pii >\n#define pid pair <int, double>\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define pp pop_back()\n#define sz size()\n#define iz insert\n#define lg length()\n#define FRNAME ""A""\n#define inf (int)1e6\n#define fr freopen(FRNAME"".in"",""r"",stdin); freopen (FRNAME"".out"",""w"",stdout);\n#define fr2 freopen(""input.txt"",""r"",stdin); freopen (""output.txt"",""w"",stdout)\nint a[100];\nint b[5][100];\nint c[5][10];\nint go[5];\nint n;\nbool solve (int t)\n{\n\tint cnt = 0;\n\twhile (t)\n\t{\n\t\tint w = t%10;\n\t\tif (!b[go[cnt]][w]) return false;\n\t\tcnt++;\n\t\tt /= 10;\n\t}\n\treturn true;\n}\t\nbool check (int t)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tgo[i] = i;\n\t}\n\tif (solve(t)) return true;\n\twhile(next_permutation(go,go+n))\n\t{\n\t\tif(solve(t)) return true;\n\t}\n\treturn false;\n}\t\nint main ()\n{\n\tcin >> n;\n\tfor (int q = 0; q < n; q++)\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcin >> c[q][i];\n\t\tb[q][c[q][i]] = 1;\n\t}\t\n\tint t = 1;\n\twhile (true)\n\t{\n\t\tif (!check(t)) \n\t\t{\n\t\t\tcout << t - 1;\n\t\t\treturn 0;\n\t\t}\t\n\t\tt++;\n\t}\t\n\treturn 0;\n}\t']",,,"['brute force', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Cubes for Masha.json,https://codeforces.com//blog/entry/55584,The answer is always less or equal to 98 We can go through numbers from 1 to 99 and find the first one which we cannot make using cubes 
https://codeforces.com//contest/1017/problem/H,205998,H,1017H,1017,H. The Films,In world there are m different film endings Abendsen owns a storage and a shelf At first he has n ordered films on the shelf In the i th month he will do Empty the storage Put k i cdot m films into the storage k i films for each ending He will think about a question if he puts all the films from the shelf into the storage then randomly picks n films from all the films in the storage and rearranges them on the shelf what is the probability that sequence of endings in l i r i on the shelf will not be changed Notice he just thinks about this question so the shelf will not actually be changed Answer all Abendsen s questions Let the probability be fraction P i Let s say that the total number of ways to take n films from the storage for i th month is A i so P i cdot A i is always an integer Print for each month P i cdot A i pmod 998244353 998244353 is a prime number and it is equal to 119 cdot 2 23 1 It is guaranteed that there will be only no more than 100 different k values ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nll n,m,q, ans[MX];\nll fac[2*MX], ifac[2*MX];\nint e[MX], co[MX], special[MX];\nvi S;\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll mul(const ll& a, const ll& b) {\n    return (a%MOD)*(b%MOD)%MOD;\n}\n\nll MUL(ll& a, const ll& b) { return a = mul(a,b); }\n\nvoid init() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m >> q;\n    FOR(i,1,n+1) {\n        // e[i] = rand() % 300+1;\n        cin >> e[i];\n        co[e[i]] ++;\n    }\n    FOR(i,1,m+1) if ((ll)co[i]*co[i] > n) {\n        special[i] = 1;\n        S.pb(i);\n    }\n}\n\nvector<array<int,4>> v;\n\nbool cmp(array<int,4> a, array<int,4> b) {\n    if (a[0]/320 != b[0]/320) return a[0] < b[0];\n    return a[1] < b[1];\n}\n\nint tmp[MX], cur[MX];\nint l = 1, r = 0;\n\nvoid ad(int x, int y) {\n    if (!special[x]) {\n        if (y == 1) tmp[co[x]-cur[x]] ++;\n        else tmp[co[x]-cur[x]+1] --;\n    }\n    cur[x] += y;\n}\n\nvoid answer(array<int,4> a) {\n    while (l > a[0]) ad(e[--l],1);\n    while (r < a[1]) ad(e[++r],1);\n    while (l < a[0]) ad(e[l++],-1);\n    while (r > a[1]) ad(e[r--],-1);\n    \n    ans[a[3]] = 1;\n    for (int i = 1; i*i <= n; ++i) \n        MUL(ans[a[3]],po(i+a[2],tmp[i]));\n    \n    for (int i: S) \n        MUL(ans[a[3]],mul(fac[co[i]+a[2]],ifac[co[i]+a[2]-cur[i]]));\n}\n\nll zz[MX];\n\nvoid addFac() {\n    sort(all(v),[](array<int,4> a, array<int,4> b) { return a[2] < b[2]; });\n    for (int i = 0; i < sz(v); ) {\n        zz[1] = 1;\n        FOR(j,2,MX) zz[j] = mul(zz[j-1],m*v[i][2]+j-1);\n        int I = i;\n        while (i < sz(v) && v[i][2] == v[I][2]) {\n            MUL(ans[v[i][3]],zz[n-(v[i][1]-v[i][0])]);\n            i ++;\n        }\n    }\n}\n\nint main() {\n    init();\n    \n    fac[0] = ifac[0] = 1;\n    FOR(i,1,2*MX) {\n        fac[i] = mul(i,fac[i-1]);\n        ifac[i] = inv(fac[i]);\n    }\n    \n    F0R(i,q) {\n        int l,r,k; cin >> l >> r >> k;\n        // int l = rand() % n+1, r = rand() % n+1, k = rand() % m+1;\n        if (l > r) swap(l,r);\n        v.pb({l,r,k,i});\n    }\n    \n    sort(all(v),cmp);\n    for (auto a: v) answer(a);\n    addFac();\n    F0R(i,q) cout << ans[i] << ""\\n"";\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']",,,['brute force'],3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. The Films.json,https://codeforces.com/blog/entry/61081,First we claim the probability is this Where is the number of times ending occurs in total and is the number of times ending occurs in segment Proof For each position in with ending you can choose any film with the same ending there are of them for the first candidate and of them for the second candidate So you can satisfy the conditions with number of ways After that other positions can be filled arbitrarily there are ways of doing that And the total number of ways is obviously If we can maintain the expression using Mo algorithm with complexity about More precisely it is or Key observation There can only be different occuring times at most Proof In the worst case the occurring times are so Similarly that there are at most different combinations of and Proof In the worst case pairs of are like 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 Let its length of same be and repeat time be Then from the total occurring times we get and from the occurring times in segment we get So around we achieve the minimum Use a hash table actually an array of size to remember them and brute force them for each query We re done About the part since there are no more than different value preprocess that for each Complexity Actually due to limit of if one simply run mo algorithm times it will reach a Under this limit it can be faster than standard solution Bonus can we have a solution that does not depend on if only part is calculated and faster than 
https://codeforces.com//contest/997/problem/A,194450,A,997A,997,A. Convert to Ones,You ve got a string a 1 a 2 dots a n consisting of zeros and ones Let s call a sequence of consecutive elements a i a i 1 ldots a j 1 leq i leq j leq n a of string a You can apply the following operations any number of times Choose some substring of string a for example you can choose entire string and reverse it paying x coins for it for example to Choose some substring of string a for example you can choose entire string or just one symbol and replace each symbol to the opposite one zeros are replaced by ones and ones by zeros paying y coins for it for example to You can apply these operations in any order It is allowed to apply the operations multiple times to the same substring What is the minimum number of coins you need to spend to get a string consisting only of ones ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,x,y;\nchar s[SZ];\nint main()\n{\n\tscanf(""%d%d%d%s"",&n,&x,&y,s+1);\n\tint b=0; ll ans=8e18;\n\tfor(int i=1;i<=n;++i)\n\t\tif(s[i]==\'0\'&&s[i-1]!=\'0\') ++b;\n\tif(!b) ans=0;\n\tfor(int i=0;i<b;++i)\n\t\tans=min(ans,y*(ll)(b-i)+x*(ll)i);\n\tprintf(""%lld\\n"",ans);\n}\n']",,,"['brute force', 'greedy', 'implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Convert to Ones.json,https://codeforces.com/blog/entry/60357,Let s partite consecutive elements of the same color into groups For example we will split into Then it is obvious that it is useless to make moves within one group and then if we have at least two groups of color for one move we can reduce by one and can t reduce by two the number of segments of color paying for it either or whatever Let s consider for example if we have a string we can flip the segment and turn it into a string or for example invert the segment turning the string into Then the number of color groups decreased from two to one But in the end you still need to do at least one inverting of the segment which will be one at the end Then let number of groups of color If the answer is Otherwise the answer is 
https://codeforces.com//contest/1364/problem/E,647246,E,1364E,1364,E. X-OR,Ehab has a hidden permutation p of length n consisting of the elements from 0 to n 1 You for some reason want to figure out the permutation To do that you can give Ehab 2 indices i and j and he ll reply with p i p j where is the bitwise or operation Ehab has just enough free time to answer 4269 questions and while he s OK with answering that many questions he s too lazy to play your silly games so he ll fix the permutation beforehand and will change it depending on your queries Can you guess the permutation ,"['#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nint n;\nbool bad[2050];\nint val[2050];\nint main() {\n    srand(time(NULL));\n    cin >> n;\n    int base = rand() % n;\n    for (int i = 0; i < n; i++) {\n        val[i] = -1;\n    }\n    while (true) {\n        int samples_cnt = 0;\n        int min_sample_val = 5000;\n        int min_sample_ind = 0;\n        int andd = (1 << 11) - 1;\n        std::vector<pair<int, int>> samples;\n        for (int i = 0; i < n; i++) {\n            if (i != base && !bad[i]) {\n                cout << ""? "" << base + 1 << "" "" << i + 1 << std::endl;\n                int res;\n                cin >> res;\n                samples_cnt++;\n                samples.push_back({i, res});\n                if (res < min_sample_val) {\n                    min_sample_val = res;\n                    min_sample_ind = i;\n                }\n                andd &= res;\n                if (samples_cnt >= 20) {\n                    if (min_sample_val == andd) {\n                        base = min_sample_ind;\n                        for (auto pr : samples) {\n                            if (pr.second != min_sample_val) {\n                                bad[pr.first] = true;\n                            }\n                        }\n                        goto m1;\n                    }\n                }\n            }\n        }\n        while (samples.size() < 20) {\n            int sample = rand() % n;\n            while (sample == base) {\n                sample = rand() % n;\n            }\n            cout << ""? "" << base + 1 << "" "" << sample + 1 << std::endl;\n            int res;\n            cin >> res;\n            if (res < min_sample_val) {\n                min_sample_val = res;\n                min_sample_ind = sample;\n            }\n            andd &= res;\n            samples.push_back({sample, res});\n        }\n        if (andd == 0) {\n            val[base] = 0;\n            for (auto pr : samples) {\n                val[pr.first] = pr.second;\n            }\n            for (int i = 0; i < n; i++) {\n                if (val[i] == -1) {\n                    cout << ""? "" << base + 1 << "" "" << i + 1 << std::endl;\n                    cin >> val[i];\n                }\n            }\n            cout << ""! "";\n            for (int i = 0; i < n - 1; i++) {\n                cout << val[i] << "" "";\n            }\n            cout << val[n - 1] << std::endl;\n            break;\n        } else {\n            // cout << min_sample_val << "" "" << andd << ""\\n"";\n            assert(min_sample_val == andd);\n            base = min_sample_ind;\n            for (auto pr : samples) {\n                if (pr.second != min_sample_val) {\n                    bad[pr.first] = true;\n                }\n            }\n            goto m1;\n        }\n        m1:;\n    }\n}']",,,"['bitmasks', 'constructive algorithms', 'divide and conquer', 'interactive', 'probabilities']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. X-OR.json,https://codeforces.com//blog/entry/78781,The common idea is if we find the index that contains we can query it with every element in and finish in queries if you didn t do that pleaaase share your solution How to get this index 
https://codeforces.com//contest/893/problem/F,135516,F,893F,893,F. Subtree Minimum Query,You are given a rooted tree consisting of vertices Each vertex has a number written on it number is written on vertex Let s denote as the distance between vertices and in the tree that is the number of edges in the shortest path from to Also let s denote the of vertex as the set of vertices such that both these conditions are met is an ancestor of every vertex is an ancestor of itself You are given queries to the tree th query is represented by two numbers and and the answer to this query is the minimum value of among such vertices such that belongs to blocked subtree of Write a program that would process these queries quickly ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nstruct Vertex {\n\tint level;\n\tint val;\n\n\tVertex() {}\n\tVertex(int l, int v): level(l), val(v) {}\n\n\tbool operator <(const Vertex& ot) const {\n\t\treturn level < ot.level;\n\t}\n};\n\nconst int INF = 1e9 + 10;\n\nstruct SegTree {\n\tint n;\n\tvector<vector<Vertex>> a;\n\tvector<vector<int>> res;\n\n\tSegTree(const vector<int>& level, const vector<int>& vals) {\n\t\tn = 1;\n\t\twhile (n < (int)level.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\ta.resize(n + n);\n\t\tres.resize(n + n);\n\t\tfor (int i = 0; i < (int)level.size(); ++i) {\n\t\t\ta[n + i] = {{level[i], vals[i]}};\n\t\t\tres[n + i] = {INF, vals[i]};\n\t\t}\n\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\ta[i].resize(a[i + i].size() + a[i + i + 1].size());\n\t\t\tmerge(all(a[i + i]), all(a[i + i + 1]), a[i].begin());\n\t\t\tres[i].resize(a[i].size() + 1, INF);\n\t\t\tfor (int j = 0; j < (int)a[i].size(); ++j) {\n\t\t\t\tres[i][j + 1] = min(res[i][j], a[i][j].val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint _get(int v, int l1, int r1, int l, int r, int maxk) {\n\t\tif (l >= r1 || l1 >= r) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (l <= l1 && r >= r1) {\n\t\t\tint idx = lower_bound(all(a[v]), Vertex(maxk + 1, 0)) - a[v].begin();\n\t\t\treturn res[v][idx];\n\t\t}\n\t\tint mid = (l1 + r1) / 2;\n\t\treturn min(_get(v + v, l1, mid, l, r, maxk),\n\t\t\t\t   _get(v + v + 1, mid, r1, l, r, maxk));\n\t}\n\n\tint get(int l, int r, int maxk) {\n\t\treturn _get(1, 0, n, l, r, maxk);\n\t}\n};\n\nconst int N = 111111;\nint tin[N], tout[N], level[N];\nint timer = 0;\nvector<int> a[N];\nint val[N];\nvector<int> levels, vals;\n\nvoid dfs(int v, int p = -1) {\n\ttin[v] = timer++;\n\tlevels.push_back(level[v]);\n\tvals.push_back(val[v]);\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tlevel[x] = level[v] + 1;\n\t\tdfs(x, v);\n\t}\n\ttout[v] = timer;\n}\n\nint main() {\n\tint n = nxt(), root = nxt() - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tval[i] = nxt();\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tdfs(root);\n\n\tSegTree tree(levels, vals);\n\tint q = nxt();\n\tint last = 0;\n\twhile (q--) {\n\t\tint p1 = nxt(), p2 = nxt();\n\t\tint x = (p1 + last) % n;\n\t\tint k = (p2 + last) % n;\n\n\t\tlast = tree.get(tin[x], tout[x], level[x] + k);\n\t\tprintf(""%d\\n"", last);\n\t}\n\n\treturn 0;\n}\n']",,,"['data structures', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Subtree Minimum Query.json,https://codeforces.com//blog/entry/55989,The main idea is to use a two dimensional data structure one dimension is depth of vertices and other dimension is the time we entered a vertex during DFS Model solution uses sparse table for these purposes First of all let s renumerate the vertices so we can handle them easier We run DFS from the root and then sort the vertices by their depth and if depths are equal by time we entered them in DFS Then we renumerate vertices in this sorted order We need to denote some functions in order to continue depth of vertex in the tree the time we entered during DFS the time we left during DFS For each depth we can store a sorted array of vertices belonging do this depth This will allow us to build an auxiliary sparse table where is such vertex that is minimal among all vertices that meet first two conditions We also need a second sparse table where is iff is minimal among all vertices that meet first two conditions These sparse tables can be built using binary search in arrays we created for depths Okay why do we need them To create a third sparse table that will process the queries themselves the minimum value of among vertices such that belongs to blocked subtree of some vertex with index included in This table can be built backwards with the help of auxiliary tables So how do we answer the queries We need to look at the binary representation of and do something like binary lifting but descending the tree instead of ascending and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in and make queries to on the segment between these two vertices This solution works in but unfortunately or fortunately to some participants we made the time limit too high so the structures that require time to process each query such as two dimensional segment trees might also get AC 
https://codeforces.com//contest/1692/problem/E,1429119,E,1692E,1692,E. Binary Deque,Slavic has an array of length n consisting only of zeroes and ones In one operation he removes either the first or the last element of the array What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to s after performing all the operations In case the sum s can t be obtained after any amount of operations you should output ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""E""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, s;\n        cin >> n >> s;\n        vector<int> a(n);\n        cin >> a;\n        if (accumulate(all(a), 0) < s) {\n            cout << ""-1\\n"";\n            continue;\n        }\n        vector<int> pref(n + 1, 0);\n        for (int i = 0; i < n; ++i)\n            pref[i + 1] = pref[i] + a[i];\n        int ans = n;\n        for (int i = 0; i < n; ++i) {\n            if (pref[n] - pref[i] < s) break;\n            int j = upper_bound(all(pref), pref[i] + s) - pref.begin();\n            ans = min(ans, i + n - j + 1);\n        }\n        cout << ans << endl;\n    }\n}']",,,"['binary search', 'implementation', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\E. Binary Deque.json,https://codeforces.com//blog/entry/103883,Note that the remaining array is a subarray of the original array There are many ways to approach the problem Here is one solution which the main solution uses Compute prefix sums on the array so we can find out the value of quickly Let s iterate through the left endpoint from to Afterwards we can binary search on the smallest value of such that since this sum is strictly increasing The time complexity is 
https://codeforces.com//contest/1418/problem/D,727426,D,1418D,1418,D. Trash Problem,Vova decided to clean his room The room can be represented as the coordinate axis OX There are n piles of trash in the room coordinate of the i th pile is the integer p i All piles have coordinates Let s define a as the following process The goal of this process is to collect the piles in different x coordinates To achieve this goal Vova can do several possibly zero moves During one move he can choose some x and move from x to x 1 or x 1 using his broom Note that he can t choose how many piles he will move Also there are two types of queries 0 x remove a pile of trash from the coordinate x It is guaranteed that there is a pile in the coordinate x at this moment 1 x add a pile of trash to the coordinate x It is guaranteed that there is no pile in the coordinate x at this moment Note that it is possible that there are zero piles of trash in the room at some moment Vova wants to know the number of moves he can spend if he wants to do a before any queries He also wants to know this number of moves after applying each query Queries are applied in the given order Note that the doesn t actually happen and doesn t change the state of piles It is only used to calculate the number of moves For better understanding please read the section below to see an explanation for the first example ,"['#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar(\'-\'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nconst int N=100005;\nint n,q;\nset<int>S;\nmultiset<int>T;\nvoid insert(int x){\n\tauto it=S.insert(x).fi;\n\tauto pre=it,nxt=it;\n\tif(it!=S.begin())--pre;\n\tif(it!=--S.end())++nxt;\n\tif(it!=S.begin()){\n\t\tT.insert(*it-*pre);\n\t}\n\tif(it!=--S.end()){\n\t\tT.insert(*nxt-*it);\n\t}\n\tif(it!=S.begin()&&it!=--S.end()){\n\t\tT.erase(T.find(*nxt-*pre));\n\t}\n}\nvoid erase(int x){\n\tauto it=S.lower_bound(x);\n\tauto pre=it,nxt=it;\n\tif(it!=S.begin())--pre;\n\tif(it!=--S.end())++nxt;\n\tif(it!=S.begin()){\n\t\tT.erase(T.find(*it-*pre));\n\t}\n\tif(it!=--S.end()){\n\t\tT.erase(T.find(*nxt-*it));\n\t}\n\tif(it!=S.begin()&&it!=--S.end()){\n\t\tT.insert(*nxt-*pre);\n\t}\n\tS.erase(it);\n}\nsigned main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\trd(n),rd(q);\n\trep(i,1,n){\n\t\tint x;rd(x);\n\t\tinsert(x);\n\t}\n\trep(_,0,q){\n\t\tif(_){\n\t\t\tint o,x;rd(o),rd(x);\n\t\t\tif(o==0){\n\t\t\t\terase(x);\n\t\t\t}else{\n\t\t\t\tinsert(x);\n\t\t\t}\n\t\t}\n\t\tif(SZ(S)<=2){\n\t\t\tputs(""0"");\n\t\t}else{\n\t\t\tpt(*--S.end()-*S.begin()-*--T.end(),\'\\n\');\n\t\t}\n\t}\n\treturn 0;\n}\n\n']",,,"['data structures', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Trash Problem.json,https://codeforces.com//blog/entry/82673,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is 
https://codeforces.com//contest/1617/problem/D1,1229933,D1,1617D1,1617,D1. Too Many Impostors  easy version ,There are n players labelled from 1 to n Among them there are k impostors and n k crewmates The number of impostors k is not given to you In each question you can choose three distinct integers a b c 1 le a b c le n and ask Among the players labelled a b and c are there more impostors or more crewmates You will be given the integer 0 if there are more impostors than crewmates and 1 otherwise Find the number of impostors k and the indices of players that are impostors after asking at most 2n questions The jury is which means the indices of impostors may not be fixed beforehand and can depend on your questions It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint query(int a, int b, int c) {\n\tcout << ""? "" << a << "" "" << b << "" "" << c << endl;\n\tint res;\n\tcin >> res;\n\treturn res;\n}\nvoid answer(vector<int>& v) {\n\tcout << ""! "" << v.size();\n\tfor (int x : v) cout << "" "" << x;\n\tcout << endl;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> v(n + 1);\n\t\tfor (int i = 1; i + 2 <= n; i += 1)\n\t\t\tv[i] = query(i, i + 1, i + 2);\n\t\tint a = -1, b = -1;\n\t\tfor (int i = 2; i + 2 <= n; i += 1)\n\t\t\tif (v[i] != v[i - 1]) {\n\t\t\t\ta = i - 1;\n\t\t\t\tb = i + 2;\n\t\t\t}\n\t\tassert(a != -1);\n\t\tvector<int> im, cr;\n\t\tfor (int i = 1; i <= n; i += 1) if (i != a and i != b) {\n\t\t\tif (query(a, b, i)) cr.push_back(i);\n\t\t\telse im.push_back(i);\n\t\t}\n\t\tif (query(im[0], cr[0], a)) im.push_back(b);\n\t\telse im.push_back(a);\n\t\tanswer(im);\n\t}\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'implementation', 'interactive']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D1. Too Many Impostors  easy version .json,https://codeforces.com//blog/entry/97920,Key observation if result of query result of query since and are common players and have different roles Additionally if result of query then player is a crewmate and player is an impostor vice versa The first step is to query players If the results of any two adjacent queries or queries and are different we instantly know the roles of the two players that are only included in one query one is a crewmate one is an impostor Since the number of impostors and crewmates satisfy and there must be one pair of adjacent queries that are different After we know one crewmate and one impostor let s call them we can query these two players with each one of the rest of the players If a query and returns player is an impostor else player is a crewmate In total queries are used 
https://codeforces.com//contest/1472/problem/E,854355,E,1472E,1472,E. Correct Placement,Polycarp has invited n friends to celebrate the New Year During the celebration he decided to take a group photo of all his friends Each friend can stand or lie on the side Each friend is characterized by two values h i their height and w i their width On the photo the i th friend will occupy a rectangle h i times w i if they are standing or w i times h i if they are lying on the side The j th friend can be placed in front of the i th friend on the photo if his rectangle is lower and narrower than the rectangle of the i th friend Formally of the following conditions must be fulfilled h j h i w j w i both friends are standing or both are lying w j h i h j w i one of the friends is standing and the other is lying For example if n 3 h 3 5 3 and w 4 4 3 then the first friend can be placed in front of the second w 1 h 2 and h 1 w 2 one of the them is standing and the other one is lying the third friend can be placed in front of the second h 3 h 2 and w 3 w 2 both friends are standing or both are lying In other cases the person in the foreground will overlap the person in the background Help Polycarp for each i find any j such that the j th friend can be located in front of the i th friend i e at least one of the conditions above is fulfilled Please note that you do not need to find the arrangement of all people for a group photo You just need to find for each friend i any other friend j who can be located in front of him Think about it as you need to solve n separate independent subproblems ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nint a[N_MAX], b[N_MAX];\n\nvector <int> v;\n\nmap <int, int> mp;\n\npair <int, int> BIT[2 * N_MAX];\n\nvoid update (int pos, int val, int x)\n{\n    for(int i = pos; i <= 2 * n; i += i & -i)\n        BIT[i] = min(BIT[i], make_pair(val, x));\n}\n\npair <int, int> query (int pos)\n{\n    pair <int, int> ans = make_pair(INT_MAX, 0);\n    for(int i = pos; i >= 1; i -= i & -i)\n        ans = min(ans, BIT[i]);\n    return ans;\n}\n\npair <int, int> ans1[N_MAX], ans2[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        v.clear();\n        mp.clear();\n        for(int i = 1; i <= n; i++)\n        {\n            cin >> a[i] >> b[i];\n            v.push_back(a[i]);\n            v.push_back(b[i]);\n            ans1[i] = ans2[i] = make_pair(INT_MAX, 0);\n        }\n        sort(v.begin(), v.end());\n        int curr = 0;\n        for(int i = 0; i < (int)v.size(); i++)\n        {\n            if(i == 0 || v[i] > v[i - 1])\n                curr++;\n            mp[v[i]] = curr;\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            a[i] = mp[a[i]];\n            b[i] = mp[b[i]];\n        }\n        for(int i = 1; i <= 2 * n; i++)\n            BIT[i] = make_pair(INT_MAX, 0);\n        for(int i = 1; i <= n; i++)\n        {\n            ans1[i] = min(ans1[i], query(a[i]));\n            ans2[i] = min(ans2[i], query(b[i]));\n            update(a[i] + 1, b[i], i);\n        }\n        for(int i = 1; i <= 2 * n; i++)\n            BIT[i] = make_pair(INT_MAX, 0);\n        for(int i = n; i >= 1; i--)\n        {\n            ans1[i] = min(ans1[i], query(a[i]));\n            ans2[i] = min(ans2[i], query(b[i]));\n            update(a[i] + 1, b[i], i);\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            if(ans1[i].first < b[i])\n                cout << ans1[i].second << "" "";\n            else if(ans2[i].first < a[i])\n                cout << ans2[i].second << "" "";\n            else\n                cout << ""-1 "";\n        }\n        cout << ""\\n"";\n    }\n    return 0;\n}\n']",,,"['binary search', 'data structures', 'dp', 'sortings', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Correct Placement.json,https://codeforces.com//blog/entry/86406,Let s sort all people by their height in descending order Now let s go through all the people and look for the position of the person in the sorted array the height of which is strictly less than ours for example by binary search Obviously only those people who are in the sorted array later than the found person can stand in front of us all of them have a height strictly less than ours Among all these people it is more profitable for us to take a person with minimum width In order to find such a person quickly we can find a person with the minimum width for each suffix of the sorted array To handle a situation where a person is lying down we need to swap the width and height and repeat the algorithm above 
https://codeforces.com//contest/966/problem/A,179475,A,966A,966,A. Stairs and Elevators,In the year of 30XX participants of some world programming championship live in a single large hotel The hotel has n floors Each floor has m sections with a single corridor connecting all of them The sections are enumerated from 1 to m along the corridor and all sections with equal numbers on different floors are located exactly one above the other Thus the hotel can be represented as a rectangle of height n and width m We can denote sections with pairs of integers i j where i is the floor and j is the section number on the floor The guests can walk along the corridor on each floor use stairs and elevators Each stairs or elevator occupies all sections 1 x 2 x ldots n x for some x between 1 and m All sections not occupied with stairs or elevators contain guest rooms It takes one time unit to move between neighboring sections on the same floor or to move one floor up or down using stairs It takes one time unit to move up to v floors in any direction using an elevator You can assume you don t have to wait for an elevator and the time needed to enter or exit an elevator is negligible You are to process q queries Each query is a question what is the minimum time needed to go from a room in section x 1 y 1 to a room in section x 2 y 2 ,"['#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,m,q,na,nb,a[100010],b[100010],v,p;\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,sx,sy,tx,ty;\n\tscanf(""%d%d%d%d%d"",&n,&m,&na,&nb,&v);\n\tfor(i=1;i<=na;i++)\n\t  scanf(""%d"",&a[i]);\n\tfor(i=1;i<=nb;i++)\n\t  scanf(""%d"",&b[i]);\n\tsort(a+1,a+na+1);\n\tsort(b+1,b+nb+1);\n\tscanf(""%d"",&q);\n\twhile(q--)\n\t  {\n       scanf(""%d%d%d%d"",&sx,&sy,&tx,&ty);\n       p=1e9;\n       if(na)\n         {\n          i=lower_bound(a+1,a+na+1,sy)-a;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n          i--;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n         }\n       if(nb)\n         {\n          i=lower_bound(b+1,b+nb+1,sy)-b;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n          i--;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n         }\n       if(sx==tx)\n         p=abs(ty-sy);\n       printf(""%d\\n"",p);\n      }\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Stairs and Elevators.json,https://codeforces.com//blog/entry/59173,First thing to mention is that we can use no more than one stairs or elevator per query Indeed optimal path is always a few sections horizontally then a stair of elevator then a few sections horizontally Then we can note that we can always use one of the nearest stairs elevators to start finish Using this fact we can binary search in the sequence of stairs elevators to find the optimal one and choose the optimum between using a stairs and an elevator Don t forget about the case where you don t have to reach any stairs elevators 
https://codeforces.com//contest/837/problem/D,116710,D,837D,837,D. Round Subset,Let s call the of the number the number of zeros to which it ends You have an array of numbers You need to choose a subset of exactly numbers so that the of the product of the selected numbers will be maximum possible ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nint dp[205][8010];\nint tdp[205][8010];\nint in[205][2];\nint main() {\n\tint N, K, i, j, k;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tll t;\n\t\tscanf(""%lld"", &t);\n\t\twhile (t % 2 == 0) {\n\t\t\tin[i][0]++;\n\t\t\tt /= 2;\n\t\t}\n\t\twhile (t % 5 == 0) {\n\t\t\tin[i][1]++;\n\t\t\tt /= 5;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) tdp[j][k] = dp[j][k];\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tfor (k = 0; k <= 8000; k++) {\n\t\t\t\tint j2 = j + 1, k2 = k + in[i][1];\n\t\t\t\tif (k2 <= 8000) tdp[j2][k2] = max(tdp[j2][k2], dp[j][k] + in[i][0]);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) dp[j][k] = tdp[j][k];\n\t}\n\n\tint ans = 0;\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) ans = max(ans, min(j, dp[i][j]));\n\treturn !printf(""%d\\n"", ans);\n}']",,,"['dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Round Subset.json,https://codeforces.com//blog/entry/53662,Let s use dynamic programming to solve this task Obviously the of the number is determined by minimum of powers of and in the number Let be the maximal power of in the number and be the maximal power of Let be the maximum amount of twos we can collect by checking first numbers taking of them with total power of five equal to It is usually called the knapsack problem There are two types of transitions You can either take current element or skip it The answer will be maximum of for every Also keeping this many states can cause ML the first dimension should be stored in two layers and recalced on the fly Overall complexity 
https://codeforces.com//contest/676/problem/E,60900,E,676E,676,E. The Last Fight Between Human and AI,100 years have passed since the last victory of the man versus computer in Go Technologies made a huge step forward and robots conquered the Earth It s time for the final fight between human and robot that will decide the faith of the planet The following game was chosen for the fights initially there is a polynomial with yet undefined coefficients and the integer Players alternate their turns At each turn a player pick some index such that coefficient that stay near is not determined yet and sets it to value integer or real positive or negative is also allowed Computer moves first The human will be declared the winner if and only if the resulting polynomial will be divisible by Polynomial is said to be divisible by polynomial if there exists a representation where is also some polynomial Some moves have been made already and now you wonder is it true that human can guarantee the victory if he plays optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nstring Coef[200000];\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, k;\n\tcin >> n >> k;\n\n\tint countQuest = 0;\n\n\tfor(int i = 0; i <= n; ++i) {\n\t\tcin >> Coef[i];\n\t\tcountQuest += (Coef[i] == ""?"");\n\t}\n\n\tif(k == 0) {\n\t\tif(Coef[0] == ""?"") {\n\t\t\tif((n + 1 - countQuest) % 2) {\n\t\t\t\tcout << ""Yes"";\n\t\t\t} else {\n\t\t\t\tcout << ""No"";\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif(Coef[0] == ""0"") {\n\t\t\t\tcout << ""Yes"";\n\t\t\t} else {\n\t\t\t\tcout << ""No"";\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i <= n; ++i) {\n\t\tif(Coef[i] == ""?"") {\n\t\t\tcout << ((n % 2) ? ""Yes\\n"" : ""No\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsrand(time(0));\n\tvector<int> mods;\n\tfor(int i = 0; i < 10; ++i) {\n\t\tmods.push_back(rand() % 500000 + 500000);\n\t}\n\n\tvector<int> Ans(mods.size(), 0);\n\tfor(int i = n; i >= 0; --i) {\n\t\tint num = stoi(Coef[i]);\n\n\t\tfor(int i = 0; i < mods.size(); ++i) {\n\t\t\tAns[i] = (1LL * Ans[i] * k + num) % mods[i];\n\t\t}\n\t}\n\n\tfor(auto x : Ans) {\n\t\tif(x != 0) {\n\t\t\tcout << ""No\\n"";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << ""Yes\\n"";\n\treturn 0;\n}\n']",,,['math'],2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The Last Fight Between Human and AI.json,https://codeforces.com/blog/entry/45018,In this problem we have two main cases Case when Then the division of the polynomial to the depends only of the value of If is already known then we need to compare it with zero If then the human wins otherwise the human loses If is not known then win who make the move Case when Here we have two cases all coefficients already known Then we need to check is it the root of the given polynomial Otherwise who will make the last move will win Let we know all coefficient except one Let this coefficient is the coefficient before Let is the sum for all and Then we have the equation which always have the solution If the human will make the last move he need to write the root to the place of the coefficient otherwise computer will write any number but not the root Asymptotic behavior 
https://codeforces.com//contest/757/problem/A,88528,A,757A,757,A. Gotta Catch Em' All ,Bash wants to become a Pokemon master one day Although he liked a lot of Pokemon he has always been fascinated by Bulbasaur the most Soon things started getting serious and his fascination turned into an obsession Since he is too young to go out and catch Bulbasaur he came up with his own way of catching a Bulbasaur Each day he takes the front page of the newspaper He cuts out the letters one at a time from anywhere on the front page of the newspaper to form the word without quotes and sticks it on his wall Bash is very particular about case the first letter of must be upper case and the rest must be lower case By doing this he thinks he has caught one Bulbasaur He then repeats this step on the left over part of the newspaper He keeps doing this until it is not possible to form the word from the newspaper Given the text on the front page of the newspaper can you tell how many Bulbasaurs he will catch today Note ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string s = ""Bulbasaur"";\n\nconst int N = 1234567;\n\nchar foo[N];\n\nint cnt[N];\n\nint main() {\n  scanf(""%s"", foo);\n  for (int j = 0; j < 256; j++) {\n    cnt[j] = 0;\n  }\n  for (int i = 0; foo[i]; i++) {\n    cnt[foo[i]]++;\n  }\n  int ans = 0;\n  while (true) {\n    bool ok = true;\n    for (int k = 0; k < (int) s.length(); k++) {\n      if (cnt[s[k]] <= 0) {\n        ok = false;\n        break;\n      }\n      cnt[s[k]]--;\n    }\n    if (!ok) {\n      break;\n    }\n    ans++;\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. Gotta Catch Em' All .json,https://codeforces.com//blog/entry/49743,Since we are allowed to permute the string in any order to find the maximum occurences of the string Bulbasaur we simply keep the count of the letters B u l b a s r Now the string Bulbasaur contains 1 B 2 u 1 l 2 a 1 s 1 r and 1 b thus the answer to the problem is Min count B count b count s count r count l count a 2 count u 2 You can maintain the counts using an array 
https://codeforces.com//contest/1800/problem/G,1805850,G,1800G,1800,G. Symmetree,Kid was gifted a tree of n vertices with the root in the vertex 1 Since he really like objects Kid wants to find out if this tree is Formally a tree is if there exists an order of children such that The subtree of the leftmost child of the root is a mirror image of the subtree of the rightmost child the subtree of the second left child of the root is a mirror image of the subtree of the second right child of the root if the number of children of the root is odd then the subtree of the middle child should be ,"['// I am teacher of MakaPakka\n// LOUGI_ID:643723\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(x,y) for(int x=0;x<(y);x++)\ninline int in(){\n  int x;\n  cin >> x;\n  return x;\n}\nconst int N=2e5;\nint n,dt[N+5],h_val[N+5];\nvector<int> g[N+5];\nvoid get_depth(int v,int p=-1){\n  for(int u:g[v])if(u!=p){\n    dt[u]=dt[v]+1;\n    get_depth(u,v);\n  }\n}\nint timer=0;\nmap<vector<int>,int> hsh;\nvoid get_hash(int v,int p=-1){\n  vector<int> c={dt[v]};\n  for(int u:g[v])if(u!=p){\n    get_hash(u,v);\n    c.push_back(h_val[u]);\n  }\n  if(int(c.size())>1)sort(c.begin()+1,c.end());\n  if(hsh.count(c))h_val[v]=hsh[c];\n  else{\n    hsh[c]=timer,h_val[v]=timer;\n    timer++;\n  }\n}\nbool test(int v,int p=-1){\n  vector<array<int,2>> c;\n  for(int u:g[v])if(u!=p){\n    c.pb({h_val[u],u});\n  }\n  sort(c.begin(), c.end());\n  for(int i=0;i+1<int(c.size());i++){\n    if(c[i][0]==c[i+1][0]){\n      c[i]=c[i+1]={-1,-1};\n      i++;continue;\n    }\n  }\n  int badcnt=0,bad=-1;\n  for(int i=0;i<int(c.size());i++){\n    if(c[i]!=array<int,2>({-1,-1}))badcnt++,bad=c[i][1];\n  }\n  if(badcnt>1)return false;\n  else if(badcnt==0)return true;\n  else return test(bad,v);\n  return true;\n}\nvoid solve(){\n  n=in();\n  timer=0,hsh.clear();\n  rep(i,n+5)g[i].clear(),h_val[i]=dt[i]=0;\n  rep(i,n-1){\n    int x=in()-1,y=in()-1;\n    g[x].pb(y),g[y].pb(x);\n  }\n  get_depth(0);\n  get_hash(0);\n  cout<<(test(0)?""YES\\n"":""NO\\n"");\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while(T--) solve();\n}']",,,"['dfs and similar', 'hashing', 'implementation', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Symmetree.json,https://codeforces.com//blog/entry/113477,Note that if one subtree is a mirror image of another then they are isomorphic that is equal without taking into account the vertex numbers To check the subtrees for isomorphism we use Now we just have to learn how to check trees for symmetry To do this let s calculate how many children of each type our vertex has let s denote the hash of its subtree by the vertex type In order for the vertex subtree to be symmetric each child must have a pair of the same type except perhaps one which must also be symmetric We can calculate the symmetry of the subtrees while counting their hash to simplify this task 
https://codeforces.com//contest/1782/problem/E,1738311,E,1782E,1782,E. Rectangle Shrinking,You have a rectangular grid of height 2 and width 10 9 consisting of unit cells There are n rectangles placed on this grid and the borders of these rectangles pass along cell borders The i th rectangle covers all cells in rows from u i to d i inclusive and columns from l i to r i inclusive 1 le u i le d i le 2 1 le l i le r i le 10 9 The initial rectangles can intersect be nested and coincide arbitrarily You should either remove each rectangle or replace it with any of its non empty subrectangles In the latter case the new subrectangle must lie inside the initial rectangle and its borders must still pass along cell borders In particular it is allowed for the subrectangle to be equal to the initial rectangle After that replacement no two non removed rectangles are allowed to have common cells and the total area covered with the new rectangles must be as large as possible ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, u[N], d[N], l[N], r[N]; \nbool vis[N];\nvector < int > S[3];\nvoid solve(vi &a, int rp = -1) {\n\tsort(a.begin(), a.end(), [&] (int x, int y) {\n\t\treturn r[x] == r[y] ? l[x] > l[y] : r[x] < r[y];\n\t});\n\tvi b;\n\tfor(auto x : a) {\n\t\twhile(sz(b) && l[b.back()] >= l[x]) {\n\t\t\tif(rp == -1) vis[b.back()] = false;\n\t\t\telse if(rp == 0) ++u[b.back()];\n\t\t\telse assert(rp == 1), --d[b.back()];\n\t\t\tb.pop_back();\n\t\t} \n\t\tif(sz(b) && r[b.back()] >= l[x]) {\n\t\t\tint y = b.back();\n\t\t\tint lenx = d[x] - u[x] + 1;\n\t\t\tint leny = d[y] - u[y] + 1;\n\t\t\tif(leny <= lenx) r[y] = l[x] - 1;\n\t\t\telse l[x] = r[y] + 1;\n\t\t}\n\t\tb.emplace_back(x); \n\t}\n\ta = b;\n}\nvoid Main() {\n\tcin >> n;\n\tS[0].clear();\n\tS[1].clear();\n\tS[2].clear();\n\tL(i, 1, n) {\n\t\tcin >> u[i] >> l[i] >> d[i] >> r[i];\n\t\tvis[i] = true;\n\t\tint op = -1;\n\t\tif(u[i] == 1 && d[i] == 1) op = 0;\n\t\tif(u[i] == 2 && d[i] == 2) op = 1;\n\t\tif(u[i] == 1 && d[i] == 2) op = 2;\n\t\tassert(op != -1);\n\t\tS[op].emplace_back(i);\n\t} \n\tL(i, 0, 2) solve(S[i]);\n\tfor(auto u : S[2]) L(i, 0, 1) S[i].emplace_back(u);\n\tL(i, 0, 1) solve(S[i], i);\n\t\n\tint sumsz = 0;\n\tL(i, 1, n) if(vis[i]) {\n\t\tint siz = (d[i] - u[i] + 1) * (r[i] - l[i] + 1);\n\t\tif(siz < 0) {\n\t\t\tcout << ""jingya\\n"";\n\t\t\tassert(false);\n\t\t}\n\t\tif(!siz) vis[i] = false;\n\t\tsumsz += siz;\n\t}\n\tcout << sumsz << \'\\n\';\n\tL(i, 1, n) \n\t\tif(vis[i]) cout << u[i] << \' \' << l[i] << \' \' << d[i] << \' \' << r[i] << \'\\n\';\n\t\telse cout << 0 << \' \' << 0 << \' \' << 0 << \' \' << 0 << \'\\n\';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ']",,,"['brute force', 'data structures', 'greedy', 'implementation', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Rectangle Shrinking.json,https://codeforces.com//blog/entry/111783,It turns out that it is always possible to cover all cells that are covered by the initial rectangles If the grid had height instead of the solution would be fairly simple Sort the rectangles in non decreasing order of their left border Maintain a variable denoting the rightmost covered cell Then for each rectangle in order If remove this rectangle note that since we process the rectangles in non decreasing order of it means that this rectangle is fully covered by other rectangles Otherwise if set shrink the current rectangle Then set this is the new rightmost covered cell Let s generalize this approach for a height grid Again sort the rectangles in non decreasing order of and maintain two variables and denoting the rightmost covered cell in row and row respectively Then for each rectangle in order If it is a height rectangle that is proceed similarly to the height grid case above If remove this rectangle Otherwise if set Then set If it is a height rectangle that is and If set remove the first row from the rectangle and go back to the height rectangle case above If set remove the second row from the rectangle and go back to the height rectangle case above Otherwise consider all rectangles that have i e intersect the th rectangle If remove rectangle otherwise shrink rectangle by setting Finally set Here only the last case is tricky and different from our initial height grid solution but it is also necessary in a height grid sometimes we have to shrink rectangles on the right not only on the left Now if we implement this solution in a straightforward fashion iterating over all for every we ll arrive at an solution again purely because of the last case To optimize it note that once a rectangle is shrinked in this last case it never has to be shrinked again Thus we can maintain all rectangles in a priority queue ordered by their and once we pop a rectangle from the priority queue we will never have to push it again which will help us arrive at an amortized solution Instead of a priority queue we can use some stacks as well one for each row and maybe an extra one for height rectangles The overall time complexity will still be due to sorting 
https://codeforces.com//contest/746/problem/C,85371,C,746C,746,C. Tram,The tram in Berland goes along a straight line from the point to the point and back passing meter per seconds in both directions It means that the tram is always in the state of uniform rectilinear motion instantly turning around at points and Igor is at the point He should reach the point Igor passes meter per seconds Your task is to determine the minimum time Igor needs to get from the point to the point if it is known where the tram is and in what direction it goes at the moment Igor comes to the point Igor can enter the tram unlimited number of times at any moment when his and the tram s positions coincide It is that points in which Igor enter and exit the tram are integers Assume that any boarding and unboarding happens instantly Igor can move arbitrary along the line but not faster than meter per seconds He can also stand at some point for some time ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)301*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll t1,t2,s;\n\npair<ll,ll> calc(ll p,ll x1,ll d)\n{\n\tll first;\n\tif((x1>=p && d==1) || (x1<=p && d==-1))first=abs(x1-p)*t1;\n    else\n    {\n    \tif(d==-1)first=p*t1+x1*t1,d=1;\n    \telse first=(s-p)*t1+(s-x1)*t1,d=-1;\n\t}\n\treturn {first,d};\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    ll x1,x2,p,d;\n    cin>>s>>x1>>x2;\n    cin>>t1>>t2;\n    cin>>p>>d;\n    ll ans=abs(x1-x2)*t2;\n    ll first=calc(p,x1,d).first;\n    d=calc(p,x1,d).second;\n\tll second=calc(x1,x2,d).first;\n\tcout<<min(ans,first+second);\n    return 0;\n}']",,,"['constructive algorithms', 'implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Tram.json,https://codeforces.com//blog/entry/49160,It is easy to show that if Igor faster than the tram the answer is In the other case we need to use the following hint the time of arrive does not depend on how much Igor walk before enter the tram if the tram will reach the finish point faster than Igor So Igor can wait the tram in the point The answer is minimum of the following values the time during which Igor will reach the point by foot and the time during which the tram will reach at first the point and than the point 
https://codeforces.com//contest/1693/problem/B,1430889,B,1693B,1693,B. Fake Plastic Trees,We are given a rooted tree consisting of n vertices numbered from 1 to n The root of the tree is the vertex 1 and the parent of the vertex v is p v There is a number written on each vertex initially all numbers are equal to 0 Let s denote the number written on the vertex v as a v For each v we want a v to be between l v and r v l v leq a v leq r v In a single operation we do the following Choose some vertex v Let b 1 b 2 ldots b k be vertices on the path from the vertex 1 to vertex v meaning b 1 1 b k v and b i p b i 1 Choose a non decreasing array c of length k of nonnegative integers 0 leq c 1 leq c 2 leq ldots leq c k For each i 1 leq i leq k increase a b i by c i What s the minimum number of operations needed to achieve our goal ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint oj[nax];\nll dol[nax];\nll gor[nax];\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""Yes\\n"");\n\telse\n\t\tprintf(""No\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=0;\n\tfor (int i=2; i<=n; i++)\n\t\tscanf(""%d"", &oj[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld%lld"", &dol[i], &gor[i]);\n\tint wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]<dol[i])\n\t\t{\n\t\t\twyn++;\n\t\t\ttab[i]=gor[i];\n\t\t}\n\t\ttab[oj[i]]+=min(gor[i], tab[i]);\n\t}\n\tprintf(""%d\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dp', 'greedy', 'trees']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Fake Plastic Trees.json,https://codeforces.com//blog/entry/103952,Lemma 1 You won t perform the operation on a particular vertex more than once Because you could merge the operations Lemma 2 If you perform the operation on some vertex you can do it with If there is another operation that helps this vertex you can cut the operation into two pieces and merge one with the operation that starts at And you can just increase if it s not equal to Define as the minimum number of operations needed to satisfy the conditions on the vertices in the subtree of vertex We claim that there is a way to achieve our goal with minimum number of operations in which for each vertex there are exactly operations done in the subtree of vertex Imagine there is a vertex that there are more than operations on vertices in the subtree of vertex We can instead satisfy the subtree by operations and make sure that we perform the operation on vertex Denote as the maximum value that vertex can pass to its ancestors if exactly operations are performed in the subtree of vertex We need to perform the operation on a vertex if and only if If we need to perform the operation on vertex then otherwise Time complexity 
https://codeforces.com//contest/1497/problem/E1,925009,E1,1497E1,1497,E1. Square-Free Division  easy version ,There is an array a 1 a 2 ldots a n of n positive integers You should divide it into a minimal number of continuous segments such that in each segment there are no two numbers on different positions whose product is a perfect square Moreover it is allowed to do at most k such operations before the division choose a number in the array and change its value to any positive integer But in this version k 0 so it is not important What is the minimum number of continuous segments you should use if you will make changes optimally ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    vector<int> h(1e7 + 5);\n    vector<int> e(1e7 + 5, 1);\n    vector<int> minD(1e7 + 5, -1);\n    minD[1] = 1;\n    for (ll i = 2; i < 1e7 + 5; ++i) {\n        if (e[i]) {\n            minD[i] = i;\n            for (ll j = i; j * i < 1e7 + 5; ++j) {\n                e[i * j] = 0;\n                if (minD[i * j] == -1) {\n                    minD[i * j] = i;\n                } else {\n                    minD[i * j] = min(minD[i * j], (int)i);\n                }\n\n            }\n        }\n    }\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            int ans = 1;\n            map<int, int> cnt;\n            while (minD[a[i]] != 1) {\n                ++cnt[minD[a[i]]];\n                a[i] /= minD[a[i]];\n            }\n            for (auto &elem : cnt) {\n                if (elem.se % 2) {\n                    ans *= elem.fi;\n                }\n            }\n            a[i] = ans;\n        }\n        vector<vector<int>> sameSegment(k + 1, vector<int>(n));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) h[a[j]] = 0;\n            int l = 0, cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                ++h[a[j]];\n                if (h[a[j]] > 1) {\n                    ++cnt;\n                }\n                while (cnt > i) {\n                    if (h[a[l]] > 1) {\n                        --cnt;\n                    }\n                    --h[a[l]];\n                    ++l;\n                }\n                sameSegment[i][j] = l;\n            }\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(n, 1e9));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int z = 0; z <= i; ++z) {\n                    int ans = 1;\n                    if (sameSegment[i - z][j] - 1 != -1) {\n                        ans += dp[z][sameSegment[i - z][j] - 1];\n                    }\n                    dp[i][j] = min(dp[i][j], ans);\n                }\n            }\n        }\n        int res = 1e9;\n        for (int j = 0; j <= k; ++j) {\n            res = min(res, dp[j][n - 1]);\n        }\n        cout << res << \'\\n\';\n    }\n}\n/*\n*/\n']",,,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Square-Free Division  easy version .json,https://codeforces.com//blog/entry/88677,For factorization of let s define After that it is easy to see that is a perfect square if and only if Now let s say for all The problem we need to solve is split the array into minimal amount of non intersecting subsegments so that on each subsegment all numbers are different Since we can do that using a greedy idea If we consider an element that has not been in our current segment then we add it to the segment If it s already taken then we should end our current segment and start a new one 
https://codeforces.com//contest/1133/problem/C,308946,C,1133C,1133,C. Balanced Team,You are a coach at your local university There are n students under your supervision the programming skill of the i th student is a i You have to create a team for a new programming competition As you know the more students some team has the more probable its victory is So you have to create a team with the maximum number of students But you also know that a team should be It means that the programming skill of each pair of students in a created team should differ by no more than 5 Your task is to report the maximum possible number of students in a team ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define INF 9223372036854775807\n#define M_PI 3.14159265358979323846\n\nint mod = INF;\n\nint fastPow(int b, int e){int r = 1;while(e){if(e%2 == 1){r*=b;r%=mod;}b*=b;b%=mod;e/=2;}return r;}\nint pgcd(int a, int b){ if(a%b == 0) return b; else return pgcd(b, a%b);}\nint sign(int a){if(a < 0){ return -1;}if(a == 0) {return 0;}return 1;}\nbool isPrime(int a){if(a == 1) {return false;}int f = sqrt(a);for(int i = 2; i<=f; i++){if(a%i == 0){return false;}}return true;}\nint toInt(string s){int tot = 0;for(int i = s.size()-1; i >= 0; i--){tot+=((s[i]-\'0\')%mod)*fastPow(10,i);tot%=mod;}return tot;}\nstring toString(int a){string s = """";while(a){s = (char)(\'0\'+a%10) + s;a/=10;}return s;}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for(int i = 0; i < n; i++){\n        cin >> v[i];\n    }\n    sort(v.begin(), v.end());\n    int ans = 1;\n\n    for(int i = 0; i < n; i++){\n        int l = lower_bound(v.begin(), v.end(), v[i]-5)-v.begin();\n        int r = i;\n        if(l > r) continue;\n        ans = max(ans, r-l+1);\n    }\n\n    cout << ans << endl;\n}\n']",,,"['sortings', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Balanced Team.json,https://codeforces.com//blog/entry/65807,Let s sort all values in non decreasing order Then we can use two pointers to calculate for each student the maximum number of students such that This is pretty standard approach We also can use binary search to do it or we can store for each programming skill the number of students with this skill and just iterate from some skill to and sum up all numbers of students 
https://codeforces.com//contest/1557/problem/E,1072436,E,1557E,1557,E. Assiut Chess,ICPC Assiut Community decided to hold a unique chess contest and you were chosen to control a queen and hunt down the hidden king while a member of ICPC Assiut Community controls this king You compete on an 8 times8 chessboard the rows are numerated from top to bottom and the columns are numerated left to right and the cell in row x and column y is denoted as x y In one turn you can move the queen to any of the squares on the same horizontal line vertical line or any of the diagonals For example if the queen was on square 4 5 you can move to q 1 5 4 q 1 q 1 9 q 1 or q 2 q 2 1 where 1 le q 1 le 8 q 1 ne 4 1 le q 2 le 7 q 2 ne 4 Note that the queen stay on its current cell In one turn the king can move Right Left Up Down Down Right Down Left Up Left or Up Right such that he doesn t get out of the board The king move into a cell that is on the same row column or diagonal with the queen including the position of the queen itself For example if the king was on square 4 5 he can move to 4 k 1 5 k 2 where 1 le k 1 k 2 le 1 k 1 k 2 ne 0 0 At the start of the game you should place the queen at any location on the board and this is done once per game After that the king is secretly placed at any cell different from the queen s location You do not know the position of the king Then the king and the queen take turns with the king moving first The king moves to one of the possible directions Right Down Up Left etc and you are only given the direction it moves to After that you should move your queen by declaring the square to which your queen will move The game follows like this until you win the game or run out of moves You win if the king has no valid moves You lose if after 130 moves of the queen the king still has valid moves ,"['#include<bits/stdc++.h>\nusing namespace std;\nint cx,cy,is[10][10],cnt,F=0;\nstring res;\nvoid Move(int dx,int dy){\n\tint tmp[10][10]={0};\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)tmp[i+dx][j+dy]=is[i][j];\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=tmp[i][j];\n}\nvoid Make(int x,int y){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)if(i==x||j==y||i+j==x+y||i-j==x-y)is[i][j]=0;\n}\nvoid MoveKing(){\n\tcin>>res;\n\tif(res==""Left"")Move(0,-1);\n\tif(res==""Right"")Move(0,1);\n\tif(res==""Up"")Move(-1,0);\n\tif(res==""Down"")Move(1,0);\n\tif(res==""Down-Right"")Move(1,1);\n\tif(res==""Down-Left"")Move(1,-1);\n\tif(res==""Up-Right"")Move(-1,1);\n\tif(res==""Up-Left"")Move(-1,-1);\n\tif(res==""Done"")F=1;\n}\nvoid Min(int &x,int &y,int tox,int toy){\n\tint mn=1e9;\n\tfor(int i=1;i<=8;i++)\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tif(i==cx||j==cy||i+j==cx+cy||i-j==cx-cy){\n\t\t\t\tif(!(i==cx&&j==cy)){\n\t\t\t\t\tif(abs(i-tox)+abs(j-toy)<mn)mn=abs(i-tox)+abs(j-toy),x=i,y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nvoid Solve(){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=(i-1)*8+j;\n\tcx=1,cy=1,cnt=0,F=0;\n\tcout<<cx<<\' \'<<cy<<endl,cnt++,MoveKing();\n\tif(F)return ;\n\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<\' \';\n//\t\t\t\t}\n//\t\t\t\tputs("""");\n//\t\t\t}\n\twhile(1){\n\t\tint w=0;\n\t\tfor(int i=1;i<=8;i++){\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tif(is[i][j])w=is[i][j];\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint p=0,q=0;\n\t\t\tfor(int i=1;i<=8;i++){\n\t\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\t\tif(is[i][j]==w)p=i,q=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!p)break;\n\t\t\tint tx,ty;\n\t\t\tMin(tx,ty,p,q);\n\t\t\tcx=tx,cy=ty;\n\t\t\t//cout<<""w:""<<w<<endl;\n\t\t\tcout<<cx<<\' \'<<cy<<endl,cnt++,assert(cnt<=130),MoveKing();\n\t\t\tif(F)return ;\n\t\t\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<\' \';\n//\t\t\t\t}\n//\t\t\t\tputs("""");\n//\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--)Solve();\n}']",,,"['brute force', 'constructive algorithms', 'interactive']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Assiut Chess.json,https://codeforces.com//blog/entry/93703,SolutionThis is one of many possible solutions We need to force the king to move into one of the four corners bottom right or bottom left corner in this solution to ensure that the king will be trapped cannot move anymore Place the queen on the top row After the king makes a move he should be below the queen s row Suppose the queen is on the row with the king below it row where If we cannot move down to the next row as the king may move up and we will not be able to trap it Otherwise we can move down by one unit To ensure that the king is not on the next row scan the current row by moving the queen from the leftmost column to the rightmost column one square at a time Therefore you can move the queen as follows During the scan if you have visited all squares of the current row and the king never made a vertical or diagonal move it means that and you can go down by one row It is now guaranteed that the king is still below the queen If the king were on row he would have been forced to move square down at some point If he ever goes down move the queen down by one row If the king moves up start scanning the row again This can only happen a limited number of times without the king moving into a check In total the queen needs to apply step up to times At each row step needs to be applied so it takes moves Step also needs to be applied every time step is applied which can happen at most times In total that is moves 
https://codeforces.com//contest/1972/problem/A,2620242,A,1972A,1972,A. Contest Proposal,A contest contains n problems and the difficulty of the i th problem is expected to be b i There are already n problem proposals and the difficulty of the i th problem is a i Initially both a 1 a 2 ldots a n and b 1 b 2 ldots b n are sorted in non decreasing order Some of the problems may be more difficult than expected so the writers must propose more problems When a new problem with difficulty w is proposed the most difficult problem will be deleted from the contest and the problems will be sorted in a way that the difficulties are non decreasing In other words in each operation you choose an integer w insert it into the array a sort array a in non decreasing order and remove the last element from it Find the minimum number of new problems to make a i le b i for all i ,"['#include<bits/stdc++.h>using namespace std;\xa0#define int int64_t#define pb push_back#define pii pair<int, int>#define st first#define nd second#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()\xa0bool check(deque<int> &a, deque<int> &b) {\tfor(int i=0;i<sz(a);i++) {\t\tif(a[i]>b[i]) return false;\t}\treturn true;}\xa0int32_t main() {\tios_base::sync_with_stdio(false);\tcin.tie(NULL);\t\tint t=1;\tcin >> t;\twhile(t--) {\t\tint n;\t\tcin >> n;\t\tdeque<int> a(n);\t\tdeque<int> b(n);\t\tfor(int i=0;i<n;i++) {\t\t\tcin >> a[i];\t\t}\t\tfor(int j=0;j<n;j++) {\t\t\tcin >> b[j];\t\t}\t\tif(check(a, b)) {\t\t\tcout << ""0\\n"";\t\t\tcontinue;\t\t}\t\tfor(int i=1;;i++) {\t\t\ta.pop_back();\t\t\ta.push_front(0);\t\t\tif(check(a, b)) {\t\t\t\tcout << i << ""\\n"";\t\t\t\tbreak;\t\t\t}\t\t}\t}}']",,,"['brute force', 'greedy', 'two pointers']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Contest Proposal.json,https://codeforces.com//blog/entry/129027,Enumerate through the array if at some index then propose a problem with difficulty Time complexity for each test case It can also be solved in if we record the problems we ve added 
https://codeforces.com//contest/1973/problem/E,2652014,E,1973E,1973,"E. Cat, Fox and Swaps ",Fox has found an array p 1 p 2 ldots p n that is a permutation of length n dagger of the numbers 1 2 ldots n She wants to sort the elements in increasing order Cat wants to help her he is able to swap any two numbers x and y in the array but only if l leq x y leq r note that the constraint is imposed on the values of the elements not their positions He can make such swaps any number of times They don t know the numbers l r yet they only know that it s true that 1 leq l leq r leq 2 cdot n You are given the number n and the array p 1 p 2 ldots p n Determine how many pairs l r satisfying the conditions are there such that you can sort the permutation if you can only swap two number x y such that l leq x y leq r arbitrary number of times possibly 0 dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>using namespace std;#define ll long longint n,p[101000],q[101000];void sol(){    scanf(""%d"",&n);for(int i=1;i<=n;i++)scanf(""%d"",&p[i]),q[p[i]]=i;    bool fl=1;    for(int i=1;i<n;i++)fl&=(q[i]<q[i+1]);    if(fl){printf(""%lld\\n"",1ll*n*(n*2+1));return;}    int L=n+1,R=-1,h=0;    for(int i=1;i<=n;i++)if(q[i]!=i){        L=min(L,i),R=max(R,i);        if(h==-1)continue;        if(!h||h==i+q[i])h=i+q[i];        else h=-1;    }    ll ans=0;    for(int l=1;l<=n*2;l++)if(L>=l-n){        int re=max(l,R)+1;        if(re<=n*2)ans+=n*2-re+1;        //R+1,l+1<=r    }    if(h>0)ans++;    printf(""%lld\\n"",ans);}int main(){    int T;scanf(""%d"",&T);while(T--)sol();    return 0;}']",,,"['graphs', 'math', 'sortings']",2500,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Cat, Fox and Swaps .json",https://codeforces.com//blog/entry/129556,Solution Let s consider the pairs that have first Then you can swap each with at most one other element So if for some then we need to be able to swap the element with the element so it must hold that This is obviously also a sufficient condition so it s enough to just find all for if there exist more then one different value there s no good pair with if there s exactly one different value there s exactly one good pair with and otherwise there are such pairs Now let s count the pairs with If the array is sorted already all pairs of are good From now consider only the case when the array isn t sorted yet Let be the smallest value such that and the largest such value respectively We obviously need to be able to swap and with some other values Note that and otherwise the array would be sorted already Now we can get the inequalities and those are the necessary conditions for being able to swap the numbers with at least one other element We can actually prove that these are the sufficient conditions too If satisfy these conditions then for any number in the range we can find an in the range such that and then we can swap the numbers and while not affecting any other element by swapping and first and then swapping and Thanks to this we can sort the whole range of values between and while the array isn t sorted we will always find the smallest index that doesn t have the right value and keep swapping the value with the value so eventually we will get and we can continue sorting on the right So it s enough to just count the number of pairs such that and add it to the answer and print it All of this can be done in time and memory complexity Implementation in C 261999566 I used set and therefore the time complexity is because it was more comfortable 
https://codeforces.com//contest/622/problem/C,47917,C,622C,622,C. Not Equal on a Segment,You are given array with integers and queries The th query is given with three integers For the th query find any position so that ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nVI d[SIZE];\nint a[SIZE],nxt[SIZE];\nint main(){\n    map<PII,int>H;\n    DRII(n,m);\n    REP(i,n){\n        DRI(x);\n        a[i+1]=x;\n        d[x].PB(i+1);\n    }\n    for(int i=n-1;i>0;i--){\n        if(a[i+1]!=a[i])nxt[i]=i+1;\n        else nxt[i]=nxt[i+1];\n    }\n    while(m--){\n        DRIII(l,r,x);\n        int it1=lower_bound(ALL(d[x]),l)-d[x].begin();\n        int it2=lower_bound(ALL(d[x]),r+1)-d[x].begin();\n        if(it2-it1==r-l+1)puts(""-1"");\n        else printf(""%d\\n"",a[l]==x?nxt[l]:l);\n    }\n    return 0;\n}\n']",,,"['data structures', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Not Equal on a Segment.json,https://codeforces.com//blog/entry/23442,This problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position C solution Complexity 
https://codeforces.com//contest/1586/problem/E,1147385,E,1586E,1586,E. Moment of Bloom,Hu Tao being the little prankster she is has tried to scare you with this graph problem You are given a connected undirected graph of n nodes with m edges You also have q queries Each query consists of two nodes a and b Initially all edges in the graph have a weight of 0 For each query you must choose a simple path starting from a and ending at b Then you add 1 to every edge along this path Determine if it s possible after processing all q queries for all edges in this graph to have an even weight If so output the choice of paths for each query If it is not possible determine the smallest number of extra queries you could add to make it possible It can be shown that this number will not exceed 10 18 under the given constraints A simple path is defined as any path that does not visit a node more than once An edge is said to have an even weight if its value is divisible by 2 ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q, qu[300005], qv[300005], par[300005], dep[300005], C[300005];\nvector<int> G[300005];\nbool vis[300005];\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\trep(i, G[v].size()) {\n\t\tint u = G[v][i];\n\t\tif(!vis[u]) {\n\t\t\tpar[u] = v; dep[u] = dep[v] + 1; dfs(u);\n\t\t}\n\t}\n}\n\nvector<int> A0, A1;\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, m) {\n\t\tint u, v;\n\t\tscanf(""%d%d"", &u, &v);\n\t\tG[v].push_back(u); G[u].push_back(v);\n\t}\n\tdfs(1);\n\t\n\tscanf(""%d"", &q);\n\trep(i, q) {\n\t\tscanf(""%d%d"", &qu[i], &qv[i]);\n\t\tC[qu[i]] ^= 1; C[qv[i]] ^= 1;\n\t}\n\tint tot = 0;\n\trep1(i, n) tot += C[i];\n\tif(tot != 0) {\n\t\tprintf(""NO\\n%d\\n"", tot / 2); return 0;\n\t}\n\tprintf(""YES\\n"");\n\trep(i, q) {\n\t\tint x = qu[i], y = qv[i];\n\t\tA0.clear(); A1.clear();\n\t\twhile(x != y) if(dep[x] > dep[y]) {\n\t\t\tA0.push_back(x); x = par[x];\n\t\t} else {\n\t\t\tA1.push_back(y); y = par[y];\n\t\t}\n\t\treverse(A1.begin(), A1.end());\n\t\tprintf(""%d\\n"", (int)A0.size() + (int)A1.size() + 1);\n\t\trep(j, A0.size()) printf(""%d "", A0[j]);\n\t\tprintf(""%d"", x);\n\t\trep(j, A1.size()) printf("" %d"", A1[j]);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'dfs and similar', 'dsu', 'graph matchings', 'graphs', 'greedy', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Moment of Bloom.json,https://codeforces.com//blog/entry/96072,Let be the number of times appears in the queries If is odd for any then there does not exist an assignment of paths that will force all even edge weights To see why notice that one query will correspond to exactly one edge adjacent to If an odd number of paths are adjacent to this implies that at least one edge adjacent to will have an odd degree It turns out that this is the only condition that we need to check In other words if is even for all then there will exist an assignment of paths that will force all edge weights to be even Let s assume all is even We can find a solution by doing the following take any spanning tree of the graph and assign each query to be the path from to in this tree An intuitive way of thinking about this is the following Consider the case if the spanning tree is a line Then each query becomes a range and we re checking if all points in this range are covered an even number of times For all points to be covered an even number of times every point should occur an even number of times in the queries To generalize this to a tree when the first path to is incremented in order to make these values even again we will need later paths to also overlap the segment from to One way this can be done is if we use two paths to and to Notice that even if a new segment that makes the to path even makes some other edges odd the later queries will always fix these edges 
https://codeforces.com//contest/946/problem/B,162807,B,946B,946,B. Weird Subtraction Process,You have two variables and Consider the following sequence of actions performed with these variables If or end the process Otherwise go to step If then set the value of to and repeat step Otherwise go to step If then set the value of to and repeat step Otherwise end the process Initially the values of and are positive integers and so the process will be finite You have to determine the values of and after the process ends ,"['// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored ""-Wunused-result""\n#pragma GCC diagnostic ignored ""-Wunused-function""\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(""%d"", &x); }\nvoid _R(int64_t &x) { scanf(""%"" SCNd64, &x); }\nvoid _R(double &x) { scanf(""%lf"", &x); }\nvoid _R(char &x) { scanf("" %c"", &x); }\nvoid _R(char *x) { scanf(""%s"", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(""%d"", x); }\nvoid _W(const int64_t &x) { printf(""%"" PRId64, x); }\nvoid _W(const double &x) { printf(""%.16f"", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(""%s"", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(\' \'); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? \' \' : \'\\n\'); W(tail...); }\n\n#ifdef SHIK\n#include ""dump.hpp""\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nvoid main() {\n    LL a,b;\n    R(a,b);\n    while ( 1 ) {\n        if ( a==0 || b==0 ) break;\n        if ( a>=2*b ) {\n            a%=2*b;\n            continue;\n        }\n        if ( b>=2*a ) {\n            b%=2*a;\n            continue;\n        }\n        break;\n    }\n    W(a,b);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n']",,,"['math', 'number theory']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Weird Subtraction Process.json,https://codeforces.com//blog/entry/58210,The answer can be calculated very easy by Euclid algorithm which is described in the problem statement but all subtractions will be replaced by taking by modulo 
https://codeforces.com//contest/587/problem/B,38259,B,587B,587,B. Duff in Beach,While Duff was resting in the beach she accidentally found a strange array consisting of positive integers This array was strange because it was extremely long but there was another maybe shorter array that can be build from with formula where denoted the remainder of dividing by Duff is so curious she wants to know the number of subsequences of like such that For each For each i e this subsequence is non decreasing Since this number can be very large she want to know it modulo Duff is not a programmer and Malek is unavailable at the moment So she asked for your help Please tell her this number ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int ,int> PII;\ntypedef pair< int , PII> pii;\n\nconst int INF = ~0U>>1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1, a = 1ll * a * a % Mod)\n        if (x & 1) ret = 1ll * ret * a % Mod;\n    return ret; \n}\n\nconst int N=1010000;\nint n,k,a[N],ans,c[N];\nPII p[N];\nll l,dp[N],ss[N];\n\nint main() {\n\tscanf(""%d%lld%d"",&n,&l,&k);\n\trep(i,0,n) scanf(""%d"",a+i);\n\trep(i,0,n*k) p[i]=mp(a[i%n],i);\n\tsort(p,p+n*k);\n\trep(j,0,n*k) {\n\t\tint i=p[j].se;\n\t\tif (i<n) dp[i]=1;\n\t\telse dp[i]=ss[i/n-1];\n\t\tss[i/n]=(ss[i/n]+dp[i])%Mod;\n//\t\tprintf(""%d %lld\\n"",i,dp[i]);\n\t\tif (i<l) {\n\t\t\tll x=(l-1-i+n)/n;\n\t\t\tans=(ans+(x%Mod)*dp[i])%Mod;\n\t\t}\n\t}\n\tif (ans<0) ans+=Mod;\n\tprintf(""%d\\n"",ans);\n}']",,,['dp'],2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Duff in Beach.json,https://codeforces.com//blog/entry/20971,If we fix x and bix mod n then problem will be solved because we can then multiply it by the number of valid distinct values of For the problem above let dp i j be the number of valid subsequences of b where x j and and Of course for every i dp i 1 1 For calculating value of dp i j For this purpose we can sort the array a and use two pointer if p0 p1 pn 1 is a permutation of 0 n 1 where for each 0 t n 1 apt apt 1 Now if and x l 1 mod n then answer equals to there are c j 1 valid different values of for the first group and c j for the second group 
https://codeforces.com//contest/1935/problem/A,2510285,A,1935A,1935,A. Entertainment in MAC,Congratulations you have been accepted to the Master s Assistance Center However you were extremely bored in class and got tired of doing nothing so you came up with a game for yourself You are given a string s and an integer n There are two types of operations that you can apply to it Add the reversed string s to the end of the string s for example if s then after applying the operation s Reverse the current string s for example if s then after applying the operation s It is required to determine the lexicographically smallest dagger string that can be obtained after applying n operations Note that you can apply operations of different types in any order but you must apply exactly n operations in total dagger A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,n,m,a[N],b[N];\nstring s,t;\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n>>s;\n        t=s,reverse(all(t));\n        cout<<min(s,t+s)<<\'\\n\';\n    }\n    return 0;\n}']",,,"['constructive algorithms', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Entertainment in MAC.json,https://codeforces.com//blog/entry/126662,Solution Let be the reversed string Notice that it is advantageous for us to use operation 1 adding the reversed string at the end no more than once Indeed having obtained some string we will simply spend the remaining operations on flipping the string Thus we will get the original string or the reversed one depending on the parity of the number of remaining operations It is easy to see that the answer will always have either the prefix or Then we find two lexicographically minimal strings with the prefix and These will be strings flip the string times since is even every 2 operations we return the string to its original initially flip the string add the reversed string to the end then flip the string times The answer will be the lexicographically minimal string out of and 
https://codeforces.com//contest/1294/problem/B,521708,B,1294B,1294,B. Collecting Packages,There is a robot in a warehouse and n packages he wants to collect The warehouse can be represented as a coordinate grid Initially the robot stays at the point 0 0 The i th package is at the point x i y i It is guaranteed that there are no two packages at the same point It is also guaranteed that the point 0 0 doesn t contain a package The robot is semi broken and only can move up and right In other words in one move the robot can go from the point x y to the point x 1 y or to the point x y 1 As we say above the robot wants to collect all n packages He wants to do it with the minimum possible number of moves If there are several possible traversals the robot wants to choose the lexicographically smallest path The string s of length n is lexicographically less than the string t of length n if there is some index 1 le j le n that for all i from 1 to j 1 s i t i and s j t j It is the standard comparison of string like in a dictionary Most programming languages compare strings in this way ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nstruct node{\n    int x,y;\n    bool operator<(const node &t)const{\n        if(x==t.x)return y<t.y;\n        return x<t.x;\n    }\n}a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        scanf(""%d"",&n);\n        for(int i=1;i<=n;i++){\n            scanf(""%d%d"",&a[i].x,&a[i].y);\n        }\n        sort(a+1,a+1+n);\n        a[0].x=a[0].y=0;\n        int flag=1;\n        for(int i=1;i<=n;i++){\n            if(a[i].y<a[i-1].y){\n                flag=0;break;\n            }\n        }\n        if(flag==0){\n            printf(""NO\\n"");\n            continue;\n        }\n        puts(""YES"");\n        for(int i=0;i<n;i++){\n            while(a[i].x<a[i+1].x){\n                a[i].x++;\n                printf(""R"");\n            }\n            while(a[i].y<a[i+1].y){\n                a[i].y++;\n                printf(""U"");\n            }\n        }printf(""\\n"");\n    }\n    return 0;\n}\n']",,,"['implementation', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Collecting Packages.json,https://codeforces.com//blog/entry/73274,It is obvious that if there is a pair of points and such that and then the answer is It means that if the answer is then there is some ordering of points such that and because we can only move right or up But what is this ordering it is just sorted order of points firstly by then by So we can sort all points check if this ordering is valid and traverse among all these points For each from to firstly do moves to the right then do moves to the up because this order minimizing the answer lexicographically Time complexity or 
https://codeforces.com//contest/1881/problem/A,2259902,A,1881A,1881,A. Don't Try to Count,Given a string x of length n and a string s of length m n cdot m le 25 consisting of lowercase Latin letters you can apply any number of operations to the string x In one operation you append the current value of x to the end of the string x Note that the value of x will change after this For example if x then after applying operations x will change as follows rightarrow rightarrow After what number of operations s will appear in x as a substring A substring of a string is defined as a segment of it ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,m,k,a[N];\nstring s,t;\nvoid prep(){\n\n}\nvoid solve()\n{\n    cin>>n>>m>>s>>t;\n    k=0;\n    while (sz(s)<sz(t)) k++,s+=s;\n    rep(i,0,sz(s)-sz(t)) if (s.substr(i,sz(t))==t){\n        cout<<k;\n        return;\n    }\n    k++;\n    s+=s;\n    rep(i,0,sz(s)-sz(t)) if (s.substr(i,sz(t))==t){\n        cout<<k;\n        return;\n    }\n    cout<<-1;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']",,,"['brute force', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Don't Try to Count.json,https://codeforces.com//blog/entry/121327,Note that the answer is always not greater than When the answer is either or it is easy to see that the answer cannot be greater This allows us to simply iterate over the number of operations each time checking if occurs in The time complexity of this solution is 
https://codeforces.com//contest/1586/problem/I,1147389,I,1586I,1586,I. Omkar and Mosaic,Omkar is creating a mosaic using colored square tiles which he places in an n times n grid When the mosaic is complete each cell in the grid will have either a glaucous or sinoper tile However currently he has only placed tiles in some cells A completed mosaic will be a if and only if each tile is adjacent to exactly 2 tiles of the same color 2 tiles are adjacent if they share a side Omkar wants to fill the rest of the tiles so that the mosaic becomes a Now he is wondering is the way to do this unique and if it is what is it ,"['//an awesome problem.\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint absv(int x)\n{\n\treturn x < 0 ? -x : x;\n}\nint n, x[2005], G[2005][2005];\nchar S[2005][2005];\nbool dfs(int v, int c)\n{\n\tif(x[v] == !c) return false;\n\telse if(x[v] == c) return true;\n\tx[v] = c;\n\trep(i, n + 1) if(G[v][i] != -1 && !dfs(i, c ^ G[v][i])) return false;\n\treturn true;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%s"", S[i]);\n\tif(n & 1) {\n\t\tprintf(""NONE\\n""); return 0;\n\t}\n\t\n\trep(i, n + 1) rep(j, n + 1) G[i][j] = -1;\n\tfor(int i = 0; i < n; i += 2) G[i][i + 2] = G[i + 2][i] = 1;\n\trep(i, n) rep(j, n) if(S[i][j] != \'.\') {\n\t\tint val = (S[i][j] == \'S\') ^ (i & 1) ^ (j & 1);\n\t\tint d0 = absv(i - j), d1 = absv(i + j - n + 1);\n\t\tif(G[d0][n - d1] == !val) {\n\t\t\tprintf(""NONE\\n""); return 0;\n\t\t}\n\t\tG[d0][n - d1] = G[n - d1][d0] = val; \n\t}\n\t\n\trep(i, n + 1) x[i] = -1;\n\tint cnt = 0;\n\trep(i, n + 1) if(x[i] == -1) {\n\t\tcnt ++;\n\t\tif(!dfs(i, 0)) {\n\t\t\tprintf(""NONE\\n""); return 0;\n\t\t}\n\t}\n\tif(cnt >= 2) printf(""MULTIPLE\\n"");\n\telse {\n\t\trep(i, n) rep(j, n) S[i][j] = (i & 1) ^ (j & 1) ^ x[absv(i - j)] ^ x[n - absv(i + j - n + 1)] ? \'S\' : \'G\';\n\t\tprintf(""UNIQUE\\n"");\n\t\trep(i, n) printf(""%s\\n"", S[i]);\n\t}\n\treturn 0;\n}']",,,"['combinatorics', 'constructive algorithms', 'math']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\I. Omkar and Mosaic.json,https://codeforces.com//blog/entry/96072,The first main observation to make is that the possible mastapeeces don t just have square loops of the same color A counterexample to this is shown below Instead observe that in a mastapeece a The two cells adjacent to corner cells must be the same color as the corner b Any cell not on the border must be adjacent to two sinoper tiles and two glaucous tiles If we then start at two cells adjacent to some corner and keep applying b to cells on the long diagonal with the corner we find that the long diagonals starting at the adjacent cells must be identical and tiled alternately with glaucous and sinoper tiles like so From here we can show that no mastapeece exists for odd Note that the two sets of such diagonals for odd intersect in cells like so But then this forces us two have two consecutive diagonals of the same color on the untiled set of diagonals which is impossible given that we ve shown they must alternate From here if we apply b to the red diagonals we find that the yellow diagonals must alternate in a similar fashion and if we keep applying this argument we find that each diagonal where every cell is the same color in the image below must alternate between glaucous and sinoper in a similar way From here consider the following yellow diagonal We know its cells must alternate so due to parity we have that the ending cells of the diagonal must be the same color Since we know each cell must be surrounded by two of the same color this also fixes the following red cells which must also be the same color This gives that the following yellow diagonals must be identical as they must alternate repeating this kind of argument shows that a mastapeece must be symmetric about both of its main diagonals Finally note that since the yellow diagonal alternates and each cell must be adjacent to of the same color the red cells must be the same color Repeating this kind of argument gives that the cells in each pair of adjacent red cells and each pair of adjacent yellow cells must be the same color Finally applying the symmetry alternating diagonals and the pairs of same colored cells gives that in the following grid fixing a cell of one color fixes all of the cells of that color Finally due to our conditions on alternating diagonals each cell in the middle of the grid will be adjacent to two cells of the same color and due to our conditions on the pairs of cells on the diagonal that must be the same color each border cell will be adjacent to two cells of the same color In other words if we pair up the cells on the leftmost column and color each pair arbitrarily there will be exactly one mastapeece that has the column colored this way For example if we color the leftmost column like so then if we go down and color in the cells fixed by each pair in the left most column we find that the final mastapeece will look like so From here it s pretty easy to figure out how to implement the problem Some examples of what mastapeeces look like are shown below 
https://codeforces.com//contest/1106/problem/B,290931,B,1106B,1106,B. Lunar New Year and Food Ordering,The restaurant Alice s serves n kinds of food The cost for the i th kind is always c i Initially the restaurant has enough ingredients for serving exactly a i dishes of the i th kind In the New Year s Eve m customers will visit Alice s one after another and the j th customer will order d j dishes of the t j th kind of food The i 1 st customer will only come after the i th customer is completely served Suppose there are r i dishes of the i th kind remaining initially r i a i When a customer orders 1 dish of the i th kind the following principles will be processed If r i 0 the customer will be served exactly 1 dish of the i th kind The cost for the dish is c i Meanwhile r i will be reduced by 1 Otherwise the customer will be served 1 dish of the available kind of food if there are any If there are multiple cheapest kinds of food the one with the smallest index among the cheapest will be served The cost will be the cost for the dish served and the remain for the corresponding dish will be reduced by 1 If there are no more dishes at all the customer will leave angrily Therefore no matter how many dishes are served previously the cost for the customer is 0 If the customer doesn t leave after the d j dishes are served the cost for the customer will be the sum of the cost for these d j dishes Please determine the total cost for each of the m customers ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nint a[N], c[N];\nset<pair<int, int> > S;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= n; i++) cin >> c[i];\n\tfor (int i = 1; i <= n; i++) S.insert(make_pair(c[i], i));\n\tlong long ans = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint t, d; cin >> t >> d;\n\t\tlong long cost = 0;\n\t\twhile (d) {\n\t\t\tif (a[t]) {\n\t\t\t\tint s = min(a[t], d);\n\t\t\t\ta[t] -= s;\n\t\t\t\td -= s;\n\t\t\t\tif (!a[t]) S.erase(make_pair(c[t], t));\n\t\t\t\tcost += 1LL * s * c[t];\n\t\t\t} else {\n\t\t\t\tif (S.empty()) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tpair<int, int> x = *S.begin();\n\t\t\t\t\tt = x.second;\n\t\t\t\t\tint s = min(a[t], d);\n\t\t\t\t\ta[t] -= s;\n\t\t\t\t\td -= s;\n\t\t\t\t\tif (!a[t]) S.erase(make_pair(c[t], t));\n\t\t\t\t\tcost += 1LL * s * c[t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}\t\t\t']",,,"['data structures', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Lunar New Year and Food Ordering.json,https://codeforces.com/blog/entry/64928,The implementation of the problem is easy Just do what Bob tells you to do The only difficulty if it is is to handle the cheapest dish This can be done by a pointer or a priority queue The details can be found in the code 
https://codeforces.com//contest/1857/problem/G,2150548,G,1857G,1857,G. Counting Graphs,Given a tree consisting of n vertices A tree is a connected undirected graph without cycles Each edge of the tree has its weight w i Your task is to count the number of different graphs that satisfy all four conditions The graph does not have self loops and multiple edges The weights on the edges of the graph are integers and do not exceed S The graph has minimum spanning tree The minimum spanning tree of the graph is the given tree Two graphs are considered different if their sets of edges are different taking into account the weights of the edges The answer can be large output it modulo 998244353 ,"[""#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n\nusing ll = long long;\nusing ld = long double;\n\nconst int MOD = 998244353;\n\n#define int long long\n\nstruct dsu {\n    vector<int> p, s;\n    dsu(int n) {\n        p.resize(n);\n        iota(all(p), 0);\n        s.assign(n, 1);\n    }\n    int get(int v) {\n        if (v == p[v]) return v;\n        p[v] = get(p[v]);\n        return p[v];\n    }\n    int unite(int u, int v) {\n        u = get(u), v = get(v);\n        if (u == v) return 0;\n        if (s[u] < s[v]) swap(u, v);\n        int res = 0;\n        res -= s[u] * (s[u] - 1) / 2;\n        res -= s[v] * (s[v] - 1) / 2;\n        s[u] += s[v];\n        p[v] = u;\n        res += s[u] * (s[u] - 1) / 2;\n        res--;\n        return res;\n    }\n};\n\nint mpow(int x, int e) {\n    int c = x, r = 1;\n    while (e) {\n        if (e & 1) r = r * c % MOD;\n        c = c * c % MOD;\n        e >>= 1;\n    }\n    return r;\n}\n\nvoid solve() {\n    int n, S;\n    cin >> n >> S;\n    vector <array <int, 3>> edg;\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u, --v;\n        edg.push_back({w, u, v});\n    }\n    sort(all(edg));\n    int ans = 1;\n    dsu z(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int add = z.unite(edg[i][1], edg[i][2]);\n        ans = ans * mpow(S - edg[i][0] + 1, add) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n}""]",,,"['combinatorics', 'divide and conquer', 'dsu', 'graphs', 'greedy', 'sortings', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Counting Graphs.json,https://codeforces.com//blog/entry/119134,The first observation is that the graphs will consist of vertices because the MST is fixed Hence the graphs will look like the given tree with some new vertices connected The next step is to determine the possible weights of a new edge between vertices and Let be the maximum weight on the simple path from to I assume that we can add a new edge between vertices and with any weight in the range This becomes clear when we consider some examples If the edge has a weight less or equal than the MST will change by taking the new edge instead of the edge with the maximal weight on the path Notice that if we add a new edge and it doesn t affect the MST we can add one more edge independently from the previous So now the task is to calculate because for each pair of vertices we can assign a new weight from the range which gives us cases or we can choose not to add any edge which is one more case Now let s discuss how to calculate the formula efficiently Sort the given edges in ascending order according to their weights We ll begin from the graph without edges and add new ones step by step Suppose we already added all the edges up to Now we want to add the th one Notice that is greater than any of the weights before and and are from different components After adding the edge we need to calculate the number of paths that go through this edge If we know the sizes of the components containing and denoted as and respectively then there exist paths through edge without including the path formed by these two vertices We know the number of paths and on each of these paths we can determine the weight we can put on the edge Thus we need to multiply answer by using binary exponentiation To add edges and find the sizes of the components efficiently you can use DSU Disjoint Set Union The complexity of this approach is 
https://codeforces.com//contest/488/problem/A,17752,A,488A,488,A. Giga Tower,Giga Tower is the tallest and deepest building in Cyberland There are floors numbered from to In particular there is floor between floor and floor Every day thousands of tourists come to this place to enjoy the wonderful view In Cyberland it is believed that the number 8 is a lucky number that s why Giga Tower has floors above the ground and an integer is if and only if its decimal notation contains at least one digit 8 For example are all while are not In the Giga Tower if you write code at a floor with lucky floor number good luck will always be with you Well this round is 278 also lucky huh Tourist Henry goes to the tower to seek good luck Now he is at the floor numbered He wants to find the minimum integer such that if he walks floors higher he will arrive at a floor with a number ,"['#define _CRT_SECURE_NO_WARNINGS\n#if 1\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst LD eps = 1e-9;\nconst LD pi = acos(-1.0);\nconst LL inf = 1e+9;\n\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n\n#define dbg(x) { cerr << #x << "" = "" << x << endl; }\n\n// extended template\n#pragma comment(linker, ""/STACK:36777216"")\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\ntemplate<typename T> istream & operator >> (istream &, vector<T> &);\ntemplate<typename T> ostream & operator << (ostream &, const vector<T> &);\n\n#define START clock_t _clock = clock();\n#define END cerr << endl << ""time: "" << (clock() - _clock) / LD(CLOCKS_PER_SEC) << endl;\n\n#define NAME ""problem""\n\nbool check(int x){\n    while (x){\n        if (abs(x % 10) == 8) return true;\n        x /= 10;\n    }\n    return false;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int res = 1;\n    while (!check(n + res)){\n        res++;\n    }\n    cout << res << endl;\n}\n\nint main()\n{\n    // freopen(NAME "".in"", ""r"", stdin); freopen(NAME "".out"", ""w"", stdout);\n    // freopen(""input.txt"", ""r"", stdin); // freopen(""output.txt"", ""w"", stdout);\n\n    solve();\n\n    return 0;\n}\n/*******************************************\n*******************************************/\n\ntemplate<typename T> istream & operator >> (istream &is, vector<T> &v)\n{\n    forn(i, v.size())\n        is >> v[i];\n    return is;\n}\ntemplate<typename T> ostream & operator << (ostream &os, const vector<T> &v)\n{\n    forn(i, v.size())\n        os << v[i] << "" "";\n    return os;\n}\n#endif']",,,['brute force'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Giga Tower.json,https://codeforces.com/blog/entry/14832,The answer is very small usually no larger than because one of has its last digit be However can exceed when is negative and close to The worst case is where Anyway is rather small so we can simply try from and check whether has a digit 8 
https://codeforces.com//contest/2050/problem/E,3070030,E,2050E,2050,E. Three Strings,You are given three strings a b and c consisting of lowercase Latin letters The string c was obtained in the following way At each step either string a or string b was randomly chosen and the first character of the chosen string was removed from it and appended to the end of string c until one of the strings ran out After that the remaining characters of the non empty string were added to the end of c Then a certain number of characters in string c were randomly changed For example from the strings a color red text abra and b color blue text cada without character replacements the strings color blue text ca color red text ab color blue text d color red text ra color blue text a color red text abra color blue text cada color red text a color blue text cada color red text bra could be obtained Find the minimum number of characters that could have been changed in string c ,"['#include <bits/stdc++.h>using namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(0);    int t;    cin >> t;    while(t--){        string a, b, c;        cin >> a >> b >> c;        int n = a.size();        int m = b.size();        const int INF = 1e9;        vector<vector<int>> dp(n+1, vector<int>(m+1, INF));        dp[0][0] = 0;        for(int i=0; i<=n; i++){            for(int j=0; j<=m; j++){                if(i < n){                    int pos = i + j;                    if(pos < c.size()){                        int cost = dp[i][j] + (a[i] != c[pos] ? 1 : 0);                        if(cost < dp[i+1][j]){                            dp[i+1][j] = cost;                        }                    }                }                if(j < m){                    int pos = i + j;                    if(pos < c.size()){                        int cost = dp[i][j] + (b[j] != c[pos] ? 1 : 0);                        if(cost < dp[i][j+1]){                            dp[i][j+1] = cost;                        }                    }                }            }        }        cout << dp[n][m] << ""\\n"";    }}']",,,"['dp', 'implementation', 'strings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Three Strings.json,https://codeforces.com//blog/entry/137018,Let s use the idea of dynamic programming Let be the answer to the problem when considering string as its own prefix of length string as its own prefix of length and string as its own prefix of length Then the dynamic programming recurrence is easy we need to iterate over where we took the next th character of string If the character is taken from string the answer is if otherwise since we need to replace character with If it is taken from string the answer is calculated similarly if otherwise Thus to obtain the minimum value of the current dynamic programming state we need to take the minimum of the two obtained values To get the answer we need to take the value of the dynamic programming table at where is the length of string and is the length of string The final time complexity of the solution is per test case 
https://codeforces.com//contest/194/problem/A,1409,A,194A,194,A. Exams,One day the Codeforces round author sat exams He had exams and he needed to get an integer from to for each exam He will have to re sit each failed exam i e the exam that gets mark The author would need to spend too much time and effort to make the sum of his marks strictly more than That could have spoilt the Codeforces round On the other hand if the sum of his marks is strictly less than the author s mum won t be pleased at all The Codeforces authors are very smart and they always get the mark they choose themselves Also the Codeforces authors just hate re sitting exams Help the author and find the minimum number of exams he will have to re sit if he passes the exams in the way that makes the sum of marks for all exams equal exactly ,"['#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  cout << max(3*N-K, 0) << endl;\n}\n']",,,"['implementation', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Exams.json,https://codeforces.com//blog/entry/4673,Let s notice that 2n k 5n If k 3n author has to get 2 on some exams There are 3n k such exams and that s the answer If 3n k author will pass all exams answer is 0 
https://codeforces.com//contest/903/problem/E,138454,E,903E,903,E. Swapping Characters,We had a string consisting of lowercase Latin letters We made copies of this string thus obtaining identical strings After that in each of these strings we swapped exactly two characters the characters we swapped could be identical but they had different indices in the string You are given strings and you have to restore any string so that it is possible to obtain these strings by performing aforementioned operations Note that the total length of the strings you are given doesn t exceed 5000 that is ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nstring in[5550];\nvector <int> Vl[5550];\nchar u[5550];\n\nint cnt[26];\nint cnt2[26];\nint main() {\n\tint K, N, i, j, k, l;\n\tscanf(""%d %d"", &K, &N);\n\tfor (i = 0; i < K; i++) {\n\t\tscanf(""%s"", u);\n\t\tin[i] = string(u);\n\t}\n\tfor (i = 0; i < N; i++) cnt[in[0][i] - \'a\']++;\n\tfor (i = 1; i < K; i++) {\n\t\tfor (j = 0; j < 26; j++) cnt2[j] = 0;\n\t\tfor (j = 0; j < N; j++) cnt2[in[i][j] - \'a\']++;\n\t\tfor (j = 0; j < 26; j++) if (cnt[j] != cnt2[j]) return !printf(""-1\\n"");\n\t}\n\n\tbool chk2 = false;\n\tfor (i = 0; i < 26; i++) if (cnt[i] >= 2) chk2 = true;\n\n\tfor (i = 1; i < K; i++) {\n\t\tfor (j = 0; j < N; j++) if (in[0][j] != in[i][j]) Vl[i].push_back(j);\n\t\tif (Vl[i].size() > 4) return !printf(""-1\\n"");\n\t}\n\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = i + 1; j < N; j++) {\n\t\t\tswap(in[0][i], in[0][j]);\n\t\t\tfor (k = 1; k < K; k++) {\n\t\t\t\tint c = 0;\n\t\t\t\tif (in[0][i] != in[k][i]) c++;\n\t\t\t\tif (in[0][j] != in[k][j]) c++;\n\t\t\t\tfor (auto it : Vl[k]) if (it != i && it != j && in[0][it] != in[k][it]) c++;\n\t\t\t\tif (c > 2) break;\n\t\t\t\tif (c == 0 && !chk2) break;\n\t\t\t}\n\t\t\tif (k >= K) return !printf(""%s\\n"", in[0].c_str());\n\t\t\tswap(in[0][i], in[0][j]);\n\t\t}\n\t}\n\treturn !printf(""-1\\n"");\n}']",,,"['brute force', 'hashing', 'implementation', 'strings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Swapping Characters.json,https://codeforces.com//blog/entry/56330,If we don t have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it Otherwise we have to find two indices and such that Then let s store all positions such that in array If the number of those positions will exceed 4 then the answer will be 1 Otherwise we need to iterate over all positions in array try to swap with any other character of and check that current string can be the answer We also should try the same thing with string It is clear how we can check string to be the answer Let s iterate over all strings and for each string count the number of positions such that Let s call it If for any given string is not equal to 0 or 2 then string can t be the answer Otherwise if for any given string is equal to 0 and all characters in string are distinct then can t be the answer If there is no string that satisfies all aforementioned conditions then the answer will be 1 
https://codeforces.com//contest/449/problem/A,11565,A,449A,449,A. Jzzhu and Chocolate,Jzzhu has a big rectangular chocolate bar that consists of unit squares He wants to cut this bar exactly times Each cut must meet the following requirements each cut should be straight horizontal or vertical each cut should go along edges of unit squares it is prohibited to divide any unit chocolate square with cut each cut should go inside the whole chocolate bar and all cuts must be distinct The picture below shows a possible way to cut a chocolate for times Imagine Jzzhu have made cuts and the big chocolate is splitted into several pieces Consider the smallest by area piece of the chocolate Jzzhu wants this piece to be as large as possible What is the maximum possible area of smallest piece he can get with exactly cuts The area of a chocolate piece is the number of unit squares in it ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000009\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64;\n\ni64 N, M, K;\n\ni64 solve(i64 X)\n{\n\tif (X >= N || (K-X) >= M) return -1;\n\tif(X < 0 || K-X < 0) return -1;\n\n\treturn (N/(X+1)) * (M/(K-X+1));\n}\n\nint main()\n{\n\tcin >> N >> M >> K;\n\n\tif (N+M-2 < K) {\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\n\ti64 ret = 0;\n\tfor(int i=0;i<=100000;i++) {\n\t\tret = max(ret, solve(i));\n\t\tif(i>0) ret = max(ret, solve(min(K, N / i - 1)));\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}\n']",,,"['greedy', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Jzzhu and Chocolate.json,https://codeforces.com//blog/entry/13112,We assume that if we can simply swap and If we finally cut the chocolate into rows and columns we should maximize the narrowest row and maximize the narrowest column so the answer will be There are two algorithms to find the optimal Notice that if is smaller the answer usually will be better Then we can find that if the optimal can only be or If the optimal can only be If the optimal can only be because let has at most values so we can enum it and choose the maximum for each value 
https://codeforces.com//contest/1879/problem/C,2226287,C,1879C,1879,C. Make it Alternating,You are given a binary string s A binary string is a string consisting of characters and or You can perform the following operation on s any number of times choose an integer i such that 1 le i le s then erase the character s i You have to make s alternating i e after you perform the operations every two adjacent characters in s should be different Your goal is to calculate two values the minimum number of operations required to make s alternating the number of different sequences of operations that make s alternating Two sequences of operations are different if in at least one operation the chosen integer i is different in these two sequences ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 200001; \n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { v++; if (v == MOD) v = 0; return mi(v); }\n    mi operator--(int) { v--; if (v < 0) v = MOD-1; return mi(v); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid __print(mi X) {\n    cout << X.v;\n}\nmi facs[MX];\nmi facInvs[MX];\n\n//REMEMBER TO CHECK A >= B >= 0\nmi choose(mi _a, mi _b) {\n    ll a = (ll) _a, b = (ll) _b;\n    mi cur = facs[a];\n    cur = cur * facInvs[b];\n    cur = cur * facInvs[a-b];\n    return cur;\n}\n\nvoid initFacs() {\n\tfacs[0] = 1;\n\tFOR(i, 1, MX) {\n\t\tfacs[i] = (facs[i-1] * i);\n\t}\n    facInvs[MX - 1] = inv(facs[MX-1]);\n    F0Rd(i, MX-1) {\n        facInvs[i] = facInvs[i+1] * (i+1);\n    }\n}\nvoid solve() {\n    string S; cin >> S;\n    int cnt = 1;\n    int lst = 0;\n    mi ans = 1;\n    FOR(i, 1, sz(S)) {\n        if (S[i] != S[i-1]) {\n            cnt++;\n            ans *= i-lst;\n            lst = i;\n        }\n    }\n    ans *= sz(S) - lst;\n    cout << sz(S)-cnt << "" "" << facs[sz(S) - cnt] * ans << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    initFacs();\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']",,,"['combinatorics', 'dp', 'greedy']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Make it Alternating.json,https://codeforces.com//blog/entry/120773,Firstly let s divide the string into blocks of equal characters For example if then we divide it into four blocks Let s denote the length of th block as and the number of blocks as To obtain the longest alternating string we can get we should choose exactly one character from each block and delete all other characters we cannot leave two or more characters from the same block Now let s calculate the number of ways to choose characters that stay after string become alternating In the first block of length there are ways to choose that element in the second block there are ways and so on So the final number of ways is equal to For example let s consider the string This string is divided into two blocks and so the number of ways if However we have chosen the characters that remain but we need to choose the characters we erase and the order in which we erase them Since choosing the characters that remain is basically the same as choosing the characters that get erased we only have to choose the order in which the character get erased The number of characters we erase is so the number of ways to order them is equal to the number of permutations of length For example let s consider that the string and the chosen indices to erase are and Then there are ways to choose the order of them Note that after we delete a character from the string the indices of other characters might change but it doesn t actually matter So the final answer is the number of operations we perform is and the number of shortest sequences of operations is 
https://codeforces.com//contest/1479/problem/C,889628,C,1479C,1479,C. Continuous City,Some time ago Homer lived in a beautiful city There were n blocks numbered from 1 to n and m directed roads between them Each road had a positive length and each road went from the block with the smaller index to the block with the larger index For every two different blocks there was at most one road between them Homer discovered that for some two numbers L and R the city was L R The city is said to be L R continuous if all paths from block 1 to block n are of length between L and R inclusive and for every L leq d leq R there is path from block 1 to block n whose length is d A path from block u to block v is a sequence u x 0 to x 1 to x 2 to dots to x k v where there is a road from block x i 1 to block x i for every 1 leq i leq k The length of a path is the sum of lengths over all roads in the path Two paths x 0 to x 1 to dots to x k and y 0 to y 1 to dots to y l are different if k neq l or x i neq y i for some 0 leq i leq min k l After moving to another city Homer only remembers the two special numbers L and R but forgets the numbers n and m of blocks and roads respectively and how blocks are connected by roads However he believes the number of blocks should be no larger than 32 because the city was small As the best friend of Homer please tell him whether it is possible to find a L R continuous city or not ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass CContinuousCity {\n public:\n  void solveOne() {\n    int l, r;\n    cin >> l >> r;\n    cout << ""YES\\n"";\n    vector<tuple<int, int, int>> edges;\n    int n = 23;\n    int need = r - l + 1;\n    int next = l;\n    for (int i = n; i >= n - 21; --i) {\n      int p2 = 1 << max(0, n - i - 1);\n      for (int j = i - 1; j >= n - 21; --j) {\n        edges.emplace_back(j, i, p2);\n      }\n      if (i < n && (need & p2)) {\n        if (next == 1) {\n          int ne = edges.size();\n          for (int j = 0; j < ne; ++j) {\n            if (get<0>(edges[j]) == i) {\n              edges.emplace_back(1, get<1>(edges[j]), get<2>(edges[j]));\n            }\n          }\n        } else {\n          edges.emplace_back(1, i, next - 1);\n        }\n        next += p2;\n        need -= p2;\n      }\n    }\n    assert(need == 0);\n    cout << n << ""\\n"";\n    cout << edges.size() << ""\\n"";\n    for (auto e : edges) {\n      cout << get<0>(e) << "" "" << get<1>(e) << "" "" << get<2>(e) << ""\\n"";\n    }\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    CContinuousCity solver;\n\n\n    solver.solve();\n    return 0;\n}\n']",,,"['bitmasks', 'constructive algorithms']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Continuous City.json,https://codeforces.com//blog/entry/87598,The answer is always For convenience we write for a directed road from block to block of length We can solve the case and for inductively The case for is trivial i e only one edge Suppose there is a city of blocks for and for some and the induced city from block to block is continuous for every Let block be a new block and add and for We can see that the new city containing block is continuous Suppose and Let be the binary representation of where Let be the continuous city constructed in Step 1 Let block be a new block Connect and then for every if then connect We can see that the new city containing block is continuous Suppose Consider where denotes the continuous city constructed in Step 2 and there are blocks in Connect We can see that the new city containing block is continuous We note that there is at most blocks in our constructed city 
https://codeforces.com//contest/1443/problem/B,782900,B,1443B,1443,B. Saving the City,Bertown is a city with n buildings in a straight line The city s security service discovered that some buildings were mined A map was compiled which is a string of length n where the i th character is if there is a mine under the building number i and otherwise Bertown s best sapper knows how to activate mines so that the buildings above them are not damaged When a mine under the building numbered x is activated it explodes and activates two adjacent mines under the buildings numbered x 1 and x 1 if there were no mines under the building then nothing happens Thus it is enough to activate any one mine on a continuous segment of mines to activate all the mines of this segment For manual activation of one mine the sapper takes a coins He can repeat this operation as many times as you want Also a sapper can place a mine under a building if it wasn t there For such an operation he takes b coins He can also repeat this operation as many times as you want The sapper can carry out operations in any order You want to blow up all the mines in the city to make it safe Find the minimum number of coins that the sapper will have to pay so that after his actions there are no mines left in the city ,"['#include<bits/stdc++.h>\n\nnamespace mem{ //v2.8.3 => size: 15.62KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)      \\\n      func(float)                   \\\n      func(double)                  \\\n      func(long double)\n  \n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n  \n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n  }\n  \n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori\'s Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    \n    template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n    template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  }\n  \n  namespace modint{\n    template<const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x<0&&(x+=mod);}\n      \n      inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n      \n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n    };\n    \n    template<const int mod> inline Z<mod> finv(Z<mod> x){\n      if(x.x<2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n      Z<mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&1)s=s*a;\n      return s;\n    }\n    \n    template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n  \n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template<class T> inline T abs(T x){return x<0?-x:x;}\n    template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n    \n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n      \n      inline bool divide(u64 n){return n*i<=t;}\n      inline bool divide(i64 n){return u64(n<0?-n:n)*i<=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i<5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n  \n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)<<64)/b)),b(b){}\n      \n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n  \n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::unordered_set;\n    using std::map;\n    using std::unordered_map;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    \n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n    \n    template<class T> struct vector:std::vector<T>{\n      using std::vector<T>::vector;\n      using iterator=typename std::vector<T>::iterator;\n      using const_iterator=typename std::vector<T>::const_iterator;\n      vector():std::vector<T>(){}\n      explicit vector(const std::vector<T> &plain):std::vector<T>(plain){}\n      \n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n      \n      inline iterator lower_bound(const T &x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &x)const{return std::upper_bound(this->begin(),this->end(),x);}\n      \n      inline void sort(){std::sort(this->begin(),this->end());}\n      template<class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n      \n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n        vector<int> rsp=(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set<T> &src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template<class R,class Function> inline vector<R> _map(Function func) const{\n        vector<R> res(this->size());\n        for(size_t i=0;i<this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n      template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n    };\n    \n    struct string:std::string{\n      using std::string::string;\n      string():std::string(""""){}\n      string(const std::string &plain):std::string(plain){}\n      \n      template<class T> inline string join(const vector<T> &vet) const;\n      \n      vector<string> split(const string &dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector<string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n      \n      template<class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template<class... Args> static inline string format(const string &fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n  \n  #define __to_string(T)                   \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n    \n    inline string to_string(const string &s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &s){return string(s);}\n    template<const int mod> inline string to_string(const modint::Z<mod> &v){return std::to_string(v.x);}\n    \n    template<class T> inline string to_string(const vector<T> &ctn){return ""[""+string("","").join(ctn)+""]"";}\n    template<class T> inline string to_string(const set<T> &ctn){\n      string result=""{"";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+="","";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+""}"";\n    }\n    template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n      string result=""{"";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+="","";\n        flag=true;\n        result+=to_string(it.first)+"":""+to_string(it.second);\n      }\n      return result+""}"";\n    }\n    \n    template<class T> inline string string::join(const vector<T> &vet) const{\n      if(!vet.size())return """";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i<vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n    \n    inline string operator """" _s(const char *s){return string(s);}\n    inline string operator """" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator """" _s(long double x){return to_string(x);}\n    inline string operator """" _s(unsigned long long int x){return to_string(x);}\n  }\n  \n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1<<18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n  #endif\n    \n    template<class T> inline void read_digit(T &x){x=getc(); while(!isdigit(x))x=getc();}\n    template<class T> inline void read_alpha(T &x){x=getc(); while(!isalpha(x))x=getc();}\n    template<class T> inline void read_lower(T &x){x=getc(); while(!islower(x))x=getc();}\n    template<class T> inline void read_upper(T &x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n  \n  #define __read(T)                             \\\n      inline void read(T &x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c==\'-\',c=getc();   \\\n        while(isdigit(c))x=x*10+c-\'0\',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n  #undef __read\n    \n    inline void read(char &x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&&!isspace(c))*s++=c,c=getc();\n      *s++=\'\\0\';\n    }\n    inline void read(container::string &s){\n      char c=getc();\n      s="""";\n      while(~c&&!isspace(c))s+=c,c=getc();\n    }\n    template<const int mod> inline void read(const modint::Z<mod> &x){read(x.x);}\n    \n    template<class T=int> inline T read(){T x; read(x); return x;}\n    template<class T,class... Args> inline void read(T &x,Args &... args){\n      read(x),read(args...);\n    }\n  \n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x<0)putc(\'-\'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc(\'0\'+x%10);        \\\n      }\n    __integer_mapper(__print)\n  #undef __print\n    \n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i<len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &s){\n      for(size_t i=0;i<s.length();i++)putc(s[i]);\n    }\n    template<const int mod> inline void print(const modint::Z<mod> &x){print(x.x);}\n    \n    template<class T,class... Args> inline void print(const T &x,Args... args){\n      print(x),print(args...);\n    }\n    template<class... Args> inline void println(Args... args){\n      print(args...),putc(\'\\n\');\n    }\n    \n    template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n  \n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,""\\033[%dm"",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\033[0m"");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,""\\033[%dm"",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\033[0m\\n"");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\n"");\n      }\n  #endif\n    }\n    template<class T> inline void logs(const T &x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template<class T,class... Args> inline void logs(const T &x,Args... args){\n      logs(x),logs(args...);\n    }\n    template<class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,""\\n"");\n  #endif\n    }\n  }\n  \n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,""r"",stdin);}\n    inline void file_output(const char *dir){freopen(dir,""w"",stdout);}\n    inline void file_input(const std::string &dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &dir){file_output(dir.c_str());}\n\n    template<class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+"".in""_s);\n      file_output(name+"".out""_s);\n    }\n\n  #ifdef memset0\n    template<class T> inline void local_file_io(T name){file_io(name);}\n    template<class T> inline void local_file_input(T dir){file_input(dir);}\n    template<class T> inline void local_file_output(T dir){file_output(dir);}\n    template<class T> inline void judge_file_io(T name){}\n    template<class T> inline void judge_file_input(T dir){}\n    template<class T> inline void judge_file_output(T dir){}\n  #else\n    template<class T> inline void local_file_io(T name){}\n    template<class T> inline void local_file_input(T dir){}\n    template<class T> inline void local_file_output(T dir){}\n    template<class T> inline void judge_file_io(T name){file_io(name);}\n    template<class T> inline void judge_file_input(T dir){file_input(dir);}\n    template<class T> inline void judge_file_output(T dir){file_output(dir);}\n  #endif\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\nusing namespace mem;\n\nconst int N=1e5+10;\nint T,n,a,b;\nchar s[N];\nlong long ans;\n\nint main(){\n#ifdef memset0\n\tfreopen(""1.in"",""r"",stdin);\n#endif\n\tread(T);\n\twhile(T--){\n\t\tread(a,b,s),n=strlen(s);\n\t\tint t=0;\n\t\twhile(t<n&&s[t]==\'0\')t++;\n\t\tif(t==n){\n\t\t\tans=0;\n\t\t}else{\n\t\t\tans=0;\n\t\t\twhile(s[n-1]==\'0\')n--;\n\t\t\tfor(int l=t,r=l;l<n;l=r+1,r=l)\n\t\t\t\tif(s[l]==\'0\'){\n\t\t\t\t\twhile(r+1<n&&s[r+1]==\'0\')r++;\n\t\t\t\t\t// log<BLUE>(""%d %d\\n"",l,r);\n\t\t\t\t\tif((long long)b*(r-l+1)<a){\n\t\t\t\t\t\tans+=b*(r-l+1)-a;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twhile(r+1<n&&s[r+1]==\'1\')r++;\n\t\t\t\t\t// log<RED>(""%d %d\\n"",l,r);\n\t\t\t\t\tans+=a;\n\t\t\t\t}\n\t\t}\n\t\tprint(ans,\'\\n\');\n\t}\n}']",,,"['dp', 'greedy', 'math', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Saving the City.json,https://codeforces.com//blog/entry/84298,Since the activation of any mine explodes the entire segment of mines which it is you can immediately replace the input string with an array of mine segments We now have two operations We can delete any segment by coins or turn two adjacent segments into one segment for That is two segments can be deleted for a cost of or This means that you need to merge two segments while You need to go through all adjacent segments and check this condition 
https://codeforces.com//contest/1083/problem/A,268421,A,1083A,1083,A. The Fair Nut and the Best Path,The Fair Nut is going to travel to the Tree Country in which there are n cities Most of the land of this country is covered by forest Furthermore the local road system forms a tree connected graph without cycles Nut wants to rent a car in the city u and go by a simple path to city v He hasn t determined the path so it s time to do it Note that chosen path can consist of only one vertex A filling station is located in every city Because of strange law Nut can buy only w i liters of gasoline in the i th city We can assume that he has Each road has a length and as soon as Nut drives through this road the amount of gasoline decreases by length Of course Nut can t choose a path which consists of roads where he runs out of gasoline He can buy gasoline in visited city even in and He also wants to find the maximum amount of gasoline that he can have at the end of the path Help him count it ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nvector <pair <int,ll> > graf[nax];\n\nll dfs(int v, int oj)\n{\n\tll ret=tab[v];\n\twyn=max(wyn, tab[v]);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tll w=dfs(i.first, v)-i.second;\n\t\twyn=max(wyn, ret+w);\n\t\tret=max(ret, w+tab[v]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c);\n\t\tgraf[a].push_back({b, c});\n\t\tgraf[b].push_back({a, c});\n\t}\n\tdfs(1, 0);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. The Fair Nut and the Best Path.json,https://codeforces.com/blog/entry/63753?locale=en,Let s write on edge with length number Let sum on the path be sum of amounts of gasoline which can be bought in cities on this path plus sum of the numbers which were written on its edges If we don t run out of gasoline on some path sum on it will be equal to amount of gasoline at the end of way If we run out of gasoline on a path we can start from the next city after the road where it happened and sum on the path won t decrease So there is a path with maximal sum where we don t run out of gasoline This sum is answer to the problem How to find it Let is maximal sum on vertical way which starts in vertex It is not difficult to calculate using values for children of vertex Every way can be divided to two vertical ways so we can calculate answer by turning over which is the highest vertex of a path and taking the two biggest vertical ways which starts from vertex 
https://codeforces.com//contest/1141/problem/A,316170,A,1141A,1141,A. Game 23,Polycarp plays Game 23 Initially he has a number n and his goal is to transform it to m In one move he can multiply n by 2 or multiply n by 3 He can perform any number of moves Print the number of moves needed to transform n to m Print if it is impossible to do so It is easy to prove that any way to transform n to m contains the same number of moves i e number of moves doesn t depend on the way of transformation ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    ll n, m;\n    cin >> n >> m;\n\n    ll ans = 0;\n\n    if(m % n != 0){\n        cout << -1;\n        return 0;\n    }\n    else{\n        m /= n;\n        while(m % 3 == 0){\n            m /= 3;\n            ans++;\n        }\n        while(m % 2 == 0){\n            m /= 2;\n            ans++;\n        }\n        if(m == 1){\n            cout << ans;\n        }\n        else{\n            cout << -1;\n        }\n    }\n\n    return 0;\n}\n']",,,"['implementation', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Game 23.json,https://codeforces.com//blog/entry/66062,If is not divisible by then just print and stop the program Otherwise calculate denoting the required number of times to multiply It is easy to see that should be a product of zero or more s and of zero or more s i e for integers To find just use a loop to divide by while it is divisible by Similarly to find just use a loop to divide by while it is divisible by After the divisions the expected value of is If print Otherwise print the total number of the loop iterations 
https://codeforces.com//contest/1850/problem/E,2083771,E,1850E,1850,E. Cardboard for Pictures,Mircea has n pictures The i th picture is a square with a side length of s i centimeters He mounted each picture on a square piece of cardboard so that each picture has a border of w centimeters of cardboard on all sides In total he used c square centimeters of cardboard Given the picture sizes and the value c can you find the value of w Please note that the piece of cardboard goes behind each picture not just the border ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tll n, c;  cin >> n >> c;\n\tvector<ll> a(n);\n\tfor (auto &ai: a) {\n\t\tcin >> ai;\n\t}\n\tll lo = 0, hi = 1;\n\twhile (true) {\n\t\tll sum = 0;\n\t\tfor (auto ai: a) {\n\t\t\tsum += (ai + 2 * hi) * (ai + 2 * hi);\n\t\t}\n\t\tif (sum >= c)  break;\n\t\thi *= 2;\n\t}\n\n\twhile (lo <= hi) {\n\t\tll mid = (lo + hi) / 2;\n\t\tll sum = 0;\n\t\tfor (auto ai: a) {\n\t\t\tsum += (ai + 2 * mid) * (ai + 2 * mid);\n\t\t}\n\t\tif (sum >= c)  hi = mid - 1;\n\t\telse  lo = mid + 1;\n\t}\n\tcout << lo << ""\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']",,,"['binary search', 'geometry', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\E. Cardboard for Pictures.json,https://codeforces.com//blog/entry/118466,The key idea is to binary search on the answer If you don t know what that is you should read this Codeforces EDU article Let s make a function which tells us the total area of cardboard if we use a width of Then you can see that we can calculate in time as because the side length of the th cardboard is So this means that now we can binary search on the answer let s find the largest so that The maximum theoretical value of can be seen not to exceed since is not more than you can set an even lower bound A quick note about implementation the value of can exceed 64 bit numbers so you need to exit the function as soon as you get a value greater than or else you risk overflow So the time complexity is per test case which is equal to with some constant factor It s not that big to make it fail You can also use the quadratic formula but be careful about implementation of square root and precision issues 
https://codeforces.com//contest/1174/problem/B,353391,B,1174B,1174,B. Ehab Is an Odd Person,You re given an array a of length n You can perform the following operation on it as many times as you want Pick two integers i and j 1 le i j le n such that then swap a i and a j What is lexicographically the smallest array you can obtain An array x is lexicographically smaller than an array y if there exists an index i such that x i y i and x j y j for all 1 le j i Less formally at the first index i in which they differ x i y i ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> mypair;\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == \'-\') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - \'0\';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nint n, a[100005];\n\nint main()\n{\n\tn = read(); int even = 0, odd = 0;\n\tfor (int i = 1; i <= n; i ++) a[i] = read(), a[i] & 1 ? odd ++ : even ++;\n\tif (!even || !odd) \n\t{\n\t\tfor (int i = 1; i<= n; i ++) printf(""%d%c"", a[i], i == n ? 10 : 32);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tsort(a + 1, a + 1 + n);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tprintf(""%d%c"", a[i], i == n ? 10 : 32);\n\t}\n\t\n}']",,,['sortings'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Ehab Is an Odd Person.json,https://codeforces.com//blog/entry/67388,Notice that you can only swap 2 elements if they have different parities If all elements in the array have the same parity you can t do any swaps and the answer will just be like the input Otherwise let s prove you can actually swap any pair of elements Assume you want to swap 2 elements and and they have the same parity There must be a third element that has a different parity Without loss of generality assume the array is You ll do the following swaps In other words you ll use as an intermediate element to swap and and it ll return to its original position afterwards Since you can swap any pair of elements you can always sort the array which is the lexicographically smallest permutation Code link https pastebin com xhqGXLiu Time complexity 
https://codeforces.com//contest/1823/problem/C,1896869,C,1823C,1823,C. Strongly Composite,A number is an integer greater than 1 which has exactly two divisors For example 7 is a prime since it has two divisors 1 7 A number is an integer greater than 1 which has more than two different divisors Note that the integer 1 is neither prime nor composite Let s look at some composite number v It has several divisors some divisors are prime others are composite themselves If the number of prime divisors of v is to the number of composite divisors let s name v as For example number 12 has 6 divisors 1 2 3 4 6 12 two divisors 2 and 3 are prime while three divisors 4 6 and 12 are composite So 12 is strongly composite Other examples of strongly composite numbers are 4 8 9 16 and so on On the other side divisors of 15 are 1 3 5 15 3 and 5 are prime 15 is composite So 15 is not a strongly composite Other examples are 2 3 5 6 7 10 and so on You are given n integers a 1 a 2 dots a n a i 1 You have to build an array b 1 b 2 dots b k such that following conditions are satisfied Product of all elements of array a is equal to product of all elements of array b a 1 cdot a 2 cdot ldots cdot a n b 1 cdot b 2 cdot ldots cdot b k All elements of array b are integers greater than 1 and The size k of array b is the maximum possible Find the size k of array b or report that there is no array b satisfying the conditions ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,M=10000005;\n\nvector<int> pr;\nint lpd[M];\nvoid sieve(){\n    pr.clear();\n    for(int i=0; i<M; ++i) lpd[i]=-1;\n    for(int i=2; i<M; ++i){\n        if(lpd[i]==-1) lpd[i]=i,pr.pb(i);\n        for(auto p: pr){\n            if(p*i>=M) break;\n            lpd[p*i]=p;\n            if(i%p==0) break;\n        }\n    }\n}\nvector<int> factors(int x){\n    vector<int> res;\n    while(x>1) res.pb(lpd[x]),x/=lpd[x];\n    return res;\n}\n\nint n,a[N];\n\nvoid ldc(){\n    cin >> n;\n    map<int,int> mm;\n    for(int i=0; i<n; ++i){\n        int x; cin >> x;\n        vector<int> vec=factors(x);\n        for(auto j: vec) mm[j]++;\n    }\n    vector<int> vec;\n    for(auto [x,y]: mm) vec.pb(y);\n    sort(all(vec));\n    if(vec.back()==1&&sz(vec)<=2){\n        cout << ""0\\n"";\n        return;\n    }\n    int cnt1=0,cnt2=0;\n    for(auto i: vec) cnt1+=i>>1,cnt2+=i&1;\n    cout << cnt1+cnt2/3 << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    sieve();\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']",,,"['greedy', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Strongly Composite.json,https://codeforces.com//blog/entry/115465,Let s understand criteria for a number being strongly composite Let s factorize the number The number of all divisors of is Since the number of prime divisors is then the number of composite divisors of is Then a number is strongly composite if or Since is the number of then Consider a weakened condition for a strongly composite number If then the condition is satisfied only if If then the condition is satisfied only if If then the condition is always satisfied In summary a number is not strongly composite if it is either a prime or the product of two distinct primes Now let s solve the problem Let s split all numbers into primes Assume we have pairs where is a prime number and is the number of its occurrences We can take either two same prime numbers or three of any prime numbers The optimal strategy is to create the maximum number of pairs of same prime numbers and when there will be only different prime numbers remaining We can merge these remaining primes in triples to get extra strongly composite numbers If after merging triples we have some primes left we can add them to any already strongly composite number and it won t change its total number 
https://codeforces.com//contest/670/problem/E,59599,E,670E,670,E. Correct Bracket Sequence Editor,Recently Polycarp started to develop a text editor that works only with correct bracket sequences abbreviated as CBS Note that a bracket sequence is correct if it is possible to get a correct mathematical expression by adding s and s to it For example sequences and are correct while and are not Each bracket in CBS has a pair For example in 1st bracket is paired with 8th 2d bracket is paired with 3d 3d bracket is paired with 2d 4th bracket is paired with 7th 5th bracket is paired with 6th 6th bracket is paired with 5th 7th bracket is paired with 4th 8th bracket is paired with 1st Polycarp s editor currently supports only three operations during the use of CBS The cursor in the editor takes the whole position of one of the brackets not the position between the brackets There are three operations being supported move the cursor one position to the left move the cursor one position to the right delete the bracket in which the cursor is located delete the bracket it s paired to and all brackets between them that is delete a substring between the bracket in which the cursor is located and the one it s paired to After the operation the cursor moves to the nearest bracket to the right of course among the non deleted If there is no such bracket that is the suffix of the CBS was deleted then the cursor moves to the nearest bracket to the left of course among the non deleted There are pictures illustrated several usages of operation below All incorrect operations shift cursor over the end of CBS delete the whole CBS etc are not supported by Polycarp s editor Polycarp is very proud of his development can you implement the functionality of his editor ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)5e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nchar s[maxN];\nint rev[maxN];\nint n, m, q;\n\nset <int> available;\nset<int> ::iterator it;\n\nvoid makeDel() {\n    int l = *it;\n    int r = rev[l];\n    auto iter2 = available.lower_bound(rev[*it]);\n    if (l < r) {\n        iter2++;\n        available.erase(it, iter2);\n    } else {\n        it++;\n        available.erase(iter2, it);\n    }\n    it = available.upper_bound(l);\n    if (it == available.end()) it = prev(it);\n}\n\nint main() {\n\n   // freopen(""input.txt"", ""r"", stdin);\n   // freopen(""output.txt"", ""w"", stdout);\n\n    n = nextInt<int>();\n    m = nextInt<int>();\n    int p = nextInt<int>() - 1;\n    gets(s);\n    stack <int> st;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == \'(\') {\n            st.push(i);\n        } else {\n            rev[i] = st.top();\n            rev[st.top()] = i;\n            st.pop();\n        }\n        available.insert(i);\n    }\n    it = available.lower_bound(p);\n\n    for (int i =0; i < m; ++i) {\n        char ch = getchar();\n        if (ch == \'L\') {\n            it--;\n        } else if (ch == \'R\') {\n            it++;\n        } else {\n            makeDel();\n        }\n    }\n    for (auto x: available) putchar(s[x]);\n    return 0;\n}\n']",,,"['data structures', 'dsu', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Correct Bracket Sequence Editor.json,https://codeforces.com//blog/entry/44715,Let s solve this problem in the following way At first with help of stack let s calculate the array where equals to the position of the bracket which paired for the bracket in the position Then we need to use two arrays and Then will equals to the position of the closest to the left bracket which did not delete and will equals to the position of the closest to the right bracket which did not delete If there are no such brackets we will store 1 in the appropriate position of the array Let s the current position of the cursor equals to Then if the current operation equals to texttt L let s make and if the current operation equals to texttt R let s make We need now only to think how process the operation texttt D Let equals to and equals to If let s swap them Now we know the ends of the substring which we need to delete now If we need to move to the left else we need to move to the right Now we need to recalculate the links for the ends of the deleted substring Here we need to check is there any brackets which we did not deleted to the left and to the right from the ends of the deleted substring To print the answer we need to find the position of the first bracket which we did not delete and go through all brackets which we did not delete with help of the array and print all such brackets To find the position of the first bracket which we did not delete we can store in the array all pairs of the ends of substrings which we deleted then sort this array and find the needed position Bonus how we can find this position in the linear time 
https://codeforces.com//contest/1593/problem/G,1142168,G,1593G,1593,G. Changing Brackets,A sequence of round and square brackets is given You can change the sequence by performing the following operations change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket i e you can change to and to you can change to and to The operation costs 0 burles change any bracket to bracket having the same direction i e you can change to but from to similarly you can change to but from to The operation costs 1 burle The operations can be performed in any order any number of times You are given a string s of the length n and q queries of the type where 1 le l r le n For every substring s l dots r find the minimum cost to pay to make it a correct bracket sequence It is guaranteed that the substring s l dots r has an even length The queries must be processed independently i e the changes made in the string for the answer to a question i don t affect the queries j j i In other words for every query the substring s l dots r is given from the initially given string s A correct bracket sequence is a sequence that can be built according the following rules an empty sequence is a correct bracket sequence if is a correct bracket sequence the sequences and are correct bracket sequences if and are correct bracket sequences the sequence the concatenation of the sequences is a correct bracket sequence E g the sequences and are correct bracket sequences whereas and are not ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=1000005;\nint t,sum[N],q,l,r;\nstring s;\nint main() {\n   \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>s;\n        for (int i=0;i<s.length();i++) {\n            sum[i+1]=sum[i];\n            if (s[i]==\'[\'||s[i]==\']\') {\n                if (i%2) sum[i+1]++;\n                else sum[i+1]--;\n            }\n        }\n        cin>>q;\n        for (int i=1;i<=q;i++) {\n            cin>>l>>r;\n            cout<<abs(sum[r]-sum[l-1])<<""\\n"";\n        }\n    }\n}\n']",,,"['constructive algorithms', 'data structures', 'dp', 'greedy']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Changing Brackets.json,https://codeforces.com//blog/entry/96034,Consider a substring Let s call square brackets located in odd positions in the substring brackets and square brackets located in even positions brackets Let be the number of odd brackets be the number of even brackets be the number of all square brackets Let s prove that the string can be turned into a correct bracket sequence for burles if and only if Let s prove the necessary condition Suppose the initial substring has been turned into a correct bracket sequence Since we have paid burles there s no bracket which form has been changed Therefore for the new sequence is the same as for the initial sequence the similar situation happens with Let s say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets since it s a correct bracket sequence so the difference between their indices is odd In a correct bracket sequence each square bracket has a pairwise bracket Therefore a correct bracket sequence contains pairs of brackets so Let s prove the sufficient condition Suppose the initial substring contains equal numbers of odd and even brackets Let s prove by induction that the substring may be turned into a correct bracket sequence for burles Suppose So the initial substring contains only round brackets Let s make the first brackets opening and the other brackets closing The resulting sequence is a correct bracket sequence whereas we haven t changed the form of any bracket so the cost is equal to A correct bracket sequence has two important properties after deleting its substring being a correct bracket sequence the resulting string is a correct bracket sequence after inserting at any place any correct bracket sequence the resulting string is a correct bracket sequence These properties can be applied to an incorrect bracket sequence too after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one the resulting sequence is an incorrect bracket sequence Consider a substring such that Suppose we have proved before that each substring having decreased by can be turned into a correct bracket sequence for burles Let s find two square brackets such that one of them is odd and another one is even and there are no square brackets between them There s an even number of round brackets between them that can be turned into a correct bracket sequence for burles Let s make the left found bracket opening and the right one closing Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence Let s remove it from The resulting string contains odd brackets and even brackets so by the assumption of induction it can be turned into a correct bracket sequence for burles Let s do it and then insert the removed string into its place Since we insert a correct bracket sequence into a correct bracket sequence the resulting string is a correct bracket sequence Actually the operations of inserting and removing are not allowed they have been used for clarity the string can be turned into a correct bracket sequence without these operations as follows let s turn the substring we have removed into a correct bracket sequence as it was described above then change the other brackets of the string the same way as it was done with the string that was the result after removing The resulting string is a correct bracket sequence Therefore the illegal operations of inserting and removing are not necessary all other operations cost burles so the substring can be turned into a correct bracket sequence for burles Therefore to turn a substring into a correct bracket sequence we need to get a sequence such that Suppose initiallly Let s pay burles to replace odd brackets with round brackets If let s replace even brackets with round brackets Anyway we must pay burles We cannot pay less than this value because for a correct bracket sequence But there s no need to pay more than this value because if we turn the initial substring into a sequence with we can turn it into a correct bracket sequence for free Therfore the answer for a given question is Since we must answer the queries fast let s use a concept of prefix sums If the given string contains brackets let s create arrays and with the length will contain the number of odd brackets on the prefix of the string with the length the same value for even brackets Let s initialize and then iterate from to Let s initialize and If the th bracket is round then the current values are correct Otherwise let s find out what bracket is it If is odd the bracket is odd so we must increase by If is even the bracket is even so we must increase by To get the answer for a current and let s calculate and is a number of odd brackets that belong to the prefix with the length but not to the prefix with the length so Similarly The remaining thing is to output 
https://codeforces.com//contest/444/problem/E,11254,E,444E,444,E. DZY Loves Planting,DZY has a weighted tree connected undirected graph without cycles containing nodes they are numbered from to He defines the function as the longest edge in the shortest path between nodes and Specially for every For every integer sequence DZY defines as DZY wants to find such a sequence that has maximum possible value But there is one more restriction the element can appear in at most times Please find the maximum possible under the described restrictions ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define M 1000000007\n#define N 211111\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n;\npair<int, pt> q[3333];\nint p[3333], sz[3333], kol[3333];\nint maxsz, sum = 0, bad = 0;\n\nint get(int x) {\n\tif (p[x] == x) return x;\n\treturn p[x] = get(p[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = get(x);\n\ty = get(y);\n\tmaxsz = max(maxsz, sz[x] + sz[y]);\n\tsz[x] += sz[y];\n\tkol[x] += kol[y];\n\tif (kol[x] > sum - sz[x]) bad = 1;\n\n\n\tp[y] = x;\n}\n\nint main(){\n//\tfreopen(""1.in"",""r"",stdin);\t\n//\tfreopen(""1.out"",""w"",stdout);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tscanf(""%d%d%d"", &q[i].S.F, &q[i].S.S, &q[i].F);\n\t\tq[i].S.F--;\n\t\tq[i].S.S--;\n\t}\n\tsort(q, q + n - 1);\n\tint ans = 0;\n\tbad = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = i;\n\t\tscanf(""%d"", &sz[i]);\n\t\tkol[i] = 1;\n\t\tsum += sz[i];\n\t}\n\tfor (int i = 0; i < n; i++) if (kol[i] > sum - sz[i]) bad = 1;\n\tif (bad == 0 && n > 1) ans = q[0].F;\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint j = i;\n\t\twhile (j < n && q[j].F == q[i].F) {\n\t\t\tunite(q[j].S.F, q[j].S.S);\n\t\t\tj++;\n\t\t}\t\t\n\t\ti = j;\n\t\tif (bad == 0 && i < n) ans = q[i].F;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']",,,"['binary search', 'dsu', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. DZY Loves Planting.json,https://codeforces.com//blog/entry/12959,Firstly use binary search We need to determine whether the answer can be bigger than Then every pair must contain at least one edge which length is bigger than It s a problem like bipartite graph matching and we can use maxflow algorithm to solve it We create nodes for every node of the original tree We call one of the nodes and the other And we need a source and a terminal Link to every with upper bound and link to with upper bound Then if the path between node and node contains an edge with value larger than link and with upper bound This means they can match Every time we build such graph we must check pairs of nodes so number of edges of the network is We can make it better Consider the process of texttt Divide and Conquer of a tree This algorithm can either based on node or edge And The one based on edge is simpler in this problem Now there are two subtrees on two sides we record the maximum edge from every node to the current edge we split we call it Suppose is in and is in it is almost the same in contrast We create two new nodes in the network to represent the two subtrees Add edges is in and edges is in If is in and we add an edge If is in and we add an edge Then use maxflow algorithm The number of nodes in the network is and the number of edges in the network is So the total complexity is with really small constant Check the C code here This is what I supposed DIV1 E will be And thank subscriber for coming up with a really good algorithm with time complexity 7025382 And maybe others have the same idea This is my mistake and I feel sorry for not noticing that I m too naive and not good at solving problems Please forgive me 
https://codeforces.com//contest/581/problem/D,36593,D,581D,581,D. Three Logos,Three companies decided to order a billboard with pictures of their logos A billboard is a big board A logo of each company is a rectangle of a non zero area Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left When you put a logo on the billboard you should rotate it so that the sides were parallel to the sides of the billboard Your task is to determine if it is possible to put the logos of all the three companies on some square billboard without breaking any of the described rules ,"['#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint main()\n{\n    int a,b,c,d,e,f,ans=0,k=-1,n1,n2;\n    cin>>a>>b>>c>>d>>e>>f;\n    ans=a*b+c*d+e*f;\n    for(n1=1;n1<=1000;n1++)\n        if(n1*n1==ans)\n        {\n            k=n1;\n            break;\n        }\n    if(k==-1)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(b==k)\n        swap(a,b);\n    if(d==k)\n        swap(c,d);\n    if(f==k)\n        swap(e,f);\n    if(a==k&&c==k&&e==k)\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'A\');\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=d;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'B\');\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=f;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'C\');\n            printf(""\\n"");\n        }\n        return 0;\n    }\n    int sd=0;\n    if(c==k)\n    {\n        sd=1;\n        swap(a,c);\n        swap(b,d);\n    }\n    else\n    if(e==k)\n    {\n        sd=2;\n        swap(a,e);\n        swap(b,f);\n    }\n    if(a!=k)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(d==k-b)\n        swap(c,d);\n    if(f==k-b)\n        swap(e,f);\n    if(c!=k-b||e!=k-b)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'A\'+sd);\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=k-b;n1++)\n        {\n            if(sd!=1)\n            for(n2=1;n2<=d;n2++)\n                putchar(\'B\');\n            else\n            for(n2=1;n2<=d;n2++)\n                putchar(\'A\');   \n            if(sd!=2)                       \n            for(n2=1;n2<=f;n2++)\n                putchar(\'C\');\n            else\n            for(n2=1;n2<=f;n2++)\n                putchar(\'A\');\n            printf(""\\n"");\n        }\n        return 0;\n    }           \n}\n']",,,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Three Logos.json,https://codeforces.com//blog/entry/20508,This problem can be solved in many ways let s consider one of them The first step is to calculate sum of squares s of given rectangles Then the side of a answer square is sqrt s If sqrt s is not integer print 1 Else we need to make the following We brute the order in which we will add given rectangles in the answer square we can do it with help of next permutation and for every order we brute will we rotate current rectangle on 90 degrees or not we can do it with help of bit masks In the beginning on every iteration the answer square c in which we add the rectangles is empty For every rectangle which we add to the answer square we make the following we need to find the uppermost and leftmost empty cell free in answer square c recall that we also brute will we rotate the current rectangle on 90 degrees or not Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added we need to fill by the required letter appropriate cells in the answer square c If no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c Else if we did not find answer after all iterations on the rectangles print 1 For random number of the rectangles k asymptotic behavior O k 2k s where s the sum of squares of the given rectangles Also this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O s where s the sum of squares of given rectangles 
https://codeforces.com//contest/350/problem/B,3563,B,350B,350,B. Resort,Valera s finally decided to go on holiday He packed up and headed for a ski resort Valera s fancied a ski trip but he soon realized that he could get lost in this new place Somebody gave him a useful hint the resort has objects we will consider the objects indexed in some way by integers from to each object is either a hotel or a mountain Valera has also found out that the ski resort had multiple ski tracks Specifically for each object the resort has at most one object such that there is a ski track built from object to object We also know that no hotel has got a ski track leading from the hotel to some object Valera is afraid of getting lost on the resort So he wants you to come up with a path he would walk along The path must consist of objects and meet the following conditions Objects with numbers are mountains and the object with number is the hotel For any integer there is ski track leading from object This track goes to object The path contains as many objects as possible is maximal Help Valera Find such path that meets all the criteria of our hero ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int NMax=100000;\nint N,A[NMax],T[NMax],C[NMax];\nint main()\n{\n    scanf(""%d"",&N);\n    for (int i=0;i<N;i++)\n        scanf(""%d"",T+i);\n    for (int i=0;i<N;i++){\n        scanf(""%d"",A+i);\n        A[i]--;\n    }\n    for (int i=0;i<N;i++)\n        C[i]=0;\n    for (int i=0;i<N;i++)\n        if (A[i]!=-1)\n            C[A[i]]++;\n    int ret=0,reti=-1;\n    for (int i=0;i<N;i++)\n        if (T[i]==1){\n            int c=1;\n            int j=i;\n            while (A[j]!=-1 && C[A[j]]==1){\n                j=A[j];\n                c++;\n            }\n            if (c>ret){\n                ret=c;\n                reti=i;\n            }\n        }\n    printf(""%d\\n"",ret);\n    vector<int> output;\n    for (int i=0;i<ret;i++){\n        output.push_back(reti);\n        reti=A[reti];\n    }\n    for (int i=0;i<ret;i++){\n        if (i)\n            printf("" "");\n        printf(""%d"",output[ret-1-i]+1);\n    }\n    puts("""");\n    return 0;\n}\n']",,,['graphs'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Resort.json,https://codeforces.com//blog/entry/9042,Input data represents a graph by using a array of parents of every vertex Because every vertex has at most one parent we can use following solution we will go up to parent of vertex until not found vertex with the outcome degree It is better to calculate outcome degrees in advance After all we will update the answer This algorithm works in Author solution 4632399 
https://codeforces.com//contest/1458/problem/A,837942,A,1458A,1458,A. Row GCD,You are given two positive integer sequences a 1 ldots a n and b 1 ldots b m For each j 1 ldots m find the greatest common divisor of a 1 b j ldots a n b j ,"['/**\n *    author:  tourist\n *    created: 19.12.2020 12:31:44       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  long long g = 0;\n  for (int i = 1; i < n; i++) {\n    g = __gcd(g, abs(a[i] - a[0]));\n  }\n  for (int i = 0; i < m; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << __gcd(g, a[0] + b[i]);\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']",,,"['math', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Row GCD.json,https://codeforces.com//blog/entry/85750,From basic properties of GCD we know that GCD x y GCD x y y The same applies for multiple arguments GCD x y z GCD x y y z Let s use this for GCD a1 bj an bj and subtract a1 bj from all other arguments GCD a1 bj an bj GCD a1 bj a2 a1 an a1 If we find G GCD a2 a1 an a1 then any answer can be found as GCD a1 bj G Note that we have to assume that GCD of an empty set is 0 and GCD x 0 x for any x since 0 is the only number divisible by any other number 
https://codeforces.com//contest/189/problem/B,1317,B,189B,189,B. Counting Rhombi,You have two positive integers and Your task is to count the number of rhombi which have the following properties Have positive area With vertices at integer points All vertices of the rhombi are located inside or on the border of the rectangle with vertices at points In other words for all vertices of the rhombus the following conditions should fulfill and Its diagonals are parallel to the axis Count the number of such rhombi Let us remind you that a is a quadrilateral whose four sides all have the same length ,"['/*\n * Author: code6\n * Created Time:  2012/5/10 23:40:52\n * File Name: B.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n#define out(v) cerr << #v << "": "" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntypedef long long ll;\nconst double PI=acos(-1.0);\nconst double eps=1e-11;\n\nint main() {\n    int w, h;\n    cin>>w>>h;\n    int i, j;\n    long long ans = 0;\n    for (i = 1; i < w; i++) {\n        for (j = 1; j < h; j++) {\n            ans += min(i, w - i) * min(j, h - j);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n']",,,"['brute force', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Counting Rhombi.json,https://codeforces.com//blog/entry/4540,Observe that lots of rhombi have the same shape but are in different locations What uniquely determines the shape of a rhombus Its width and its height Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points No it is possible only if the width and the height are both even How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h w w0 1 h h0 1 So iterator over all even widths and heights and for each of them add the number of possible locations to the final result 
https://codeforces.com//contest/1268/problem/C,499894,C,1268C,1268,C. K Integers,You are given a permutation p 1 p 2 ldots p n In one move you can swap two adjacent values You want to perform a minimum number of moves such that in the end there will exist a subsegment 1 2 ldots k in other words in the end there should be an integer i 1 leq i leq n k 1 such that p i 1 p i 1 2 ldots p i k 1 k Let f k be the minimum number of moves that you need to make a subsegment with values 1 2 ldots k appear in the permutation You need to find f 1 f 2 ldots f n ,"['/**\n *    author:  tourist\n *    created: 21.12.2019 14:12:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nclass segtree {\n public:\n  struct node {\n    // don\'t forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    long long L = 0;\n    long long R = 0;\n    int alive = 1;\n    int addL = 0;\n    int addR = 0;\n\n    void apply(int l, int r) {\n      alive = 0;\n      L = R = 0;\n      addL = addR = 0;\n    }\n\n    void apply(int l, int r, int v, char c) {\n      if (c == \'L\') {\n        L += (long long) alive * v;\n        addL += v;\n      }\n      if (c == \'R\') {\n        R += (long long) alive * v;\n        addR += v;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.L = a.L + b.L;\n    res.R = a.R + b.R;\n    res.alive = a.alive + b.alive;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].addL != 0) {\n      tree[x + 1].apply(l, y, tree[x].addL, \'L\');\n      tree[z].apply(y + 1, r, tree[x].addL, \'L\');\n      tree[x].addL = 0;\n    }\n    if (tree[x].addR != 0) {\n      tree[x + 1].apply(l, y, tree[x].addR, \'R\');\n      tree[z].apply(y + 1, r, tree[x].addR, \'R\');\n      tree[x].addR = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    pos[p[i]] = i;\n  }\n  fenwick<int> fenw(n);\n  vector<long long> res(n);\n  long long inv = 0;\n  segtree st(n);\n  for (int it = 0; it < n; it++) {\n    int at = pos[it];\n    inv += fenw.get(n - 1) - fenw.get(at);\n    fenw.modify(at, +1);\n    if (at > 0) {\n      st.modify(0, at - 1, 1, \'R\');\n    }\n    if (at < n - 1) {\n      st.modify(at + 1, n - 1, 1, \'L\');\n    }\n    st.modify(at, at);\n    int med = -1;\n    {\n      int low = 0, high = n - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        int s = fenw.get(mid);\n        if (s >= it / 2 + 1) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      med = low;\n    }\n    res[it] = inv;\n    if (med > 0) {\n      res[it] += st.get(0, med - 1).L;\n    }\n    if (med < n - 1) {\n      res[it] += st.get(med + 1, n - 1).R;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << res[i];\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']",,,"['binary search', 'data structures']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. K Integers.json,https://codeforces.com//blog/entry/72358,At first let s add to the answer number of inversions among numbers 1 2 k After that let s say that x k is one and x k is zero Then you need to calculate the smallest number of swaps to make segment 1 1 1 of length k appear in the permutation For this let s call pi the number of ones on the prefix For all si 0 we need to add min pi k pi to the answer it is an obvious lower bound and it is simple to prove that we always can do one operation to reduce this total value by one How to calculate this for each k Let s move k from 1 to n You can maintain number of inversions with BIT To calculate the second value you can note that you just need to find k2 th number k and add values at the left and add the right with different coefficients To maintain them you can recalculate everything when you are moving the median in heap But also it is possible to maintain the segment tree by pi and just take some sum 
https://codeforces.com//contest/1034/problem/B,222951,B,1034B,1034,B. Little C Loves 3 II,Little C loves number very much He loves all things about it Now he is playing a game on a chessboard of size n times m The cell in the x th row and in the y th column is called x y Initially The chessboard is empty Each time he places two chessmen on two different empty cells the Manhattan distance between which is exactly 3 The Manhattan distance between two cells x i y i and x j y j is defined as x i x j y i y j He want to place as many chessmen as possible on the chessboard Please help him find the maximum number of chessmen he can place ,"['#include<cstdio>\nlong long calc(int n,int m){\n\tif(n==1)return m/6*6+(m%6<3?0:m%6-3)*2;\n\tif(n==2){\n\t\tif(m==2)return 0;\n\t\tif(m==3||m==7)return 1ll*n*m-2;\n\t\treturn 1ll*n*m;\n\t}\n\tif(n%2==1&&m%2==1)return 1ll*n*m-1;\n\treturn 1ll*n*m;\n}\nint main(){\n\tint n,m;\n\tscanf(""%d%d"",&n,&m);\n\tif(n>m){int t=n;n=m;m=t;}\n\tprintf(""%lld\\n"",calc(n,m));\n}\n']",,,"['brute force', 'constructive algorithms', 'flows', 'graph matchings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Little C Loves 3 II.json,https://codeforces.com//blog/entry/61993,Following the rules in the problem the and grids full of chessmen can be easily constructed How to construct Let the number denote the time when the chessman placed Grids of 1 2 3 1 2 3Grids of 1 2 3 43 4 1 2Grids of 1 3 2 1 52 4 5 3 4Grids of 1 3 4 25 2 1 56 4 3 6Assume that Consider the following cases If obviously the answer is If only the and grids cannot be completely constructed The others can be constructed by using the and constructed by two grids girds How to prove that they cannot be constructed You can write a brute force or enumerate all the possibilities by yourself If you consider each grid from left to right and choose the grid it matched with there are only several possible conditions So I think it can be proved in several minutes If the following things we can consider We know that using the and grids we can construct the grid and using several grids we can construct the grid so using the and grids we can construct the grid while and is an even number Therefore we only need to consider the grid that and are both odd numbers Since is an odd integer we can place chessmen at most so we try to reach the maximum Then we can easily construct the and grids that have only one empty grid According to the above mentioned conclusions any grids can be reduce to one of the three grids by using some or is even grids The maximum is reached How to construct Grids of 1 2 33 0 44 1 2Grids of 1 3 4 6 72 5 1 0 53 4 2 7 6Grids of 1 2 3 1 23 4 5 6 45 6 7 8 910 8 9 12 711 12 10 11 0It seems that the chessboard is a little bit big but you can match them arbitrarily and get correct solution with a big possibility 
https://codeforces.com//contest/2044/problem/B,3086853,B,2044B,2044,B. Normal Problem,A string consisting of only characters p q and w is painted on a glass window of a store Ship walks past the store standing directly in front of the glass window and observes string a Ship then heads inside the store looks directly at the same glass window and observes string b Ship gives you string a Your job is to find and output b ,"['#include<bits/stdc++.h>#define int long longusing namespace std;const int N = 1e5+5;int t;string s;main(){    cin>>t;    while(t--){        cin>>s;        int cc = s.size();        for(int i = cc - 1 ; i >= 0 ; i--){            if(s[i] == \'q\') cout<<""p"";            else if(s[i] == \'p\') cout<<""q"";            else cout<<""w"";        }        cout<<\'\\n\';    }}']",,,"['implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\B. Normal Problem.json,https://codeforces.com//blog/entry/137306,Problem Credits Lilypad Analysis Lilypad macaquedev Solution The letters she reads that comprise string are just the letters that comprise string flipped left to right This means that p becomes q q becomes p and w stays w since it is vertically symmetrical The order in which the letters are read is also reversed because what used to be the left side of string gets flipped over to the right side of string and vice versa We now have an algorithm for constructing string which is to iterate from right to left on string outputting p when there is a q q when there is a p and w when there is a w 
https://codeforces.com//contest/721/problem/C,73869,C,721C,721,C. Journey,Recently Irina arrived to one of the most famous cities of Berland the Berlatov city There are showplaces in the city numbered from to and some of them are connected by one directional roads The roads in Berlatov are designed in a way such that there cyclic routes between showplaces Initially Irina stands at the showplace and the endpoint of her journey is the showplace Naturally Irina wants to visit as much showplaces as she can during her journey However Irina s stay in Berlatov is limited and she can t be there for more than time units Help Irina determine how many showplaces she may visit during her journey from showplace to showplace within a time not exceeding It is guaranteed that there is at least one route from showplace to showplace such that Irina will spend no more than time units passing it ,"['#include<bits/stdc++.h>\n#define N 5005\nusing namespace std;\n\nint d[N][N],pre[N][N],tot,fst[N],nxt[N],pnt[N],len[N],n,m,t; bool vis[N];\nvoid add(int x,int y,int z){pnt[++tot]=y;len[tot]=z;nxt[tot]=fst[x];fst[x]=tot;}\nvoid dp(int x){\n\tint i,j,y;\n\tif (vis[x]) return; vis[x]=1;\n\t\tif (x==1) d[x][1]=0;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];dp(y);\n\t\tfor (j=1; j<=n; j++)\n\t\t\tif (d[y][j-1]+len[i]<d[x][j]){\n\t\t\t\td[x][j]=d[y][j-1]+len[i]; pre[x][j]=y;\n\t\t\t}\n\t}\n}\nvoid solve(int x,int y){\n\tif (y>1) solve(pre[x][y],y-1);printf(""%d "",x);\n}\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&t);\n\tint i,x,y,z;\n\tfor (i=1; i<=m; i++){\n\t\tscanf(""%d%d%d"",&x,&y,&z);\n\t\tadd(y,x,z);\n\t}\n\tmemset(d,0x3f,sizeof(d));\n\t//cout<<d[0][0]<<endl;\n\tdp(n);\n\tfor (i=n; i; i--) if (d[n][i]<=t) break;\n\t//\tcout<<d[n][i]<<endl;\n\tprintf(""%d\\n"",i);\n\tsolve(n,i);\n\treturn 0;\n}\n']",,,"['dp', 'graphs']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Journey3970.json,https://codeforces.com//blog/entry/47457,Author s solution uses dynamic programming Let be the minimum time required to arrive at the vertex if we visit vertices including vertices and We have a DAG directed acyclic graph so we can compute it recursively and memory constraints were a bit strict in this problem so it s better to use recursion to compute it Let s store the transposed version of the graph if we had an edge in the input we will store Then our function which will compute the answer for will be like that the base of dynamic programming is all other states are equal to 1 If we call then it will work like that if the state we want to compute is incorrect we return a very large integer number any number that is greater than because If the answer for this state has already been calculated then we return it is easy do determine if then it has already been calculated Else we begin to calculate the state Firstly let s put a number greater than into Then look at all the edges beginning in and try to update with the value of is the vertex at the endpoint of current edge is the weight of this edge If this value is less than then we update and store the information that our last update in was from the vertex If we try to go by path which doesn t end in the vertex then we get a value which is greater than that s because that the only value we didn t denote as is So now we have our function let s compute the answer We will iterate on the number of vertices in the path from to in descending order and if then we have found the answer now we iterate on the parent vertices we stored while calculating our until we come to vertex it s important because some participants sent solutions that continued even past vertex and print the answer Time complexity of this solution and mempry complexity 
https://codeforces.com//contest/797/problem/C,103030,C,797C,797,C. Minimal string,Petya recieved a gift of a string with length up to characters for his birthday He took two more empty strings and and decided to play a game This game has two possible moves Extract the character of and append with this character Extract the character of and append with this character Petya wants to get strings and empty and string lexicographically minimal You should write a program that will help Petya win the game ,"['// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e5 + 5, mod = (int) 0;\nint best[N], q[N];\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = (int) s.size();\n\tbest[n] = 1e9;\n\tfor (int j = n - 1; j >= 0; --j) {\n\t\ts[j] -= \'a\';\n\t\tbest[j] = min(best[j + 1], (int) s[j]);\n\t}\n\tstring res = """";\n\tint t = 0;\n\tfor (int j = 0; j < n; ++j) {\n\t\tq[t++] = s[j];\n\t\twhile (t > 0 && q[t - 1] <= best[j + 1]) res += char(q[t - 1] + \'a\'), --t;\n\t}\n\tcout << res << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",,,"['data structures', 'greedy', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Minimal string.json,https://codeforces.com//blog/entry/51588,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case 
https://codeforces.com//contest/1711/problem/C,1478274,C,1711C,1711,C. Color the Picture,A picture can be represented as an n times m grid n rows and m columns so that each of the n cdot m cells is colored with one color You have k pigments of different colors You have a limited amount of each pigment more precisely you can color at most a i cells with the i th pigment A picture is considered beautiful if each cell has 3 neighbors with the same color as itself Two cells are considered neighbors if they share an edge In other words for some integers 1 leq x 1 x 2 leq n and 1 leq y 1 y 2 leq m the cell in the x 1 th row and y 1 th column is a toroidal neighbor of the cell in the x 2 th row and y 2 th column if one of following two conditions holds x 1 x 2 equiv pm1 pmod n and y 1 y 2 or y 1 y 2 equiv pm1 pmod m and x 1 x 2 Notice that each cell has exactly 4 toroidal neighbors For example if n 3 and m 4 the toroidal neighbors of the cell 1 2 the cell on the first row and second column are 3 2 2 2 1 3 1 1 They are shown in gray on the image below Is it possible to color all cells with the pigments provided and create a beautiful picture ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint T,n,m,k;\nint arr[100000];\n#define ll long long int\n\nint main(void)\n{\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d%d"",&n,&m,&k);\n\t\tfor(int i=0;i<k;i++)\n\t\t\tscanf(""%d"",&arr[i]);\n\t\tbool n3=0,m3=0;\n\t\tll ns=0,ms=0;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tif(arr[i]>=n*2) ns+=arr[i]/n;\n\t\t\tif(arr[i]>=n*3) n3=1;\n\t\t\tif(arr[i]>=m*2) ms+=arr[i]/m;\n\t\t\tif(arr[i]>=m*3) m3=1;\n\t\t}\n\t\tif(ns>=m&&(n3==1||m%2==0))\n\t\t\tprintf(""Yes\\n"");\n\t\telse if(ms>=n&&(m3==1||n%2==0))\n\t\t\tprintf(""Yes\\n"");\n\t\telse printf(""No\\n"");\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Color the Picture.json,https://codeforces.com//blog/entry/105232,Let s first prove hint1 first If there is a pair of toroidal neighbors with different colors For example colx y a and colx 1 y b a b Then we will find colx 1 y colx y 1 colx y 1 a colx 2 y colx 1 y 1 colx 1 y 1 b must hold Then we find another two pairs of toroidal neighbors colx y 1 colx 1 y 1 and colx y 1 colx 1 y 1 Repeat such process we will find the boundary should be like Similar the boundaries can be vertical lines but horizontal lines and vertical lines can not exist in one picture So the pattern should be row stripes all with at least 2 rows or column stripes all with at least 2 columns Check if one can draw a beautiful picture with row stripes only or with column stripes only We consider only the case of row stripes the reasoning is analogous for column stripes If it is possible then ai 2m aim n must hold If n is even then such a condition is enough If n is odd there must be some aim 3 In this case you can draw a beautiful picture using such algorithm Sort ai from large to small Draw 2 rows stripes of each color if possible If the picture still has some rows empty insert new rows into each stripe 
https://codeforces.com//contest/148/problem/E,883,E,148E,148,E. Porcelain,During her tantrums the princess usually smashes some collectable porcelain Every furious shriek is accompanied with one item smashed The collection of porcelain is arranged neatly on shelves Within each shelf the items are placed in one row so that one can access only the outermost items the leftmost or the rightmost item not the ones in the middle of the shelf Once an item is taken the next item on that side of the shelf can be accessed see example Once an item is taken it can t be returned to the shelves You are given the values of all items Your task is to find the maximal damage the princess tantrum of shrieks can inflict on the collection of porcelain ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint dp[111][11111],sum[111];\nint a[111][111];\nint main()\n{\n    int i,j,k,n,m;\n    scanf(""%d%d"",&n,&m);\n    clr(a);\n    for (i=0;i<n;i++)\n    {\n        int c;\n        int v[111];\n        scanf(""%d"",&c);\n        for (j=1;j<=c;j++)\n        {\n            scanf(""%d"",v+j);\n        }\n        clr(sum);\n        sum[0]=0;\n        for (j=1;j<=c;j++)\n        {\n            sum[j]=sum[j-1]+v[j];\n        }\n        for (j=1;j<=c;j++)\n        {\n            for (k=0;k<=j;k++)\n            {\n                int t=sum[k]+sum[c]-sum[c-(j-k)];\n                a[i][j]=max(a[i][j],t);\n            }\n        }\n    }\n    //printf(""%d\\n"",a[0][3]);\n    memset(dp,200,sizeof(dp));\n    dp[0][0]=0;\n    for (i=0;i<n;i++)\n    {\n        for (j=0;j<=m;j++)if (dp[i][j]>=0)\n        {\n            for (k=0;k<=100&&j+k<=m;k++)\n            {\n                dp[i+1][j+k]=max(dp[i+1][j+k],dp[i][j]+a[i][k]);\n            }\n        }\n    }\n    printf(""%d\\n"",*max_element(dp[n],dp[n]+m+1));\n    return 0;\n}\n']",,,['dp'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Porcelain.json,https://codeforces.com//blog/entry/3819,This problem involved dynamic programming with precalculation The first part of the solution was to precalculate the maximal cost of i items taken from the shelf i ranging from 1 to the number of items on the shelf for each shelf Note that this can t be done greedily this can be seen on the shelf 6 5 1 10 1 1 5 The second part is a standard dynamic programming which calculates the maximal cost of items taken for index of last shelf used and total number of items taken To advance to the next shelf one has to try all possible numbers of items taken from it and increase the total cost of items taken by corresponding precalculated values 
https://codeforces.com//contest/557/problem/A,30553,A,557A,557,A. Ilya and Diplomas,Soon a school Olympiad in Informatics will be held in Berland schoolchildren will participate there At a meeting of the jury of the Olympiad it was decided that of the participants depending on the results will get a diploma of the first second or third degree Thus each student will receive exactly one diploma They also decided that there must be given at least and at most diplomas of the first degree at least and at most diplomas of the second degree and at least and at most diplomas of the third degree After some discussion it was decided to choose from all the options of distributing diplomas satisfying these limitations the one that maximizes the number of participants who receive diplomas of the first degree Of all these options they select the one which maximizes the number of the participants who receive diplomas of the second degree If there are multiple of these options they select the option that maximizes the number of diplomas of the third degree Choosing the best option of distributing certificates was entrusted to Ilya one of the best programmers of Berland However he found more important things to do so it is your task now to choose the best option of distributing of diplomas based on the described limitations It is guaranteed that the described limitations are such that there is a way to choose such an option of distributing diplomas that all participants of the Olympiad will receive a diploma of some degree ,"[""#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n; cin >> n; \n    int min1, max1, min2, max2, min3, max3; \n    cin >> min1 >> max1 >> min2 >> max2 >> min3 >> max3;\n    int first = min(max1, n-min2-min3); \n    n-=first; \n    int second = min (max2, n-min3); \n    n-=second;\n    cout << first << ' ' << second << ' '<< n;\n    return 0;\n}""]",,,"['greedy', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Ilya and Diplomas.json,https://codeforces.com//blog/entry/18943,This problem can be solved in the different ways We consider one of them parsing cases If max1 min2 min3 n then the optimal solution is n min2 min3 min2 min3 Else if max1 max2 min3 n then the optimal solution is max1 n max1 min3 min3 Else the optimal solution is max1 max2 n max1 max2 This solution is correct because of statement It is guaranteed that min1 min2 min3 n max1 max2 max3 
https://codeforces.com//contest/722/problem/C,74001,C,722C,722,C. Destroying Array,You are given an array consisting of non negative integers You are going to destroy integers in the array one by one Thus you are given the permutation of integers from to defining the order elements of the array are destroyed After each element is destroyed you have to find out the segment of the array such that it contains no destroyed elements and the sum of its elements is maximum possible The sum of elements in the empty segment is considered to be ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nint A[100000];\nint P[100000];\nbool ok[100000];\nint fa[100000];\nlong long s[100000];\nlong long ans[100000];\n\nint find(int u)\n{\n    if(fa[u]!=u)\n        fa[u]=find(fa[u]);\n    return fa[u];\n}\n\nvoid merge(int u, int v)\n{\n    u=find(u), v=find(v);\n    fa[u]=v;\n    s[v]+=s[u];\n}\n\nint main()\n{\n    scanf(""%d"", &N);\n    for(int i=0; i<N; i++)\n        scanf(""%d"", A+i);\n    for(int i=0; i<N; i++)\n    {\n        scanf(""%d"", P+i);\n        P[i]--;\n        fa[i]=i;\n    }\n    long long rans=0;\n    for(int i=N-1; i>=0; i--)\n    {\n        s[P[i]]=A[P[i]];\n        if(P[i]>0 && ok[P[i]-1])\n            merge(P[i], P[i]-1);\n        if(P[i]+1<N && ok[P[i]+1])\n            merge(P[i], P[i]+1);\n        ok[P[i]]=true;\n        ans[i]=rans;\n        rans=max(rans, s[find(P[i])]);\n    }\n    for(int i=0; i<N; i++)\n        printf(""%lld\\n"", ans[i]);\n    return 0;\n}\n']",,,"['data structures', 'dsu']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Destroying Array.json,https://codeforces.com//blog/entry/47497,Main observation that was necessary to solve the problem since all numbers are non negative it makes sense to consider only subsegments maximal with respect to inclusion That is such segments on both sides of which there are either destroyed numbers or the end of the array Let s solve the problem in reversed order first destroy all the numbers and then add them back We will carry a single value the current maximum sum among all subsegments After destroying all the numbers the answer is equal to zero Now we add a new number on each step To find the maximum subsegment containing this number we need to find the nearest to the left and to the right destroyed number This can be done in using binary search tree f e set from STL To find the sum of the numbers in the subsegment we can compute partial sums of the original array Thus at each step we can update the maximum sum among all subsegments in time The total complexity of this solution is 
https://codeforces.com//contest/1782/problem/F,1738312,F,1782F,1782,F. Bracket Insertion,Vika likes playing with bracket sequences Today she wants to create a new bracket sequence using the following algorithm Initially Vika s sequence is an empty string and then she will repeat the following actions n times Choose a place in the current bracket sequence to insert new brackets uniformly at random If the length of the current sequence is k then there are k 1 such places before the first bracket between the first and the second brackets ldots after the k th bracket In particular there is one such place in an empty bracket sequence Choose string with probability p or string with probability 1 p and insert it into the chosen place The length of the bracket sequence will increase by 2 A bracket sequence is called if it is possible to obtain a correct arithmetic expression by inserting characters and into it For example sequences and are regular while and are not Vika wants to know the probability that her bracket sequence will be a regular one at the end Help her and find this probability modulo 998 244 353 see Output section ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1007, mod = 998244353;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) (mod - mod / i) * inv[mod % i] % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n} \nint C(int x, int y) {\n\treturn x < y || y < 0 ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint n, p, dp[N][N], f[N][N];\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> p;\n\tinit(n * 2);\n\tp = (ll) p * qpow(10000) % mod;\n\tL(i, 0, n) dp[i][0] = 1, f[i][0] = 1;\n\tL(len, 1, n) {\n\t\tL(h, 0, n) { \n\t\t\tL(i, 0, len - 1) \n\t\t\t\t(dp[h][len] += (ll) f[h][i] * \n\t\t\t\t\t((ll) p * dp[h + 1][len - i - 1] % mod + \n\t\t\t\t\t(h == 0 ? 0 : (ll) (mod + 1 - p) * dp[h - 1][len - i - 1] % mod)) % mod\n\t\t\t\t\t* C(len - 1, i) % mod) %= mod;\n//\t\t\tL(i, 0, len - 1) {\n//\t\t\t\tL(j, 0, len - 1 - i) {\n//\t\t\t\t\t(dp[h][len] += (ll) dp[h][i] * dp[h][j] % mod * \n//\t\t\t\t\t\t((ll) p * dp[h + 1][len - i - j - 1] % mod + \n//\t\t\t\t\t\t(h == 0 ? 0 : (ll) (mod + 1 - p) * dp[h - 1][len - i - j - 1] % mod)) % mod\n//\t\t\t\t\t\t* C(len - 1, i + j) % mod * C(i + j, i) % mod) %= mod;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tL(i, 0, len)\n\t\t\t\t(f[h][len] += (ll) dp[h][i] * dp[h][len - i] % mod * C(len, i) % mod) %= mod;\n\t\t}\n\t}\n\tint ns = dp[0][n];\n\tL(i, 1, n) \n\t\tns = (ll) ns * inv[i * 2 - 1] % mod;\n\tcout << ns << '\\n';\n\treturn 0;\n} ""]",,,"['combinatorics', 'dp', 'probabilities', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Bracket Insertion.json,https://codeforces.com//blog/entry/111783,Instead of looking at a probabilistic process we can consider all possible ways of inserting brackets There are ways of choosing places and ways of choosing or at every point Let be the sum of over all such ways that lead to a regular bracket sequence where is the number of strings inserted during the process and is then the number of strings inserted Then is the answer to the problem Consider the sequence of prefix balances of the bracket sequence The first empty prefix balance is and each successive balance is larger than the previous one if the next bracket is and smaller if the bracket is Initially when the bracket sequence is empty the sequence of prefix balances is Whenever we insert into the bracket sequence in a place with prefix balance essentially we are replacing with in the sequence of prefix balances Whenever we insert instead that s equivalent to replacing with A bracket sequence is regular if and only if its corresponding sequence of prefix balances does not have any negative integers and ends with however this is guaranteed in our setting Thus we can reformulate the problem as follows Initially we have an integer array times we choose an integer from the array uniformly at random Say this integer is then we replace with with probability and with with probability What is the probability that the sequence will not contain negative integers at any point Let be the sought probability multiplied by if we start with Here we multiply by to simplify the formulas and to keep thinking about numbers of ways instead of probabilities as described in the first paragraph of this tutorial The base cases are if and otherwise When What does this formula mean Essentially since we start with an array of a single integer the first operation has to be applied to After that once gets replaced with operations will be applied to the left including everything produced from it operations will be applied to again together with its production and operations will be applied to the right and to its production Thus we can find the sum over and of the product of the corresponding values of and the binomial coefficients since the sequences of and operations can be interleaved arbitrarily we have ways to choose the positions of operations applied to the left in the global sequence of operations and then ways to choose the positions of operations applied to out of the remaining positions in the global sequence This results in an solution since there are values of to calculate and each of them is calculated in To optimize it let s rewrite the formula a little bit by moving the loop over outside Now let s introduce an auxiliary function Now let s rewrite the formula for using Now both and can be computed in time resulting in an solution 
https://codeforces.com//contest/1626/problem/E,1263151,E,1626E,1626,E. Black and White Tree,You are given a tree consisting of n vertices Some of the vertices at least two are black all the other vertices are white You place a chip on one of the vertices of the tree and then perform the following operations let the current vertex where the chip is located is x You choose a black vertex y and then move the chip along the first edge on the simple path from x to y You are not allowed to choose the same black vertex y in two operations in a row i e for every two consecutive operations the chosen black vertex should be different You end your operations when the chip moves to the black vertex if it is initially placed in a black vertex you don t perform the operations at all or when the number of performed operations exceeds 100 500 For every vertex i you have to determine if there exists a possibly empty sequence of operations that moves the chip to some black vertex if the chip is initially placed on the vertex i ,"['#pragma region Macros\n//#pragma GCC target(""avx2"")\n// #pragma GCC optimize(""O3"")\n// #pragma comment(linker, ""/stack:200000000"")\n#ifdef ONLINE_JUDGE\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2"")\n// #pragma GCC target(""avx2"")\n#endif\n#pragma GCC optimize(""Ofast"")\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl \'\\n\'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= b; i -= c)\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define rng(v, l, r) v.begin() + l, v.begin() + r\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {""NO"", ""YES""};\nconst string YesNo[2] = {""No"", ""Yes""};\nconst string yesno[2] = {""no"", ""yes""};\nconst string firstsecond[2] = {""second"", ""first""};\nconst string FirstSecond[2] = {""Second"", ""First""};\nconst string possiblestr[2] = {""impossible"", ""possible""};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\n\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\n// bit \nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - \'0\'; }\n    }\n    if(s[0] == \'-\') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << ""0""); }\n    i128 num = v;\n    if(v < 0) {\n        os << \'-\';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + \'0\'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? "", "" : "" "");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << \'(\'; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << \')\'; }\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << ""("" << p.first << "", "" << p.second << "")""; }\n    return os << p.first << "" "" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << ""["";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? """" : "", "") << y;\n        else\n            os << (f ? """" : "" "") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << ""]"";\n    return os;\n}\n\n#ifdef noimi\n#undef endl\nvoid debug() { cerr << endl; }\nvoid debug(bool) { cerr << endl; }\ntemplate <class Head, class... Tail> void debug(bool is_front, Head head, Tail... tail) {\n    if(!is_front) cerr << "", "";\n    cerr << head;\n    debug(false, tail...);\n}\n\n#define dump(args...)                                                                                                                                          \\\n    {                                                                                                                                                          \\\n        vector<string> _debug = _split(#args, \',\');                                                                                                            \\\n        err(true, begin(_debug), args);                                                                                                                        \\\n    }\n\nvector<string> _split(const string &s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while(getline(ss, x, c)) {\n        if(empty(v))\n            v.eb(x);\n        else {\n            bool flag = false;\n            for(auto [c, d] : {pair(\'(\', \')\'), pair(\'[\', \']\'), pair(\'{\', \'}\')}) {\n                if(count(all(v.back()), c) != count(all(v.back()), d)) flag = true;\n            }\n            if(flag)\n                v.back() += "","" + x;\n            else\n                v.eb(x);\n        }\n    }\n    return move(v);\n}\n\nvoid err(bool, vector<string>::iterator) { cerr << endl; }\ntemplate <typename T, typename... Args> void err(bool is_front, vector<string>::iterator it, T a, Args... args) {\n    if(!is_front) cerr << "", "";\n    cerr << it->substr((*it)[0] == \' \', (*it).size()) << "" = "" << a, err(false, ++it, args...);\n}\n\n// #define dump(...) cerr << #__VA_ARGS__ << "" : "", debug(true, __VA_ARGS__)\n#else\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n#endif\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << \' \';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(std::forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, std::forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nint toint(const char &c, const char start = \'a\') { return c - start; }\nint toint(const char &c, const string &chars) { return find(all(chars), c) - begin(chars); }\nint alphabets_to_int(const char &c) { return (islower(c) ? c - \'a\' : c - \'A\' + 26); }\ntemplate <typename T> auto toint(const T &v, const char &start = \'a\') {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\ntemplate <typename T> auto toint(const T &v, const string &start) {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\n// a -> 0, A -> 26\ntemplate <typename T> auto alphabets_to_int(const T &s) {\n    vector<decltype(alphabets_to_int(s[0]))> res;\n    res.reserve(s.size());\n    for(auto &&e : s) { res.emplace_back(alphabets_to_int(e)); }\n    return res;\n}\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        T mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#pragma endregion\n\ntemplate <typename key_t, typename sum_t = key_t> struct ReRooting {\n    struct Edge {\n        int from, to;\n        key_t cost;\n        sum_t dp, ndp;\n    };\n    using F = function<sum_t(sum_t, sum_t)>;\n    using G = function<sum_t(sum_t, Edge)>;\n\n    vector<vector<Edge>> g;\n    const F f;\n    const G gg;\n    const sum_t id;\n    vector<sum_t> subdp, dp;\n\n    void add_edge(int u, int v, const key_t &d) {\n        g[u].emplace_back(Edge{u, v, d, id, id});\n        g[v].emplace_back(Edge{v, u, d, id, id});\n    }\n    void add_edge(int u, int v, const key_t &d, const key_t &rev_d) {\n        g[u].emplace_back(Edge{u, v, d, id, id});\n        g[v].emplace_back(Edge{v, u, rev_d, id, id});\n    }\n    void add_directed_edge(int u, int v, const key_t &d) { g[u].emplace_back(Edge{u, v, d, id, id}); }\n\n    ReRooting(int n, const G &g, const F &f, const sum_t &id = sum_t{}) : g(n), f(f), gg(g), id(id), subdp(n, id), dp(n, id) {}\n    ReRooting(Graph &graph, const G &g, const F &f, const sum_t &id = sum_t{})\n        : g(graph.size()), f(f), gg(g), id(id), subdp(graph.size(), id), dp(graph.size(), id) {\n        for(int i = 0; i < graph.size(); i++)\n            for(auto e : graph[i]) add_directed_edge(i, e, 1);\n    }\n    template <typename T>\n    ReRooting(Wgraph<T> &graph, const G &g, const F &f, const sum_t &id = sum_t{})\n        : g(graph.size()), f(f), gg(g), id(id), subdp(graph.size(), id), dp(graph.size(), id) {\n        for(int i = 0; i < graph.size(); i++)\n            for(auto e : graph[i]) add_directed_edge(i, e, e.cost);\n    }\n\n    void dfs_sub(int x, int p) {\n        for(auto &e : g[x]) {\n            if(e.to == p) continue;\n            dfs_sub(e.to, x);\n            e.dp = gg(subdp[e.to], e);\n            subdp[x] = f(subdp[x], e.dp);\n        }\n    }\n\n    void dfs_all(int x, int p, sum_t top) {\n        sum_t now = id;\n        for(int i = 0; i < (int)g[x].size(); i++) {\n            auto &e = g[x][i];\n            e.ndp = now;\n            if(e.to == p) e.dp = gg(top, e);\n            now = f(now, e.dp);\n        }\n        dp[x] = now;\n        now = id;\n        for(int i = (int)g[x].size() - 1; i >= 0; i--) {\n            auto &e = g[x][i];\n            if(e.to != p) dfs_all(e.to, x, f(e.ndp, now));\n            now = f(now, e.dp);\n        }\n    }\n\n    vector<sum_t> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, id);\n        return dp;\n    }\n};\nusing A = array<int, 3>;\nA operator+(A x, A y) {\n    rep(i, si(x)) x[i] += y[i];\n    return x;\n}\nint main() {\n    INT(n);\n    VEC(int, a, n);\n    auto g = getG(n);\n\n    // , , ok \n    auto F = [](A x, A y) {\n        A res{};\n        rep(i, 3) res[i] = x[i] + y[i];\n        return res;\n    };\n    auto G = [&](A x, auto e) {\n        A res{};\n        if(x[2] or (x[0] and x[1] > 1)) res[2] = 1;\n        res[0] = a[e.to];\n        res[1] = a[e.to] + x[1];\n        dump(e.from, e.to, x, res);\n        return res;\n    };\n    ReRooting<int, A> rr(g, G, F, A{});\n    auto res = rr.build();\n    rep(i, n) { dump(res[i][0], res[i][1], res[i][2]); }\n    vi ans(n);\n    rep(i, n) {\n        if(res[i][0] or res[i][2] or a[i]) ans[i] = true;\n    }\n    OUT(ans);\n}']",,,"['dfs and similar', 'greedy', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Black and White Tree.json,https://codeforces.com//blog/entry/99136,I think there are some ways to solve this problem with casework but let s try to come up with an intuitive and easy to implement approach It s always possible to move closer to some black vertex no matter in which vertex you are currently and which black vertex was used in the previous operation However sometimes if you try to move along an edge you immediately get forced back Let s analyze when we can move without being forced back We can move along the edge so that our next action is not moving back if either is black there is no next action or if we remove the edge between and the number of black vertices in s component is at least we can use one of them to go from to and another one to continue our path Note that the cases and may be different sometimes it will be possible to move in one direction and impossible to move in the opposite direction Let s treat this possible move as an arc in a directed graph We can find all such arcs if we can answer the queries of the type count black vertices in a subtree of some vertex and this can be done by rooting the tree and calculating this information for each subtree with DFS Now if there is a way from some vertex to some black vertex along these arcs the answer for the vertex is How can we find all such vertices Let s transpose the graph change the direction of each arc to opposite now we need to find all vertices reachable from black ones which is easily done with multisource BFS or DFS The complexity of this solution is 
https://codeforces.com//contest/552/problem/E,29865,E,552E,552,E. Vanya and Brackets,Vanya is doing his maths homework He has an expression of form where are digits from to and sign represents either a plus or the multiplication sign Vanya needs to add pair of brackets in this expression so that to maximize the value of the resulting expression ,"[""#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nconst int MAXV = 12345;\n\nint N = 0;\nll ans = 0;\n\nstring s;\nint vals[MAXV];\nbool mult[MAXV];\n\npair<ll, ll> pref[MAXV];\npair<ll, ll> suff[MAXV];\n\nint main(){\n    setup();\n    cin >> s;\n    N = (s.size()+1)/2;\n\n    for(int i=0; i<N; i++){\n        vals[i] = s[2*i]-'0';\n        if(i) mult[i-1] = s[2*i-1]=='*';\n    }\n\n    if(N == 1){ cout << vals[0] << endl; return 0; }\n    if(N == 2){ cout << (mult[0] ? vals[0] * vals[1] : vals[0] + vals[1]) << endl; return 0; }\n\n    pref[0] = {1, 0};\n    for(int i=1; i<N; i++){\n        if(mult[i-1]){\n            pref[i].first = pref[i-1].first * vals[i-1];\n            pref[i].second = pref[i-1].second;\n        }\n        else{\n            pref[i].first = 1;\n            pref[i].second = vals[i-1] * pref[i-1].first + pref[i-1].second;                 \n        }\n    }    \n\n    suff[N-1] = {1, 0};\n    for(int i=N-1; i>=1; i--){\n        if(i<N-1){\n            if(mult[i]){\n                suff[i].first = suff[i+1].first * vals[i+1];\n                suff[i].second = suff[i+1].second;\n            }\n            else{\n                suff[i].first = 1;\n                suff[i].second = vals[i+1] * suff[i+1].first + suff[i+1].second;\n            }\n        }\n  \n        ll sum = 0;\n        ll prod = vals[i]; \n        for(int j=i; j>=0; j--){\n            ll cand = pref[j].first * suff[i].first * (sum + prod)\n                    + pref[j].second + suff[i].second;\n            ans = max(ans, cand);\n            \n            if(!j) break;\n            if(mult[j-1]) prod *= vals[j-1];\n            else{ sum += prod; prod = vals[j-1]; }\n        } \n    }\n\n    cout << ans << endl;\n}\n""]",,,"['brute force', 'dp', 'expression parsing', 'greedy', 'implementation', 'strings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Vanya and Brackets.json,https://codeforces.com//blog/entry/18696,We can see that we can reach maximal answer when brackets will be between two signs or between one sign and the end of expression For convenience we will add in the begin of expression and in the end of expression After that we can iterate all possible pairs of signs and count the expression with putting brackets between two signs for each pair We can use two variables and to count the value of expression in the begin where is first digit of expression then if next sign is then and if next sign is then The value of expression will be we can create function like that to count expressions inside and outside the brackets Time complexity C code Wild Hamster Java code Wild Hamster Java code Zlobober P S Sorry for my bad english I will try to correct mistakes in the near time UPD Editorial from hsk 
https://codeforces.com//contest/732/problem/C,76073,C,732C,732,C. Sanatorium,Vasiliy spent his vacation in a sanatorium came back and found that he completely forgot details of his vacation Every day there was a breakfast a dinner and a supper in a dining room of the sanatorium of course in this order The only thing that Vasiliy has now is a card from the dining room contaning notes how many times he had a breakfast a dinner and a supper thus the card contains three integers Vasiliy could sometimes have missed some meal for example he could have had a breakfast and a supper but a dinner or probably at some days he haven t been at the dining room at all Vasiliy doesn t remember what was the time of the day when he arrived to sanatorium before breakfast before dinner before supper or after supper and the time when he left it before breakfast before dinner before supper or after supper So he considers any of these options After Vasiliy arrived to the sanatorium he was there all the time until he left Please note that it s possible that Vasiliy left the sanatorium on the same day he arrived According to the notes in the card help Vasiliy determine the minimum number of meals in the dining room that he could have missed We shouldn t count as missed meals on the arrival day before Vasiliy s arrival and meals on the departure day after he left ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nll a[3],b[3];\n\nint main(){\n    ll Sum = 0;\n    rep(i,0,3) cin >> a[i] , Sum += a[i];\n    ll ans = 9 * 1e18;\n    rep(i,0,3) rep(j,i,3){\n        memset(b,0,sizeof(b));\n        rep(k,i,j+1) b[k] = 1;\n        bool ok = true;\n        rep(k,0,3) ok &= b[k] >= a[k];\n        if(ok) ans = min(ans , j - i + 1ll - Sum);\n    }\n    rep(i,0,4) rep(j,0,4){\n        memset(b , 0 , sizeof(b));\n        for(int k=0;k<min(3,i);++k) b[k]++;\n        for(int k=0;k<min(3,j);++k) b[2-k]++;\n        ll Max = 0;\n        rep(k,0,3) Max = max(Max , a[k] - b[k]);\n        ll tmp = 3 * Max + i + j - Sum;\n        ans = min(tmp , ans);\n    }\n    cout <<ans << endl;\n    return 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Sanatorium.json,https://codeforces.com//blog/entry/47890,Let s iterate on the time of day when Vasiliy arrived at the sanatorium breakfast dinner or supper and on the time when Vasiliy left We sum the changed values of and considering that we take all possible meals during the first and the last day into the variable find the maximum of these three variables also changed and if our current answer is more than we update it with this value After considering all possible scenarios we print the answer Time complexity 
https://codeforces.com//contest/1131/problem/B,302309,B,1131B,1131,B. Draw ,You still have partial information about the score during the historic football match You are given a set of pairs a i b i indicating that at some point during the match the score was a i b i It is known that if the current score is x y then after the goal it will change to x 1 y or x y 1 What is the largest number of times a draw could appear on the scoreboard The pairs a i b i are given in chronological order time increases but you are given score only for some moments of time The last pair corresponds to the end of the match ,"['/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,""r"",stdin);\n#define fpo(x) freopen(x,""w"",stdout);\n#define fprio fpi(""in.txt"");fpo(""out.txt"");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==\' \');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes("""");}\ninline void writei(int x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(""-funsafe-loop-optimizations"")\n#pragma GCC optimize(""-funroll-loops"")\n#pragma GCC optimize(""-fwhole-program"")\n#pragma GCC optimize(""Ofast,no-stack-protector"")\n#pragma GCC optimize(""-fthread-jumps"")\n#pragma GCC optimize(""-falign-functions"")\n#pragma GCC optimize(""-falign-jumps"")\n#pragma GCC optimize(""-falign-loops"")\n#pragma GCC optimize(""-falign-labels"")\n#pragma GCC optimize(""-fcaller-saves"")\n#pragma GCC optimize(""-fcrossjumping"")\n#pragma GCC optimize(""-fcse-follow-jumps"")\n#pragma GCC optimize(""-fcse-skip-blocks"")\n#pragma GCC optimize(""-fdelete-null-pointer-checks"")\n#pragma GCC optimize(""-fdevirtualize"")\n#pragma GCC optimize(""-fexpensive-optimizations"")\n#pragma GCC optimize(""-fgcse"")\n#pragma GCC optimize(""-fgcse-lm"")\n#pragma GCC optimize(""-fhoist-adjacent-loads"")\n#pragma GCC optimize(""-finline-small-functions"")\n#pragma GCC optimize(""-findirect-inlining"")\n#pragma GCC optimize(""-fipa-sra"")\n#pragma GCC optimize(""-foptimize-sibling-calls"")\n#pragma GCC optimize(""-fpartial-inlining"")\n#pragma GCC optimize(""-fpeephole2"")\n#pragma GCC optimize(""-freorder-blocks"")\n#pragma GCC optimize(""-freorder-functions"")\n#pragma GCC optimize(""-frerun-cse-after-loop"")\n#pragma GCC optimize(""-fsched-interblock"")\n#pragma GCC optimize(""-fsched-spec"")\n#pragma GCC optimize(""-fschedule-insns"")\n#pragma GCC optimize(""-fschedule-insns2"")\n#pragma GCC optimize(""-fstrict-aliasing"")\n#pragma GCC optimize(""-fstrict-overflow"")\n#pragma GCC optimize(""-ftree-switch-conversion"")\n#pragma GCC optimize(""-ftree-tail-merge"")\n#pragma GCC optimize(""-ftree-pre"")\n#pragma GCC optimize(""-ftree-vrp"")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<""NO"";return 0;}\n#define YES {cout<<""YES"";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nll n,m,i,j,a,b,c,d,ans;\nstring st;\nint main()\n{\n\ta=b=0;\n\tread(n);\n\twhile (n--)\n\t{\n\t\tread(c);read(d);\n\t\tans+=max(0ll,min(c,d)-max(a,b)+1);\n\t\ta=c;b=d;\n\t\tif (a==b){a++;b++;}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}']",,,"['greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Draw .json,https://codeforces.com//blog/entry/65487,Since some scores are already fixed we only have liberty in between of them One can easily see that basically we need to solve the problem between each neighboring pair and then sum all the answers it may turn out that for a fixed score it will be accounted twice in the left pair and in the right but it s easy to subtract it back How to solve the problem between score and We want to put in the middle as much pairs as possible So we have and hence it s easy to count the number of such s and you can also see that there is a goal sequence which achieves all such s together 
https://codeforces.com//contest/991/problem/A,192850,A,991A,991,A. If at first you don t succeed...,Each student eagerly awaits the day he would pass the exams successfully Thus Vasya was ready to celebrate but alas he didn t pass it However many of Vasya s fellow students from the same group were more successful and celebrated after the exam Some of them celebrated in the BugDonalds restaurant some of them in the BeaverKing restaurant the most successful ones were fast enough to celebrate in both of restaurants Students which didn t pass the exam didn t celebrate in any of those restaurants and elected to stay home to prepare for their reexamination However this quickly bored Vasya and he started checking celebration photos on the Kilogramm He found out that in total BugDonalds was visited by A students BeaverKing by B students and C students visited both restaurants Vasya also knows that there are N students in his group Based on this info Vasya wants to determine either if his data contradicts itself or if it doesn t how many students in his group didn t pass the exam Can you help him so he won t waste his valuable preparation time ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint A, B, C, N;\n\tcin >> A >> B >> C >> N;\n\tint x = A + B - C;\n\tif (N - x > 0 && C <= A && C <= B) {\n\t\tcout << N - x << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}""]",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. If at first you don t succeed....json,https://codeforces.com/blog/entry/60181,EditorialThere are 4 groups of students those who visited only the first restaurant who visited only the second who visited both places and who stayed at home One of the easiest ways to detect all the incorrect situations is to calculate number of students in each group For the first group it is for the second for the third and for the fourth Now we must just to check that there are non negative numbers in the first three groups and the positive number for the last group If such conditions are met the answer is the number of students in the fourth group In general you are recommended to view inclusion exclusion principle Moreover the limitations allow to go over all possible numbers of students for each group except for the third in and to check whether such numbers produce a correct solution If no correct numbers found just print 
https://codeforces.com//contest/1800/problem/C1,1805844,C1,1800C1,1800,C1. Powering the Hero  easy version , There is a deck of n cards each of which is characterized by its power There are two types of cards a hero card the power of such a card is always equal to 0 a bonus card the power of such a card is always positive You can do the following with the deck take a card from the top of the deck if this card is a bonus card you can put it of your bonus deck or discard if this card is a hero card then the power of card from your bonus deck is added to his power if it is not empty after that the hero is added to your army and the used bonus discards Your task is to use such actions to gather an army with the maximum possible total power ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lo; \ntypedef pair< lo,lo > PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define endl ""\\n""\n#define pb push_back\n#define int long long\n#define fio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define FOR for(int i=1;i<=n;i++)\n#define mid ((start+end)/2)\n#define ort ((bas+son)/2)\n\nconst lo inf = 1000000000000000000;\nconst lo KOK = 100000;\nconst lo LOG = 30;\nconst lo li = 500005;\nconst lo mod = 1000000007;\n\nint n,m,b[li],a[li],k,flag,t;\nint cev;\nstring s;\nvector<int> v;\n\ninline int in(){\n    int x;\n    scanf(""%lld"",&x);\n    return x;\n}\n\nint32_t main(void){\n    t=in();\n    while(t--){\n        n=in();\n        FOR a[i]=in();\n        priority_queue<int> pq;\n        cev=0;\n        FOR{\n\t\t\tif(a[i])pq.push(a[i]);\n\t\t\telse{\n\t\t\t\tif(pq.size()){cev+=pq.top();pq.pop();}\n\t\t\t}\n\t\t}\n\t\tprintf(""%lld\\n"",cev);\n    }\n    return 0;\n}\n']",,,"['data structures', 'greedy']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C1. Powering the Hero  easy version .json,https://codeforces.com//blog/entry/113477,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints allow you to sort the current array with bonus values each time and remove the maximum element 
https://codeforces.com//contest/1896/problem/E,2346409,E,1896E,1896,E. Permutation Sorting,You are given a permutation dagger a of size n We call an index i if a i i is satisfied After each second we rotate all indices that are not good to the right by one position Formally Let s 1 s 2 ldots s k be the indices of a that are good in increasing order That is s j s j 1 and if index i is not good then there exists j such that s j i For each i from 1 to k we assign a s i ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=2000*1007;\n\nint n;\nint tab[nax];\nint gdz[nax];\n\nint wyn[nax];\n\nordered_set<int> setel;\n\nint fix(int v)\n{\n\tif (v>n)\n\t\tv-=n;\n\treturn v;\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tgdz[i]=0;\n\t\tscanf(""%d"", &tab[i]);\n\t\ttab[n+i]=tab[i];\n\t}\n\tsetel.clear();\n\t\n\tfor (int i=1; i<=2*n; i++)\n\t{\n\t\tif (gdz[tab[i]])\n\t\t\tsetel.erase(gdz[tab[i]]);\n\t\tgdz[tab[i]]=i;\n\t\tif (gdz[fix(i)])\n\t\t{\n\t\t\t//~ debug() << i << "" "" << gdz[fix(i)] << "" "" << setel;\n\t\t\twyn[i]=(i-gdz[fix(i)])-((int)setel.size()-(int)setel.order_of_key(gdz[fix(i)]));\n\t\t\tsetel.insert(gdz[fix(i)]);\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%d "", wyn[n+i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['data structures', 'sortings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Permutation Sorting.json,https://codeforces.com//blog/entry/122172,SolutionFor convenience we will assume that the array is cyclic so The answer for each index from to is defined in hint 1 minus the number of indices where and or to handle cyclic case when This is because the value that we are calculating is equal to the number of positions that will skip during the rotation as the index is already good To calculate the above value it is convenient to define an array of size where for all between to and for all between to to handle cyclicity We will loop from to and do a point increment to position if otherwise do a point increment to position Then to get the answer for index we do a range sum query from to Point increment and range sum query can be done using a binary indexed tree in time per query update Hence the problem can be solved in time 
https://codeforces.com//contest/1419/problem/F,729813,F,1419F,1419,F. Rain of Fire,There are n detachments on the surface numbered from 1 to n the i th detachment is placed in a point with coordinates x i y i All detachments are placed in different points Brimstone should visit each detachment at least once You can choose the detachment where Brimstone starts To move from one detachment to another he should first choose one of four directions of movement up right left or down and then start moving with the constant speed of one unit interval in a second until he comes to a detachment After he reaches an arbitrary detachment he can repeat the same process Each t seconds an orbital strike covers the whole surface so at that moment Brimstone should be in a point where some detachment is located He can stay with any detachment as long as needed Brimstone is a good commander that s why he can create detachment and place it in any empty point with integer coordinates he wants before his trip Keep in mind that Brimstone will need to visit this detachment too Help Brimstone and find such minimal t that it is possible to check each detachment If there is no such t report about it ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#pragma GCC optimize(""Ofast"")\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e3 + 5;\nstruct Node {\n\tint x, y;\n}a[MAXN], b[MAXN];\nint n, dx[MAXN], dy[MAXN], tx, ty;\nvector < int > row[MAXN], clm[MAXN];\nbool cmp1(int i, int j) {return a[i].y < a[j].y;}\nbool cmp2(int i, int j) {return a[i].x < a[j].x;}\n\nint f[MAXN], siz[MAXN];\ninline int find(int x) {\n\twhile(x != f[x]) x = f[x];\n\treturn x;\n}\nstruct Tri {\n\tint x, y, r, w;\n};\nstack < Tri > s;\ninline int merge(int x, int y, int opt = 0) {\n\tx = find(x), y = find(y);\n\tif(x == y) return 0;\n\tif(siz[x] < siz[y]) swap(x, y);\n\tif(opt) s.push((Tri) {y, f[y], x, siz[x]});\n\tf[y] = x; siz[x] += siz[y]; return 1;\n}\ninline void back() {\n\twhile(s.size()) {\n\t\tf[s.top().x] = s.top().y; siz[s.top().r] = s.top().w;\n\t\ts.pop();\n\t}\n}\nbool check(int mid) {\n//\tcerr << mid << "":"" << endl;\n\tFor(i, 1, tx) row[i].clear(); tx = 0;\n\tFor(i, 1, ty) clm[i].clear(); ty = 0;\n\tFor(i, 1, n) a[i] = b[i];\n\tFor(i, 1, n) dx[++tx] = a[i].x, dx[++tx] = a[i].x - mid, dx[++tx] = a[i].x + mid; \n\tFor(i, 1, n) dy[++ty] = a[i].y, dy[++ty] = a[i].y - mid, dy[++ty] = a[i].y + mid; \n\tsort(dx + 1, dx + 1 + tx); sort(dy + 1, dy + 1 + ty); tx = unique(dx + 1, dx + 1 + tx) - dx - 1, ty = unique(dy + 1, dy + 1 + ty) - dy - 1;\n//\tcerr << tx << \' \' << ty << endl;\n    For(i, 1, n) row[a[i].x = lower_bound(dx + 1, dx + 1 + tx, a[i].x) - dx].pb(i), clm[a[i].y = lower_bound(dy + 1, dy + 1 + ty, a[i].y) - dy].pb(i);\n\tFor(i, 1, tx) sort(row[i].begin(), row[i].end(), cmp1);\n\tFor(i, 1, ty) sort(clm[i].begin(), clm[i].end(), cmp2);\n\t\n\tFor(i, 1, n + 1) f[i] = i, siz[i] = 1;\n\twhile(s.size()) s.pop();\n\tFor(i, 1, tx) {\n\t\tfor(rint j = 1; j < row[i].size(); j++) {\n\t\t\tif(dy[a[row[i][j]].y] - dy[a[row[i][j-1]].y] <= mid) {\n\t\t\t\tmerge(row[i][j], row[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tFor(i, 1, ty) {\n\t\tfor(rint j = 1; j < clm[i].size(); j++) {\n\t\t\tif(dx[a[clm[i][j]].x] - dx[a[clm[i][j-1]].x] <= mid) {\n\t\t\t\tmerge(clm[i][j], clm[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(siz[find(1)] == n) return 1;\n\tFor(x, 1, tx) {\n\t\tFor(y, 1, ty) {\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tfor(int j = 0; j < row[x].size(); j++) {\n\t\t\t\tif(abs(dy[a[row[x][j]].y] - dy[y]) <= mid) {\n//\t\t\t\t\tcerr << x << \' \' << y << \' \' << row[x][j] << \' \' << dy[a[row[x][j]].y]  << \' \' << dy[y] << endl;\n\t\t\t\t\tmerge(row[x][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < clm[y].size(); j++) {\n\t\t\t\tif(abs(dx[a[clm[y][j]].x] - dx[x]) <= mid) {\n//\t\t\t\t\tcerr << x << \' \' << y << \' \' << clm[y][j] << \' \' << dx[a[clm[y][j]].x] << \' \' << dx[x] << endl;\n\t\t\t\t\tmerge(clm[y][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tif(siz[find(1)] == n + 1) return 1;\n\t\t\tback();\n\t\t}\n\t}\n\treturn 0;\n}\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    cin >> n;\n    For(i, 1, n) cin >> a[i].x >> a[i].y, b[i] = a[i];\n    \n\tll l = 1, r = 2e9, res = -1;\n\twhile(l <= r) {\n//\t\tcerr << l << \' \' << r << endl;\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid)) {\n\t\t\tr = mid - 1, res = mid;\n\t\t} else l = mid + 1;\n\t}\n\tcout << res << endl;\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'implementation']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Rain of Fire.json,https://codeforces.com//blog/entry/82817,We can consider a graph where vertices are the points detachments and there is an edge between two points if it s possible to move from one point to another It is possible if these points are on the same line or and the distance between them is Now we can check whether current value is good whether it is possible to check all detachments It is easy to see that it is only possible when the graph is connected This means that we can make a binary search for Let s now learn how to check whether it is possible to add at most one point to make the graph connected If there is component then the graph is already connected If there are components then we can search through all such pairs of points that one point is from the first component and another point is from the second component We can connect these points if they are on one line and the distance between them is or the differences and If are three components then we should consider triples of points Two of these points should be on the same line The added point should be on a segment between these two points and there are such segments Now let s search through all such pairs segment point and check whether it is possible to place a point on the segment and connect it with the point from the pair If there are components then you can search trough pairs segment segment so that one segment is horizontal and another one is vertical they should make a cross Now we just need to check whether it is possible to connect their intersection point with all 4 endpoints of the segments If there are more than components then it is not possible to connect them adding only one point because there are 4 movement directions If your binary search did not find the answer even for then the answer is because the maximal distance between any two points is 
https://codeforces.com//contest/1975/problem/D,2665475,D,1975D,1975,D. Paint the Tree,378QAQ has a tree with n vertices Initially all vertices are white There are two chess pieces called P A and P B on the tree P A and P B are initially located on vertices a and b respectively In one step 378QAQ will do the following in order Move P A to a neighboring vertex If the target vertex is white this vertex will be painted red Move P B to a neighboring vertex If the target vertex is colored in red this vertex will be painted blue Initially the vertex a is painted red If a b the vertex a is painted blue instead Note that both the chess pieces be moved in each step Two pieces can be on the same vertex at any given time 378QAQ wants to know the minimum number of steps to paint all vertices blue ,"['/** *    author:  tourist *    created: 25.05.2024 10:41:49**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };\xa0  vector<edge> edges;  vector<vector<int>> g;  int n;\xa0  graph(int _n) : n(_n) {    g.resize(n);  }\xa0  virtual int add(int from, int to, T cost) = 0;};\xa0template <typename T>class forest : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;\xa0  forest(int _n) : graph<T>(_n) {  }\xa0  int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    assert(id < n - 1);    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }};\xa0template <typename T>class dfs_forest : public forest<T> { public:  using forest<T>::edges;  using forest<T>::g;  using forest<T>::n;\xa0  vector<int> pv;  vector<int> pe;  vector<int> order;  vector<int> pos;  vector<int> end;  vector<int> sz;  vector<int> root;  vector<int> depth;  vector<T> dist;\xa0  dfs_forest(int _n) : forest<T>(_n) {  }\xa0  void init() {    pv = vector<int>(n, -1);    pe = vector<int>(n, -1);    order.clear();    pos = vector<int>(n, -1);    end = vector<int>(n, -1);    sz = vector<int>(n, 0);    root = vector<int>(n, -1);    depth = vector<int>(n, -1);    dist = vector<T>(n);  }\xa0  void clear() {    pv.clear();    pe.clear();    order.clear();    pos.clear();    end.clear();    sz.clear();    root.clear();    depth.clear();    dist.clear();  }\xa0 private:  void do_dfs(int v) {    pos[v] = (int) order.size();    order.push_back(v);    sz[v] = 1;    for (int id : g[v]) {      if (id == pe[v]) {        continue;      }      auto &e = edges[id];      int to = e.from ^ e.to ^ v;      depth[to] = depth[v] + 1;      dist[to] = dist[v] + e.cost;      pv[to] = v;      pe[to] = id;      root[to] = (root[v] != -1 ? root[v] : to);      do_dfs(to);      sz[v] += sz[to];    }    end[v] = (int) order.size() - 1;  }\xa0  void do_dfs_from(int v) {    depth[v] = 0;    dist[v] = T{};    root[v] = v;    pv[v] = pe[v] = -1;    do_dfs(v);  }\xa0 public:  void dfs(int v, bool clear_order = true) {    if (pv.empty()) {      init();    } else {      if (clear_order) {        order.clear();      }    }    do_dfs_from(v);  }\xa0  void dfs_all() {    init();    for (int v = 0; v < n; v++) {      if (depth[v] == -1) {        do_dfs_from(v);      }    }    assert((int) order.size() == n);  }};\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    int a, b;    cin >> a >> b;    --a; --b;    dfs_forest<int> g(n);    for (int i = 0; i < n - 1; i++) {      int x, y;      cin >> x >> y;      --x; --y;      g.add(x, y);    }    g.dfs(a);    int ans = 0;    int steps = (g.depth[b] + 1) / 2;    while (steps > 0) {      b = g.pv[b];      ans += 1;      steps -= 1;    }    ans += 2 * (n - 1);    g.dfs(b);    int mx = *max_element(g.depth.begin(), g.depth.end());    cout << ans - mx << \'\\n\';  }  return 0;}']",,,"['brute force', 'dfs and similar', 'dp', 'greedy', 'shortest paths', 'trees']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Paint the Tree.json,https://codeforces.com//blog/entry/129801,SolutionRead the hints In subsequent movements after the first time a vertex is painted blue we can ignore the process of painting vertices red and then painting them blue We call the first vertex painted blue Then it is not difficult to find that arrived at this vertex earlier than Considering all subsequent movements of can restore these movements one by one after reaching then will pass through all vertices have been painted red If we know which vertex is this will be a classic problem assuming the distance between the farthest vertex on the tree from and is then the answer is Then we consider the strategies of and at this time The two must be close to each other and then until the first vertex is painted blue If another vertex is although the value of may increase every time the value of increases by the time when and meet will also increase by at least so the answer will not decrease 
https://codeforces.com//contest/722/problem/B,74000,B,722B,722,B. Verse Pattern,You are given a text consisting of lines Each line contains some space separated words consisting of lowercase English letters We define a syllable as a string that contains exactly one vowel and any arbitrary number possibly none of consonants In English alphabet following letters are considered to be vowels and Each word of the text that contains at least one vowel can be divided into syllables Each character should be a part of exactly one syllable For example the word can be divided into syllables as and and and and Words that consist of only consonants should be ignored The verse patterns for the given text is a sequence of integers Text matches the given verse pattern if for each from to one can divide words of the th line in syllables in such a way that the total number of syllables is equal to You are given the text and the verse pattern Check if the given text matches the given verse pattern ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\nconst int N = 1010;\nint n;\nint a[N];\n\nbool isVowel(char c)\n{\n\treturn c == \'a\' || c == \'e\' || c == \'i\' || c == \'o\' || c == \'u\' || c == \'y\';\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tstring s;\n\tgetline(cin, s);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tgetline(cin, s);\n\t\tfor (char c : s)\n\t\t\tif (isVowel(c))\n\t\t\t\ta[i]--;\n\t\tif (a[i] != 0)\n\t\t{\n\t\t\tcout << ""NO\\n"";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ""YES\\n"";\n\n\treturn 0;\n}']",,,"['implementation', 'strings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Verse Pattern.json,https://codeforces.com//blog/entry/47497,Number of syllables in which we can split a word can be uniqely defined by the number of vowels in it Thus we need to count the number of vowels in each line and compare them to the given sequence 
https://codeforces.com//contest/1132/problem/A,307695,A,1132A,1132,A. Regular Bracket Sequence,A string is called if it does not contain any characters other than and A bracket sequence is called if it it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are regular bracket sequences and are bracket sequences but not regular ones and and are not bracket sequences at all You have a number of strings each string is a bracket sequence of length 2 So overall you have cnt 1 strings cnt 2 strings cnt 3 strings and cnt 4 strings You want to write all these strings in some order one after another after that you will get a long bracket sequence of length 2 cnt 1 cnt 2 cnt 3 cnt 4 You wonder is it possible to choose some order of the strings you have such that you will get a regular bracket sequence ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    ll bal = 2ll * a;\n    if (c > 0 && bal == 0) {\n        cout << 0 << ""\\n"";\n        return 0;\n    }\n    if (a != d) {\n        cout << 0 << ""\\n"";\n        return 0;\n    }\n    cout << 1 << ""\\n"";\n    return 0;\n}\n\n']",,,"['greedy', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Regular Bracket Sequence42814.json,https://codeforces.com/blog/entry/65752,For bracket sequence to be regular it should have equal number of opening and closing brackets So if then it s impossible to construct any regular bracket sequence is completely irrelevant to us since inserting or removing a substring doesn t change the status of the string we get Almost the same applies to but we should have at least one substring before it So if but there is no solution In all other cases it is possible to order all strings as follows all strings then all strings then all strings then all strings 
https://codeforces.com//contest/938/problem/A,157303,A,938A,938,A. Word Correction,Victor tries to write his own text editor with word correction included However the rules of word correction are really strange Victor thinks that if a word contains two vowels then it s kinda weird and it needs to be replaced So the word corrector works in such a way as long as there are two consecutive vowels in the word it deletes the first vowel in a word such that there is If there are no two consecutive vowels in the word it is considered to be correct You are given a word Can you predict what will it become after correction ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nstring in;\nbool isVowel(char c) {\n\treturn c == \'a\' || c == \'e\' || c == \'i\' || c == \'o\' || c == \'u\' || c == \'y\';\n}\nint main() {\n\tint N, i;\n\tcin >> N >> in;\n\tfor (i = 0; in[i];) {\n\t\tif (!isVowel(in[i])) {\n\t\t\tprintf(""%c"", in[i]);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint j;\n\t\tfor (j = i; in[j]; j++) if (!isVowel(in[j])) break;\n\t\tprintf(""%c"", in[i]);\n\t\ti = j;\n\t}\n\treturn !printf(""\\n"");\n}']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Word Correction.json,https://codeforces.com//blog/entry/57840,Hint When does some vowel stay in string Solution Iterate over the string output only consonants and vowels which don t have a vowel before them 
https://codeforces.com//contest/1447/problem/A,797262,A,1447A,1447,A. Add Candies,There are n bags with candies initially the i th bag contains i candies You want all the bags to contain an equal amount of candies in the end To achieve this you will Choose m such that 1 le m le 1000Perform m operations In the j th operation you will pick one bag and add j candies to all bags apart from the chosen one Your goal is to find a valid sequence of operations after which all the bags will contain an equal amount of candies It can be proved that for the given constraints such a sequence always exists You have to minimize m If there are several valid sequences you can output ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n    int T;\n    scanf(""%d"",&T);\n    while(T--) {\n        int N;\n        scanf(""%d"",&N);\n        printf(""%d\\n"",N);\n        for (int i=1;i<=N;i++) {\n            printf(""%d%c"",i,"" \\n""[i==N]);\n        }\n    }\n}']",,,"['constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Add Candies.json,https://codeforces.com//blog/entry/82067,Tiny hintWe re only interested in differences between the elements Is there another way to express the operation 
https://codeforces.com//contest/1093/problem/G,270228,G,1093G,1093,G. Multidimensional Queries,You are given an array a of n points in k dimensional space Let the distance between two points a x and a y be sum limits i 1 k a x i a y i it is also known as Manhattan distance You have to process q queries of the following two types 1 i b 1 b 2 b k set i th element of a to the point b 1 b 2 dots b k 2 l r find the maximum distance between two points a i and a j where l le i j le r ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nconst int inf = 1e9;\n\nnamespace segtree {\n    struct data {\n        vector<int> x, y;\n        data() {}\n        data(int sz) {\n            x.resize(sz, -inf);\n            y.resize(sz, +inf);\n        }\n        data(const vector<int> &p) {\n            int k = (int)p.size();\n            x.resize(1 << k, -inf);\n            y.resize(1 << k, +inf);\n            for (int i = 0; i < (1 << k); ++i) {\n                int s = 0;\n                for (int j = 0; j < k; ++j) {\n                    if (i >> j & 1) s += p[j];\n                    else s -= p[j];\n                }\n                x[i] = max(x[i], s);\n                y[i] = min(y[i], s);\n            }\n        }\n        data operator+(const data &d) const {\n            data res(x.size());\n            for (int i = 0; i < (int)x.size(); ++i) {\n                res.x[i] = max(res.x[i], x[i]);\n                res.x[i] = max(res.x[i], d.x[i]);\n                res.y[i] = min(res.y[i], y[i]);\n                res.y[i] = min(res.y[i], d.y[i]);\n            }\n            return res;\n        }\n    }; \n    data st[maxn * 4];\n    void build(int l, int r, const vector<vector<int>> &p, int o = 0) {\n        if (r - l == 1) return st[o] = data(p[l]), void();\n        build(l, (l + r) >> 1, p, o * 2 + 1);\n        build((l + r) >> 1, r, p, o * 2 + 2);\n        st[o] = st[o * 2 + 1] + st[o * 2 + 2];\n    }\n    void modify(int l, int r, int z, const vector<int> &p, int o = 0) {\n        if (r - l == 1) return st[o] = data(p), void();\n        if (z < (l + r) >> 1) modify(l, (l + r) >> 1, z, p, o * 2 + 1);\n        else modify((l + r) >> 1, r, z, p, o * 2 + 2);\n        st[o] = st[o * 2 + 1] + st[o * 2 + 2];\n    }\n    data query(int l, int r, int ql, int qr, int o = 0) {\n        if (l >= ql && r <= qr) return st[o];\n        if (qr <= (l + r) >> 1) return query(l, (l + r) >> 1, ql, qr, o * 2 + 1);\n        if (ql >= (l + r) >> 1) return query((l + r) >> 1, r, ql, qr, o * 2 + 2);\n        return query(l, (l + r) >> 1, ql, qr, o * 2 + 1) +\n               query((l + r) >> 1, r, ql, qr, o * 2 + 2);\n    } \n}\n\nint main() {\n    int n, k; scanf(""%d%d"", &n, &k);\n    vector<vector<int>> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i].resize(k);\n        for (int j = 0; j < k; ++j) scanf(""%d"", &p[i][j]);\n    }\n    segtree::build(0, n, p);\n    int q; scanf(""%d"", &q);\n    while (q--) {\n        int t; scanf(""%d"", &t);\n        if (t == 1) {\n            int z; vector<int> p(k);\n            scanf(""%d"", &z); z--;\n            for (int i = 0; i < k; ++i) scanf(""%d"", &p[i]);\n            segtree::modify(0, n, z, p);\n        } else {\n            int l, r; scanf(""%d%d"", &l, &r);\n            segtree::data res = segtree::query(0, n, l - 1, r);\n            int ans = 0;\n            for (int i = 0; i < (1 << k); ++i) ans = max(ans, res.x[i] - res.y[i]);\n            printf(""%d\\n"", ans);\n        }\n    }\n}\n']",,,"['bitmasks', 'data structures']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Multidimensional Queries.json,https://codeforces.com/blog/entry/63877,Let s rewrite the formula of distance between two points as follows where if otherwise Consider what will happen if we change some to the opposite value The result of this formula obviously won t increase so we may try all possible values of and pick maximum result This allows us to consider every option to set values of there are such options separately and when we fix a set of values of find two points that maximize the distance if it is expressed with fixed To do so we have to find the point having maximum and having minimum So actually our problem is reduced to the following we have arrays we want to process some queries in the form change an element of some array and find maximum and minimum on some segment of some array This can be done simply by building a segment tree over each array and then we will get the solution having time complexity 
https://codeforces.com//contest/1658/problem/F,1344628,F,1658F,1658,F. Juju and Binary String,The of a binary string is the number of texttt 1 s divided by the length of the string For example the of texttt 01101 is frac 3 5 Juju has a binary string s of length n She wants to choose some non intersecting subsegments of s such that their concatenation has length m and it has the same as the string s More specifically she wants to find two arrays l and r of equal length k such that 1 leq l 1 leq r 1 l 2 leq r 2 ldots l k leq r k leq n and also sum limits i 1 k r i l i 1 m The of s l 1 r 1 s l 2 r 2 ldots s l k r k is equal to the of s where s x y denotes the subsegment s x s x 1 ldots s y and denotes string concatenation Juju does not like splitting the string into many parts so she also wants to the value of k Find the minimum value of k such that there exist l and r that satisfy the constraints above or determine that it is impossible to find such l and r for any k ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint sum[500005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint cnt1=0,cnt0=0;\n\t\tfor(auto t:s)\n\t\t\tcnt1+=t==\'1\',cnt0+=t==\'0\';\n\t\tcnt1*=m,cnt0*=m;\n\t\tif(cnt1%n||cnt0%n)\n\t\t{\n\t\t\tcout << ""-1\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\ts=\' \'+s+s;\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t{\n\t\t\tif(s[i]==\'1\') sum[i]=cnt0;\n\t\t\telse sum[i]=-cnt1;\n\t\t}\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t\tsum[i]+=sum[i-1];\n\t\tint pos=0;\n\t\tfor(int i=m;i<=n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << ""1\\n"";\n\t\t\tcout << pos-m+1 << "" "" << pos << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=n+1;i<=n+n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << ""2\\n"";\n\t\t\tint l=pos-m+1,r=pos;\n\t\t\tcout << 1 << "" "" << r-n << ""\\n"";\n\t\t\tcout << l << "" "" << n << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\texit(1);\n\t}\n\treturn 0;\n}']",,,"['brute force', 'constructive algorithms', 'greedy', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Juju and Binary String.json,https://codeforces.com//blog/entry/101302,ObservationIt is easy to show that the cuteness of is What is the number of in the concatenated string needed so that the answer exists 
https://codeforces.com//contest/818/problem/B,112246,B,818B,818,B. Permutation Game,children are standing in a circle and playing a game Children s numbers in clockwise order form a permutation of length It is an integer sequence such that each integer from to appears exactly once in it The game consists of steps On each step the current leader with index counts out people in clockwise order starting from the next person The last one to be pointed at by the leader becomes the new leader You are given numbers indices of leaders in the beginning of each step Child with number is the first leader in the game Write a program which will restore a possible permutation If there are multiple solutions then print any of them If there is no solution then print ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 111\nint n , m , a[ N ] , l[ N ];\nbool used[ N ];\nint main(){\n  cin >> n >> m;\n  for( int i = 0 ; i < m ; i ++ )\n    cin >> l[ i ];\n  for( int i = 1 ; i < m ; i ++ ){\n    int x = ( l[ i ] - l[ i - 1 ] + n ) % n;\n    if( x == 0 ) x = n;\n    if( a[ l[ i - 1 ] ] == 0 ){\n      if( used[ x ] ){\n        puts( ""-1"" );\n        exit(0);\n      }\n      a[ l[ i - 1 ] ] = x;\n      used[ x ] = true;\n      continue;\n    }\n    if( x != a[ l[ i - 1 ] ] ){\n      puts( ""-1"" );\n      exit(0);\n    }\n  }\n  for( int i = 1 ; i <= n ; i ++ ) if( a[ i ] == 0 )\n    for( int j = 1 ; j <= n ; j ++ ) if( !used[ j ] ){\n      a[ i ] = j;\n      used[ j ] = true;\n      break;\n    }\n  for( int i = 1 ; i <= n ; i ++ )\n    printf( ""%d%c"" , a[ i ] , "" \\n""[ i == n ] );\n}\n']",,,['implementation'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Permutation Game.json,https://codeforces.com/blog/entry/52991,Let s show by construction that there can be no ambiguity in values of of the children who were leaders at least once except for probably the last leader If then on this step the value of taken was exactly Otherwise went over and in circle ended up to the left or in the same position So for this case should be Obviously counting cannot go over two or more times as this will result in We only need to check if all the numbers are unique and fill the unvisited children with remaining values to form the permutation Overall complexity 
https://codeforces.com//contest/758/problem/D,89338,D,758D,758,D. Ability To Convert,Alexander is learning how to convert numbers from the decimal system to any other however he doesn t know English letters so he writes any number only as a decimal number it means that instead of the letter he will write the number Thus by converting the number from decimal to hexadecimal system he gets Alexander lived calmly until he tried to convert the number back to the decimal number system Alexander remembers that he worked with little numbers so he asks to find the minimum decimal number so that by converting it to the system with the base he will get the number ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n#define rep(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nconst ll INF = 1e18;\n\nint a[N], n;\nll dp[61][61];\nll w[61][61];\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\tint k=s.length();\n\tll t=0;\n\tint cur = 0;\n\tll ans=0;\n\tll st=1;\n\tmemset(w,-1,sizeof w);\n\tfor(int i=0;i<k;++i)\n\t{\n\t\tll f=0;\n\t\tif(s[i]=='0')\n\t\t{\n\t\t\tw[i][i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=i;j<k&&f<n;++j)\n\t\t{\n\t\t\tf=f*10+(s[j]-'0');\n\t\t\tif(f < n) w[i][j]=f;\n\t\t}\n\t}                          /*\n\tmemset(dp,-1,sizeof dp);\n\tdp[k][0]=0;\n\tfor(int i=k-1;i>=0;--i)\n\t{\n\t\tfor(int cnt=1;cnt<=k;++cnt)\n\t\t\tfor(int j=i;j<k;++j)\n\t\t\t{\n\t\t\t\tif(w[i][j]<n&&dp[j+1]!=-1)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t}          \n\t                  */\n\tint last=k;\n\twhile(last!=0)\n\t{\n\t\tfor(int i=0;i<last;++i)\n\t\t{\n\t\t\tif(w[i][last - 1] != -1 && w[i][last - 1] < n)\n\t\t\t{\n\t\t\t\ta[cur++] = w[i][last - 1];\n\t\t\t\tlast = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<cur;++i)\n\t{\n\t\tans+=a[i]*st;\n\t\tst*=n;\n\t}\n\tcout<<ans;\n\treturn 0;\t\n}""]",,,"['constructive algorithms', 'dp', 'greedy', 'math', 'strings']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Ability To Convert.json,https://codeforces.com//blog/entry/49880,Let s compare answers for numbers and that is without the rightmost digit Note that for any number is either contains less substrings valid digits in base numeric system or it s possible to decrease value of the last substring of number That proves that partition of number without the rightmost digit isn t worse than partition of the number itself Thus greedy strategy will work On each step take the longest suffix of a string as the last base digit and proceed to same task for string with this suffix excluded Repeat until the string isn t empty Check carefully that the suffix is a number less than and also doesn t have any leading zeros except for the case when it s equal to zero Overall complexity where length of input string 
https://codeforces.com//contest/845/problem/D,119174,D,845D,845,D. Driving Test,Polycarp has just attempted to pass the driving test He ran over the straight road with the signs of four types speed limit this sign comes with a positive integer number maximal speed of the car after the sign cancel the action of the previous sign of this type overtake is allowed this sign means that after some car meets it it can overtake any other car no speed limit this sign cancels speed limit if any car can move with arbitrary speed after this sign no overtake allowed some car can t overtake any other car after this sign Polycarp goes past the signs consequentially each new sign cancels the action of all the previous signs of it s kind speed limit overtake It is possible that two or more no overtake allowed signs go one after another with zero overtake is allowed signs between them It works with no speed limit and overtake is allowed signs as well In the beginning of the ride overtake is allowed and there is no speed limit You are given the sequence of events in chronological order events which happened to Polycarp during the ride There are events of following types Polycarp changes the speed of his car to specified this event comes with a positive integer number Polycarp s car overtakes the other car Polycarp s car goes past the speed limit sign this sign comes with a positive integer Polycarp s car goes past the overtake is allowed sign Polycarp s car goes past the no speed limit Polycarp s car goes past the no overtake allowed It is guaranteed that the first event in chronological order is the event of type Polycarp changed the speed of his car to specified After the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn t notice some of the signs What is the minimal number of signs Polycarp should say he didn t notice so that he would make no rule violations from his point of view ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint main()\n{\n    int n;\n    scanf(""%d"",&n);\n    int now=0,ovt=0,cnt=0;\n    vector<int> spd;\n    for(int i=1;i<=n;i++)\n    {\n        int t,s;\n        scanf(""%d"",&t);\n        if(t==1)\n        {\n            scanf(""%d"",&s);\n            now=s;\n            while(!spd.empty() && now>spd.back())\n                spd.pop_back(),cnt++;\n        }\n        if(t==2)cnt+=ovt,ovt=0;\n        if(t==3)\n        {\n            scanf(""%d"",&s);\n            spd.push_back(s);\n            while(!spd.empty() && now>spd.back())\n                spd.pop_back(),cnt++;\n        }\n        if(t==4)ovt=0;\n        if(t==5)spd.clear();\n        if(t==6)ovt++;\n    }\n    return 0*printf(""%d\\n"",cnt);\n}\n']",,,"['data structures', 'dp', 'greedy']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Driving Test.json,https://codeforces.com//blog/entry/53986,Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity 
https://codeforces.com//contest/1993/problem/A,2795981,A,1993A,1993,A. Question Marks,Tim is doing a test consisting of 4n questions each question has 4 options and For each option there are exactly n correct answers corresponding to that option meaning there are n questions with the answer n questions with the answer n questions with the answer and n questions with the answer For each question Tim wrote his answer on the answer sheet If he could not figure out the answer he would leave a question mark for that question You are given his answer sheet of 4n characters What is the maximum number of correct answers Tim can get ,"['#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<""=""<<x<<""\\n"";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+"".in"").c_str(),""r"",stdin);\tfreopen((s+"".out"").c_str(),""w"",stdout);}void run(){\tint n;\tstring s;\tcin>>n>>s;\tint ca=0,cb=0,cc=0,cd=0;\tfor(char c:s){\t\tif(c==\'A\')ca++;\t\tif(c==\'B\')cb++;\t\tif(c==\'C\')cc++;\t\tif(c==\'D\')cd++;\t}\tcout<<min(n,ca)+min(n,cb)+min(n,cc)+min(n,cd)<<""\\n"";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Question Marks.json,https://codeforces.com//blog/entry/132185,SolutionLet s say there are problems take as the answer therefore he can only get points with the answer The same is correct for and Therefore the maximum score can be achieved is Time complexity 
https://codeforces.com//contest/1546/problem/A,1042724,A,1546A,1546,A. AquaMoon and Two Arrays,AquaMoon and Cirno are playing an interesting game with arrays Cirno has prepared two arrays a and b both consist of n non negative integers AquaMoon can perform the following operation an arbitrary number of times possibly zero She chooses two indices i and j 1 le i j le n then decreases the i th element of array a by 1 and increases the j th element of array a by 1 The resulting values at i th and j th index of array a are a i 1 and a j 1 respectively Each element of array a If i j this operation doesn t change the array a AquaMoon wants to make some operations to make arrays a and b equal Two arrays a and b are considered equal if and only if a i b i for all 1 leq i leq n Help AquaMoon to find a sequence of operations that will solve her problem or find that it is impossible to make arrays a and b equal Please note that you the number of operations ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"") \n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n;\nint a[105],b[105];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n        }\n        for(int i = 1;i <= n;i++) {\n            cin >> b[i];\n        }\n        vec v,v2;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= a[i]-b[i];j++) v.pb(i);\n            for(int j = 1;j <= b[i]-a[i];j++) v2.pb(i);\n        }\n        if(v.size() != v2.size()) {\n            cout << ""-1\\n"";\n            continue;\n        }\n        cout << v.size() << \'\\n\';\n        for(int i = 0;i < v.size();i++) {\n            cout << v[i] << \' \' << v2[i] << \'\\n\';\n        }\n    }\n}']",,,"['brute force', 'greedy']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. AquaMoon and Two Arrays.json,https://codeforces.com//blog/entry/92739,First if the sum of elements in is not equal to the sum of elements in then the solution does not exist Each time find a position satisfying and find such a satisfying Then let until the two arrays become the same 
https://codeforces.com//contest/1406/problem/D,720774,D,1406D,1406,D. Three Sequences,You are given a sequence of n integers a 1 a 2 ldots a n You have to construct two sequences of integers b and c with length n that satisfy for every i 1 leq i leq n b i c i a i b is non decreasing which means that for every 1 i leq n b i geq b i 1 must hold c is non increasing which means that for every 1 i leq n c i leq c i 1 must hold You have to minimize max b i c i In other words you have to minimize the maximum number in sequences b and c Also there will be q changes the i th change is described by three integers l r x You should add x to a l a l 1 ldots a r You have to find the minimum possible value of max b i c i for the initial sequence and for sequence after each change ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl '\\n'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\n\nstruct LAZY{\nvector<ll> tree,lazy;\nint n;\nLAZY(){}\nLAZY(int _n){ // pass a vector/array if needed\n  n = _n;\n  tree.resize(4*n + 100,0);\n  lazy.resize(4*n + 100,0);\n}\n\nll f(ll a,ll b){\n   return (a>b ? a : b); // max/min (a>b ? a : b)\n}\nvoid build(int no,int i,int j){\n  if(i==j){\n    tree[no] = 0;\n  }else{\n    int m = (i+j)/2;\n    int l = 2*no,r=2*no+1;\n    build(l,i,m);\n    build(r,m+1,j);\n    tree[no] = f(tree[l],tree[r]);\n  }\n}\n\nvoid propagate(int no,int i,int j){\n  if(lazy[no]==0)return;\n  tree[no]+=lazy[no];\n  if(i!=j){\n    lazy[2*no]+=lazy[no];\n    lazy[2*no+1]+=lazy[no];\n  }\n  lazy[no] = 0;\n}\n\nvoid update(int no,int i,int j,int a,int b,ll v){\n  propagate(no,i,j);\n  if(i>b || j<a || i>j)return;\n  if(a<=i && j<=b){\n    tree[no] += v;\n    if(i!=j){\n      lazy[2*no]+=v;\n      lazy[2*no+1]+=v;\n    }\n    return;\n  }\n  int m = (i+j)/2;\n  int l = 2*no,r=2*no+1;\n  update(l,i,m,a,b,v);\n  update(r,m+1,j,a,b,v);  \n  tree[no] = f(tree[l],tree[r]);\n}\n\nconst ll inf = 1e18;\nll query(int no,int i,int j,int a,int b){\n  if(i>b || j<a || i>j)return -inf;\n  \n  propagate(no,i,j);\n  \n  if(a<=i && j<=b)return tree[no];\n  \n  int m = (i+j)/2;\n  int l = 2*no,r=2*no+1;\n  \n  return f(query(l,i,m,a,b),query(r,m+1,j,a,b));\n}\n\n\n ll get(int x){\n  if(x == 1)return 0;\n  return max(0ll,query(1,1,n,x,x) - query(1,1,n,x-1,x-1));\n }\n\n};\n\n\nconst int N = 100100;\nll a[N];\n\nll get(ll X){\n  ll r = (X+1)/2 - 5;\n  while(r*2 < X)r++;\n  assert(2*r >= X);\n  return r;\n}\n\nint32_t main(){\n  FASTIO;\n  int n;\n  cin >> n;\n  LAZY L(n);\n  ll d=0;\n  for(int i=1;i<=n;i++){\n    cin >> a[i];\n    L.update(1,1,n,i,i,a[i]);\n    if(i!=1){\n      d+=max(0ll,a[i] - a[i-1]);\n    }\n  }\n  int q;\n  cin >> q;\n  cout << get(d + a[1]) << endl;\n  while(q--){\n    int l,r,x;\n    \n    cin >> l >> r >> x;\n    if(l==1)a[1]+=x;\n    pii c1 = pii(0,0),c2 = pii(0,0);\n    c1.ff = L.get(l);\n    c2.ff = L.get(r+1);\n    L.update(1,1,n,l,r,x);\n    c1.ss = L.get(l);\n    c2.ss = L.get(r+1);\n    //\n    d+=c1.ss - c1.ff;\n    d+=c2.ss - c2.ff;\n    //\n    ll res = get(d + a[1]);\n    cout << res << endl;\n  }\n}""]",,,"['constructive algorithms', 'data structures', 'greedy', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Three Sequences.json,https://codeforces.com//blog/entry/82560,Since sequence is non decreasing and sequence is non increasing we need to mimimize Now observe that if then and Else if then but Now we calculate Let this sum be Now lets assume is So then is And as observed before Now we just need to minimize Now it is easily observable that should be For the changes since we only need to know so only and will change Total time complexity 
https://codeforces.com//contest/1176/problem/D,356086,D,1176D,1176,D. Recover it ,Authors guessed an array a consisting of n integers each integer is not less than 2 and not greater than 2 cdot 10 5 You don t know the array a but you know the array b which is formed from it with the following sequence of operations Firstly let the array b be equal to the array a Secondly for each i from 1 to n if a i is a number then one integer p a i is appended to array b where p is an infinite sequence of prime numbers 2 3 5 dots otherwise if a i is not a number the greatest divisor of a i which is not equal to a i is appended to b Then the obtained array of length 2n is shuffled and given to you in the input Here p a i means the a i th prime number The first prime p 1 2 the second one is p 2 3 and so on Your task is to recover suitable array a that forms the given array b It is guaranteed that the answer exists so the array b is obtained from some suitable array a If there are multiple answers you can print any ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=400005,maxi=2*2750132;\nint prim[Maxn],cnt,bel[maxi+5];\nbool vis[maxi+5];\nvoid init(void)\n{\n\tvis[1]=true;\n\tfor(int i=2;i<=maxi;i++)\n\t{\n\t\tif(!vis[i]) prim[++cnt]=i,bel[i]=cnt;\n\t\tfor(int j=1;j<=cnt&&i*prim[j]<=maxi;j++)\n\t\t{\n\t\t\tvis[i*prim[j]]=true;\n\t\t\tif(i%prim[j]==0) break;\n\t\t}\n\t}\n}\nint n,a[Maxn];\nmultiset <int> Se,D;\nint main()\n{\n\tinit();\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=2*n;i++)\n\t\tscanf(""%d"",&a[i]),Se.insert(a[i]);\n\tsort(a+1,a+1+2*n);\n\tfor(int i=2*n;i>=1;i--)\n\t{\n\t\tif(D.find(a[i])!=D.end())\n\t\t{\n\t\t\tD.erase(D.find(a[i]));\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[a[i]])\n\t\t{\n\t\t\tint maxi=sqrt(a[i]);\n\t\t\tfor(int j=2;j<=maxi;j++)\n\t\t\t\tif(a[i]%j==0)\n\t\t\t\t{\n\t\t\t\t\tD.insert(a[i]/j);\n\t\t\t\t\tprintf(""%d "",a[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tD.insert(bel[a[i]]);\n\t\t\tprintf(""%d "",bel[a[i]]);\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['dfs and similar', 'graphs', 'greedy', 'number theory', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Recover it .json,https://codeforces.com/blog/entry/67598,Firstly let s generate first primes It can be done in almost naively just check all elements in range It also can be done with Eratosthenes sieve in or We also can calculate for each number in this range the maximum its divisor non equal to it if this number is not a prime And in other case we can calculate the index of this prime Using all this information we can restore the array Let s maintain a multiset a set in which multiple copies of the same element are allowed of all elements in While it is not empty let s take the maximum element from this set If it is prime we can check it using the information calculated earlier then it is some Let s find the index of this prime using calculated information remove this element and push in and continue Otherwise this element is not a prime and then it is some Let s remove it and its maximum divisor non equal to it from the multiset push in and continue 
https://codeforces.com//contest/688/problem/A,63905,A,688A,688,A. Opponents,Arya has opponents in the school Each day he will fight with all opponents who are present this day His opponents have some fighting plan that guarantees they will win but implementing this plan requires presence of them all That means if one day at least one of Arya s opponents is absent at the school then Arya will beat all present opponents Otherwise if all opponents are present then they will beat Arya For each opponent Arya knows his schedule whether or not he is going to present on each particular day Tell him the maximum number of days that he will beat all present opponents Note that if some day there are no opponents present Arya still considers he beats all the present opponents ,"[""// VSCF.cpp : Defines the entry point for the console application.\n//\n#include <unordered_map>\n#include <iomanip>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <set>\n#include <deque>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<string> inp(d);\n\tREP(i, d) {\n\t\tcin >> inp[i];\n\t}\n\tvector<bool> ok(d);\n\tREP(i, d) {\n\t\tREP(j, n) {\n\t\t\tif (inp[i][j] == '0') {\n\t\t\t\tok[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint co = 0;\n\tint maxCo = 0;\n\tREP(i, d) {\n\t\tif (ok[i]) {\n\t\t\tco++;\n\t\t\tmaxCo = max(co, maxCo);\n\t\t} else {\n\t\t\tco = 0;\n\t\t}\n\t}\n\tcout << maxCo;\n\treturn 0;\n}\n\n""]",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Opponents.json,https://codeforces.com//blog/entry/45770,Let s find out for each row of the given matrix if it is completely consisting of ones or not Make another array canWin and set canWini equal to one if the i th row consists at least one zero Then the problem is to find the maximum subsegment of canWin array consisting only ones It can be solved by finding for each element of canWin the closest zero to it from left The complexity of this solution is O nd but the limits allow you to solve the problem in O nd2 by iterating over all possible subsegments and check if each one of them is full of ones or not 
https://codeforces.com//contest/776/problem/B,95206,B,776B,776,B. Sherlock and his girlfriend,Sherlock has a new girlfriend so unlike him Valentine s day is coming and he wants to gift her some jewelry He bought pieces of jewelry The th piece has price equal to that is the prices of the jewelry are Watson gave Sherlock a challenge to color these jewelry pieces such that two pieces don t have the same color if the price of one piece is a prime divisor of the price of the other piece Also Watson asked him to minimize the number of different colors used Help Sherlock complete this trivial task ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[101000], n;\nint main(){\n    int i, j;\n    scanf(""%d"",&n);\n    for(i=2;i<=n+1;i++){\n        for(j=i+i;j<=n+1;j+=i){\n            w[j] = 1;\n        }\n    }\n    if(n<=2){\n        printf(""1\\n"");\n        for(i=1;i<=n;i++)printf(""%d "",1);\n        return 0;\n    }\n    printf(""2\\n"");\n    for(i=1;i<=n;i++){\n        if(!w[i+1])printf(""1 "");\n        else printf(""2 "");\n    }\n}']",,,"['constructive algorithms', 'number theory']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Sherlock and his girlfriend.json,https://codeforces.com//blog/entry/50622,Hint Observe that if is prime then only would the pieces having their prices as the multiples of would have to be of a different color Editorial We are required to color the jewelry pieces such that for every jewelry piece having a price all the pieces whose prices are prime divisors of should have colors different from that of the th piece This can be achieved by simply coloring all the pieces with their prices as primes in one color and all the other pieces in a second color We calculate the Sieve of Eratosthenes upto the range of and thus obtain the list of primes as well as non primes 
https://codeforces.com//contest/1436/problem/F,772601,F,1436F,1436,F. Sum Over Subsets,You are given a multiset S Over all pairs of subsets A and B such that B subset A B A 1 greatest common divisor of all elements in A is equal to one find the sum of sum x in A x cdot sum x in B x modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include <debug-template.hpp>\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<int MOD>\nstruct ModInt {\n\tModInt() : ModInt(0) {}\n\ttemplate<class U> ModInt(const U& x) { val = (1LL * x % MOD + MOD) % MOD; }\n\tModInt(const ModInt& x) { val = static_cast<int>(x); }\n\ttemplate<class U> inline operator U() const { return static_cast<U>(val); }\n\tinline ModInt& operator=(const ModInt& x) { val = static_cast<int>(x); return *this; }\n\ttemplate<class U> inline ModInt& operator=(const U& x) { val = static_cast<int>(ModInt(x)); return *this; }\n\tinline ModInt& operator+=(const ModInt& x) { val = (val + static_cast<long long>(x)) % MOD; return *this; }\n\tinline ModInt& operator-=(const ModInt& x) { val = (val - static_cast<long long>(x) + MOD) % MOD; return *this; }\n\tinline ModInt& operator*=(const ModInt& x) { val = (val * static_cast<long long>(x)) % MOD; return *this; }\n\tinline ModInt& operator/=(const ModInt& x) { *this *= ~x; return *this; }\n\ttemplate<class U> inline ModInt& operator+=(const U& x) { *this += ModInt(x); return *this; }\n\ttemplate<class U> inline ModInt& operator-=(const U& x) { *this -= ModInt(x); return *this; }\n\ttemplate<class U> inline ModInt& operator*=(const U& x) { *this *= ModInt(x); return *this; }\n\ttemplate<class U> inline ModInt& operator/=(const U& x) { *this /= ModInt(x); return *this; }\n\tinline ModInt& operator++() { return *this += 1; }\n\tinline ModInt operator++(int) { ModInt tmp = *this; *this += 1; return tmp; }\n\tinline ModInt& operator--() { return *this -= 1; }\n\tinline ModInt operator--(int) { ModInt tmp = *this; *this -= 1; return tmp; }\n\tfriend inline ModInt operator+(const ModInt& x, const ModInt& y) { return ModInt(x) += y; }\n\tfriend inline ModInt operator-(const ModInt& x, const ModInt& y) { return ModInt(x) -= y; }\n\tfriend inline ModInt operator*(const ModInt& x, const ModInt& y) { return ModInt(x) *= y; }\n\tfriend inline ModInt operator/(const ModInt& x, const ModInt& y) { return ModInt(x) /= y; }\n\tfriend inline bool operator==(const ModInt& x, const ModInt& y) { return static_cast<int>(x) == static_cast<int>(y); };\n\tfriend inline bool operator!=(const ModInt& x, const ModInt& y) { return static_cast<int>(x) != static_cast<int>(y); };\n\tinline ModInt operator+() const { return ModInt(+val); }\n\tinline ModInt operator-() const { return ModInt(-val); }\n\tinline ModInt operator~() const { return Pow(MOD - 2); }\n\ttemplate<class U> friend inline ModInt operator+(const ModInt& x, const U& y) { return ModInt(x) += y; }\n\ttemplate<class U> friend inline ModInt operator-(const ModInt& x, const U& y) { return ModInt(x) -= y; }\n\ttemplate<class U> friend inline ModInt operator*(const ModInt& x, const U& y) { return ModInt(x) *= y; }\n\ttemplate<class U> friend inline ModInt operator/(const ModInt& x, const U& y) { return ModInt(x) /= y; }\n\ttemplate<class U> friend inline ModInt operator+(const U& x, const ModInt& y) { return ModInt(x) += y; }\n\ttemplate<class U> friend inline ModInt operator-(const U& x, const ModInt& y) { return ModInt(x) -= y; }\n\ttemplate<class U> friend inline ModInt operator*(const U& x, const ModInt& y) { return ModInt(x) *= y; }\n\ttemplate<class U> friend inline ModInt operator/(const U& x, const ModInt& y) { return ModInt(x) /= y; }\n\ttemplate<class U> friend inline bool operator==(const ModInt& x, const U& y) { return x == ModInt(y); };\n\ttemplate<class U> friend inline bool operator!=(const ModInt& x, const U& y) { return x != ModInt(y); };\n\ttemplate<class U> friend inline bool operator==(const U& x, const ModInt& y) { return ModInt(x) == y; };\n\ttemplate<class U> friend inline bool operator!=(const U& x, const ModInt& y) { return ModInt(x) != y; };\n\ttemplate<class U> friend inline U& operator<<(U& ost, const ModInt& y) { return ost << static_cast<int>(y); }\n\ttemplate<class U> friend inline U& operator>>(U& ist, ModInt& x) { int t; ist >> t; x = t; return ist; }\n\ttemplate<class U> friend inline U& operator+=(U& x, const ModInt& y) { x = static_cast<U>(x + y); return x; }\n\ttemplate<class U> friend inline U& operator-=(U& x, const ModInt& y) { x = static_cast<U>(x - y); return x; }\n\ttemplate<class U> friend inline U& operator*=(U& x, const ModInt& y) { x = static_cast<U>(x * y); return x; }\n\ttemplate<class U> friend inline U& operator/=(U& x, const ModInt& y) { x = static_cast<U>(x / y); return x; }\n\ttemplate<class U> inline ModInt Pow(U n) const {\n\t\tif (n < 0) return ~Pow(-n);\n\t\tModInt rlt = 1, tmp = *this;\n\t\twhile (n) {\n\t\t\tif (n & 1) rlt *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn rlt;\n\t}\nprivate:\n\tint val;\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tusing mint = ModInt<998244353>;\n\tint M; cin >> M;\n\tvector<int> freq(100001);\n\tvector<mint> ans(100001);\n\twhile (M--) {\n\t\tint a; cin >> a;\n\t\tcin >> freq[a];\n\t}\n\tmint tp = 2;\n\tfor (int i = freq.size() - 1; i >= 1; i--) {\n\t\tlong long k = 0; mint s = 0, t = 0;\n\t\tfor (int j = i; j < freq.size(); j += i) {\n\t\t\tk += freq[j];\n\t\t\ts += freq[j] * mint(j);\n\t\t\tt += mint(j) * freq[j] * j;\n\t\t}\n\t\ts = (s * s - t);\n\t\t// a[i] * a[i] (k - 1) * 2 ^ (k - 2)\n\t\t// a[i] * a[j] k * 2 ^ (k - 2)\n\t\tans[i] = tp.Pow(k-3) * (s * k + t * (k - 1) * tp);\n\t\tfor (int j = i * 2; j < freq.size(); j += i) ans[i] -= ans[j];\n\t}\n\tcout << ans[1];\n\t\n\treturn 0;\n}\n']",,,"['combinatorics', 'math', 'number theory']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Sum Over Subsets.json,https://codeforces.com//blog/entry/84024,Let s calculate the required product of the sums for the sets the greatest common divisor of the elements of which is First let s select all the elements that are divisible by To find only those sets whose GCD is exactly one can find the product of the sums for all subsets and subtract the answers of all such that and divides without a remainder To find the products of all subsets of a set of elements consider two cases the product will be counted times Each element in the set can be removed and this will add the product The number of elements and the number select the rest of the subset the product will be counted The first term is similar to the example above And the second is obtained if is removed from the set the number of ways to choose a subset of elements is It is only to count the individual sums and for all elements that are divisible by To do this you can maintain for already added numbers their number sum sum of squares of numbers and pairwise sum of numbers The answer to the problem will be 
https://codeforces.com//contest/1703/problem/E,1459219,E,1703E,1703,E. Mirror Grid,You are given a square grid with n rows and n columns Each cell contains either 0 or 1 In an operation you can select a cell of the grid and flip it from 0 to 1 or 1 to 0 Find the minimum number of operations you need to obtain a square that remains the same when rotated 0 circ 90 circ 180 circ and 270 circ The picture below shows an example of all rotations of a grid ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""../debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""../input.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n\tfstart;\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n; cin >> n;\n\t\tvector<string> a(n);\n\t\tfor (auto& s : a)\n\t\t\tcin >> s;\n\n\t\tint res = 0;\n\t\tfor (int l = 0; l < n / 2; l++) {\n\t\t\tfor (int i = l; i < n - l; i++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tcnt += (a[l][i] == \'1\');\n\t\t\t\ta[l][i] = \'2\';\n\t\t\t\tcnt += (a[i][n - 1 - l] == \'1\');\n\t\t\t\ta[i][n - 1 - l] = \'2\';\n\t\t\t\tcnt += (a[n - 1 - l][n - 1 - i] == \'1\');\n\t\t\t\ta[n - 1 - l][n - 1 - i] = \'2\';\n\t\t\t\tcnt += (a[n - 1 - i][l] == \'1\');\n\t\t\t\ta[n - 1 - i][l] = \'2\';\n\t\t\t\tres += min(cnt, 4 - cnt);\n\t\t\t}\n\t\t}\n\n\t\tcout << res << ""\\n"";\n\n\t}\n\n\n\tfinish;\n}\n\n']",,,['implementation'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\E. Mirror Grid.json,https://codeforces.com//blog/entry/104786,Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase 
https://codeforces.com//contest/1881/problem/B,2259903,B,1881B,1881,B. Three Threadlets,Once upon a time bartender Decim found three threadlets and a pair of scissors In one operation Decim chooses any threadlet and cuts it into two threadlets whose lengths are and their sum is to the length of the threadlet being cut For example he can cut a threadlet of length 5 into threadlets of lengths 2 and 3 but he cannot cut it into threadlets of lengths 2 5 and 2 5 or lengths 0 and 5 or lengths 3 and 4 Decim can perform three operations He is allowed to cut the threadlets obtained from previous cuts Will he be able to make all the threadlets of equal length ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,m,k,a[N];\nstring s,t;\nvoid prep(){\n\n}\nvoid solve()\n{\n    cin>>n>>m>>k;\n    if (m>k) swap(m,k);\n    if (n>m) swap(n,m);\n    if (m>k) swap(m,k);\n    if (n==k) cout<<""YES"";\n    else if (k%2==0 && n==m && n==k/2) cout<<""YES"";\n    else if (k%3==0 && n==m && n==k/3) cout<<""YES"";\n    else if (k%4==0 && n==m && n==k/4) cout<<""YES"";\n    else if (k%2==0 && m%2==0 && n==m/2 && n==k/2) cout<<""YES"";\n    else if (k%3==0 && m%2==0 && n==m/2 && n==k/3) cout<<""YES"";\n    else cout<<""NO"";\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']",,,['math'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Three Threadlets.json,https://codeforces.com//blog/entry/121327,If the lengths of the threadlets are equal the answer is Otherwise let s denote the length of the minimum threadlet as If we cut it we will have only two operations which is not enough Therefore the desired length should be equal to If or are not divisible by the answer is Otherwise we will check if 
https://codeforces.com//contest/1101/problem/C,281056,C,1101C,1101,C. Division and Union,There are n segments l i r i for 1 le i le n You should divide all segments into two groups in such way that there is no pair of segments from different groups which have at least one common point or say that it s impossible to do it Each segment should belong to exactly one group To optimize testing process you will be given multitest ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nstruct Seg { int l,r,id; };\nbool operator<(const Seg &a,const Seg &b) { return a.l<b.l; }\n\nint n;\nSeg seg[MAXN];\nint ans[MAXN];\n\nbool solve() {\n\tsort(seg,seg+n);\n\tint upto=seg[0].r;\n\tREP(i,n) {\n\t\tif(seg[i].l>upto) { REP(j,n) ans[seg[j].id]=seg[j].r<=upto?1:2; return true; }\n\t\tupto=max(upto,seg[i].r);\n\t}\n\treturn false;\n}\n\nvoid run() {\n\tscanf(""%d"",&n);\n\tREP(i,n) scanf(""%d%d"",&seg[i].l,&seg[i].r),seg[i].id=i;\n\tif(!solve()) { printf(""-1\\n""); return; }\n\tREP(i,n) { if(i!=0) printf("" ""); printf(""%d"",ans[i]); } puts("""");\n}\n\nint main() {\n\tint n; scanf(""%d"",&n); REP(i,n) run();\n\treturn 0;\n}']",,,['sortings'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Division and Union.json,https://codeforces.com/blog/entry/64483,Let s prove that division possible if and only if union of all segments has two and more segments If the union have at least two segments then we can choose one of them and put all segments it contains in one group and other segments to another group On the other hand if we can divide all segments in two groups in such way that there are no pair from different group which intersects then union of segments from the first group doesn t intersect union of segments from another and union of unions consists of several non intersecting components How can it help If union of segments consits of several segments then exists such that for any segment either or and both parts are non empty Moreover equals to one of It leads us straight to one of possible solutions sort all segments by in increasing order and for each we should check that suffix minimum If we ve found such then all prefix goes to one group and suffix to another 
https://codeforces.com//contest/1454/problem/D,808363,D,1454D,1454,D. Number into Sequence,You are given an integer n n 1 Your task is to find a sequence of integers a 1 a 2 ldots a k such that each a i is strictly greater than 1 a 1 cdot a 2 cdot ldots cdot a k n i e the product of this sequence is n a i 1 is divisible by a i for each i from 1 to k 1 k is the possible i e the length of this sequence is the possible If there are several such sequences any of them is acceptable It can be proven that at least one valid sequence always exists for any integer n 1 You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nnamespace factorBasic {\n    template<class T> vector<pair<T,int>> factor(T x) { \n        vector<pair<T,int>> pri;\n        for (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n            int t = 0;\n            while (x % i == 0) x /= i, t ++;\n            pri.pb({i,t});\n        }\n        if (x > 1) pri.pb({x,1});\n        return pri;\n    }\n    /* Note:\n     * number of operations needed s.t.\n     *                phi(phi(...phi(n)...))=1\n     * is O(log n).\n     * Euler\'s theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1\n     */\n    ll phi(ll x) {\n        trav(a,factor(x)) x -= x/a.f;\n        return x;\n    }\n    template<class T> void tour(vector<pair<T,int>>& v, \n        vector<T>& V, int ind, T cur) {\n            if (ind == sz(v)) V.pb(cur);\n            else {\n                T mul = 1;\n                F0R(i,v[ind].s+1) {\n                    tour(v,V,ind+1,cur*mul);\n                    mul *= v[ind].f;\n                }\n            }\n        }\n    template<class T> vector<T> getDivi(T x) {\n        auto v = factor(x);\n        vector<T> V; tour(v,V,0,(T)1); sort(all(V));\n        return V;\n    }\n}\n\nusing namespace factorBasic;\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        ll n; re(n);\n        auto f = factor<ll>(n);\n        int k = 0;\n        for (auto x : f) {\n            ckmax(k, x.s);\n        }\n        vl res(k, 1);\n        for (auto x : f ){\n            int cnt = 0;\n            for (int i = k-1; i >= 0; i--) {\n                res[i] *= x.f;\n                cnt++;\n                if (cnt == x.s) break;\n            }\n        }\n        ps(sz(res));\n        for (auto x : res) pr(x, "" "");\n        ps();\n    }\n    return 0;\n}']",,,"['constructive algorithms', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Number into Sequence.json,https://codeforces.com//blog/entry/84984,Consider in this canonical form just find the prime factorization of Let be such an index that is the maximum among all values of Then the answer length can not exceed This is because if the answer has greater length then some number doesn t have in its representation thus there will be problems with divisibility because we are considering primes So let s create the answer of length consisting of Then let s just multiply the last element by all other primes in their degrees So we satisfied the divisibility rule and the length of the answer is the maximum possible 
https://codeforces.com//contest/922/problem/D,154241,D,922D,922,D. Robot Vacuum Cleaner,Pushok the dog has been chasing Imp for a few hours already Fortunately Imp knows that Pushok is afraid of a robot vacuum cleaner While moving the robot generates a string consisting of letters and that produces a lot of noise We define of string as the number of occurrences of string as a in it in other words the number of such pairs that and and The robot is off at the moment Imp knows that it has a sequence of strings in its memory and he can arbitrary change their order When the robot is started it generates the string as a concatenation of these strings in the given order The noise of the resulting string equals the noise of this concatenation Help Imp to find the maximum noise he can achieve by changing the order of the strings ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, a[MAXN];\nstring s[MAXN];\n\nll get(string t){\n\tll res = 0;\n\tint c = 0;\n\tfor (int i = 0; i < t.size(); i++){\n\t\tif (t[i] == 's')\n\t\t\tc++;\n\t\telse\n\t\t\tres += c;\n\t}\n\treturn res;\n}\n\nbool cmp(int u, int v){\n\treturn get(s[u]+s[v]) > get(s[v]+s[u]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> s[i];\n\tiota(a, a + n, 0);\n\tsort(a, a + n, cmp);\n\tstring t;\n\tfor (int i = 0; i < n; i++)\n\t\tt += s[a[i]];\n\tcout << get(t) << endl;\n}\n""]",,,"['greedy', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Robot Vacuum Cleaner.json,https://codeforces.com//blog/entry/57605,Denote as the noise function We are gonna sort the string set in the following way for each pair we will put earlier if The claim is that the final concatenation will be optimal Let be the number of subsequences in in Then and are reduced and the comparator turns into This is almost equivalent to except the degenerate case when the string consists of only meaning that the sort is transitive Now suppose that this is all false and in the optimal concatenation for some pair of strings the aforementioned statement doesn t hold Then it can be easily shown that you can change their positions and the answer will only get better 
https://codeforces.com//contest/786/problem/B,99628,B,786B,786,B. Legacy,Rick and his co workers have made a new radioactive formula and a lot of bad guys are after them So Rick wants to give his legacy to Morty before bad guys catch them There are planets in their universe numbered from to Rick is in planet number the earth and he doesn t know where Morty is As we all know Rick owns a portal gun With this gun he can open one way portal from a planet he is in to any other planet including that planet But there are limits on this gun because he s still using its free trial By default he can not open any portal by this gun There are plans in the website that sells these guns Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more Plans on the website have three types With a plan of this type you can open a portal from planet to planet With a plan of this type you can open a portal from planet to any planet with index in range With a plan of this type you can open a portal from any planet with index in range to planet Rick doesn t known where Morty is but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately So for each planet including earth itself he wants to know the minimum amount of money he needs to get from earth to that planet ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=901000;\nvector<PII> e[N];\nVI ve;\nll dis[N];\nint vis[N],tot;\nset<pair<ll,int> > hs;\nint nd[2][N],n,q,s,ty,u,v,w,l,r;\nvoid add(int u,int v,int w) {\n\te[u].pb(mp(v,w));\n//\tprintf(""%d %d %d\\n"",u,v,w);\n}\nvoid dijkstra(int S,int n) {\n\trep(i,1,n+1) dis[i]=1ll<<60,vis[i]=0;\n\tdis[S]=0;\n\trep(i,1,n+1) hs.insert(mp(dis[i],i));\n\trep(i,1,n+1) {\n\t\tint u=hs.begin()->se; hs.erase(hs.begin());\n\t\tvis[u]=1;\n\t\trep(j,0,SZ(e[u])) {\n\t\t\tint v=e[u][j].fi;\n\t\t\tif (dis[v]>dis[u]+e[u][j].se) {\n\t\t\t\ths.erase(mp(dis[v],v));\n\t\t\t\tdis[v]=dis[u]+e[u][j].se;\n\t\t\t\ths.insert(mp(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid build(int p,int l,int r,int ty) {\n\tnd[ty][p]=++tot;\n\tif (l==r) {\n\t\tif (ty==0) add(nd[0][p],l,0);\n\t\tif (ty==1) add(l,nd[1][p],0);\n\t\treturn;\n\t}\n\tint md=(l+r)>>1;\n\tbuild(p+p,l,md,ty);\n\tbuild(p+p+1,md+1,r,ty);\n\tif (ty==0) {\n\t\tadd(nd[0][p],nd[0][p+p],0);\n\t\tadd(nd[0][p],nd[0][p+p+1],0);\n\t} else {\n\t\tadd(nd[1][p+p],nd[1][p],0);\n\t\tadd(nd[1][p+p+1],nd[1][p],0);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,int ty) {\n\tif (tl==l&&tr==r) ve.pb(nd[ty][p]);\n\telse {\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,ty);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,ty);\n\t\telse modify(p+p,l,md,tl,md,ty),modify(p+p+1,md+1,r,md+1,tr,ty);\n\t}\n}\nint main() {\n\tscanf(""%d%d%d"",&n,&q,&s);\n\ttot=n+1;\n\tbuild(1,1,n,0);\n\tbuild(1,1,n,1);\n\trep(i,1,q+1) {\n\t\tscanf(""%d%d"",&ty,&v);\n\t\tif (ty==1) {\n\t\t\tscanf(""%d%d"",&u,&w);\n\t\t\tadd(v,u,w);\n\t\t} else {\n\t\t\tscanf(""%d%d%d"",&l,&r,&w);\n\t\t\tve.clear();\n\t\t\tmodify(1,1,n,l,r,ty-2);\n\t\t\tif (ty==2) {\n\t\t\t\tfor (auto u:ve) add(v,u,w);\n\t\t\t} else {\n\t\t\t\tfor (auto u:ve) add(u,v,w);\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(s,tot-1);\n\trep(i,1,n+1) {\n\t\tif (dis[i]>=(1ll<<50)) dis[i]=-1;\n\t\tprintf(""%lld "",dis[i]);\n\t}\n\tputs("""");\n}\n']",,,"['data structures', 'graphs', 'shortest paths']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Legacy.json,https://codeforces.com//blog/entry/51163,Consider a weighted directed graph initially it has vertices and no edges We will construct a segment tree to handle queries of second type and one for the third type but with similar approach Build a segment tree on number For each node of segment tree consider a vertex in the graph For each leaf in this tree like one with interval add an edge with weight equal to from vertex corresponding to this node to vertex in the original graph And for each non leaf node add an edge with weight equal to from vertex corresponding to this node to the vertex corresponding to node of each of its children So we re adding about vertices and edges to the graph For each query of second type we will add an edge from to each maximal node of segment tree that contains nodes for each query with weight equal to And construct a segment tree in the same way for queries of third type Finally run Dijkstra s algorithm on this graph Time complexity 
https://codeforces.com//contest/1799/problem/E,1800602,E,1799E,1799,E. City Union,You are given n times m grid Some cells are filled and some are empty A is a maximal by inclusion set of filled cells such that it is possible to get from any cell in the set to any other cell in the set by moving to adjacent by side cells without moving into any cells not in the set In other words a city is a connected component of filled cells with edges between adjacent by side cells Initially there are on the grid You want to change some empty cells into filled cells so that both of the following are satisfied There is on the resulting grid The shortest path between any two filled cells achievable only by moving onto filled cells is equal to the Manhattan distance between them The between two cells a b and c d is equal to a c b d Find a way to add filled cells that satisfies these conditions and minimizes the total number of filled cells ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::string> s(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> s[i];\n    }\n    \n    std::vector<int> minr(n, m), maxr(n, -1), minc(m, n), maxc(m, -1);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (s[i][j] == \'#\') {\n                minr[i] = std::min(minr[i], j);\n                maxr[i] = std::max(maxr[i], j);\n                minc[j] = std::min(minc[j], i);\n                maxc[j] = std::max(maxc[j], i);\n            }\n        }\n    }\n    \n    std::function<void(int, int)> work = [&](int x, int y) -> void {\n        s[x][y] = \'#\';\n        minr[x] = std::min(minr[x], y);\n        maxr[x] = std::max(maxr[x], y);\n        minc[y] = std::min(minc[y], x);\n        maxc[y] = std::max(maxc[y], x);\n        \n        for (int j = minr[x]; j <= maxr[x]; j++) {\n            if (s[x][j] == \'.\') {\n                work(x, j);\n            }\n        }\n        for (int i = minc[y]; i <= maxc[y]; i++) {\n            if (s[i][y] == \'.\') {\n                work(i, y);\n            }\n        }\n    };\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = minr[i]; j <= maxr[i]; j++) {\n            if (s[i][j] == \'.\') {\n                work(i, j);\n            }\n        }\n    }\n    for (int j = 0; j < m; j++) {\n        for (int i = minc[j]; i <= maxc[j]; i++) {\n            if (s[i][j] == \'.\') {\n                work(i, j);\n            }\n        }\n    }\n    \n    int u1 = 0;\n    while (minr[u1] > maxr[u1]) {\n        u1++;\n    }\n    int d1 = u1;\n    while (d1 + 1 < n && minr[d1 + 1] <= maxr[d1] && maxr[d1 + 1] >= minr[d1]) {\n        d1++;\n    }\n    int u2 = d1 + 1;\n    while (u2 < n && minr[u2] > maxr[u2]) {\n        u2++;\n    }\n    if (u2 < n) {\n        int d2 = u2;\n        while (d2 + 1 < n && minr[d2 + 1] <= maxr[d2] && maxr[d2 + 1] >= minr[d2]) {\n            d2++;\n        }\n        \n        int r1 = -1, l2 = m;\n        int r2 = -1, l1 = m;\n        for (int i = u1; i <= d1; i++) {\n            r1 = std::max(r1, maxr[i]);\n            l1 = std::min(l1, minr[i]);\n        }\n        for (int i = u2; i <= d2; i++) {\n            r2 = std::max(r2, maxr[i]);\n            l2 = std::min(l2, minr[i]);\n        }\n        if (r1 < l2) {\n            work(d1, r1);\n            work(u2, l2);\n            for (int i = d1 + 1; i <= u2; i++) {\n                work(i, r1);\n            }\n        } else {\n            work(d1, l1);\n            work(u2, r2);\n            for (int i = d1 + 1; i <= u2; i++) {\n                work(i, l1);\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << s[i] << ""\\n"";\n    }\n    std::cout << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'dsu', 'geometry', 'greedy', 'implementation', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. City Union.json,https://codeforces.com//blog/entry/113321,Let s note that the resulting grid is correct if and only if filled cells form continious segment in each row and column condition and there is one city So we can define a filling operation given a grid fill all cells between the most left and most right cells in each row and the most up and most down cells in each column Doing this operation times we get that condition is satisfied and we filled cells that definitely should be filled If now there is one city we solved the problem But if there are still two cities their projections to horisontal and vertical axes do not intersect So we need to connect them with some path Let s consider the case when one city is upper left than the other city otherwise we can apply rotation and get this case Let s define the lowest row of the first city as the right column of the first city as the upper row of the second city as and the left column of the second city as We can fill cells on any Manhattan shortest path between cells After that again using filling operation we will fill cells that should be filled It is easy to see that by this solution we will get the smallest possible number of filled cells Time complexity 
https://codeforces.com//contest/1979/problem/D,2684282,D,1979D,1979,D. Fixing a Binary String,You are given a binary string s of length n consisting of zeros and ones You can perform the following operation Choose an integer p 1 le p le n Reverse the substring s 1 s 2 ldots s p After this step the string s 1 s 2 ldots s n will become s p s p 1 ldots s 1 s p 1 s p 2 ldots s n Then perform a cyclic shift of the string s to the left p times After this step the initial string s 1s 2 ldots s n will become s p 1 s p 2 ldots s n s p s p 1 ldots s 1 For example if you apply the operation to the string with p 3 after the second step the string will become and after the third step it will become A string s is called if two conditions are met s 1 s 2 ldots s k s i k neq s i for any i 1 le i le n k For example with k 3 the strings and are k proper while the strings and are not You are given an integer k which of n Find an integer p 1 le p le n such that after performing the operation the string s becomes k proper or determine that it is impossible Note that if the string is initially k proper you still need to apply exactly one operation to it ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));const int MOD=1e9+7;const int P=rnd()%MOD;const int MAXN=2e5+5;ll pw[MAXN],hs[MAXN],rhs[MAXN];int n,k;char c[MAXN];ll get_hs(ll *h,int l,int r){return (h[r]-h[l-1]*pw[r-l+1]%MOD+MOD)%MOD;}void solve(){\tcin>>n>>k>>(c+1);\tfor(int i=1;i<=n;i++) hs[i]=(hs[i-1]*P+c[i]-\'0\')%MOD;\trhs[n+1]=hs[n+1]=0;\tfor(int i=1;i<=n;i++) rhs[i]=(rhs[i-1]*P+c[n+1-i]-\'0\')%MOD;\tll g1=0,g2=0;\tfor(int i=0;i<n;i++){\t\tg1=(g1*P+((i/k)%2))%MOD;\t\tg2=(g2*P+(1-(i/k)%2))%MOD;\t}\tfor(int p=1;p<=n;p++){\t\tll gh=get_hs(hs,p+1,n)*pw[p]+get_hs(rhs,n+1-p,n);\t\tgh%=MOD;\t\tif(gh==g1||gh==g2){\t\t\tcout<<p<<\'\\n\';\t\t\treturn;\t\t}\t}\tcout<<""-1\\n"";}int main(){\tios::sync_with_stdio(false);\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tpw[0]=1;\tfor(int i=1;i<MAXN;i++) pw[i]=pw[i-1]*P%MOD;\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}']",,,"['bitmasks', 'brute force', 'constructive algorithms', 'dp', 'greedy', 'hashing', 'strings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Fixing a Binary String.json,https://codeforces.com//blog/entry/130213,SolutionLet s consider the block of characters at the end Notice that their quantity cannot decrease Let be the number of identical characters at the end there are three possible cases it is enough to find any block of length greater than and separate a block of length from it obviously there is no solution find a block of length or and separate a block of length from it This solution works in but it is not the only correct one Your solution may differ significantly from the one proposed 
https://codeforces.com//contest/791/problem/B,98945,B,791B,791,B. Bear and Friendship Condition,Bear Limak examines a social network Its main functionality is that two members can become friends then they can talk with each other and share funny pictures There are members numbered through pairs of members are friends Of course a member can t be a friend with themselves Let denote that members and are friends Limak thinks that a network is if and only if the following condition is satisfied For every three members if and then also For example if Alan and Bob are friends and Bob and Ciri are friends then Alan and Ciri should be friends as well Can you help Limak and check if the network is reasonable Print or accordingly without the quotes ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n\n#define inf 0x3f3f3f3f\n#define Inf 0x3FFFFFFFFFFFFFFFLL\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define Rep(i, n) for (int i = 1; i <= (n); ++i)\n#define clr(x, a) memset(x, (a), sizeof x)\nusing namespace std;\ntypedef long long ll;\nint const N = 202020;\nint parents[N];\nint deg[N];\nint Find(int a) {\n\treturn parents[a] < 0 ? a : parents[a] = Find(parents[a]);\n}\nvoid Union(int a,int b) {\n\tif (parents[a] < parents[b]) parents[a] += parents[b], parents[b] = a;\n\telse parents[b] += parents[a], parents[a] = b;\n}\nvoid init() { clr(parents, 0xff); }\n\nint main() {\n\tinit(); int n, m; scanf(""%d%d"", &n, &m);\n\trep(i, m) {\n\t\tint a, b; scanf(""%d %d"", &a, &b);\n\t\tint ra = Find(a), rb = Find(b);\n\t\t++deg[a], ++deg[b];\n\t\tif (ra != rb) {\n\t\t\tUnion(ra, rb);\n\t\t}\n\t}\n\tbool ok = 1;\n\tRep(i, n) {\n\t\tint t = Find(i);\n\t\tint c = -parents[t];\n\t\tif (deg[i] < c - 1) {\n\t\t\tok = 0; break;\n\t\t}\n\t}\n\tif (ok) puts(""YES""); else puts(""NO"");\n\treturn 0;\n}\n\n']",,,"['dfs and similar', 'dsu', 'graphs']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Bear and Friendship Condition.json,https://codeforces.com//blog/entry/51068,The main observation is that you should print YES if the graph is a set of disjoint cliques in each connected non clique there is a triple of vertices X Y Z that X Y and Y Z but not X Z To check if each connected component is a clique you can run dfs and count vertices and edges in the connected component it s a clique if and only if 
https://codeforces.com//contest/1394/problem/B,697385,B,1394B,1394,B. Boboniu Walks on Graph,Boboniu has a graph with n vertices and m edges The out degree of each vertex is at most k Each edge has an integer weight between 1 and m No two edges have equal weights Boboniu likes to walk on the graph with some specific rules which is represented by a tuple c 1 c 2 ldots c k If he now stands on a vertex u with out degree i then he will go to the next vertex by the edge with the c i th 1 le c i le i smallest weight among all edges outgoing from u Now Boboniu asks you to calculate the number of tuples c 1 c 2 ldots c k such that 1 le c i le i for all i 1 le i le k Starting from any vertex u it is possible to go back to u in finite time by walking on the graph under the described rules ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n,m,k,ans;\nvpi adj[MX];\nmap<pi,int> bad[MX];\n\nint BAD[500][500];\nint hsh(pi p) { return 10*p.f+p.s; }\n\nvpi st;\nvoid dfs(int x) {\n\tif (x == k+1) {\n\t\tans ++;\n\t\treturn;\n\t}\n\tF0R(i,x) {\n\t\tpi p = {x,i};\n\t\tst.pb(p);\n\t\tbool oops = 0;\n\t\ttrav(t,st) if (BAD[hsh(p)][hsh(t)]) oops = 1;\n\t\tif (!oops) {\n\t\t\tdfs(x+1);\n\t\t}\n\t\tst.pop_back();\n\t}\n}\n\nint main() {\n\tsetIO(); re(n,m,k);\n\tF0R(i,m) {\n\t\tint u,v,w; re(u,v,w);\n\t\tadj[u].pb({w,v});\n\t}\n\tFOR(i,1,n+1) {\n\t\tsort(all(adj[i]));\n\t\tF0R(j,sz(adj[i])) bad[adj[i][j].s][{sz(adj[i]),j}] ++;\n\t}\n\tFOR(i,1,n+1) {\n\t\ttrav(a,bad[i]) trav(b,bad[i]) if (a.f != b.f) {\n\t\t\tBAD[hsh(a.f)][hsh(b.f)] = 1;\n\t\t} else if (a.s > 1) {\n\t\t\tBAD[hsh(a.f)][hsh(b.f)] = 1;\n\t\t}\n\t}\n\tdfs(1);\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']",,,"['brute force', 'dfs and similar', 'graphs', 'hashing']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Boboniu Walks on Graph.json,https://codeforces.com//blog/entry/81355,Let denote the out degree of Let denote the vertex which the edge with the the smallest weight among all edges start from ends at For a fixed tuple if i e each vertex appears exactly once then it is a correct tuple Let denote if the set for vertex with out degree which is Thus the condition above can be changed to Let s enumerate all situations and use hash to check if it s correct The hash function is diverse For example for a integer set we can use or Just make sure it has associative property Here may be a random number Let alone using multiple hash The total time complexity is 
https://codeforces.com//contest/990/problem/G,188996,G,990G,990,G. GCD Counting,You are given a tree consisting of n vertices A number is written on each vertex the number on vertex i is equal to a i Let s denote the function g x y as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex x to vertex y including these two vertices For every integer from 1 to 2 cdot 10 5 you have to count the number of pairs x y 1 le x le y le n such that g x y is equal to this number ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxm = 200001;\n\nint n;\nint a[Maxm];\nint par[Maxm], siz[Maxm];\nll cur;\nvector <int> V[Maxm];\nvector <ii> E[Maxm];\nll res[Maxm];\n\nint gcd(int x, int y) { return x? gcd(y % x, x): y; }\n\nint getPar(int x) { return par[x] == x? x: par[x] = getPar(par[x]); }\n\nvoid unionSet(int a, int b)\n{\n\ta = getPar(a), b = getPar(b);\n\tif (a == b) return;\n\tif (siz[a] < siz[b]) swap(a, b);\n\tcur -= ll(siz[a]) * (siz[a] + 1) / 2;\n\tcur -= ll(siz[b]) * (siz[b] + 1) / 2;\n\tsiz[a] += siz[b]; par[b] = a;\n\tcur += ll(siz[a]) * (siz[a] + 1) / 2;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tV[a[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v; scanf(""%d %d"", &u, &v);\n\t\tE[gcd(a[u], a[v])].push_back(ii(u, v));\n\t}\n\tfor (int i = Maxm - 1; i > 0; i--) {\n\t\tcur = 0;\n\t\tfor (int j = i; j < Maxm; j += i) {\n\t\t\tfor (int k = 0; k < V[j].size(); k++) {\n\t\t\t\tint v = V[j][k];\n\t\t\t\tpar[v] = v; siz[v] = 1;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tif (j > i) res[i] -= res[j];\n\t\t}\n\t\tfor (int j = i; j < Maxm; j += i)\n\t\t\tfor (int k = 0; k < E[j].size(); k++) {\n\t\t\t\tii& p = E[j][k];\n\t\t\t\tunionSet(p.first, p.second);\n\t\t\t}\n\t\tres[i] += cur;\n\t}\n\tfor (int i = 1; i < Maxm; i++) if (res[i] > 0)\n\t\tprintf(""%d %I64d\\n"", i, res[i]);\n\treturn 0;\n}']",,,"['divide and conquer', 'dp', 'dsu', 'number theory', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. GCD Counting.json,https://codeforces.com//blog/entry/59962,Firstly for every we can calculate the number of paths such that is divisible by We can do it as follows generate all divisors of numbers numbers not exceeding have at most divisors so this will be fast enough and then for every analyze the graph containing the vertices that have as its divisor Each component of this graph gives us paths if its size is and this is the only formula we need to calculate the number of paths where is divisible by let this be How can we get the answer if we know the values of We can use inclusion exclusion with Mobius function for example to prove that and then if we want to apply the same technique for finding with any possible we could divide all numbers by and do the same thing But it might be too slow so it s better to rewrite this formula as because we will do exactly the same when dividing all numbers by In fact most contestants have written a much easier version of this solution so this might be a bit too complicated This problem can also be solved with centroid decomposition 
https://codeforces.com//contest/1152/problem/F1,335385,F1,1152F1,1152,F1. Neko Rules the Catniverse  Small Version , Aki is playing a new video game In the video game he will control Neko the giant cat to fly between planets in the Catniverse There are n planets in the Catniverse numbered from 1 to n At the beginning of the game Aki chooses the planet where Neko is initially located Then Aki performs k 1 moves where in each move Neko is moved from the current planet x to some other planet y such that Planet y is not visited yet 1 leq y leq x m where m is a fixed constant given in the input This way Neko will visit exactly k different planets Two ways of visiting planets are called different if there is some index i such that the i th planet visited in the first way is different from the i th planet visited in the second way What is the total number of ways to visit k planets this way Since the answer can be quite large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007;\nll cc[105][15];\nll modpow(ll a, int b) {\n\tll res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn res;\n}\nint dis[20], arr[20], K, n, m;\nll f[4100][12];\nvector<int> bt[4100];\nstruct HashMap {\n\tstatic const int N = 1 << 20, B = N - 1;\n\tll key[N], sz; bool vis[N];\n\tll val[N];\n\tint hash(ll x) { return (x << 16 ^ x >> 6 ^ x << 1) & B; }\n\tint khash(ll x) { return (x << 15 ^ x >> 5 ^ x << 2) & B; }\n\tvoid ins(ll x, int y) {\n\t\tint t = hash(x), s = khash(x) | 1;\n\t\twhile (vis[t]) {\n\t\t\tif (key[t] == x) { val[t] += y; return; }\n\t\t\tt = (t + s) & B;\n\t\t}\n\t\tvis[t] = true, key[t] = x, ++sz, val[t] = y;\n\t}\n\tint query(ll x) {\n\t\tint t = hash(x), s = khash(x) | 1;\n\t\twhile (vis[t]) {\n\t\t\tif (key[t] == x) return val[t];\n\t\t\tt = (t + s) & B;\n\t\t}\n\t\treturn 0;\n\t}\n} hm, hn;\nvoid dfs(int k) {\n\tif (dis[k] >= K) return;\n\tif (k == n) {\n\t\tint mul = 0, cnt = 1;\n\t\tfor (int i = 1; i < k; i++) {\n\t\t\tint f = 0;\n\t\t\tfor (int j = i + 1; j <= k; j++)\n\t\t\t\tif (dis[j] - dis[i] <= m) f = j - i;\n\t\t\t\telse break;\n\t\t\tmul = mul * (m + 1) + f;\n\t\t\tif (dis[i + 1] - dis[i] > m) ++cnt;\n\t\t}\n\t\thm.ins(mul, cc[dis[k] + 1 - cnt][cnt]);\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= m + 1; i++) {\n\t\tdis[k + 1] = dis[k] + i;\n\t\tdfs(k + 1);\n\t}\n}\nint brr[20];\nint calc(int n) {\n\tif (n == 1) return 1;\n\tint nn = (1 << n) - 1;\n\tfor (int i = 1; i <= nn; i++)\n\tfor (int j : bt[i]) f[i][j] = 0;\n\tfor (int i = 0; i < n; i++) f[1 << i][i] = 1;\n\tfor (int i = 1; i < nn; i++)\n\tfor (int j : bt[i]) if (f[i][j])\n\tfor (int k : bt[nn ^ i]) {\n\t\tif (k > j + brr[j]) break;\n\t\tf[i | 1 << k][k] += f[i][j];\n\t}\n\tll res = 0;\n\tfor (int i = 0; i < n; i++) res += f[nn][i];\n\treturn res % MOD;\n}\nint main() {\n\tscanf(""%d%d%d"", &K, &n, &m);\n\tfor (int i = 0; i <= K && i <= 100; i++) {\n\t\tint nn = K - i;\n\t\tcc[i][0] = 1;\n\t\tfor (int j = 1; j <= nn && j <= n; j++)\n\t\t\tcc[i][j] = cc[i][j - 1] * (nn - j + 1) % MOD * modpow(j, MOD - 2) % MOD;\n\t}\n\tdfs(1);\n\t/*printf(""%d\\n"", hm.sz);\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = 0; k < n; k++, j /= m + 1) printf(""%d "", j % 5);\n\t\tputs("""");\n\t}*/\n\tfor (int i = 0; i < 1 << n; i++)\n\tfor (int j = 0; j < n; j++) if (i >> j & 1) bt[i].push_back(j);\n\tll ans = 0;\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);\n\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\tint k = j;\n\t\t\twhile (k < n - 1 && arr[k]) ++k;\n\t\t\tfor (int l = j; l <= k; l++) brr[l - j] = arr[l];\n\t\t\tint temp = 0;\n\t\t\tfor (int l = 0; l <= k - j; l++) temp = temp * (m + 1) + brr[l];\n\t\t\thn.ins((ll)temp << 5 | (k - j + 1), 0);\n\t\t\tj = k;\n\t\t}\n\t}\n\tfor (int i = 0; i < hn.N; i++) if (hn.vis[i]) {\n\t\tint now = hn.key[i] & 31, num = hn.key[i] >> 5;\n\t\tfor (int j = num, k = now - 1; k >= 0; k--, j /= m + 1) brr[k] = j % (m + 1);\n\t\thn.val[i] = calc(now);\n\t}\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);\n\t\tll mul = hm.val[i] % MOD, ss = mul;\n\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\tint k = j;\n\t\t\twhile (k < n - 1 && arr[k]) ++k;\n\t\t\tfor (int l = j; l <= k; l++) brr[l - j] = arr[l];\n\t\t\tint temp = 0;\n\t\t\tfor (int l = 0; l <= k - j; l++) temp = temp * (m + 1) + brr[l];\n\t\t\tmul = mul * hn.query((ll)temp << 5 | (k - j + 1)) % MOD;\n\t\t\tj = k;\n\t\t}\n\t\tans += mul;\n\t}\n\tprintf(""%lld\\n"", ans % MOD);\n\treturn 0;\n}//for (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);']",,,"['bitmasks', 'dp', 'matrices']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F1. Neko Rules the Catniverse  Small Version .json,https://codeforces.com/blog/entry/66696,As the problem stated from planet we can go backwards any to any planet such that This implies an idea of considering the planets from to then deciding whether to insert each planet to the current path or not Formally if our current path is and we are going to insert planet somewhere for all we can either insert it into the back or insert it before some planet such that Therefore we can use dynamic programming with the parameters being the planet being considered the number of planets chosen so far and the bitmask of the last planets whether each of them is chosen or not The transition is straightforward either we don t choose the planet or we choose it and there are ways to insert the planet into the path Total complexity 
https://codeforces.com//contest/1691/problem/C,1416259,C,1691C,1691,C. Sum of Substrings,You are given a binary string s of length n Let s define d i as the number whose decimal representation is s i s i 1 possibly with a leading zero We define f s to be the sum of all the valid d i In other words f s sum limits i 1 n 1 d i For example for the string s 1011 d 1 10 ten d 2 01 one d 3 11 eleven f s 10 01 11 22 In one operation you can swap any two adjacent elements of the string Find the minimum value of f s that can be achieved if at most k operations are allowed ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, K, lpos[N], rpos[N];\nchar s[N];\nll tot = 0;\n\nvoid solve() {\n\tn = in, K = in; tot = 0; scanf(""%s"", s + 1);\n\trep(i, 0, 9) lpos[i] = rpos[i] = 0;\n\trep(i, 1, n) {\n\t\tint x = s[i] - \'0\'; tot += x;\n\t\tlpos[x] = lpos[x] ? lpos[x] : i;\n\t\trpos[x] = i;\n\t}\n\ttot *= 11; ll ans = tot;\n\trep(x, 0, 9)\n\t\trep(y, 0, 9) if(lpos[x] && rpos[y]) {\n\t\tint a = lpos[x], b = rpos[y];\n\t\tif(a == b) continue;\n\t\tint oper = a - 1 + n - b - (a > b);\n\t\tif(oper <= K) chkmin(ans, tot - x - y * 10);\n\t} // two\n\trep(x, 0, 9) if(lpos[x]) {\n\t\tint oper = lpos[x] - 1;\n\t\tif(oper <= K) chkmin(ans, tot - x);\n\t}\n\trep(x, 0, 9) if(rpos[x]) {\n\t\tint oper = n - rpos[x];\n\t\tif(oper <= K) chkmin(ans, tot - x * 10);\n\t}\n\tprintf(""%lld\\n"", ans);\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy', 'math', 'strings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Sum of Substrings.json,https://codeforces.com//blog/entry/103212,We can observe that for any string can also be written as In the above equation is the integral face value of the character of the string We came to this equation by observing what character is contributing to the value of If the character is a 1 it will contribute a value of 1 to and a value of 10 to Now in order to minimize the value of we would want to put the 1s at position first then at position and then anywhere in the middle of the string In order to achieve the best configuration in at max operations we will try to move the last 1 at position first then with the remaining operations we will try to move the first 1 at position 1 The remaining 1s can stay where they are as they will anyways be contributing a value of no matter which position they take 
https://codeforces.com//contest/1201/problem/E1,383828,E1,1201E1,1201,E1. Knightmare  easy ,Alice and Bob are playing a game on the chessboard of size n times m where n and m are The rows are numbered from 1 to n and the columns are numbered from 1 to m There are two knights on the chessboard A white one initially is on the position x 1 y 1 while the black one is on the position x 2 y 2 Alice will choose one of the knights to play with and Bob will use the other one The Alice and Bob will play in turns and whoever controls knight starts the game During a turn the player must move their knight adhering the chess rules That is if the knight is currently on the position x y it can be moved to any of those positions as long as they are inside the chessboard x 1 y 2 x 1 y 2 x 1 y 2 x 1 y 2 x 2 y 1 x 2 y 1 x 2 y 1 x 2 y 1 We all know that knights are strongest in the middle of the board Both knight have a single position they want to reach the owner of the white knight wins if it captures the black knight or if the white knight is at n 2 m 2 and this position is not under attack of the black knight at this moment The owner of the black knight wins if it captures the white knight or if the black knight is at n 2 1 m 2 and this position is not under attack of the white knight at this moment Formally the player who captures the other knight wins The player who is at its target square n 2 m 2 for white n 2 1 m 2 for black and this position is not under opponent s attack also wins A position is under attack of a knight if it can move into this position Capturing a knight means that a player moves their knight to the cell where the opponent s knight is If Alice made 350 moves and nobody won the game is a draw Alice is unsure in her chess skills so she asks you for a help Choose a knight and win the game for her It can be shown that Alice always has a winning strategy ,"['#include<bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}, dy[8] = {2, -2, 2, -2, 1, -1, 1, -1};\nconst int N = 1005;\n\nint n, m, dis1[N][N], dis2[N][N];\n\nbool chk(int x,int y) {\n\treturn x >= 1 && x <= n && y >= 1 && y <= m;\n}\n\nvoid run(int x, int y, int dis[N][N]) {\n\tvector<pair<int,int>> q;\n\tdis[x][y]=1;\n\tq.push_back(make_pair(x,y));\n\tfor(int i = 0; i < q.size(); i++)\n\t{\n\t\tint x = q[i].first, y = q[i].second;\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tif (chk(x + dx[j], y + dy[j]) && !dis[x + dx[j]][y + dy[j]]) {\n\t\t\t\tq.push_back(make_pair(x + dx[j], y + dy[j]));\n\t\t\t\tdis[x + dx[j]][y + dy[j]] = dis[x][y] + 1;\n\t\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tdis[i][j]--;\n}\n\nint get(int x0, int y0, int x1, int y1, bool st) {\n\tif(!st) {\n\t\tif (x0 == n / 2 && y0 == m / 2) return 0;\n\t\tfor (int i = 0; i < 8; i++) if (x0 + dx[i] == x1 && y0 + dy[i] == y1) return 0;\n\t\tif (dis1[x0][y0] <= dis2[x1][y1]) {\n\t\t\tif (dis1[x0][y0] < dis1[x1][y1] || ((dis1[x0][y0] ^ dis1[x1][y1]) & 1)) return 0;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (dis2[x1][y1] + 1 < dis2[x0][y0] || (~(dis2[x1][y1] ^ dis2[x0][y0]) & 1)) return 1;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (x1 == n / 2 + 1 && y1 == m / 2) return 1;\n\t\tfor (int i = 0; i < 8; i++) if (x0 + dx[i] == x1 && y0 + dy[i] == y1) return 1;\n\t\tif (dis2[x1][y1] <= dis1[x0][y0]) {\n\t\t\tif (dis2[x1][y1] < dis2[x0][y0] || ((dis2[x1][y1] ^ dis2[x0][y0]) & 1)) return 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (dis1[x0][y0] + 1 < dis1[x1][y1] || (~(dis1[x0][y0] ^ dis1[x1][y1]) & 1)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nset<ll> vis;\n\nint main() {\n\tint x0, y0, x1, y1;\n\tscanf(""%d%d%d%d%d%d"", &n, &m, &x0, &y0, &x1, &y1);\n\tvis.insert((ll)x0 << 30 | y0 << 20 | x1 << 10 | y1);\n\trun(n / 2, m / 2, dis1);\n\trun(n / 2 + 1, m / 2, dis2);\n\tbool mt = get(x0, y0, x1, y1, 0) == 1;\n\tputs(mt ? ""BLACK"" : ""WHITE"");\n\tfflush(stdout);\n\tbool turn = 0;\n\tfor (; ; turn ^= 1, vis.insert((ll)x0 << 30 | y0 << 20 | x1 << 10 | y1)) {\n\t\tif (turn != mt) {\n\t\t\tif (turn == 0) scanf(""%d%d"", &x0, &y0);\n\t\t\telse scanf(""%d%d"", &x1, &y1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (turn == 0) {\n\t\t\tint fdis = 1e9, ox, oy;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tif (chk(x0 + dx[i], y0 + dy[i]) && (get(x0 + dx[i], y0 + dy[i], x1, y1, 1) == 0 || (x0 + dx[i] == x1 && y0 + dy[i] == y1))) {\n\t\t\t\t\tif (!vis.count((ll)(x0 + dx[i]) << 30 | (y0 + dy[i]) << 20 | x1 << 10 | y1) && dis1[x0 + dx[i]][y0 + dy[i]] < fdis) {\n\t\t\t\t\t\tox = x0 + dx[i], oy = y0 + dy[i];\n\t\t\t\t\t\tfdis = dis1[x0 + dx[i]][y0 + dy[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx0 = ox, y0 = oy;\n\t\t\tprintf(""%d %d\\n"", ox, oy);\n\t\t\tfflush(stdout);\n\t\t\tif (ox == n / 2 && oy == m / 2) return 0;\n\t\t\tif (ox == x1 && oy == y1) return 0;\n\t\t} else {\n\t\t\tint fdis = 1e9, ox, oy;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tif (chk(x1 + dx[i], y1 + dy[i]) && (get(x0, y0, x1 + dx[i], y1 + dy[i], 0) == 1 || (x1 + dx[i] == x0 && y1 + dy[i] == y0))) {\n\t\t\t\t\tif (!vis.count((ll)x0 << 30 | y0 << 20 | (x1 + dx[i]) << 10 | (y1 + dy[i])) && dis2[x1 + dx[i]][y1 + dy[i]] < fdis) {\n\t\t\t\t\t\tox = x1 + dx[i], oy = y1 + dy[i];\n\t\t\t\t\t\tfdis = dis2[x1 + dx[i]][y1 + dy[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx1 = ox, y1 = oy;\n\t\t\tprintf(""%d %d\\n"", ox, oy);\n\t\t\tfflush(stdout);\n\t\t\tif (ox == n / 2 + 1 && oy == m / 2) return 0;\n\t\t\tif (ox == x0 && oy == y0) return 0;\n\t\t}\n\t}\n}']",,,"['graphs', 'interactive', 'shortest paths']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Knightmare  easy .json,https://codeforces.com/blog/entry/68911,First calculate the number of moves needed to reach without capturing positions a1 b1 and a2 b2 If one of the knights can reach it s goal at least 2 moves faster than the other can and faster than the other can reach it s goal than there is a winning strategy with it Just go the shortest path The other knight won t be able to capture your knight because after you move you are x moves away from it than the other knight must be at least x 2 far so it will be at least x 1 after it s move If one of the knights can reach it s goal at exactly 1 move faster than the other can and faster than the other can reach it s goal we have to count the moves needed to reach all the positions which is 1 move away from the goal If there is a position from these which can be reached at least 2 moves faster than that knight can win Let s color the chessboard the regular way with white and black colors If the 2 knights are in same color than only the black knight can capture the white otherwise only the white can capture the black that is because knights always move to different color than they come from In all the other situation there is at least drawing strategy with the knight that can capture the other Move to the position that the other knight have to reach and stay there or 1 move away from it The other knight won t be able to reach that position without getting captured So we choose that knight and search for the winning strategy You can win the game in 2 steps First Go to your opponent s target cell in the fastest way if the opponent could go there faster you can still outrun him because there is no position which is 1 move away from the opponents goal and can be reached at least 2 moves faster we already looked that situation so you can take away the opponent s possibility to reach the target by threatening with capturing their knight This is maximum of 333 moves Second Go from there to your target cell on the fastest way It can be easily shown that it takes 3 moves to go there When you are in the opponent s target position your opponent can be either exactly 1 move or at least 3 moves away from you because the distance in moves between you and your opponent s knight after your opponent s turn is always odd If it is 1 move away you can capture his knight if at least 3 or moves away from you and therefore the target position you can reach your target faster than your opponent That s a total of 336 moves 
https://codeforces.com//contest/131/problem/A,692,A,131A,131,A. cAPS lOCK,wHAT DO WE NEED cAPS LOCK FOR Caps lock is a computer keyboard key Pressing it sets an input mode in which typed letters are capital by default If it is pressed by accident it leads to accidents like the one we had in the first passage Let s consider that a word has been typed with the Caps lock key accidentally switched on if either it only contains uppercase letters or all letters except for the first one are uppercase In this case we should automatically change the case of all letters For example the case of the letters that form words should be changed Write a program that applies the rule mentioned above If the rule cannot be applied the program should leave the word unchanged ,"['#include <cstdio>\n#include <cstring>\n#include <cctype>\nchar s[110];\nint main()\n{\n    scanf(""%s"",s);\n    int n=strlen(s),sum=0;\n    for (int i=0;i<n;i++)\n        if (isupper(s[i]))\n            sum++;\n    if (sum==n || sum==n-1 && islower(s[0]))\n        for (int i=0;i<n;i++)\n            if (isupper(s[i]))\n                s[i]=tolower(s[i]);\n            else\n                s[i]=toupper(s[i]);\n    printf(""%s\\n"",s);\n    return(0);\n}\n']",,,"['implementation', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. cAPS lOCK.json,https://codeforces.com//blog/entry/3256,Just do what the statement asks you to Check if all letters are uppercase except for the first one that you don t need to check If so change the case of the entire string If not do nothing Please notice that an one letter string must have its case changed It can be easly done in O n where n is the lenght of the string 
https://codeforces.com//contest/1768/problem/A,1720618,A,1768A,1768,A. Greatest Convex,You are given an integer k Find the largest integer x where 1 le x k such that x x 1 dagger is a multiple of ddagger k or determine that no such x exists dagger y denotes the factorial of y which is defined recursively as y y cdot y 1 for y geq 1 with the base case of 0 1 For example 5 5 cdot 4 cdot 3 cdot 2 cdot 1 cdot 0 120 ddagger If a and b are integers then a is a multiple of b if there exists an integer c such that a b cdot c For example 10 is a multiple of 5 but 9 is not a multiple of 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=2e5+10;\nint a[maxn],m,n,t_case;\nint main(){\n\tscanf(""%d"",&t_case);\n\twhile(t_case--){\n\t\tscanf(""%d"",&n);\n\t\tprintf(""%d\\n"",n-1);\n\t}\n\treturn 0;\n}\n']",,,"['greedy', 'math', 'number theory']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Greatest Convex.json,https://codeforces.com//blog/entry/110901,Suppose we can make operations so that elements do not participate in any operation Then these elements in the final array will end up at the beginning in the order in which they were in the initial array And since this must be maximized to minimize the number of operations we need to find the maximal subsequence of the numbers Let this sequence have numbers then the answer is 
https://codeforces.com//contest/583/problem/A,37190,A,583A,583,A. Asphalting Roads,City X consists of vertical and horizontal infinite roads forming intersections Roads both vertical and horizontal are numbered from to and the intersections are indicated by the numbers of the roads that form them Sand roads have long been recognized out of date so the decision was made to asphalt them To do this a team of workers was hired and a schedule of work was made according to which the intersections should be asphalted Road repairs are planned for days On the th day of the team arrives at the th intersection in the list and if of the two roads that form the intersection were already asphalted they asphalt both roads Otherwise the team leaves the intersection without doing anything with the roads According to the schedule of road works tell in which days at least one road will be asphalted ,"[""#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint a[55],b[55],n;\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n*n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(a[x]==0&&b[y]==0)a[x]=b[y]=1,cout<<i<<' ';\n\t}\n\treturn 0;\n}\n""]",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Asphalting Roads.json,https://codeforces.com//blog/entry/20692,To solve the problem one could just store two arrays hused j and vused j sized n and filled with false initially Then process intersections one by one from 1 to n and if for i th intersections both hused hi and vused vi are false add i to answer and set both hused hi and vused vi with true meaning that hi th horizontal and vi th vertical roads are now asphalted and skip asphalting the intersection roads otherwise 
https://codeforces.com//contest/848/problem/C,120619,C,848C,848,C. Goodbye Souvenir,A string of beads is left as the message of leaving The beads are numbered from to from left to right each having a shape numbered by integers between and inclusive Some beads may have the same shapes The of a shape in a certain subsegment of beads is defined to be the difference between the last position and the first position that shape appears in the segment The of a subsegment is the sum of over all shapes that occur in it From time to time shapes of beads change as well as the Sometimes the past secreted in subsegments are being recalled and you are to find the for each of them ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nclass Node {\npublic:\n\tvector <int> Vx;\n\tvector <ll> bit;\n\tint it_max;\n\tNode() {\n\t\tVx.clear();\n\t\tbit.clear();\n\t}\n\tvoid update(int p, int v) {\n\t\tp = lower_bound(all(Vx), p) - Vx.begin() + 1;\n\t\tfor (; p <= it_max; p += p & (-p)) bit[p] += v;\n\t}\n\tll getsum(int x) {\n\t\tx = lower_bound(all(Vx), x + 1) - Vx.begin();\n\n\t\tll rv = 0;\n\t\tfor (; x; x -= x & (-x)) rv += bit[x];\n\t\treturn rv;\n\t}\n};\nNode indt[300000];\nint val[300000];\nvoid update(int p, int v) {\n\tif (v == INF) v = 0;\n\tif (val[p] != 0) for (int i = IT_MAX + p - 1; i; i /= 2) indt[i].update(val[p], p - val[p]);\n\tif (v != 0) for (int i = IT_MAX + p - 1; i; i /= 2) indt[i].update(v, v - p);\n\tval[p] = v;\n}\nll getsum(int p1, int p2) {\n\tint op1 = p1, op2 = p2;\n\tp1 += IT_MAX - 1, p2 += IT_MAX - 1;\n\tll rv = 0;\n\tfor (; p1 <= p2; p1 /= 2, p2 /= 2) {\n\t\tif (p1 % 2 == 1) rv += indt[p1++].getsum(op2);\n\t\tif (p2 % 2 == 0) rv += indt[p2--].getsum(op2);\n\t}\n\treturn rv;\n}\n\nint OA[100050];\nint A[100050];\nset <int> Sp[100050];\nint getnxt(int p) {\n\tauto it = Sp[A[p]].lower_bound(p + 1);\n\tif (it == Sp[A[p]].end()) return INF;\n\telse return *it;\n}\nint Qu[100050][3];\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(""%d"", &A[i]);\n\t\tOA[i] = A[i];\n\t}\n\tfor (i = 1; i <= M; i++) scanf(""%d %d %d"", &Qu[i][0], &Qu[i][1], &Qu[i][2]);\n\n\tfor (i = 1; i <= N; i++) Sp[A[i]].insert(i);\n\tfor (i = 1; i <= N; i++) {\n\t\tint p = getnxt(i);\n\t\tif (p == INF) continue;\n\t\tfor (j = IT_MAX + i - 1; j >= 1; j /= 2) indt[j].Vx.push_back(p);\n\t}\n\tfor (i = 1; i <= M; i++) {\n\t\tif (Qu[i][0] == 2) continue;\n\t\tint p = Qu[i][1], x = Qu[i][2];\n\t\t\n\t\tauto it = Sp[A[p]].lower_bound(p);\n\t\tif (it != Sp[A[p]].begin()) {\n\t\t\tauto it2 = it;\n\t\t\tit2++;\n\t\t\tit--;\n\t\t\tif (it2 != Sp[A[p]].end()) {\n\t\t\t\tint y = *it, z = *it2;\n\t\t\t\tfor (j = IT_MAX + y - 1; j >= 1; j /= 2) indt[j].Vx.push_back(z);\n\t\t\t}\n\t\t}\n\t\tSp[A[p]].erase(p);\n\t\tA[p] = x;\n\t\tSp[A[p]].insert(p);\n\n\t\tit = Sp[A[p]].lower_bound(p);\n\t\tif (it != Sp[A[p]].begin()) {\n\t\t\tit--;\n\t\t\tint y = *it;\n\t\t\tfor (j = IT_MAX + y - 1; j >= 1; j /= 2) indt[j].Vx.push_back(p);\n\t\t}\n\t\tint p2 = getnxt(p);\n\t\tif (p2 == INF) continue;\n\t\tfor (j = IT_MAX + p - 1; j >= 1; j /= 2) indt[j].Vx.push_back(p2);\n\t}\n\tfor (i = 1; i < IT_MAX * 2; i++) {\n\t\tsort(all(indt[i].Vx));\n\t\tindt[i].Vx.erase(unique(all(indt[i].Vx)), indt[i].Vx.end());\n\t\t\n\t\tint x;\n\t\tfor (x = 2; x < indt[i].Vx.size(); x *= 2);\n\t\tindt[i].it_max = x;\n\t\tindt[i].bit.resize(x + 1);\n\t}\n\n\tfor (i = 1; i <= N; i++) A[i] = OA[i];\n\tfor (i = 1; i <= N; i++) Sp[i].clear();\n\tfor (i = 1; i <= N; i++) Sp[A[i]].insert(i);\n\n\tfor (i = 1; i <= N; i++) {\n\t\tint p = getnxt(i);\n\t\tif (p != INF) update(i, p);\n\t}\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1 = Qu[i][0], t2 = Qu[i][1], t3 = Qu[i][2];\n\t\tif (t1 == 1) {\n\t\t\tint p = t2, x = t3;\n\n\t\t\tauto it = Sp[A[p]].lower_bound(p);\n\t\t\tif (it != Sp[A[p]].begin()) {\n\t\t\t\tint v = INF;\n\t\t\t\tauto it2 = it;\n\t\t\t\tit2++;\n\t\t\t\tit--;\n\t\t\t\tif (it2 != Sp[A[p]].end()) v = *it2;\n\t\t\t\tupdate(*it, v);\n\t\t\t}\n\t\t\tSp[A[p]].erase(p);\n\t\t\tA[p] = x;\n\t\t\tSp[A[p]].insert(p);\n\n\t\t\tit = Sp[A[p]].lower_bound(p);\n\t\t\tif (it != Sp[A[p]].begin()) {\n\t\t\t\tit--;\n\t\t\t\tupdate(*it, p);\n\t\t\t}\n\t\t\tupdate(p, getnxt(p));\n\t\t}\n\t\telse printf(""%lld\\n"", getsum(t2, t3));\n\t}\n\treturn 0;\n}']",,,"['data structures', 'divide and conquer']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Goodbye Souvenir.json,https://codeforces.com//blog/entry/54233,Let s look at segment Let s positions of all occurences of shape at segment Then memory of shape at segment is Then we can build array of pairs where previous occurence of shape A query transforms to which is variation of counting numbers of greater on segment Queries of change in position can be proccessed by recounting values for and next occurence of that shape before and after changing shape Processing of all queries can be done by building segment tree which every node contains Fenwick tree by types of shape For reducing memory usage we can for every node save only shapes which appeared in any query for this node Then Fenwick tree can be build only on this shapes by coordinate compressing Result complexity 
https://codeforces.com//contest/1276/problem/C,495590,C,1276C,1276,C. Beautiful Rectangle,You are given n integers You need to choose a subset and put the chosen numbers in a beautiful rectangle rectangular matrix Each chosen number should occupy one of its rectangle cells each cell must be filled with exactly one chosen number Some of the n numbers may not be chosen A rectangle rectangular matrix is called beautiful if in each row and in each column all values are different What is the largest by the total number of cells beautiful rectangle you can construct Print the rectangle itself ,"['#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define N_ 401000\nusing namespace std;\nint n, w[N_];\n\nstruct AA {\n\tint c, a;\n\tbool operator <(const AA &p)const {\n\t\treturn c < p.c;\n\t}\n}U[N_];\n\nint A, B;\n\nvoid UDT(int x, int y) {\n\tif (A*B<x*y) {\n\t\tA = x, B = y;\n\t}\n}\n\nvoid Solve() {\n\tint i, j;\n\tmap<int, int>Map;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &w[i]);\n\t\tMap[w[i]]++;\n\t}\n\tint cnt = 0;\n\tfor (auto &t : Map) {\n\t\tcnt++;\n\t\tU[cnt] = { t.second,t.first };\n\t}\n\tsort(U + 1, U + cnt + 1);\n\tint pv = 0, s = 0;\n\tfor (i = 1; i*i <= n; i++) {\n\t\twhile (pv + 1 <= cnt && U[pv + 1].c <= i) {\n\t\t\ts += U[pv + 1].c;\n\t\t\tpv++;\n\t\t}\n\t\tint tot = (cnt - pv) * i + s;\n\t\tif (tot >= i * i) {\n\t\t\tUDT(i, tot/i);\n\t\t}\n\t}\n\ts = A * B;\n\tfor (i = 1; i <= cnt; i++) {\n\t\tif (U[i].c > A) U[i].c = A;\n\t\tU[i].c = min(U[i].c, s);\n\t\ts -= U[i].c;\n\t}\n\tprintf(""%d\\n%d %d\\n"", A*B, A, B);\n\tvector<vector<int>>V;\n\tV.resize(A);\n\tfor (i = 0; i < A; i++)V[i].resize(B);\n\tsort(U + 1, U + cnt + 1);\n\tint x = 0, y = 0;\n\tfor (i = cnt; i >= 1; i--) {\n\t\twhile (U[i].c) {\n\t\t\tV[x][y%B] = U[i].a;\n\t\t\tU[i].c--;\n\t\t\tx++, y++;\n\t\t\tif (x >= A) {\n\t\t\t\tx -= A;\n\t\t\t\ty -= A - 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < A; i++) {\n\t\tfor (j = 0; j < B; j++) {\n\t\t\tprintf(""%d "", V[i][j]);\n\t\t}\n\t\tputs("""");\n\t}\n}\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin);\n\tint TC = 1;\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}']",,,"['brute force', 'combinatorics', 'constructive algorithms', 'data structures', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Beautiful Rectangle.json,https://codeforces.com//blog/entry/72239,First let s formulate the criteria that from the given set of numbers x1 x2 xk we can create a beautiful rectangle a b where a b k a b Obviously if some number occurs more than a times then among a rows there will be such row that will contain two or more occurrences of the number pigeonhole principle Let s prove that if all numbers in x 1 k occur no more than a times we can create a beautiful rectangle a b where a b k a b We will numerate cells from the upper left corner in the order from one moving diagonally each time Assume rows are numerated from 0 to a 1 and columns are numerated from 0 to b 1 Let s begin from the cell 0 0 and move right down each time If we face to a border we will move cyclically Thus from the cell i j we will move to the cell i 1 moda j 1 modb each time where pmodq is the remainder when divided p by q If we are going to move to a visited cell before moving let s assign i i 1 moda Example of the numeration for rectangles 3 3 and 4 6 We can also prove that while such numeration each row and each column contain numbers that differ by no less than a 1 if we are on a row column we will make a turn before we will be on the row column again Moreover the difference reaches a 1 not a when we move to the previously visited cell and assign i i 1 moda So we can prove that the lengths of such orbits are equal lcm a b lcm is a least common multiple Consequently they are divided by a It means that if we will arrange the numbers from x in the order from the most common at worst case those that meet a times to the least common each row and each column will always contain different numbers Thus we have a plan of the solution find optimal a and b so that the answer is the largest rectangle a b a b For this we will iterate over all possible candidates in a and for each candidate each number v from x we will use it no more than min cv a times where cv is a number of occurrences v in the given sequence So if we choose a the upper bound of a rectangle area is min cv a for all possible different numbers v from the given sequence Consequently the maximal value of b is min cv a a And let s update the answer if for current iteration a b is larger than previously found answer still consider that a b We can maintain the value min cv a while a is incremented by one For doing this we should each time add geq a to this value where geq a is a number of different numbers in the given sequence which occurs at least a times we can precalculate this array 
https://codeforces.com//contest/996/problem/B,193040,B,996B,996,B. World Cup,Allen wants to enter a fan zone that occupies a round square and has n entrances There already is a queue of a i people in front of the i th entrance Each entrance allows one person from its queue to enter the fan zone in one minute Allen uses the following strategy to enter the fan zone Initially he stands in the end of the queue in front of the first entrance Each minute if he is not allowed into the fan zone during the minute meaning he is not the first in the queue he leaves the current queue and stands in the end of the queue of the next entrance or the first entrance if he leaves the last entrance Determine the entrance through which Allen will finally enter the fan zone ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <stdlib.h>\n#include <set>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <regex>\n#include <math.h>\n#include <map>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <array>\n#include <valarray>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\ntypedef int integer;\ntypedef array<int, 2> hv;\n#define double long double\n#define int long long\n#define make(type, x) type x; cin>>x\n#define make2(type, x, y) type x, y; cin>>x>>y\n#define make3(type, x, y, z) type x, y, z; cin>>x>>y>>z\n#define make4(type, x, y, z, q) type x, y, z, q; cin>>x>>y>>z>>q\n#define ALL(x) (x).begin(), (x).end()\n#define FORIT(p) for(auto it = p.begin(); it != p.end(); it++)\n#define FOR(b) for(int i = 0; i <(b); ++i)\n#define VI vector<int>\n#define VVI vector<vector<int>>\n#define PII pair<int, int>\n#define PPII pair<PII, int>\n#define M7 1000000007\n#define M9 1000000009\n\n\n\n\nvoid Solve() {\n\tmake(int, n);\n\tVI a(n);\n\tFOR(n) cin >> a[i];\n\tint mn = a[0];\n\tfor (int i = 1; i < n; ++i) mn = min(a[i], mn);\n\tint cnt_kr = mn / n;\n\tFOR(n) a[i] -= cnt_kr*n;\n\tfor (int d = 0; d < 20; d++) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] -= i;\n\t\t\tif (a[i] <= 0) {\n\t\t\t\tcout << i + 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\ta[i] -= n - i;\n\t\t}\n\t}\n\n\n}\n\n\n\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie();\n#if  _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tSolve();\n\twhile (!cin.eof()) {\n\t\tstring s = ""_"";\n\t\tdo getline(cin, s);\n\t\twhile (!cin.eof() && !s.empty());\n\t\tif (cin.eof()) return 0;\n\t\tFOR(3) cout << endl;\n\t\tSolve();\n\t}\n#else\n\tSolve();\n#endif\n\treturn 0;\n\t}']",,,"['binary search', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. World Cup.json,https://codeforces.com//blog/entry/60217,For gate where we visit the gate at times Therefore the earliest Allen could enter from gate is the time such that Now for each compute the minimal integer such that Now find the integer with minimum and output 
https://codeforces.com//contest/1695/problem/B,1432672,B,1695B,1695,B. Circle Game,Mike and Joe are playing a game with some stones Specifically they have n piles of stones of sizes a 1 a 2 ldots a n These piles are arranged in a circle The game goes as follows Players take turns removing some positive number of stones from a pile in clockwise order starting from pile 1 Formally if a player removed stones from pile i on a turn the other player removes stones from pile i bmod n 1 on the next turn If a player cannot remove any stones on their turn because the pile is empty they lose Mike goes first If Mike and Joe play optimally who will win ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n;\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) cin >> a[i];\n        if (n % 2 == 1) {\n            cout << ""Mike"" << endl;\n            continue;\n        }\n        int mn = 2e9, pos;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < mn) {\n                mn = a[i];\n                pos = i;\n            }\n        }\n        if (pos % 2 == 0) {\n            cout << ""Joe"" << endl;\n        } else {\n            cout << ""Mike"" << endl;\n        }\n    }\n    return 0;\n}']",,,"['games', 'greedy']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Circle Game.json,https://codeforces.com//blog/entry/103996,Note that since all piles are initially nonempty the game will not end for the first turns because on each of those turns a player will be removing from a nonempty pile If is odd Mike can remove all of the stones from the first pile Then on the th turn the first turn where the game can end Joe will be forced to remove from the first pile which is empty So Mike can always win if is odd If is even then Mike will only ever remove from the odd piles and Joe will only ever remove from the even piles So each player has piles and neither can remove from the other s piles Therefore it is optimal for each player to remove the minimal possible number of stones at each step so that they stay in the game for as long as possible So on each turn a player removes exactly one stone and the first pile to become empty will be the pile with the minimal number of stones If there are multiple minimal piles it will be the leftmost such pile So if this pile is on an odd position Mike will lose and therefore Joe will win and otherwise Joe will lose and Mike will win Complexity 
https://codeforces.com//contest/2024/problem/A,2964356,A,2024A,2024,A. Profitable Interest Rate,Alice has a coins She can open a bank deposit called Profitable but the minimum amount required to open this deposit is b coins There is also a deposit called Unprofitable which can be opened with amount of coins Alice noticed that if she opens the Unprofitable deposit with x coins the minimum amount required to open the Profitable deposit decreases by 2x coins However these coins cannot later be deposited into the Profitable deposit Help Alice determine the maximum number of coins she can deposit into the Profitable deposit if she first deposits some amount of coins possibly 0 into the Unprofitable deposit If Alice can never open the Profitable deposit output 0 ,"['#include <bits/stdc++.h>using namespace std;\xa0typedef long long int ll;const ll FOD = 998244353;typedef pair<ll, ll> P;using ull = unsigned long long;template <class T> using V = vector<T>;template <class T> using VV = V<V<T>>;\xa0\xa0template <ll MD> struct ModInt {    using M = ModInt;    const static M G;    ll v;    ModInt(ll _v = 0) { set_v(_v % MD + MD); }    M& set_v(ll _v) {        v = (_v < MD) ? _v : _v - MD;        return *this;    }    explicit operator bool() const { return v != 0; }    M operator-() const { return M() - *this; }    M operator+(const M& r) const { return M().set_v(v + r.v); }    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }    M operator*(const M& r) const { return M().set_v(ll(v) * r.v % MD); }    M operator/(const M& r) const { return *this * r.inv(); }    M& operator+=(const M& r) { return *this = *this + r; }    M& operator-=(const M& r) { return *this = *this - r; }    M& operator*=(const M& r) { return *this = *this * r; }    M& operator/=(const M& r) { return *this = *this / r; }    bool operator==(const M& r) const { return v == r.v; }    M pow(ll n) const {        M x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    M inv() const { return pow(MD - 2); }    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }};using Mint = ModInt<998244353>;template<> const Mint Mint::G = Mint(3);\xa0template <class Mint> void nft(bool type, V<Mint>& a) {    int n = int(a.size()), s = 0;    while ((1 << s) < n) s++;    assert(1 << s == n);\xa0    static V<Mint> ep, iep;    while (int(ep.size()) <= s) {        ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));        iep.push_back(ep.back().inv());    }    V<Mint> b(n);    for (int i = 1; i <= s; i++) {        int w = 1 << (s - i);        Mint base = type ? iep[i] : ep[i], now = 1;        for (int y = 0; y < n / 2; y += w) {            for (int x = 0; x < w; x++) {                auto l = a[y << 1 | x];                auto r = now * a[y << 1 | x | w];                b[y | x] = l + r;                b[y | x | n >> 1] = l - r;            }            now *= base;        }        swap(a, b);    }}\xa0template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {    int n = int(a.size()), m = int(b.size());    if (!n || !m) return {};    int lg = 0;    while ((1 << lg) < n + m - 1) lg++;    int z = 1 << lg;    auto a2 = a, b2 = b;    a2.resize(z);    b2.resize(z);    nft(false, a2);    nft(false, b2);    for (int i = 0; i < z; i++) a2[i] *= b2[i];    nft(true, a2);    a2.resize(n + m - 1);    Mint iz = Mint(z).inv();    for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;    return a2;}\xa0ll n, m, k, q, h, w;\xa0vector<ll> a, b;\xa0vector<ll> qs[200\'009];ll qi = 0;ll sz = 0;\xa0Mint mod_pow (Mint l, ll r) {\tif (r == 0) return 1;\xa0\treturn mod_pow((l * l), r/2) * ((r%2) ? l : 1);}Mint mod_inv (Mint x) {\treturn mod_pow(x, FOD-2);}\xa0void solve () {\tll ans;\tif (h >= w) {\t\tans = h;\t} else {\t\tans = max(0LL, h*2-w);\t}\xa0\tcout << ans << ""\\n"";}\xa0int main (void) {\tcin >> q;\twhile (q--) {\t\tcin >> h >> w;\xa0\t\tsolve();\t}}']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Profitable Interest Rate.json,https://codeforces.com//blog/entry/135341,Let s say we have deposited coins into the Unprofitable deposit then we can open a Profitable deposit if is satisfied Which is equivalent to the inequality Thus we need to open an Unprofitable deposit for coins and open a Profitable deposit for the rest of the coins 
https://codeforces.com//contest/1833/problem/F,1929819,F,1833F,1833,F. Ira and Flamenco,Ira loves Spanish flamenco dance very much She decided to start her own dance studio and found n students ith of whom has a i Ira can choose several of her students and set a dance with them So she can set a huge number of dances but she is only interested in dances The dance is called if the following is true m students participate in the dance of all dancers are of every two dancers have an absolute difference than m For example if m 3 and a 4 2 2 3 6 the following dances are students participating in the dance are highlighted in red color red 4 2 color red 2 color red 3 6 color red 4 color red 2 2 color red 3 6 At the same time dances color red 4 2 2 color red 3 6 4 color red 2 color red 2 color red 3 6 color red 4 2 2 color red 3 color red 6 are not In the dance color red 4 2 2 color red 3 6 only 2 students participate although m 3 The dance 4 color red 2 color red 2 color red 3 6 involves students with 2 and 2 although of all dancers must be pairwise distinct In the dance color red 4 2 2 color red 3 color red 6 students with 3 and 6 participate but 3 6 3 although m 3 Help Ira count the number of dances that she can set Since this number can be very large count it 10 9 7 Two dances are considered different if the sets of students participating in them are different ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n \ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % P)} {}\n    \n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += P;\n        }\n        if (x >= P) {\n            x -= P;\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(P - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) {\n        x = 1LL * x * rhs.x % P;\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing Z = MInt<MOD>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z C(int m, int k) {\n        if (m < k || k < 0) return 0;\n        return fac(m) * invfac(k) * invfac(m - k);\n    }\n} comb;\n\ntemplate<class Info>\nstruct SegmentTree {\n    int n;\n    std::vector<Info> info;\n\n    SegmentTree() : n(0) {}\n\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n\n    template<class T>\n    SegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        int sz = (1 << (std::__lg(n - 1) + 1));\n        info.assign(sz * 2, Info());\n        std::function<void(int, int, int)> build = [&](int v, int l, int r) {\n            if (l == r) {\n                info[v] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(v + v, l, m);\n            build(v + v + 1, m + 1, r);\n            info[v] = info[v + v] + info[v + v + 1];\n        };\n        build(1, 0, n - 1);\n    }\n\n    Info rangeQuery(int v, int l, int r, int tl, int tr) {\n        if (r < tl || l > tr) {\n            return Info();\n        }\n        if (l >= tl && r <= tr) {\n            return info[v];\n        }\n        int m = (l + r) / 2;\n        return rangeQuery(v + v, l, m, tl, tr) + rangeQuery(v + v + 1, m + 1, r, tl, tr);\n    }\n\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n - 1, l, r);\n    }\n\n    void modify(int v, int l, int r, int i, const Info &x) {\n        if (l == r) {\n            info[v] = x;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            modify(v + v, l, m, i, x);\n        } else {\n            modify(v + v + 1, m + 1, r, i, x);\n        }\n        info[v] = info[v + v] + info[v + v + 1];\n    }\n\n    void modify(int i, const Info &x) {\n        modify(1, 0, n - 1, i, x);\n    }\n\n    Info query(int v, int l, int r, int i) {\n        if (l == r) {\n            return info[v];\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            return query(v + v, l, m, i);\n        } else {\n            return query(v + v + 1, m + 1, r, i);\n        }\n    }\n\n    Info query(int i) {\n        return query(1, 0, n - 1, i);\n    }\n};\n\nstruct Info {\n    Z mul;\n\n    Info() : mul(1) {}\n\n    Info(int x) : mul(x) {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info res;\n    res.mul = a.mul * b.mul;\n    return res;\n}\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    std::sort(a.begin(), a.end());\n    std::vector<std::pair<int, int>> p;\n    p.emplace_back(a[0], 1);\n    for (int i = 1; i < n; i++) {\n        if (a[i] == a[i - 1]) {\n            ++p.back().second;\n        } else {\n            p.emplace_back(a[i], 1);\n        }\n    }\n    Z res = 0;\n    n = (int) p.size();\n    if (m - 1 >= n) {\n        std::cout << 0 << ""\\n"";\n        return;\n    }\n    std::vector<int> cnt(n);\n    for (int i = 0; i < n; i++) {\n        cnt[i] = p[i].second;\n    }\n    SegmentTree<Info> t(cnt);\n    for (int i = m - 1; i < n; i++) {\n        if (p[i].first - p[i - m + 1].first == m - 1) {\n            res += t.rangeQuery(i - m + 1, i).mul;\n        }\n    }\n    std::cout << res << ""\\n"";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}']",,,"['combinatorics', 'constructive algorithms', 'data structures', 'implementation', 'math', 'sortings', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Ira and Flamenco.json,https://codeforces.com//blog/entry/116636,Reformulate the definition of dance A dance is called if there exists such a non negative integer that forms a permutation Let s build an array such that it is sorted all the numbers in it are unique and each number from occurs in For each element set as its number of occurrences in the array This process is called coordinate compression For example if then Let the constructed array has length In every dance there is a dancer with a minimum Let s fix this minimal in the array let its index be then the desired dance exists if and If the desired dance exists the number of such dances must be added to the answer which is equal to How to quickly calculate such a number Let s build prefix products Then by Fermat s small theorem Time complexity is Let s build a segment tree on a product modulo Time complexity is and we don t use that the module is prime We will use the idea of building a queue on two stacks but we will support prefix products modulo in these stacks Time complexity is and we don t use that the module is prime 
https://codeforces.com//contest/1398/problem/E,699505,E,1398E,1398,E. Two Types of Spells,Polycarp plays a computer game yet again In this game he fights monsters using magic spells There are two types of spells spell of power x deals x damage to the monster and spell of power y deals y damage to the monster and the damage of the next spell Polycarp casts Each spell can be cast but Polycarp can cast them in any order For example suppose that Polycarp knows three spells a fire spell of power 5 a lightning spell of power 1 and a lightning spell of power 8 There are 6 ways to choose the order in which he casts the spells first second third This order deals 5 1 2 cdot 8 22 damage first third second This order deals 5 8 2 cdot 1 15 damage second first third This order deals 1 2 cdot 5 8 19 damage second third first This order deals 1 2 cdot 8 2 cdot 5 27 damage third first second This order deals 8 2 cdot 5 1 19 damage third second first This order deals 8 2 cdot 1 2 cdot 5 20 damage Initially Polycarp knows 0 spells His spell set changes n times each time he either learns a new spell or forgets an already known one After each change calculate the maximum possible damage Polycarp may deal using the spells he knows ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nset<int> small, big;\nset<int> fire, elec;\nll sumBig = 0;\nll sumAll = 0;\n\nvoid addOne(int x) {\n\tsumAll += x;\n\tif (big.empty() || x < *big.begin()) {\n\t\tsmall.insert(x);\n\t} else {\n\t\tbig.insert(x);\n\t\tsumBig += x;\n\t}\n}\nvoid remOne(int x) {\n\tsumAll -= x;\n\tif (small.count(x)) {\n\t\tsmall.erase(x);\n\t} else {\n\t\tbig.erase(x);\n\t\tsumBig -= x;\n\t}\n}\n\nll calcAns() {\n\twhile((int)big.size() > (int)elec.size()) {\n\t\tint x = *big.begin();\n\t\tbig.erase(x);\n\t\tsmall.insert(x);\n\t\tsumBig -= x;\n\t}\n\twhile((int)big.size() < (int)elec.size()) {\n\t\tint x = *small.rbegin();\n\t\tsmall.erase(x);\n\t\tbig.insert(x);\n\t\tsumBig += x;\n\t}\n\tll ans = sumAll + sumBig;\n\tif ((int)elec.size() > 0 && (fire.empty() || *fire.rbegin() < *elec.begin())) {\n\t\tans -= *elec.begin();\n\t\tif (!fire.empty()) ans += *fire.rbegin();\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint t, x;\n\t\tscanf(""%d%d"", &t, &x);\n\t\tif (x > 0) {\n\t\t\tif (t == 0)\n\t\t\t\tfire.insert(x);\n\t\t\telse\n\t\t\t\telec.insert(x);\n\t\t\taddOne(x);\n\t\t} else {\n\t\t\tx *= -1;\n\t\t\tif (t == 0)\n\t\t\t\tfire.erase(x);\n\t\t\telse\n\t\t\t\telec.erase(x);\n\t\t\tremOne(x);\n\t\t}\n\t\tprintf(""%lld\\n"", calcAns());\n\t}\n\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'greedy', 'implementation', 'math', 'sortings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Two Types of Spells.json,https://codeforces.com//blog/entry/81506,Let s solve this problem for fixed set of spells For example we have a fireball spells with powers and lighting spells with powers We reach the maximum total damage if we can double all spells with maximum damage It s possibly iff the set of largest by power spell let s denote this set as contains at least one fireball spell Otherwise if set contains only lightning spells the maximum damage reach when we double largest spells in set and one largest spell not from set if such spell exist Now how do you solve the original problem when spells are added and removed All we have to do it maintain the set of largest by power spells where is current number of lightning spells and change this set by adding or removing one spell Also you have to maintain the sum of spells power in set this set and the number of fireball spells in this set You can do it by in or on 
https://codeforces.com//contest/707/problem/A,68575,A,707A,707,A. Brain s Photos,Small but very brave mouse Brain was not accepted to summer school of young villains He was upset and decided to postpone his plans of taking over the world but to become a photographer instead As you may know the coolest photos are on the film because you can specify the hashtag film for such Brain took a lot of colourful pictures on colored and black and white film Then he developed and translated it into a digital form But now color and black and white photos are in one folder and to sort them one needs to spend more than one hour As soon as Brain is a photographer not programmer now he asks you to help him determine for a photo whether it is colored or black and white Photo can be represented as a matrix sized and each element of the matrix stores a symbol indicating corresponding pixel color There are only colors C cyan M magenta Y yellow W white G grey B black The photo is considered black and white if it has only white black and grey pixels in it If there are any of cyan magenta or yellow pixels in the photo then it is considered colored ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tint n,m;\n\tscanf(""%d%d"", &n, &m);\n\tbool color = 0;\n\tfor(int i = 1;i <= n;i ++)\n\t\tfor(int j = 1;j <= m;j ++)\n\t\t{\n\t\t\tchar c;\n\t\t\twhile (c = getchar(),c < \'A\' || c > \'Z\');\n\t\t\tif (c == \'C\' || c == \'Y\' || c == \'M\') color = 1;\n\t\t}\n\tif (color) printf(""#Color\\n""); else\n\t\tprintf(""#Black&White\\n"");\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Brain s Photos.json,https://codeforces.com//blog/entry/46662,We need to do exactly what is written in the task to consider all of the characters and if there is at least one of the set C M Y print Color else Black White 
https://codeforces.com//contest/1207/problem/G,393977,G,1207G,1207,G. Indie Album,Mishka s favourite experimental indie band has recently dropped a new album Songs of that album share one gimmick Each name s i is one of the following types 1 c a single lowercase Latin letter 2 j c name s j 1 le j i with a single lowercase Latin letter appended to its end Songs are numbered from 1 to n It s guaranteed that the first song is always of type 1 Vova is rather interested in the new album but he really doesn t have the time to listen to it entirely Thus he asks Mishka some questions about it to determine if some song is worth listening to Questions have the following format i t count the number of occurrences of string t in s i the name of the i th song of the album as a continuous substring t consists only of lowercase Latin letters Mishka doesn t question the purpose of that information yet he struggles to provide it Can you please help Mishka answer all Vova s questions ,"['#include <bits/stdc++.h>\nusing namespace std;\nnamespace treeArr {\n    int sum[400010];\n    inline void add(int x, int k) {\n        for(; x <= 400000; x += x & -x) sum[x] += k;\n    }\n    inline int get(int x) {\n        int ans = 0;\n        for(; x; x -= x & -x) ans += sum[x];\n        return ans;\n    }\n}\nnamespace AC {\n    int son[400010][26], cnt;\n    int fail[400010];\n    vector<int> e[400010];\n    int dfn[400010], sze[400010];\n    int dfsnow;\n    inline int add(char *s) {\n        int now = 0;\n        for(int i = 0, n = strlen(s); i < n; i++) {\n            if(son[now][s[i] - \'a\'] == 0) son[now][s[i] - \'a\'] = ++cnt;\n            now = son[now][s[i] - \'a\'];\n        }\n        return now;\n    }\n    inline int getans(int id) {\n        return treeArr :: get(dfn[id] + sze[id] - 1) - treeArr :: get(dfn[id] - 1);\n    }\n    inline void dfs(int now) {\n        dfn[now] = ++dfsnow;\n        sze[now] = 1;\n        for(auto i : e[now]) dfs(i), sze[now] += sze[i];\n    }\n    inline void build() {\n        queue<int> q;\n        for(int i = 0; i < 26; i++) if(son[0][i]) q.push(son[0][i]);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            e[fail[now]].push_back(now);\n            for(int i = 0; i < 26; i++) {\n                if(son[now][i]) fail[son[now][i]] = son[fail[now]][i], q.push(son[now][i]);\n                else son[now][i] = son[fail[now]][i];\n            }\n        }\n        dfs(0);\n    }\n    inline int f(int x, int k) {\n        return son[x][k - \'a\'];\n    }\n}\nchar c[400010];\nint opt[400010];\nvector<int> son[400010];\nint ans[400010];\nvector<pair<int, int> > que[400010];\nvoid dfs(int now, int nowd) {\n    nowd = AC :: f(nowd, c[now]);\n    treeArr :: add(AC :: dfn[nowd], 1);\n    for(auto i : son[now]) dfs(i, nowd);\n    for(auto i : que[now]) {\n        ans[i.second] = AC :: getans(i.first);\n    }\n    treeArr :: add(AC :: dfn[nowd], -1);\n}\nchar s[400010];\nint main() {\n    int n;\n    scanf(""%d"", &n);\n    for(int i = 1, fa; i <= n; i++) {\n        scanf(""%d"", opt + i);\n        if(opt[i] == 2) scanf(""%d"", &fa), son[fa].push_back(i);\n        scanf(""%s"", c + i);\n    }\n    int m;\n    scanf(""%d"", &m);\n    for(int i = 1; i <= m; i++) {\n        int id;\n        scanf(""%d%s"", &id, s);\n        que[id].push_back(make_pair(AC :: add(s), i));\n    }\n    AC :: build();\n    for(int i = 1; i <= n; i++) if(opt[i] == 1) dfs(i, 0);\n    for(int i = 1; i <= m; i++) printf(""%d\\n"", ans[i]);\n    return 0;\n}']",,,"['data structures', 'dfs and similar', 'hashing', 'string suffix structures', 'strings', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Indie Album.json,https://codeforces.com//blog/entry/69314,There is a common approach for the problem you are given a lot of strings and texts count the number of occurences of the strings in the texts build an Aho Corasick automaton on the given strings and somehow process the texts with it Let s see if it can handle this problem The names of the songs can be represented as a tree We may build an Aho Corasick on the strings given in the queries then try to input the names of the album into the automaton character by character with DFS on the aforementioned tree feeding a character to the automaton when we enter a node and reverting the automaton to the previous state when we leave that node Suppose that when we are in the vertex corresponding to the th song the automaton is in state If is a terminal state corresponding to some string from the queries it means that the string from the query is a suffix of the th song But some other strings can also be the suffixes of the same song to find all such strings we can start ascending from the state to the root of Aho Corasick automaton using suffix links or dictionary links Since suffix links can be represented as the edges of some rooted tree then we can build some data structure on this tree that allows adding an integer to all vertices on the path from the root to the given vertex for example we can use Fenwick tree over Euler tour of the tree Then to check whether some string from the query is a suffix of the song we may add to all vertices on the path to state and then check the value in the state corresponding to Okay what about counting the occurences of in Let s consider the path from the root to in the song tree Every vertex on this path corresponds to some prefix of the song so we can add on the path to state corresponding to some prefix and then extract the answer from the state corresponding to In fact that s all we have to do to obtain a solution Build an automaton on strings from queries a tree of suffix links over this automaton and a data structure on this tree for each vertex of the song tree store all queries to it Then run a DFS on the song tree When we enter some vertex input the corresponding character into the automaton and add to all states from the root of suffix link tree to the current state when we have to process queries to the current vertex extract the values from the data structure and when we leave a vertex subtract from all states from the root of suffix link tree to the current state and revert to the previous state This solution has complexity of where is the total length of all strings in the input 
https://codeforces.com//contest/518/problem/F,22991,F,518F,518,F. Pasha and Pipe,On a certain meeting of a ruling party minister Pavel suggested to improve the sewer system and to create a new pipe in the city The city is an rectangular squared field Each square of the field is either empty then the pipe can go in it or occupied the pipe cannot go in such square Empty squares are denoted by character occupied squares are denoted by character The pipe must meet the following criteria the pipe is a polyline of width the pipe goes in empty squares the pipe starts from the edge of the field but not from a corner square the pipe ends at the edge of the field but not in a corner square the pipe has at most turns degrees the border squares of the field must share squares with the pipe if the pipe looks like a single segment then the end points of the pipe must lie on distinct edges of the field for each non border square of the pipe there are side adjacent squares that also belong to the pipe for each border square of the pipe there is side adjacent cell that also belongs to the pipe Here are some samples of piping routes Here are some samples of piping routes In these samples the pipes are represented by characters You were asked to write a program that calculates the number of distinct ways to make exactly one pipe in the city The two ways to make a pipe are considered distinct if they are distinct in at least one square ,"['#include <algorithm>\n#include <iostream>\n#include <memory.h>                     \n#include <fstream>\n#include <queue>\n#include <vector>\n\nusing namespace std;  \n\nint a[2222][2222], n, m, b[2222], c[2222], d[2222];\nint sum[2222][2222];\nlong long answer; \n\nint getsum(int x1, int y1, int x2, int y2) {\n\treturn sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];\n}          \n\nvoid addRow(int l, int r) {\n\tlong long k = d[r] - d[l - 1] + c[r] - c[l - 1];\n\tlong long h = 0;\n\tfor (int i = l; i <= r; ++i) {\n\t\tint k1 = k - (d[i] - d[i - 1]) - (c[i] - c[i - 1]);\n\t\tint k2 = k - k1;\n\t\th += (long long)k1 * (long long)k2;\n\t}\t\n\tanswer += (h / 2);\t\n}\n\nvoid addColumn(int l, int r) {\n\taddRow(l, r);  \n}\n                             \nint main() {\n\t//freopen(""input.txt"", ""r"", stdin);\n\t//freopen(""output.txt"", ""w"", stdout); \n\tscanf(""%d %d\\n"", &n, &m);  \t\n\tstring s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tgetline(cin, s);\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\t//a[i][j] = 0;\n\t\t\tif (s[j - 1] == \'.\') a[i][j] = 0; else a[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];\n\t\t}\n\t}\n\tfor (int i = 2; i + 1 <= n; ++i) {\n\t\tif (getsum(i, 1, i, m) == 0) ++answer;\t\t\t\t\n\t}\n\tfor (int i = 2; i + 1 <= m; ++i) {\n\t\tif (getsum(1, i, n, i) == 0) ++answer;\n\t}\n\n\tfor (int i = 2; i + 1<= n; ++i) {\n\t\tfor (int j = 2; j + 1 <= m; ++j) {\n\t\t\tint q1 = getsum(i, 1, i, j);\n\t\t\tint q2 = getsum(i, j, i, m);\n\t\t\tint q3 = getsum(1, j, i, j);\n\t\t\tint q4 = getsum(i, j, n, j);\n\t\t\tint cnt1 = 0, cnt2 = 0;\n\t\t\tif (q1 == 0) ++cnt1;\n\t\t\tif (q2 == 0) ++cnt1;\n\t\t\tif (q3 == 0) ++cnt2;\n\t\t\tif (q4 == 0) ++cnt2;\n\t\t\tanswer += (long long)(cnt1 * cnt2);\n\t\t}\n\t}\n\t\n\tfor (int j = 2; j + 1 <= m; ++j) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tb[i] = a[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tc[i] = 0; \n\t\t\td[i] = 0;   \t\n\t\t\tif (getsum(i, 1, i, j) == 0) ++c[i];\n\t\t\tif (getsum(i, j, i, m) == 0) ++d[i];\n\t\t}   \n\t\n\t\tc[0] = 0, d[0] = 0;\n\t\tfor (int i = 1; i <= n; ++i) c[i] = c[i - 1] + c[i], d[i] = d[i - 1] + d[i];    \n\n\n\t\tint l = 2;\n\t\twhile (l < n) {\n\t\t\tif (b[l] == 1) ++l; else {\n\t\t\t\tint r = l;\n\t\t\t\twhile (r < n && b[r] == 0) ++r; --r;\n\t\t\t\taddRow(l, r);\n\t\t\t\tl = r + 1;\n\t\t\t}\n\t\t}   \n\t}\n\n\n\tfor (int i = 2; i + 1 <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tb[j] = a[i][j];\n\t\t}\n\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tc[j] = 0;\n\t\t\td[j] = 0;\n\t\t\tif (getsum(1, j, i, j) == 0) ++c[j];\n\t\t\tif (getsum(i, j, n, j) == 0) ++d[j];\n\t\t}\n\t\t\n\t\tc[0] = 0, d[0] = 0;\n\t\tfor (int j = 1; j <= m; ++j) c[j] = c[j - 1] + c[j], d[j] = d[j - 1] + d[j];\n\n\t\tint l = 2;\n\t\twhile (l < m) {\n\t\t\tif (b[l] == 1) ++l; else {\n\t\t\t\tint r = l;\n\t\t\t\twhile (r < m && b[r] == 0) ++r; --r;\n\t\t\t\taddColumn(l, r);\n\t\t\t\tl = r + 1;\n\t\t\t}\n\t\t} \n\t}    \n\n\tfor (int i = 2; i + 1 <= n; ++i) {     \n\t\tfor (int j = 2; j + 1 <= m; ++j) {\n\t\t\tif (a[i][j] == 0 && a[i + 1][j] == 0 && i + 1 < n) {\n\t\t\t\tint h1 = getsum(i, 1, i, j), h2 = getsum(i, j, i, m);\n\t\t\t\tint h3 = getsum(i + 1, 1, i + 1, j), h4 = getsum(i + 1, j, i + 1, m);\n\t\t\t\tif (h1 == 0 && h3 == 0) --answer;\n\t\t\t\tif (h2 == 0 && h4 == 0) --answer;\n\t\t\t}\n\t\t\tif (a[i][j] == 0 && a[i][j + 1] == 0 && j + 1 < m) {\n\t\t\t\tint h1 = getsum(1, j, i, j), h2 = getsum(i, j, n, j);\n\t\t\t\tint h3 = getsum(1, j + 1, i, j + 1), h4 = getsum(i, j + 1, n, j + 1);\t\n\t\t\t\tif (h1 == 0 && h3 == 0) --answer;\n\t\t\t\tif (h2 == 0 && h4 == 0) --answer;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << answer << endl;\n\n\treturn 0;\n}                           ']",,,"['binary search', 'brute force', 'combinatorics', 'dp', 'implementation']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Pasha and Pipe.json,https://codeforces.com//blog/entry/16598,At first let s count two two dimensional arrays of prefix sums sumv and sumg In sumv i j store how many grids are in column j beginning from row 1 to row i In sumg i j store how many grid are in row i beginning from column 1 to column j Let s count ans0 how many pipes without bending we can pave Count how many vertical pipes we can pave Iterate on j from 2 to m 1 and if sumg n j sumg n 0 0 i e in this column zero grids increase ans0 on one Similary count number of horizontal pipes Let s count ans1 how many pipes with 1 bending we can pave We need to brute cell in which will bending There are four cases Let s consider first case others we can count similary This case pipe begin in left column go to current cell in brute and then go to top row If brute cell in row i and column j then to ans1 we need to add one if sumg i j sumg i 0 sumv i j sumv 0 j 0 Let s count ans2 how many pipes with 2 bendings we can pave Let s count how many tunes begin from top row and end in top or bottom row and add this number to ans2 Then rotate our matrix three times on 90 degrees and after every rotate add to ans2 count of pipes which begin from top row and end in top or bottom row Then we need divide ans2 to 2 because every pipe will count twice How we can count to current matrix how many pipes begin from top row and end in top or bottom row Let s count four two dimension arrays lf rg sumUp sumDown If i number of row j number of column of current cell then in position i lf i j in matrix are nearest from left grid for cell i j and in position i rg i j in matrix are nearest from right grid for cell i j sumUp i j how many columns without grids are in submatrix from 1 1 to i j of given matrix sumDown i j how many columns without grids are in submatrix from i 1 to n j of given matrix Then let s brute cell in which will be the first bending of pipe pipe goes from top row and in this cell turned to left or to right check that in column j above this cell 0 grids with help of arrays lf and rg find out as far as pipe can go to left or to right and with help of arrays sumUp and sumDown carefully update answer Now print number ans1 ans2 ans3 Asymptotic behavior of this solution O n m const where n hoew many rows in given matrix m how many columns in given matrix const takes different values depending on the implementation in solution from editorial const 10 
https://codeforces.com//contest/1036/problem/G,216423,G,1036G,1036,G. Sources and Sinks,You are given an acyclic directed graph consisting of n vertices and m edges The graph contains no multiple edges and no self loops The vertex is called a if it has no incoming edges The vertex is called a if it has no outgoing edges These definitions imply that some vertices can be both source and sink The number of sources in the given graph is equal to the number of sinks in it and each of these numbers doesn t exceed 20 The following algorithm is applied to the graph if the graph has no sources and sinks then quit choose arbitrary source s arbitrary sink t add an edge from t to s to the graph and go to step 1 that operation pops s out of sources and t out of sinks Note that s and t may be the same vertex then a self loop is added At the end you check if the graph becomes strongly connected that is any vertex is reachable from any other vertex Your task is to check that the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=(1<<20);\nvoid build(){\n\n}\nint n, m, od[N], id[N];\nvector<int> v[N];\nint oid[N], iid[N], tot;\nvoid init(){\n  n=getint();\n  m=getint();\n  while(m--){\n    int ui=getint();\n    int vi=getint();\n    od[ui]++;\n    id[vi]++;\n    v[ui].push_back(vi);\n  }\n  int _oid=0, _iid=0;\n  for(int i=1; i<=n; i++){\n    if(od[i]==0) oid[i]=_oid++;\n    else oid[i]=-1;\n    if(id[i]==0) iid[i]=_iid++;\n    else iid[i]=-1;\n  }\n  tot=_oid;\n}\nconst int K=20;\nint to[K], tg[N], stmp;\nvoid go(int st, int now){\n  tg[now]=stmp;\n  if(oid[now] >= 0)\n    to[st]|=(1<<oid[now]);\n  for(int nxt: v[now]){\n    if(tg[nxt] == stmp) continue;\n    go(st, nxt);\n  }\n}\nint msk[1<<K], cb[1<<K];\nvoid solve(){\n  for(int i=1; i<=n; i++)\n    if(iid[i] >= 0){\n      ++stmp;\n      go(iid[i], i);\n    }\n  for(int i=1; i<(1<<tot); i++)\n    cb[i]=cb[i>>1]+(i&1);\n  bool win=false;\n  for(int i=1; i<(1<<tot) and not win; i++){\n    for(int j=0; j<tot; j++)\n      if((i >> j) & 1)\n        msk[i]=msk[i^(1<<j)]|to[j];\n    if(i < (1<<tot)-1){\n      if(cb[i] == cb[msk[i]])\n        win=true;\n    }\n  }\n  puts(win?""NO"":""YES"");\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']",,,"['bitmasks', 'brute force', 'dfs and similar']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Sources and Sinks.json,https://codeforces.com/blog/entry/61727,Since the graph is acyclic then for every vertex there exists a path to some sink and to every vertex there exists a path from some source So our problem can be reduced to the following check that after running our algorithm all vertices from the initial set of sources and sinks belong to the same strongly connected component Let be the number of sources or sinks in the initial graph First of all let s run DFS or any other graph traversal from every source to form a set of reachable sinks for every source This part of solution has complexity of If is some set of sources of the original graph let be the set of sinks such that every sink from is reachable from at least one source from It s easy to see that there exists some set such that and then the answer is if we connected the sinks from with the sources from then any sink not belonging to would be unreachable from any sink belonging to Checking every possible set can be done in or in Let s prove that there is no such set then the answer is Let be an arbitrary sink of the original graph Also if is some set of sinks let be the set of sources containing every source directly connected to some sink from We can use mathematical induction to prove that every source and every sink is reachable from in the resulting graph Initially we state that is reachable from quite obvious If there is a set of sinks reachable from then either and the whole graph is reachable from or the number of sinks reachable from is at least so some set of sinks is reachable from So in fact checking every possible subset of sources is enough 
https://codeforces.com//contest/1084/problem/A,268415,A,1084A,1084,A. The Fair Nut and Elevator,The Fair Nut lives in n story house a i people live on the i th floor of the house Every person uses elevator twice a day to get from the floor where he she lives to the ground first floor and to get from the first floor to the floor where he she lives when he she comes back home in the evening It was decided that elevator when it is not used will stay on the x th floor but x hasn t been chosen yet When a person needs to get from floor a to floor b elevator follows the simple algorithm Moves from the x th floor initially it stays on the x th floor to the a th and takes the passenger Moves from the a th floor to the b th floor and lets out the passenger if a equals b elevator just opens and closes the doors comes to the floor from the x th floor Moves from the b th floor back to the x th The elevator never transposes more than one person and always goes back to the floor x before transposing a next passenger The elevator spends one unit of electricity to move between neighboring floors So moving from the a th floor to the b th floor requires a b units of electricity Your task is to help Nut to find the minimum number of electricity units that it would be enough for one day by choosing an optimal the x th floor Don t forget than elevator initially stays on the x th floor ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int n; cin >> n;\n    int data[n]; F0R(i, n) cin >> data[i];\n\n    int best = 1000000000;\n    F0R(i, n) {\n        int curTotal = 0;\n        F0R(j, n) {\n            int perPerson = i + j + abs(i-j);\n            curTotal += perPerson * data[j] * 2;\n        }\n        best = min(best, curTotal);\n    }\n\n    cout << best << endl;\n\n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343']",,,"['brute force', 'implementation']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. The Fair Nut and Elevator.json,https://codeforces.com/blog/entry/63753?locale=en,For each request of passenger who lives on the th floor to get to the first floor we need energy because in this case lift moves from the th floor to the th then from the th to the first then from the first to the th So sum is and it equals if request is to get from the first to the th floor number of energy is the same So the optimal answer can be acheived be choosing the first floor as the th 
https://codeforces.com//contest/1573/problem/B,1113070,B,1573B,1573,B. Swaps,You are given two arrays a and b of length n Array a contains each integer from 1 to 2n in an arbitrary order and array b contains each integer from 1 to 2n in an arbitrary order You can perform the following operation on those arrays choose one of the two arrays pick an index i from 1 to n 1 swap the i th and the i 1 th elements of the chosen array Compute the minimum number of operations needed to make array a lexicographically smaller than array b For two different arrays x and y of the same length n we say that x is lexicographically smaller than y if in the first position where x and y differ the array x has a smaller element than the corresponding element in y ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint i,j,k,n,m,t,res,pos[200500],mx[200500],it;\n\nint main(){\n\tscanf(""%d"",&t);\n\twhile(t--){\n\t\tscanf(""%d"",&n);res=11451491;\n\t\tit=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&k);\n\t\t\tpos[k]=++it;\n\t\t}\n\t\tit=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&k);\n\t\t\tpos[k]=++it;\n\t\t}\n\t\tmx[n+n+2]=11451419;\n\t\tfor(i=n+n;i>=2;i-=2){\n\t\t\tmx[i]=min(mx[i+2],pos[i]);\n\t\t\t//cout<<mx[i]<<endl;\n\t\t}\n\t\tfor(i=n+n-1;i>=1;i-=2){\n\t\t\tres=min(res,pos[i]-1+mx[i+1]-1);\n\t\t}\n\t\tprintf(""%d\\n"",res);\n\t}\n}']",,,"['greedy', 'math', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Swaps.json,https://codeforces.com//blog/entry/95086,Since the array has odd numbers and array has even numbers then they will differ at the first position no matter how we perform the operations It follows that in order to make the first array lexicographically smaller than the second one we need to make the first element of smaller than the first element of To move the th element of an array to the first position we can perform the operation on elements which is optimal The answer is then the minimum of over all such that Now we will think how to calculate this effectively Let be the position of number in its respective sequence for odd and for even We will go through the numbers from biggest to smallest Let be the position of the leftmost number in sequence that was already considered If is even we will set to If is odd we will set to Our total time complexity is then 
https://codeforces.com//contest/477/problem/B,15279,B,477B,477,B. Dreamoon and Sets,Dreamoon likes to play with sets integers and is defined as the largest positive integer that divides both and Let be a set of exactly four distinct integers greater than Define to be of rank if and only if for all pairs of distinct elements from Given and Dreamoon wants to make up sets of rank using integers from to such that no integer is used in two different sets of course you can leave some integers without use Calculate the minimum that makes it possible and print one possible solution ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\nint main() {\n\tscanf(""%d%d"",&n,&k);\n\tprintf(""%d\\n"",(6*n-1)*k);\n\trep(i,0,n) {\n\t\tprintf(""%d %d %d %d\\n"",(6*i+1)*k,(6*i+2)*k,(6*i+3)*k,(6*i+5)*k);\n\t}\n}\n']",,,['math'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Dreamoon and Sets.json,https://codeforces.com/blog/entry/14256,The first observation is that if we divide each number in a set by k than the set would be rank 1 So we could find n sets of rank 1 then multiple every number by k For how to find n sets of rank 1 we can use 6a 1 6a 2 6a 3 6a 5 as a valid rank 1 set and take a 0 to n 1 to form n sets and thus m 6n 1 k The proof that m is minimal can be shown by the fact that we take three consecutive odd numbers in each set If we take less odd numbers there will be more than 1 even number in a set which their gcd is obviously a multiple of 2 And if we take more odd numbers m would be larger 
https://codeforces.com//contest/1846/problem/E2,1999906,E2,1846E2,1846,E2. Rudolf and Snowflakes  hard version ,One winter morning Rudolf was looking thoughtfully out the window watching the falling snowflakes He quickly noticed a certain symmetry in the configuration of the snowflakes And like a true mathematician Rudolf came up with a mathematical model of a snowflake He defined a snowflake as an undirected graph constructed according to the following rules Initially the graph has only one vertex Then more vertices are added to the graph The initial vertex is connected by edges to k new vertices k 1 Each vertex that is connected to only one other vertex is connected by edges to k more new vertices This step should be done The smallest possible snowflake for k 4 is shown in the figure After some mathematical research Rudolf realized that such snowflakes may not have any number of vertices Help Rudolf check whether a snowflake with n vertices can exist ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long root_n(long long n, int k)\n{\n\tlong long m = pow(n, (long double)1.0 / k);\n\twhile (pow(m, k) <= n) \n    m++;\n\tm--;\n\treturn m;\n}\n\nvoid solve()\n{\n  long long n;\n\tcin >> n;\n\n\n\tfor (int m = 3; m<65;++m)\n    {\n\t\tlong long k = root_n(n, m-1);\n\t\tif (k < 2) continue;\n\t\t__int128 nn = n;\n\t\tnn *= (k - 1);\n\t\tnn += 1;\n\t\twhile (nn % k == 0) nn /= k;\n\t\tif (nn == 1) {\n\t\t\tcout << ""YES"" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << ""NO"" << endl;\n\treturn;\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n']",,,"['binary search', 'brute force', 'implementation', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E2. Rudolf and Snowflakes  hard version .json,https://codeforces.com//blog/entry/118044,On these constraints it is also possible to precalculate whether it is possible to obtain certain values of for some To do this we can iterate through all possible and for each of them calculate the values where is such that However in order to obtain all possible values of we would have to iterate through which exceeds the time limits Therefore let s precalculate all possible values of that can be obtained for We will store all the obtained values for example in a set We cannot use an array called used here due to the constraints on It is better to perform this precalculation before iterating through the test cases of the current test case Next for each test we only need to read the value of and check if we obtained it in the aforementioned precalculation If we obtained it we output YES and move on to the next test If we did not obtain it we need to separately check if we could obtain this value for To do this we solve the quadratic equation If it has integer roots that satisfy the problem s constraints then the answer is YES Otherwise it is NO The time complexity of the solution is Here is the number of tests in the test case 
https://codeforces.com//contest/1843/problem/B,1972491,B,1843B,1843,B. Long Long,Today Alex was brought array a 1 a 2 dots a n of length n He can apply as many operations as he wants including zero operations to change the array elements In 1 operation Alex can choose any l and r such that 1 leq l leq r leq n and multiply all elements of the array from l to r inclusive by 1 In other words Alex can replace the subarray a l a l 1 dots a r by a l a l 1 dots a r in 1 operation For example let n 5 the array is 1 2 0 3 1 l 2 and r 4 then after the operation the array will be 1 2 0 3 1 Alex is late for school so you should help him find the maximum possible sum of numbers in the array which can be obtained by making any number of operations as well as the minimum number of operations that must be done for this ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint a[N];\nvoid solve()\n{\n\tn=read();\tll ans=0;\tll tot=0;\n\tfor(int i=1;i<=n;++i)\ta[i]=read();\n\tbool flag=false;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tans+=abs(a[i]);\n\t\tif(a[i]>0)\tflag=false;\n\t\tif(a[i]<0)\n\t\t{\n\t\t\tif(!flag)\tflag=true,++tot;\n\t\t}\n\t}\n\tprintf(""%lld %lld\\n"",ans,tot);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}']",,,"['greedy', 'math', 'two pointers']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Long Long.json,https://codeforces.com//blog/entry/117468,We can delete all zeros from the array and it won t affect on answer Maximum sum is Minimum number of operations we should do number of continuous subsequences with negative values of elements Total complexity 
https://codeforces.com//contest/317/problem/B,3167,B,317B,317,B. Ants,It has been noted that if some ants are put in the junctions of the graphene integer lattice then they will act in the following fashion every minute at each junction containing at least four ants a group of four ants will be formed and these four ants will scatter to the neighbouring junctions one ant in each direction No other ant movements will happen Ants never interfere with each other Scientists have put a colony of ants into the junction 0 0 and now they wish to know how many ants will there be at some given junctions when the movement of the ants stops ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nconst int A = 500;\n\nint t[1005][1005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    t[A][A] = n;\n    int sz = 0;\n    while (true) {\n        bool ok = false;\n        for (int x = A - sz; x <= A + sz; ++x) {\n            for (int y = A - sz; y <= A + sz; ++y) {\n                if (t[x][y] >= 4) {\n                    if (max(abs(x - A), abs(y - A)) == sz) {\n                        ++sz;\n                    }\n                    ok = true;\n                    t[x - 1][y] += t[x][y] / 4;\n                    t[x + 1][y] += t[x][y] / 4;\n                    t[x][y - 1] += t[x][y] / 4;\n                    t[x][y + 1] += t[x][y] / 4;\n                    t[x][y] %= 4;\n                }\n            }\n        }\n        if (!ok) {\n            break;\n        }\n    }\n    int d;\n    cin >> d;\n    while (d--) {\n        int x, y;\n        cin >> x >> y;\n        if (max(abs(x), abs(y)) > sz) {\n            cout << 0 << ""\\n"";\n        } else {\n            cout << t[A + x][A + y  ] << ""\\n"";\n        }\n    }\n}\n']",,,"['brute force', 'implementation']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Ants.json,https://codeforces.com//blog/entry/7956,One may reformulate the problem ass follows Non negative integers A x y are placed in the vertices of two dimensional lattice We may imagine this construction as a function On each step for each vertex P x y with A x y 4 we perform operation P which substracts 4 from A x y and adds 1 to A x y 1 A x y 1 A x 1 y A x 1 y We may think that operation P applies to the whole function A We need to find values of A after the iterations stops Key idea is that operactions P and Q for all points P and Q commutes that is P Q A Q P A This means that the order of operations is unimportant In particular we may assume that from each given vertex run all possible four groups of ants and not only one After this observation one may run full emulation of the process As an exercise contestants may check that ants will never leave square 200 200 with center in the origin 0 with given constraints 
https://codeforces.com//contest/1671/problem/E,1376219,E,1671E,1671,E. Preorder,You are given a rooted tree of 2 n 1 vertices Every vertex of this tree has either 0 children or 2 children All leaves of this tree have the same distance from the root and for every non leaf vertex one of its children is the left one and the other child is the right one Formally you are given a The vertices of the tree are numbered in the following order the root has index 1 if a vertex has index x then its left child has index 2x and its right child has index 2x 1 Every vertex of the tree has a letter written on it either or Let s define the character on the vertex x as s x Let the of some vertex x be defined in the following way if the vertex x is a leaf then the of x be consisting of only one character s x otherwise the of x is s x f l x f r x where operator defines concatenation of strings f l x is the of the left child of x and f r x is the of the right child of x The of the tree is the of its root You have to calculate the number of different strings that can be obtained as the of the given tree if you are allowed to perform the following operation any number of times before constructing the of the tree choose any non leaf vertex x and swap its children so the left child becomes the right one and vice versa ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:45:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  Mint ans = 1;\n  function<string(int)> Dfs = [&](int v) {\n    if (2 * v + 1 >= (int) s.size()) {\n      return (string) """" + s[v];\n    }\n    auto x = Dfs(2 * v + 1);\n    auto y = Dfs(2 * v + 2);\n    if (x != y) {\n      ans *= 2;\n    }\n    if (x > y) {\n      swap(x, y);\n    }\n    return (string) """" + s[v] + x + y;\n  };\n  Dfs(0);\n  cout << ans << \'\\n\';\n  return 0;\n}\n']",,,"['combinatorics', 'divide and conquer', 'dp', 'dsu', 'hashing', 'sortings', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Preorder.json,https://codeforces.com//blog/entry/102181,In terms of preorder strings the operation swap two children of some vertex means swap two substrings of equal length in some specific location This operation can be inverted by applying it an additional time so for every positive integer all of the strings of length are split into equivalence classes in such a way that two strings from the same class can be transformed into each other and two strings from different classes cannot For each vertex the set of its possible preorder strings is one of these classes Let s calculate the answer for the problem recursively let be the number of preorder strings for the vertex For a leaf the number of its preorder strings is For a vertex with children and one of the two holds if the equivalence class for vertex is different from the equivalence class for vertex then we have to pick a string from the class of vertex pick a string from the class of vertex and choose the order in which we take them So if the equivalence class for is the same as the equivalence class for then swapping and doesn t do anything so we pick a string from the equivalence class of and then a string from the equivalence class of So The only thing we don t know is how to determine if two vertices represent the same equivalence class The model solution uses hashing for this but there s a much simpler method for each vertex let be the lexicographically smallest string that can be a preorder string of If a vertex has children and then and we can calculate these strings recursively since the total length is each of characters will be present in strings 
https://codeforces.com//contest/1314/problem/B,547037,B,1314B,1314,B. Double Elimination,The biggest event of the year Cota 2 world championship The Innernational is right around the corner 2 n teams will compete in a double elimination format please carefully read problem statement even if you know what is it to identify the champion Teams are numbered from 1 to 2 n and will play games one on one All teams start in the upper bracket All upper bracket matches will be held played between teams that haven t lost any games yet Teams are split into games by team numbers Game winner advances in the next round of upper bracket losers drop into the lower bracket Lower bracket starts with 2 n 1 teams that lost the first upper bracket game Each lower bracket round consists of two games In the first game of a round 2 k teams play a game with each other teams are split into games by team numbers 2 k 1 loosing teams are eliminated from the championship 2 k 1 winning teams are playing 2 k 1 teams that got eliminated in this round of upper bracket again teams are split into games by team numbers As a result of each round both upper and lower bracket have 2 k 1 teams remaining See example notes for better understanding Single remaining team of upper bracket plays with single remaining team of lower bracket in grand finals to identify championship winner You are a fan of teams with numbers a 1 a 2 a k You want the championship to have as many games with your favourite teams as possible Luckily you can affect results of every championship game the way you want What s maximal possible number of championship games that include teams you re fan of ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bool> a(1 << n);\n  while (m--) {\n    int x;\n    cin >> x;\n    a[--x] = true;\n  }\n  vector<vector<int>> dp(1 << (n + 1), vector<int>(4, -1));\n  auto merge = [&](int x, int l, int r) {\n    for (int i = 0; i < 4; ++i) {\n      if (dp[l][i] == -1) {\n        continue;\n      }\n      for (int j = 0; j < 4; ++j) {\n        if (dp[r][j] == -1) {\n          continue;\n        }\n        int w1 = i / 2, w2 = j / 2;\n        int l1 = i % 2, l2 = j % 2;\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n        swap(w1, w2);\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n      }\n    }\n  };\n  function<void(int, int, int)> solve = [&](int x, int l, int r) {\n    if (r - l == 2) {\n      if (!a[l] && !a[l + 1]) {\n        dp[x][0] = 0;\n      } else if (a[l] && a[l + 1]) {\n        dp[x][3] = 1;\n      } else {\n        dp[x][1] = dp[x][2] = 1;\n      }\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l) << 1);\n      solve(x + 1, l, y);\n      solve(z, y, r);\n      merge(x, x + 1, z);\n    }\n  };\n  solve(0, 0, 1 << n);\n  cout << max(dp[0][0], max(dp[0][1] + 1, max(dp[0][2] + 1, dp[0][3] + 1))) << ""\\n"";\n  return 0;\n}\n']",,,"['dp', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Double Elimination.json,https://codeforces.com//blog/entry/74214,The main observation in this problem is that for each set of players that lie in the subtree of any vertex of a binary tree of the upper bracket exactly one player will win all matches in the upper bracket and exactly one player will win all matches in the lower bracket We can define this set of players in 0 indexation instead of 1 indexation from statement as a 2t a 1 2t for some 1 t n 0 a 2n2t For each fixed t the players with different values of id2t don t play with each other and their upper and lower brackets are independent For each of these sets of players we are interested only in a number of interesting matches between them and if the winner of their upper and lower brackets are the teams that are we re fans of This leads us to the dynamic programming solution dp l r fup flower the maximal number of matches between teams with indices in l r if fup 0 1 is 1 if the we re fans of winner of upper bracket and flower 0 1 is 1 if the we re fans of winner of lower bracket Again l r is the special segment l a 2t r a 1 2t 1 for some 1 t n 0 a 2n2t dp l r fup flower can be recalculated from dp l l r2 flup fllower and dp l r2 r frup frlower we just iterate over all possible flup fllower frup frlower and the results of all three matches one in the upper bracket and two in the lower bracket In the end we use dp 0 2n fup flower to count the result with the last grand finals match This solution works in something like O 2n 27 because there are 2n interesting segments 
https://codeforces.com//contest/353/problem/D,3646,D,353D,353,D. Queue,There are schoolchildren boys and girls lined up in the school canteen in front of the bun stall The buns aren t ready yet and the line is undergoing some changes Each second all boys that stand right in front of girls simultaneously swap places with the girls so that the girls could go closer to the beginning of the line In other words if at some time the th position has a boy and the th position has a girl then in a second the th position will have a girl and the th one will have a boy Let s take an example of a line of four people a boy a boy a girl a girl from the beginning to the end of the line Next second the line will look like that a boy a girl a boy a girl Next second it will be a girl a boy a girl a boy Next second it will be a girl a girl a boy a boy The line won t change any more Your task is given the arrangement of the children in the line to determine the time needed to move all girls in front of boys in the example above it takes 3 seconds Baking buns takes a lot of time so no one leaves the line until the line stops changing ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n    cin.sync_with_stdio(0);\n    string s; cin >> s;\n    int N =s.length();\n    \n    vector<int> T(N+1,0);\n    int g =(int)(s[N-1] == \'F\'), lastM =N, ans =0;\n    for(int i =N-2; i >= 0; i--) {\n        if(s[i] == \'F\') {g++; continue;}\n        // collide directly\n        if(s[i+1] == \'M\') T[i] =T[i+1]+(int)(g > 0); \n        // dont collide\n        else if(g > 0) {\n            T[i] =g;\n            if(lastM < N && T[i] <= T[lastM]) T[i] =T[lastM]+1;}\n        ans =T[i];\n        lastM =i;}\n    cout << ans << ""\\n"";\n    return 0;}\n']",,,"['constructive algorithms', 'dp']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Queue60557.json,https://codeforces.com/blog/entry/9145,Note that if there are some girls in the begining of the line they will never move So let s remove them and will consider that the first schoolchildren in the line is a boy Also note the relative order of the girls doesn t change Let s calculate for each girl such moment of time that after it she won t move forever Note that for th girl Let s calculate in order from left to right Let s denote is the position in the line where th girl will stop ans is her current position Therefore it is needed second for girl to reach her finish position So if then Let s manage the case when The girl with number will be on th position by th second so Let s consider such moment of time when th girl stand right after th but not on th position After that in th moment of time th girl and the boy standing in front of her will swap their positions but th girl will save her position Then since th second till both girls will change their positions Finally at second th girl will occupy her position Therefore in this case 
https://codeforces.com//contest/1455/problem/F,815719,F,1455F,1455,F. String and Operations,You are given a string s consisting of n characters These characters are among the first k lowercase letters of the Latin alphabet You have to perform n operations with the string During the i th operation you take the character that the i th position and perform of the following actions with it swap it with the previous character in the string if it exists This operation is represented as swap it with the next character in the string if it exists This operation is represented as cyclically change it to the previous character in the alphabet becomes becomes and so on becomes the k th letter of the Latin alphabet This operation is represented as cyclically change it to the next character in the alphabet becomes becomes and so on the k th letter of the Latin alphabet becomes This operation is represented as do nothing This operation is represented as For example suppose the initial string is k 20 and the sequence of operations is Then the string is transformed as follows the first operation is so we change the underlined letter in to the next one in the first 20 Latin letters which is The string is now the second operation is so we swap the underlined letter with the next one in the string The string is now the third operation is so we swap the underlined letter with the previous one in the string note that this is now the 2 nd character of the string but it was initially the 3 rd one so the 3 rd operation is performed to it The resulting string is the fourth operation is so we change the underlined letter in to the previous one in the first 20 Latin letters which is The string is now The result of performing the sequence of operations is Given the string s and the value of k find the lexicographically smallest string that can be obtained after applying a sequence of operations to s ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N, K;\n    string S;\n    cin >> N >> K >> S;\n\n    auto down = [&](char ch) -> char {\n        return ch == \'a\' ? char(\'a\' + K - 1) : char(ch - 1);\n    };\n\n    auto up = [&](char ch) -> char {\n        return ch == char(\'a\' + K - 1) ? \'a\' : char(ch + 1);\n    };\n\n    string dp, dp_gap;\n\n    for (int i = 0; i < N; i++) {\n        // Transitions from dp[i]\n        string next_dp = dp + min({S[i], down(S[i]), up(S[i])});\n        string next_dp_gap = dp + S[i];\n\n        if (i >= 1)\n            next_dp = min(next_dp, dp.substr(0, i - 1) + S[i] + dp.back());\n\n        // Transitions from dp_gap[i]\n        if (i >= 1)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 1) + min({S[i], down(S[i]), up(S[i])}) + dp_gap.back());\n\n        if (i >= 2)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 2) + S[i] + dp_gap.substr(i - 2));\n\n        next_dp = min(next_dp, dp_gap + S[i]);\n        swap(dp, next_dp);\n        swap(dp_gap, next_dp_gap);\n    }\n\n    cout << dp << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['dp', 'greedy']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. String and Operations.json,https://codeforces.com//blog/entry/85186,The crucial observation that we have to make is that the character that initially occupied the position cannot occupy the positions to the left of we can shift some character two positions to the left using a combination of operations but we can t go any further So the prefix of the first characters of the resulting string can only be affected by the prefix of the first characters of the initial string Let s use the following dynamic programming to solve the problem let be the that we can obtain by applying operations to the first characters that is is the answer to the problem if we consider only first characters of the original string The transitions here are a bit tricky If we apply the operation or to the character then where is the character we get when we apply the aforementioned operation to that character is a bit more complicated we have to insert the character just before the last character of Modeling that we can apply the operation is likely the most complex transition in our dynamic programming First of all we can t just make an update to or since it leads us to a situation where we can still apply some operations to the prefix we have built Instead we have to consider the operation we will be able to do with the character Using another operation is useless since the result is like performing no operations with those two characters at all so we have to consider two options for operation with the th character or whichever is better or In the first case we update by appending the resulting two characters to the one that we get when we change and the one that initially was In the second case things are a bit trickier but still not very complicated the character that was moves two positions backward so it is inserted right before the last character of and then we append to the string we get So there are four transitions we have to make a transition from to that models the case when we apply or to the th character a transition from to that models the case when we apply to the th character a transition from to to model the operations or a transition from to to model the operations Overall complexity is but it can be improved to with some complicated data structures like persistent segment tree with hashes to compare strings and append characters to them in 
https://codeforces.com//contest/1286/problem/C2,509642,C2,1286C2,1286,C2. Madhouse  Hard version ,Venya joined a tour to the madhouse in which orderlies play with patients the following game Orderlies pick a string s of length n consisting only of lowercase English letters The player can ask two types of queries ask to list all substrings of s l r Substrings will be returned in random order and in every substring all characters will be randomly shuffled guess the string picked by the orderlies This query can be asked exactly once after that the game will finish If the string is guessed correctly the player wins otherwise he loses The player can ask of the first type To make it easier for the orderlies there is an additional limitation the total number of returned substrings in all queries of the first type must not exceed left lceil 0 777 n 1 2 right rceil lceil x rceil is x rounded up Venya asked you to write a program which will guess the string by interacting with the orderlies program and acting by the game s rules Your program should immediately terminate after guessing the string using a query of the second type In case your program guessed the string incorrectly or it violated the game rules it will receive verdict Note that in every test case the string is fixed beforehand and will not change during the game which means that the interactor is not adaptive ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar p[120], A[10100][120], B[10100][120], res[120];\nint SA[110], SB[110], Z[110], Pre[110];\nint SS[110], Suf[110];\nvoid Do(int n) {\n\tint i, j;\n\tprintf(""? %d %d\\n"", 1, n);\n\tfflush(stdout);\n\tfor (i = 0; i < n*(n + 1) / 2; i++) {\n\t\tscanf(""%s"", A[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; A[i][j]; j++)c += A[i][j] - \'a\';\n\t\tint L = j;\n\t\tSA[L] += c;\n\t}\n\tprintf(""? %d %d\\n"", 1, n - 1);\n\tfflush(stdout);\n\n\tfor (i = 0; i < n*(n - 1) / 2; i++) {\n\t\tscanf(""%s"", B[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; B[i][j]; j++)c += B[i][j] - \'a\';\n\t\tint L = j;\n\t\tSB[L] += c;\n\t}\n\n\tfor (i = 1; i <= n; i++) {\n\t\tZ[i] = SA[i] - SB[i];\n\t\tres[n - i] = Z[i] - Z[i - 1] + \'a\';\n\t}\n\n}\nint main() {\n\tint i, j, k;\n\tint n;\n\tscanf(""%d"", &n);\n\n\tif (n == 1) {\n\t\tprintf(""? %d %d\\n"", 1, n);\n\t\tfflush(stdout);\n\t\tscanf(""%s"", p);\n\t\tprintf(""! %s\\n"", p);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tif (n == 2) {\n\n\t\tprintf(""? %d %d\\n"", 1, 1);\n\t\tfflush(stdout);\n\t\tscanf(""%s"", p);\n\t\tres[0] = p[0];\n\t\tprintf(""? %d %d\\n"", 2, 2);\n\t\tfflush(stdout);\n\t\tscanf(""%s"", p);\n\t\tres[1] = p[0];\n\t\tres[2] = 0;\n\t\tprintf(""! %s\\n"", res);\n\t\treturn 0;\n\t}\n\n\tDo((n + 1) / 2);\n\n\tprintf(""? %d %d\\n"", 1, n);\n\tfflush(stdout);\n\n\tfor (i = 0; i < (n + 1) / 2; i++) {\n\t\tPre[i + 1] = Pre[i] + res[i] - \'a\';\n\t}\n\n\tfor (i = 0; i < n*(n + 1) / 2; i++) {\n\t\tscanf(""%s"", A[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; A[i][j]; j++)c += A[i][j] - \'a\';\n\t\tint L = j;\n\t\tSS[L] += c;\n\t}\n\tint tot = SS[n];\n\n\tfor (i = 1; i <= n / 2; i++) {\n\t\tint z = SS[n-i];\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tint s = 0;\n\t\t\tfor (k = 0; k < i - j; k++) {\n\t\t\t\ts += res[n - k - 1] - \'a\';\n\t\t\t}\n\t\t\tz -= tot - (s + Pre[j]);\n\t\t}\n\n\t\tz -= (tot - Pre[i]);\n\t\tSuf[i] = tot - z;\n\t\tres[n - i] = Suf[i] - Suf[i - 1] + \'a\';\n\t}\n\tprintf(""! %s\\n"", res);\n\tfflush(stdout);\n\n}']",,,"['brute force', 'constructive algorithms', 'hashing', 'interactive', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C2. Madhouse  Hard version .json,https://codeforces.com//blog/entry/72867,Let s consider the solution that uses queries with the lengths and it asks about too many substrings so it will not pass all the tests but it will help us further Let s ask about substrings and For convenience rearrange the letters in all strings in alphabetical order Then note that all the suffixes of correspond to those strings that we get in the first case and do not get in the second Having found all such strings we can easily find all suffixes of by looking at them from smaller ones to bigger For a complete solution we should first find the first characters of the string by the solution described above Then ask about the whole string Let be the number of times that the symbol occurs in total in all substrings of length in the last query Note that the symbol at position is counted in exactly times Then for all from to the value is equal to the number of times that occurs on positions with indices from to Knowing these quantities it is possible to find out how many times the element x occurs on positions and in sum for each from to Since we already know the first half of the string it is not difficult to restore the character at the position and therefore the entire string In total we asked about the substrings and the total number of substrings received is and that the limitations of the problem 
https://codeforces.com//contest/1038/problem/A,216021,A,1038A,1038,A. Equality,You are given a string s of length n which consists only of the first k letters of the Latin alphabet All letters in string s are uppercase A of string s is a string that can be derived from s by deleting some of its symbols without changing the order of the remaining symbols For example and are subsequences of but is not A subsequence of s called if the number of occurences of each of the first k letters of the alphabet is the same Find the length of the longest good subsequence of s ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(""%lld"", &x); return x;}\nvoid read(char *s){scanf(""%s"", s);}\nvoid no(){printf(""NO""); exit(0);}\n\n#define maxn 120000\n#define maxm\n\nchar s[maxn];\nint c[maxn];\nint main(){\n\tint n = read(), k = read(), ans = n + 1;\n\tread(s);\n\tfor(int i = 0; i < n; i += 1) c[s[i] - \'A\'] += 1;\n\tfor(int i = 0; i < k; i += 1) ans = min(ans, c[i]);\n\tprintf(""%d"", ans * k);\n}']",,,"['implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Equality.json,https://codeforces.com/blog/entry/61692,First we need to find the frequencies of the first alphabets in the string Let the minimum frequency among these frequencies be Then we cannot select characters of one kind and we can definitely select characters of each kind hence the answer is given by frequency of first characters Overall Complexity 
https://codeforces.com//contest/1617/problem/E,1229935,E,1617E,1617,E. Christmas Chocolates,Christmas is coming Icy has just received a box of chocolates from her grandparents The box contains n chocolates The i th chocolate has a non negative integer type a i Icy believes that good things come in pairs Unfortunately all types of chocolates are distinct all a i are Icy wants to make at least one pair of chocolates the same type As a result she asks her grandparents to perform some Icy chooses two chocolates with indices x and y 1 le x y le n x ne y In a Icy s grandparents choose a non negative integer k such that 2 k ge a x and change the type of the chocolate x from a x to 2 k a x that is perform a x 2 k a x The chocolate exchanges will be stopped only when a x a y Icy s grandparents are smart so they would choose the sequence of chocolate exchanges that the number of exchanges needed Since Icy likes causing trouble she wants to the minimum number of exchanges needed by choosing x and y appropriately She wonders what is the optimal pair x y such that the minimum number of exchanges needed is maximized across all possible choices of x y Since Icy is not good at math she hopes that you can help her solve the problem ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin >> n;\n\tmap<int, int> par, pos;\n\tauto fp = [&](int u){\n\t\tif (u == 0) return -1;\n\t\tint k = 1;\n\t\twhile (k < u) k <<= 1;\n\t\treturn k - u;\n\t};\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i += 1) {\n\t\tcin >> a[i];\n\t\tfor (int p = a[i]; p != -1; p = par[p])\n\t\t\tpar[p] = fp(p);\n\t\tpos[a[i]] = i;\n\t}\n\tint m = par.size();\n\tvector<int> v(m), p(m, -1), key(m);\n\tmap<int, int> mp;\n\tfor (int i = 0; auto [x, y] : par) {\n\t\tv[i] = x;\n\t\tmp[x] = i;\n\t\tif (y != -1) p[i] = mp[y];\n\t\tif (pos.contains(x)) key[i] = 1;\n\t\ti += 1;\n\t}\n\tvector<tuple<int, int, int>> dp(m, {0, -1, -1});\n\tvector<pair<int, int>> mx(m, {-1, -1}), mx2(m, {-1, -1});\n\tauto insert = [&](int i, pair<int, int> p){\n\t\tif (p > mx[i]) {\n\t\t\tmx2[i] = mx[i];\n\t\t\tmx[i] = p;\n\t\t}\n\t\telse if (p > mx2[i]) mx2[i] = p;\n\t};\n\tfor (int i = m - 1; i >= 0; i -= 1) {\n\t\tif (key[i]) insert(i, {0, i});\n\t\tif (mx2[i].first != -1)\n\t\t\tdp[i] = max(dp[i], {mx[i].first + mx2[i].first, mx[i].second, mx2[i].second});\n\t\tif (i) {\n\t\t\tif (mx[i].first != -1) insert(p[i], {mx[i].first + 1, mx[i].second});\n\t\t\tdp[p[i]] = max(dp[p[i]], dp[i]);\n\t\t}\n\t}\n\tauto [w, x, y] = dp[0];\n\tcout << pos[v[x]] << "" "" << pos[v[y]] << "" "" << w << ""\\n"";\n\treturn 0;\n}']",,,"['dfs and similar', 'dp', 'games', 'graphs', 'implementation', 'math', 'number theory', 'shortest paths', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Christmas Chocolates.json,https://codeforces.com//blog/entry/97920,Solution Step 1 In graph terms the problem is as follows in a graph with infinite nodes two nodes and are connected if for some Among special nodes find the pair of nodes with maximum shortest distance Here comes the key observation For any there exists only one such that for some The proof is as follows let s say that Then So Since Then we realize we can build a graph as follows add an edge between and if for some Because of the first key observation the graph must be a tree We can root the tree at node Our problem is equivalent to finding the pair of nodes which have maximum distance in a tree which can be solved using the diameter of tree algorithm 
https://codeforces.com//contest/1426/problem/C,741032,C,1426C,1426,C. Increase and Copy,Initially you have the array a consisting of one element 1 a 1 In one move you can do one of the following things Increase some element of a by 1 choose some i from 1 to the current length of a and increase a i by one Append the copy of some element of a to the end of the array choose some i from 1 to the current length of a and append a i to the end of the array For example consider the sequence of five moves You take the first element a 1 append its copy to the end of the array and get a 1 1 You take the first element a 1 increase it by 1 and get a 2 1 You take the second element a 2 append its copy to the end of the array and get a 2 1 1 You take the first element a 1 append its copy to the end of the array and get a 2 1 1 2 You take the fourth element a 4 increase it by 1 and get a 2 1 1 3 Your task is to find the number of moves required to obtain the array with the sum at least n You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl ""\\n""\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<\'(\'<<p.F<< "",""<<p.S<<\')\'; \n}\n\nint _runtimeTerror_()\n{\n    ll n;\n    cin>>n;\n    ll ans = INF;\n    for(ll i=1;i*i<=n;++i)\n    {\n        if(n%i==0)\n        {\n            amin(ans,(i-1) + n/i -1);\n        }\n        else\n        {\n            amin(ans,(i-1) + n/i);\n        }\n    }\n    cout<<ans<<""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']",,,"['binary search', 'constructive algorithms', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Increase and Copy.json,https://codeforces.com//blog/entry/83120,It is pretty intuitive that we firstly need to do all increments and only then copy numbers because otherwise we can swap the order of moves and the sum will not decrease You could notice that the answer does not exceed so we can just iterate from to and fix the number we will copy Let it be Then we need moves to obtain it and also need moves to get the enough number of copies So we can update the answer with this number of moves Time complexity per test case Actually the required number is always pretty near to so it is enough to try a few options in range to get the optimal answer This is solution 
https://codeforces.com//contest/1512/problem/C,953476,C,1512C,1512,C. A-B Palindrome,You are given a string s consisting of the characters and You need to replace all the characters with in the string s by or so that the string becomes a palindrome and has a characters and b characters Note that each of the characters is replaced from the others A string t of length n is called a palindrome if the equality t i t n i 1 is true for all i 1 le i le n For example if s a 4 and b 4 then you can replace the characters in the following ways For the given string s and the numbers a and b replace all the characters with in the string s by or so that the string becomes a palindrome and has a characters and b characters ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=100010;\nconst int mod=1000000007;\nusing namespace std;\n\nint a[2];\nstring s;\n\nstring solve()\n{\tint n=s.length();\n\tif(a[0]+a[1]!=n)return ""-1"";\n\tfor(int i=0;i<n/2;i++){\n\t\tif(s[i]!=\'?\'||s[n-i-1]!=\'?\'){\n\t\t\tif(s[i]!=\'?\'&&s[n-i-1]!=\'?\'){\n\t\t\t\tif(s[i]!=s[n-i-1])return ""-1"";\n\t\t\t}else{\n\t\t\t\tif(s[i]==\'?\')\n\t\t\t\t\ts[i]=s[n-i-1];\n\t\t\t\telse\n\t\t\t\t\ts[n-i-1]=s[i];\n\t\t\t}\n\t\t\ta[s[i]-\'0\']-=2;\n\t\t\tif(a[s[i]-\'0\']<0)return ""-1"";\n\t\t}\n\t}\n\tif(n%2){\n\t\tif(s[n/2]==\'?\'){\n\t\t\tif(a[0]%2)s[n/2]=\'0\';\n\t\t\telse if(a[1]%2)s[n/2]=\'1\';\n\t\t\telse return ""-1"";\n\t\t\ta[s[n/2]-\'0\']--;\n\t\t}else{\n\t\t\ta[s[n/2]-\'0\']--;\n\t\t\tif(a[s[n/2]-\'0\']<0)return ""-1"";\n\t\t}\n\t}\n\tfor(int i=0;i<n/2;i++){\n\t\tif(s[i]==\'?\'){\n\t\t\tif(a[0])\n\t\t\t\ts[i]=s[n-i-1]=\'0\';\n\t\t\telse\n\t\t\t\ts[i]=s[n-i-1]=\'1\';\n\t\t\ta[s[i]-\'0\']-=2;\n\t\t\tif(a[s[i]-\'0\']<0)return ""-1"";\n\t\t}\n\t}\n\treturn s;\n}\n\nint main()\n{\tint _=1,__=1;\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""/Users/py/Documents/workspace/C++/try.in"",""r"",stdin);\n\tfreopen(""/Users/py/Documents/workspace/C++/try.out"",""w"",stdout);\n\t#endif\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d%d"",&a[0],&a[1]);\n\t\tcin>>s;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'implementation', 'strings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. A-B Palindrome.json,https://codeforces.com//blog/entry/89535,First let s find such positions such that symbols in symmetric positions are uniquely determined If then If then at the end we will not get a palindrome in any way so the answer is Note that after such a replacement the remaining characters are split into pairs except maybe the central one If the center character is then it is necessary to put the character if is odd or if is odd if neither nor is odd then the answer is Now the remaining characters are split into pairs i e if then This allows the remaining characters and to be replaced greedily If and then and decrease for If and then and decrease for Otherwise the answer is 
https://codeforces.com//contest/9/problem/E,41,E,9E,9,E. Interesting Graph and Apples,Hexadecimal likes drawing She has drawn many graphs already both directed and not Recently she has started to work on a still life interesting graph and apples An undirected graph is called interesting if each of its vertices belongs to one cycle only a funny ring and does not belong to any other cycles A funny ring is a cycle that goes through all the vertices just once Moreover loops are funny rings too She has already drawn the apples and some of the graph edges But now it is not clear how to connect the rest of the vertices to get an interesting graph as a result The answer should contain the minimal amount of added edges And furthermore the answer should be the lexicographically smallest one The set of edges where is lexicographically smaller than the set where provided that the sequence of integers is lexicographically smaller than the sequence If you do not cope Hexadecimal will eat you eat you alive ,"['#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint pos[120] = {0};\n\nvector <pair <int, int> > paths;\nint f[1000];\n\nint alt(int x)\n{\n\tint p = pos[x];\n\treturn (paths[p].first + paths[p].second - x);\n}\n\npair <int, int> unite(pair <int, int> a, pair <int, int> b)\n{\n\tif (a.first == b.first) return make_pair(a.second, b.second);\n\tif (a.first == b.second) return make_pair(a.second, b.first);\n\tif (a.second == b.first) return make_pair(a.first, b.second);\n\treturn make_pair(a.first, b.first);\n}\n\nint main()\n{\n//\tfreopen("""", ""rt"", stdin);\n//\tfreopen("""", ""wt"", stdout);\n\tint n, m;\n\tcin >> n >> m;\t\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tpos[i] = i;\n\t\tpaths.push_back(make_pair(i, i));\n\t\tf[i] = 1;\n\t}\n\tint q = n;\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tif (pos[x] > pos[y]) swap(x, y);\n\t\tif (pos[x] == pos[y])\n\t\t\tif (q != 1)\n\t\t\t{\n\t\t\t\tcout << ""NO"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (i == m-1)\n\t\t\t{\n\t\t\t\tcout << ""YES\\n0\\n"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << ""NO"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tif (pos[x] < 0 || pos[y] < 0)\n\t\t{\n\t\t\tcout << ""NO"";\n\t\t\treturn 0;\n\t\t}\n\t\tpaths.push_back(make_pair(alt(x), alt(y)));\n\t\tint fr = paths.size() - 1;\n\t\tf[pos[x]] = 0;\n\t\tf[pos[y]] = 0;\n\t\tf[fr] = 1;\n\t\tq--;\n\t\tif (x != alt(x))\n\t\t{\n\t\t\tpos[alt(x)] = fr;\n\t\t\tpos[x] = -1;\n\t\t}\n\t\telse pos[x] = fr;\n\t\tif (y != alt(y)) \n\t\t{\n\t\t\tpos[alt(y)] = fr;\n\t\t\tpos[y] = -1;\n\t\t}\n\t\telse pos[y] = fr;\n\t}\n\tvector <pair <int, int> > chains;\n\tfor (int i = 0; i < paths.size(); ++i)\n\t\tif (f[i])\n\t\t{\n\t\t\tif (paths[i].first > paths[i].second) swap(paths[i].first, paths[i].second);\n\t\t\tchains.push_back(paths[i]);\n\t\t}\t\n\tsort(chains.begin(), chains.end());\n\tcout << ""YES\\n"";\n\tcout << chains.size() << \'\\n\';\n\twhile (chains.size() > 1)\n\t{\n\t\tcout << chains[0].first + 1 << \' \' << chains[1].first + 1 << \'\\n\';\n\t\tchains[1].first = chains[0].second;\n\t\tif (chains[1].first > chains[1].second) swap(chains[1].first, chains[1].second);\n\t\tchains.erase(chains.begin());\n\t\tsort(chains.begin(), chains.end());\n\t}\n\tcout << chains[0].first + 1 << \' \' << chains[0].second + 1<< \'\\n\';\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dsu', 'graphs']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Interesting Graph and Apples.json,https://codeforces.com//blog/entry/283,The funny ring consists of n vertices and n edges If there is another edge except for these n then the vertices it connects belong to more than one cycle So an interesting graph is just a funny ring A graph is a funny ring if and only if the following conditions hold A1 The degree of each vertex equals 2 A2 The graph is connected Now let s figure out when a graph is not yet a funny ring but can be transformed into a funny ring by adding edges There are obvious necessary conditions B1 m n B2 There are no cycles B3 The degree of each vertex is not more than 2 Let s add edges so that these conditions were preserved and the sequence of edges was lexicographically minimal So we add an edge i j such that 1 The degrees of i and j are less than 2 Otherwise we would break B3 2 i and j belong to different connected components Otherwise we would break B2 3 The pair i j is lexicographically minimal Let s see what we have when we can t add edges anymore Since there are no cycles each connected component is a tree and therefore has at least one vertex with degree less than 2 If there are two connected components then they could be connected by an edge without breaking B1 B3 So the graph is connected has no cycles and the degree of each vertex is not more than 2 This means that the obtained graph is just a walk and we can connect its end points to obtain a funny ring To summarize the algorithm is the following 1 Check if A1 A2 hold If yes output YES and 0 2 Check if B1 B3 hold If no output NO 3 Output YES and n m 4 Add edges as described When the edge i j is added output i j 5 Find the only vertices i and j with degree less than 2 they can be equal if n 1 Output i j 
https://codeforces.com//contest/1670/problem/F,1390326,F,1670F,1670,"F. Jee, You See ",You are given 4 integers n l r and z Count the number of arrays a of length n containing non negative integers such that l le a 1 a 2 ldots a n le r and a 1 oplus a 2 oplus ldots oplus a n z where oplus denotes the bitwise XOR operation Since the answer can be large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint C[1005][1005],dp[70][1005][2],n,z;\ninline int cal(int x)\n{\n\tmemset(dp,0,sizeof dp);\n\tdp[0][0][1]=1;\n\tfor(int i=1;i<=61;i++)\n\t{\n\t\tint X=(x>>i-1)&1;\n\t\tfor(int j=0;j<=1000;j++)\n\t\t{\n\t\t\tif(!dp[i-1][j][0]&&!dp[i-1][j][1]) continue;\n\t\t\tfor(int k=(z>>i-1)%2;k<=1000;k+=2)\n\t\t\t{\n\t\t\t\tint nw=j+k;\n\t\t\t\tif(nw&1)\n\t\t\t\t{\n\t\t\t\t\tif(X==0)\n\t\t\t\t\t\tdp[i][nw/2][0]=((dp[i-1][j][0]+dp[i-1][j][1])*C[n][k]+dp[i][nw/2][0])%mod;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][nw/2][1]=(C[n][k]*dp[i-1][j][1]+dp[i][nw/2][1])%mod;\n\t\t\t\t\t\tdp[i][nw/2][0]=(C[n][k]*dp[i-1][j][0]+dp[i][nw/2][0])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(X==1)\n\t\t\t\t\t\tdp[i][nw/2][1]=((dp[i-1][j][0]+dp[i-1][j][1])*C[n][k]+dp[i][nw/2][1])%mod;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][nw/2][1]=(C[n][k]*dp[i-1][j][1]+dp[i][nw/2][1])%mod;\n\t\t\t\t\t\tdp[i][nw/2][0]=(C[n][k]*dp[i-1][j][0]+dp[i][nw/2][0])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[61][0][1];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor(int i=0;i<=1000;i++)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=0;j<i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint l,r;\n\tcin >> n >> l >> r >> z;\n\tcout << ((cal(r)-cal(l-1)+mod)%mod+mod)%mod ;\n\treturn 0;\n}']",,,"['bitmasks', 'combinatorics', 'dp']",2400,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Jee, You See .json",https://codeforces.com//blog/entry/102579,Let s put aside the XOR constraint and only focus on the sum constraint let be the number of ways to construct integers such that their sum is at most We will construct each bit of the integers at the same time we want to guarantee that the contribution of the sum of the bits generated at each position plus the sum of the previous bits wont exceed we only have to know the difference between the previous bits of add 1 if the current bit is on and the sum of the generated bits However we know for sure that at each position we can generate at most bits which will sum to at most so for the next position the difference will be the current difference the sum of the bits at the cur position we can see that if the current difference has a value we can place any number of bits at the remaining positions Let s define as the number of ways to construct the first bits of the integers such that their sum doesn t exceed where is min between the difference between the previous bits and and We can have from 0 to ones placed at the current bit and for each we have ways to distribute them Formally where is one if the limit have the bit on For the XOR constraint we only have to make sure that count is even if the current bit of Z is 0 or odd if the current bit is 1 The answer of the problem will be 
https://codeforces.com//contest/820/problem/A,112028,A,820A,820,A. Mister B and Book Reading,Mister B once received a gift it was a book about aliens which he started read immediately This book had pages At first day Mister B read pages but after that he started to speed up Every day starting from the second he read pages more than on the previous day at first day he read pages at second pages at third pages and so on But Mister B is just a human so he physically wasn t able to read more than pages per day Also to refresh his memory every day starting from the second Mister B had to reread last pages he read on the previous day Mister B finished the book when he read the last page for the first time Help Mister B to calculate how many days he needed to finish the book ,"['#include<iostream>\n#include<cstdio>\nusing namespace std;\ninline int read()\n{\n\tint x = 0 , f = 1; char ch = getchar();\n\twhile(ch < \'0\' || ch > \'9\'){ if(ch == \'-\') f = -1;  ch = getchar();}\n\twhile(ch >= \'0\' && ch <= \'9\'){x = x * 10 + ch - \'0\';ch = getchar();}\n\treturn x * f;\n}\nint c,v0,v1,a,l;\nint main()\n{\n\tc=read();v0=read();v1=read();a=read();l=read();\n\tfor(int now=1,day=1;;++day)\n\t{\n\t\tint Rd=v0-(day!=1?l:0);\n\t\tnow+=Rd;\n\t\tif(now>c) return 0*printf(""%d\\n"",day);\n\t\tv0=min(v1,v0+a);\n\t}\n\treturn 0;\n}\n']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Mister B and Book Reading.json,https://codeforces.com//blog/entry/52946,All that needed is to accurately simulate process Create variable which will contain count of read pages subtract add check what you still have unread pages make and again Complexity is 
https://codeforces.com//contest/1574/problem/E,1115678,E,1574E,1574,E. Coloring,A matrix of size n times m such that each cell of it contains either 0 or 1 is considered if the sum in every contiguous submatrix of size 2 times 2 is exactly 2 i e every square of size 2 times 2 contains exactly two 1 s and exactly two 0 s You are given a matrix of size n times m Initially each cell of this matrix is empty Let s denote the cell on the intersection of the x th row and the y th column as x y You have to process the queries of three types x y 1 clear the cell x y if there was a number in it x y 0 write the number 0 in the cell x y x y 1 write the number 1 in the cell x y After each query print the number of ways to fill the empty cells of the matrix so that the resulting matrix is Since the answers can be large print them modulo 998244353 ,"['/**\n *    author:  tourist\n *    created: 20.09.2021 17:49:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> row_has(n, vector<int>(2));\n  vector<vector<int>> col_has(m, vector<int>(2));\n  vector<int> mat_has(2);\n  int bad_rows = 0;\n  int bad_cols = 0;\n  int empty_rows = n;\n  int empty_cols = m;\n  map<pair<int, int>, int> mp;\n  auto CountRow = [&](int x, int coeff) {\n    if (row_has[x][0] + row_has[x][1] == 0) {\n      empty_rows += coeff;\n    }\n    if (row_has[x][0] > 0 && row_has[x][1] > 0) {\n      bad_rows += coeff;\n    }\n  };\n  auto CountCol = [&](int x, int coeff) {\n    if (col_has[x][0] + col_has[x][1] == 0) {\n      empty_cols += coeff;\n    }\n    if (col_has[x][0] > 0 && col_has[x][1] > 0) {\n      bad_cols += coeff;\n    }\n  };\n  auto Add = [&](int x, int y, int z) {\n    CountRow(x, -1);\n    CountCol(y, -1);\n    row_has[x][(y + z) % 2] += 1;\n    col_has[y][(x + z) % 2] += 1;\n    CountRow(x, +1);\n    CountCol(y, +1);\n    mat_has[(x + y + z) % 2] += 1;\n  };\n  auto Remove = [&](int x, int y, int z) {\n    CountRow(x, -1);\n    CountCol(y, -1);\n    row_has[x][(y + z) % 2] -= 1;\n    col_has[y][(x + z) % 2] -= 1;\n    CountRow(x, +1);\n    CountCol(y, +1);\n    mat_has[(x + y + z) % 2] -= 1;\n  };\n  while (k--) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    auto p = make_pair(x, y);\n    auto it = mp.find(p);\n    if (it != mp.end()) {\n      Remove(x, y, it->second);\n      mp.erase(it);\n    }\n    if (z != -1) {\n      Add(x, y, z);\n      mp[p] = z;\n    }\n    Mint ans = 0;\n    if (bad_rows == 0) {\n      ans += power(Mint(2), empty_rows);\n    }\n    if (bad_cols == 0) {\n      ans += power(Mint(2), empty_cols);\n    }\n    for (int v : mat_has) {\n      if (v == 0) {\n        ans -= 1;\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'implementation', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Coloring66829.json,https://codeforces.com//blog/entry/95188,For best understanding we replace the matrix with and with the matrix with black and white cells At first let s consider matrix if there are two adjacent horizontal cell with same color for example cells and are black Then the cells and must have the opposite color white the cells and must have the same color black and so on So two adjacent horizontal cells generate the of width two Reciprocally two adjacent vertical cells generate the of width two And if simultaneously there are and then the answer is because they contradict each other If there are two cells of same color in the same row with even number of cells between them for example and with four cells between them then there is the because there are always two adjacent cells with same color between them The same is correct for Now let s consider how the matrix look if there are the It look like a chess board of size but colors of some verticals are inverted The same is correct if there are the How we can quickly understand that there are two cells of same color in the same row with even number of cells between them For this mentally color the matrix in a checkerboard pattern And then one of this cells has the same color witch cells in chessboard and the other has the opposite color witch cells in chessboard For calculating the answer we have maintain to the following values The color of each colored cell The row and columns containing the cells of same color with even number of cells between them And the number of row and columns containing at least one colored cell for calculating the number of beautiful matrix 
https://codeforces.com//contest/1901/problem/F,2344508,F,1901F,1901,F. Landscaping,You are appointed to a very important task you are in charge of flattening one specific road The road can be represented as a polygonal line starting at 0 0 ending at n 1 0 and consisting of n vertices including starting and ending points The coordinates of the i th vertex of the polyline are i a i Flattening road is equivalent to choosing some line segment from 0 y 0 to n 1 y 1 such that all points of the polyline are below the chosen segment or on the same height Values y 0 and y 1 You can imagine that the road has some dips and pits and you start pouring pavement onto it until you make the road flat Points 0 and n 1 have infinitely high walls so pavement doesn t fall out of segment 0 n 1 The of flattening the road is equal to the area between the chosen segment and the polyline You want to minimize the cost that s why the flattened road is not necessary horizontal But there is a problem your data may be too old so you sent a person to measure new heights The person goes from 0 to n 1 and sends you new heights b i of each vertex i of the polyline Since measuring new heights may take a while and you don t know when you ll be asked calculate the minimum cost and corresponding y 0 and y 1 to flatten the road after each new height b i you get ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n#define int long long\n\nstruct Vector {\n    int x;\n    int y;\n\n    Vector(int x = 0, int y = 0): x(x), y(y) {}\n};\n\nVector operator-(const Vector& a, const Vector& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nint cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nconst int N = 2e5 + 100;\nconst double EPS = 1e-6;\nint a[N], b[N];\nVector pa[N], pb[N];\n\nint ltan[2][N], rtan[2][N];\n\ndouble out[N];\n\ndouble mid;\n\nvoid upd(double& ans, Vector a, Vector b) {\n    if (a.x <= mid + EPS && b.x >= mid - EPS) {\n        ans = max(ans, (a.y * (b.x - mid) + b.y * (mid - a.x)) / (b.x - a.x));\n    }\n}\n\nint st[N];\n\nvoid solve(int l, int r, double ans) {\n    if (r - l == 1) {\n        upd(ans, pb[ltan[1][l]], pb[l]);\n        upd(ans, pb[l], pa[rtan[1][l]]);\n        out[l] = ans;\n        return;\n    }\n    int m = (l + r) / 2;\n    int sz = 0;\n    for (int i = m; i < r; ++i) {\n        while (sz >= 2 && cross(pa[st[sz - 1]] - pa[st[sz - 2]], pa[i] - pa[st[sz - 1]]) >= 0) {\n            --sz;\n        }\n        st[sz++] = i;\n    }\n    double ansl = ans;\n    for (int i = m; i < r; ++i) {\n        upd(ansl, pb[ltan[0][i]], pa[i]);\n        upd(ansl, pa[i], pa[rtan[0][i]]);\n    }\n    double ansr = ans;\n    for (int i = l; i < m; ++i) {\n        upd(ansr, pb[ltan[1][i]], pb[i]);\n        upd(ansr, pb[i], pa[rtan[1][i]]);\n    }\n    for (int i = 1; i < sz; ++i) {\n        upd(ansl, pa[st[i - 1]], pa[st[i]]);\n    }\n    int start_k = 0;\n    while ((1 << start_k) < sz) ++start_k;\n    for (int i = l; i < m; ++i) {\n        if (i > mid + EPS) continue;\n        int id = 0;\n        for (int k = start_k; k >= 0; --k) {\n            int id1 = id + (1 << k);\n            int id2 = id - (1 << k);\n            while (id1 >= sz) id1 -= sz;\n            while (id2 < 0) id2 += sz;\n            if (cross(pa[st[id1]] - pa[i], pa[st[id]] - pa[i]) < 0) {\n                id = id1;\n            }\n            if (cross(pa[st[id2]] - pa[i], pa[st[id]] - pa[i]) < 0) {\n                id = id2;\n            }\n        }\n        if (cross(pa[st[id]] - pa[i], pa[rtan[0][i]] - pa[i]) < 0) {\n            rtan[0][i] = st[id];\n        }\n    }\n    for (int i = l; i < m; ++i) {\n        if (i > mid + EPS) continue;\n        int id = 0;\n        for (int k = start_k; k >= 0; --k) {\n            int id1 = id + (1 << k);\n            int id2 = id - (1 << k);\n            while (id1 >= sz) id1 -= sz;\n            while (id2 < 0) id2 += sz;\n            if (cross(pa[st[id1]] - pb[i], pa[st[id]] - pb[i]) < 0) {\n                id = id1;\n            }\n            if (cross(pa[st[id2]] - pb[i], pa[st[id]] - pb[i]) < 0) {\n                id = id2;\n            }\n        }\n        if (cross(pa[st[id]] - pb[i], pa[rtan[1][i]] - pb[i]) < 0) {\n            rtan[1][i] = st[id];\n        }\n    }\n\n    sz = 0;\n    for (int i = l; i < m; ++i) {\n        while (sz >= 2 && cross(pb[st[sz - 1]] - pb[st[sz - 2]], pb[i] - pb[st[sz - 1]]) >= 0) {\n            --sz;\n        }\n        st[sz++] = i;\n    }\n    for (int i = 1; i < sz; ++i) {\n        upd(ansr, pb[st[i - 1]], pb[st[i]]);\n    }\n    start_k = 0;\n    while ((1 << start_k) < sz) ++start_k;\n    for (int i = m; i < r; ++i) {\n        if (i < mid - EPS) continue;\n        int id = 0;\n        for (int k = start_k; k >= 0; --k) {\n            int id1 = id + (1 << k);\n            int id2 = id - (1 << k);\n            while (id1 >= sz) id1 -= sz;\n            while (id2 < 0) id2 += sz;\n            if (cross(pb[st[id1]] - pa[i], pb[st[id]] - pa[i]) > 0) {\n                id = id1;\n            }\n            if (cross(pb[st[id2]] - pa[i], pb[st[id]] - pa[i]) > 0) {\n                id = id2;\n            }\n        }\n        if (cross(pb[st[id]] - pa[i], pb[ltan[0][i]] - pa[i]) > 0) {\n            ltan[0][i] = st[id];\n        }\n    }\n    for (int i = m; i < r; ++i) {\n        if (i < mid - EPS) continue;\n        int id = 0;\n        for (int k = start_k; k >= 0; --k) {\n            int id1 = id + (1 << k);\n            int id2 = id - (1 << k);\n            while (id1 >= sz) id1 -= sz;\n            while (id2 < 0) id2 += sz;\n            if (cross(pb[st[id1]] - pb[i], pb[st[id]] - pb[i]) > 0) {\n                id = id1;\n            }\n            if (cross(pb[st[id2]] - pb[i], pb[st[id]] - pb[i]) > 0) {\n                id = id2;\n            }\n        }\n        if (cross(pb[st[id]] - pb[i], pb[ltan[1][i]] - pb[i]) > 0) {\n            ltan[1][i] = st[id];\n        }\n    }\n\n    solve(l, m, ansl);\n    solve(m, r, ansr);\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        pa[i] = {i, a[i]};\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n        pb[i] = {i, b[i]};\n    }\n    for (int i = 0; i < n; ++i) {\n        ltan[0][i] = ltan[1][i] = 0;\n        rtan[0][i] = rtan[1][i] = n - 1;\n    }\n    mid = (double)(n - 1) / 2;\n    solve(0, n, 0);\n    for (int i = 0; i < n; ++i) {\n        cout << out[i] * 2 << "" "";\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(20);\n    int uwu = 1;\n    /// cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']",,,"['binary search', 'geometry', 'two pointers']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Landscaping.json,https://codeforces.com//blog/entry/122645,Let s say that we are searching for the best line that contains the best segment Observation the best line touches at least one vertex of the polyline Otherwise you can push it down until it touches polyline Observation the best line touches two vertices of the polyline Suppose it touches only one vertex then it s not hard to prove that rotating the line around point either clockwise or counterclockwise will decrease the area under the line Observation if both points are on the left half then rotating the line clockwise around point will decrease the area Analogically if both points are on the right half then rotating the line counterclockwise around will decrease the area Observation since all points of the polyline should be under the line then the vertices the line touches are the consecutive vertices on the convex hull of the polyline In total we understand that the pair of points we need a segment of the convex hull that crosses a vertical line Knowing that what can we do Let s split all vertices in two halves left half with all vertices to the left of and right half with all vertices to the right Note that while we process the first half of queries the right half vertices in remains the same If we know how to process the first half of queries then processing the second half is practically the same thing but in the reverse order So how to find that best segment of the convex hull that crosses efficiently while we work with the left half of vertices Note that if we look at all segments that connect vertex from the left part with vertex from the right part each segment will certainly cross in some real point the segment of the convex hull will have maximum possible otherwise it s not a convex hull segment There are around segment that crosses but we don t need all of them Let s calculate for each vertex both the old and new values the segment that crosses and has maximum possible Note that this maximum possible segment connects with some vertex that on the convex hull that was built on the right half otherwise we will find convex hull point with higher slope and its will be bigger In other words for each point from the left we are searching a to the convex hull on the right And we can do it efficiently with binary search while checking some cross products Let s name that tangent line as where is a point from the left half One more observation You can prove it by looking at the area of trapezoid that formed by segment So let s define a function that takes line and returns or the answer to the task We have all we need to calculate the answer the answer to the th query is equal to the maximum among for all and for all In total the solution is next build convex hull on vertices calculate with binary search for all calculate for all and store suffix maximums among these values calculate with binary search for all calculate for all and store prefix maximums among these values calculate the th answer as maximum between the th prefix maximum and the th suffix maximum In order to solve the task for the right half just reverse arrays and and swap them and do the same algorithm above It s true because replacing first values with in array is equivalent to replacing last values with in array Complexity of the solution is because of binary searches Note that we can do everything in integers except calculating the values of function and taking maximum among 
https://codeforces.com//contest/216/problem/B,1598,B,216B,216,B. Forming Teams,One day students come to the stadium They want to play football and for that they need to split into teams the teams must have an equal number of people We know that this group of people has archenemies Each student has at most two archenemies Besides if student is an archenemy to student then student is an archenemy to student The students want to split so as no two archenemies were in one team If splitting in the required manner is impossible some students will have to sit on the bench Determine the minimum number of students you will have to send to the bench in order to form the two teams in the described manner and begin the game at last ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\nint a[200][200];\nint used[200];\n\nint main()\n{\n  int i,j,k,m,n,x,y,t,tt,ans;\n  vector<int> q;\n  scanf(""%d%d"",&n,&m);\n  memset(a,0,sizeof(a));\n  for (i=0;i<m;i++)\n  {\n    scanf(""%d%d"",&x,&y);\n    x--;y--;\n    a[x][y]=1;\n    a[y][x]=1;\n  }\n  memset(used,0,sizeof(used));\n  ans=0;\n  for (i=0;i<n;i++)\n    if (used[i]==0)\n    {\n      t=1;\n      tt=0;\n      used[i]=1;\n      q.clear();\n      q.push_back(i);\n      for (j=0;j<q.size();j++)\n        for (k=0;k<n;k++)\n          if (a[q[j]][k]==1)\n          {\n            tt++;\n            if (used[k]==0)\n            {\n              used[k]=1;\n              t++;\n              q.push_back(k);\n            }\n          }\n      tt/=2;\n      if ((t==tt)&&(t%2!=0)) ans++;\n    }\n  if ((n-ans)%2!=0) ans++;\n  printf(""%d\\n"",ans);\n}\n']",,,"['dfs and similar', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Forming Teams.json,https://codeforces.com//blog/entry/5066,You can build some graph where vertices are students and edges are enmities You should drop some vertices and then paint them in two colors Any edge should connect vertices of distinct colors and numbers of vertices of every color should be same You can see that graph consists chians cycles and sepatated vertices Every of that component can be painted in 2 colors except one case cycles of odd length So you should drop one vertex from every odd cycle After that you can get odd number of vertices Then you should drop one more vertex you can chose any of them The obtained graph can be easily painted in 2 colors in the required manner 
https://codeforces.com//contest/1671/problem/A,1376215,A,1671A,1671,A. String Building,You are given a string s You have to determine whether it is possible to build the string s out of strings and or by concatenating them You can use the strings and or any number of times and in any order For example can be built as can be built as can be built as cannot be built from and or ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:35:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string s;\n    cin >> s;\n    bool ok = true;\n    for (int i = 0; i < (int) s.size(); i++) {\n      bool good = false;\n      if (i > 0 && s[i] == s[i - 1]) good = true;\n      if (i < (int) s.size() - 1 && s[i] == s[i + 1]) good = true;\n      ok &= good;\n    }\n    cout << (ok ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. String Building.json,https://codeforces.com//blog/entry/102181,Every character in strings and has at least one character adjacent to it that is the same So if there is an isolated character in our string a character that has no neighbors equal to it we cannot build it It s easy to see that in the other case we can build the string we can split it into blocks of consecutive equal characters and since there are no isolated characters each block will have at least characters so it can be formed from strings of length and or consisting of equal characters So the problem is reduced to checking if each character has a neighbor equal to it 
https://codeforces.com//contest/261/problem/D,2514,D,261D,261,D. Maxim and Increasing Subsequence,Maxim loves sequences especially those that strictly increase He is wondering what is the length of the longest increasing subsequence of the given sequence Sequence is given as follows the length of the sequence equals where operation means taking the remainder after dividing number by number Sequence of length is a of sequence if there is such increasing sequence of indexes that In other words the subsequence can be obtained from the sequence by crossing out some elements Sequence is if the following inequality holds Maxim have variants of the sequence Help Maxim to determine for each sequence the length of the longest increasing subsequence ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <queue>\n#include <memory.h>\n#include <stack>\n#define mp make_pair\n#define pb push_back                     \n#define setval(a,v) memset(a,v,sizeof(a))\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 110000;\n\nint n,t;\n\nint b[MAXN];\npair<int,int> _b[MAXN];\n\nint ans[MAXN];\nint ptr[MAXN];\n\n\nvoid solve(){\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(""%d"",&_b[i].first);\n\t\t_b[i].second = i;\n\t}\n\tsort(_b,_b+n);\n\tint maxc = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (i && _b[i].first != _b[i-1].first) maxc++;\n\t\tb[_b[i].second] = maxc;\n\t}\n\tmaxc++;\n\n\tmemset(ans,0x3f,sizeof(ans));\n\tmemset(ptr,0,sizeof(ptr));\n\n\tint tmp;\n\tfor (int i = 0; i < t && i < maxc; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\ttmp = b[j];\n\t\t\twhile (ans[ptr[tmp]] < tmp)\n\t\t\t\tptr[tmp]++;\n\t\t\tans[ptr[tmp]] = tmp;\n\t\t}\n\t}\n\n\tcout << *max_element(ptr,ptr+maxc) + 1 << endl;\n}\n\n\nint main(){\n  #ifdef LOCAL\n    freopen(""input.txt"",""r"",stdin);\n    freopen(""output.txt"",""w"",stdout);\n  #endif\n\n  int tests;\n  scanf(""%d %d %*d %d"",&tests,&n,&t);\n\n  for (int i = 0; i < tests; i++)\n  \tsolve();\n  \t      \n  return 0;\n}']",,,['dp'],2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Maxim and Increasing Subsequence.json,https://codeforces.com//blog/entry/6398,This problem can be done using dp i j where we can end our increasing sequence with length i and last number j Its not hard to understand that number of states will be n b To make a tranfer we need to know array first j first position of the number j in the sequence b next i j first position of the number j in the sequence b after position i Now its easy to calculate all values 
https://codeforces.com//contest/845/problem/A,119171,A,845A,845,A. Chess Tourney,Berland annual chess tournament is coming Organizers have gathered chess players who should be divided into two teams with people each The first team is sponsored by BerOil and the second team is sponsored by BerMobile Obviously organizers should guarantee the win for the team of BerOil Thus organizers should divide all players into two teams with people each in such a way that the first team always wins Every chess player has its rating It is known that chess player with the greater rating always wins the player with the lower rating If their ratings are equal then any of the players can win After teams assignment there will come a drawing to form pairs of opponents in each pair there is a player from the first team and a player from the second team Every chess player should be in exactly one pair Every pair plays once The drawing is totally random Is it possible to divide all players into two teams with people each so that the player from the first team in every pair wins of the results of the drawing ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint a[205];\nint main()\n{\n    int n;\n    scanf(""%d"",&n);\n    for(int i=1;i<=2*n;i++)\n        scanf(""%d"",&a[i]);\n    sort(a+1,a+2*n+1);\n    return 0*printf(""%s\\n"",(a[n]==a[n+1] ? ""NO"" : ""YES""));\n}\n']",,,"['implementation', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Chess Tourney.json,https://codeforces.com//blog/entry/53986,Let s sort the input array in non decreasing order Now we should take the first players to the first team and the last players to the second team That will guarantee that every member of the first team has greater or equal rating than every member of the second team Now the only thing left is to check if all ratings in the first teams differ from all the ratings in the second team if some are equal then in sorted order 
https://codeforces.com//contest/1674/problem/E,1387201,E,1674E,1674,E. Breaking the Wall,Monocarp plays Rage of Empires II Definitive Edition a strategic computer game Right now he s planning to attack his opponent in the game but Monocarp s forces cannot enter the opponent s territory since the opponent has built a wall The wall consists of n sections aligned in a row The i th section initially has durability a i If durability of some section becomes 0 or less this section is considered broken To attack the opponent Monocarp needs to break at least two sections of the wall any two sections possibly adjacent possibly not To do this he plans to use an onager a special siege weapon The onager can be used to shoot any section of the wall the shot deals 2 damage to the target section and 1 damage to adjacent sections In other words if the onager shoots at the section x then the durability of the section x decreases by 2 and the durability of the sections x 1 and x 1 if they exist decreases by 1 each Monocarp can shoot at any sections any number of times Monocarp wants to calculate the minimum number of onager shots needed to break at least two sections Help him ,"['#include ""bits/stdc++.h""\n \nusing namespace std;\n \nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n \n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n \n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n \n#define pb                          push_back\n \n#define pry                         puts(""YES"")\n#define prn                         puts(""NO"")\n#define endl                        \'\\n\'\n \n#define fst                         first\n#define scn                         second\n \n#define int long long\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<int>a(n);\n    forn(i,n)cin>>a[i];\n    vector<int>b=a;\n    sort(all(b));\n    int ans = (b[0]+1)/2+(b[1]+1)/2;\n\n    for(int i=0;i+1<n;i++){\n        int x=a[i],y=a[i+1];\n        if(x>y)swap(x,y);\n        if(y>=2*x){\n            ans=min(ans,(y+1)/2);\n            continue;\n        }\n        int pp = y-x;\n        y-=pp*2;\n        x-=pp;\n        int now = pp+x/3*2+x%3;\n        ans=min(ans,now);\n    }\n    for(int i=0;i+2<n;++i){\n        int x=a[i],y=a[i+2];\n        if(x>y)swap(x,y);\n        int now=x/2+y/2;\n        x%=2,y%=2;\n        if(x || y) ++now;\n        ans=min(ans,now);\n    }\n    cout<<ans<<endl;\n}\n \nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while(t--)\n        solve();\n}']",,,"['binary search', 'brute force', 'constructive algorithms', 'greedy', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Breaking the Wall.json,https://codeforces.com//blog/entry/102482,Let s analyze three cases based on the distance between two sections we are going to break break two neighboring sections and break two sections with another section between them and break two sections with more than one section between them Why exactly these cases Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them If there is more than one section between the two we want to break then any shot hits only one of these sections so each shot should be aimed at one of those sections and we break them independently Let s pick two sections with minimum durability and calculate the number of shots required to break them if these sections are and then the required number of shots is It actually does not matter if the distance between them is less than if it is so these sections will be analyzed in one of the other cases Okay now let s deal with two sections having exactly one section between them We can iterate on all combinations of these sections iterate on from to and pick sections and Let s analyze how can we damage them If we shoot at the section between them we deal damage to both sections if we shoot at one of those sections we deal damage to it and damage to the other section So each shot distributes damage between these two sections the way we want to distribute it and the number of shots required to break these two sections is The case when we try to break two adjacent sections is the trickiest one Let s say that these sections are and and If we target one of these sections we deal damage to it and damage to the other section Let s try to run the following algorithm shoot at the section with higher durability until both of them break It can be slow but we can see that after the first shots the durabilities of the sections become equal and each pair of shots after that deals damage to both sections So we can model the first shots subtract from and from and then we ll need shots The only case when this doesn t work is if we break both sections before we equalize their durabilities it means that and we need to do only shots 
https://codeforces.com//contest/349/problem/B,3547,B,349B,349,B. Color the Fence,Igor has fallen in love with Tanya Now Igor wants to show his feelings and write a number on the fence opposite to Tanya s house Igor thinks that the larger the number is the more chance to win Tanya s heart he has Unfortunately Igor could only get liters of paint He did the math and concluded that digit requires liters of paint Besides Igor heard that Tanya doesn t like zeroes That s why Igor won t use them in his number Help Igor find the maximum number he can write on the fence ,"['#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <math.h>\n\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\ntemplate<typename T>inline string to_str(const T& v) {\n    ostringstream os; os << v; return os.str();\n}\ntemplate<typename T>inline T to_obj(const string& v) {\n    istringstream is(v); T r; is>>r; return r;\n}\ntemplate<class T>inline int cMin(T& a, T b) {return b<a ? a=b,1 : 0;}\ntemplate<class T>inline int cMax(T& a, T b) {return a<b ? a=b,1 : 0;}\n\n#define CLR(A,v) memset(A, v, sizeof(A))\n#define MP(a,b)  make_pair(a, b)\n#define F0(i, n) for(int i=0; i<(n); ++i)\n#define F1(i, n) for(int i=1; i<=(n); ++i)\n\n\nint A[16] = {0};\n\nint main(int argc, char *argv[]) {\n    int v;\n    scanf(""%d"", &v);\n\n    F1(i, 9) scanf(""%d"", A+i);\n    int g = A[1];\n    int idx = 1;\n    F1(i, 9) {\n        if(A[i] <= g) {\n            g = A[i];\n            idx = i;\n        }\n    }\n    int n = v / g;\n    if(n == 0) {\n        puts(""-1"");\n        return 0;\n    }\n    for(; n>0; --n) {\n        int rem = v - g*n;\n        int cur = g + rem;\n        int h = idx;\n        F1(i, 9) {\n            if(cur >= A[i]) h = i;\n        }\n        printf(""%d"", h);\n        v -= A[h];\n    }\n    printf(""\\n"");\n    return 0;\n}\n']",,,"['data structures', 'dp', 'greedy', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Color the Fence.json,https://codeforces.com//blog/entry/9031,In the problem you re asked to write the largest possible number given number of paint that you have and number of paint that you need to write each digit Longer number means larger number so it s worth to write the longest possible number Because of that we choose the largest digit among those that require the least number of paint Let the number of paint for that digit be equal to and we have liters of paint total Then we can write number of the length Now we know the length of the number let it be Write down temporary result string of length consisting of digits We have supply of liters of paint In order to enhance the answer we can try to update the number from the beginning and swap each digit with the maximal possible It s true because numbers of the equal length are compared in the highest digits first Among digits that are greater than current we choose one that we have enough paint for and then update answer and current number of paint If the length of the answer is 0 then you need to output 1 
https://codeforces.com//contest/610/problem/D,44289,D,610D,610,D. Vika and Segments,Vika has an infinite sheet of squared paper Initially all squares are white She introduced a two dimensional coordinate system on this sheet and drew black horizontal and vertical segments parallel to the coordinate axes All segments have width equal to square that means every segment occupy some set of neighbouring squares situated in one row or one column Your task is to calculate the number of painted cells If a cell was painted more than once it should be calculated exactly once ,"[""#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\nint n;\nstruct seg{\n    int x1,y1,x2,y2;\n}s[111111];\nseg v[111111],h[111111];\nseg vn[111111];int ntot=0;\nint vtot=0,htot=0;\nint cmpx(const seg&a,const seg&b){\n    if(a.x1==b.x1)return a.y1<b.y1;\n    return a.x1<b.x1;\n}\nint cmpy(const seg&a,const seg&b){\n    if(a.y1==b.y1)return a.x1<b.x1;\n    return a.y1<b.y1;\n}\n\nstruct node{\n    int x,y,sg;\n}tt[222222];int ttot=0;\n\n\n\nint cmpnode(const node&a,const node&b){\n    return a.x<b.x;\n}\nstruct nnode{int ch[2],sz,v,fix;}t[1000005];int ndtot=0;\nint root=0;\nvoid rot(int &x,int f){\n    int y=t[x].ch[!f];\n    t[x].ch[!f]=t[y].ch[f];\n    t[y].ch[f]=x;\n    t[y].sz=t[x].sz;\n    t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz+1;\n    x=y;\n}\nvoid ins(int &x,int v){\n    if(x==0){\n        x=++ndtot;\n        t[x].ch[0]=t[x].ch[1]=0;\n        t[x].sz=1;\n        t[x].fix=rand();\n        t[x].v=v;\n    }else{\n        int f=v>=t[x].v;\n        ins(t[x].ch[f],v);\n        t[x].sz++;\n        if(t[t[x].ch[f]].fix<t[x].fix)rot(x,!f);\n    }\n}\nvoid del(int &x){\n    if(!t[x].ch[0] && !t[x].ch[1])x=0;\n    else{\n        int f=!t[x].ch[0] || t[x].ch[1]&&t[t[x].ch[1]].fix<t[t[x].ch[0]].fix;\n        rot(x,!f);\n        t[x].sz--;\n        del(t[x].ch[!f]);\n    }\n}\nvoid del_num(int &x,int v){\n    if(t[x].v==v)del(x);\n    else{\n        int f=v>=t[x].v;\n        t[x].sz--;\n        del_num(t[x].ch[f],v);\n    }\n}\nint rk(int v){\n    int x=root;int ans=0;\n    while(x){\n        if(t[x].v>=v)x=t[x].ch[0];\n        else{\n            ans+=t[t[x].ch[0]].sz+1;\n            x=t[x].ch[1];\n        }\n    }\n    return ans+1;\n}\nint main()\n{\n    gn(n);\n    for (int i=1;i<=n;i++){\n        gn(s[i].x1);\n        gn(s[i].y1);\n        gn(s[i].x2);\n        gn(s[i].y2);\n        if(s[i].x1>s[i].x2)swap(s[i].x1,s[i].x2);\n        if(s[i].y1>s[i].y2)swap(s[i].y1,s[i].y2);\n        if(s[i].x1==s[i].x2){\n            v[++vtot]=s[i];\n        }else h[++htot]=s[i];\n    }\n    sort(h+1,h+1+htot,cmpy);\n\n    ll sum=0;\n    for (int i=1,j;i<=htot;i=j){\n        for (j=i;j<=htot && h[j].y1==h[i].y1;j++);\n\n        int far=-inf;\n        for (int k=i;k<j;k++){\n            if(h[k].x1>far){\n                if(far!=-inf)tt[++ttot]=(node){far+1,h[i].y1,-1};\n                tt[++ttot]=(node){h[k].x1,h[i].y1,+1};\n                far=max(far,h[k].x2);\n            }else{\n                far=max(far,h[k].x2);\n            }\n        }\n        tt[++ttot]=(node){far+1,h[i].y1,-1};\n    }\n    for (int i=1;i<=ttot;i++)sum-=tt[i].x*tt[i].sg;\n\n    sort(tt+1,tt+1+ttot,cmpnode);\n\n    sort(v+1,v+1+vtot,cmpx);\n\n    for (int i=1,j;i<=vtot;i=j){\n        for (j=i;j<=vtot && v[j].x1==v[i].x1;j++);\n\n        int far=-inf,st=-inf;\n        for (int k=i;k<j;k++){\n            if(v[k].y1>far){\n                if(far!=-inf)vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n                st=v[k].y1;\n                far=max(far,v[k].y2);\n            }else{\n                far=max(far,v[k].y2);\n            }\n        }\n        vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n    }\n\n    sort(vn+1,vn+1+ntot,cmpx);\n\n    int cur=1;\n    for (int i=1;i<=ntot;i++){\n        while(cur<=ttot && tt[cur].x<=vn[i].x1){\n            if(tt[cur].sg==1){\n                ins(root,tt[cur].y);\n            }else{\n                del_num(root,tt[cur].y);\n            }\n            cur++;\n        }\n        int coin = rk(vn[i].y2+1)-rk(vn[i].y1);\n        sum+=vn[i].y2-vn[i].y1+1 - coin;\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n""]",,,"['constructive algorithms', 'data structures', 'geometry', 'two pointers']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Vika and Segments.json,https://codeforces.com//blog/entry/22341,At first let s unite all segments which are in same verticals or horizontals Now the answer to the problem is the sum of lengths of all segments subtract the number of intersections Let s count the number of intersections For this let s use the horizontal scan line from the top to the bottom is can be done with help of events vertical segment is open vertical segment is close and hadle horizontal segment and in some data structure store the set of x coordinates of the open segments For example we can use Fenwick tree with precompression of the coordinates Now for current horizontal segment we need to take the number of the opened vertical segmetns with value x in the range x1 x2 where x vertical where the vertical segment are locating and x1 x2 the x coordinates of the current horizontal segment 
https://codeforces.com//contest/1669/problem/G,1375144,G,1669G,1669,G. Fall Down,There is a grid with n rows and m columns and three types of cells An empty cell denoted with A stone denoted with An obstacle denoted with the lowercase Latin letter All stones fall down until they meet the floor the bottom row an obstacle or other stone which is already immovable In other words all the stones just fall down as long as they can fall Simulate the process What does the resulting grid look like ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n, m;\n  cin >> n >> m;\n  char c[n][m];\n  rep(i, n) rep(j, m) cin >> c[i][j];\n  for(int i = n - 1; i >= 0; --i){\n    for(int j = 0; j < m; ++j){\n      if(c[i][j] == \'.\'){\n        int k = i - 1;\n        while(k >= 0 and c[k][j] == \'.\') k--;\n        if(k < 0 || c[k][j] == \'o\') continue;\n        else{\n          c[k][j] = \'.\';\n          c[i][j] = \'*\';\n        }\n      }\n    }\n  }\n  rep(i, n){\n    rep(j, m) cout << c[i][j];\n    cout << \'\\n\';\n  }\n}\n\n\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << ""Case #"" << i << "": "";\n      solve();\n    }\n    return 0;\n}   ']",,,"['dfs and similar', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\G. Fall Down.json,https://codeforces.com//blog/entry/102101,Note that the columns don t affect each other so we can solve for each column by itself For each column go from the bottom to the top and keep track of the row of the last obstacle seen call it Note that initially since we treat the floor as the th row of obstacles Whenever we see a new obstacle we should update Now if we ever see a stone we should move it to row since it will be one row above the last obstacle seen it will fall on top of it Afterwards we should also decrease by because if any future stones fall on top of it they will land on the row above this stone This solution works in We also accepted slower solutions that run in that simulate each stone falling 
https://codeforces.com//contest/860/problem/E,122868,E,860E,860,E. Arkady and a Nobody-men,Arkady words in a large company There are employees working in a system of a strict hierarchy Namely each employee with an exception of the CEO has exactly one immediate manager The CEO is a manager through a chain of immediate managers of all employees Each employee has an integer rank The CEO has rank equal to each other employee has rank equal to the rank of his immediate manager plus Arkady has a good post in the company however he feels that he is nobody in the company s structure and there are a lot of people who can replace him He introduced the value of Consider an employee and an employee the latter being manager of not necessarily immediate Then the replaceability of with respect to is the number of subordinates not necessarily immediate of the manager whose rank is not greater than the rank of Apart from replaceability Arkady introduced the value of The negligibility of employee equals the sum of his replaceabilities with respect to all his managers i e where the sum is taken over all his managers Arkady is interested not only in negligibility of himself but also in negligibility of all employees in the company Find the negligibility of each employee for Arkady ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[20][505050],D[505050];\nll ret[505050];\nvector<int> E[505050];\n\nvector<int> ev[505050];\n\nint lca(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn (aa==bb)?aa:P[0][aa];               // vertex\n}\n\nvoid dfs(int cur,int dep) {\n\tD[cur]=dep;\n\tev[D[cur]].push_back(cur);\n\tFORR(e,E[cur]) dfs(e,dep+1);\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tscanf(""%d"",&N);\n\t\n\tint root=-1;\n\tFOR(i,N) {\n\t\tscanf(""%d"",&P[0][i+1]);\n\t\tif(P[0][i+1]==0) root=i+1, P[0][i+1]=root;\n\t\telse E[P[0][i+1]].push_back(i+1);\n\t}\n\t\n\tdfs(root,0);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\t\n\tfor(i=1;i<=N;i++) if(ev[i].size()) {\n\t\tFORR(e,ev[i]) ret[e]=ret[P[0][e]]+D[e];\n\t\tFOR(j,2) {\n\t\t\tvector<vector<int>> V;\n\t\t\tll sum=0;\n\t\t\tFOR(x,ev[i].size()) {\n\t\t\t\tint e=ev[i][x];\n\t\t\t\tif(x==0) {\n\t\t\t\t\tV.push_back({e,-1,0});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(1) {\n\t\t\t\t\t\tint cand=V.back()[0];\n\t\t\t\t\t\tint lc=lca(cand,e);\n\t\t\t\t\t\tif(V.back()[1]<D[lc]) {\n\t\t\t\t\t\t\tV.push_back({e,D[lc],x});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum-=1LL*(V[V.size()-1][2]-V[V.size()-2][2])*(V[V.size()-1][1]+1);\n\t\t\t\t\t\tV.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tsum+=1LL*(V[V.size()-1][2]-V[V.size()-2][2])*(V[V.size()-1][1]+1);\n\t\t\t\t\tret[e]+=sum;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treverse(ALL(ev[i]));\n\t\t}\n\t}\n\t\n\tFOR(i,N) printf(""%"" PRIu64 ""%c"", ret[i+1],(i==N-1)?\'\\n\':\' \');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']",,,"['data structures', 'dfs and similar', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Arkady and a Nobody-men.json,https://codeforces.com//blog/entry/54604,First of all where is the sum of number of descendants of the rank depth v for all predecessors of All we need is to compute now Let s make a dfs in the graph Let the dfs v return a vector such that is the following tuple number of vertices on depth in subtree of some vertex with depth in the subtree of the if we consider only predecessors in the subtree of Also let s build some structure so that we can easily restore answers in this subtree if we know the final value of We will see what is this structure later To compute we need to be able to merge two s of its sons Let s say we merge tuple with Then all we need to do is return as the result However we must also be able to restore after the dfs is complete remind the unknown structure So after performing let s add an edge to a new graph with weight Note that the difference between these values will be the same all the time after the tuples are merged so using this edge we will be able to restore the answer After the dfs is done run another dfs on the new graph to restore the values and then To perform the second step fast we need to note that we can always merge smaller s into larger and move them in into parents Since each tuple is merged into a larger vector only once this solution works in total in 
https://codeforces.com//contest/2019/problem/A,2905353,A,2019A,2019,A. Max Plus Size,You are given an array a 1 a 2 ldots a n of positive integers You can color some elements of the array red but there cannot be two adjacent red elements i e for 1 leq i leq n 1 at least one of a i and a i 1 must not be red Your score is the maximum value of a red element plus the number of red elements Find the maximum score you can get ,"['#include<bits/stdc++.h>using namespace std;const int N=110;int T,n,a[110];int calc(int x){\tif(x<=0)return 0;\treturn (x+1)/2;}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n;\t\tfor(int i=1;i<=n;i++)\t\t\tcin>>a[i];\t\tint ans=0;\t\tfor(int i=1;i<=n;i++){\t\t\tans=max(ans,a[i]+calc(i-2)+calc(n-i-1));\t\t}\t\tcout<<ans+1<<""\\n"";\t}\treturn 0;}']",,,"['brute force', 'dp', 'greedy']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Max Plus Size.json,https://codeforces.com//blog/entry/134420,SolutionThe maximum red element is and the maximum number of red elements is Can you reach the score If is even you always can by either choosing all the elements in even positions or all the elements in odd positions at least one of these choices contains If is odd you can if and only if there is one occurrence of in an odd position Otherwise you can choose even positions and your score is Complexity 
https://codeforces.com//contest/1282/problem/E,502550,E,1282E,1282,E. The Cake Is a Lie,It is known that the cake was originally a regular n sided polygon each vertex of which had a unique number from 1 to n The vertices were numbered in random order Each piece of the cake is a triangle The cake was cut into n 2 pieces as follows each time one cut was made with a knife from one vertex to another such that exactly one triangular piece was separated from the current cake and the rest continued to be a convex polygon In other words each time three consecutive vertices of the polygon were selected and the corresponding triangle was cut off A possible process of cutting the cake is presented in the picture below You are given a set of n 2 triangular pieces in random order The vertices of each piece are given in random order clockwise or counterclockwise Each piece is defined by three numbers the numbers of the corresponding n sided cake vertices For example for the situation in the picture above you could be given a set of pieces 3 6 5 5 2 4 5 4 6 6 3 1 You are interested in two questions What was the enumeration of the n sided cake vertices In what order were the pieces cut Formally you have to find two permutations p 1 p 2 dots p n 1 le p i le n and q 1 q 2 dots q n 2 1 le q i le n 2 such that if the cake vertices are numbered with the numbers p 1 p 2 dots p n in order clockwise or counterclockwise then when cutting pieces of the cake in the order q 1 q 2 dots q n 2 always cuts off a triangular piece so that the remaining part forms one convex polygon For example in the picture above the answer permutations could be p 2 4 6 1 3 5 or any of its cyclic shifts or its reversal and after that any cyclic shift and q 2 4 1 3 Write a program that based on the given triangular pieces finds any suitable permutations p and q ,"['#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nset<pii> f;\nset<vector<ll> > g[205000];\nvector<ll> ff;\nvector<vector<ll> > ans;\nmap<vector<ll>, ll> num;\nvector<ll> ans1;\nll p[MAXN], nt[MAXN];\nvoid solve() {\n    f.clear();\n    num.clear();\n    ans.clear();\n    ans1.clear();\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        g[i].clear();\n    }\n    for (int i = 0; i < n - 2; i++) {\n        ll x;\n        ff.clear();\n        for (int j = 0; j < 3; j++) {\n            cin >> x;\n            ff.push_back(x);\n        }\n\n        sort(ff.begin(), ff.end());\n        num[ff] = i + 1;\n        for (int j = 0; j < 3; j++) {\n            g[ff[j]].insert(ff);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        f.insert(mp((ll)g[i].size(), i));\n    }\n    while (!f.empty()) {\n        auto it = f.begin();\n        if (it->X == 0) {\n            f.erase(it);\n            continue;\n        }\n        ll v = it->Y;\n        f.erase(it);\n        auto it2 = g[v].begin();\n        ff.clear();\n        for (auto x : *it2) {\n            ff.push_back(x);\n        }\n        for (auto x : ff) {\n            f.erase(mp((ll)g[x].size(), x));\n            g[x].erase(ff);\n            if (!g[x].empty()) {\n                f.insert(mp((ll)g[x].size(), x));\n            }\n        }\n        ans1.push_back(num[ff]);\n        for (int j = 0; j < 3; j++) {\n            if (ff[j] == v) {\n                swap(ff[j], ff[1]);\n                break;\n            }\n        }\n        ans.push_back(ff);\n    }\n    reverse(ans.begin(), ans.end());\n    for (int i = 1; i <= n; i++) {\n        p[i] = i;\n    }\n    p[ans[0][0]] = nt[ans[0][0]] = ans[0][2];\n    p[ans[0][2]] = nt[ans[0][2]] = ans[0][0];\n    for (int i = 0; i < n-2; i++) {\n        ll mid = ans[i][1];\n        ll l = ans[i][0];\n        ll r = ans[i][2];\n        if (nt[l] != r) {\n            swap(l, r);\n        }\n        nt[l] = mid;\n        nt[mid] = r;\n    }\n    ll x = 1;\n    do {\n        cout << x << "" "";\n        x = nt[x];\n    } while (x != 1);\n    cout << ""\\n"";\n    for (auto x : ans1) {\n        cout << x << "" "";\n    }\n    cout << ""\\n"";\n\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n\n    return 0;\n}']",,,"['constructive algorithms', 'data structures', 'dfs and similar', 'graphs']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The Cake Is a Lie.json,https://codeforces.com/blog/entry/72461?locale=en,The problem can be solved in different ways one can independently find both permutations or use one to find another Firstly let s find the order of cutting cake pieces Let s take a look at the edges of the first piece This triangle has a common side with no more than one other piece If it has no common sides with other triangles there is only one triangle the answer is trivial So we consider that the first triangle is adjacent to exactly one other triangle After cutting off this triangle we have a similar problem for a sided cake Let the first triangle be any triangle adjacent only to another triangle cut it off solve the problem recursively This can be done by building for the polygon dual graph The remaining problem is to find the permutation Let s use to find Reverse to get the order of adding triangles to obtain the desired polygon This can be done by adding to the doubly linked list a triangle vertex that wasn t in the list before between two existing ones Let s note that each side of the cake is found exactly once in the input the other edges are found twice So we have to find these sides of the polygon then we get a doubly linked list which represents 
https://codeforces.com//contest/1980/problem/E,2679077,E,1980E,1980,E. Permutation of Rows and Columns,You have been given a matrix a of size n by m containing a permutation of integers from 1 to n cdot m A permutation of n integers is an array containing all numbers from 1 to n exactly once For example the arrays 1 2 1 3 5 4 3 2 1 are permutations while the arrays 1 1 100 1 2 4 5 are not A matrix contains a permutation if when all its elements are written out the resulting array is a permutation Matrices 1 2 3 4 1 1 5 3 2 6 4 contain permutations while matrices 2 1 1 2 2 1 2 100 200 do not You can perform one of the following two actions in one operation choose columns c and d 1 le c d le m c ne d and swap these columns choose rows c and d 1 le c d le n c ne d and swap these rows You can perform any number of operations You are given the original matrix a and the matrix b Your task is to determine whether it is possible to transform matrix a into matrix b using the given operations ,"['#include <bits/stdc++.h>using namespace std;\xa0int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n, m; cin >> n >> m;        vector a(n, vector<int>(m)), b(n, vector<int>(m));        for (auto &v: a) for (int &x: v) cin >> x;        for (auto &v: b) for (int &x: v) cin >> x;        map<int, int> ai, aj;        map<int, vector<int>> imp, jmp;        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = a[i][j];                ai[x] = i, aj[x] = j;            }        }        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = b[i][j];                imp[ai[x]].push_back(i), jmp[aj[x]].push_back(j);            }        }        bool ans = true;        for (auto [_, v]: imp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        for (auto [_, v]: jmp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        cout << (ans ? ""YES"" : ""NO"") << ""\\n"";    }}']",,,"['constructive algorithms', 'data structures', 'greedy', 'hashing', 'implementation', 'math', 'matrices', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Permutation of Rows and Columns.json,https://codeforces.com//blog/entry/130135,For each element you can calculate its positions in both matrices You can see that the rearrangement of rows does not affect the column positions of the elements being rearranged Similarly column rearrangement does not affect row positions Since the permutation of rows affects the entire rows for all elements that have the same position row in the original matrix the position row in the resulting matrix must also match Similarly the columns must match In order to check the coincidence of rows and columns let s count 4 arrays the positions of rows and columns in the original and received matrices Then you need to check that for all with the same row value in the original matrix the row values in the resulting matrix are the same Similarly the values of the columns should be the same 
https://codeforces.com//contest/1133/problem/B,308945,B,1133B,1133,B. Preparation for International Women's Day,International Women s Day is coming soon Polycarp is preparing for the holiday There are n candy boxes in the shop for sale The i th box contains d i candies Polycarp wants to prepare the maximum number of gifts for k girls Each gift will consist of boxes The girls should be able to share each gift equally so the total amount of candies in a gift in a pair of boxes should be divisible by k In other words two boxes i and j i ne j can be combined as a gift if d i d j is divisible by k How many boxes will Polycarp be able to give Of course each box can be a part of no more than one gift Polycarp cannot use boxes partially or redistribute candies between them ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define INF 9223372036854775807\n#define M_PI 3.14159265358979323846\n\nint mod = INF;\n\nint fastPow(int b, int e){int r = 1;while(e){if(e%2 == 1){r*=b;r%=mod;}b*=b;b%=mod;e/=2;}return r;}\nint pgcd(int a, int b){ if(a%b == 0) return b; else return pgcd(b, a%b);}\nint sign(int a){if(a < 0){ return -1;}if(a == 0) {return 0;}return 1;}\nbool isPrime(int a){if(a == 1) {return false;}int f = sqrt(a);for(int i = 2; i<=f; i++){if(a%i == 0){return false;}}return true;}\nint toInt(string s){int tot = 0;for(int i = s.size()-1; i >= 0; i--){tot+=((s[i]-\'0\')%mod)*fastPow(10,i);tot%=mod;}return tot;}\nstring toString(int a){string s = """";while(a){s = (char)(\'0\'+a%10) + s;a/=10;}return s;}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, k;\n    cin >> n >> k;\n    vector<int> rem(101);\n    for(int i = 0; i < n; i++){\n        int a;\n        cin >> a;\n        rem[a%k]++;\n    }\n    int tot = 0;\n    for(int i = 0; i <= k/2; i++){\n        if(i != (k-i)%k)tot+=min(rem[i], rem[k-i]);\n        else tot+=rem[i]/2;\n    }\n    cout << tot*2 << endl;\n}\n']",,,"['math', 'number theory']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Preparation for International Women's Day.json,https://codeforces.com//blog/entry/65807,Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs 
https://codeforces.com//contest/687/problem/C,63912,C,687C,687,C. The Values You Can Make,Pari wants to buy an expensive chocolate from Arya She has coins the value of the th coin is The price of the chocolate is so Pari will take a subset of her coins with sum equal to and give it to Arya Looking at her coins a question came to her mind after giving the coins to Arya what values does Arya can make with them She is jealous and she doesn t want Arya to make a lot of values So she wants to know all the values such that Arya will be able to make using some subset of coins with the sum Formally Pari wants to know the values such that there exists a subset of coins with the sum such that some subset of this subset has the sum i e there is exists some way to pay for the chocolate such that Arya will be able to make the sum using these coins ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,m,x;\nbool dp[510][510],pd[510][510];\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\tdp[0][0]=1;\n\trep(i,0,n) {\n\t\tscanf(""%d"",&x);\n\t\trep(j,0,m+1) rep(k,0,m+1) pd[j][k]=dp[j][k],dp[j][k]=0;\n\t\trep(j,0,m+1) rep(k,0,m+1) {\n\t\t\tdp[j][k]|=pd[j][k];\n\t\t\tif (j+x<=m) dp[j+x][k]|=pd[j][k];\n\t\t\tif (k+x<=m) dp[j][k+x]|=pd[j][k];\n\t\t}\n\t}\n\tVI ret;\n\trep(j,0,m+1) if (dp[j][m-j]) ret.pb(j);\n\tprintf(""%d\\n"",SZ(ret));\n\tfor (auto p: ret) {\n\t\tprintf(""%d "",p);\n\t}\n\tputs("""");\n}\n']",,,['dp'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. The Values You Can Make.json,https://codeforces.com//blog/entry/45770,Hint Use dynamic programming Solution Let dpi j k be true if and only if there exists a subset of the first i coins with sum j that has a subset with sum k There are 3 cases to handle The i th coin is not used in the subsets The i th coin is used in the subset to make j but it s not used in the subset of this subset The i th coin is used in both subsets So dpi j k is equal to dpi 1 j k OR dpi 1 j ci k OR dpi 1 j ci k ci 
https://codeforces.com//contest/1660/problem/C,1349757,C,1660C,1660,C. Get an Even String,A string a a 1a 2 dots a n is called if it consists of a concatenation joining of strings of length 2 consisting of the same characters In other words a string a is even if two conditions are satisfied its length n is even for all odd i 1 le i le n 1 a i a i 1 is satisfied For example the following strings are even empty string and The following strings are not even and Given a string s consisting of lowercase Latin letters Find the minimum number of characters to remove from the string s to make it even The deleted characters do not have to be consecutive ,"[""#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  string s;\n  cin >> s;\n  vector<bool> used(26, false);\n  int ln = 0;\n  for (auto c : s) {\n    if (used[c - 'a']) {\n      ln++;\n      used.assign(26, false);\n    } else {\n      used[c - 'a'] = true;\n    }\n  }\n  cout << (int) s.size() - 2 * ln << '\\n';\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}""]",,,"['dp', 'greedy', 'strings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Get an Even String.json,https://codeforces.com//blog/entry/101526,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
https://codeforces.com//contest/1842/problem/E,1978969,E,1842E,1842,E. Tenzing and Triangle,There are n points and a line x y k on a two dimensional plane The i th point is at x i y i All points have non negative coordinates and are strictly below the line Alternatively 0 leq x i y i x i y i k Tenzing wants to erase all the points He can perform the following two operations Draw triangle Tenzing will choose two non negative integers a b that satisfy a b k then all points inside the triangle formed by lines x a y b and x y k will be erased It can be shown that this triangle is an isosceles right triangle Let the side lengths of the triangle be l l and sqrt 2 l respectively Then the cost of this operation is l cdot A The blue area of the following picture describes the triangle with a 1 b 1 with cost 1 cdot A Erase a specific point Tenzing will choose an integer i that satisfies 1 leq i leq n and erase the point i The cost of this operation is c i Help Tenzing find the minimum cost to erase all of the points ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:36:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    long long mx = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mx += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  long long A;\n  cin >> n >> k >> A;\n  vector<int> l(n), r(n);\n  vector<long long> cost(n);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y >> cost[i];\n    l[i] = x;\n    r[i] = k - y;\n    total += cost[i];\n  }\n  vector<vector<int>> at(k + 1);\n  for (int i = 0; i < n; i++) {\n    at[r[i]].push_back(i);\n  }\n  segtree st(k + 1);\n  long long dp = 0;\n  for (int i = 1; i <= k; i++) {\n    for (int id : at[i]) {\n      st.modify(0, l[id], +cost[id]);\n    }\n    dp = max(dp, -A * i + st.get(0, i - 1).mx);\n    st.modify(i, i, dp + A * i);\n  }\n  cout << total - dp << \'\\n\';\n  return 0;\n}\n']",,,"['data structures', 'dp', 'geometry', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Tenzing and Triangle.json,https://codeforces.com//blog/entry/117606,TutorialObserve that all triangles will be disjoint if two triangle were not disjoint we can merge them together to such that the cost used is less Therefore we can consider doing DP The oblique side of the triangle is a segment on the line Therefore we use the interval to represent the triangle with the upper left corner at and the lower right corner at First suppose that all points will generate costs After covering points with a triangle the costs can be reduced Let represent the sum of costs of points covered by triangle minus We need to find several intervals without common parts and maximize Let represent the maximum value of when considering the prefix There are two transitions If is not covered by any interval then If is covered by interval then Enumerate from small to large for maintain When will change as follows Subtract from For each point add the cost of the point to needs to support interval addition and global maximum value assuming that illegal positions are 0 which can be achieved using a segment tree Time complexity is 
https://codeforces.com//contest/1795/problem/F,1785702,F,1795F,1795,F. Blocking Chips,You are given a tree consisting of n vertices There are k chips placed in vertices a 1 a 2 dots a k All a i are distinct Vertices a 1 a 2 dots a k are colored black initially The remaining vertices are white You are going to play a game where you perform some moves possibly zero On the i th move 1 indexed you are going to move the i 1 bmod k 1 st chip from its current vertex to an adjacent vertex and color that vertex So if k 3 you move chip 1 on move 1 chip 2 on move 2 chip 3 on move 3 chip 1 on move 4 chip 2 on move 5 and so on If there is no adjacent white vertex then the game ends What s the maximum number of moves you can perform ,"['/**\n *    author:  tourist\n *    created: 16.02.2023 18:44:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> que(1, 0);\n    vector<int> pv(n, -1);\n    pv[0] = -2;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (pv[u] == -1) {\n          que.push_back(u);\n          pv[u] = que[b];\n        }\n      }\n    }\n    int k;\n    cin >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    int low = 0, high = n;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      vector<int> val(n, -1);\n      for (int i = 0; i < k; i++) {\n        val[a[i]] = mid / k + (i < mid % k);\n      }\n      bool ok = true;\n      vector<int> down(n, 0);\n      for (int it = n - 1; it >= 0; it--) {\n        int i = que[it];\n        if (val[i] >= 0) {\n          if (down[i] < val[i]) {\n            if (pv[i] < 0) {\n              ok = false;\n              break;\n            }\n            if (val[pv[i]] >= 0) {\n              ok = false;\n              break;\n            }\n            val[pv[i]] = val[i] - 1;\n          }\n        } else {\n          if (pv[i] >= 0) {\n            down[pv[i]] = max(down[pv[i]], down[i] + 1);\n          }\n        }\n      }\n      if (ok) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'dfs and similar', 'greedy', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Blocking Chips.json,https://codeforces.com//blog/entry/112963,The constraints tell us that the solution should be linear or pretty close to it Well in particular that implies that the solution almost certainly isn t dynamic programming since we have both and to care about Thus we ll think about something greedy When we know the number of move the game will last we can tell how many steps each chip should make Well since the more moves the game last the more steps each ship makes the answer is a monotonic function Let s apply binary search and think if we can check if each chip can make some known number of steps A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up Consider the bottommost chip If it can move its number of moves downwards it s always optimal to do that Since it s the bottommost chip it can only make things worse for chips above it And any of them can t pass through the initial vertex of this chip anyway If it can t it has to move to its parent vertex Let s move it there and deal with this chip later when it becomes the bottommost again If it can t move to its parent it can t move at all Thus the game can t last for this many steps Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced the greedy strategy is correct As for implementation details it s not too tricky Basically for each vertex we should maintain these values if this vertex has been visited the number of steps the chip in this vertex still has to make if any chip is in this vertex the longest path downwards from this vertex via non visited vertices The second value can be initialized beforehand and pushed to the parent when needed The rest of them are easily maintained with a single dfs Overall complexity per testcase 
https://codeforces.com//contest/512/problem/B,21643,B,512B,512,B. Fox And Jumping,Fox Ciel is playing a game In this game there is an infinite long tape with cells indexed by integers positive negative and zero At the beginning she is standing at the cell 0 There are also cards each card has 2 attributes length and cost If she pays dollars then she can apply th card After applying th card she becomes able to make jumps of length i e from cell to cell or cell She wants to be able to jump to any cell on the tape possibly visiting some intermediate cells For achieving this goal she wants to buy some cards paying as little money as possible If this is possible calculate the minimal cost ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nmap<int, int> dp[301];\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vi a(N), c(N);\n    forn(i, N) cin >> a[i];\n    forn(i, N) cin >> c[i];\n    dp[0][0] = 0;\n    forn(i, N) {\n//        cerr << dp[i].size() << \'\\n\';\n        for (pii p: dp[i]) {\n            int g = p.fi, w = p.se;\n            if (!dp[i + 1].count(g) || dp[i + 1][g] > w) dp[i + 1][g] = w;\n            int gg = gcd(g, a[i]);\n            if (!dp[i + 1].count(gg) || dp[i + 1][gg] > w + c[i]) dp[i + 1][gg] = w + c[i];\n        }\n    }\n    if (dp[N].count(1)) cout << dp[N][1] << \'\\n\';\n    else cout << -1 << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",,,"['data structures', 'dp', 'math', 'number theory', 'shortest paths']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Fox And Jumping.json,https://codeforces.com/blog/entry/16173,This task equals to what is the minimal sum of costs that we can select k cards so their GCD is 1 First observation is that means that for any prime there exist i such that is not dividable by So we only care about what prime factors a number contain So for example 12 2 3 6 2 3 9 3 The second observation is If then it has at most 9 prime factors So after we select one number we only care about these 9 or less primes Then this problem equals to set covering problem SCP it can be done by mask DP It can run in about O 2 9 n 2 
https://codeforces.com//contest/1280/problem/F,495765,F,1280F,1280,F. Intergalactic Sliding Puzzle,You are an intergalactic surgeon and you have an alien patient For the purposes of this problem we can and we will model this patient s body using a 2 times 2k 1 rectangular grid The alien has 4k 1 distinct organs numbered 1 to 4k 1 In healthy such aliens the organs are arranged in a particular way For example here is how the organs of a healthy such alien would be positioned when viewed from the top for k 4 Here the represents empty space In general the first row contains organs 1 to 2k 1 in that order from left to right and the second row contains organs 2k 2 to 4k 1 in that order from left to right and then empty space right after Your patient s organs are complete and inside their body but they somehow got shuffled around Your job as an intergalactic surgeon is to put everything back in its correct position All organs of the alien must be in its body during the entire procedure This means that at any point during the procedure there is exactly one cell in the grid that is empty In addition you can only move organs around by doing one of the following things You can switch the positions of the empty space with any organ to its immediate left or to its immediate right if they exist In reality you do this by sliding the organ in question to the empty space You can switch the positions of the empty space with any organ to its immediate top or its immediate bottom if they exist the empty space is on the column column or in the column Again you do this by sliding the organ in question to the empty space Your job is to figure out a sequence of moves you must do during the surgical procedure in order to place back all 4k 1 internal organs of your patient in the correct cells If it is impossible to do so you must say so ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint V[100];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint K; cin >> K;\n\t\tconst int R = 2 * K + 1;\n\t\tN = 2 * R;\n\t\tint p0 = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == ""E"") {\n\t\t\t\tV[i] = 0;\n\t\t\t\tp0 = i;\n\t\t\t} else {\n\t\t\t\tV[i] = stoi(s);\n\t\t\t}\n\t\t}\n\t\tassert(p0 != -1);\n\t\tstring ans;\n\t\twhile (p0 % R) {\n\t\t\tans += \'l\';\n\t\t\tswap(V[p0], V[p0-1]);\n\t\t\tp0--;\n\t\t}\n\t\tif (p0 == R) {\n\t\t\tans += \'u\';\n\t\t\tswap(V[p0], V[p0 - R]);\n\t\t\tp0 -= R;\n\t\t}\n\t\tassert(p0 == 0);\n\n\t\tbool parity = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i+1; j < N; j++) {\n\t\t\t\tif (V[j] < V[i]) parity ^= 1;\n\t\t\t}\n\t\t}\n\t\tif (parity) {\n\t\t\tcout << ""SURGERY FAILED"" << \'\\n\';\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tans += \'r\';\n\t\t\tswap(V[p0], V[p0+1]);\n\t\t\tp0++;\n\t\t}\n\t\tassert(p0 == K);\n\t\tans += \'d\';\n\t\tswap(V[p0], V[p0 + R]);\n\t\tp0 += R;\n\n\t\tauto VtoF = [&](int v) {\n\t\t\tassert(v != 0);\n\t\t\tif (v <= K) {\n\t\t\t\treturn v + K;\n\t\t\t} else if (v == K+1) {\n\t\t\t\treturn R;\n\t\t\t} else if (v <= R) {\n\t\t\t\treturn 2 * R - (v - (K+1));\n\t\t\t} else if (v <= R + K) {\n\t\t\t\treturn (K+1) - (v - R);\n\t\t\t} else {\n\t\t\t\treturn R + (v - R - K);\n\t\t\t}\n\t\t};\n\n\t\tdeque<int> lhs;\n\t\tdeque<int> rhs;\n\t\tfor (int i = K-1; i >= 0; i--) {\n\t\t\tlhs.push_front(VtoF(V[i]));\n\t\t}\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tlhs.push_front(VtoF(V[R+i]));\n\t\t}\n\n\t\tfor (int i = K+1; i < R; i++) {\n\t\t\trhs.push_front(VtoF(V[i]));\n\t\t}\n\t\tfor (int i = R-1; i > K; i--) {\n\t\t\trhs.push_front(VtoF(V[R+i]));\n\t\t}\n\t\tint mid = VtoF(V[K]);\n\t\tassert(int(lhs.size()) == 2 * K);\n\t\tassert(int(rhs.size()) == 2 * K);\n\n\t\tauto rotL = [&]() {\n\t\t\tans += \'L\';\n\t\t\tlhs.push_back(mid); mid = lhs.front(); lhs.pop_front();\n\t\t};\n\t\tauto unrotL = [&]() {\n\t\t\tans += \'X\';\n\t\t\tlhs.push_front(mid); mid = lhs.back(); lhs.pop_back();\n\t\t};\n\t\tauto rotR = [&]() {\n\t\t\tans += \'R\';\n\t\t\trhs.push_back(mid); mid = rhs.front(); rhs.pop_front();\n\t\t};\n\t\tauto unrotR = [&]() {\n\t\t\tans += \'Y\';\n\t\t\trhs.push_front(mid); mid = rhs.back(); rhs.pop_back();\n\t\t};\n\t\tfor (int z = 0; z < 2 * N; z++) {\n\t\t\tif (mid <= R) {\n\t\t\t\trotL();\n\t\t\t} else {\n\t\t\t\trotR();\n\t\t\t}\n\t\t}\n\n\t\tfor (int z = 0; z < R; z++) {\n\t\t\trotL();\n\t\t\tfor (int i = 0; i < R-1; i++) {\n\t\t\t\tif (lhs.front() < mid) {\n\t\t\t\t\t// do the swap\n\t\t\t\t\trotR();\n\t\t\t\t\trotL();\n\t\t\t\t\tunrotR();\n\t\t\t\t\tunrotL();\n\t\t\t\t\trotR();\n\t\t\t\t}\n\t\t\t\trotL();\n\t\t\t}\n\t\t}\n\n\t\tassert(mid == R);\n\t\tmid = 2 * R;\n\n\t\tbool f = false;\n\t\tfor (int z = 0; z < R; z++) {\n\t\t\trotR();\n\t\t\tfor (int i = 0; i < R-1; i++) {\n\t\t\t\tif (rhs.front() < mid) {\n\t\t\t\t\t// do the swap\n\t\t\t\t\tf ? unrotL() : rotL();\n\t\t\t\t\trotR();\n\t\t\t\t\tf ? rotL() : unrotL();\n\t\t\t\t\tunrotR();\n\t\t\t\t\tf ? unrotL() : rotL();\n\t\t\t\t\tf = !f;\n\t\t\t\t}\n\t\t\t\trotR();\n\t\t\t}\n\t\t}\n\t\tassert(f == false);\n\n\t\t// finalize answer by moving it to the rightmost\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tans += \'r\';\n\t\t}\n\t\tcout << ""SURGERY COMPLETE"" << \'\\n\';\n\t\tcout << ans << \'\\n\';\n\t\tcout << ""L"" << \' \' << string(K, \'l\')+""u""+string(K, \'r\')+""d"" << \'\\n\';\n\t\tcout << ""X"" << \' \' << ""u""+string(K, \'l\')+""d""+string(K, \'r\') << \'\\n\';\n\t\tcout << ""R"" << \' \' << string(K, \'r\')+""u""+string(K, \'l\')+""d"" << \'\\n\';\n\t\tcout << ""Y"" << \' \' << ""u""+string(K, \'r\')+""d""+string(K, \'l\') << \'\\n\';\n\t\tcout << ""DONE"" << \'\\n\';\n\t}\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'math']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Intergalactic Sliding Puzzle.json,https://codeforces.com//blog/entry/72212,The shortcuts thing in the output section is basically a way for you to define i e you can create simpler useful operations and then you can combine them into more complex operations Now to solve the problem we may represent the grid by the circular permutation obtained by going around the grid once say in a clockwise order starting from say the top left corner Without the middle column this circular permutation cannot be changed we can rotate it but that s it Thus to make progress we must use the middle column The key insight here is that moving something through the middle column corresponds to one and only one kind of operation which on our circular permutation corresponds to Notice that it simply moved a couple of places to the right In other words moving through the middle corresponds to a rotation of elements Since we can also rotate the whole thing this rotation can be performed in our permutation But since rotations and full rotations i e rotations are both permutations and these are the only available moves this means that inputs that are an odd permutation away from the target state are unsolvable You can also notice this right away once you realize that this problem is essentially the sliding picture puzzle but with even more restricted moves Amazingly the converse is true This follows from the fact that we can produce a rotation from the given operations You may want to try to come up with it yourself so instead of giving the sequence of moves directly I ll just give you a hint there is a sequence of that is equivalent to the rotation or and it only involves and If you still can t find it you could also write a backtracking program that finds it Once we have any single rotation it can then be applied anywhere again using with full rotations Also it is a well known fact that any even permutation is representable by a product of rotations This means that all even permutations are solvable Now determining which inputs are solvable is one thing but actually finding the solution is a whole different beast Fortunately the shortcuts thing is here to make it a bit easier The most important milestone is being able to come up with a sequence corresponding to a rotation assign an uppercase letter for such an operation After that you will only need rotations and full rotations to solve the rest 
https://codeforces.com//contest/1446/problem/F,797261,F,1446F,1446,F. Line Distance,You are given an integer k and n distinct points with integer coordinates on the Euclidean plane the i th point has coordinates x i y i Consider a list of all the frac n n 1 2 pairs of points x i y i x j y j 1 le i j le n For every such pair write out the distance from the line through these two points to the origin 0 0 Your goal is to calculate the k th smallest number among these distances ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst double PI = 4 * atan(1.);\n\nconst int IT = 80;\nconst double INF = 2e4;\nconst int N = 200100;\nint n;\ndouble a[N][2];\nint b[N][2];\npair<double, int> ord[N];\nint m;\n\n\nstruct Fenwick {\n\tvector<int> fenv;\n\n\tFenwick() : fenv() {}\n\tFenwick(int n) : fenv(vector<int>(n, 0)) {}\n\n\tvoid add(int p, int x) {\n\t\tfor(; p < (int)fenv.size(); p |= p + 1)\n\t\t\tfenv[p] += x;\n\t}\n\tint get(int r) {\n\t\tint res = 0;\n\t\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\t\tres += fenv[r];\n\t\treturn res;\n\t}\n\tint getSum(int l, int r) {\n\t\tif (l >= r) return 0;\n\t\treturn get(r - 1) - get(l - 1);\n\t}\n} fenv;\n\ndouble normAng(double ang) {\n\twhile(ang >= 2 * PI) ang -= 2 * PI;\n\twhile(ang < 0) ang += 2 * PI;\n\treturn ang;\n}\n\nll solve(double R) {\n//\tprintf(""solve %.5lf\\n"", R);\n\tm = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble L = sqrt(a[i][0] * a[i][0] + a[i][1] * a[i][1]);\n\t\tif (L <= R) continue;\n\t\tm++;\n\t\tdouble ang = atan2(a[i][1], a[i][0]);\n\t\tdouble phi = acos(R / L);\n//\t\tprintf(""%.5lf %.5lf\\n"", ang, phi);\n\t\tord[2 * m - 2] = mp(normAng(ang - phi), -m);\n\t\tord[2 * m - 1] = mp(normAng(ang + phi), m);\n\t}\n\tsort(ord, ord + 2 * m);\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tint v = ord[i].second;\n\t\tif (v < 0) {\n\t\t\tb[-v][0] = i;\n\t\t} else {\n\t\t\tb[v][1] = i;\n\t\t}\n\t}\n\tfenv = Fenwick(2 * m);\n\tfor (int i = 1; i <= m; i++) {\n//\t\tprintf(""%d %d\\n"", b[i][0], b[i][1]);\n\t\tif (b[i][0] > b[i][1])\n\t\t\tfenv.add(b[i][0], 1);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tint v = ord[i].second;\n\t\tif (v < 0) {\n\t\t\tv *= -1;\n\t\t\t\n\t\t\tfenv.add(i, 1);\n\t\t} else {\n\n\t\t\tfenv.add(b[v][0], -1);\n\t\t\tif (b[v][0] < b[v][1]) {\n\t\t\t\tans += fenv.getSum(b[v][0], b[v][1]);\n\t\t\t} else {\n\t\t\t\tans += fenv.getSum(b[v][0], 2 * m) + fenv.getSum(0, b[v][1]);\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(""ans = %lld\\n"", ans);\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tll k;\n\tscanf(""%d%lld"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tscanf(""%lf"", &a[i][j]);\n\tdouble l = 0, r = INF;\n//\tsolve(0.5);\n\tfor (int it = 0; it < IT; it++) {\n\t\tdouble x = (l + r) / 2;\n\t\tll z = solve(x);\n\t\tif (k + z > (ll)n * (n - 1) / 2)\n\t\t\tl = x;\n\t\telse\n\t\t\tr = x;\n\t}\n\tprintf(""%.15lf\\n"", l);\n\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'geometry']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Line Distance.json,https://codeforces.com//blog/entry/82067,Stupid hintBinary search is your friend To determine if the answer is bigger or smaller than we need to count the number of pairs of points such that 
https://codeforces.com//contest/777/problem/C,95271,C,777C,777,C. Alyona and Spreadsheet,During the lesson small girl Alyona works with one famous spreadsheet computer program and learns how to edit tables Now she has a table filled with integers The table consists of rows and columns By we will denote the integer located at the th row and the th column We say that the table is sorted in non decreasing order in the column if for all from to Teacher gave Alyona tasks For each of the tasks two integers and are given and Alyona has to answer the following question if one keeps the rows from to inclusive and deletes all others will the table be sorted in non decreasing order in at least one column Formally does there exist such that for all from to inclusive Alyona is too small to deal with this task and asks you to help ,"['#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c==\'-\') start=neg=true;\n        else if(c>=\'0\' && c<=\'9\') {\n            start=true;\n            num=num*10+c-\'0\';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nconst int maxn=(int)(1e5)+5;\nvector<int> a[maxn];\nint mi[maxn];\nint tmp[maxn];\n\nint main() {\n    int n,m;\n    read(n);read(m);\n    REP(i,1,n) {\n        a[i].push_back(0);\n        REP(j,1,m) {\n            int x;\n            read(x);\n            a[i].push_back(x);\n        }\n    }\n    int q;\n    read(q);\n    memset(mi,0x3f,sizeof(mi));\n    REP(j,1,m) {\n        int lst=1;\n        tmp[1]=1;\n        REP(i,2,n) {\n            if(a[i][j]<a[i-1][j]) lst=i;\n            tmp[i]=lst;\n        }\n        REP(i,1,n) mi[i]=min(mi[i],tmp[i]);\n    }\n    REP(i,1,q) {\n        int l,r;\n        read(l);read(r);\n        if(mi[r]<=l) {\n            printf(""Yes\\n"");\n        } else {\n            printf(""No\\n"");\n        }\n    }\n    return 0;\n}']",,,"['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Alyona and Spreadsheet.json,https://codeforces.com//blog/entry/50670,For each cell compute value equal to maximum such that table is non decreasing in row if we keep only rows from to inclusive This values can be computed in time using the following formulas if and otherwise To process the query we have to check whether there exists such that We will answer this questions using by precomputing maximum values in each row 
https://codeforces.com//contest/1722/problem/G,1524439,G,1722G,1722,G. Even-Odd XOR,Given an integer n find any array a of n nonnegative integers less than 2 31 such that the bitwise XOR of the elements on odd indices equals the bitwise XOR of the elements on even indices ,"['#include <bits/stdc++.h>\n#ifdef LOCAL\n#include ""txm/debug.h""\n#endif\n#define int long long\nusing namespace std;\nusing ll=long long;\nconst int N=200005;\nint n,a[N];\nvoid solve()\n{\n\tcin>>n;\n\tif(n==3) {cout<<""2 1 3\\n""; return;}\n\tbool bj=0;\n\tif(n%2) n--,bj=1;\n\tfor(int i=1;i<=n;i+=2) a[i]=i/2+1;\n\tfor(int i=2;i<=n;i+=2) a[i]=i/2;\n\tif(n%4==0)\n\t{\n\t\tfor(int i=2;i<=n;i+=2) a[i]|=(1<<30);\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<n;i+=2) a[i]|=(1<<30);\n\t\tfor(int i=n;i>=4;i-=2) a[i]|=(1<<29);\n\t}\n\tif(bj) a[++n]=0;\n\tfor(int i=1;i<=n;i++) cout<<a[i]<<"" \\n""[i==n];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}\n']",,,"['bitmasks', 'constructive algorithms', 'greedy']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\G. Even-Odd XOR.json,https://codeforces.com//blog/entry/106478,There are a lot of solutions to this problem Here I will describe one of them First we observe that having the XOR of even indexed numbers and odd indexed numbers equal is equivalent to having the XOR of all the elements equal to 0 Let s note with the XOR of all odd indexed numbers and the xor of all even indexed numbers Notice that the XOR of all the array equals if and only if a b So how do we generate such an array with XOR of all elements Our first instinct might be to arbitrarily generate the first numbers then set the last element as the XOR of the first ensuring that the total XOR is However we might have problems with the condition that all elements must be distinct Let s arbitrarily set the first so that they don t have the highest bit set and then the th number can be just The last number can be the XOR of the first XOR the th number you will be sure that the last number has not occurred in the first elements because they don t have the highest bit set while the last number must have the highest bit set But how do we know that the th number and the th number will not be equal This occurs only if the total XOR of the first numbers equals To fix this we can just choose a different arbitrary number in one of the spots For example my solution checks if the XOR of the numbers is If it is not great We can use the simple solution without any changes However if the XOR is I use the numbers in their place These two sequences have different XORs so it ensures that one of them always works 
https://codeforces.com//contest/615/problem/D,45132,D,615D,615,D. Multipliers,Ayrat has number represented as it s prime factorization of size i e Ayrat got secret information that that the product of all divisors of taken modulo is the password to the secret data base Now he wants to calculate this value ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int Mod = 1e9 + 7;\n\nconst int maxn = 200000;\n\nmap<int, int> cnt;\n\ninline int fpm(LL b, int e, int m)\n{\n    b %= m;\n    LL t = 1;\n    for ( ; e; e >>= 1, (b *= b) %= m)\n        if (e & 1) (t *= b) %= m;\n    return t;\n}\n\nvector<pair<int, int> > all;\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    int n;\n    scanf(""%d"", &n);\n    while (n--)\n    {\n        int x;\n        scanf(""%d"", &x), ++cnt[x];\n    }\n    static int suf[maxn + 5];\n    all.clear();\n    for (auto &x : cnt) all.pb(x);\n    int m = SZ(all);\n    suf[m] = 1;\n    for (int i = m - 1; i >= 0; --i) suf[i] = (LL)suf[i + 1] * (all[i].y + 1) % (Mod - 1);\n    LL ans = 1;\n    LL now = 1;\n    REP(i, 0, m)\n    {\n        LL lyc = now * suf[i + 1] % (Mod - 1);\n        int tmp = 0;\n        REP(j, 0, all[i].y + 1) (tmp += j) %= Mod - 1;\n        (lyc *= tmp) %= Mod - 1;\n        ans = ans * fpm(all[i].x, lyc, Mod) % Mod;\n        (now *= all[i].y + 1) %= Mod - 1;\n    }\n    printf(""%I64d\\n"", ans);\n    return 0;\n}\n']",,,"['math', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Multipliers.json,https://codeforces.com//blog/entry/22658,Let d x be a number of divisors of x and f x be the product of divisors Let then There is pairs of divisors of type and if x is a perfect square we have one more divisor for a prime and the statement little Fermat theorem We can see that if a and b are co prime Now we can count the answer code 15260890 Another problem Given secquence distinct primes and q queries l r to calculate Can you solve with complexity Suppose r l 1 M const in all queries Can you solve with complexity 
https://codeforces.com//contest/1985/problem/D,2693240,D,1985D,1985,D. Manhattan Circle,Given a n by m grid consisting of and characters there exists a whole manhattan circle on the grid The top left corner of the grid has coordinates 1 1 and the bottom right corner has coordinates n m Point a b belongs to the manhattan circle centered at h k if h a k b r where r is a positive constant On the grid the set of points that are part of the manhattan circle is marked as Find the coordinates of the center of the circle ,"[""#include <bits/stdc++.h>\xa0using namespace std;\xa0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\xa0const int MXN = 3e5 + 5;\xa0void _(){\tint n, m;\tcin >> n >> m;\tvector<int> a, b;\tfor (int i = 1; i <= n; i++)\t{\t\tfor (int j = 1; j <= m; j++)\t\t{\t\t\tchar ch;\t\t\tcin >> ch;\t\t\tif (ch == '#') a.push_back(i), b.push_back(j);\t\t}\t}\tsort(a.begin(), a.end()), sort(b.begin(), b.end());\ta.resize(unique(a.begin(), a.end()) - a.begin());\tb.resize(unique(b.begin(), b.end()) - b.begin());\tcout << a[(int)a.size() / 2] << ' ' << b[b.size() / 2] << '\\n';}\xa0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\tfor (int tt = 1; tt <= t; tt++)\t{\t\t_();\t}}""]",,,"['implementation', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Manhattan Circle.json,https://codeforces.com//blog/entry/129620,Note that the manhattan circle is always in a diamond shape symmetric from the center Let s take notice of some special characteristics that can help us One way is to find the top and bottom points of the circle Note that these points will have columns at the center of the circle so here we can acquire the value of k To find h since the circle is symmetric it is just the middle of the rows of the top and bottom points Note that we never needed to find the value of r 
https://codeforces.com//contest/1539/problem/D,1021673,D,1539D,1539,D. PriceFixed,Lena is the most economical girl in Moscow So when her dad asks her to buy some food for a trip to the country she goes to the best store PriceFixed Here are some rules of that store The store has an infinite number of items of every product All products have the same price 2 rubles per item For every product i there is a discount for experienced buyers if you buy b i items of products not necessarily type i then for all future purchases of the i th product there is a 50 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> pll;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\nconst int MAXN=100005;\n\nint n;\npll a[MAXN];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\treadint(n);\n\tfor(int i=1;i<=n;++i)readint(a[i].y),readint(a[i].x);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)swap(a[i].x,a[i].y);\n\tll cur=0,sum=0;\n\tint l,r;\n\tfor(r=n,l=1;;)\n\t{\n\t\twhile(l<=n && !a[l].x)++l;\n\t\twhile(r && !a[r].x)--r;\n\t\tif(l>r)break;\n\t\tif(cur>=a[l].y)sum+=a[l].x,cur+=a[l].x,a[l].x=0;\n\t\telse\n\t\t{\n\t\t\tll t=min(a[r].x,a[l].y-cur);\n\t\t\tsum+=2*t,cur+=t,a[r].x-=t;\n\t\t}\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}\n']",,,"['binary search', 'greedy', 'implementation', 'sortings', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. PriceFixed.json,https://codeforces.com//blog/entry/91906,Let be the sum of all Important greedy observations If there is an item which costs 1 then we will not make the answer worse by buying this item If all prices are 2 then we will not make the answer worse by buying the item with max Therefore we can sort all items by and on each iteration we will only need to consider two items with max and with min among all not bought items Another important observation We already know how many items with price 2 we should buy to be able to buy something with a discount This means that we can buy multiple items with full price together Similarly we can buy multiple items with a discount at once This solution can be implemented using a two pointers technique which allows to find the answer in 
https://codeforces.com//contest/253/problem/B,2356,B,253B,253,B. Physics Practical,One day Vasya was on a physics practical performing the task on measuring the capacitance He followed the teacher s advice and did as much as measurements and recorded the results in the notebook After that he was about to show the results to the teacher but he remembered that at the last lesson the teacher had made his friend Petya redo the experiment because the largest and the smallest results differed by more than two times Vasya is lazy and he does not want to redo the experiment He wants to do the task and go home play computer games So he decided to cheat before Vasya shows the measurements to the teacher he will erase some of them so as to make the largest and the smallest results of the remaining measurements differ in no more than two times In other words if the remaining measurements have the smallest result and the largest result then the inequality must fulfill Of course to avoid the teacher s suspicion Vasya wants to remove as few measurement results as possible from his notes Help Vasya find what minimum number of measurement results he will have to erase from his notes so that the largest and the smallest of the remaining results of the measurements differed in no more than two times ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint c[111111];\n\nint main(void)\n{\n    freopen(""input.txt"",""rt"",stdin);\n    freopen(""output.txt"",""wt"",stdout);\n    int n = 0;\n    scanf(""%d"",&n);\n    for(int i = 0;i < n;i++) scanf(""%d"",&c[i]);\n    sort(c,c+n);\n    \n    int ans = n-1;\n    for(int i = 0;i < n;i++)\n    {\n        int tans = i+(n-(upper_bound(c,c+n,2*c[i])-c));\n        ans = min(ans,tans);\n    }\n    printf(""%d\\n"",ans);\n    while(getchar() != EOF);\n    return 0;\n}\n']",,,"['binary search', 'dp', 'sortings', 'two pointers']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Physics Practical.json,https://codeforces.com//blog/entry/6073,For each from 1 to 5000 calculate the number of measurements equal to The iterate over all possible minimal values from 1 to 5000 For a fixed we can easily figure out which numbers we have to erase we should erase every number that or To find out the number of such values in the given sequence we should sum up values for all such 
https://codeforces.com//contest/876/problem/B,128565,B,876B,876,B. Divisiblity of Differences,You are given a multiset of integers You should select exactly of them in a such way that the difference between any two of them is divisible by or tell that it is impossible Numbers can be repeated in the original multiset and in the multiset of selected numbers but number of occurrences of any number in multiset of selected numbers should not exceed the number of its occurrences in the original multiset ,"['#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\n\n\nint main() {\n#ifdef __APPLE__\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n\n    int n, k, m;\n    scanf(""%d %d %d"", &n, &k, &m);\n    vector<int> a(n);\n    map<int, vector<int>> q;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", &a[i]);\n        q[a[i] % m].push_back(a[i]);\n    }\n    for (auto it : q) {\n        if (it.second.size() >= k) {\n            printf(""Yes\\n"");\n            for (int i = 0; i < k; ++i)\n                printf(""%d "", it.second[i]);\n            return 0;\n        }\n    }\n    printf(""No"");\n\n    return 0;\n}\n']",,,"['implementation', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Divisiblity of Differences.json,https://codeforces.com//blog/entry/55233,If is divisible by then and have same reminder when divided by Let s divide number to groups by reminder by modulo and if there is a group with size at least print numbers from it 
https://codeforces.com//contest/1038/problem/B,216022,B,1038B,1038,B. Non-Coprime Partition,Find out if it is possible to partition the first n positive integers into two disjoint sets S 1 and S 2 such that mathrm gcd mathrm sum S 1 mathrm sum S 2 1 Here mathrm sum S denotes the sum of all elements present in set S and mathrm gcd means thegreatest common divisor Every integer number from 1 to n should be present in of S 1 or S 2 ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(""%lld"", &x); return x;}\nvoid read(char *s){scanf(""%s"", s);}\nvoid no(){printf(""No""); exit(0);}\n\n#define maxn 120000\n#define maxm\n\n\nint main(){\n\tLL n = read();\n\tLL s = n * (n + 1) / 2;\n\tfor(int i = 2; i <= n; i += 1){\n\t\tif(s % i == 0){\n\t\t\tprintf(""Yes\\n1 %d\\n%lld "", i, n - 1);\n\t\t\tfor(int j = 1; j <= n; j += 1) if(j != i) printf(""%d "", j);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tno();\n}']",,,"['constructive algorithms', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Non-Coprime Partition.json,https://codeforces.com/blog/entry/61692,There are many ways to solve this question The easiest way perhaps was to note that the sum of first numbers is given by and one of or has to be an integer suppose Then we can partition the numbers into two sets one containing and the other containing the remaining integers both of which will have as a common factor Special Case There is no answer for Overall Complexity 
https://codeforces.com//contest/995/problem/F,193038,F,995F,995,F. Cowmpany Cowmpensation,Allen having graduated from the MOO Institute of Techcowlogy MIT has started a startup Allen is the president of his startup He also hires n 1 other employees each of which is assigned a direct superior If u is a superior of v and v is a superior of w then also u is a superior of w Additionally there are no u and v such that u is the superior of v and v is the superior of u Allen himself has no superior Allen is employee number 1 and the others are employee numbers 2 through n Finally Allen must assign salaries to each employee in the company including himself Due to budget constraints each employee s salary is an integer between 1 and D Additionally no employee can make strictly more than his superior Help Allen find the number of ways to assign salaries As this number may be large output it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nnamespace polysum {\n\tconst int D=101000;\n\tll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D];\n\tll calcn(int d,ll *a,ll n) {\n\t\tif (n<=d) return a[n];\n\t\tp1[0]=p2[0]=1;\n\t\trep(i,0,d+1) {\n\t\t\tll t=(n-i+mod)%mod;\n\t\t\tp1[i+1]=p1[i]*t%mod;\n\t\t}\n\t\trep(i,0,d+1) {\n\t\t\tll t=(n-d+i+mod)%mod;\n\t\t\tp2[i+1]=p2[i]*t%mod;\n\t\t}\n\t\tll ans=0;\n\t\trep(i,0,d+1) {\n\t\t\tll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod;\n\t\t\tif ((d-i)&1) ans=(ans-t+mod)%mod;\n\t\t\telse ans=(ans+t)%mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init(int M) {\n\t\tf[0]=f[1]=g[0]=g[1]=1;\n\t\trep(i,2,M+5) f[i]=f[i-1]*i%mod;\n\t\tg[M+4]=powmod(f[M+4],mod-2);\n\t\tper(i,1,M+4) g[i]=g[i+1]*(i+1)%mod;\n\t}\n\tll polysum(ll n,ll *a,ll m) { // a[0].. a[m] \\sum_{i=0}^{n-1} a[i]\n\t\ta[m+1]=calcn(m,a,m+1);\n\t\trep(i,1,m+2) a[i]=(a[i-1]+a[i])%mod;\n\t\treturn calcn(m+1,a,n-1);\n\t}\n\tll qpolysum(ll R,ll n,ll *a,ll m) { // a[0].. a[m] \\sum_{i=0}^{n-1} a[i]*R^i\n\t\tif (R==1) return polysum(n,a,m);\n\t\ta[m+1]=calcn(m,a,m+1);\n\t\tll r=powmod(R,mod-2),p3=0,p4=0,c,ans;\n\t\th[0][0]=0;h[0][1]=1;\n\t\trep(i,1,m+2) {\n\t\t\th[i][0]=(h[i-1][0]+a[i-1])*r%mod;\n\t\t\th[i][1]=h[i-1][1]*r%mod;\n\t\t}\n\t\trep(i,0,m+2) {\n\t\t\tll t=g[i]*g[m+1-i]%mod;\n\t\t\tif (i&1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod;\n\t\t\telse p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod;\n\t\t}\n\t\tc=powmod(p4,mod-2)*(mod-p3)%mod;\n\t\trep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod;\n\t\trep(i,0,m+2) C[i]=h[i][0];\n\t\tans=(calcn(m,C,n)*powmod(R,n)-c)%mod;\n\t\tif (ans<0) ans+=mod;\n\t\treturn ans;\n\t}\n}\n\nconst int N=3010;\nint n,d,p,dp[N][N];\nVI s[N];\nll pres[N];\nvoid dfs(int u) {\n\trep(i,0,n+1) dp[u][i]=1;\n\tfor (auto v:s[u]) {\n\t\tdfs(v);\n\t\trep(i,0,n+1) pres[i]=dp[v][i];\n\t\trep(i,1,n+1) pres[i]=(pres[i]+pres[i-1])%mod;\n\t\trep(i,0,n+1) dp[u][i]=dp[u][i]*pres[i]%mod;\n\t}\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&d); --d;\n\tpolysum::init(3456);\n\trep(i,2,n+1) {\n\t\tscanf(""%d"",&p);\n\t\ts[p].pb(i);\n\t}\n\tdfs(1);\n\trep(i,0,n+1) pres[i]=dp[1][i];\n\trep(i,1,n+1) pres[i]=(pres[i]+pres[i-1])%mod;\n\tprintf(""%lld\\n"",polysum::calcn(n,pres,d));\n}\n']",,,"['combinatorics', 'dp', 'math', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Cowmpany Cowmpensation.json,https://codeforces.com//blog/entry/60217,A immediate simple observation is that we can compute the answer in with a simple dynamic program How to speed it up though To speed it up we need the following lemma Lemma 1 For a tree with vertices the answer is a polynomial in of degree at most We can prove this via induction and the fact that for any polynomial of degree the sum is a polynomial in of degree Now the solution is easy compute the answer for and use interpolation to compute the answer for The complexity is for the initial dp and for the interpolation step 
https://codeforces.com//contest/1276/problem/B,495589,B,1276B,1276,B. Two Fairs,There are n cities in Berland and some pairs of them are connected by two way roads It is guaranteed that you can pass from any city to any other moving along the roads Cities are numerated from 1 to n Two fairs are currently taking place in Berland they are held in two different cities a and b 1 le a b le n a ne b Find the number of pairs of cities x and y x ne a x ne b y ne a y ne b such that if you go from x to y you will have to go through both fairs the order of visits doesn t matter Formally you need to find the number of pairs of cities x y such that any path from x to y goes through a and b in any order Print the required number of pairs The order of two cities in a pair does not matter that is the pairs x y and y x must be taken into account only once ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\nusing namespace std;\nint w[N_], n, m, A, B, chk[N_], vis[N_], T1[N_], T2[N_];\nvector<int>E[N_];\nvoid DFS(int a) {\n\tvis[a] = 1;\n\tfor (auto &x : E[a]) {\n\t\tif (!vis[x] && !chk[x])DFS(x);\n\t}\n}\nvoid Solve() {\n\tint i, a, b;\n\tscanf(""%d%d%d%d"", &n,&m,&A,&B);\n\tfor (i = 1; i <= n; i++) {\n\t\tE[i].clear();\n\t\tT1[i] = T2[i] = vis[i] = 0;\n\t\tchk[i] = 0;\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(""%d%d"", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tchk[B] = 1;\n\tDFS(A);\n\tlong long c1 = 0, c2 = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (!vis[i] && i != B)T1[i] = 1,c1++;\n\t\tvis[i] = 0;\n\t}\n\tchk[B] = 0;\n\tchk[A] = 1;\n\tDFS(B);\n\tfor (i = 1; i <= n; i++) {\n\t\tif (!vis[i] && i != A)T2[i] = 1,c2++;\n\t}\n\tprintf(""%lld\\n"", c1*c2);\n}\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin);\n\tint TC;\n\tscanf(""%d"", &TC);\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}']",,,"['combinatorics', 'dfs and similar', 'dsu', 'graphs']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Two Fairs.json,https://codeforces.com//blog/entry/72239,This problem has a simple linear solution just two depth first searches without involving cut points biconnected components and other advanced techniques Let s reformulate this problem in the language of graph theory you are given an undirected graph and two vertices a and b you need to find the number of pairs of vertices x y such that any path from x to y contains both vertices a and b In other words we are interested in pairs of vertices x y such that deleting the vertex a while going from b breaks the connection from x to y and deleting the vertex b while going from a breaks the connection from x to y Let s remove the vertex a and select the connected components in the resulting graph Similarly we remove the vertex b and select the connected components in the resulting graph Then the pair x y interests us if x and y belong to different components both when removing a and when removing b Thus let s find a pair of u u for each vertex u It will be numbers of the connected components when a and b are removed respectively The pair x y interests us if x x y y The total number of vertex pairs is n n 1 2 Let s subtract the number of uninteresting pairs from it Firstly these are pairs such that x x and y y partially equals in exactly one component For example let the equality be on the first component in the common value of Let the total number of pairs u u such that u be equal to c then subtract c c 1 2 from the current answer We will do this with all and Note that some uninteresting pairs were counted twice These are pairs of vertices such that x x and y y equals in both components We can count the number of corresponding vertices c and add c c 1 2 to the current answer for each pair In the following code let p be an array of pairs of component numbers for all vertices except a and b Each pair is the number of the connected component of this vertex if a is removed and the number of the connected component of this vertex if b is removed Then the main part of the solution can be like this 
https://codeforces.com//contest/1948/problem/A,2532313,A,1948A,1948,A. Special Characters,You are given an integer n Your task is to build a string of uppercase Latin letters There must be exactly n special characters in this string Let s call a character if it is equal to exactly one of its neighbors For example there are 6 special characters in the string at positions 1 3 5 6 7 and 8 Print any suitable string or report that there is no such string ,"['/**\n *    author:  tourist\n *    created: 15.03.2024 10:34:51\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    if (n % 2 == 1) {\n      cout << ""NO"" << \'\\n\';\n    } else {\n      cout << ""YES"" << \'\\n\';\n      for (int i = 0; i < n / 2; i++) {\n        cout << (i % 2 == 0 ? ""AA"" : ""BB"");\n      }\n      cout << \'\\n\';\n    }\n  }\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Special Characters.json,https://codeforces.com//blog/entry/127182,Let s look at the blocks of consecutive equal characters such that it cannot be extended to the left or to the right if its length is 1 then this block has 0 special characters if its length is 2 then this block has 2 special characters if its length is at least 3 then this block has 2 special characters only the leftmost and the rightmost elements We can see that there is no way to obtain an odd number of special characters So the answer is for all odd values of n And we can easily build the string for all even values of n The answer for an even n may look like this with frac n 2 blocks of length 2 alternating between two different letters 
https://codeforces.com//contest/260/problem/E,2469,E,260E,260,E. Dividing Kingdom,A country called Flatland is an infinite two dimensional plane Flatland has cities each of them is a point on the plane Flatland is ruled by king Circle IV Circle IV has 9 sons He wants to give each of his sons part of Flatland to rule For that he wants to draw four straight lines such that two of them are parallel to the axis and two others are parallel to the axis At that no straight line can go through any city Thus Flatland will be divided into 9 parts and each son will be given exactly one of these parts Circle IV thought a little evaluated his sons obedience and decided that the th son should get the part of Flatland that has exactly cities Help Circle find such four straight lines that if we divide Flatland into 9 parts by these lines the resulting parts can be given to the sons so that son number got the part of Flatland which contains cities ,"['//program 260-E\n\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point\n{\n  int X,Y;\n};\n\nbool operator <(Point A,Point B)\n{\n  return (A.X==B.X)?(A.Y<B.Y):(A.X<B.X);\n}\n\nstruct Node\n{\n  int Left,Right,Count;\n  Node *Lc,*Rc;\n};\n\nint Get()\n{\n  char c;\n  while(c=getchar(),(c<\'0\'||c>\'9\')&&(c!=\'-\'));\n  bool Flag=(c==\'-\');\n  if(Flag)\n    c=getchar();\n  int X=0;\n  while(c>=\'0\'&&c<=\'9\')\n    {\n      X=X*10+c-48;\n      c=getchar();\n    }\n  return Flag?-X:X;\n}\n\nconst int inf=1000000000;\n\nbool Used[9];\nint DataY[100000];\nint Data[9],S[9];\nPoint P[100000];\nNode *Tree[100001];\n\nNode *Build(int L,int R)\n{\n  Node *P=new Node;\n  P->Left=L;\n  P->Right=R;\n  P->Count=0;\n  if(L<R)\n    {\n      int Mid=(L+R)/2;\n      P->Lc=Build(L,Mid);\n      P->Rc=Build(Mid+1,R);\n    }\n  return P;\n}\n\nNode *Insert(Node *P,int X)\n{\n  Node *Q=new Node;\n  *Q=*P;\n  Q->Count++;\n  if(Q->Left<Q->Right)\n    {\n      int Mid=(Q->Left+Q->Right)/2;\n      if(X<=Mid)\n        Q->Lc=Insert(Q->Lc,X);\n      else\n        Q->Rc=Insert(Q->Rc,X);\n    }\n  return Q;\n}\n\nint Query(Node *L,Node *R,int K)\n{\n  if(L->Left==L->Right)\n    return L->Left;\n  int Left=R->Lc->Count-L->Lc->Count;\n  if(K<=Left)\n    return Query(L->Lc,R->Lc,K);\n  else\n    return Query(L->Rc,R->Rc,K-Left);\n}\n\nint GetKth(int LB,int UB,int K)\n{\n  return Query(Tree[LB],Tree[UB],K);\n}\n\nbool Check()\n{\n  int Left=S[0]+S[1]+S[2];\n  int Mid=Left+S[3]+S[4]+S[5];\n  int N=Mid+S[6]+S[7]+S[8];\n  if(P[Left-1].X==P[Left].X)\n    return false;\n  if(P[Mid-1].X==P[Mid].X)\n    return false;\n  int LB_0=-inf,UB_0=inf;\n  LB_0=max(LB_0,GetKth(0,Left,S[0]));\n  UB_0=min(UB_0,GetKth(0,Left,S[0]+1));\n  if(UB_0-LB_0<1)\n    return false;\n  LB_0=max(LB_0,GetKth(Left,Mid,S[3]));\n  UB_0=min(UB_0,GetKth(Left,Mid,S[3]+1));\n  if(UB_0-LB_0<1)\n    return false;\n  LB_0=max(LB_0,GetKth(Mid,N,S[6]));\n  UB_0=min(UB_0,GetKth(Mid,N,S[6]+1));\n  if(UB_0-LB_0<1)\n    return false;\n  int LB_1=-inf,UB_1=inf;\n  LB_1=max(LB_1,GetKth(0,Left,S[0]+S[1]));\n  UB_1=min(UB_1,GetKth(0,Left,S[0]+S[1]+1));\n  if(UB_1-LB_1<1)\n    return false;\n  LB_1=max(LB_1,GetKth(Left,Mid,S[3]+S[4]));\n  UB_1=min(UB_1,GetKth(Left,Mid,S[3]+S[4]+1));\n  if(UB_1-LB_1<1)\n    return false;\n  LB_1=max(LB_1,GetKth(Mid,N,S[6]+S[7]));\n  UB_1=min(UB_1,GetKth(Mid,N,S[6]+S[7]+1));\n  if(UB_1-LB_1<1)\n    return false;\n  printf(""%0.6lf %0.6lf\\n"",(P[Left-1].X+P[Left].X)*0.5,(P[Mid-1].X+P[Mid].X)*0.5);\n  printf(""%0.6lf %0.6lf\\n"",(DataY[LB_0]+DataY[UB_0])*0.5,(DataY[LB_1]+DataY[UB_1])*0.5);\n  return true;\n}\n\nbool DFS(int Depth)\n{\n  if(Depth==9)\n    return Check();\n  for(int i=0;i<9;i++)\n    if(!Used[i])\n      {\n        Used[i]=true;\n        S[Depth]=Data[i];\n        if(DFS(Depth+1))\n          return true;\n        Used[i]=false;\n      }\n  return false;\n}\n\nint main()\n{\n  int N=Get();\n  for(int i=0;i<N;i++)\n    {\n      P[i].X=Get();\n      P[i].Y=Get();\n    }\n  sort(P,P+N);\n  for(int i=0;i<N;i++)\n    DataY[i]=P[i].Y;\n  sort(DataY,DataY+N);\n  int Total=1;\n  for(int i=1;i<N;i++)\n    if(DataY[i-1]!=DataY[i])\n      DataY[Total++]=DataY[i];\n  for(int i=0;i<N;i++)\n    {\n      int Left=0,Right=Total-1;\n      while(Left<Right)\n        {\n          int Mid=(Left+Right)/2;\n          if(DataY[Mid]==P[i].Y)\n            Left=Right=Mid;\n          else if(DataY[Mid]<P[i].Y)\n            Left=Mid+1;\n          else\n            Right=Mid-1;\n        }\n      P[i].Y=Left;\n    }\n  Tree[0]=Build(0,Total-1);\n  for(int i=0;i<N;i++)\n    Tree[i+1]=Insert(Tree[i],P[i].Y);\n  for(int i=0;i<9;i++)\n    Data[i]=Get();\n  memset(Used,0,sizeof(Used));\n  if(!DFS(0))\n    printf(""-1\\n"");\n  return 0;\n}\n']",,,"['binary search', 'brute force', 'data structures']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Dividing Kingdom.json,https://codeforces.com//blog/entry/6263,Consider variants of location of integers on areas When we consider some location some grid we can easily find amount of cities to the left of the left vertical line to the right of the right vertical line below the lower horizontal line and above the upper horizontal line All these numbers is sum of three values We assume that the lines of the answer are always in half integer coordinates Then knowing the above numbers we can uniquely determine separately for and how to accommodate all the lines It remains only to check that in all areas there is desired number of points For each of four zones to the left of the left vertical line to the right of the right vertical line below the lower horizontal line and above the upper horizontal line separately check that all three areas have correct number of cities It can be done offline using scan line and segment tree which can find sum on interval and change value in some point You should put all queries in some array sort them and process from left to right Note when you check from areas for every variants of location the last area central could not be checked it will be correct automatically 
https://codeforces.com//contest/1203/problem/A,388102,A,1203A,1203,A. Circle of Students,There are n students standing in a circle in some order The index of the i th student is p i It is guaranteed that all indices of students are distinct integers from 1 to n i e they form a permutation Students want to start a round dance A round dance can be started if the student 2 comes right after the student 1 in clockwise order there are no students between them the student 3 comes right after the student 2 in clockwise order and so on and the student n comes right after the student n 1 in clockwise order A round dance is almost the same thing the only difference is that the student i should be right after the student i 1 in counterclockwise order this condition should be met for every i from 2 to n For example if the indices of students listed in clockwise order are 2 3 4 5 1 then they can start a clockwise round dance If the students have indices 3 2 1 4 in clockwise order then they can start a counterclockwise round dance Your task is to determine whether it is possible to start a round dance Note that the students cannot change their positions before starting the dance they cannot swap or leave the circle and no other student can enter the circle You have to answer q independent queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool ok(const vector<int> &a) {\n    for (int i = 0; i < a.size(); ++i) if (a[i] == 1) {\n        for (int j = i, v = 1; v <= a.size(); ++v, j = (j + 1) % a.size()) {\n            if (a[j] != v) {\n                return false;\n            }\n        }\n        break;\n    }\n    return true;\n}\n\nint main() {\n    int q; cin >> q;\n    while (q--) {\n        int n; cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) cin >> a[i];\n        bool yes = ok(a);\n        reverse(begin(a), end(a));\n        yes |= ok(a);\n        cout << (yes ? ""YES"" : ""NO"") << endl;\n    }\n}']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Circle of Students.json,https://codeforces.com//blog/entry/69108,We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity 
https://codeforces.com//contest/1508/problem/C,958783,C,1508C,1508,C. Complete the MST,As a teacher Riko Hakozaki often needs to help her students with problems from various subjects Today she is asked a programming task which goes as follows You are given an undirected complete graph with n nodes where some edges are pre assigned with a positive weight while the rest aren t You need to assign all unassigned edges with so that in the resulting fully assigned complete graph the XOR sum of all weights would be equal to 0 Define the of a fully assigned complete graph the weight of its minimum spanning tree where the weight of a spanning tree equals the sum of weights of its edges You need to assign the weights so that the ugliness of the resulting graph is as small as possible As a reminder an undirected complete graph with n nodes contains all edges u v with 1 le u v le n such a graph has frac n n 1 2 edges She is not sure how to solve this problem so she asks you to solve it for her ,"[""#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, M; cin >> N >> M;\n\tstruct edge_t {\n\t\tarray<int, 2> V;\n\t\tint W;\n\t};\n\tvector<edge_t> edges(M);\n\tvector<set<int>> adj(N);\n\tint totW = 0;\n\tfor (auto& e : edges) {\n\t\tcin >> e.V[0] >> e.V[1] >> e.W; e.V[0]--, e.V[1]--;\n\t\ttotW ^= e.W;\n\t\tadj[e.V[0]].insert(e.V[1]);\n\t\tadj[e.V[1]].insert(e.V[0]);\n\t}\n\tsort(edges.begin(), edges.end(), [&](const auto& a, const auto& b) { return a.W < b.W; });\n\n\tint64_t num_unassigned = int64_t(N) * int64_t(N-1) / 2 - M;\n\n\tvector<int> par(N, -1);\n\tauto reset_par = [&]() -> void { fill(par.begin(), par.end(), -1); };\n\tauto get_par = [&](int a) -> int {\n\t\twhile (par[a] >= 0) {\n\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\n\t\t\ta = par[a];\n\t\t}\n\t\treturn a;\n\t};\n\tauto merge = [&](int a, int b) -> bool {\n\t\ta = get_par(a), b = get_par(b);\n\t\tif (a == b) return false;\n\t\tif (par[a] > par[b]) swap(a, b);\n\t\tpar[a] += par[b];\n\t\tpar[b] = a;\n\t\treturn true;\n\t};\n\n\t{\n\t\tint nm = 0;\n\t\tfor (int z = 0; z < M; z++) {\n\t\t\tedge_t e = edges[z];\n\t\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\t\tedges[nm++] = e;\n\t\t\t}\n\t\t}\n\t\tM = nm;\n\t\tedges.resize(M);\n\t}\n\n\treset_par();\n\n\tvector<int> unvis(N); iota(unvis.begin(), unvis.end(), 0);\n\tvector<int> q; q.reserve(N);\n\twhile (!unvis.empty()) {\n\t\tq.push_back(unvis.back()); unvis.pop_back();\n\t\tfor (int z = int(q.size())-1; z < int(q.size()); z++) {\n\t\t\tint cur = q[z];\n\t\t\tint b = 0;\n\t\t\tfor (int a = 0; a < int(unvis.size()); a++) {\n\t\t\t\tint nxt = unvis[a];\n\t\t\t\tif (adj[cur].count(nxt)) {\n\t\t\t\t\tunvis[b++] = nxt;\n\t\t\t\t} else {\n\t\t\t\t\tmerge(cur, nxt);\n\t\t\t\t\tnum_unassigned--;\n\t\t\t\t\tq.push_back(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunvis.resize(b);\n\t\t}\n\t}\n\n\tint64_t ans = 0;\n\tfor (auto e : edges) {\n\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\tans += e.W;\n\t\t} else if (num_unassigned == 0) {\n\t\t\tans += min(totW, e.W);\n\t\t\tnum_unassigned = -1;\n\t\t}\n\t}\n\n\tif (num_unassigned == 0) {\n\t\tans += totW;\n\t\tnum_unassigned = -1;\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n""]",,,"['bitmasks', 'brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Complete the MST.json,https://codeforces.com//blog/entry/89644,Call the XOR sum of the weights of all pre assigned edges All but one unassigned edges are assigned with while the remaining unassigned edge is assigned with Consider any assignment of unassigned edges There are two cases on the minimum spanning tree The MST does not use all unassigned edges We can assign one unused unassigned edge with while all other unassigned edges including all used in the MST are assigned with This reduces the weight of the MST The MST uses all unassigned edges We can prove that the sum of weights of unassigned edges is at least and the equality can be achieved with the construction from the lemma Intuitively the XOR sum is an uncarried summation and the construction from the lemma removes any digit carry Let s DFS on the unassigned edges It can happen that the unassigned edges may separate the graph into multiple components and we might need to use some pre assigned edges in our MST I will divide the collection of pre assigned edges into 3 types Edges that must be included in the MST these are edges with smallest weights that connect the components after traversing through unassigned edges Edges that cannot be included in the MST these are edges that form cycles with smaller weighted pre assigned edges In other words these are edges that do not exist in the minimum spanning forest of the pre assigned edges Edges that are in neither of the previous types For the unassigned edges there are two cases The unassigned edges form at least a cycle We can assign any edge on this cycle as the rest as then build an MST using the weighted edges with pre assigned edges of type 1 The unassigned edges does not form a cycle Suppose we build the tree using only unassigned edges and edges of type 1 Then any edge of type 3 can replace an unassigned edge in the tree That is because the edges of type 3 must form a cycle with edges of type 1 and unassigned edges else it would either be in type 1 or type 2 We can simply replace an unassigned edge in that cycle with this type 3 edge Therefore for this case our solution is to first form the tree with all edges of type 1 and unassigned edge Then if the smallest weighted type 3 edge has weight we can replace an unassigned edge with this edge else we keep the tree 
https://codeforces.com//contest/1687/problem/E,1419369,E,1687E,1687,E. Become Big For Me,Kijin Seija Shinmyoumaru has a mallet that can turn objects bigger or smaller She is testing it out on a sequence a and a number v whose initial value is 1 She wants to make v gcd limits i ne j a i cdot a j by 10 5 operations gcd limits i ne j a i cdot a j denotes the gcd of all products of two distinct elements of the sequence a In each operation she picks a subsequence b of a and does one of the followings v v cdot mathrm lcm b v frac v mathrm lcm b Note that she does need to guarantee that v is an integer that is v does need to be a multiple of mathrm lcm b when performing Reduce Moreover she wants to guarantee that the total length of b chosen over the operations does not exceed 10 6 Fine a possible operation sequence for her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint d[N];\nint cntDif[N];\nint c[N][3];\nbool u[N];\n\nvector<pair<vector<int>, int>> getGcd(int ban) {\n\tint g = 0;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tg = gcd(g, a[i]);\n\t}\n\tint gg = 0;\n\tvector<int> w;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tint ng = gcd(gg, a[i]);\n\t\tif (ng == gg) continue;\n\t\tif (gg == 0 || cntDif[gg / g] != cntDif[ng / g]) {\n\t\t\tw.push_back(i);\n\t\t}\n\t\tgg = ng;\n\t}\n\tvector<pair<vector<int>, int>> ans;\n\tint sz = (int)w.size();\n\tassert(sz > 0);\n\tfor (int mask = 1; mask < (1 << sz); mask++) {\n\t\tint t = 1;\n\t\tvector<int> cur;\n\t\tfor (int i = 0; i < sz; i++) if ((mask >> i) & 1) {\n\t\t\tt ^= 1;\n\t\t\tcur.push_back(w[i]);\n\t\t}\n\t\tans.push_back(mp(cur, t));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int x = 2; x < N; x++) {\n\t\tif (d[x] != 0) continue;\n\t\tc[x][0] = 0;\n\t\tc[x][1] = 30;\n\t\tc[x][2] = -1;\n\t\tfor (int y = x; y < N; y += x)\n\t\t\tif (d[y] == 0)\n\t\t\t\td[y] = x;\n\t}\n\tcntDif[1] = 0;\n\tfor (int x = 2; x < N; x++) {\n\t\tint y = x;\n\t\twhile(d[y] == d[x]) y /= d[x];\n\t\tcntDif[x] = cntDif[y] + 1;\n\t}\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tint x = a[i];\n\t\twhile(x > 1) {\n\t\t\tint p = d[x];\n\t\t\tint k = 0;\n\t\t\twhile(x % p == 0) {\n\t\t\t\tx /= p;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tc[p][0]++;\n\t\t\tif (k < c[p][1]) {\n\t\t\t\tc[p][1] = k;\n\t\t\t\tc[p][2] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int p = 2; p < N; p++) if (d[p] == p) {\n\t\tif (c[p][0] <= n - 2) continue;\n\t\tif (c[p][0] == n - 1) {\n\t\t\tint v = 0;\n\t\t\twhile(a[v] % p == 0) v++;\n\t\t\tu[v] = 1;\n\t\t} else {\n\t\t\tu[c[p][2]] = 1;\n\t\t}\n\t}\n\tvector<int> zz;\n\tfor (int i = 0; i < n; i++)\n\t\tif (u[i])\n\t\t\tzz.push_back(i);\n\tvector<pair<vector<int>, int>> ans;\n\tvector<pair<vector<int>, int>> ans0 = getGcd(-1);\n\tint w = 2 - (int)zz.size();\n\tif (w > 0) {\n\t\tfor (int it = 0; it < w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(z);\n\t} else {\n\t\tfor (int it = 0; it < -w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(mp(z.first, z.second ^ 1));\n\t}\n\tfor (int x : zz) {\n\t\tans0 = getGcd(x);\n\t\tfor (auto z : ans0)\n\t\t\tans.push_back(z);\n\t}\n\tprintf(""%d\\n"", (int)ans.size());\n\tfor (auto z : ans) {\n\t\tprintf(""%d %d"", z.second, (int)z.first.size());\n\t\tsort(all(z.first));\n\t\tfor (int id : z.first)\n\t\t\tprintf("" %d"", id + 1);\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'greedy', 'math', 'number theory']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Become Big For Me.json,https://codeforces.com//blog/entry/103493,Solution Let be the maximum integer satisfying For each prime WLOG assuming then Consider the Inclusion Exclusion Principle So Then We can solve the task by choosing a short subsequence satisfying and enumerating its subsets To fit in the constraint the length of should be no longer than Think of an easier task choosing a small subset satisfying If we can solve it we can construct by choosing if does not exceed First choose an arbitrary element in as the only element of and factorize into For each if then add an arbitrary element in satisfying to Now obviously but We can prove that and do not hold at the same time then we can solve the task by choosing Consider the necessary condition of According to how we choose so Since and But causing a conflict So does not hold The time complexity is Worth mentioning with this conclusion such small set exists we can solve it much more easier Just choose a small set by greedy and enumerate its subset of size 
https://codeforces.com//contest/18/problem/A,82,A,18A,18,A. Triangle,At a geometry lesson Bob learnt that a triangle is called right angled if it is nondegenerate and one of its angles is right Bob decided to draw such a triangle immediately on a sheet of paper he drew three points with integer coordinates and joined them with segments of straight lines then he showed the triangle to Peter Peter said that Bob s triangle is not right angled but is right angled the triangle itself is not right angled but it is possible to move one of the points exactly by distance 1 so that all the coordinates remain integer and the triangle become right angled Bob asks you to help him and find out if Peter tricks him By the given coordinates of the triangle you should find out if it is right angled almost right angled or neither of these ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""f""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\nint X[3], Y[3], x[3], y[3];\nbool vp(int x1, int y1, int x2, int y2) {\n    return (x1*x1+y1*y1) && (x2*x2+y2*y2) && !(x1*x2+y1*y2);    \n}\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n    forn(i,3)\n        cin >> x[i] >> y[i];\n    for (int i=0; i<3; i++)\n        for (int j=0; j<3; j++)\n            for (int k=0; k<3; k++)\n                if (i!=j && j!=k && i!=k && vp(x[j]-x[i], y[j]-y[i], x[k]-x[i], y[k]-y[i])) {\n                    cout << ""RIGHT\\n"";\n                    return 0;\n                }\n    for (int q=0; q<3; q++)\n        for (int dx=-1; dx<=1; dx++)\n            for (int dy=-1; dy<=1; dy++) \n                if (abs(dx)+abs(dy)==1) {\n                    for (int p=0; p<3; p++)\n                        X[p]=x[p], Y[p]=y[p];\n                    X[q]=x[q]+dx, Y[q]=y[q]+dy;\n                    for (int i=0; i<3; i++)\n                        for (int j=0; j<3; j++)\n                            for (int k=0; k<3; k++)\n                                if (i!=j && j!=k && i!=k && vp(X[j]-X[i], Y[j]-Y[i], X[k]-X[i], Y[k]-Y[i])) {\n                                    cout << ""ALMOST\\n"";\n                                    return 0;\n                                }\n                }\n    cout << ""NEITHER\\n"";\n    return 0;\n}']",,,"['brute force', 'geometry']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Triangle.json,https://codeforces.com//blog/entry/463,n this problem you should implement a function which takes three points and checks whether they form a right angled triangle There are a lot of ways to do so but the simplest one is using a Pythagorean theorem You should use squared distances instead of taking roots to overcome problems related to precision errors To examine a triangle on almost rightness you can try to move each point in each of four possible directions and check the new triangle using our function It s good and easy to use two arrays dx 1 0 1 0 and dy 0 1 0 1 for moving Then we can get the new coordinates of shifted point simply using the following code 
https://codeforces.com//contest/1703/problem/C,1459217,C,1703C,1703,C. Cypher,Luca has a cypher made up of a sequence of n wheels each with a digit a i written on it On the i th wheel he made b i moves Each move is one of two types move denoted by texttt U it increases the i th digit by 1 After applying the up move on 9 it becomes 0 move denoted by texttt D it decreases the i th digit by 1 After applying the down move on 0 it becomes 9 Luca knows the final sequence of wheels and the moves for each wheel Help him find the original sequence and crack the cypher ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""./debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""./input.txt""); ofstream cout(""output.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n    fstart;\n\n    int T; cin >> T;\n    while (T--) {\n        int n; cin >> n;\n        vector<int> a(n);\n        for (auto& x : a)\n            cin >> x;\n\n        for (int i = 0; i < n; i++) {\n            int k; cin >> k;\n            string s; cin >> s;\n            for (auto& c : s)\n                a[i] += (c == \'D\'), a[i] -= (c == \'U\');\n            a[i] %= 10;\n            a[i] += 10;\n            a[i] %= 10;\n        }\n\n        for (auto& x : a)\n            cout << x << "" "";\n        cout << ""\\n"";\n\n    }\n\n    finish;\n}\n']",,,"['brute force', 'implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\C. Cypher.json,https://codeforces.com//blog/entry/104786,We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case 
https://codeforces.com//contest/1863/problem/C,2186454,C,1863C,1863,C. MEX Repetition,You are given an array a 1 a 2 ldots a n of integers from 0 to n Consider the following operation consecutively for each i from 1 to n in this order replace a i with operatorname MEX a 1 a 2 ldots a n Here operatorname MEX of a collection of integers c 1 c 2 ldots c m is defined as the smallest non negative integer x which does not occur in the collection c For example operatorname MEX 0 2 2 1 4 3 and operatorname MEX 1 2 0 Print the array after applying k such operations ,"['/**\n *    author:  tourist\n *    created: 30.08.2023 10:40:04       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      sum += a[i];\n    }\n    long long last = (long long) n * (n + 1) / 2 - sum;\n    a.push_back((int) last);\n    k %= n + 1;\n    rotate(a.begin(), a.begin() + (n + 1) - k, a.end());\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']",,,"['implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. MEX Repetition.json,https://codeforces.com//blog/entry/119902,Append the initial array with It is easy to see that is a permutation of In this case setting is basically equivalent but after this the new is changed In fact it becomes equal to the old value of since this value is not now present in the array In other words performing the operation on is equivalent to swapping and Performing the operation on can be viewed as swaps It means that the array changes from to i e we simply perform the cyclic shift to the right To finish up the solution first calculate you can do so for example by setting Second calculate and then perform the cyclic shift in 
https://codeforces.com//contest/803/problem/G,104512,G,803G,803,G. Periodic RMQ Problem,You are given an array consisting of positive integers and queries to this array There are two types of queries for each index such that set find the minimum among such that We decided that this problem is too easy So the array is given in a compressed form there is an array consisting of elements and a number in the input and before all queries is equal to the concatenation of arrays so the size of is ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9 + 5;\n\nstruct Node\n{\n    int l, r;\n    int val;\n    int toPush;\n\n    Node() : l(), r(), val(INF), toPush(-1) {}\n    Node(int _l, int _r) : l(_l), r(_r), val(INF), toPush(-1) {}\n};\n\nconst int N = 1 << 18;\nNode tree[2 * N];\nint a[N];\nint n, k, m;\nint q[N][4];\nint xs[N];\nint xsSz;\n\nvoid build()\n{\n    for (int i = 0; i < N; i++)\n        tree[N + i] = Node(i, i + 1);\n    for (int i = N - 1; i > 0; i--)\n        tree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n    return;\n}\n\nvoid push(int v)\n{\n    if (v >= N) throw;\n    if (tree[v].toPush == -1) return;\n    for (int u = 2 * v; u < 2 * v + 2; u++)\n    {\n        tree[u].val = tree[v].toPush;\n        tree[u].toPush = tree[v].toPush;\n    }\n    tree[v].toPush = -1;\n    return;\n}\nvoid update(int v)\n{\n    if (v >= N) throw;\n    tree[v].val = min(tree[2 * v].val, tree[2 * v + 1].val);\n    return;\n}\n\nvoid setOnSegm(int v, int l, int r, int x)\n{\n    if (l <= tree[v].l && tree[v].r <= r)\n    {\n        tree[v].val = tree[v].toPush = x;\n        return;\n    }\n    if (l >= tree[v].r || tree[v].l >= r) return;\n    push(v);\n    setOnSegm(2 * v, l, r, x);\n    setOnSegm(2 * v + 1, l, r, x);\n    update(v);\n    return;\n}\n\nint getMin(int v, int l, int r)\n{\n    if (l <= tree[v].l && tree[v].r <= r)\n        return tree[v].val;\n    if (l >= tree[v].r || tree[v].l >= r)\n        return INF;\n    push(v);\n    return min(getMin(2 * v, l, r), getMin(2 * v + 1, l, r));\n}\n\nint getCyclicMin(int l, int r)\n{\n    if (r - l >= n)\n        return getMin(1, 0, n);\n    l %= n;\n    r %= n;\n    if (l < r)\n        return getMin(1, l, r);\n    else\n        return min(getMin(1, l, n), getMin(1, 0, r));\n}\n\nvoid read()\n{\n    scanf(""%d%d"", &n, &k);\n    for (int i = 0; i < n; i++)\n        scanf(""%d"", &a[i]);\n    build();\n    for (int i = 0; i < n; i++)\n        setOnSegm(1, i, i + 1, a[i]);\n    scanf(""%d"", &m);\n    xsSz = 0;\n    xs[xsSz++] = 0;\n    xs[xsSz++] = n * k;\n    for (int i = 0; i < m; i++)\n    {\n        scanf(""%d%d%d"", &q[i][0], &q[i][1], &q[i][2]);\n        if (q[i][0] == 1)\n            scanf(""%d"", &q[i][3]);\n        q[i][1]--;\n        xs[xsSz++] = q[i][1];\n        xs[xsSz++] = q[i][2];\n    }\n    sort(xs, xs + xsSz);\n    xsSz = unique(xs, xs + xsSz) - xs;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j < 3; j++)\n            q[i][j] = lower_bound(xs, xs + xsSz, q[i][j]) - xs;\n    for (int i = 0; i < xsSz - 1; i++)\n        a[i] = getCyclicMin(xs[i], xs[i + 1]);\n    build();\n    n = xsSz - 1;\n    for (int i = 0; i < n; i++)\n        setOnSegm(1, i, i + 1, a[i]);\n    return;\n}\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    read();\n    for (int i = 0; i < m; i++)\n    {\n        if (q[i][0] == 1)\n            setOnSegm(1, q[i][1], q[i][2], q[i][3]);\n        else\n            printf(""%d\\n"", getMin(1, q[i][1], q[i][2]));\n    }\n\n    return 0;\n}\n']",,,['data structures'],2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Periodic RMQ Problem.json,https://codeforces.com//blog/entry/51768,Most of the solutions used the fact that we can read all the queries compress them and process after the compression using simple segment tree But there is also an online solution Let s build a sparse table on array to answer queries on segments that are not modified in To process modification segments we will use implicit segment tree and lazy propagation technique We do not build the whole segment tree instead in the beginning we have only one node for segment and if some modification query accesses some node but does not modify the complete segment this node maintains only then we create the children of this node So the leaves of the segment tree are the nodes such that their segments are completely set to some value or not modified at all Since each modification query affects only nodes the resulting complexity will be 
https://codeforces.com//contest/1073/problem/A,243296,A,1073A,1073,A. Diverse Substring,You are given a string s consisting of n lowercase Latin letters A substring of string s is a continuous segment of letters from s For example is a substring of and is not The length of the substring is the number of letters in it Let s call some string of length n if and only if there is no letter to appear strictly more than frac n 2 times For example strings and are and strings and are not Your task is to find substring of string s or report that there is none Note that it is not required to maximize or minimize the length of the resulting substring ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n  int n;\n  string s;\n  cin >> n >> s;\n  for (int i = 0; i + 1 < n; i++) {\n    if (s[i] != s[i + 1]) {\n      cout << ""YES"" << endl;\n      cout << s.substr(i, 2) << endl;\n      return 0;\n    }\n  }\n  cout << ""NO"" << endl;\n}\n\n']",,,"['implementation', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Diverse Substring.json,https://codeforces.com/blog/entry/62742,Notice that the string of two distinct letter is already diverse That implies that the answer is if and only if all the letters in the string are the same Otherwise you can check all pairs of adjacent letters in Overall complexity 
https://codeforces.com//contest/484/problem/B,16629,B,484B,484,B. Maximum Value,You are given a sequence consisting of integers Find the maximum possible value of integer remainder of divided by where and ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nint a[2000011];\nint prv[2000011];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    forn(i, N) {\n        int x;\n        cin >> x;\n        a[x] = 1;\n    }\n\n    prv[1] = 0;\n    for (int i = 2; i <= 2000000; ++i) {\n        if (a[i - 1]) prv[i] = i - 1;\n        else prv[i] = prv[i - 1];\n    }\n    int ans = 0;\n    for (int i = 1; i <= 1000000; ++i) {\n        if (!a[i]) continue;\n//        cerr << i << \'\\n\';\n        for (int k = 2; i * k <= 2000000; ++k) {\n//            cerr << prv[i * k] << \'\\n\';\n            ans = max(ans, prv[i * k] % i);\n        }\n    }\n    cout << ans << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",,,"['binary search', 'math', 'sortings', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Maximum Value.json,https://codeforces.com//blog/entry/14592,Let us iterate over all different Since we need to maximize then iterate all integer such divisible by in range from to where doubled maximum value of the sequence For each such we need to find maximum such Limits for numbers allow to do this in time with an array After that update answer by value Total time complexity is 
https://codeforces.com//contest/66/problem/D,349,D,66D,66,D. Petya and His Friends,Little Petya has a birthday soon Due this wonderful event Petya s friends decided to give him sweets The total number of Petya s friends equals to Let us remind you the definition of the greatest common divisor where represents such a maximal positive number that each is evenly divisible by At that we assume that all s are greater than zero Knowing that Petya is keen on programming his friends has agreed beforehand that the st friend gives sweets the nd one gives sweets the th one gives sweets At the same time for any and they want the not to be equal to However they also want the following condition to be satisfied One more all the should be distinct Help the friends to choose the suitable numbers ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""d""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nconst int BASE = 10000;\n\nstruct Long\n{\n    int size, x[1005];\n};\n\nint N;\n\nvoid Load ()\n{           \n    cin >> N;\n}\n\nvoid Mul (Long &a, int b)\n{\n    int cur = 0;\n\n    for (int i = 0;i < a.size;i++)\n    {\n        a.x[i] = a.x[i] * b + cur;\n        cur = a.x[i] / BASE;\n        a.x[i] %= BASE;\n    }\n    if (cur > 0)\n        a.x[a.size++] = cur;\n}\n\nvoid print (Long &a)\n{\n    printf (""%d"", a.x[a.size-1]);\n\n    for (int i = a.size - 2;i >= 0;i--)\n        printf (""%04d"", a.x[i]);\n    printf (""\\n"");\n}\n\nLong a;\n\nvoid Solve ()\n{\n    if (N == 2)\n    {\n        cout << ""-1"";\n        return;\n    }\n    cout << ""10\\n"";\n\n    a.x[0] = 6;\n    a.size = 1;\n    for (int i = 1;i < N - 1;i++)\n    {\n        print (a);\n        Mul (a, 2);\n    }\n    cout << ""15\\n"";\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']",,,"['constructive algorithms', 'math', 'number theory']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Petya and His Friends.json,https://codeforces.com//blog/entry/1452,Consider N distinct prime numbers p1 p2 pn Let A p1 p2 pn Then easy to see that the numbers A p1 A p2 A pn can be considered as the answer The special case is when N 2 In this case there is no answer We can see that this solution needs long arithmetic If we choose first n prime numbers as p1 p2 pn then the maximal number in the answer for all N 50 contains less than 100 digits Of course there are other solutions For example if N 3 numbers 15 10 6 are the answer and for N 3 numbers 15 10 6 6 2 6 3 6 N 2 are the answer 
https://codeforces.com//contest/1312/problem/C,557979,C,1312C,1312,C. Adding Powers,Suppose you are performing the following algorithm There is an array v 1 v 2 dots v n filled with zeroes at start The following operation is applied to the array several times at i th step 0 indexed you can either choose position pos 1 le pos le n and increase v pos by k i or not choose any position and skip this step You can choose how the algorithm would behave on each step and when to stop it The question is can you make array v equal to the given array a v j a j for each j after some step ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 65;\nbool ok[maxN][maxN];\nint k;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n;\n        cin >> n >> k;\n        memset(ok, 0, sizeof ok);\n        bool can = true;\n        for (int i = 1; i <= n; i++) {\n            ll x;\n            cin >> x;\n            for (int pos = 0; pos < maxN; pos++) {\n                int t = x % k;\n                x /= k;\n                if (t > 1) {\n                    can = false;\n                }\n                else if (t == 1) {\n                    if (ok[pos][t]) can = false;\n                    ok[pos][t] = true;\n                }\n            }\n        }\n        if (can) cout << ""YES\\n"";\n        else cout << ""NO\\n"";\n    }\n    return 0;\n}']",,,"['bitmasks', 'greedy', 'implementation', 'math', 'number theory', 'ternary search']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Adding Powers.json,https://codeforces.com//blog/entry/74640,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array 
https://codeforces.com//contest/1758/problem/C,1661250,C,1758C,1758,C. Almost All Multiples,Given two integers n and x a permutation dagger p of length n is called if p i is a multiple of i for all 1 leq i leq n 1 p n 1 and p 1 x Find the lexicographically minimal ddagger funny permutation or report that no such permutation exists dagger A permutation of length n is an array consisting of each of the integers from 1 to n exactly once ddagger Let a and b be permutations of length n Then a is lexicographically smaller than b if in the first position i where a and b differ a i b i A permutation is lexicographically minimal if it is lexicographically smaller than all other permutations ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=998244353;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n,a[N];\nV input(){\n\tint x;\n\tn = getint(), x = getint();\n\ta[1] = x, a[n] = 1;\n\tif(n%x!=0)\n\t\treturn void(cout<<""-1\\n"");\n\tFOR(i,2,n-1)a[i] = i;\n\t// x  n -> x  n \n\tint p = 2;\n\twhile(x!=n){\n\t\tint d= n/x;\n\t\twhile(d%p!=0)p++;\n\t\ta[x] = x *p, x*=p;\n\t}\n\tFOR(i,1,n)cout<<a[i]<<"" \\n""[i==n];\n\n\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n']",,,"['greedy', 'number theory']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Almost All Multiples.json,https://codeforces.com//blog/entry/109438,We start by giving the answer for and for As you can see the array is almost the identity permutation with certain elements rotated to the left In particular these are the elements that you get when you find the longest sequence such that recall means divides For example and To find this longest sequence you need to prime factorize The complexity is The main idea is intuitive but the proof is rather long We include it below The idea is to look at cycles in the permutation Consider any cycle of length greater than say that is We claim that for at least one element of the cycle is a multiple of In fact we ll show a more general claim for one element of the cycle which implies that cannot be a multiple of Indeed let s sum over all elements of the cycle This sum is because each element appears once before the sign and once afterwards Since none of these equal it follows that at least one of these terms is negative and at least one is positive If then as desired So in each cycle we must have at least one element breaking the key claim in the problem But this claim holds for all so the only cycle we can have goes through Indeed since and the cycle goes For all arrows except the first one we to write because only can break the condition Since we want the permutation to be lexicographically minimal we want the longest such chain So we should find the longest sequence of numbers from to such that each number divides the previous If there are multiple such sequences we need to pick the one that puts smaller numbers earlier since we want smaller elements earlier on in the sequence To do this we can just find the prime factorization of it is the longest since the primes cannot be broken up into smaller factors sort it and cycle it 
https://codeforces.com//contest/420/problem/C,8700,C,420C,420,C. Bug in Code,Recently a serious bug has been found in the FOS code The head of the F company wants to find the culprit and punish him For that he set up an organizational meeting the issue is who s bugged the code Each of the coders on the meeting said I know for sure that either or did it The head of the company decided to choose two suspects and invite them to his office Naturally he should consider the coders opinions That s why the head wants to make such a choice that at least of coders agreed with it A coder agrees with the choice of two suspects if at least one of the two people that he named at the meeting was chosen as a suspect In how many ways can the head of F choose two suspects Note that even if some coder was chosen as a suspect he can agree with the head s choice if he named the other chosen coder at the meeting ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define LLD long long\n#define N 300005\nusing namespace std;\n\nstruct dat{\n\tint x, id;\n\tbool operator < (dat const &T) const{return x < T.x;}\n};\n\nint n, m, x, y, tx, ty;\nint d[N], v[N];\ndat a[N];\nmap<int, int> S[N];\nLLD ret;\n\nint main(){\n\tscanf(""%d%d"", &n, &m);\n\tFOR(i,0,n) a[i].id = i;\n\tFOR(i,0,n){\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--, y--;\n\t\tS[x][y]++;\n\t\tS[y][x]++;\n\t\ta[x].x++, a[y].x++;\n\t\td[x]++, d[y]++;\n\t}\n\t\n\tsort(a, a + n);\n\tret = 0;\n\tfor (int i=0, j=n; i<n-1; i++){\n\t\twhile (j > i && a[i].x + a[j-1].x >= m) --j;\n\t\tj = max(j, i + 1);\n\t\tif (j == n) continue;\n\t\tx = a[i].id;\n\t\tret += n - j;\n\t\tfor (map<int, int>::iterator itr=S[x].begin(); itr != S[x].end(); itr++){\n\t\t\ttx = itr->first;\n\t\t\tty = itr->second;\n\t\t\tif (v[tx]) continue;\n\t\t\tif (d[tx] + d[x] >= m && d[tx] + d[x] - ty < m) --ret;\n\t\t}\n\t\tv[x] = 1;\n\t}\n\t\n\tprintf(""%I64d\\n"", ret);\n\treturn 0;\n}\n']",,,"['data structures', 'graphs', 'implementation', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Bug in Code.json,https://codeforces.com//blog/entry/11871,Lets construct an undirected graph the vertices of the graph are the persons there is an edge between two persons if there are claim of some person about these two persons Now we can describe the problem on this graph We need to find the number of such pairs of vertices that at least edges are adjacent to them How to count such pairs Just for each vertex to calculate the number of vertices such that then we should consider all the adjacent vertices correctly Iterate through all the edges and subtract such the vertices from the answer Then iterate through adjacent vertices and add only such of them that is needed to be added Pay attention to multiple edges they should be considered very carefully 
https://codeforces.com//contest/1523/problem/A,1000211,A,1523A,1523,A. Game of Life,William really likes the cellular automaton called Game of Life so he decided to make his own version For simplicity William decided to define his cellular automaton on an array containing n cells with each cell either being alive or dead Evolution of the array in William s cellular automaton occurs iteratively in the following way If the element is dead and it has 1 alive neighbor then on the next iteration it will become alive For an element at index i the neighbors would be elements with indices i 1 and i 1 If there is no element at that index it is considered to be a dead neighbor William is a humane person so all alive elements stay alive Check the note section for examples of the evolution You are given some initial state of all elements and you need to help William find the state of the array after m iterations of evolution ,"[""/**\n *    author:  tourist\n *    created: 30.05.2021 17:34:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int beg = 0;\n    while (beg < n) {\n      if (s[beg] == '1') {\n        ++beg;\n        continue;\n      }\n      int end = beg;\n      while (end + 1 < n && s[end + 1] == '0') {\n        ++end;\n      }\n      if (beg == 0 && end == n - 1) {\n      } else {\n        if (beg == 0) {\n          for (int j = end; j >= beg && j >= end - m + 1; j--) {\n            s[j] = '1';\n          }\n        } else {\n          if (end == n - 1) {\n            for (int j = beg; j <= end && j <= beg + m - 1; j++) {\n              s[j] = '1';\n            }\n          } else {\n            int i = beg;\n            int j = end;\n            for (int it = 0; i < j && it < m; it++) {\n              s[i] = s[j] = '1';\n              i += 1;\n              j -= 1;\n            }\n          }\n        }\n      }\n      beg = end + 1;\n    }\n    cout << s << '\\n';\n  }\n  return 0;\n}\n""]",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. Game of Life.json,https://codeforces.com//blog/entry/91271,Notice that evolution will go on for no more than iterations since on each iteration at least one new living cell will appear and if it doesn t this would mean that we remain in the same state as on the previous step and the simulation is over Knowing this we can write a simple simulation of the process described in the problem statement which would process each iteration in Final complexity 
https://codeforces.com//contest/936/problem/B,159977,B,936B,936,B. Sleepy Game,Petya and Vasya arranged a game The game runs by the following rules Players have a directed graph consisting of vertices and edges One of the vertices contains a chip Initially the chip is located at vertex Players take turns moving the chip along some edge of the graph Petya goes first Player who can t move the chip loses If the game lasts for turns the draw is announced Vasya was performing big laboratory work in Spelling and parts of speech at night before the game so he fell asleep at the very beginning of the game Petya decided to take the advantage of this situation and make both Petya s and Vasya s moves Your task is to help Petya find out if he can win the game or at least draw a tie ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nint N, M, S;\nvector<int> Adj[MaxN];\n\nbool Reachable[MaxN][2];\nint PrevVert[MaxN][2];\n\nvoid dfs(int v, int x) {\n  Reachable[v][x] = true;\n  for (int s : Adj[v])\n    if (!Reachable[s][x ^ 1]) {\n      PrevVert[s][x ^ 1] = v;\n      dfs(s, x ^ 1);\n    }\n}\n\nint Vis[MaxN];\n\nbool dfsCycle(int v) {\n  Vis[v] = 1;\n  for (int s : Adj[v]) {\n    if (Vis[s] == 1) { return true; }\n    if (Vis[s] == 0 && dfsCycle(s))\n      return true;\n  }\n\n  Vis[v] = 2;\n  return false;\n}\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> M;\n  for (int i = 1; i <= N; ++i) {\n    int c; cin >> c;\n    for (int j = 0; j < c; ++j) {\n      int v;\n      cin >> v;\n      Adj[i].PB(v);\n    }\n  }\n\n  cin >> S;\n  dfs(S, 0);\n\n  for (int i = 1; i <= N; ++i) {\n    if (SZ(Adj[i]) == 0 && Reachable[i][1]) {\n      cout << ""Win\\n"";\n      vector<int> Res;\n      int v = i, x = 1;\n      Res.push_back(v);\n      while (v != S || x != 0) {\n        v = PrevVert[v][x];\n        x ^= 1;\n        Res.push_back(v);\n      }\n\n      reverse(ALL(Res));\n      for (int s : Res) { cout << s << "" ""; }\n      cout << ""\\n"";\n      return 0;\n    }\n  }\n\n  if (dfsCycle(S))\n    cout << ""Draw\\n"";\n  else\n    cout << ""Lose\\n"";\n}\n\n']",,,"['dfs and similar', 'dp', 'games', 'graphs']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Sleepy Game.json,https://codeforces.com//blog/entry/58056,Note that the answer is sequence of adjacent vertices of even length such that the last vertex of this sequence has no outgoing edges Build state graph as follows State is pair where is vertex of initial graph and is parity of count of vertices on path from to For every edge of initial graph add edges and in state graph So there exists path from to if and only if there exists path from to in initial graph of parity Lets find all reachable from states using BFS or DFS If there is state among them such that has no outgoing edges in initial graph then Petya can win He can move along vertices in path from to in state graph Otherwise we need to check if Petya can make moves for drawing a tie If there is a tie then the chip visited some vertex twice because Therefore it is sufficient to check if there is a cycle in initial graph reachable from In this case Petya can play as follows move to any vertex of cycle and then move along the cycle as long as it requires to draw a tie 
https://codeforces.com//contest/1263/problem/E,483581,E,1263E,1263,E. Editor,The development of a text editor is a hard problem You need to implement an extra module for brackets coloring in text Your editor consists of a line with infinite length and cursor which points to the current character Please note that it points to only one of the characters and not between a pair of characters Thus it points to an index character The user can move the cursor left or right one position If the cursor is already at the first leftmost position then it does not move left Initially the cursor is in the first leftmost character Also the user can write a letter or brackets either or to the position that the cursor is currently pointing at A new character always overwrites the old value at that position Your editor must check whether the current line is the Text is correct if the brackets in them form the Formally correct text CT must satisfy the following rules any line without brackets is CT the line can contain whitespaces If the first character of the string is the last is and all the rest form a CT then the whole line is a CT two consecutively written CT is also CT Examples of correct texts Examples of incorrect texts The user uses special commands to work with your editor Each command has its symbol which must be written to execute this command The correspondence of commands and characters is as follows move the cursor one character to the left remains in place if it already points to the first character move the cursor one character to the right any lowercase Latin letter or bracket or write the entered character to the position where the cursor is now For a complete understanding take a look at the first example and its illustrations in the note below You are given a string containing the characters that the user entered For the brackets coloring module s work after each command you need to check if the current text in the editor is a correct text if it is print the least number of colors that required to color all brackets If two pairs of brackets are nested the first in the second or vice versa then these pairs of brackets should be painted in colors If two pairs of brackets are not nested then they can be painted in different or the same colors For example for the bracket sequence the least number of colors is 2 and for the bracket sequence is 3 Write a program that prints the minimal number of colors after processing each command ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n#include <iostream>\n\nusing namespace std;\n\n#define BT 1048576\n\nstruct node_t {\n  int minv, maxv;\n  int add;\n};\n\nnode_t tree[BT * 2];\n\nvoid refresh(int p) {\n  if (p >= BT) {\n    tree[p].minv = tree[p].maxv = tree[p].add;\n    return;\n  }\n  tree[p].minv = min(tree[p * 2].minv, tree[p * 2 + 1].minv) + tree[p].add;\n  tree[p].maxv = max(tree[p * 2].maxv, tree[p * 2 + 1].maxv) + tree[p].add;\n}\nvoid update(int l, int r, int add) {\n  l |= BT, r |= BT;\n  int oL = l, oR = r;\n  while (l <= r) {\n    if (l & 1){\n      tree[l].add += add;\n      tree[l].minv += add;\n      tree[l].maxv += add;\n    }\n    if (!(r & 1)) {\n      tree[r].add += add;\n      tree[r].minv += add;\n      tree[r].maxv += add;\n    }\n    l = (l + 1) >> 1;\n    r = (r - 1) >> 1;\n  }\n  tie(l, r) = tie(oL, oR);\n  while (l >= 1) {\n    refresh(l);\n    refresh(r);\n    l >>= 1;\n    r >>= 1;\n  }\n}\n\nint get_point(int p) {\n  p |= BT;\n  int ans = 0;\n  while (p >>= 1) {\n    ans += tree[p].add;\n  }\n  return ans;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  string command;\n  cin >> command;\n\n  string line(BT, \' \');\n  int pos = 0;\n  for (int i = 0; i < n; i++) {\n    if (command[i] == \'L\') {\n      pos = max(0, pos - 1);\n    } else if (command[i] == \'R\') {\n      pos++;\n    } else {\n      if (line[pos] == \'(\') {\n        update(pos, BT - 1, -1);\n      } else if (line[pos] == \')\') {\n        update(pos, BT - 1, 1);\n      }\n      line[pos] = command[i];\n      if (line[pos] == \'(\') {\n        update(pos, BT - 1, 1);\n      } else if (line[pos] == \')\') {\n        update(pos, BT - 1, -1);\n      }\n    }\n    int ans = -1;\n    if (get_point(BT - 1) == 0 && tree[1].minv >= 0) {\n      ans = tree[1].maxv;\n    }\n    cout << ans << (i + 1 == n ? ""\\n"" : "" "");\n  }\n  return 0;\n}\n']",,,"['data structures', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Editor.json,https://codeforces.com/blog/entry/71844?locale=en,To respond to requests you need two stacks The first stack will contain all the brackets at the positions left than the cursor position and the second one all the remaining ones Also for each closing bracket in the first stack we will maintain the maximum depth of the correct bracket sequence CBS ending with this bracket Similarly in the second stack we will maintain the maximum depth of CBS that starting in this bracket Since the brackets are added to the stack at the end and one at a time you can easily recalculate this value Even in the left stack you need to maintain the number of opening brackets that do not have a pair of closing brackets and in the right stack the number of closing brackets that do not have a pair of opening brackets If the previous two values are equal then the current line is CBS Otherwise there is either one non closed bracket or one bracket that does not have an opening one The answer to the problem after each query will be a maximum of three values the maximum depth in the left stack the maximum depth in the right stack and the number of non closed brackets the number of non opened brackets in the right stack does not need to be taken into account since if the line is CBS then it is the number of open brackets in the left Total complexity is 
https://codeforces.com//contest/1554/problem/A,1061271,A,1554A,1554,A. Cherry,You are given n integers a 1 a 2 ldots a n Find the maximum value of max a l a l 1 ldots a r cdot min a l a l 1 ldots a r over all pairs l r of integers for which 1 le l r le n ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint T,n,a[100010];\nint main(){\n    scanf(""%d"",&T);\n    while(T--){\n        scanf(""%d"",&n);\n        for(int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n        long long ans=0;\n        for(int i=1;i<n;i++){\n            ans=max(ans,1ll*a[i]*a[i+1]);\n        }\n        printf(""%lld\\n"",ans);\n    }\n    return 0;\n}']",,,['greedy'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Cherry.json,https://codeforces.com//blog/entry/93321,Do we really need to check all the subarrays Consider a subarray If we add a new element when will the new subarray give a better result Pause and think The minimum of the new subarray can t get better the minimum of a smaller subarray the minimum of a larger subarray So only when is greater than the previous maximum then it will give a better result But in that case do we really need to check the whole subarray to get that result Can we get the same or a better result from a smaller subarray Think Here the maximum is So if the minimum is not then the subarray will give the same result Otherwise the minimum of will not be smaller which implies that will give a better result So if we add a new element we don t have to check the whole subarray checking and is enough What good this observation just brought to this world Think Yes we don t have to check subarrays with length because according to the observation won t give a better result than and And subarrays with length won t give a better result than subarrays with length and subarrays with length won t give a better result than subarrays with length You got the idea right Another thing to notice here is that the product of maximum and minimum of two integers is just the product of two integers So the answer to the problem is the maximum of the products of adjacent elements in 
https://codeforces.com//contest/1893/problem/E,2312789,E,1893E,1893,E. Cacti Symphony,You are given an undirected connected graph in which any two distinct simple cycles common vertices Since the graph can be very large it is given to you in a compressed form for each edge you are also given a number d which indicates that there are d additional vertices on this edge You need to assign a weight to each vertex and each edge of the graph an integer from 1 to 3 An edge of the graph is called if the bitwise XOR of the weights of its adjacent vertices is 0 and the weight of that edge Similarly a vertex of the graph is called if the bitwise XOR of the weights of its adjacent edges is 0 and the weight of that vertex You need to determine how many ways there are to assign weights to the vertices and edges of the graph so that all vertices and edges are Since the answer can be quite large you need to calculate the remainder of the answer divided by 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT  (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n// i  idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n// sortidx  idx \n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\n//mint107  verify \n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 \n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n//KUPC 2020 C\n//XXII Opencup GP of Gomel E\n//verify\n\n// cactus \n//cs \n//dfs ->\n//cs  2 \n//\ntemplate<class E>\nstruct cactus{\n\tconst vvc<E>&g;\n\tconst int n;\n\tvvc<E> cs;\n\tvi vis,par,u;\n\tvc<E> come;\n\tvc<bool> done;\n\tvoid dfs(int v,int p,E co){\n\t\tassert(vis[v]==0);\n\t\tvis[v]=1;\n\t\tpar[v]=p;\n\t\tcome[v]=co;\n\t\tE gopar;\n\t\tfor(auto e:g[v]){\n\t\t\tif(e==p){\n\t\t\t\tgopar=e;\n\t\t\t}else if(vis[e]==0){\n\t\t\t\tdfs(e,v,e);\n\t\t\t}else if(vis[e]==1){\n\t\t\t\tint x=v;\n\t\t\t\tvc<E> z{e};\n\t\t\t\twhile(x!=e){\n\t\t\t\t\tassert(!done[x]);\n\t\t\t\t\tdone[x]=true;\n\t\t\t\t\tz.pb(come[x]);\n\t\t\t\t\tx=par[x];\n\t\t\t\t}\n\t\t\t\treverse(all(z));\n\t\t\t\tcs.pb(z);\n\t\t\t}\n\t\t}\n\t\tif(p!=-1&&!done[v]){\n\t\t\tdone[v]=true;\n\t\t\tcs.pb({co,gopar});\n\t\t}\n\t\tvis[v]=2;\n\t}\n\tcactus(const vvc<E>&gg):g(gg),n(g.size()),vis(n),par(n),u(n),come(n),done(n){\n\t\trep(i,n)if(!vis[i])\n\t\t\tdfs(i,-1,E());\n\t}\n};\nstruct E{\n\tint to,dist;\n\toperator int()const{return to;}\n};\n\nbool dbg=false;\n\nconst int D=40000;\nmint transA[4][D+1][4];\nmint transB[4][D+1][4];\nvoid inittrans(){\n\trng(init,1,4){\n\t\ttransA[init][0][init]=1;\n\t\trep(i,D){\n\t\t\trng(j,1,4)rng(k,1,4)if(j!=k){\n\t\t\t\ttransA[init][i+1][k]+=transA[init][i][j];\n\t\t\t}\n\t\t}\n\t}\n\trng(init,1,4){\n\t\ttransB[init][0][init]=1;\n\t\trep(i,D){\n\t\t\trng(j,1,4)rng(k,1,4){\n\t\t\t\ttransB[init][i+1][k]+=transB[init][i][j]*transA[j][D][k];\n\t\t\t}\n\t\t}\n\t}\n}\n\nmint trans(int init,int d,int to){\n\tint u=d/D,v=d%D;\n\tmint res;\n\trng(k,1,4)res+=transB[init][u][k]*transA[k][v][to];\n\treturn res;\n}\n\nusing A=array<array<mint,4>,4>;\n\nA mg(const A&a,const A&b){\n\tA res{};\n\trng(x,1,4)rep(y,4)rep(z,4){\n\t\tres[x][y^z]+=a[x][y]*b[x][z];\n\t}\n\treturn res;\n}\n\nA up(const A&a,int d){\n\tA res;\n\trng(x,1,4)rep(y,4)rng(z,1,4)if(0!=(y^z)&&x!=(y^z)){\n\t\tif(z==x){\n\t\t\trng(w,1,4)rng(v,1,4)if(w!=v)\n\t\t\t\tres[v][w]+=a[x][y]*trans(z,d-1,w);\n\t\t}else{\n\t\t\trng(w,1,4)\n\t\t\t\tres[w][w]+=a[x][y]*trans(z,d-1,w);\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<E> g(n);\n\trep(i,m){\n\t\tint a,b,d;cin>>a>>b>>d;\n\t\ta--;b--;\n\t\td++;\n\t\tg[a].pb({b,d});\n\t\tg[b].pb({a,d});\n\t}\n\t\n\tcactus<E> cc(g);\n\t\n\t//int s=n+si(cc.cs);\n\t//vvc<int> t(s);\n\tvvc<int> t(n);\n\trep(i,si(cc.cs)){\n\t\t/*rep(j,si(cc.cs[i])){\n\t\t\tint v=cc.cs[i][j];\n\t\t\tif(j+1<si(cc.cs[i])-1)\n\t\t\t\tt[n+i].pb(v);\n\t\t\telse\n\t\t\t\tt[v].pb(n+i);\n\t\t}*/\n\t\tt[cc.cs[i].back()].pb(i);\n\t}\n\t\n\tauto dfs=[&](auto self,int v)->A{\n\t\tdmp(v);\n\t\tassert(v<n);\n\t\tA res;\n\t\trng(x,1,4)res[x][0]=1;\n\t\tfor(int c:t[v]){\n\t\t\tint len=si(cc.cs[c])-1;\n\t\t\tvc<A> buf(len);\n\t\t\trep(i,len)buf[i]=self(self,cc.cs[c][i]);\n\t\t\tif(len==1){\n\t\t\t\t//edge\n\t\t\t\tres=mg(res,up(buf[0],cc.cs[c][0].dist));\n\t\t\t}else if(len>=2){\n\t\t\t\tA sum{};\n\t\t\t\tint d=cc.cs[c].back().dist;\n\t\t\t\t{\n\t\t\t\t\trng(w,1,4){\n\t\t\t\t\t\tA cur{};\n\t\t\t\t\t\tper(step,len){\n\t\t\t\t\t\t\t//dmp(step);\n\t\t\t\t\t\t\tif(step==len-1){\n\t\t\t\t\t\t\t\trng(x,1,4)if(x==w)rep(y,4)cur[x][y^w]+=buf[len-1][x][y];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcur=mg(cur,buf[step]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//dmp2(cur);\n\t\t\t\t\t\t\tcur=up(cur,cc.cs[c][step].dist);\n\t\t\t\t\t\t\t//dmp2(cur);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(u,1,4)rng(x,1,4)if(u!=x)rep(y,4)\n\t\t\t\t\t\t\tsum[x][y^u]+=cur[x][y]*trans(w,d-1,u);\n\t\t\t\t\t\tdmp(sum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\trng(w,1,4){\n\t\t\t\t\t\tA cur{};\n\t\t\t\t\t\tper(step,len){\n\t\t\t\t\t\t\tif(step==len-1){\n\t\t\t\t\t\t\t\trng(x,1,4)if(x!=w)rep(y,4)cur[x][y^w]+=buf[len-1][x][y];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcur=mg(cur,buf[step]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur=up(cur,cc.cs[c][step].dist);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(u,1,4)rng(x,1,4)if(u==x)rep(y,4)\n\t\t\t\t\t\t\tsum[x][y^u]+=cur[x][y]*trans(w,d-1,u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdmp(sum);\n\t\t\t\tres=mg(res,sum);\n\t\t\t}else{\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t};\n\tA ans=dfs(dfs,0);\n\t\n\tmint res=0;\n\trng(x,1,4)rng(y,1,4)if(x!=y)res+=ans[x][y];\n\tprint(res);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinittrans();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']",,,"['combinatorics', 'dfs and similar', 'dp', 'graphs']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Cacti Symphony.json,https://codeforces.com//blog/entry/122074,First observation for each edge the vertices connected by it have different weights otherwise the XOR of the weights of the adjacent vertices of this edge is equal to Second observation for each edge one of its adjacent vertices has a weight equal to the weight of the edge since From these two observations it follows that each edge has the same weight as one of the vertices it is connected to Let s say that a vertex all the adjacent edges with the same weight Then each edge is controlled by exactly one vertex Third observation if a vertex has an even degree then the number of edges controlled by it must be odd and this is a sufficient condition for the vertex to be good Fourth observation if a vertex has an odd degree then the number of edges controlled by it must be even and this is a sufficient condition for the vertex to be good Therefore in order for all vertices to be good it is necessary to choose who controls each edge in such a way that the parity of the vertex degree and the parity of the number of edges controlled by it are different And in order for all edges to be good it is necessary to assign weights from to to the vertices in such a way that no two adjacent vertices have the same weight The weight of each edge will then be equal to the weight of the vertex it is controlled by Now the problem is divided into two independent parts finding the number of ways to assign weights to the vertices and finding the number of ways to orient the edges The answer to the original problem will be the product of the answers to these two parts How many ways are there to color the vertices with colors such that two adjacent vertices are colored differently How many ways are there to orient the edges such that a vertex with an even degree has an odd number of outgoing edges and a vertex with an odd degree has an even number of outgoing edges Solution to problem 1 note that if there is a bridge in the graph and it divides the graph into graphs and then the answer for is the product of the answers for and multiplied by Then we can identify all the bridges and since the graph is a vertex cactus after removing the bridges the graph will be divided into cycle components For a cycle of length the number of ways to color the vertices can be calculated using simple dynamic programming To prove this dynamic programming consider any two vertices that are one apart in a cycle of length If they have the same color then the vertex between them has possible colors and the rest have possibilities If they have different colors then there are possibilities Knowing the transition formula we can notice that This formula can be trivially proved by induction Solution to problem 2 we will solve the same problem but requiring that each vertex has an odd number of outgoing edges if we invert all the edges in such a graph we will get what is required If and have different parity then the answer is since the sum of odd numbers which are the degrees of the vertices must be equal to Otherwise the answer is At any moment we can remove any leaf as it does not solve anything We will remove the leaves as long as they exist After this one of the cycles in the graph will be a leaf connected only to one other cycle For all vertices of this cycle the necessary parities of the degrees are known Choose any edge of the cycle and orient it there are ways to orient it both will work After that all other edges in the cycle are oriented uniquely After that the bridge between this cycle and the other one is also uniquely oriented Now we have one less cycle and we also know all the necessary parities of the vertices the parity changes for the vertex where the bridge came in In this way we can gradually reduce the number of cycles With each removal of a cycle the answer is multiplied by since there are ways to orient the edge in the cycle In the end we get ways The final answer to the problem if and have same parity is where are the sizes of cycles cycle can be a single vertice if it did not lie on any other cycle and in this case 
https://codeforces.com//contest/1242/problem/C,461421,C,1242C,1242,C. Sum Balance,Ujan has a lot of numbers in his boxes He likes order and balance so he decided to reorder the numbers There are k boxes numbered from 1 to k The i th box contains n i integer numbers The integers can be negative Ujan is lazy so he will do the following reordering of the numbers He will pick a single integer from each of the boxes k integers in total Then he will insert the chosen numbers one integer in each of the boxes so that the number of integers in each box is the same as in the beginning Note that he may also insert an integer he picked from a box back into the same box Ujan will be happy if the sum of the integers in each box is the same Can he achieve this and make the boxes perfectly balanced like all things should be ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint k;\nvi a[15];\nvi ok[1<<15];\nll avg, sum[15];\nmap<ll,int> m;\nint pre[1<<15];\n\nvoid bad() {\n\tps(""No"");\n\texit(0);\n}\n\nvoid makeCyc(int a, int b) {\n\tvi res(k,MOD);\n\tpi ori = {a,b}; res[a] = b;\n\twhile (1) {\n\t\tll nex = avg-(sum[a]-b);\n\t\tif (m.count(nex)) {\n\t\t\ttie(a,b) = mp(m[nex],nex);\n\t\t\tif (res[a] == MOD) res[a] = b;\n\t\t\telse {\n\t\t\t\tif (a == ori.f && b == ori.s) {\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tF0R(i,k) if (res[i] != MOD) mask ^= 1<<i;\n\t\t\t\t\tok[mask] = res;\n\t\t\t\t\t// ps(""WUT"",mask,res);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else return;\n\t}\n}\n\nint main() {\n\tsetIO(); re(k);\n\tF0R(i,k) {\n\t\tint n; re(n); a[i].rsz(n); re(a[i]);\n\t\ttrav(t,a[i]) {\n\t\t\tm[t] = i;\n\t\t\tsum[i] += t;\n\t\t}\n\t\tavg += sum[i];\n\t}\n\tif (avg%k != 0) bad();\n\tavg /= k;\n\tF0R(i,k) trav(t,a[i]) makeCyc(i,t);\n\tF0R(i,1<<k) pre[i] = MOD;\n\tpre[0] = -1;\n\tFOR(i,1,1<<k) {\n\t\tint j = i;\n\t\twhile (j) {\n\t\t\tj = (j-1)&i;\n\t\t\tif (sz(ok[i^j]) && pre[j] != MOD) pre[i] = j;\n\t\t}\n\t}\n\tint cur = (1<<k)-1;\n\tif (pre[cur] == MOD) bad();\n\tps(""Yes"");\n\tvi tmp(k,MOD);\n\twhile (cur != 0) {\n\t\tF0R(i,sz(ok[cur^pre[cur]])) ckmin(tmp[i],ok[cur^pre[cur]][i]);\n\t\tcur = pre[cur];\n\t}\n\tF0R(i,k) sum[i] -= tmp[i];\n\tF0R(i,k) {\n\t\tint ind = 0;\n\t\twhile (sum[ind] != avg-tmp[i]) ind ++;\n\t\tps(tmp[i],ind+1);\n\t}\n\t// ps(""HA"",avg,ok[(1<<3)-1]);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']",,,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Sum Balance.json,https://codeforces.com//blog/entry/71216,First calculate the total average sum If the answer is positive the sum of integers in each box must be equal to after reordering If is not integer then the answer is immediately negative Now suppose that an integer is taken out of some box Then we know that it should be replaced by We then construct a graph where all of the given integers are vertices and we draw a directed edge from to Note that we obtain a functional graph Examine all of the cycles of this graph since this a functional graph no two cycles share the same vertex Let then the total number of cycles is at most Examine any valid reordering It is easy to see that it is a collection of cycles from the obtained graph such that each box is visited by some cycle exactly once Therefore lets extract all of the cycles from our graph such that do not pass through the same box twice A valid reordering then is some subset of these cycles that visit all of the boxes exactly once We can also reformulate this problem in the following way each of the extracted cycles visits some set of boxes Find all of such subsets the number of such subsets is at most Now the problem is reduced to exactly covering the set with some subset of such sets This is a classical problem that can be solved in using dynamic programming For a subset of define to be if can be exactly covered and otherwise Firstly To find for iterate over all subsets of and check whether is visited by some cycle and can be covered e g is Then the answer is This algorithm can be implemented with complexity you can read about it here https cp algorithms com algebra all submasks html The reordering can be restored from this DP table The total complexity of the algorithm 
https://codeforces.com//contest/2023/problem/E,2964368,E,2023E,2023,E. Tree of Life,In the heart of an ancient kingdom grows the legendary Tree of Life the only one of its kind and the source of magical power for the entire world The tree consists of n nodes Each node of this tree is a magical source connected to other such sources through magical channels edges In total there are n 1 channels in the tree with the i th channel connecting nodes v i and u i Moreover there exists a unique simple path through the channels between any two nodes in the tree However the magical energy flowing through these channels must be balanced otherwise the power of the Tree of Life may disrupt the natural order and cause catastrophic consequences The sages of the kingdom discovered that when two magical channels converge at a single node a dangerous magical resonance vibration occurs between them To protect the Tree of Life and maintain its balance it is necessary to select several paths and perform special rituals along them A path is a sequence of distinct nodes v 1 v 2 ldots v k where each pair of adjacent nodes v i and v i 1 is connected by a channel When the sages perform a ritual along such a path the resonance vibration between the channels v i v i 1 and v i 1 v i 2 is blocked for each 1 leq i leq k 2 The sages task is to select the minimum number of paths and perform rituals along them to block all resonance vibrations This means that for every pair of channels emanating from a single node there must exist selected path that contains of these channels Help the sages find the minimum number of such paths so that the magical balance of the Tree of Life is preserved and its power continues to nourish the entire world ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        i64 ans = 0;    for (int i = 0; i < n; i++) {        i64 d = adj[i].size();        ans += d * (d - 1) / 2;    }    std::vector<i64> f(n), g(n);    auto dfs = [&](this auto &&self, int x, int p) -> void {        i64 d = adj[x].size();                i64 max = 0;        for (auto y : adj[x]) {            if (y == p) {                continue;            }            self(y, x);                        i64 t = std::min(d - 1, f[y]);            f[y] -= t;            ans -= t;                        t = d - 1 - t;            i64 v = std::min(t, 2 * g[y]);            ans -= v;                        g[y] -= v / 2;            if (v % 2 == 1) {                g[y]--;                f[y]++;            }                        g[x] += g[y];            f[x] += f[y];            max = std::max(max, f[y]);        }                if (max * 2 > f[x]) {            i64 v = g[x];            for (auto y : adj[x]) {                if (y == p) {                    continue;                }                if (f[y] == max) {                    v -= g[y];                    break;                }            }            g[x] += f[x] - max;            f[x] = max * 2 - f[x];            v = std::min(v, f[x] / 2);            f[x] -= 2 * v;            g[x] += v;        } else {            g[x] += f[x] / 2;            f[x] %= 2;        }                f[x] += d - 1;    };    dfs(0, -1);        ans -= g[0];        std::cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }\xa0    return 0;}']",,,"['dp', 'greedy', 'trees']",3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Tree of Life.json,https://codeforces.com//blog/entry/135341,This problem has several solutions that are similar to varying degrees We will describe one of them We will apply the following greedy approach We will construct the answer by combining the answers for the subtrees To do this we will perform a depth first traversal and when exiting a vertex we return a triplet where is the minimum number of paths needed to cover all pairs of adjacent edges in the subtree considering the edge upwards is the number of edges upwards and is the number of paths that are connected at some vertex of the subtree but can be separated into two paths upwards without violating the coverage Then if we are at vertex and receive from child the triplet we need to increase to at least to satisfy the coverage Next we will effectively reduce it by implying that we have satisfied all such pairs Meanwhile we will sum and and subtract from when connecting We first increase using and then simply by adding new paths After this we have remaining excess paths leading to which we might be able to combine to reduce the answer This is represented by the set If we can combine all pairs leaving at most path upwards in adding these paths to Otherwise we increase all using until is satisfied Finally we return if the condition is met and while and are the sums that may have changed during the process Don t forget to account for the paths that merged at The root needs to be handled separately as there are no paths upwards there To prove this solution one can consider the minimum number of paths needed to cover subtree if paths go upwards It is not hard to notice that the triplet in the greedy solution describes all optimal states of the dynamic programming P S Strict proofs are left as an exercise for the reader 
https://codeforces.com//contest/282/problem/B,2736,B,282B,282,B. Painting Eggs,The Bitlandians are quite weird people They have very peculiar customs As is customary Uncle J wants to have eggs painted for Bitruz an ancient Bitland festival He has asked G and A to do the work The kids are excited because just as is customary they re going to be paid for the job Overall uncle J has got eggs G named his price for painting each egg Similarly A named his price for painting each egg It turns out that for each egg the sum of the money both A and G want for the painting equals Uncle J wants to distribute the eggs between the children so as to give each egg to exactly one child Also Uncle J wants the total money paid to A to be different from the total money paid to G by no more than Help Uncle J Find the required distribution of eggs or otherwise say that distributing the eggs in the required manner is impossible ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define LL long long\n#define maxn 200100\n#define maxe 210000\n\nint a[1100000],b[1100000];\nchar s[1100000];\n\nint cal(int n,int now)\n{\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(s[i]==\'A\')\n\t\t{\n\t\t\tif(abs(now-1000)<abs(now))\n\t\t\t\tnow-=1000,s[i]=\'G\';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(abs(now+1000)<abs(now))\n\t\t\t\tnow+=1000,s[i]=\'A\';\n\t\t}\n\t}\n\treturn now;\n}\nint main()\n{\n\tint n,i,j;\n\tint now=0;\n\n\tscanf(""%d"",&n);\n\tint aa,bb;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d%d"",&aa,&bb);\n\t\n\t\ta[i]=aa,b[i]=bb;\n\t\tif(abs(now+aa)<abs(now-bb))\n\t\t\tnow+=a[i],s[i]=\'A\';\n\t\telse\n\t\t\tnow-=b[i],s[i]=\'G\';\n\t}\n\twhile(abs(now)>500)\n\t{\n\t\tint t=now;\n\t\tnow=cal(n,now);\n\t\tif(abs(t)==abs(now))\n\t\t\tbreak;\n\t}\n\tif(abs(now)>500)\n\t\tputs(""-1"");\n\telse\n\t\tprintf(""%s\\n"",s+1);\n}']",,,"['greedy', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Painting Eggs.json,https://codeforces.com//blog/entry/6999,This one can be solved by a greedy algorithm Start from the 1st egg and each time give the egg to A if and only if giving it to A doesn t make the difference 500 otherwise give it to G To prove the correctness one can use induction The base case is trivial Suppose that we ve assigned the first n 1 eggs such that the total money given to A is Sa and total money given to G is Sg We can assume Sa Sg Now we must either add gn to Sg or add an to Sa If we can t add gn to Sg then Sg gn Sa 500 so 500 Sa Sg gn adding 1000 to both sides gives us the inequality 500 Sa 1000 gn Sg which is exactly what we need to make sure that we can add an 1000 gn to Sa 
https://codeforces.com//contest/1454/problem/F,808365,F,1454F,1454,F. Array Partition,You are given an array a consisting of n integers Let min l r be the minimum value among a l a l 1 ldots a r and max l r be the maximum value among a l a l 1 ldots a r Your task is to choose three greater than 0 integers x y and z such that x y z n max 1 x min x 1 x y max x y 1 n In other words you have to split the array a into three consecutive non empty parts that cover the whole array and the maximum in the first part equals the minimum in the second part and equals the maximum in the third part or determine it is impossible to find such a partition Among all such triples partitions you can choose any You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nstruct DSU {\n    vector<int> e;\n    void init(int n) {\n        e = vector<int>(n, -1);\n    }\n    int get(int x) {\n        return e[x] < 0 ? x : e[x] = get(e[x]);\n    }\n    bool same_set(int a, int b) {\n        return get(a) == get(b);\n    }\n    int size(int x) {\n        return -e[get(x)];\n    }\n    bool unite(int x, int y) {\n        x = get(x), y = get(y);\n        if (x == y) return false;\n        if (e[x] > e[y]) swap(x, y);\n        e[x] += e[y]; e[y] = x;\n        return true;\n    }\n};\ntemplate<class T> struct RMQ { // floor(log_2(x))\n    int level(int x) { return 31-__builtin_clz(x); } \n    vector<T> v; vector<vi> jmp;\n    int comb(int a, int b) { // index of min\n        return v[a]==v[b]?min(a,b):(v[a]<v[b]?a:b); } \n    void init(const vector<T>& _v) {\n        v = _v; jmp = {vi(sz(v))}; iota(all(jmp[0]),0);\n        for (int j = 1; 1<<j <= sz(v); ++j) {\n            jmp.pb(vi(sz(v)-(1<<j)+1));\n            F0R(i,sz(jmp[j])) jmp[j][i] = comb(jmp[j-1][i],\n                                    jmp[j-1][i+(1<<(j-1))]);\n        }\n    }\n    int index(int l, int r) { // get index of min element\n        assert(l <= r); int d = level(r-l+1);\n        return comb(jmp[d][l],jmp[d][r-(1<<d)+1]); }\n    T query(int l, int r) { return v[index(l,r)]; }\n};\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        RMQ<int> R;\n        R.init(a);\n        vi pre(n);\n        vi suf(n);\n        f0r(i, n) {\n            if (i == 0) pre[i] = a[i];\n            else pre[i] = max(pre[i-1], a[i]);\n        }\n        for (int i = n-1; i >= 0; i--) {\n            if (i == n-1) suf[i] = a[i];\n            else suf[i] = max(suf[i+1], a[i]);\n        }\n        auto check = [&](int x, int y) -> bool {\n            if (x < 0 || y >= n) return false;\n            if (y - x <= 1) return false;\n            if (suf[y] != pre[x]) return false;\n            if (pre[x] != R.query(x+1, y-1)) return false;\n            return true;\n        };\n        bool ok = false;\n        pi res;\n        f1r(i, 2, n) {\n            int val = suf[i];\n            int lo = 0;\n            int hi = i-1;\n            while (hi - lo > 1) {\n                int mid = (lo + hi) / 2;\n                if (pre[mid] <= val) lo = mid;\n                else hi = mid - 1;\n            }\n            {\n                if (!ok && check(lo, i)) {\n                    ok = true;\n                    res = {lo, i};\n                } \n                if (!ok && check(lo - 1, i)) {\n                    ok = true;\n                    res = {lo - 1, i};\n                }\n                if (!ok && check(hi, i)) {\n                    ok = true;\n                    res = {hi, i};\n                }\n                if (!ok && check(hi - 1, i)) {\n                    ok = true;\n                    res = {hi - 1, i};\n                }\n            }\n            if (ok) break;\n        }\n        if (ok) {\n            ps(""YES"");\n            int x = res.f + 1;\n            int y = res.s - res.f - 1;\n            int z = n - x - y;\n            ps(x, y, z);\n        } else {\n            ps(""NO"");\n        }\n    }\n    return 0;\n}']",,,"['binary search', 'data structures', 'greedy', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Array Partition.json,https://codeforces.com//blog/entry/84984,Let s fix the length of the first block iterate through from to Let s also try to maximize the length of the third block using the second pointer So initially the length of the first block is and the maximum in the block is after that its length will be and the maximum will be and so on Let s move the left border of the third block while and the second block have at least one element After we expanded the third block consider some cases if its maximum is less than then we don t need to consider this partition we expanded the third block as much as we can but didn t find the required maximum Otherwise its maximum fits our conditions Then let s find the minimum in the second block Let it be If this partition is also bad If this partition is good and we can just print it Otherwise and we need to fix the second block somehow I claim that we only need to expand it by at most one element Let s see why is it true Consider we want to expand it to the right the other case just uses the same logic If we expanded our block by one element to the right and the new value in it is less than then this partition is bad and we can not use it this is also the reason why we are trying to maximize the length of the third block Otherwise this value is always because the first and the third blocks didn t have values greater than There are some cases in the implementation we need to consider carefully first we need to find the minimum in the second block fast enough This can be done if we store it as a multiset set with repetitions Second we can remove the only maximum in the third or the first block by expanding the second one This can be handled easily if we just store all three blocks not only the second one as multisets And the last case is that we sometimes need to move the left border of the third block to the right This happens when we expand the first block and the second block becomes empty So this happens only times in total Total time complexity of this solution is There is also another solution from Gassa Let us start solving by asking the following question in which segments will the maximal values end up Consider the maximum value in the whole array If there are at least three of them a valid answer is to pick any maximum except the first and the last as the middle segment For example can be partitioned as or as where the middle segment is marked with square brackets Otherwise all should end up in the middle segment so that maximums to the left and to the right are less For example in we have to put both threes into the middle segment Let us now calculate the minimum value on the middle segment considering the numbers between those equal to For example in the value All numbers greater than should also go into the middle segment and everything between them which can result in decreasing even more We have to expand the borders of the middle segment until the minimum value is such that there are only values not greater than left outside Continuing with the example we see that in the middle segment should be expanded to Conversely if the maximum was unique then and we didn t have to expand the middle segment at this stage For example in the current state is If the maximums to the left and to the right are exactly we found an answer Otherwise any possible middle segment contains the middle segment that we now got So we have to expand the middle segment either to the left or to the right As a result the value may become smaller which can cause another expansion What s left is to decide where to expand when we have a choice We would like to do it greedily Indeed consider three values the minimum on middle segment the maximum on left segment and the maximum on right segment When we expand the middle segment each of them can only decrease And if we find an answer the equation will be satisfied So as we make the minimum of these three values smaller we have less and less opportunities to make them equal Thus we can pick the side of expansion after which the value is larger and if these are equal pick any For example in the state we have and If we expand to the left we get where and If we expand to the right we get where and Our algorithm will pick expanding to the right however there is no valid answer in this example anyway Implementation let us precalculate the maximums on all prefixes and all suffixes of the array Then we can expand the middle segment by one element in and the total running time is linear 
https://codeforces.com//contest/78/problem/B,418,B,78B,78,B. Easter Eggs,The Easter Rabbit laid eggs in a circle and is about to paint them Each egg should be painted one color out of 7 red orange yellow green blue indigo or violet Also the following conditions should be satisfied Each of the seven colors should be used to paint at least one egg Any four eggs should be painted different colors Help the Easter Rabbit paint the eggs in the required manner We know that it is always possible ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n\nchar C[] = ""ROYGBIV"";\n\nint main() {\n\n    int N;\n    scanf(""%d"", &N);\n    for (int i = 0; i < N-3; i++) {\n        putchar(C[i%4]);\n    }\n    puts(""BIV"");\n\n    return 0;\n}\n']",,,"['constructive algorithms', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Easter Eggs.json,https://codeforces.com//blog/entry/1812,At first you can n 7 times output string ROYGBIV is a rounding down After than you can output G GB YGB YGBI OYGBI or OYGBIV according to remainder of division n by 7 A resulting string will satisfy problem s requirements 
https://codeforces.com//contest/889/problem/E,133722,E,889E,889,E. Mod Mod Mod,You are given a sequence of integers Let and for Here denotes the modulus operation Find the maximum value of over all nonnegative integers ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\nconst ll INF = (1ll << 50);\n\nset <pair <ll, ll>> s;\n\nvoid ins(ll x, ll y) {\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n;\n    cin >> n;\n\n    ll p = INF;\n\n    s.emplace(p - 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        ll x;\n        cin >> x;\n\n        if (x >= p) {\n            continue;\n        }\n\n        p = x;\n\n        vector<pair<ll, ll>> rmed;\n        while (!s.empty()) {\n            auto val = *s.rbegin();\n            if (val.first < x - 1) {\n                break;\n            }\n\n            s.erase(val);\n            rmed.push_back(val);\n        }\n\n\n        pair<ll, ll> tmp{ x, -1 };\n        s.emplace(tmp);\n\n        ll last = 0;\n\n        for (auto& val : rmed) {\n            ll dv = val.first / x;\n            last = max(last, val.second + x * (dv - 1) * i);\n            ll md = val.first % x;\n            ll nvl = x * dv * i + val.second;\n            auto it = s.lower_bound(pair<ll, ll>{md, nvl});\n\n            if (it->second >= nvl) {\n                continue;\n            }\n\n            auto lit = it;\n            while (lit != s.begin()) {\n                auto nit = lit;\n                --nit;\n                if (nit->second > nvl) {\n                    break;\n                }\n                lit = nit;\n            }\n\n            s.erase(lit, it);\n            s.emplace(md, nvl);\n        }\n\n        while (!s.empty() && s.rbegin()->second <= last) {\n            auto it = s.end();\n            --it;\n            s.erase(it);\n        }\n\n        s.emplace(x - 1, last);\n    }\n\n    ll ans = 0;\n\n    for (auto& val : s) {\n        ans = max(ans, val.first * n + val.second);\n    }\n\n    cout << ans << ""\\n"";\n}']",,,"['binary search', 'dp', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Mod Mod Mod.json,https://codeforces.com//blog/entry/55734,let Can you define some segments of value think of some dp once you get the dp in to speed it up note the following fact if then either or let s call in other words it s the part of answer we gain from summands from to For the following is true can be any number from to and Suppose for some we have the following option can be any number from to and in this case We can describe this situation by triple We will show that this triple will produce at most two such triples for Indeed we can have many triples with different and one triple However we can note that among triplets of the first type we can leave only one with maximum because we re interested in maximum answer This will equal Thus we have two transitions from each triple that leads us to bruteforce solution when we have a bruteforce we almost always can think of a dp Indeed we have triples among those with equal and let s keep only one with the largest There are at most such triples on step on each step half of the generated triples have so we can merge them This leads us to dp in Okay what does the third hint say It basically says that a number can only be taken by modulo times until it becomes zero where is the bound of its initial value What do we get from this We can note that if we can just leave a triple untouched except changing to Let s then keep pairs assuming triples where changes in a cycle On each step we should change all pairs such that possibly adding one more pair with But when we change a pair is get by modulo so this won t happen with a pair more than times Overall the total number of times we touch a pair is bounded by Adding for map in which we keeps the pairs we obtain the final complexity Also map can be replaced with binary search but the complexity remains the same 
https://codeforces.com//contest/1536/problem/C,1007471,C,1536C,1536,C. Diluc and Kaeya,This time the brothers are dealing with a strange piece of wood marked with their names This plank of wood can be represented as a string of n characters Each character is either a or a You want to make some number of cuts possibly 0 on this string partitioning it into several contiguous pieces each with length at least 1 Both brothers act with dignity so they want to split the wood as evenly as possible They want to know the maximum number of pieces you can split the wood into such that the ratios of the number of occurrences of to the number of occurrences of in each chunk are the same Kaeya the curious thinker is interested in the solution for multiple scenarios He wants to know the answer for every of the given string Help him to solve this problem For a string we define a ratio as a b where appears in it a times and appears b times Note that a or b can equal 0 but not both Ratios a b and c d are considered equal if and only if a cdot d b cdot c For example for the string the ratio will be 3 0 for 2 1 for 1 2 and for 2 4 Note that the ratios of the latter two strings are equal to each other but they are not equal to the ratios of the first two strings ,"['#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\nconst int N=5e5+5;\nint n,c1,c2,lp;\nchar s[N];\nmap<P,int> mp;\nint read()\n{\n\tint res=0,fl=0; char a=getchar();\n\twhile(a<\'0\'||a>\'9\') fl|=a==\'-\',a=getchar();\n\twhile(a>=\'0\'&&a<=\'9\') res=res*10+a-\'0\',a=getchar();\n\treturn fl? -res:res;\n}\nint gcd(int x,int y) {return y? gcd(y,x%y):x;}\nint main()\n{\n\tint i,j,li,tt=read();\n\twhile(tt--)\n\t{\n\t\tmp.clear(),scanf(""%d%s"",&n,s+1);\n\t\tfor(i=1,c1=c2=0;i<=n;i++)\n\t\t{\n\t\t\ts[i]==\'D\'? c1++:c2++;\n\t\t\tlp=gcd(c1,c2),j=c1/lp,li=c2/lp;\n\t\t\tcout<<(++mp[P(j,li)])<<\' \';\n\t\t}\n\t\tcout<<\'\\n\';\n\t}\n\treturn 0;\n}']",,,"['data structures', 'dp', 'hashing', 'number theory']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Diluc and Kaeya.json,https://codeforces.com//blog/entry/91520,SolutionFor each prefix label it with a pair where frequency of D in this prefix and frequency of K in this prefix Divide and by If we iterate over all prefixes from to left we can notice that the answer for the prefix equals the of occurrences of this pair we have seen so far This can be visualized by drawing a poly line as mentioned in the hints As for implementation you can use a map in C or a HashMap in Java to achieve or runtime 
https://codeforces.com//contest/1174/problem/A,353390,A,1174A,1174,A. Ehab Fails to Be Thanos,You re given an array a of length 2n Is it possible to reorder it in such way so that the sum of the first n elements equal to the sum of the last n elements ,"[' #include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> mypair;\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == \'-\') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - \'0\';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nint n, a[4000005];\n\nint main()\n{\n\tn = read(); n <<= 1;\n\tfor (int i = 1; i <= n; i ++) a[i] = read();\n\tsort(a + 1, a + 1 + n);\n\tll ans = 0, s = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tif (i <= n / 2) s += a[i];\n\t\tans += a[i];\n\t}\n\tif (s * 2ll == ans) puts(""-1"");\n\telse for (int i = 1; i <= n; i ++) printf(""%d%c"", a[i], i == n ? 10 : 32);\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Ehab Fails to Be Thanos.json,https://codeforces.com//blog/entry/67388,If all elements in the array are equal there s no solution Otherwise sort the array The sum of the second half will indeed be greater than that of the first half Another solution is to see if they already have different sums If they do print the array as it is Otherwise find any pair of different elements from different halves and swap them Code link https pastebin com FDXTuDdZ 
https://codeforces.com//contest/1006/problem/F,198030,F,1006F,1006,F. Xor-Paths,There is a rectangular grid of size n times m Each cell has a number written on it the number on the cell i j is a i j Your task is to calculate the number of paths from the upper left cell 1 1 to the bottom right cell n m meeting the following constraints You can move to the right or to the bottom only Formally from the cell i j you may move to the cell i j 1 or to the cell i 1 j The target cell can t be outside of the grid The of all the numbers on the path from the cell 1 1 to the cell n m must be equal to k operation is the bitwise exclusive OR it is represented as in Java or C and in Pascal Find the number of such paths in the given grid ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint n, m;\nlong long k;\nlong long a[MAX_N + 1][MAX_N + 1];\nmap<long long, long long> f[MAX_N + 1][MAX_N + 1];\nlong long ans;\n\nvoid backtrack1(int x, int y, int step, long long xorsum) {\n\tif (step == n) {\n\t\tf[x][y][xorsum]++;\n\t\treturn;\n\t}\n\tif (x < n) {\n\t\tbacktrack1(x + 1, y, step + 1, xorsum ^ a[x + 1][y]);\n\t}\n\tif (y < m) {\n\t\tbacktrack1(x, y + 1, step + 1, xorsum ^ a[x][y + 1]);\n\t}\n}\n\nvoid backtrack2(int x, int y, int step, long long xorsum) {\n\tif (step == m) {\n\t\tans += f[x][y][k ^ a[x][y] ^ xorsum];\n\t\treturn;\n\t}\n\tif (x > 1) {\n\t\tbacktrack2(x - 1, y, step + 1, xorsum ^ a[x - 1][y]);\n\t}\n\tif (y > 1) {\n\t\tbacktrack2(x, y - 1, step + 1, xorsum^a[x][y - 1]);\n\t}\n}\n\nint main() {\n\t//freopen(""input.inp"", ""r"", stdin);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> m >> k;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin >> a[i][j];\n\tans = 0;\n\tbacktrack1(1, 1, 1, a[1][1]);\n\tbacktrack2(n, m, 1, a[n][m]);\n\tcout << ans;\n\treturn 0;\n}']",,,"['bitmasks', 'brute force', 'dp', 'meet-in-the-middle']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Xor-Paths.json,https://codeforces.com//blog/entry/60672,This is a typical problem on the technique The number of moves we will made equals So if would be small enough 25 is the upper bound I think then we can just run recursive backtracking in or in to iterate over all binary masks of lengths containing exactly ones and check each path described by such mask in this mask is the move to the bottom and is the move to the right if its is But it is too slow So let s split this mask of bits into two parts the left part will consist of bits and the right part will consist of bits Note that each left mask and each right mask too uniquely describes the endpoint of the path and the path itself Let s carry associative arrays where for the endpoint and will denote the number of paths which end in the cell having Let s run recursive backtracking which will iterate over paths starting from the cell and move to the right or to the bottom and maintain of the path If we made moves and we are currently in the cell with right now set and return from the function Otherwise try to move to the bottom or to the right changing as needed Let s run another recursive backtracking which will iterate over paths starting from the cell and move to the left or to the top and maintain of the path except the last cell The same if we made moves and we are currently in the cell with right now let s add to the answer obvious that way we complement our from the right part of the path with the suitable from the left part of the path Otherwise try to move to the left or to the top changing as needed So this is the technique at least the way I code it Overall complexity is 
https://codeforces.com//contest/763/problem/C,91411,C,763C,763,C. Timofey and remoduling,Little Timofey likes integers a lot Unfortunately he is very young and can t work with very big integers so he does all the operations modulo his favorite prime Also Timofey likes to look for arithmetical progressions everywhere One of his birthday presents was a sequence of integers Timofey wants to know whether he can rearrange the elements of the sequence so that is will be an arithmetical progression modulo or not Arithmetical progression modulo of length with first element and difference is sequence of integers each taken modulo ,"['// saratov 2013-2014 I Wuhongxun\'s code\n\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 1000010;\nint a[N], b[N], G, md, c[N], cl; int m, tot = 0;\nbool vis[N];\n#define nxt(x) (x == n ? 1 : x + 1)\n#define pre(x) (x == 1 ? n : x - 1)\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nvoid work(int n) {\n\ttot++; if (tot > 60) { printf(""-1\\n""); return; }\n\tif (m == n) {\n\t\tprintf(""%d %d\\n"",md,G >= G * m ? 1 : G);\n\t} else if (m - 1 == n) {\n\t\trep(i,1,n) if (a[i] != i - 1) { printf(""%d %d\\n"",a[i] * G + md,G); return; }\n\t} else if (n <= 1000) {\n\t\tif (n == 1) { printf(""%d %d\\n"", a[1], 1); return; }\n\t\trep(i,2,n) {\n\t\t\tint d = a[i] - a[1]; if (gcd(d, m) != 1) continue;\n\t\t\tint cnt = 0, j = 1; bool haveans = true;\n\t\t\trep(k,1,n) {\n\t\t\t\tint x = (a[k] + d) % m, t = j; j = nxt(j);\n\t\t\t\twhile (j != t && a[j] != x) j = nxt(j);\n\t\t\t\tif (j == t) { cnt++; if (cnt == 2) { haveans = false; break; }}\n\t\t\t}\n\t\t\tif (haveans) {\n\t\t\t\tint j = n;  n = cl; d *= G, m *= G;\n\t\t\t\tdep(k,n,1) {\n\t\t\t\t\tint x = (c[k] - d + m) % m, t = j; j = pre(j);\n\t\t\t\t\twhile (j != t && c[j] != x) j = pre(j);\n\t\t\t\t\tif (j == t) { printf(""%d %d\\n"",c[k],d); return; }\n\t\t\t\t}\n\t\t\t\tprintf(""%d %d\\n"",c[1],d); return;\n\t\t\t}\n\t\t}\n\t\tprintf(""-1\\n"");\n\t} else {\n\t\tbool flag = true;\n\t\twhile (flag) {\n\t\t\trep(i,1,n) vis[i] = false;\n\t\t\tint x = rand() % n + 1; vis[x] = true; int j = pre(x), k = nxt(x);\n\t\t\tfor(;j != k; j = pre(j)) {\n\t\t\t\twhile (k != j && (a[k] + m - a[x]) % m < (a[x] + m - a[j]) % m) k = nxt(k);\n\t\t\t\tif ((a[j] + a[k]) % m == 2 * a[x] % m) vis[j] = vis[k] = true;\n\t\t\t\tif (k == j) break;\n\t\t\t} \n\t\t\tint l = 0; rep(i,1,n) if (!vis[i]) b[++l] = a[i];\n\t\t\tflag = l < 2; if (!flag) { n = l; rep(i,1,n) a[i] = b[i]; } \n\t\t}\n\t\twork(n);\n\t}\n}\n\nvoid init(int n) {\n\tint g = gcd(m, a[1] + m - a[n]); rep(i,1,n - 1) g = gcd(g, a[i + 1] - a[i]);\n\tG = g, md = a[1] % g;\n\tm /= g; rep(i,1,n) a[i] /= g;\n}\n\nint main() {\n\tsrand(233); int n; scanf(""%d%d"",&m,&n); cl = n;\n\trep(i,1,n) scanf(""%d"",&a[i]);\n\tsort(a+1,a+n+1);\n\trep(i,1,n) c[i] = a[i];\n\tinit(n); work(n);\n\treturn 0;\n}']",,,"['brute force', 'implementation', 'math', 'number theory']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Timofey and remoduling.json,https://codeforces.com//blog/entry/50205,First let s think about the case when In this editorial we say that an outcoming sequence is Assume is the difference of some two elements and of Let s say that was on th place in the sequence and was on th place Then On the other hand we have that is less then so must be difference of exactly pairs of elements of We can count this value in time using binary search or in time using a hashtable Then we know the value of After that we calculate the value is prime so we can use Fermat s little theorem and then we know the difference of the sequence Then we just take any element of and look on values and also on If we can get all of the numbers in in this way then we know the first element of the sequence Otherwise the answer is NO If we just solve the problem for the complement of in and then add to the first element value If we had a correct sequence in then we must have a correct sequence in its complement with the same difference as long as is coprime with the difference the complement is just set of numbers Author s solution http pastebin com jTdcUpFM 
https://codeforces.com//contest/630/problem/J,48795,J,630J,630,J. Divisibility,IT City company developing computer games invented a new way to reward its employees After a new game release users start buying it actively and the company tracks the number of sales with precision to each transaction Every time when the next number of sales is divisible by all numbers from to every developer of this game gets a small bonus A game designer Petya knows that the company is just about to release a new game that was partly developed by him On the basis of his experience he predicts that people will buy the game during the first month Now Petya wants to determine how many times he will get the bonus Help him to know it ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\nll cnk(ll n, int k)\n{\n    ll res = 1;\n    forn(i, k) res = (res * (n - i)) / (i + 1);\n    return res;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    ll n;\n\n    cin >> n;\n    ll lcm = 2;\n    for (int i = 3; i <= 10; ++i) lcm = lcm * i / __gcd(lcm, (ll)i);\n    cout << n / lcm;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']",,,"['math', 'number theory']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\J. Divisibility.json,https://codeforces.com//blog/entry/23604?locale=en,Let s factorize numbers from 2 to 10 2 2 3 3 4 22 5 5 6 2 3 7 7 8 23 9 32 10 2 5 If a number is divisible by all numbers from 2 to 10 its factorization should contain 2 at least in the power of 3 3 at least in the power of 2 5 and 7 at least in the power of 1 So it can be written as x 23 32 5 7 x 2520 So any number divisible by 2520 is divisible by all numbers from 2 to 10 There are numbers from 1 to n divisible by all numbers from 2 to 10 In a programming language it is usually implemented as simple integer division 
https://codeforces.com//contest/1296/problem/C,531584,C,1296C,1296,C. Yet Another Walking Robot,There is a robot on a coordinate plane Initially the robot is located at the point 0 0 Its path is described as a string s of length n consisting of characters Each of these characters corresponds to some move left means that the robot moves from the point x y to the point x 1 y right means that the robot moves from the point x y to the point x 1 y up means that the robot moves from the point x y to the point x y 1 down means that the robot moves from the point x y to the point x y 1 The company that created this robot asked you to optimize the path of the robot somehow To do this you can remove of the path But this company doesn t want their customers to notice the change in the robot behavior It means that if before the optimization the robot ended its path at the point x e y e then after optimization i e removing some single substring from s the robot also ends its path at the point x e y e This optimization is a low budget project so you need to remove possible substring to optimize the robot s path such that the endpoint of his path doesn t change It is possible that you can t optimize the path Also it is possible that after the optimization the target path is an empty string i e deleted substring is the whole string s Recall that the substring of s is such string that can be obtained from s by removing some amount of characters possibly zero from the prefix and some amount of characters possibly zero from the suffix For example the substrings of are but not and You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;char a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int x=0,y=0;\n        map<PII,int>mp;\n        mp[PII(0,0)]=0;\n        scanf(""%d"",&n);\n        scanf(""%s"",a+1);\n        int ans=INF;\n        int l=0;\n        for(int i=1;i<=n;i++){\n            if(a[i]==\'L\')x++;\n            if(a[i]==\'R\')x--;\n            if(a[i]==\'U\')y++;\n            if(a[i]==\'D\')y--;\n            if(mp.count(PII(x,y))){\n                int k=mp[PII(x,y)];\n                if(i-k<ans)ans=i-k,l=k+1;\n            }\n            mp[PII(x,y)]=i;\n        }\n        if(l==0)printf(""-1\\n"");\n        else printf(""%d %d\\n"",l,l+ans-1);\n    }\n    return 0;\n}\n/*\n*/\n']",,,"['data structures', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Yet Another Walking Robot.json,https://codeforces.com//blog/entry/73627,Formally the problem asks you to remove the shortest cycle from the robot s path Because the endpoint of the path cannot be changed the number of s should be equal to the number of s and the same with and How to find the shortest cycle Let s create the associative array for C which will say for each point of the path the maximum number of operations such that if we apply first operations we will stay at this point Initially this array will contain only the point with the value Let s go over all characters of in order from left to right Let the current point be we applied first operations indexed If this point is in the array already let s try to update the answer with the value and left and right borders with values and correspondingly Then let s assign and continue If there were no updates of the answer the answer is Otherwise you can print any substring you found Time complexity per test case 
https://codeforces.com//contest/1735/problem/F,1564420,F,1735F,1735,F. Pebbles and Beads,There are two currencies pebbles and beads Initially you have a pebbles b beads There are n days each day you can exchange one currency for another at some exchange rate On day i you can exchange p i leq x leq p i pebbles for q i leq y leq q i beads or vice versa It s allowed not to perform an exchange at all Meanwhile if you perform an exchange the proportion x cdot q i y cdot p i must be fulfilled Fractional exchanges are allowed You can perform no more than one such exchange in one day The numbers of pebbles and beads you have must always remain non negative Please solve the following n problems independently for each day i output the maximum number of pebbles that you can have at the end of day i if you perform exchanges optimally ,"['// LUOGU_RID: 91546812\n//author: HugeWide\n/*rating:\nCodeforces: 2307,International Master\nAtcoder: 1990,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\') {\n\t\tif(ch==\'-\') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\') {\n\t\tx=(x<<3)+(x<<1)+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar(\'-\'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+\'0\');\n}\n#define writesp(x) write(x),putchar(\' \')\n#define writeln(x) write(x),putchar(\'\\n\')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=300300;\n\nint n;\ndb a,b;\ndb p[N],q[N];\n\nstruct Vector {\n\tdb x,y;\n\tVector(db _x,db _y) {\n\t\tx=_x,y=_y;\n\t}\n\tbool operator < (const Vector& a) const {\n\t\treturn y*a.x>x*a.y;\n\t}\n};\nmultiset<Vector> s;\ntypedef multiset<Vector>::iterator si;\n\ndb lx,ly,rx,ry;\nvoid solve() {\n\tn=read(),a=read(),b=read();\n\trep(i,1,n) p[i]=read();\n\trep(i,1,n) q[i]=read();\n\ts.clear(); lx=rx=a,ly=ry=b;\n\trep(i,1,n) {\n\t\ts.insert(Vector(p[i]*2,q[i]*2));\n\t\tlx-=p[i],ly+=q[i],rx+=p[i],ry-=q[i];\n\t\twhile(ry<0) {\n\t\t\tsi it=s.begin();\n\t\t\tdb x=it->x,y=it->y;\n\t\t\ts.erase(it);\n\t\t\tif(ry+y<=0) {\n\t\t\t\trx-=x,ry+=y;\n\t\t\t} else {\n\t\t\t\trx-=x,ry+=y;\n\t\t\t\tdb t=ry/y;\n\t\t\t\tx*=t,y*=t;\n\t\t\t\trx+=x,ry-=y;\n\t\t\t\ts.insert(Vector(x,y));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(lx<0) {\n\t\t\tsi it=s.end(); it--;\n\t\t\tdb x=it->x,y=it->y;\n\t\t\ts.erase(it);\n\t\t\tif(lx+x<=0) {\n\t\t\t\tlx+=x,ly-=y;\n\t\t\t} else {\n\t\t\t\tlx+=x,ly-=y;\n\t\t\t\tdb t=lx/x;\n\t\t\t\tx*=t,y*=t;\n\t\t\t\tlx-=x,ly+=y;\n\t\t\t\ts.insert(Vector(x,y));\n\t\t\t}\n\t\t}\n//\t\tdb x=rx,y=ry;\n//\t\tprintf(""(%.0lf,%.0lf) "",x,y);\n//\t\tfor(si it=s.begin();it!=s.end();it++) {\n//\t\t\tx-=it->x,y+=it->y;\n//\t\t\tprintf(""(%.0lf,%.0lf) "",x,y);\n//\t\t}\n//\t\tprintf(""\\n"");\n\t\tdouble ans=rx;\n\t\tprintf(""%.12lf\\n"",ans);\n\t}\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n']",,,"['data structures', 'geometry']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Pebbles and Beads.json,https://codeforces.com//blog/entry/107533,SolutionLet s draw currencies on 2D plane Having pebbles and beads is described as point Let s assume that we can throw out any amount of money at any moment In this case an area of possible points can be described as a convex polygon in the upper right quarter Initially it is the rectangle At any moment this polygon can be described as a list of segments starting at point and finishing at point In the rectangle described above there are segments Let s keep those segments sorted by angle When a new day comes each point can be shifted by the vector if the new point has non negative coordinates If we forget about new points to be non negative how new segments look like We just have to add new segment and shift a prefix of old segments by and remaining suffix of segments by Then the only thing left to do is to cut segments to keep our polygon non negative Sounds great but sounds like Do we need to maintain segments explicitly No Let s just keep the set of their lengths and angles Knowledge of extreme points and is enough So we need to Insert a new segment to the set You need just length and angle Shift extreme points and by and correspondingly Delete or cut the last and first segments while they are out of the non negative area Complexity There is another simple approach We can keep the area as a polygon At each step create two copies shifted by corresponding vectors Build a convex hull of them Cut this convex hull to be in the non negative area It won t fit Mentioned just for fun 
https://codeforces.com//contest/592/problem/E,39719,E,592E,592,E. BCPC,BCPC stands for Byteforces Collegiate Programming Contest and is the most famous competition in Byteforces BCPC is a team competition Each team is composed by a coach and three contestants Blenda is the coach of the Bit State University BSU and she is very strict selecting the members of her team In BSU there are students numbered from 1 to Since all BSU students are infinitely smart the only important parameters for Blenda are their reading and writing speed After a careful measuring Blenda have found that the th student have a speed equal to words per minute and a speed of symbols per minute Since BSU students are very smart the measured speeds are sometimes very big and Blenda have decided to subtract some constant value from all the values of reading speed and some value from all the values of writing speed Therefore she considers and The student is said to the student if and only if Blenda doesn t like fights in teams so she thinks that a team consisting of three distinct students and is if overwhelms overwhelms and overwhelms Yes the relation of overwhelming is not transitive as it often happens in real life Since Blenda is busy preparing a training camp in Codeforces you are given a task to calculate the number of different good teams in BSU Two teams are considered to be different if there is at least one student that is present in one team but is not present in the other In other words two teams are different if the sets of students that form these teams are different ,"['#include <functional>\n#include <algorithm>\n#include <stdexcept>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <ctime>\n#include <list>\n#include <map>\n#include <set>\n#include <assert.h>\n#include <complex>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define TR(i,x) for(__typeof(x.begin()) i=x.begin();i!=x.end();i++)\n#define ALL(x) x.begin(),x.end()\n#define SORT(x) sort(ALL(x))\n#define CLEAR(x) memset(x,0,sizeof(x))\n#define FILL(x,c) memset(x,c,sizeof(x))\n\nusing namespace std;\n\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define PB push_back\n#define MP make_pair\n\ntypedef map<int,int> MII;\ntypedef map<string,int> MSI;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<long double> VD;\ntypedef pair<int,int> PII;\ntypedef long long int64;\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n\nstruct Point {\n    long long x, y;\n    Point(long long x = 0, long long y = 0) : x(x), y(y) {}\n    Point operator + (const Point &o) const {\n        return Point(x + o.x, y + o.y);\n    }\n    Point operator - (const Point &o) const {\n        return Point(x - o.x, y - o.y);\n    }\n    Point operator * (const int k) const {\n        return Point(x * k, y * k);\n    }\n    void read() {\n        cin >> x >> y;\n    }\n\n    bool up() const {\n    \treturn y > 0 || y == 0 && x > 0;\n    }\n};\n\nlong long det(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nlong long dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nlong long vlen(const Point& a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nbool cmp(const Point &a, const Point &b) {\n    if (a.up() ^ b.up()) return b.up();\n    if (det(a, b) != 0) {\n        return det(a, b) > 0;\n    }\n    return vlen(a) < vlen(b);\n}\n\nbool in_big_range(const Point& a, const Point& b) {\n    if (det(a, b) != 0) {\n        return det(a, b) > 0;\n    }\n    if (dot(a, b) < 0) {\n        return true;\n    }\n    return vlen(b) > vlen(a);\n}\n\nbool in_small_range(const Point& a, const Point& b) {\n    if (det(a, b) != 0) {\n        return det(a, b) > 0;\n    }\n    if (dot(a, b) < 0) {\n        return false;\n    }\n    return vlen(b) > vlen(a);\n}\n\nint main() {\n    int n, c, d;\n    cin >> n >> c >> d;\n    vector<Point> points(n);\n    REP(i, n) {\n        int u, v;\n        scanf(""%d%d"", &u, &v);\n        u -= c; v -= d;\n        points[i].x = u;\n        points[i].y = v;\n    }\n\n    sort(ALL(points), cmp);\n    reverse(ALL(points));\n    REP(i, n) points.PB(points[i]);\n    int ptr_big = n, ptr_small = n;\n    while (ptr_big - 1 > 0 && in_big_range(points[0], points[ptr_big - 1])) {\n        --ptr_big;\n    }\n    while (ptr_small - 1 > 0 && in_small_range(points[0], points[ptr_small - 1])) {\n        --ptr_small;\n    }\n    long long ans = 0;\n    for (int i = n; i < 2 * n; ++i) {\n        ptr_small = max(ptr_small, i - n + 1);\n        ptr_big = max(ptr_big, i - n + 1);\n        while (ptr_small + 1 <= i && !in_small_range(points[i], points[ptr_small])) {\n            ++ptr_small;\n        }\n        while (ptr_big + 1 <= i && !in_big_range(points[i], points[ptr_big])) {\n            ++ptr_big;\n        }\n        LL len_big = i - ptr_big;\n        LL len_small = i - ptr_small;\n        // cout << ""ptr is "" << ptr << endl;\n        ans += len_small * (len_small - 1) / 2;\n        ans += len_small * (len_big - len_small);\n    }\n    // cout << ""ans = "" << ans << endl;\n    ans = n * (n - 1LL) * (n - 2LL) / 6 - ans;\n    cout << ans << endl;\n    return 0;\n}']",,,"['binary search', 'geometry', 'two pointers']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. BCPC.json,https://codeforces.com//blog/entry/21318,Let s represent the reading and writing speeds of the students as points in a plane Two students i j are compatible if ri wj rj wi 0 this equation is identical to the cross product ri wi rj wj 0 Using this fact is easy to see that three students i j k are compatible if the triangle ri wi rj wj rk wk contains the point x y So the problem is reduced to count the number of triangles that contains the origin Let s count the triangles that have two known vertices i and j look at the picture above It is easy to see that the third vertex should be inside the region S So now we have to be able of counting points that are between two rays that can be done using binary search ordering the points first by slope and then by the distance to the origin Now given a point i let s count the triangles that have i as a vertex look at the picture above again We have to count the points that lie between the ray iO and every other ray jO the angle between iO and jO must be 180 Let Sj denote the number points that are between the rays OR and jO then the number of triangles that have i as a vertex are This summation can be calculated if we pre calculate the cumulative sums of Sj 
https://codeforces.com//contest/427/problem/D,9096,D,427D,427,D. Match   Catch,Police headquarter is monitoring signal on different frequency levels They have got two suspiciously encoded strings and from two different frequencies as signals They are suspecting that these two strings are from two different criminals and they are planning to do some evil task Now they are trying to find a common substring of minimum length between these two strings The substring must occur only once in the first string and also it must occur only once in the second string Given two strings and consist of lowercase Latin letters find the smallest by length common substring of both and where is a unique substring in and also in See notes for formal definition of substring and uniqueness ,"['#include <stdio.h>\n#include <string.h>\n#define max(a,b) ((a)>(b)?(a):(b))\n\nconst int N = 5001;\n\nchar str1[N];\nchar str2[N];\n\nint csa[N][N];\nint csb[N][N];\nint csab[N][N];\nint cna[N];\nint cnb[N];\n\nvoid calc(int d[N][N], char* a, int na, char* b, int nb)\n{\n  for (int i = na; i >= 0; i--)\n  {\n    for (int j = nb; j >= 0; j--)\n    {\n      if (i == na || j == nb || a[i] != b[j])\n        d[i][j] = 0;\n      else\n        d[i][j] = d[i + 1][j + 1] + 1;\n    }\n  }\n}\nvoid calc2(int d[N], int s[N][N], int n)\n{\n  for (int i = 0; i < n; i++)\n  {\n    d[i] = 0;\n    for (int j = 0; j < n; j++)\n      if (j != i && s[i][j] > d[i])\n        d[i] = s[i][j];\n  }\n}\n\nint main()\n{\n  //freopen(""input.txt"", ""rt"", stdin);\n  //freopen(""output.txt"", ""wt"", stdout);\n\n  scanf(""%s %s"", str1, str2);\n  int n1 = strlen(str1);\n  int n2 = strlen(str2);\n\n  calc(csa, str1, n1, str1, n1);\n  calc(csb, str2, n2, str2, n2);\n  calc(csab, str1, n1, str2, n2);\n  calc2(cna, csa, n1);\n  calc2(cnb, csb, n2);\n\n  int best = -1;\n  for (int i = 0; i < n1; i++)\n  {\n    for (int j = 0; j < n2; j++)\n    {\n      int mx = max(cna[i], cnb[j]) + 1;\n      if (csab[i][j] >= mx && (best < 0 || best > mx))\n        best = mx;\n    }\n  }\n\n  printf(""%d"", best);\n\n  return 0;\n}\n']",,,"['dp', 'string suffix structures', 'strings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Match   Catch.json,https://codeforces.com//blog/entry/12082,Calculate the longest common prefix LCP for each index of with each index of Then calculate LCP for each index of with all the other indexes of it s own Do the same for Now from precalculated values you can easily check the length of the shortest unique substring starting from any of the indexes of or Suppose is an index of and is an index of Find the LCP for and Now the minimum of the length of LCP length of shortest unique substring starting from length of shortest unique substring starting from is the answer for Now we need to find the minimum answer from all possible pair This problem can also be solved in by suffix array and in using suffix automaton 
https://codeforces.com//contest/986/problem/C,186083,C,986C,986,C. AND Graph,You are given a set of size m with integer elements between 0 and 2 n 1 inclusive Let s build an undirected graph on these integers in the following way connect two integers x and y with an edge if and only if x y 0 Here is the bitwise AND operation Count the number of connected components in that graph ,"[""/**\n *    author:  tourist\n *    created: 29.05.2018 19:13:49       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> was(1 << n, 1);\n  for (int i = 0; i < m; i++) {\n    int x;\n    cin >> x;\n    was[x] = 0;\n  }\n  vector<int> used(1 << n, 0);\n  vector<int> que(1 << n);\n  vector<int> inner(1 << n);\n  int ans = 0;\n  for (int start = 0; start < (1 << n); start++) {\n    if (was[start]) {\n      continue;\n    }\n    ans++;\n    was[start] = 1;\n    que[0] = start;\n    int qs = 1;\n    for (int q = 0; q < qs; q++) {\n      int u = (1 << n) - 1 - que[q];\n      if (!used[u]) {\n        used[u] = 1;\n        inner[0] = u;\n        int is = 1;\n        for (int i = 0; i < is; i++) {\n          int z = inner[i];\n          if (!was[z]) {\n            was[z] = 1;\n            que[qs++] = z;\n          }\n          for (int bit = 0; bit < n; bit++) {\n            if ((z & (1 << bit)) && !used[z ^ (1 << bit)]) {\n              used[z ^ (1 << bit)] = 1;\n              inner[is++] = z ^ (1 << bit);\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]",,,"['bitmasks', 'dfs and similar', 'dsu', 'graphs']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. AND Graph.json,https://codeforces.com//blog/entry/59758,Let s build directed graph on vertices There will be two types of vertices is a vertex for from input and is a vertex for all between and There will be edges of three classes for all from input for all and such that th bit of is for all from input Here the complement of Let s look at some path of form The transition from to just change some bits to So is a submask of is and is the complement of Now it is clear that The opposite is also true whenever there is a path from to The solution is simple now iterate over all from input and if the vertex is not visited yet run a DFS from it and increase the answer by It is clear that we will run DFS exactly once for each connected component of original graph Complexity 
https://codeforces.com//contest/370/problem/D,4146,D,370D,370,D. Broken Monitor,Innocentius has a problem his computer monitor has broken Now some of the pixels are dead that is they are always black As consequence Innocentius can t play the usual computer games He is recently playing the following game with his younger brother Polycarpus Innocentius is touch typing a program that paints a white square one pixel wide frame on the black screen As the monitor is broken some pixels that should be white remain black Polycarpus should look at what the program displayed on the screen and guess the position and size of the frame Innocentius has painted Polycarpus doesn t like the game but Innocentius persuaded brother to play as the game is good for the imagination and attention Help Polycarpus automatize his part in the gaming process Write the code that finds such possible frame that the frame s width is 1 pixel the frame doesn t go beyond the borders of the screen all white pixels of the monitor are located on the frame of all frames that satisfy the previous three conditions the required frame must have the smallest size Formally a square frame is represented by such pixels of the solid square that are on the square s border that is are not fully surrounded by the other pixels of the square For example if the frame s size is then it consists of 8 pixels if its size is then it contains 4 pixels and if then the frame is reduced to a single pixel ,"['#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file """"\n#define N 100500\n\nchar a[2300][2300];\n       \nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        scanf(""%s"", a[i]);\n    int l = inf, r = -inf, u = inf, d = -inf;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            if (a[i][j] == \'w\')\n            {\n                l = min(l, j);\n                r = max(r, j);\n                u = min(u, i);\n                d = max(d, i);\n            }\n    if (l == inf)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    bool L = 0, R = 0, U = 0, D = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (i == u && j > l && j < r && a[i][j] == \'w\') U = 1;\n            if (i == d && j > l && j < r && a[i][j] == \'w\') D = 1;\n            if (j == l && i > u && i < d && a[i][j] == \'w\') L = 1;\n            if (j == r && i > u && i < d && a[i][j] == \'w\') R = 1;\n        }\n    int s = max(r - l, d - u);\n    if (l == r || u == d)\n    {\n        if (l == r)\n        {\n            if (r - s >= 0) l = r - s;\n            else if (l + s < m) r = l + s;\n            else if (L || R)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                l = max(0, r - s);\n                r = min(m - 1, l + s);\n                if (r - l != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n        else\n        {\n            if (d - s >= 0) u = d - s;\n            else if (u + s < n) d = u + s;  \n            else if (U || D)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                u = max(0, d - s);\n                d = min(n - 1, u + s);\n                if (d - u != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    else\n    {                         \n    if (U && D && d - u != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (L && R && r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (U && d - u != s) d = s + u;\n    if (D && d - u != s) u = d - s;\n    if (L && r - l != s) r = l + s;\n    if (R && r - l != s) l = r - s;\n    if (!U && !D && d - u != s)\n    {\n        u = max(0, d - s);\n        d = min(n - 1, u + s);\n    }\n    if (!L && !R && r - l != s)\n    {\n        l = max(0, r - s);\n        r = min(m - 1, l + s);\n    }\n    if (u < 0 || l < 0 || d >= n || r >= m)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (d - u != s || r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if ((i == u || i == d) && j >= l && j <= r)\n            {\n                if (a[i][j] != \'w\') a[i][j] = \'+\';\n            }\n            else if (i >= u && i <= d && (j == l || j == r))\n            {\n                if (a[i][j] != \'w\') a[i][j] = \'+\';\n            }\n            else if (a[i][j] == \'w\')\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    for (int i = 0; i < n; i++)\n        printf(""%s\\n"", a[i]);\n\n\n\n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'greedy', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Broken Monitor.json,https://codeforces.com//blog/entry/9866,There are a lot of correct approaches to solve the problem But there are much more incorrect One way to solve the problem is following It is easy to see that in possible answer there are two opposite sides each containing w In opposite case frame can be shrinked So the size of frame is or where and are coordinates of left right top bottom ws Obviously you should choose as a size Now we know the size of the required frame How to find it s leftmost topmost corner The set of possible s is and 0 Indeed you may move frame to the left until it will abuts to w by left size right size of abuts to the left side of monitor Similarly the set of possible s as y coordinate of leftmost topmost corner Now the solution looks like All you need is to write frame correct You may iterate through frame and check that all cells inside monitor and calculate the number of ws on it If all the cells are inside and calculated number equals to total number of w then return true This solution works in 
https://codeforces.com//contest/1455/problem/D,815717,D,1455D,1455,D. Sequence and Swaps,You are given a sequence a consisting of n integers a 1 a 2 dots a n and an integer x Your task is to make the sequence a sorted it is considered sorted if the condition a 1 le a 2 le a 3 le dots le a n holds To make the sequence sorted you may perform the following operation any number of times you want possibly zero choose an integer i such that 1 le i le n and a i x and swap the values of a i and x For example if a 0 2 3 5 4 x 1 the following sequence of operations is possible choose i 2 it is possible since a 2 x then a 0 1 3 5 4 x 2 choose i 3 it is possible since a 3 x then a 0 1 2 5 4 x 3 choose i 4 it is possible since a 4 x then a 0 1 2 3 4 x 5 Calculate the minimum number of operations you have to perform so that a becomes sorted or report that it is impossible ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N, X;\n    cin >> N >> X;\n    vector<int> A(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    int last = -1;\n\n    for (int i = 0; i < N - 1; i++)\n        if (A[i] > A[i + 1])\n            last = i;\n\n    int ops = 0;\n\n    for (int i = 0; i <= last; i++)\n        if (A[i] > X) {\n            ops++;\n            swap(A[i], X);\n        }\n\n    if (!is_sorted(A.begin(), A.end()))\n        ops = -1;\n\n    cout << ops << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['dp', 'greedy', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Sequence and Swaps.json,https://codeforces.com//blog/entry/85186,The main fact that allows us to solve this problem is that the value of always increases after swaps and since the resulting sequence should be sorted the indices of elements we swap with also increase This observation is actually enough for us to implement a dynamic programming solution of the form dp i j is the minimum number of actions we have to perform to reach the following situation the last integer we swapped with was and the current value of is Depending on your implementation it works either in or in But there exists a much simpler to code greedy solution scan the array from left to right until it is sorted and find the first element such that we can apply the operation to it and apply that operation to it Implementing it in or even in is easy but proving it is a bit harder The key fact that is required to prove it is that if we can apply an operation to some position but don t do it and instead apply this operation to some position to the right of that one the elements on these two positions are no longer sorted if we can apply the operation to some position then but if we apply the operation to position instead then after it Since we can t go backward the resulting array cannot be sorted by any means that s why we can t skip elements in this greedy solution 
https://codeforces.com//contest/2019/problem/B,2905354,B,2019B,2019,B. All Pairs Segments,You are given n points on the x axis at increasing positive integer coordinates x 1 x 2 ldots x n For each pair i j with 1 leq i j leq n you draw the segment x i x j The segments are closed i e a segment a b contains the points a a 1 ldots b You are given q queries In the i th query you are given a positive integer k i and you have to determine how many points with integer coordinates are contained in exactly k i segments ,"['#include<bits/stdc++.h>using namespace std;#define int long longconst int N=1e5+7;int T,n,q,x[N];map<int,int>mp;signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n>>q;\t\tfor(int i=1;i<=n;i++){\t\t\tcin>>x[i];\t\t\tint cnt=(n-1)+(i-1)*(n-i);\t\t\tmp[cnt]++;\t\t}\t\tfor(int i=1;i<n;i++){\t\t\tint cnt=i*(n-i);\t\t\tmp[cnt]+=(x[i+1]-x[i]-1);\t\t}\t\twhile(q--){\t\t\tint x;\t\t\tcin>>x;\t\t\tcout<<mp[x]<<"" "";\t\t\t}\t\tcout<<""\\n"";\t\tmp.clear();\t}\treturn 0;}']",,,"['implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. All Pairs Segments.json,https://codeforces.com//blog/entry/134420,SolutionFirst let s focus on determining how many intervals contain some point These intervals are the ones with and So a point satisfies and It means that you have found points contained in exactly intervals because there are possible left endpoints and possible right endpoints Similarly the point is contained in intervals you have to remove interval which you do not draw So you can use a map that stores how many points are contained in exactly intervals and update the map in the positions and Complexity 
https://codeforces.com//contest/716/problem/A,71755,A,716A,716,A. Crazy Computer,ZS the Coder is coding on a crazy computer If you don t type in a word for a consecutive seconds everything you typed disappear More formally if you typed a word at second and then the next word at second then if just the new word is appended to other words on the screen If then everything on the screen disappears and after that the word you have typed appears on the screen For example if and you typed words at seconds then at the second there will be words on the screen After that everything disappears at the second because nothing was typed At the seconds and another two words are typed and finally at the second one more word is typed and a total of words remain on the screen You re given the times when ZS the Coder typed the words Determine how many words remain on the screen after he finished typing everything ,"['/*AMETHYSTS*/\n#pragma comment(linker, ""/STACK:1000000000"")\n#include <cstdio>\n#include <iostream>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <climits>\n#include <string>\n#include <queue>\n#include <memory.h>\n#include <unordered_map>\n#include <random>\n\n#define ll long long\n#define ld double\n#define pii pair <int, int>\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define ui unsigned ll\n\nusing namespace std;\n\nint main() {\n\tint n, c;\n\n\tcin >> n >> c;\n\n\tint last = -(int)1e9 - 10;\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\n\t\tscanf(""%d"", &x);\n\n\t\tif (x - last > c) {\n\t\t\tans = 1;\n\t\t} else {\n\t\t\tans++;\n\t\t}\n\n\t\tlast = x;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Crazy Computer.json,https://codeforces.com//blog/entry/47169,Prerequisites None This is a straightforward implementation problem Iterate through the times in order keeping track of when is the last time a word is typed keeping a counter for the number of words appearing on the screen Increment the counter by whenever you process a new time Whenever the difference between the time for two consecutive words is greater than reset the counter to After that increment it by Time Complexity since the times are already sorted Code O n 
https://codeforces.com//contest/678/problem/E,62343,E,678E,678,E. Another Sith Tournament,The rules of Sith Tournament are well known to everyone Sith take part in the Tournament The Tournament starts with the random choice of two Sith who will fight in the first battle As one of them loses his place is taken by the next randomly chosen Sith who didn t fight before Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents The Tournament ends when the only Sith remains alive Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament However his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser s place after each battle Of course he won t miss his chance to take advantage of it Help him to calculate the probability of his victory ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 18;\nint n;\nint cnt[1 << N];\ndouble p[N][N];\ndouble f[N][1 << N];\n\nint main() {\n    cin >> n;\n    for (int i = 0 ; i < n; ++ i) {\n        for (int j = 0 ; j < n ; ++ j) {\n            cin >> p[i][j];\n        }\n    }\n    for (int i = 1 ; i < 1 << n ; ++ i) {\n        cnt[i] = cnt[i & (i - 1)] + 1;\n    }\n    f[0][1] = 1;\n    for (int i = 1 ; i < 1 << n ; ++ i) {\n        if (cnt[i] < 2) continue;\n        for (int j = 0 ; j < n ; ++ j) {\n\n            for (int k = 0 ; k < n ; ++ k) {\n                if (j != k && (i >> k & 1)) {\n                    f[j][i] = max(f[j][i] , p[j][k] * f[j][i ^ (1 << k)] + p[k][j] * f[k][i ^ (1 << j)]);\n                }\n            }\n        }\n        //f[i] /= cnt;\n    }\n    double res = 0;\n    for (int i = 0 ; i < n ; ++ i) {\n        res = max(res , f[i][(1 << n) - 1]);\n    }\n    printf(""%.12f\\n"" , res);\n}\n']",,,"['bitmasks', 'dp', 'math', 'probabilities']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Another Sith Tournament.json,https://codeforces.com//blog/entry/45405,The problem was suggested and prepared by Alexey Dergunov dalex Let s solve the problem using dynamic programming the maximal probability of Ivans victory if the siths from the already fought and the th sith left alive To calculate that DP we should iterate over the next sith he will fight against the th sith C solution 
https://codeforces.com//contest/1428/problem/H,762871,H,1428H,1428,H. Rotary Laser Lock,To prevent the mischievous rabbits from freely roaming around the zoo Zookeeper has set up a special lock for the rabbit enclosure This lock is called the Rotary Laser Lock The lock consists of n concentric rings numbered from 0 to n 1 The innermost ring is ring 0 and the outermost ring is ring n 1 All rings are split equally into nm sections each Each of those rings contains a single metal arc that covers exactly m contiguous sections At the center of the ring is a core and surrounding the entire lock are nm receivers aligned to the nm sections The core has nm lasers that shine outward from the center one for each section The lasers can be blocked by any of the arcs A display on the outside of the lock shows how many lasers hit the outer receivers In the example above there are n 3 rings each covering m 4 sections The arcs are colored in green ring 0 purple ring 1 and blue ring 2 while the lasers beams are shown in red There are nm 12 sections and 3 of the lasers are not blocked by any arc thus the display will show 3 in this case Wabbit is trying to open the lock to free the rabbits but the lock is completely opaque and he cannot see where any of the arcs are Given the of the arcs Wabbit can open the lock on his own To be precise Wabbit needs n 1 integers p 1 p 2 ldots p n 1 satisfying 0 leq p i nm such that for each i 1 leq i n Wabbit can rotate ring 0 clockwise exactly p i times such that the sections that ring 0 covers perfectly aligns with the sections that ring i covers In the example above the relative positions are p 1 1 and p 2 7 To operate the lock he can pick any of the n rings and rotate them by 1 section either clockwise or anti clockwise You will see the number on the display after every rotation Because his paws are small Wabbit has asked you to help him to find the of the arcs You may perform up to 15000 rotations before Wabbit gets impatient ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=3007;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint n, m;\n\nint pole;\n\nint poz[nax];\n\nint zapy;\n\nint policz()\n{\n\tint ret=0;\n\tfor (int i=0; i<n*m; i++)\n\t{\n\t\tint czy=1;\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tint x=i-poz[j];\n\t\t\tx%=(n*m);\n\t\t\tx+=(n*m);\n\t\t\tx%=(n*m);\n\t\t\tif (x<m)\n\t\t\t\tczy=0;\n\t\t}\n\t\tret+=czy;\n\t}\n\treturn ret;\n}\n\nvoid zrob(int v, int kier)\n{\n\tzapy++;\n\tassert(zapy<=15000);\n\tprintf(""? %d %d\\n"", v, kier);\n\tff();\n\tscanf(""%d"", &pole);\n\t\n\t//~ poz[v]=(poz[v]+kier+n*m)%(n*m);\n\t//~ pole=policz();\n}\n\nint los(int a, int b)\n{\n\treturn a+rng()%(b-a+1);\n}\n\nint k;\nvi gru[nax];\n\nvector<pii> graf[nax];\n\nvoid kra(int a, int b, int prz)\n{\n\tprz%=(n*m);\n\tprz+=(n*m);\n\tprz%=(n*m);\n\tgraf[a].push_back({b, prz});\n\tgraf[b].push_back({a, (n*m-prz)%(n*m)});\n}\n\nint malew[nax];\n\nint wyn[nax];\nint bylo[nax];\n\nvoid dfs(int v)\n{\n\tbylo[v]=1;\n\tfor (pii i : graf[v])\n\t{\n\t\tif (!bylo[i.first])\n\t\t{\n\t\t\twyn[i.first]=(wyn[v]+i.second)%(n*m);\n\t\t\tdfs(i.first);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\t//~ for (int i=0; i<n; i++)\n\t\t//~ poz[i]=los(0, n*m-1);\n\t\t//~ poz[i]=i*m;\n\t//~ debug() << range(poz, poz+n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tint x=los(-20, 20);\n\t\twhile(x)\n\t\t{\n\t\t\tzrob(i, x/abs(x));\n\t\t\tx-=x/abs(x);\n\t\t}\n\t}\n\tvi kol(n);\n\tiota(kol.begin(), kol.end(), 0);\n\tshuffle(kol.begin(), kol.end(), rng);\n\tfor (int i : kol)\n\t{\n\t\tint pam=pole;\n\t\twhile(1)\n\t\t{\n\t\t\tzrob(i, 1);\n\t\t\tif (pole<pam)\n\t\t\t{\n\t\t\t\tzrob(i, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpam=pole;\n\t\t}\n\t}\n\t//~ debug() << range(poz, poz+n);\n\t//~ debug() << imie(zapy);\n\t\n\tshuffle(kol.begin(), kol.end(), rng);\n\tfor (int i : kol)\n\t{\n\t\tint mam=0;\n\t\tzrob(i, 1);\n\t\tint pam=pole;\n\t\tfor (int j=0; j<k && !mam; j++)\n\t\t{\n\t\t\tint x=gru[j].back();\n\t\t\tzrob(x, 1);\n\t\t\tif (pole>=pam)\n\t\t\t{\n\t\t\t\tgru[j].push_back(i);\n\t\t\t\tmam=1;\n\t\t\t}\n\t\t\tzrob(x, -1);\n\t\t}\n\t\tzrob(i, -1);\n\t\tif (!mam)\n\t\t{\n\t\t\tgru[k].push_back(i);\n\t\t\tk++;\n\t\t}\n\t}\n\t//~ debug() << imie(k);\n\t//~ for (int i=0; i<k; i++)\n\t\t//~ debug() << gru[i];\n\tfor (int i=0; i<k; i++)\n\t\tfor (int j=1; j<(int)gru[i].size(); j++)\n\t\t\tkra(gru[i][0], gru[i][j], 0);\n\t//~ debug() << imie(zapy);\n\tfor (int i=0; i+1<k; i++)\n\t{\n\t\tint x=gru[i].back();\n\t\tint ruchy=0;\n\t\twhile(1)\n\t\t{\n\t\t\truchy++;\n\t\t\tint pam=pole;\n\t\t\tint oczek=pam;\n\t\t\tif (ruchy<=m)\n\t\t\t\toczek--;\n\t\t\tzrob(x, 1);\n\t\t\tif (pole==oczek)\n\t\t\t\tcontinue;\n\t\t\truchy--;\n\t\t\tzrob(x, -1);\n\t\t\tint znaj=0;\n\t\t\tfor (int j=0; j<k && !znaj; j++)\n\t\t\t{\n\t\t\t\tif (malew[j] || j==i)\n\t\t\t\t\tcontinue;\n\t\t\t\tpam=pole;\n\t\t\t\tint y=gru[j].back();\n\t\t\t\tzrob(y, -1);\n\t\t\t\tint nowe=pole;\n\t\t\t\tzrob(y, 1);\n\t\t\t\tif (nowe>=pam)\n\t\t\t\t{\n\t\t\t\t\tkra(x, y, ruchy+m);\n\t\t\t\t\tmalew[j]=1;\n\t\t\t\t\tznaj=1;\n\t\t\t\t\t//~ debug() << ""od "" << i << "" do "" << j << ""   "" << x << "" "" << y << "" "" << imie(ruchy) << imie(poz[x]) << imie(poz[y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(znaj);\n\t\t\twhile(ruchy--)\n\t\t\t\tzrob(x, -1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(0);\n\t//~ for (int i=0; i<n; i++)\n\t\t//~ debug() << i << "" "" << graf[i];\n\t//~ debug() << range(poz, poz+n);\n\tprintf(""!"");\n\tfor (int i=1; i<n; i++)\n\t\tprintf("" %d"", wyn[i]);\n\tprintf(""\\n"");\n\tff();\n\t//~ for (int i=1; i<n; i++)\n\t\t//~ assert(wyn[i]==((poz[i]-poz[0]+n*m)%(n*m)));\n\t//~ debug() << imie(zapy);\n\treturn 0;\n}\n']",,,"['binary search', 'interactive']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. Rotary Laser Lock.json,https://codeforces.com//blog/entry/83771,Algorithm AnalysisFlatten the circle such that it becomes rows of length with vertical sections numbered from to that loops on the end We say that the position of an arc is if the left endpoint of the arc is at section Indices are taken modulo at all times Moving arcs right is equivalent to rotating them clockwise and moving arcs left is equivalent to rotating them counter clockwise Notice that if we shift arc 0 right and the display increases then the leftmost section of arc 0 had no other arcs in the same section Thus if we shift arc 0 right again and the display does not increase we are certain that there was another arc at that position so we shift arc 0 left We now enter the detection stage to find any arc that coincides with arc 0 of which there exists at least 1 at this position Let s note down this positions as Let be the set of arcs that we do not know the positions of yet this set initially contains all arcs from 1 to and and be an empty sets will be the set of all candidate arcs those that may coincide here and will contain all arcs that we have shifted leftwards Take all elements in and put them in and pick half of the elements in and add them to the set We now shift all elements in left We move arc 0 left to check if any arc is at position If there is then we know that an arc that initially coincided at lies in In this case we set to elements of that are in pick half of the elements in to move right and remove those from If no arc is at position then the arc we are looking for lies in elements in that are not in We set to be and pick half of to move left and add those to We then shift arc 0 right and recurse When we have narrowed to exactly 1 arc we know where exactly that arc is now We shift that arc left such that its right endpoint is at so that it does not cover position which we may still need for future tests Now we remove the arc found from and leave the detection stage and continue searching for the other arcs Once we have found all other arcs we find the relative position to arc 0 and print them as the final output Query AnalysisWhenever we shift arc 0 right and are not in the detection stage we use 1 shift This occurs at most times because it takes up to shifts right to find the first position where arc 0 coincides and another to traverse the entire circle again to find all of the arcs Whenever we enter the detection stage we find one arc and use shifts initially when we move arc 0 right then left yielding a total of such shifts Each binary search requires shifts of arc 0 left and right so across the detection stages this is at most when summed across all stages The way we perform the binary search is quite important here Performing it in a naive manner e g shifting half left test and shifting them back can use up to queries Instead we set the number of elements that move in out of at each iteration of the binary search to be the smaller half This way we can guarantee that the number of shifts done by the candidate arcs is at most the total number of candidate arcs in the first place This becomes since we start with candidate arcs and reduce that number by 1 after each detection stage When we shift each of the arcs left by or depending on whether they were in when we narrowed it down to 1 arc we use at most shifts Thus in total we use at most shifts For this is less than which is much lower than the query limit of Other CommentsThe limit was set higher than the provable bound to allow for other possible solutions At least tester found a different solution that used around queries Some other optimizations that empirically improve the number of queries Instead of using arc as the detector we can randomly pick one of the arcs as the detector arcs At the very beginning we perform some constant number of random shifts of the arcs e g to random shifts This helps to break up long groups of arcs that overlap which speeds up the initial search The official solution augmented with these optimizations uses well below queries and is very consistent for non handcrafted test cases 
https://codeforces.com//contest/2000/problem/D,2814030,D,2000D,2000,D. Right Left Wrong,Vlad found a strip of n cells numbered from left to right from 1 to n In the i th cell there is a positive integer a i and a letter s i where all s i are either or Vlad invites you to try to score the maximum possible points by performing any possibly zero number of operations In one operation you can choose two indices l and r 1 le l r le n such that s l and s r and do the following add a l a l 1 dots a r 1 a r points to the current score replace s i with for all l le i le r meaning you can no longer choose these indices For example consider the following strip 351432 You can first choose l 1 r 2 and add 3 5 8 to your score 351432 Then choose l 3 r 6 and add 1 4 3 2 10 to your score 351432 As a result it is impossible to perform another operation and the final score is 18 What is the maximum score that can be achieved ,"['#include <bits/stdc++.h>#include<array>using namespace std;#define ll long long#define int long long#define y1 idfsu#define PII pair<int, int>#define fi first#define se second#define endl ""\\n""const int MAX = 1e9;const int MAXN = 1e6 + 10;const int mod = 1e9 + 7;const int N = 200010;int aa[200010];void solve(){    int n;    int sum = 0;    cin >> n;    for (int i = 1; i <= n; i++)        cin >> aa[i], aa[i] += aa[i - 1];    string a;    cin >> a;    a = \' \' + a;    int l = 1, r = n;    while (l < r)    {        while (l < r && a[l] == \'R\')            l++;        while (l < r && a[r] == \'L\')            r--;        if (l < r)        {            sum += aa[r] - aa[l - 1];            r--, l++;        }    }    cout << sum << endl;}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int T = 1;    cin >> T;    while (T--)        solve();    return 0;}']",,,"['greedy', 'implementation', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Right Left Wrong.json,https://codeforces.com//blog/entry/132689,Note that since all characters of the selected segment of the string are erased after applying the operation the segments we choose cannot overlap However they can be nested if we first choose an inner segment and then an outer one Since all numbers in the array are positive it is always beneficial to take the largest possible segment in the answer that is from the first to the last By choosing this segment we can only select segments within it We will continue to choose such segments within the last selected one as long as possible To quickly find the sums of the segments we will calculate the prefix sums of the array 
https://codeforces.com//contest/1253/problem/E,472862,E,1253E,1253,E. Antenna Coverage,The mayor of the Central Town wants to modernize Central Street represented in this problem by the Ox axis On this street there are n antennas numbered from 1 to n The i th antenna lies on the position x i and has an initial scope of s i it covers all integer positions inside the interval x i s i x i s i It is possible to increment the scope of any antenna by 1 this operation costs 1 coin We can do this operation as much as we want multiple times on the same antenna if we want To modernize the street we need to make all positions from 1 to m inclusive covered by one antenna Note that it is authorized to cover positions outside 1 m even if it s not required What is the minimum amount of coins needed to achieve this modernization ,"['#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n\nint n,m;\nint X[105], S[105];\nint dp[100005][85];\nvector < int > id;\n\nbool cmp( int a, int b ){\n\tif ( X[a] - S[a] == X[b] - S[b] ){\n\t\treturn X[a] + S[a] < X[b] + S[b];\n\t}\n\treturn X[a] - S[a] < X[b] - S[b];\n}\n\nint f( int pos, int i ){\n\t// printf(""%d %d\\n"", pos, i);\n\tif ( pos > m ){\n\t\treturn 0;\n\t}\n\tif ( i == n ){\n\t\treturn m - pos + 1;\n\t}\n\tint &ans = dp[pos][i];\n\tif ( ans != -1 ) return ans;\n\tans = 1e9;\n\tans = min( ans, f(pos,i+1) );\n\tint x = X[id[i]], s = S[id[i]];\n\tif ( x - s <= pos ){\n\t\tans = min( ans, f(x+s+1,i+1));\n\t} else {\n\t\tint s2 = x - s - pos;\n\t\tans = min( ans, f(x + s2 + s+1, i + 1) + s2);\n\t}\n\treturn ans;\n}\n\nint main(){\n\n\n\tscanf(""%d%d"",&n,&m);\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tscanf(""%d%d"",&X[i],&S[i]);\n\t\tid.push_back(i);\n\t}\n\tsort(id.begin(),id.end(),cmp);\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(""%d\\n"",f(1,0));\n\treturn 0;\n}']",,,"['data structures', 'dp', 'greedy', 'sortings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Antenna Coverage.json,https://codeforces.com//blog/entry/71489?locale=en,We can add an antenna It will not modifiy the answer because it would be non optimal to increase the scope of this antenna Let be the minimum cost to cover all positions from to inclusive knowing that position is covered We compute in decreasing order of Base case is The default transition is If position is initially covered Otherwise let s consider all antennas and their initial intervals If let then a possible transition is We take the minimum of all these transitions Note that we always extend intervals as less as possible but it s optimal because If after using this interval we use another interval at the right of the time spent to extend could have been used to extend instead which will be more optimal If was the last interval used we don t care because the default transition will take care of this case The final answer will be There are states and transitions hence final complexity is with very low constant can also get AC because of very low constant Implementation 
https://codeforces.com//contest/1367/problem/D,650996,D,1367D,1367,D. Task On The Board,Polycarp wrote on the board a string s containing only lowercase Latin letters This string is known for you and given in the input After that he erased some letters from the string s and he rewrote the remaining letters in order As a result he got some new string t You have to find it with some additional information Suppose that the string t has length m and the characters are numbered from left to right from 1 to m You are given a sequence of m integers b 1 b 2 ldots b m where b i is the sum of the distances i j from the index i to all such indices j that t j t i consider that In other words to calculate b i Polycarp finds all such indices j that the index j contains a letter that is later in the alphabet than t i and sums all the values i j For example if t then since t 1 all other indices contain letters which are later in the alphabet that is b 1 1 2 1 3 1 4 1 2 3 6 since t 2 only the index j 3 contains the letter which is later in the alphabet that is b 2 2 3 1 since t 3 then there are no indexes j such that t j t i thus b 3 0 since t 4 only the index j 3 contains the letter which is later in the alphabet that is b 4 4 3 1 Thus if t then b 6 1 0 1 Given the string s and the array b find any possible string t for which the following two requirements are fulfilled simultaneously t is obtained from s by erasing some letters possibly zero and then writing the rest in order the array constructed from the string t according to the rules above equals to the array b specified in the input data ,"[""#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nint h[26];\nchar findmin(int val)\n{\n\tfor(int i = 26; i >= 0; i--)\n\t{\n\t\tif(h[i] >= val)\n\t\t{\n\t\t\th[i] = 0;\n\t\t\treturn char(i + 'a');\n\t\t}\n\t\th[i] = 0;\n\t}\n}\nvoid f()\n{\n\tstring s;\n\tcin >> s;\n\tfl(i,0,26)\n\t{\n\t\th[i] = 0;\n\t}\n\tfl(i,0,s.size())\n\t{\n\t\th[s[i] - 'a']++;\n\t}\n\tint m;\n\tcin >> m;\n\tint arr[m];\n\tint ans[m] = {0};\n\tchar res[m];\n\tint vis[m] = {0};\n\tfl(i,0,m)\n\t{\n\t\tcin >> arr[i];\n\t}\n\tint cnt = 0;\n\twhile(1)\n\t{\n\t\tcnt++;\n\t\t\n\t\tbool f = 1;\n\t\tint val = 0;\n\t\tfl(i,0,m)\n\t\t{\n\t\t\tif(vis[i] == 0 && arr[i] == 0)\n\t\t\t{\n\t\t\t\tval++;\n\t\t\t}\n\t\t}\n\t\tchar c = findmin(val);\n\t\tfl(i,0,m)\n\t\t{\n\t\t\tif(vis[i] == 0 && arr[i] == 0)\n\t\t\t{\n\t\t\t\tf = 0;\n\t\t\t\tvis[i] = cnt;\n\t\t\t\tres[i] = c;\n\t\t\t}\n\t\t}\n\t\tfl(i,0,m)\n\t\t{\n\t\t\tfl(j,0,m)\n\t\t\t{\n\t\t\t\tif(vis[i] == 0 && vis[j] == cnt)\n\t\t\t\t{\n\t\t\t\t\tarr[i] -= abs(i - j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t}\n\tfl(i,0,m)\n\t{\n\t\tcout << res[i];\n\t}\n\tcout << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}""]",,,"['constructive algorithms', 'greedy', 'implementation', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Task On The Board.json,https://codeforces.com//blog/entry/78864,We will construct the string starting with the largest letters Note that if then the th letter of the string is maximal so we know that the th letter affect all While the string is not completely constructed we will do the following Find all such that and the th character of string is not placed Put on all these positions in the string the maximum letter not used in the string there should be a sufficient number of letters in the string Subtract from all 
https://codeforces.com//contest/601/problem/C,41471,C,601C,601,C. Kleof and the n-thlon,Kleof is participating in an thlon a tournament consisting of different competitions in different disciplines numbered through There are participants in the thlon and each of them participates in all competitions In each of these competitions the participants are given from to in such a way that no two participants are given the same rank in other words the ranks in each competition form a permutation of numbers from to The of a participant in a competition is equal to his her rank in it The of each participant is computed as the sum of that participant s scores in all competitions The of each participant is equal to where is the number of participants with overall score The thlon is over now but the results haven t been published yet Kleof still remembers his ranks in each particular competition however he doesn t remember anything about how well the other participants did Therefore Kleof would like to know his expected overall rank All competitors are equally good at each discipline so all rankings permutations of ranks of everyone except Kleof in each competition are equiprobable ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,m,x;\nlong double dp[1010000],s[1010000];\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\tdp[0]=1;\n\tif (m==1) { puts(""1""); return 0; }\n\tint S=0;\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",&x);\n\t\tS+=x;\n\t\ts[0]=dp[0];\n\t\trep(j,1,i*m+1) s[j]=s[j-1]+dp[j];\n\t\tper(j,1,i*m+1) {\n\t\t\tdp[j]=s[j-1];\n\t\t\tif (j-m-1>=0) dp[j]-=s[j-m-1];\n\t\t\tif (j-x>=0) dp[j]-=dp[j-x];\n\t\t\tdp[j]/=(m-1);\n\t\t}\n\t\tdp[0]=0;\n\t//\trep(j,1,i*m+1) printf(""%.10f "",dp[j]);\n\t//\tputs("""");\n\t}\n\tdouble prob=0;\n\trep(i,0,S) prob+=dp[i];\n\tprintf(""%.10f\\n"",1+prob*(m-1));\n}\n']",,,"['dp', 'math', 'probabilities']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Kleof and the n-thlon.json,https://codeforces.com//blog/entry/21755,Some dynamic programming Definitely not for the exp score of one person look at fixed scores instead 
https://codeforces.com//contest/1728/problem/G,1534228,G,1728G,1728,G. Illumination,Consider a segment 0 d of the coordinate line There are n lanterns and m points of interest in this segment For each lantern you can choose its power an integer between 0 and d inclusive A lantern with coordinate x illuminates the point of interest with coordinate y if x y is less than or equal to the power of the lantern A way to choose the power values for all lanterns is considered if every point of interest is illuminated by at least one lantern You have to process q queries Each query is represented by one integer f i To answer the i th query you have to add a lantern on coordinate f i calculate the number of valid ways to assign power values to all lanterns and print it modulo 998244353 remove the lantern you just added ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int P = 998244353;\n\nint add(int x, int y) {\n\tif (x + y >= P) return x + y - P;\n\treturn x + y;\n}\n\nint sub(int x, int y) {\n\tif (x < y) return x - y + P;\n\treturn x - y;\n}\n\nint mul(int x, int y) { return 1ull * x * y % P; }\n\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn ans;\n}\n\ninline void upd(int& x, int y) { x = add(x, y); }\n\nconst int N = 3e5 + 5;\n\nint ans[N], p[N], a[25], c[25][25], v[25][25];\nint d, n, m, q;\n\nint getpos(int x) {\n\tint ans = 0;\n\twhile (ans < m && a[ans + 1] <= x) ++ans;\n\treturn ans;\n}\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\td = read();\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++) p[i] = read();\n\tfor (int i = 1; i <= m; i++) a[i] = read();\n\tsort(a + 1, a + m + 1);\n\tfor (int l = 0; l <= m + 1; l++) {\n\t\tfor (int r = l; r <= m + 1; r++) c[l][r] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = getpos(p[i]);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, p[i] - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - p[i]);\n\t\t\t\tc[l][r] = mul(c[l][r], lim);\n\t\t\t\t// fprintf(stderr, ""c[%d][%d] = %d, lim = %d\\n"", l, r, c[l][r], lim);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tint now = 1, las = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tnow = mul(now, c[las][j + 1]);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tnow = mul(now, c[las][m + 1]);\n\t\tlas = 0;\n\t\tif (__builtin_popcount(i) & 1) now = sub(0, now);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tupd(v[las][j + 1], now);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tupd(v[las][m + 1], now);\n\t}\n\tfor (int x = 1; x <= d - 1; x++) {\n\t\tint pos = getpos(x);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, x - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - x);\n\t\t\t\tupd(ans[x], mul(lim, v[l][r]));\n\t\t\t}\n\t\t}\n\t}\n\tq = read();\n\twhile (q--) {\n\t\tint x = read();\n\t\tprintf(""%d\\n"", ans[x]);\n\t}\n}']",,,"['binary search', 'bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'two pointers']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Illumination.json,https://codeforces.com//blog/entry/106805,Let s start without the queries How to calculate the number of ways for the given lanterns First it s much easier to calculate the number of bad ways some point of interest is not illuminated If at least one point of interest is not illuminated then all lanterns have power lower than the distance from them to this point of interest More importantly it s less than Thus the number of good ways is minus the number of bad ways Let s use inclusion exclusion For a mask of non illuminated points of interest let s calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated All other points can be either illuminated or not Let s call it With the values for all masks the answer is the sum of over all masks How to calculate the value for the mask First let s do it in for each mask Each lantern can have any power from to the distance to the closest point of interest inside the mask non inclusive Thus we can iterate over the lanterns and find the closest point to each of them then multiply the number of ways for all lanterns Let s calculate it the other way around Initialize the answers for the masks with Then iterate over the lantern and the point of interest that will be the closest non illuminated one to this lantern Let the distance between them be some value Which masks will this pair affect Let the lantern be to the right of that point of interest The opposite can be handled similarly All points to the left of the chosen point can be in either state All points between the chosen one and the lantern must be illuminated All points to the right of the lantern and with distance smaller than must also be illumunated All point to the right of these can be in either state Thus the masks look like 1000 000 where 1 denotes the chosen non illuminated point All masks that correspond to this template will be multiplied by You have to be careful when there are two points of interest with the same distance to some lantern one to the left of it and one to the right of it In particular in one case you should force illumination on all points with distance In another case you should force illumination on all points with distance How to multiply fast enough We ll use a technique called sum over subsets Let s express the template in terms of submasks For a template 100000 all submasks of 111100000111 will be multiplied by However we accidentally multiplied masks of form 000000 too Let s cancel them by dividing the submasks of 111000000111 by Record all multiplications for all pairs them force push them into submasks with sum over subsets well product over subsets in this case Now we have the values of for all masks in basically give or take the time to find the points that must be forced illuminated extra from lower bound or two pointers which is not really faster Now for the queries How does the answer change after an extra lantern is added Again let s iterate over the closest point of interest and find the mask template All masks corresponding to this template will get multiplied by Thus the answer will change by the sum of values of these masks multiplied by including the inclusion exclusion coefficient How to handle that Well yet another sum over subsets Just collect the sum of values over the submasks beforehand and use these during the query That gives us an per query Overall complexity 
https://codeforces.com//contest/1713/problem/A,1496884,A,1713A,1713,A. Traveling Salesman Problem,You are living on an infinite plane with the Cartesian coordinate system on it In one move you can go to any of the four adjacent points left right up down More formally if you are standing at the point x y you can go left and move to x 1 y or go right and move to x 1 y or go up and move to x y 1 or go down and move to x y 1 There are n boxes on this plane The i th box has coordinates x i y i It is guaranteed that the boxes are either on the x axis or the y axis That is either x i 0 or y i 0 You can collect a box if you and the box are at the same point Find the minimum number of moves you have to perform to collect all of these boxes if you have to at the point 0 0 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\n\nbool solve(int caseN) {\n    int n;\n    cin >> n;\n\n    int minX = 0, maxX = 0, minY = 0, maxY = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n    }\n    cout << 2*(maxX-minX+maxY-minY) << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""complexity.in"", ""r"", stdin);\n    // freopen(""complexity.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(i); /*\n    for (int i = 1; solve(i); i++); /**/\n    cout.flush();\n    return 0;\n}']",,,"['geometry', 'greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Traveling Salesman Problem.json,https://codeforces.com//blog/entry/105419,Suppose we only have boxes on the axis then the optimal strategy is going in the following way There is no way to do in less than moves What if we have boxes on two axis Let s assume it is suppose we have a strategy to go in the following way In this case it is optimal to fill the three dots with which is just solving each axis independently Therefore the number of axis does not matters For each axis that has at least one box go from to the farthest one then come back to Time complexity Solution 
https://codeforces.com//contest/1433/problem/C,766658,C,1433C,1433,C. Dominant Piranha,There are n piranhas with sizes a 1 a 2 ldots a n in the aquarium Piranhas are numbered from left to right in order they live in the aquarium Scientists of the Berland State University want to find if there is piranha in the aquarium The piranha is called if it can eat all the other piranhas in the aquarium except itself of course Other piranhas will do nothing while the piranha will eat them Because the aquarium is pretty narrow and long the piranha can eat only one of the adjacent piranhas during one move Piranha can do as many moves as it needs or as it can More precisely The piranha i can eat the piranha i 1 if the piranha i 1 exists and a i 1 a i The piranha i can eat the piranha i 1 if the piranha i 1 exists and a i 1 a i When the piranha i eats some piranha its a i becomes a i 1 Your task is to find piranha in the aquarium or determine if there are no such piranhas Note that you have to find exactly one dominant piranha you don t have to find all of them For example if a 5 3 4 4 5 then the third piranha can be Consider the sequence of its moves The piranha eats the second piranha and a becomes 5 underline 5 4 5 the underlined piranha is our candidate The piranha eats the third piranha and a becomes 5 underline 6 5 The piranha eats the first piranha and a becomes underline 7 5 The piranha eats the second piranha and a becomes underline 8 You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define forinc(i,a,b) for(int i=a;i<=b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forv(i,x) for(auto &i:x)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r)\n{\n    return l+rng()%(r-l+1);\n}\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c==\'-\');for(;isdigit(c);c=getchar()) x=x*10+c-\'0\';n?-x:x;})\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define batbit(i,x) (x|(1ll<<i))\n#define getbit(i,x) ((x>>i)&1)\n\nconst int mn=3e5+10;\nint a[mn];\n\nmain()\n{\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        int ma=0,kq=0,ok=0;\n        forinc(i,1,n)\n        {\n            cin >> a[i];\n            ma=max(ma,a[i]);\n            if(a[i]!=a[i-1]&&i!=1) ok=1;\n        }\n        forinc(i,1,n) if(a[i]==ma)\n        {\n            if(i!=1&&a[i]>a[i-1])\n            {\n                kq=i;\n                break;\n            }\n            if(i!=n&&a[i]>a[i+1])\n            {\n                kq=i;\n                break;\n            }\n        }\n        if(!ok) cout << -1 << ""\\n"";\n        else cout << kq << ""\\n"";\n    }\n}\n']",,,"['constructive algorithms', 'greedy']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Dominant Piranha.json,https://codeforces.com//blog/entry/83903,If all the piranhas have the same size then the answer is Otherwise there are at least two different sizes of piranhas and the answer always exists Claim that the answer is such a piranha with the maximum size that one of the adjacent piranhas has the size less than a maximum Why is it true and why the answer always exists First if the piranha with the maximum size eats some other piranha it becomes the only maximum in the array and can eat all other piranhas Why is there always such a pair of piranhas Let s change our array a bit replace every maximum with and every non maximum with There is always some pair or pair in such array because we have at least two different elements 
https://codeforces.com//contest/1366/problem/C,646801,C,1366C,1366,C. Palindromic Paths,You are given a matrix with n rows numbered from 1 to n and m columns numbered from 1 to m A number a i j is written in the cell belonging to the i th row and the j th column each number is either 0 or 1 A chip is initially in the cell 1 1 and it will be moved to the cell n m During each move it either moves to the next cell in the current row or in the current column if the current cell is x y then after the move it can be either x 1 y or x y 1 The chip cannot leave the matrix Consider each path of the chip from 1 1 to n m A path is called if the number in the first cell is equal to the number in the last cell the number in the second cell is equal to the number in the second to last cell and so on Your goal is to change the values in the minimum number of cells so that path is ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tint s = n-1 + m-1;\n\tvector<vector<int> > freqs(n + m, vector<int>(2, 0));\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(i + j == (s - i - j)) continue;\n\t\t\tint r = min(i + j, s - i - j);\n\t\t\tfreqs[r][a]++;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(vector<int> z : freqs){\n\t\tans += min(z[0], z[1]);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]",,,"['greedy', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Palindromic Paths.json,https://codeforces.com//blog/entry/78735,Let s group the cells by their distance from the starting point the group consists of a single cell the group consists of the cells and and so on In total there are groups Let s analyze the groups and There are two cases if or then we are looking at the starting cell and the ending cell and their contents should be equal otherwise suppose two cells and belong to the same group We can easily prove that the contents of these two cells should be equal for example by analyzing two paths that go through cell and coincide after this cell but one goes to from and another from and using induction we can prove that the contents of all cells in a group should be equal And since the paths should be palindromic the contents of the group should be equal to the contents of the group So in each pair of groups we should calculate the number of s and s and choose which of them to change Note that if is even the central group has no pair so it should not be modified 
https://codeforces.com//contest/1547/problem/A,1041925,A,1547A,1547,A. Shortest Path with Obstacle,There are three cells on an infinite 2 dimensional grid labeled A B and F Find the length of the shortest path from A to B if in one move you can go to any of the four adjacent cells sharing a side visiting the cell F is forbidden it is an obstacle ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        int ans = abs(x1 - x2) + abs(y1 - y2);\n        if (x1 == x2 && x1 == x3 && min(y1, y2) <= y3 && max(y1, y2) >= y3) {\n            ans += 2;\n        }\n        if (y1 == y2 && y1 == y3 && min(x1, x2) <= x3 && max(x1, x2) >= x3) {\n            ans += 2;\n        }\n        cout << ans << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']",,,"['implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Shortest Path with Obstacle.json,https://codeforces.com//blog/entry/92715,Let s suppose that the forbidden cell does not affect the shortest path In that case the answer would be The forbidden cell blocks the shortest path if and only if it belongs to every shortest path In other words if there is only one shortest path and the forbidden cell belongs to it So the answer differs from if and only if and are in one row or column and is between them In that case the answer is i e greater by In order to check that point lays between and on a straight line just check So the correct solution looks like this 
https://codeforces.com//contest/596/problem/A,40905,A,596A,596,A. Wilbur and Swimming Pool,After making bad dives into swimming pools Wilbur wants to build a swimming pool in the shape of a rectangle in his backyard He has set up coordinate axes and he wants the sides of the rectangle to be parallel to them Of course the area of the rectangle must be positive Wilbur had all four vertices of the planned pool written on a paper until his friend came along and erased some of the vertices Now Wilbur is wondering if the remaining vertices of the initial rectangle give enough information to restore the area of the planned swimming pool ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nset<int> x, y;\nmap<int, int> cntx, cnty;\n\nvoid ex () {\n    cout << -1 << endl;\n    exit(0);\n}\n\nint32_t main () {\n    ios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        int a, b; cin >> a >> b;\n        cntx[a]++;\n        cnty[b]++;\n        x.insert(a);\n        y.insert(b);    \n    }\n    if ((int) x.size() == 2 && (int) y.size() == 2) {\n        auto it1 = x.begin(); if (cntx[*it1] > 2) ex(); it1++;if (cntx[*it1] > 2) ex();\n        auto it2 = y.begin(); if (cnty[*it2] > 2) ex(); it2++;if (cnty[*it2] > 2) ex();\n        cout << (*it1 - *(x.begin())) * (*it2 - *(y.begin()));\n    } else {\n        cout << -1; \n    }\n        \n            \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",,,"['geometry', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Wilbur and Swimming Pool.json,https://codeforces.com//blog/entry/21599,It is a necessary and sufficient condition that we have exactly 2 distinct values for and If we have less than 2 distinct values for any variable then there is no way to know the length of that dimension If there are at least 3 distinct values for any variable then that means more than 3 vertices lie on that dimension which cannot happen since there can be at most 2 vertices in a line segment The area if it can be found is just the difference of values of the coordinates times the difference of values of the coordinates Complexity Code Solution No matter what we make operations to make equal to Once this is done Then no matter what we must make operations to make equal to In general to make we need to make operations so in total we make operations Complexity Code Solution Note that if there is an integer so that the number of equal to differs from the number of the given squares whose weight equals then the answer is automatically NO This can be easily checked by using a map for the and the weights of the squares and checking if the maps are the same This step takes time Let be an integer and let be the set of all so that Let be the set of all special points so that the weight of is Note that and have the same number of elements Suppose that are the elements of Let if or and Suppose that are the elements of Note that the point has to be labeled by for Now each special point is labeled It remains to check if this is a valid labeling This can be done by taking an array of vectors The vector will denote the points with coordinate This vector can be easily made from the points given in time and since the points are already labeled will denote the label for the point Now for all points the point if it is special and the point if it is special must have a greater number than This step takes a total of time Complexity Code Solution Bonus Can you do this problem in time Comments This problem was inspired by the representation theory of the group of permutations Representation theory of the Symmetric Group Essential objects in the study of are Young diagrams and standard Young tableau Young Tableau The weight of a point as defined by the problem is basically the same thing as the content of a square in a standard Young tableaux If you have questions feel free to message me Let us solve this problem using dynamic programming First let us reindex the trees by sorting them by coordinate Let where we would like to consider the problem of if we only have trees standing where indicates that tree falls right and if it falls left and indicates that tree falls right and if it falls left We start with the case that Wilbur chooses the left tree and it falls right The plan is to calculate the expected length in this scenario and multiply by the chance of this case occurring which is We can easily calculate what is the farthest right tree that falls as a result of this and call it Then if this means the entire segment falls from which the length of the ground covered by trees in can be calculated However be careful when as there may be overlapping covered regions when the tree falls right but the tree falls left If only then we just consider adding the length of ground covered by trees falling right and add to the value of the subproblem There is another interesting case where Wilbur chooses the left tree and it falls left In this case we calculate the expected length and multiply by the chance of this occurring which is The expected length of ground covered by the trees here is just the length contributed by tree falling left which we must be careful calculating as there might be overlapping covered regions with the th tree falling left and the th tree falling right Then we also add the value of subproblem Doing this naively would take time but this can be lowered to by precalculating what happens when tree falls left or right We should also consider the cases that Wilbur chooses the right tree but these cases are analogous by symmetry Complexity Code Solution Solution 1 Suppose that is a string in the query Reverse and the direction of all the moves that can be made on the table Note that starting at any point that is part of a cycle there is a loop and then edges that go out of the loop So for every point it can be checked by dfs whether the can be made by starting at that point by storing what is in the cycle Moreover note that in the reversed graph each point can only be a part of one cycle Therefore the total time for the dfs in a query is This is good enough for queries to run in time Complexity where is the number of distinct characters in the table and is the query string for the th query Code Solution Solution 2 Actually too slow see comment by waterfalls below for more details For each string dfs from every node that has in degree equal to in the original graph There will be a path which leads into a cycle after which anything in the cycle can be used any number of times in Only every node with in degree equal to has to be checked because every path which leads to a cycle is part of a larger path which starts with a vertex of in degree that leads into a cycle This solution is slower but it works in practice since it is really hard for a string to match so many times in the table Each query will take time but it is much faster in practice Complexity where is the number of distinct characters in the table and is the query string of the th query 
https://codeforces.com//contest/1265/problem/E,486712,E,1265E,1265,E. Beautiful Mirrors,Creatnx has n mirrors numbered from 1 to n Every day Creatnx asks exactly one mirror Am I beautiful The i th mirror will tell Creatnx that he is beautiful with probability frac p i 100 for all 1 le i le n Creatnx asks the mirrors one by one starting from the 1 st mirror Every day if he asks i th mirror there are two possibilities The i th mirror tells Creatnx that he is beautiful In this case if i n Creatnx will stop and become happy otherwise he will continue asking the i 1 th mirror next day In the other case Creatnx will feel upset The next day Creatnx will start asking from the 1 st mirror again You need to calculate the expected number of days until Creatnx becomes happy This number should be found by modulo 998244353 Formally let M 998244353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"[""#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=2e5+5;\nconst int mod=998244353;\nint n,p[maxn];\ninline int ksm(int x,int k){\n\tint s=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod)if(k&1)s=1ll*s*x%mod;\n\treturn s;\n}\nint dp[maxn];\nint main(){\n\tn=read();\n\tint inv=ksm(100,mod-2);\n\tfor(int i=1;i<=n;i++){\n\t\tp[i]=read();\n\t\tp[i]=1ll*p[i]*inv%mod;\n\t}\n\tdp[1]=0;\n\tfor(int i=2;i<=n+1;i++)dp[i]=1ll*(dp[i-1]+1)*ksm(p[i-1],mod-2)%mod;\n\tcout<<dp[n+1]<<'\\n';\n\treturn 0;\n}\n\n""]",,,"['data structures', 'dp', 'math', 'probabilities']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Beautiful Mirrors.json,https://codeforces.com//blog/entry/71995,Let be the probability that the th mirror will answer YES when it is asked That is this equals to in the problem statement divide by 100 Let be the expected number of days until Creatnx becomes happy when initially he is at the th mirror For convenient let because when Creatnx is at th mirror he is happy already The answer of the problem will be By the definition of expectation value and its basic properties the following must holds for all Let explain this equation for those who are not familiar with probability Expectation value is just average of all possible outcomes The first number 1 in the right hand side means Creatnx spends 1 day to ask the th mirror With probability of the th mirror will answer YES and Creatnx will move to the th mirror in the next day At the th mirror Creatnx on average needs to spend days more to become happy The second term explains this case Similarly the third term represents the case where the th mirror answers NO To find we need to solve equations 1 2 We can solve this system of equations by using substitution a common technique From equation 1 we have Substituting this in 2 we obtained See the pattern now Similarly by substituting to that last equation we have We can compute according to the above formula in 
https://codeforces.com//contest/18/problem/C,84,C,18C,18,C. Stripe,Once Bob took a paper stripe of squares the height of the stripe is 1 square In each square he wrote an integer number possibly negative He became interested in how many ways exist to cut this stripe into two pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece and each piece contains positive integer amount of squares Would you help Bob solve this problem ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""g""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\n\nint const N=100005;\n\nint a[N], s[N];\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n\n\n    int n;\n    cin >> n;\n    s[0]=0;\n    for (int i=1; i<=n; i++) {\n        cin >> a[i];\n        s[i]=s[i-1]+a[i];\n    }\n    int res=0;\n    for (int i=1; i<n; i++)\n        if (s[i]+s[i]==s[n])\n            res++;\n    cout << res << endl;\n    return 0;\n}']",,,"['data structures', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Stripe.json,https://codeforces.com//blog/entry/463,One should keep two sums S1 ans S2 where S1 is the sum of all numbers on the left part of the stripe and S2 is the sum of the right one At the beginning S1 0 and S2 equals to the sum of all numbers of the stripe Then we move the border of the parts within a cycle from left to right recalculating the values of S1 and S2 each iteration and increasing the answer when it s necessary 
https://codeforces.com//contest/1665/problem/D,1360543,D,1665D,1665,D. GCD Guess,There is a positive integer 1 le x le 10 9 that you have to guess In one query you can choose two positive integers a neq b As an answer to this query you will get gcd x a x b where gcd n m is the greatest common divisor of the numbers n and m To guess one hidden number x you are allowed to make no more than 30 queries ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nconst int TEST=0;\nint x;\ninline int ask(int a,int b)\n{\n\tcout << ""? "" << a << "" "" << b << endl;\n\tint k;\n\tif(!TEST)\n\t{\n\t\tcin >> k;\n\t\treturn k;\n\t}\n\tif(TEST)\n\t{\n\t\tcout << __gcd(x+a,x+b) << endl;\n\t\treturn __gcd(x+a,x+b);\n\t}\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tif(TEST) cin >> x;\n\t\tint now=0;\n\t\tfor(int i=0;i<=29;i++)\n\t\t{\n\t\t\tint a=1<<i,b=(3<<i);\n\t\t\tint x=ask(a-now,b-now);\n\t\t\tif(x%(a+a)==0) now+=a;\n\t\t}\n\t\tcout << ""! "" << now << endl;\n\t}\n\treturn 0;\n}']",,,"['bitmasks', 'chinese remainder theorem', 'constructive algorithms', 'games', 'interactive', 'math', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. GCD Guess.json,https://codeforces.com//blog/entry/101663,EditorialSolution 1Let s iteratively find the remainder of each power of Initially we know that If we know that then how do we find To do that let s ask If then else Using this algorithm we will find which is just It takes exactly queries Solution 2Let s consider a set of pairwise coprime numbers Their that s why Let s find each of these numbers To do that for each we can ask the query is If the is a multiple of some number from our set then this number is After that we can use the chinese remainder theorem to find that gives the same remainders for numbers from the set This solution asks only queries Observation 1 It s enough to make only queries because if we did not find anything for then we can guarantee that will do Observation 2 All moduli are small that s why it is possible to use a simplified CRT check the implementation 
https://codeforces.com//contest/1015/problem/E1,203550,E1,1015E1,1015,E1. Stars Drawing  Easy Edition ,A is a figure of the following type an asterisk character in the center of the figure and four rays to the left right top bottom of the same positive length The size of a is the length of its rays The size of a star must be a positive number i e rays of length 0 are not allowed Let s consider empty cells are denoted by then the following figures are You are given a rectangular grid of size n times m consisting only of asterisks and periods dots Rows are numbered from 1 to n columns are numbered from 1 to m Your task is to draw this grid using number of or find out that it is impossible can intersect overlap or even coincide with each other The number of in the output can t exceed n cdot m Each star should be completely inside the grid You can use stars of same and arbitrary sizes ,"['#include <bits/stdc++.h>\n\n#define p_b push_back\n#define endl ""\\n""\n#define m_p make_pair\n#define fi first\n#define se second\n#define pll pair <ll,ll>\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\ntypedef long long ll;\n\nll binpow(ll a,ll n)\n{\n    ll res = 1;\n    while(n)\n    {\n        if(n % 2)res *= a;\n        a *= a;\n        n /= 2;\n    }\n    return res;\n}\n\ntemplate <typename T>\nT sqr(T x)\n{\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s)\n{\n    cout << s << endl;\n    exit(0);\n}\n\nll log(ll a,ll b){\n    ll res = 0;\n    while(a){\n        a /= b;\n        res++;\n    }\n    return res;\n}\n\nconst ll MAXN = 1123456;\n\nint n, m;\nll pref[1001][1001], prefu[1001][1001];\nchar a[1001][1001];\n\nll z[1003][1003], zu[1003][1003];\nll b[1003][1003];\n\nvector<pair<pll,ll> > ans;\n\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(""1.in"",""r"",stdin);\n    //freopen(""1.out"",""w"",stdout);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i){\n        for (int j = 1; j <= m; ++j){\n            cin >> a[i][j];\n            pref[i][j] = pref[i][j - 1] + (a[i][j] == \'*\');\n            prefu[i][j] = prefu[i - 1][j] + (a[i][j] == \'*\');\n        }\n    }\n\n    for (int i = 1; i <= n; ++i){\n        for (int j = 1; j <= m; ++j){\n            if (a[i][j] == \'*\'){\n                ll l = 0, r = min(m - j, min(i - 1, min(n - i, j - 1)));\n                ll p = r;\n\n\n//                if (i == 3 && j == 5) cout << pref[i][j + r] << "" "" <<  pref[i][j - r - 1] << ""+"" << endl;\n//                if (i == 3 && j == 5) cout << prefu[i + r][j] << "" "" <<  prefu[i - r - 1][j] << ""+"" << endl;\n\n                while (l + 1 < r){\n                    ll c = (l + r) / 2;\n                    if ((prefu[i + c][j] - prefu[i - c - 1][j] == (i + c) - (i - c) + 1)\n                     && (pref[i][j + c] - pref[i][j - c -1] == (i + c) - (i - c) + 1 )) l = c; else r = c - 1;\n                }\n                ll c = l + 1;\n                while (l != p && (prefu[i + c][j] - prefu[i - c - 1][j] == (i + c) - (i - c) + 1)\n                     && (pref[i][j + c] - pref[i][j - c -1] == (i + c) - (i - c) + 1 )) {\n                    l = c;\n                    c = l + 1;\n                     }\n//                if (i == 3 && j == 5) {\n//                    cout << l << ""___"" << endl;\n//                }\n\n                if (l != 0) {\n                    ans.p_b({{i, j}, l});\n                    zu[i - l][j] += 1;\n                    zu[i + l + 1][j] += -1;\n                    z[i][j - l] += 1;\n                    z[i][j + l + 1] += -1;\n                }\n            }\n        }\n    }\n\n\n    for (int i = 1; i <= n; i++) {\n        ll o = 0;\n        for (int j = 1; j <= m; j++) {\n            o += z[i][j];\n            b[i][j] += o;\n        }\n    }\n\n\n    for (int j = 1; j <= m; j++) {\n        ll o = 0;\n        for (int i = 1; i <= n; i++) {\n            o += zu[i][j];\n            b[i][j] += o;\n        }\n    }\n\n//    for (int i = 1; i <= n; i++) {\n//        for (int j = 1; j <= m; j++) cout << b[i][j] << "" "";\n//        cout << endl;\n//    }\n\n\n\n    for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n        if (a[i][j] == \'*\' && b[i][j] != 0) continue;\n        if (a[i][j] != \'*\' && b[i][j] == 0) continue;\n        cout << -1;\n        return 0;\n    }\n\n\n    cout << ans.size() << endl;\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i].fi.fi << "" "" << ans[i].fi.se << "" "" << ans[i].se << endl;\n    }\n\n    return 0;\n}\n']",,,"['brute force', 'dp', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E1. Stars Drawing  Easy Edition .json,https://codeforces.com/blog/entry/60949,Since we are almost unlimited in the number of in the answer the following solution will works We iterate over all possible centers and try to extend rays of the current as large as possible It can be done by the simple iterating and checking in If the size of the current is non zero let s add it to the answer It is obvious that the number of in such answer will not exceed Then let s try to draw all these on the empty grid Drawing of each is also can be done in If after drawing our grid equals to the input grid the answer is and our set of is the correct answer Otherwise the answer is Time complexity 
https://codeforces.com//contest/222/problem/C,1638,C,222C,222,C. Reducing Fractions,To confuse the opponents the Galactic Empire represents fractions in an unusual format The fractions are represented as two sets of integers The product of numbers from the first set gives the fraction numerator the product of numbers from the second set gives the fraction denominator However it turned out that the programs that work with fractions in this representations aren t complete they lack supporting the operation of reducing fractions Implement this operation and the Empire won t forget you ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#define min(a,b) (((a)<(b))?(a):(b))\nusing namespace std;\n\nbool visit[ 3164 ];\nint prime[ 1000 ], pcnt;\nint faca[ 100001 ][ 10 ][ 2 ], facb[ 100001 ][ 10 ][ 2 ], c1[ 100001 ], c2[ 100001 ], f1[ 10000001 ], f2[ 10000001 ];\n\nvoid init( )\n{\n\tint i, j;\n\tfor ( i = 2; i <= 3163; i++ )\n\t\tif ( !visit[ i ] )\n\t\t{\n\t\t\tprime[ pcnt++ ] = i;\n\t\t\tfor ( j = i * 2; j <= 3163; j += i )\n\t\t\t\tvisit[ j ] = 1;\n\t\t}\n}\n\nint main( )\n{\n\tint n, m, i, j, k, t, p;\n\tscanf(""%d%d"", &n, &m);\n\tinit( );\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tscanf(""%d"", &t);\n\t\tif ( t == 1 )\n\t\t{\n\t\t\tc1[ i ] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( j = 0; prime[ j ] * prime[ j ] <= t; j++ )\n\t\t\tif ( t % prime[ j ] == 0 )\n\t\t\t{\n\t\t\t\tfaca[ i ][ c1[ i ] ][ 0 ] = prime[ j ];\n\t\t\t\twhile ( t % prime[ j ] == 0 )\n\t\t\t\t{\n\t\t\t\t\tt /= prime[ j ];\n\t\t\t\t\tf1[ prime[ j ] ]++;\n\t\t\t\t\tfaca[ i ][ c1[ i ] ][ 1 ]++;\n\t\t\t\t}\n\t\t\t\tc1[ i ]++;\n\t\t\t}\n\t\tif ( t != 1 )\n\t\t{\n\t\t\tfaca[ i ][ c1[ i ] ][ 0 ] = t;\n\t\t\tfaca[ i ][ c1[ i ]++ ][ 1 ] = 1;\n\t\t\tf1[ t ]++;\n\t\t}\n\t}\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tscanf(""%d"", &t);\n\t\tif ( t == 1 )\n\t\t{\n\t\t\tc2[ i ] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( j = 0; prime[ j ] * prime[ j ] <= t; j++ )\n\t\t\tif ( t % prime[ j ] == 0 )\n\t\t\t{\n\t\t\t\tfacb[ i ][ c2[ i ] ][ 0 ] = prime[ j ];\n\t\t\t\twhile ( t % prime[ j ] == 0 )\n\t\t\t\t{\n\t\t\t\t\tt /= prime[ j ];\n\t\t\t\t\tf2[ prime[ j ] ]++;\n\t\t\t\t\tfacb[ i ][ c2[ i ] ][ 1 ]++;\n\t\t\t\t}\n\t\t\t\tc2[ i ]++;\n\t\t\t}\n\t\tif ( t != 1 )\n\t\t{\n\t\t\tfacb[ i ][ c2[ i ] ][ 0 ] = t;\n\t\t\tfacb[ i ][ c2[ i ]++ ][ 1 ] = 1;\n\t\t\tf2[ t ]++;\n\t\t}\n\t}\n\tfor ( i = 2; i <= 10000000; i++ )\n\t{\n\t\tt = min( f1[ i ], f2[ i ] );\n\t\tf1[ i ] -= t;\n\t\tf2[ i ] -= t;\n\t}\n\tprintf(""%d %d\\n"", n, m);\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tt = 1;\n\t\tfor ( j = 0; j < c1[ i ]; j++ )\n\t\t\tfor ( k = 0; k < faca[ i ][ j ][ 1 ] && f1[ faca[ i ][ j ][ 0 ] ]; k++ )\n\t\t\t{\n\t\t\t\tf1[ faca[ i ][ j ][ 0 ] ]--;\n\t\t\t\tt *= faca[ i ][ j ][ 0 ];\n\t\t\t}\n\t\tif ( i != 0 ) printf("" "");\n\t\tprintf(""%d"", t);\n\t}\n\tputs("""");\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tt = 1;\n\t\tfor ( j = 0; j < c2[ i ]; j++ )\n\t\t\tfor ( k = 0; k < facb[ i ][ j ][ 1 ] && f2[ facb[ i ][ j ][ 0 ] ]; k++ )\n\t\t\t{\n\t\t\t\tf2[ facb[ i ][ j ][ 0 ] ]--;\n\t\t\t\tt *= facb[ i ][ j ][ 0 ];\n\t\t\t}\n\t\tif ( i != 0 ) printf("" "");\n\t\tprintf(""%d"", t);\n\t}\n\tputs("""");\n\treturn 0;\n}\n']",,,"['implementation', 'math', 'number theory', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Reducing Fractions.json,https://codeforces.com//blog/entry/5251,Let s factorize the numerator and denominator Now for each prime integer x we know the extent of x in the factorization of the numerator a x and the denominator b x For each prime number x we can calculate the extent of x in the factorization of the numerator and the denominator after reduction newa x a x min a x b x newb x b x min a x b x We have the numerator and the denominator of the answer in factorized form Now we have to bring them into the form which is required in the condition One of the ways to do it is to note that the fraction from the statement satisfies the conditions We can factorize it again and in the answer we will have the same fraction for which there will not be such a prime x so that the degree of x in answer would be greater than newa x or newb x This operation can be called reduction The result will satisfy the condition and the fraction will be equal to the required number If you try to build answer greedily put factors in the answer till their product 10 7 the count of numbers in the answer n out or m out will be bigger than 10 5 Factorization by O sqrt max received TL You should have found a faster way For example you could have used linear sieve of Eratosthenes Complexity O max n log max log max is size of factorization 
https://codeforces.com//contest/1342/problem/C,604758,C,1342C,1342,C. Yet Another Counting Problem,You are given two integers a and b and q queries The i th query consists of two numbers l i and r i and the answer to it is the number of integers x such that l i le x le r i and x bmod a bmod b ne x bmod b bmod a Calculate the answer for each query Recall that y bmod z is the remainder of the division of y by z For example 5 bmod 3 2 7 bmod 8 7 9 bmod 4 1 9 bmod 9 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\nint f[100000];\nlong long solve(long long p, int n) {\n\treturn f[n - 1] * (p / n) + f[p % n];\n}\nint main() {\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t --) {\n\t\tint a, b, q;\n\t\tscanf(""%d %d %d"", &a, &b, &q);\n\t\tint n = a * b;\n\t\tfor (int i = 1; i < n; i ++) {\n\t\t\tf[i] = f[i - 1];\n\t\t\tif(i % a % b != i % b % a)\n\t\t\t                f[i] ++;\n\t\t}\n\t\twhile(q --) {\n\t\t\tlong long l, r;\n\t\t\tscanf(""%I64d %I64d"", &l, &r);\n\t\t\tprintf(""%I64d "", solve(r, n) - solve(l - 1, n));\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}']",,,"['math', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Yet Another Counting Problem.json,https://codeforces.com//blog/entry/76633,It s quite easy to see that What does it mean The property given in the statement holds for if and only if it holds for It allows us to answer each testcase in as follows for each number from to we may check the given property before processing the queries and build an array of prefix sums on it to efficiently count the number of integers satisfying the property from the segment where Then each query can be divided into two prefix queries and To answer a prefix query in we can calculate the number of full segments of length inside this prefix that is and the length of the last segment of numbers that don t belong into a full segment that is To handle full segments we multiply the number of integers satisfying the property on one segment by the number of such segments and to handle the last part of segment we use prefix sums 
https://codeforces.com//contest/999/problem/E,192344,E,999E,999,E. Reachability from the Capital,There are n cities and m roads in Berland Each road connects a pair of cities The roads in Berland are one way What is the minimum number of new roads that need to be built to make all the cities reachable from the capital New roads will also be one way ,"['#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl \'\\n\'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, m, s;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint cnt[MAXN], comp[MAXN];\nbool used[MAXN];\n\nbool read() {\n    if (!(cin >> n >> m >> s))\n        return false;\n\n    forn (i, m) {\n        int u, v;\n        cin >> u >> v;\n        g1[u - 1].push_back(v - 1);\n        g2[v - 1].push_back(u - 1);\n    }\n\n    return true;\n}\n\nvector<int> order, vv;\n\nvoid dfs1(int v) {\n    used[v] = true;\n\n    for (auto to : g1[v])\n        if (!used[to])\n            dfs1(to);\n\n    order.push_back(v);\n}\n\nvoid dfs2(int v) {\n    vv.push_back(v);\n    used[v] = true;\n\n    for (auto to : g2[v])\n        if (!used[to])\n            dfs2(to);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n\n    for (auto to : g3[v])\n        if (!used[to])\n            dfs(to);\n}\n\nvoid solve() {\n    --s;\n\n    forn (i, n)\n        if (!used[i])\n            dfs1(i);\n\n    fill(used, used + n, false);\n    reverse(order.begin(), order.end());\n    int cur = 0;\n\n    for (auto v : order)\n        if (!used[v]) {\n            vv.clear();\n            dfs2(v);\n\n            for (auto i : vv)\n                comp[i] = cur;\n\n            ++cur;\n        }\n\n    s = comp[s];\n\n    for (int i = 0; i < n; ++i)\n        for (auto to : g1[i])\n            if (comp[i] != comp[to]) {\n                g3[comp[i]].push_back(comp[to]);\n                ++cnt[comp[to]];\n            }\n\n    fill(used, used + cur, false);\n    dfs(s);\n    int ans = 0;\n\n    forn (i, cur)\n        if (cnt[i] == 0 && !used[i])\n            dfs(i), ++ans;\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand(\'S\' + \'E\' + \'R\' + \'E\' + \'Z\' + \'H\' + \'K\' + \'A\');\n\n#ifdef SEREZHKA\n    freopen(""file.in"", ""r"", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n']",,,"['dfs and similar', 'graphs', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Reachability from the Capital.json,https://codeforces.com/blog/entry/60138,This problem is almost equivalent to the following count the number of sources the vertices with indegree equal to in the given graph s condensation Thus there exist solutions with complexity However the constraints in the problem are small so solutions with complexity also pass One of these solutions is the following first let s mark all the vertices reachable from as using a simple DFS Then for each bad vertex count the number of vertices reachable from it also can be done by simple DFS Let this number be Now iterate over all bad vertices in non increasing order of For the current bad vertex if it is still not marked as run a DFS from it marking all the reachable vertices as and increase the answer by in fact we are implicitly adding the edge It can be proved that this solution gives an optimal answer 
https://codeforces.com//contest/1693/problem/E,1430892,E,1693E,1693,E. Outermost Maximums,Yeri has an array of n 2 non negative integers a 0 a 1 a n a n 1 We know that a 0 a n 1 0 She wants to make all the elements of a equal to zero in the minimum number of operations In one operation she can do one of the following Choose the leftmost maximum element and change it to the maximum of the elements on its left Choose the rightmost maximum element and change it to the maximum of the elements on its right Help her find the minimum number of operations needed to make all elements of a equal to zero ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int n1=(1<<18);\n\nint n;\nint tab[nax];\n\nstruct info\n{\n\tvector<pii> wyj;//first to stan, second to dodanie\n};\n\ninfo operator +(const info &a, const info &b)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tint x=a.wyj[i].first;\n\t\tret.wyj[i]={b.wyj[x].first, b.wyj[x].second+a.wyj[i].second};\n\t}\n\treturn ret;\n}\n\ninfo drz[nax];\n\n//0 to JEDYNKI\nint polew[nax];\nint popra[nax];\n\nll wyn;\n\ninfo daj(int l, int p)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tif (l && p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={0, 1};\n\t\treturn ret;\n\t}\n\tif (!l && !p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={i, 0};\n\t\treturn ret;\n\t}\n\tif (l)\n\t{\n\t\tret.wyj[0]={1, 0};\n\t\tret.wyj[1]={1, 0};\n\t\tret.wyj[2]={0, 1};\n\t\treturn ret;\n\t}\n\tif (p)\n\t{\n\t\tret.wyj[0]={2, 0};\n\t\tret.wyj[1]={0, 1};\n\t\tret.wyj[2]={2, 0};\n\t\treturn ret;\n\t}\n\tassert(0);\n}\n\nvoid upd(int v)\n{\n\tif (!v)\n\t\treturn;\n\tdrz[n1-1+v]=daj(polew[v], popra[v]);\n\tv+=n1-1;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=(drz[2*v+1]+drz[2*v]);\n\t\tv>>=1;\n\t}\n}\n\ninfo glo;\n\nvoid czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tglo=(glo+drz[v]);\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab);\n\tczyt((v<<1), a, (a+b)>>1, graa, grab);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tpopra[tab[i]]++;\n\tfor (int i=1; i<2*n1; i++)\n\t\tdrz[i]=daj(0, 0);\n\tfor (int i=1; i<=n; i++)\n\t\tdrz[n1-1+i]=daj(0, popra[i]);\n\tfor (int i=n1-1; i; i--)\n\t\tdrz[i]=(drz[2*i+1]+drz[2*i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpopra[tab[i]]--;\n\t\tupd(tab[i]);\n\t\tif (tab[i])\n\t\t{\n\t\t\tglo=daj(0, 0);\n\t\t\tczyt(1, 1, n1, 1, tab[i]-1);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)/2].wyj);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)].wyj);\n\t\t\t//~ debug() << imie(drz[(2+n1-1)].wyj);\n\t\t\t//~ debug() << i << "" "" << glo.wyj;\n\t\t\twyn+=glo.wyj[0].second+1;\n\t\t}\n\t\tpolew[tab[i]]++;\n\t\tupd(tab[i]);\n\t}\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['data structures', 'greedy']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Outermost Maximums.json,https://codeforces.com//blog/entry/103952,Let s calculate for each element of the array the minimum number of times it needs to change throughout the process Let s take a look at the first time the th element is changing We know that is the maximum number and the elements smaller than haven t changed yet Denote the maximum element on its left as and the maximum element on its right as So is equal to the largest number among that is smaller than Likewise for We can change to either or It s better to change it to the smaller one We ll get into the details of why this is correct later Let be the minimum number of times the th element needs to change The following greedy algorithm works in operations Let be the number the leftmost maximum becomes if we do the first operation and be the number the rightmost maximum becomes if we do the second operation Do the first operation if and do the second operation otherwise If then for the leftmost maximum the maximum element on its left is smaller than the maximum element on its right That means we are making the right choice for this element Let s assume the array is a permutation of numbers from through for simplicity For some element make string of length such that O for any L for any R Imagine Yeri is initially standing on the th character of S which is O and she is facing the beginning of the string In each step she either jumps to the nearest L or jumps to the nearest R And her goal is to jump out of the string in minimum number of jumps We know it s always better to jump to the further one but we won t need this fact We will use a segment tree For each node maintain 4 values What is the minimum possible number of jumps made in this interval in case we enter it looking for an L and leave it looking for an L we enter it looking for an L and leave it looking for an R we enter it looking for an R and leave it looking for an L we enter it looking for an R and leave it looking for an R It s easy to update this Just fix which character you are looking for when moving from the node s one child to the other And you can find these values for intervals of length Now if you iterate over from to At each step at most 2 characters of the string are changing hence you can keep your segment tree updated But there are still some details we need to sort out The array is not necessarily a permutation To fix this first get rid of the O Then for each number see if it appears on the left side and see if it appears on the right side Now there are 4 different states for each number but the same segment tree can handle this too We just need to find the 4 values for each of the 4 states of a single number Time complexity 
https://codeforces.com//contest/1459/problem/A,837948,A,1459A,1459,A. Red-Blue Shuffle,There are n cards numbered 1 ldots n The card i has a red digit r i and a blue digit b i written on it We arrange all n cards in random order from left to right with all permutations of 1 ldots n having the same probability We then read all red digits on the cards from left to right and obtain an integer R In the same way we read all blue digits and obtain an integer B When reading a number leading zeros can be ignored If all digits in a number are zeros then the number is equal to 0 Below is an illustration of a possible rearrangement of three cards and how R and B can be found Two players Red and Blue are involved in a bet Red bets that after the shuffle R B and Blue bets that R B If in the end R B the bet results in a draw and neither player wins Determine which of the two players is more likely has higher probability to win the bet or that their chances are equal Refer to the Note section for a formal discussion of comparing probabilities ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define N 1000002\ntypedef long long ll;\nint n,T;\nchar a[N],b[N];\nint main()\n{\n\tscanf(""%d"",&T);\n\twhile(T--)\n\t{\n\t\tscanf(""%d"",&n);\n\t\tscanf(""%s%s"",a+1,b+1);\n\t\tint c1=0,c2=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-\'0\'<b[i]-\'0\')c1++;\n\t\t\telse if(a[i]-\'0\'>b[i]-\'0\')c2++;\n\t\t}\n\t\tif(c1==c2)puts(""EQUAL"");\n\t\telse if(c1<c2)puts(""RED"");\n\t\telse puts(""BLUE"");\n\t}\n}\n\n']",,,"['math', 'probabilities']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Red-Blue Shuffle.json,https://codeforces.com//blog/entry/85750,First we can observe that if a card has then if doesn t affect the comparison between and regardless of its position We can forget about all such cards Formally if we erase all such cards after the permutation then and are still compared in the same way and further all the remaining cards are still permuted equiprobably Now we only have cards with let s call them Red favourable and call them Blue favourable But then the comparison between and will only be decided by whether the first card is Red or Blue favourable Naturally if say there are more Red favourable cards than Blue favourable cards then Red is more likely to win If there is an equal number of Red and Blue favourable cards then the chances are equal Thus for the solution purposes we only need to count indices with and those with and compare these two numbers 
https://codeforces.com//contest/1300/problem/B,536069,B,1300B,1300,B. Assigning to Classes,of the array a 1 a 2 dots a 2k 1 of odd number of elements is defined as follows let b 1 b 2 dots b 2k 1 be the elements of the array in the sorted order Then median of this array is equal to b k 1 There are 2n students the i th student has skill level a i It s that all skill levels are distinct Let s define as the median of skill levels of students of the class As a principal of the school you would like to assign each student to one of the 2 classes such that each class has not divisible by 2 The number of students in the classes may be equal or different by your choice Every student has to be assigned to exactly one class Among such partitions you want to choose one in which the absolute difference between skill levels of the classes is minimized What is the minimum possible absolute difference you can achieve ,"['#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < \'0\' || ch > \'9\') && ch != \'-\') ch = getchar();\n\tif(ch == \'-\'){f = true; ch = getchar();}\n\twhile(ch >= \'0\' && ch <= \'9\'){x = x * 10 + ch - \'0\'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nconst int N = 200003;\nint n, a[N], t, ans;\nint main(){\n\tread(t);\n\twhile(t --){\n\t\tread(n);\n\t\tfor(Rint i = 1;i <= 2 * n;++ i) read(a[i]);\n\t\tsort(a + 1, a + 2 * n + 1);\n\t\tprintf(""%d\\n"", a[n + 1] - a[n]);\n\t}\n}']",,,"['greedy', 'implementation', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Assigning to Classes.json,https://codeforces.com//blog/entry/73763,Let s sort the array From now on Consider any partition Suppose that the first class has students and the skill level of this class is and the second class had students and the skill level of this class is where Without losing generality At least students have skill level at least Indeed as is a median of his class he and other students have skill level at least As and at least other students of the second class have skill level at least we get at least students including with skill level at least Therefore Similarly we get that at least students have skill level at most Therefore So However is achievable Let s put student into the class alone and all other students into other class will be the median skill level of that class so the absolute difference will be exactly Therefore it s enough to sort the array and to output the difference between two middle elements 
https://codeforces.com//contest/1016/problem/B,204437,B,1016B,1016,B. Segment Occurrences,You are given two strings s and t both consisting only of lowercase Latin letters The substring s l r is the string which is obtained by taking characters s l s l 1 dots s r without changing the order Each of the occurrences of string a in a string b is a position i 1 le i le b a 1 such that b i i a 1 a a is the length of string a You are asked q queries for the i th query you are required to calculate the number of occurrences of string t in a substring s l i r i ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=1021;\nint n, m, q, ans[N];\nstring s, t;\nint main(){\n  scanf(""%d%d%d"", &n, &m, &q);\n  cin>>s>>t;\n  for(int i=0; i+m<=n; i++)\n    if(s.substr(i, m) == t)\n      ans[i+1]++;\n  for(int i=2; i<=n; i++)\n    ans[i]+=ans[i-1];\n  while(q--){\n    int li, ri;\n    scanf(""%d%d"", &li, &ri);\n    ri=ri-m+1;\n    printf(""%d\\n"", max(0, ans[max(0,ri)]-ans[li-1]));\n  }\n}\n']",,,"['brute force', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Segment Occurrences.json,https://codeforces.com/blog/entry/61015,Let s take a look at a naive approach for each query you iterate over positions and check if Okay this is obviously Now we notice that there are only positions for to start from we can calculate if there is an occurrence of starting in this position beforehand in Thus we transition to solution Finally we calculate a partial sum array over this occurrence check array and answer each query in Overall complexity 
https://codeforces.com//contest/547/problem/A,28329,A,547A,547,A. Mike and Frog,Mike has a frog and a flower His frog is named Xaniar and his flower is named Abol Initially at time height of Xaniar is and height of Abol is Each second Mike waters Abol and Xaniar So if height of Xaniar is and height of Abol is after one second height of Xaniar will become and height of Abol will become where and are some integer numbers and denotes the remainder of modulo Mike is a competitive programmer fan He wants to know the minimum time it takes until height of Xania is and height of Abol is Mike has asked you for your help Calculate the minimum time or say it will never happen ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n// template end here\nint m;\nvoid get(LL h,LL a,LL x,LL y,LL &v1,LL &v2){\n    v1=-1;\n    v2=-1;\n    int tt=0;\n    REP(i,m*5){\n        h=(x*h+y)%m;\n        if(h==a){\n            if(!tt){\n                v1=i+1;\n            }\n            else if(tt==1){\n                v2=i+1;\n            }\n            else break;\n            tt++;\n        }\n    }\n}\nint ha[SIZE];\nint main(){\n    RI(m);\n    DRII(h1,a1);\n    DRII(x1,y1);\n    DRII(h2,a2);\n    DRII(x2,y2);\n    LL v1,v2,u1,u2;\n    get(h1,a1,x1,y1,v1,v2);\n    get(h2,a2,x2,y2,u1,u2);\n    if(v1==-1||u1==-1){\n        puts(""-1"");\n    }\n    else{\n        if(u2==-1){\n            swap(v1,u1);\n            swap(v2,u2);\n        }\n        if(v2==-1){\n            if(u2==-1){\n                if(v1==u1)cout<<v1<<endl;\n                else cout<<-1<<endl;\n            }\n            else{\n                LL now=u1;\n                REP(k,m*5){\n                    if(now==v1){\n                        cout<<now<<endl;\n                        return 0;\n                    }\n                    now+=u2-u1;\n                }\n                cout<<-1<<endl;\n                return 0;\n            }\n        }\n        else{\n            LL now=u1;\n            REP(k,m*5){\n                if(now>=v1&&(now-v1)%(v2-v1)==0){\n                    cout<<now<<endl;\n                    return 0;\n                }\n                now+=u2-u1;\n            }\n            cout<<-1<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n']",,,"['brute force', 'greedy', 'implementation', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Mike and Frog.json,https://codeforces.com/blog/entry/18126,In this editorial consider and and First of all find the number of seconds it takes until height of Xaniar becomes starting from and call it Please note that and if we don t reach after seconds then answer is If after seconds also height of Abol will become equal to then answer if Otherwise find the height of Abdol after seconds and call it Then find the number of seconds it takes until height of Xaniar becomes starting from and call it Please note that and if we don t reach after seconds then answer is if then find times It is really easy Then Actually if height of Abol is then after seconds it will be Then starting from find the minimum number of steps of performing e f e it takes to reach and call it Please note that and if we don t reach after seconds then answer is Then answer is Time Complexity C Code by PrinceOfPersia C Code by Haghani Java Code by Zlobober 
https://codeforces.com//contest/977/problem/D,181255,D,977D,977,"D. Divide by three, multiply by two",Polycarp likes to play with numbers He takes some integer number x writes it down on the board and then performs with it n 1 operations of the two kinds divide the number x by 3 x must be divisible by 3 multiply the number x by 2 After each operation Polycarp writes down the result on the board and replaces x by the result So there will be n numbers on the board after all You are given a sequence of length n the numbers that Polycarp wrote down This sequence is given in arbitrary order i e the order of the sequence can mismatch the order of the numbers written on the board Your problem is to rearrange reorder elements of this sequence in such a way that it can match possible Polycarp s game in the order of the numbers written on the board I e each next number will be exactly two times of the previous number or exactly one third of previous number It is guaranteed that the answer exists ,"['/*input\n2\n1000000000000000000 3000000000000000000\n\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define db(a) cerr<<#a<<"" = ""<<a<<\'\\n\'\nusing namespace std;\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<ll> a(n);\n\t\n\t\n\n\tvector<pair<pair<int, int>, ll> > p(n);\n\tfor(int i=0; i<n; i++){\n\t\tll t;\n\t\tcin >> t;\n\t\tp[i].second = t;\n\n\t\twhile(t % 2 == 0){\n\t\t\tp[i].first.first++;\n\t\t\tt /= 2;\n\t\t}\n\n\t\tt = p[i].second;\n\t\twhile(t % 3 == 0){\n\t\t\tp[i].first.second++;\n\t\t\tt /= 3;\n\t\t}\n\t}\n\n\tsort(p.begin(), p.end(), [](pair<pair<int, int>, ll> a, pair<pair<int, int>, ll> b){\n\t\tpair<int, int> aa = {-a.first.second, a.first.first};\n\t\tpair<int, int> bb = {-b.first.second, b.first.first};\n\t\treturn aa < bb;\n\t});\n\n\tfor(int i=0; i<n; i++){\n\t\tcout << p[i].second << "" "";\n\t}\n\n}\n\t']",,,"['dfs and similar', 'math', 'sortings']",1400,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Divide by three, multiply by two.json",https://codeforces.com//blog/entry/59281,Let be the maximum integer such that is divisible by Our problem is to rearrange the given array in such a way that easy to see it if we look at our operations if it looks like then for each the next inequality will be satisfied And if then numbers must be placed in increasing order because of our operations So we can store an array of pairs when Then if we sort it in lexicographical order we can just print the second elements of the sorted array 
https://codeforces.com//contest/1322/problem/F,555658,F,1322F,1322,F. Assigning Fares,Mayor of city M decided to launch several new metro lines during 2020 Since the city has a very limited budget it was decided not to dig new tunnels but to use the existing underground network The tunnel system of the city M consists of n metro stations The stations are connected with n 1 bidirectional tunnels Between every two stations v and u there is exactly one simple path Each metro line the mayor wants to create is a simple path between stations a i and b i Metro lines can intersects freely that is they can share common stations or even common tunnels However it s not yet decided which of two directions each line will go More precisely between the stations a i and b i the trains will go either from a i to b i or from b i to a i but not simultaneously The city M uses complicated faring rules Each station is assigned with a positive integer c i the fare zone of the station The cost of travel from v to u is defined as c u c v roubles Of course such travel only allowed in case there is a metro line the trains on which go from v to u Mayor doesn t want to have any travels with a negative cost so it was decided to assign directions of metro lines and station fare zones in such a way that fare zones are strictly increasing during any travel on any metro line Mayor wants firstly assign each station a fare zone and then choose a lines direction such that all fare zones are increasing along any line In connection with the approaching celebration of the day of the city the mayor wants to assign fare zones so that the maximum c i will be as low as possible Please help mayor to design a new assignment or determine if it s impossible to do Please note that you only need to assign the fare zones optimally you don t need to print lines directions This way you solution will be considered correct if there will be a way to assign directions of every metro line so that the fare zones will be strictly increasing along any movement of the trains ,"['#include <bits/stdc++.h>\n#define FR first\n#define SE second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\ninline pr merge(pr x,pr y) {\n  return pr(max(x.FR,y.FR),min(x.SE,y.SE));\n}\n\nvector <int> e[500005];\nint fa[500005][20],dep[500005];\n\nvoid dfs1(int x) {\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa[x][0]) {\n    \tint u=e[x][i];\n    \tfa[u][0]=x;dep[u]=dep[x]+1;\n    \tfor(int j=1;j<20;j++) fa[u][j]=fa[fa[u][j-1]][j-1];\n    \tdfs1(u);\n\t}\n}\n\nint lca(int x,int y) {\n  if (dep[x]<dep[y]) swap(x,y);\n  int d=dep[x]-dep[y];\n  for(int i=0;i<20;i++)\n    if ((d>>i)&1) x=fa[x][i];\n  if (x==y) return x;\n  for(int i=19;i>=0;i--)\n    if (fa[x][i]!=fa[y][i]) {\n    \tx=fa[x][i];\n    \ty=fa[y][i];\n\t}\n  return fa[x][0];\n}\n\nint jump(int x,int d) {\n  for(int i=0;i<20;i++)\n    if ((d>>i)&1) x=fa[x][i];\n  return x;\n}\n\nvector <pr> ee[500005];\nint size[500005];\n\nvoid dfs2(int x,int fa) {\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) {\n    \tint u=e[x][i];\n    \tdfs2(u,x);\n    \tsize[x]+=size[u];\n\t}\n  if (size[x]) {\n  \tee[x].push_back(pr(fa,0));\n  \tee[fa].push_back(pr(x,0));\n  }\n}\n\nint col[500005],id[500005];\n\nvoid dfs3(int x) {\n  for(int i=0;i<ee[x].size();i++) {\n  \tint u=ee[x][i].FR;\n  \tif (!id[u]) {\n  \t\tid[u]=id[x];\n  \t\tcol[u]=col[x]^ee[x][i].SE;\n  \t\tdfs3(u);\n\t  }\n\telse if ((col[x]^col[u])!=ee[x][i].SE) {\n\t\tputs(""-1"");\n\t\texit(0);\n\t}\n  }\n}\n\npr f[500005],g[500005];\nint vis[500005];\n\nbool dfs4(int x,int fa,int k) {\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) {\n    \tint u=e[x][i];\n    \tif (!dfs4(u,x,k)) return 0;\n\t}\n  f[x]=pr(1,k);\n  int sz=0;\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa&&id[e[x][i]]) {\n    \tint u=e[x][i];\n    \tif (id[u]==id[x]) {\n    \t\tif (!col[u]) f[x]=merge(f[x],pr(1,f[u].SE-1));\n    \t\telse f[x]=merge(f[x],pr(f[u].FR+1,k));\n\t\t}\n\t\telse {\n\t\t\tif (!vis[id[u]]) {\n\t\t\t\tvis[id[u]]=++sz;\n\t\t\t\tg[sz]=pr(1,k);\n\t\t\t}\n\t\t\tint t=vis[id[u]];\n\t\t\tif (!col[u]) g[t]=merge(g[t],pr(1,f[u].SE-1));\n\t\t\telse g[t]=merge(g[t],pr(f[u].FR+1,k));\n\t\t}\n\t}\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) vis[id[e[x][i]]]=0;\n  if (f[x].FR>f[x].SE) return 0;\n  pr u(1,k);\n  for(int i=1;i<=sz;i++) {\n  \tif (g[i].FR>g[i].SE) return 0;\n  \tif (k-g[i].SE+1<g[i].FR) g[i]=pr(k-g[i].SE+1,k-g[i].FR+1);\n  \tu=merge(u,g[i]);\n  }\n  pr t1=merge(u,f[x]),t2=merge(pr(k-u.SE+1,k-u.FR+1),f[x]);\n  if (t1.FR>t1.SE&&t2.FR>t2.SE) return 0;\n  if (t1.FR>t1.SE) f[x]=t2;\n  else if (t2.FR>t2.SE) f[x]=t1;\n  else f[x]=pr(min(t1.FR,t2.FR),max(t1.SE,t2.SE));\n  return 1;\n}\n\nint ans[500005],val[500005];\nbool d[500005];\n\nvoid dfs5(int x,int fa,int k,bool v) {\n  int sz=0;\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa&&id[e[x][i]]!=id[x]) {\n    \tint u=e[x][i];\n\t\tif (!vis[id[u]]) {\n\t\t\tvis[id[u]]=++sz;\n\t\t\tval[sz]=id[u];\n\t\t\tg[sz]=pr(1,k);\n\t\t}\n\t\tint t=vis[id[u]];\n\t\tif (!col[u]) g[t]=merge(g[t],pr(1,f[u].SE-1));\n\t\telse g[t]=merge(g[t],pr(f[u].FR+1,k));\n\t}\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) vis[id[e[x][i]]]=0;\n  for(int i=1;i<=sz;i++) d[val[i]]=((g[i].FR<=ans[x]&&g[i].SE>=ans[x])?0:1);\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) {\n    \tint u=e[x][i];\n    \tif (!id[u]) {\n    \t\tans[u]=f[u].FR;\n    \t\tdfs5(u,x,k,0);\n\t\t}\n\t\telse {\n\t\t\tbool c=((id[u]==id[x])?v:d[id[u]]);\n\t\t\tif (!c) ans[u]=((!col[u])?f[u].SE:f[u].FR);\n\t\t\telse ans[u]=((col[u])?k-f[u].FR+1:k-f[u].SE+1);\n\t\t\tdfs5(u,x,k,c);\n\t\t}\n\t}\n} \n\nint main() {\n  int n,m;\n  scanf(""%d%d"",&n,&m);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(""%d%d"",&x,&y);\n  \te[x].push_back(y);\n  \te[y].push_back(x);\n  }\n  dfs1(1);\n  for(int i=1;i<=m;i++) {\n  \tint x,y;\n  \tscanf(""%d%d"",&x,&y);\n  \tint p=lca(x,y),u,v;\n  \tif (p!=x) {\n  \t\tsize[x]++;\n  \t\tsize[u=jump(x,dep[x]-dep[p]-1)]--;\n\t  }\n\tif (p!=y) {\n\t\tsize[y]++;\n\t\tsize[v=jump(y,dep[y]-dep[p]-1)]--;\n\t}\n\tif (p!=x&&p!=y) {\n\t\tee[u].push_back(pr(v,1));\n\t\tee[v].push_back(pr(u,1));\n\t}\n  }\n  dfs2(1,0);\n  int cnt=0;\n  for(int i=2;i<=n;i++)\n    if (!id[i]) {\n    \tid[i]=++cnt;\n    \tdfs3(i);\n\t}\n  int l=1,r=n;\n  while (l<r) {\n  \tint mid=((l+r)>>1);\n    bool v=dfs4(1,0,mid);\n    if (v) r=mid; else l=mid+1;\n  }\n  dfs4(1,0,l);\n  ans[1]=f[1].FR;\n  dfs5(1,0,l,0);\n  printf(""%d\\n"",l);\n  for(int i=1;i<=n;i++) printf(""%d "",ans[i]);\n  printf(""\\n"");\n  return 0;\n} \n/*\n3 1 \n1 2\n1 3\n2 3 \n*/ ']",,,"['dp', 'trees']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Assigning Fares.json,https://codeforces.com//blog/entry/74148,Let s assume is the color of vertex v So we need to find a coloring of tree where strictly increases along every path First of all if coloring exists we can renumerate colors so that they will be in range 1 Secondly we can always revert our coloring make Also let s do binary search to find So now we want to check if it is possible to paint tree using colors Every path can be on of two directions If we determine direction for path 0 then we also automatically determine direction for every path which has common edge with path 0 So we can get a components of paths if we choose one path direction we choose every other paths direction We can notice that if a single component is not bipartite answer is 1 So for every path we know it s component and it s orientation inside the component It can be calculated using subtree sum for vertexes and we make 1 for 1 for and 2 for Let s make our tree rooted and then count dp on subtrees minimal color of if all it s subtree is colored in a correct way and edge goes from lower to higher color How to calculate dp If we fix edge direction for some edges we know the orientation It happens when they were in same component as For other components we can or use or depending on which direction of component we use If we will try both variants and combine all the constraints we will get two different segments and and must be in one of them It can be solved with scanline in time Now we can notice that Let s think of segments as about two left constraints and We have two sets and We either put or So we want these conditions to be done If we fix what is more or we get fixed distribuition between and max of and goes to max of two sets Then we just need to check conditions and use best of variants Solution will have complexity 
https://codeforces.com//contest/536/problem/D,26045,D,536D,536,D. Tavas in Kansas,Tavas lives in Kansas Kansas has cities numbered from 1 to connected with bidirectional roads We can travel from any city to any other city via these roads Kansas is as strange as Tavas So there may be a road between a city and itself or more than one road between two cities Tavas invented a game and called it Dashti He wants to play Dashti with his girlfriends Nafas In this game they assign an arbitrary integer value to each city of Kansas The value of th city equals to During the game Tavas is in city and Nafas is in city They play in turn and Tavas goes first A player in his her turn must choose a non negative integer and his her score increases by the sum of values of all cities with shortest distance no more than from his her city Each city may be used once or in the other words after first time a player gets score from a city city score becomes zero There is an additional rule the player must choose such that he she gets the point of at least one city that was not used before Note that city may initially have value 0 such city isn t considered as been used at the beginning of the game i e each player may use it to fullfill this rule The game ends when nobody can make a move A player s score is the sum of the points he she earned during the game The winner is the player with greater score or there is a draw if players score the same value Both players start game with zero points If Tavas wins he ll break his girlfriend s heart and if Nafas wins Tavas will cry But if their scores are equal they ll be happy and Tavas will give Nafas flowers They re not too emotional after all so they ll play optimally Your task is to tell Tavas what s going to happen after the game ends ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N,S,T;\nll graph[2010][2010];\nll p[2010];\nll dist[2010];\nbool used[2010];\nll dists[2010],distt[2010];\n\nvector <pair <ll, int> > vs,vt; // dist, id\nint ranks[2010],rankt[2010];\nll dps[2010][2010],dpt[2010][2010];\nbool new_s[2010][2010],new_t[2010][2010];\n\nll calc_s(int x, int y){\n    if(x == N) return 0;\n    if(!new_s[x][y]) return dps[x+1][y];\n    \n    ll next_cost = p[vs[x].second];\n    ll ans = next_cost + dps[x+1][y];\n    \n    for(int i=x+1;i<=N;i++){\n        ans = max(ans, next_cost - dpt[i][y]);\n        if(new_s[i][y]) break;\n    }\n    \n    return ans;\n}\n\nll calc_t(int x, int y){\n    if(y == N) return 0;\n    if(!new_t[x][y]) return dpt[x][y+1];\n    \n    ll next_cost = p[vt[y].second];\n    ll ans = next_cost + dpt[x][y+1];\n    \n    for(int i=y+1;i<=N;i++){\n        ans = max(ans, next_cost - dps[x][i]);\n        if(new_t[x][i]) break;\n    }\n    \n    return ans;\n}\n\nvoid main2(void){\n    int i,j;\n    \n    REP(i,N) REP(j,N+1) new_s[i][j] = (rankt[vs[i].second] >= j);\n    REP(i,N+1) REP(j,N) new_t[i][j] = (ranks[vt[j].second] >= i);\n    \n    for(i=N;i>=0;i--) for(j=N;j>=0;j--){\n        dps[i][j] = calc_s(i, j);\n        dpt[i][j] = calc_t(i, j);\n    }\n    \n    ll ans = dps[0][0];\n    if(ans > 0) cout << ""Break a heart"" << endl;\n    if(ans < 0) cout << ""Cry"" << endl;\n    if(ans == 0) cout << ""Flowers"" << endl;\n}\n\nvoid get_dist(int s){\n    int i,j;\n    \n    REP(i,N) dist[i] = INF;\n    REP(i,N) used[i] = false;\n    dist[s] = 0;\n    \n    REP(i,N){\n        int x = -1;\n        REP(j,N) if(!used[j] && (x == -1 || dist[j] < dist[x])) x = j;\n        used[x] = true;\n        REP(j,N) dist[j] = min(dist[j], dist[x] + graph[x][j]);\n    }\n}\n\nint main(void){\n    int M,i,j;\n    \n    cin >> N >> M >> S >> T;\n    S--; T--;\n    REP(i,N){\n        int tmp;\n        scanf(""%d"", &tmp);\n        p[i] = tmp;\n    }\n    REP(i,N) REP(j,N) if(i != j) graph[i][j] = INF;\n    REP(i,M){\n        int u,v,w;\n        scanf(""%d%d%d"", &u, &v, &w);\n        u--; v--;\n        graph[u][v] = min(graph[u][v], (ll)w);\n        graph[v][u] = min(graph[v][u], (ll)w);\n    }\n    \n    get_dist(S);\n    REP(i,N) dists[i] = dist[i];\n    get_dist(T);\n    REP(i,N) distt[i] = dist[i];\n    \n    REP(i,N) vs.push_back(make_pair(dists[i], i));\n    sort(vs.begin(),vs.end());\n    REP(i,N) vt.push_back(make_pair(distt[i], i));\n    sort(vt.begin(),vt.end());\n    \n    REP(i,N) ranks[vs[i].second] = i;\n    REP(i,N) rankt[vt[i].second] = i;\n    \n    main2();\n    \n    return 0;\n}\n']",,,"['dp', 'games']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Tavas in Kansas.json,https://codeforces.com//blog/entry/17401,For each vertex put a point with its point score in the Cartesian plane The first player in his her turn chooses a vertical line and erases all the points on its left side Second player in his her turn chooses a horizontal line and erases all the point below it Each player tries to maximize his her score Obviously each time a player chooses a line on the right upper side of his her last choice Imagine that there are different components and different components among all these lines So we can show each state before the game ends with a pair It means that in this state a point is not erased yet if and only if and So using dp is the maximum score of player in state and it s player s turn So consider is the sum of the scores of all valid points in state and is the amount of them So If then Otherwise So we need two backward fors for our dp and another for on So now the only thing that matters is updating the dp For this purpose we need two more arrays and the minimum value of pairs and minimum value of pairs such that in the states we ve seen so far Similarly the minimum value of pairs and minimum value of pairs such that in the states we ve seen so far Now updating dp is pretty easy And updating and is super easy Now let and be the sum of scores of all points So the score of first player is and the second one is Time complexity Code by sobhan miryoosefi Another Code by Haghani Java Code by Zlobober 
https://codeforces.com//contest/1735/problem/C,1564417,C,1735C,1735,C. Phase Shift,There was a string s which was supposed to be encrypted For this reason all 26 lowercase English letters were arranged in a circle in some order afterwards each letter in s was replaced with the one that follows in clockwise order in that way the string t was obtained You are given a string t Determine the lexicographically smallest string s that could be a prototype of the given string t A string a is lexicographically smaller than a string b of the same length if and only if in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['// LUOGU_RID: 91547491\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\') {\n\t\tif(ch==\'-\') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\') {\n\t\tx=(x<<3)+(x<<1)+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar(\'-\'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+\'0\');\n}\n#define writesp(x) write(x),putchar(\' \')\n#define writeln(x) write(x),putchar(\'\\n\')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=100100;\n\nint n;\nchar s[N];\nint a[N];\n\nint nxt[N];\nbool vis[N];\nint C;\n\nint fa[N];\nint find(int x) {\n\tif(fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nvoid merge(int x,int y) {\n\tx=find(x),y=find(y);\n\tif(x==y) return;\n\tfa[y]=x;\n}\n\nvoid solve() {\n\tn=read(); scanf(""%s"",s+1);\n\trep(i,1,n) a[i]=s[i]-\'a\';\n\trep(i,0,25) nxt[i]=-1,vis[i]=0;\n\trep(i,0,25) fa[i]=i; C=0;\n\trep(i,1,n) {\n\t\tif(nxt[a[i]]==-1) {\n\t\t\tint k=-1;\n\t\t\trep(j,0,25) if(j!=a[i]) {\n\t\t\t\tif(!vis[j]) {\n\t\t\t\t\tif(find(a[i])==find(j)) {\n\t\t\t\t\t\tif(C<25) continue;\n\t\t\t\t\t}\n\t\t\t\t\tk=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnxt[a[i]]=k,vis[k]=1; C++;\n\t\t\tmerge(a[i],k);\n\t\t}\n\t}\n\trep(i,1,n) putchar(nxt[a[i]]+\'a\');\n\tputchar(\'\\n\');\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'strings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Phase Shift.json,https://codeforces.com//blog/entry/107533,SolutionFirst of all the encryption process is reversible If we obtained from using the circle we can obtain from using the same cycle but reversed So let s think in terms of encryption of Lexicographical order itself is a greedy thing So we can create a greedy algorithm Let s go from left to right and generate the result letter by letter We have to choose the best possible option at each step Let s describe the options we have If the current letter was used earlier we already know the replacement we need to choose Otherwise we would like to choose the minimum possible option We need to maintain some structure to know what is acceptable Let s keep the circle that is already generated it s a graph For each letter we have one incoming edge and one outgoing edge in the end Let s keep them for every letter arrays When we want to generate an outgoing edge at some step let s define the letter on this step as we have to choose the minimum letter that doesn t have an incoming edge yet With one exception if creating the edge using this rule creates a circle of size less than It would mean that we wouldn t have a full circle in the end It s easy to see that there is no more than one such letter as this letter is just the end of a chain starting in To check that a small circle wasn t generated we can go along an outgoing edge times starting at If we end up in or there was no edge at some step then everything is ok we can create this edge Complexity is that is 
https://codeforces.com//contest/777/problem/A,95269,A,777A,777,A. Shell Game,Bomboslav likes to look out of the window in his room and watch lads outside playing famous shell game The game is played by two persons operator and player Operator takes three similar opaque shells and places a ball beneath one of them Then he shuffles the shells by swapping some pairs and the player has to guess the current position of the ball Bomboslav noticed that guys are not very inventive so the operator always swaps the left shell with the middle one during odd moves first third fifth etc and always swaps the middle shell with the right one during even moves second fourth etc Let s number shells from to from left to right Thus the left shell is assigned number the middle shell is and the right shell is Bomboslav has missed the moment when the ball was placed beneath the shell but he knows that exactly movements were made by the operator and the ball was under shell at the end Now he wonders what was the initial position of the ball ,"[""#include <bits/stdc++.h>\n#define REP(i, a, b) for (register int i = a; i <= b; ++i)\n#define PER(i, a, b) for (register int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n\ninline LL read() {\n\tLL x = 0; int ch = getchar(), f = 1;\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x * f;\n}\n\nint main(){\n\tLL n = read() % 6;\n\tLL x = read();\n\tif (n == 1 && x == 1) cout << 0;\n\tif (n == 2 && x == 2) cout << 0;\n\tif (n == 3 && x == 2) cout << 0;\n\tif (n == 4 && x == 1) cout << 0;\n\tif (n == 5 && x == 0) cout << 0;\n\tif (n == 0 && x == 0) cout << 0;\n\n\tif (n == 1 && x == 0) cout << 1;\n\tif (n == 2 && x == 0) cout << 1;\n\tif (n == 3 && x == 1) cout << 1;\n\tif (n == 4 && x == 2) cout << 1;\n\tif (n == 5 && x == 2) cout << 1;\n\tif (n == 0 && x == 1) cout << 1;\n\t\n\tif (n == 1 && x == 2) cout << 2;\n\tif (n == 2 && x == 1) cout << 2;\n\tif (n == 3 && x == 0) cout << 2;\n\tif (n == 4 && x == 0) cout << 2;\n\tif (n == 5 && x == 1) cout << 2;\n\tif (n == 0 && x == 2) cout << 2;\n\treturn 0;\n}""]",,,"['constructive algorithms', 'implementation', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Shell Game.json,https://codeforces.com//blog/entry/50670,Fix the initial numeration of shells Consider function to be the index of the shell located at position after moves Thus after movements all shells will get back to initial positions To solve the problem we need to take modulo and simulate that number of moves 
https://codeforces.com//contest/1712/problem/A,1501803,A,1712A,1712,A. Wonderful Permutation,A Random PebbleYou are given a permutation p 1 p 2 ldots p n of length n and a positive integer k le n In one operation you can choose two indices i and j 1 le i j le n and swap p i with p j Find the minimum number of operations needed to make the sum p 1 p 2 ldots p k as small as possible A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define int long long\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n\nint T,n,ans,i,j,k,a[N]; \nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>k;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i];\n\t\t\tif(i<=k&&a[i]>k)++ans;\n\t\t}\n\t\tcout<<ans<<""\\n"";ans=0;\n\t}\n}']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Wonderful Permutation.json,https://codeforces.com//blog/entry/105919,For any permutation of length the final sum after some number of operations can t be less than This means that we need to apply the operation at least once for every such that and Every time we apply it we have to choose some index such that and This is always possible since initially the number of suitable is equal to the number of suitable and one operation decreases both the number of suitable and the number of suitable by one It is easy to see that in the end the set only contains the values which means that the sum is equal to which is the smallest sum we can get So the answer is the the number of such that and Complexity 
https://codeforces.com//contest/477/problem/D,15281,D,477D,477,D. Dreamoon and Binary,Dreamoon saw a large integer written on the ground and wants to print its binary form out Dreamoon has accomplished the part of turning into its binary format Now he is going to print it in the following manner He has an integer and can only perform the following two operations in any order for unlimited times each Print n in binary form without leading zeros each print will append to the right of previous prints Increase n by 1 Let s define an as a sequence of operations that can successfully print binary representation of without leading zeros and ends with a print operation i e operation 1 Dreamoon wants to know how many different ideal sequences are there and the length in operations of the shortest ideal sequence The answers might be large so please print them modulo 1000000007 Let s define the string representation of an ideal sequence as a string of and where the th character in the string matches the th operation performed Two ideal sequences are called different if their string representations are different ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=5010;\nstruct node {\n\tnode *s[2]; int cr;\n} pool[N*N/2],*cur=pool,*rt=pool;\nint dp[N][N],dp2[N][N],rk[N][N],ret;\nint tot,n;\nPII ret2;\nchar s[N];\nvoid dfs(node *p) {\n\tp->cr=tot++;\n\tif (p->s[0]) dfs(p->s[0]);\n\tif (p->s[1]) dfs(p->s[1]);\n}\nvoid upd(PII &a,PII b) {\n\tif (b.se<=a.se) a=b;\n\telse {\n\t\tif (a.fi-b.fi>=30||b.fi>=30) a=b;\n\t\telse {\n\t\t\tll s1=0,s2=0;\n\t\t\trep(j,n-a.fi+1,n+1) s1=s1*2+s[j]-\'0\';\n\t\t\trep(j,n-b.fi+1,n+1) s2=s2*2+s[j]-\'0\';\n\t\t\tif (s1+a.se>s2+b.se) a=b;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(""%s"",s+1);\n\tn=strlen(s+1);\n\trt=cur++;\n\trep(i,1,n+1) {\n\t\tnode *p=rt;\n\t\trep(j,i,n+1) {\n\t\t\tint w=s[j]-\'0\';\n\t\t\tif (!p->s[w]) p->s[w]=cur++;\n\t\t\tp=p->s[w];\n\t\t\trk[i][j]=p-pool;\n\t\t}\n\t}\n\tdfs(rt);\n\trep(i,1,n+1) rep(j,i,n+1) rk[i][j]=pool[rk[i][j]].cr;\n\tmemset(dp2,0x20,sizeof(dp2));\n\tdp[0][0]=1;\n\trep(i,1,n+1) {\n\t\trep(j,1,i) if (s[i-j+1]==\'1\') {\n\t\t\tif (i>=2*j) {\n\t\t\t\tif (rk[i-2*j+1][i-j]<=rk[i-j+1][i]) {\n\t\t\t\t\tdp[i][j]=dp[i-j][j];\n\t\t\t\t\tdp2[i][j]=dp2[i-j][j]+1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j]=dp[i-j][j-1];\n\t\t\t\t\tdp2[i][j]=dp2[i-j][j-1]+1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp[i][j]=dp[i-j][i-j];\n\t\t\t\tdp2[i][j]=dp2[i-j][i-j]+1;\n\t\t\t}\n\t\t}\n\t\tdp[i][i]=1; dp2[i][i]=1;\n\t\tdp2[i][0]=0x20202020;\n\t\trep(j,1,i+1) {\n\t\t\tdp[i][j]=(dp[i][j-1]+dp[i][j])%mod;\n\t\t\tdp2[i][j]=min(dp2[i][j-1],dp2[i][j]);\n\t\t}\n\t}\n\tprintf(""%d\\n"",dp[n][n]);\n\tret2=mp(n,1);\n\trep(i,2,n+1) if (s[i]==\'1\'&&dp2[n][n-i+1]<=n) \n\t\tupd(ret2,mp(n-i+1,dp2[n][n-i+1]));\n\tret=0;\n\trep(i,n-ret2.fi+1,n+1) ret=(ret*2+s[i]-\'0\')%mod;\n\tret=(ret+ret2.se)%mod;\n\tprintf(""%d\\n"",ret);\n}\n']",,,"['dp', 'strings']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Dreamoon and Binary.json,https://codeforces.com/blog/entry/14256,So let s look into how to calculate the value for a given pair If the value of is equal to or greater than than is because if is less than would make length of the new partition less than the previous partition thus its value would be lesser And if can t be the value of is always a valid choice because it would make the length of the new partition greater than the previous one So for each length if we know the order of and in time we can calculate k in time can be easily shown by assuming One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in time The prefix doubling algorithm requires precompute time Note there is still a various of ways to do this part of task in the same or better time complexties And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp Then compare all states ends with Overall we can solve this problem in with caution in details like boundaries and module operations time complexity Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code 8215216 
https://codeforces.com//contest/1132/problem/F,307700,F,1132F,1132,F. Clear the String,You are given a string s of length n consisting of lowercase Latin letters You may apply some operations to this string in one operation you can delete some contiguous substring of this string if all letters in the substring you delete are equal For example after deleting substring from string we get the string Calculate the minimum number of operations to delete the whole string s ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 507;\n\nint f[MX][MX];\nint g[MX];\nconst int INF = 1000 * 1000 * 1000 + 7;\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    s = ""$"" + s;\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= n + 1; j++) {\n            f[i][j] = INF;\n        }\n        f[i][i] = 1;\n    }\n    for (int l = n; l >= 1; l--) {\n        for (int i = 1; i <= n; i++) {\n            g[i] = INF;\n        }\n        g[l] = 0;\n        for (int r = l; r < n; r++) {\n            if (s[r + 1] == s[l]) {\n                g[r + 1] = min(g[r + 1], g[r]);\n            }\n            for (int k = r + 1; k <= n; k++) {\n                g[k] = min(g[k], g[r] + f[r + 1][k]);\n            }\n        }\n        for (int r = l; r <= n; r++) {\n            f[l][r] = g[r] + 1;\n        }\n    }\n\n    cout << f[1][n] << ""\\n"";\n    return 0;\n}\n\n']",,,['dp'],2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Clear the String.json,https://codeforces.com/blog/entry/65752,We will solve the problem by dynamic programming Let be the answer for substring Then we have two cases The first letter of the substring is deleted separately from the rest then The first letter of the substring is deleted alongside with some other letter both letters must be equal then 
https://codeforces.com//contest/96/problem/A,502,A,96A,96,A. Football,Petya loves football very much One day as he was watching a football match he was writing the players current positions on a piece of paper To simplify the situation he depicted it as a string consisting of zeroes and ones A zero corresponds to players of one team a one corresponds to players of another team If there are at least players of some team standing one after another then the situation is considered dangerous For example the situation is dangerous and is not You are given the current situation Determine whether it is dangerous or not ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nstring\tst;\n\n\nint\tmain()\n{\n//\tfreopen(""A.in"", ""r"", stdin);\n//\tfreopen(""A.out"", ""w"", stdout);\n\t\n\tcin >> st;\n\tint\tnow = 1, last = -1, most = 0;\n\tfor (int i = 0; i < st.size(); ++ i)\n\t{\n\t\tif (st[i] - \'0\' == last) now ++; else now = 1;\n\t\tmost = max(most, now);\n\t\tlast = st[i] - \'0\';\n\t}\n\tputs(most >= 7 ? ""YES"" : ""NO"");\n\t\n\treturn 0;\n}\n']",,,"['implementation', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Football.json,https://codeforces.com//blog/entry/2257,In this problem you must find longest substring consisting of equal characters and compare it with 7 
https://codeforces.com//contest/699/problem/A,65782,A,699A,699,A. Launch of Collider,There will be a launch of a new powerful and unusual collider very soon which located along a straight line particles will be launched inside it All of them are located in a straight line and there can not be two or more particles located in the same point The coordinates of the particles coincide with the distance in meters from the center of the collider is the coordinate of the th particle and its position in the collider at the same time All coordinates of particle positions are You know the direction of each particle movement it will move to the right or to the left after the collider s launch start All particles begin to move simultaneously at the time of the collider s launch start Each particle will move straight to the left or straight to the right with the constant speed of meter per microsecond The collider is big enough so particles can not leave it in the foreseeable time Write the program which finds the moment of the first collision of any two particles of the collider In other words find the number of microseconds before the first moment when any two particles are at the same point ,"['#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#define bll long long\n#define dou double\n#define For(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define Rof(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define rep(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define rek(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define Cpy(a,b) memcpy(a,b,sizeof(b))\n//__builtin_popcountll\n\nconst int maxn=100000*2+100,oo=1<<30;\nint N,A[maxn];\nchar s[maxn];\n\nint main(int argc, char* argv[])\n{\n    for (; scanf(""%d"",&N)!=EOF; )\n    {\n        scanf(""%s"",s+1);\n        For(i,1,N) scanf(""%d"",&A[i]);\n        int tim=oo;\n        For(i,1,N-1)\n            if (s[i]==\'R\' && s[i+1]==\'L\')\n                tim=min(tim,A[i+1]-A[i]);\n        if (tim!=oo)\n        {\n            tim>>=1;\n            printf(""%d\\n"",tim);\n        }\n        else printf(""-1\\n"");\n\n    }\n    return 0;\n}']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Launch of Collider.json,https://codeforces.com//blog/entry/46148,To solve this problem it is enough to look at all pairs of adjacent particles such that the left particle will move to the right and the right particle will move to the left If there is no such pair the answer is Otherwise let s iterate through the particles from the left to the right If the particle will move to the right and the particle will move to the left we know that this particles will be at the same point simultaneously so we need to update the answer with value The answer is always integer because all coordinates of the particles are even numbers 
https://codeforces.com//contest/1782/problem/G,1738313,G,1782G,1782,G. Diverse Coloring,In this problem we will be working with rooted binary trees A tree is called a rooted binary tree if it has a fixed root and every vertex has at most two children Let s assign a color white or blue to each vertex of the tree and call this assignment a of the tree Let s call a coloring if every vertex has a neighbor a parent or a child colored into an opposite color compared to this vertex It can be shown that any tree with at least two vertices allows a diverse coloring Let s define the of a coloring as the absolute value of the difference between the number of white vertices and the number of blue vertices Now to the problem Initially the tree consists of a single vertex with the number 1 which is its root Then for each i from 2 to n a new vertex i appears in the tree and it becomes a child of vertex p i It is guaranteed that after each step the tree will keep being a binary tree rooted at vertex 1 that is each vertex will have at most two children After every new vertex is added print the smallest value of disbalance over all possible diverse colorings of the current tree Moreover after adding the last vertex with the number n also print a diverse coloring with the smallest possible disbalance as well ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, p[N], deg[N], ns, vis[N], tag[N], ans[N];\nint to[N], tow[N], sum[N];\nvi e[N], G[N];\nvoid dfs(int x, int rt, int rtx) {\n\tif(rtx) \n\t\tsum[rt] -= 1;\n\telse \n\t\tsum[rt] += 1;\n\tto[x] = rt;\n\ttow[x] = rtx;\n\tfor(auto v : G[x]) if(!to[v]) \n//\t\tcout << x << "" -> "" << v << endl, \n\t\tdfs(v, rt, rtx ^ 1);\n}\nint S[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) deg[i] = 0, sum[i] = 0, tow[i] = 0, ans[i] = 0, \n\t\tto[i] = 0, tow[i] = 0, e[i].clear(), G[i].clear();\n\tL(i, 2, n) {\n\t\tcin >> p[i];\n\t\tdeg[i] += 1;\n\t\tdeg[p[i]] += 1;\n\t\tns = i & 1;\n\t\tif(i == 4) {\n\t\t\tL(i, 1, 4) \n\t\t\t\tif(deg[i] == 3)\n\t\t\t\t\tns = 2;\n \t\t}\n \t\tcout << ns << \'\\n\';\n\t\te[i].emplace_back(p[i]);\n\t\te[p[i]].emplace_back(i);\n\t} \n\tif(n <= 4) {\n\t\tL(msk, 0, (1 << n) - 1) {\n\t\t\tint bt = __builtin_popcount(msk);\n\t\t\tif(n - bt * 2 != ns) continue;\n\t\t\tint qwq = 1;\n\t\t\tL(i, 1, n) {\n\t\t\t\tint ok = 0;\n\t\t\t\tfor(auto v : e[i]) {\n\t\t\t\t\tif((msk >> (i - 1) & 1) != (msk >> (v - 1) & 1)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\tif(!ok) qwq = 0;\n\t\t\t}\n\t\t\tif(qwq) {\n\t\t\t\tL(i, 1, n) cout << ((msk >> (i - 1) & 1) ? \'w\' : \'b\');\n\t\t\t\tcout << \'\\n\';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t\treturn ;\n\t}\n\tqueue < int > q;\n\tL(i, 1, n) if(deg[i] == 1) q.push(i);\n\tL(i, 1, n) vis[i] = 0, tag[i] = 0, S[i] = 1; \n\twhile(sz(q)) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tvis[u] = 1;\n//\t\tcout << ""u = "" << u << endl;\n\t\t\n\t\tint to = -1;\n\t\tfor(auto v : e[u]) {\n\t\t\tif(!vis[v]) {\n\t\t\t\t--deg[v];\n\t\t\t\tif(deg[v] == 1) \n\t\t\t\t\tq.push(v);\n\t\t\t\tto = v;\n\t\t\t}\n\t\t}\n\t\t\n//\t\tcout << ""act "" << u << "" : "" << S[u] << endl;\n\t\tif(tag[u]) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(auto v : e[u]) \n\t\t\tif(S[v] >= 0) \n\t\t\t\tto = v;\n\t\tif(to == -1) \n\t\t\tto = e[u][0];\n//\t\tcout << u << "" : "" << S[u] << endl;\n\t\t\n\t\tG[u].emplace_back(to);\n\t\tG[to].emplace_back(u);\n\t\tS[to] -= S[u];\n\t\ttag[u] = tag[to] = true;\n\t}\n\t\n//\tL(i, 1, n) \n//\t\tcout << S[i] << \' \';\n//\tcout << endl;\n\t\n\tvi arr;\n\tL(i, 1, n) if(!to[i]) \n\t\tsum[i] = 0, dfs(i, i, 0), arr.emplace_back(i);\n\t\n\tsort(arr.begin(), arr.end(), [&] (int x, int y) {\n\t\treturn abs(sum[x]) > abs(sum[y]);\n\t});\n\tint all = 0;\n\tfor(auto u : arr) {\n\t\tint ab = abs(sum[u]);\n//\t\tcout << ""ab = "" << ab << endl; \n\t\tif(all <= 0) {\n\t\t\tall += ab;\n\t\t\tans[u] = 0 ^ (sum[u] < 0);\n\t\t} else {\n\t\t\tall -= ab;\n\t\t\tans[u] = 1 ^ (sum[u] < 0);\n\t\t}\n\t}\n\tL(i, 1, n) \n\t\tans[i] = ans[to[i]] ^ tow[i];\n\tassert(all == ns);\n\t\n\tL(i, 1, n) \n\t\tif(ans[i]) cout << \'w\';\n\t\telse cout << \'b\';\n\tcout << \'\\n\';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ']",,,"['constructive algorithms', 'dp', 'greedy', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Diverse Coloring.json,https://codeforces.com//blog/entry/111783,It turns out that it is always possible to construct a diverse coloring with disbalance or depending on the parity of except for the case of a tree with vertices with one vertex of degree which is given in the example Let s traverse the tree from bottom to top For each subtree we will try to construct a diverse coloring where the subtree root is colored white We will define the disbalance of the subtree coloring to be the number of vertices colored white minus the number of vertices colored blue This is equivalent to the original definition except that now the number also has a sign We will aim at obtaining disbalances and if possible In some small cases it will be impossible We will say subtree has disbalance or vertex has disbalance meaning that we have constructed a coloring of the vertex s subtree with disbalance Let be the root of the subtree colored white If has no children the only coloring has disbalance however it is not diverse Thus we will have to be careful about the leaf case in the future If has one child flip the colors in s subtree to create a blue neighbor for If had disbalance before the flip now has disbalance If had disbalance before the flip now has disbalance If has two children and If both have disbalance flip the colors in at least one of s and s subtrees now has disbalance If both have disbalance flip the colors in either s or s subtree now has disbalance If one has disbalance and the other has disbalance flip the colors in the one with now has disbalance The only issue happens when has two children that are both leaves we have to recolor both and into blue which will force to have disbalance Let s add new cases to the analysis above based on the existence of subtrees with disbalance If has one child with disbalance Flip the colors in s subtree now has disbalance If has two children and where has disbalance If has disbalance flip the colors in either s or s subtree now has disbalance If has disbalance flip the colors in s subtree now has disbalance If has disbalance flip the colors in both s and s subtrees now has disbalance We can see that once again a new case appears where a subtree has disbalance described at the beginning of this tutorial and unfortunately we can t avoid that We can see that this case only happens for a specific subtree of vertices Let s proceed with the case analysis If has one child with disbalance Flip s color not the whole subtree but just now has disbalance If has two children and where has disbalance If has disbalance flip the colors in both s and s subtrees now has disbalance If has disbalance flip s color now has disbalance If has disbalance flip s color and the colors in s subtree now has disbalance If has disbalance flip the colors in either s or s subtree now has disbalance It follows that for any other tree except two special cases of a vertex tree and a vertex tree it is possible to obtain disbalance or From this point one way to implement the solution is to carefully consider all the cases Note that whenever we say flip the colors in s subtree we can just set some flag in vertex Then as we traverse the tree from top to bottom we can construct the correct coloring in time Another way is to use dynamic programming whether it is possible to color s subtree to obtain disbalance so that all vertices except have neighbors of opposite color and has such a neighbor iff Since it is enough to limit disbalance by we can conclude that the number of states the number of transitions and the time complexity are all 
https://codeforces.com//contest/817/problem/F,110092,F,817F,817,F. MEX Queries,You are given a set of integer numbers initially it is empty You should perform queries There are three different types of queries Add all missing numbers from the interval Remove all present numbers from the interval Invert the interval add all missing and remove all present numbers from the interval After each query you should output of the set the smallest positive integer number which is not presented in the set ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nconst int maxn = 1e6 + 5;\nint n;\nint op[maxn];\nlong long l[maxn];\nlong long r[maxn];\n\nint st[maxn << 2];\nint lz1[maxn << 2];\nint lz2[maxn << 2];\n\nvoid pushdown(int p, int L, int R) {\n    if (lz1[p]) {\n        st[p] = (R - L + 1) - st[p];\n        if (L < R) {\n            if (~lz2[p << 1]) {\n                lz1[p << 1] = 0;\n                lz2[p << 1] ^= 1;\n            }\n            else {\n                lz1[p << 1] ^= 1;\n            }\n            if (~lz2[p << 1 | 1]) {\n                lz1[p << 1 | 1] = 0;\n                lz2[p << 1 | 1] ^= 1;\n            }\n            else {\n                lz1[p << 1 | 1] ^= 1;\n            }\n        }\n        lz1[p] = 0;\n    }\n    if (~lz2[p]) {\n        st[p] = lz2[p] * (R - L + 1);\n        if (L < R) {\n            lz2[p << 1] = lz2[p];\n            lz1[p << 1] = 0;\n            lz2[p << 1 | 1] = lz2[p];\n            lz1[p << 1 | 1] = 0;\n        }\n        lz2[p] = -1;\n    }\n}\n\nvoid upd1(int p, int l, int r, int L, int R) {\n    pushdown(p, L, R);\n    if (l > R || r < L) return;\n    if (l <= L && r >= R) {\n        lz1[p] = 1;\n        pushdown(p, L, R);\n        return;\n    }\n    upd1(p << 1, l, r, L, L + R >> 1);\n    upd1(p << 1 | 1, l, r, (L + R >> 1) + 1, R);\n    st[p] = st[p << 1] + st[p << 1 | 1];\n}\n\nvoid upd2(int p, int l, int r, int L, int R, int val) {\n    pushdown(p, L, R);\n    if (l > R || r < L) return;\n    if (l <= L && r >= R) {\n        lz2[p] = val;\n        pushdown(p, L, R);\n        return;\n    }\n    upd2(p << 1, l, r, L, L + R >> 1, val);\n    upd2(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n    st[p] = st[p << 1] + st[p << 1 | 1];\n}\n\nint query(int p, int L, int R) {\n    pushdown(p, L, R);\n    if (L == R) return L;\n    pushdown(p << 1, L, L + R >> 1);\n    pushdown(p << 1 | 1, (L + R >> 1) + 1, R);\n    if (st[p << 1] < (L + R >> 1) - L + 1) return query(p << 1, L, L + R >> 1);\n    return query(p << 1 | 1, (L + R >> 1) + 1, R);\n}\n\nvoid solve() {\n    cin >> n;\n    vector<long long> dc;\n    FOR(i, 0, n) {\n        cin >> op[i] >> l[i] >> r[i];\n        FOR(k, -1, 1 + 1) {\n            if (l[i] + k > 0) {\n                dc.pb(l[i] + k);\n            }\n            if (r[i] + k > 0) {\n                dc.pb(r[i] + k);\n            }\n        }\n    }\n    dc.pb(1);\n    sort(all(dc)), uni(dc);\n    FOR(i, 0, n) {\n        int x = lower_bound(all(dc), l[i]) - dc.begin();\n        int y = lower_bound(all(dc), r[i]) - dc.begin();\n        if (op[i] == 1) {\n            upd2(1, x, y, 0, sz(dc) - 1, 1);\n        }\n        else if (op[i] == 2) {\n            upd2(1, x, y, 0, sz(dc) - 1, 0);\n        }\n        else if (op[i] == 3) {\n            upd1(1, x, y, 0, sz(dc) - 1);\n        }\n        cout << dc[query(1, 0, sz(dc) - 1)] << ""\\n"";\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']",,,"['binary search', 'data structures', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. MEX Queries.json,https://codeforces.com//blog/entry/52638,There are many ways to solve this problem you can use cartesian tree segment tree sqrt decomposition maybe something else I personally see the solution with the segment tree the easiest one so let me describe it Firstly let s notice that the queries are offline So we can compress the numbers by taking and of each query will be either one of these numbers or So now we have numbers up to and pretty basic task on segment tree The first two types of queries are translated to assign value or on a segment set the number on some position is either present or not The third is for each in segment assign to this will inverse the segment as described in statement Segment tree should keep sum of the segment in its nodes XOR on segment will turn into is the length of the segment being covered by the node The leftmost zero cell is While standing in some node check if its left son is full has in every cell of the segment like if you use 1 indexed tree and intervals for it If it is full then go down to the right son otherwise there exists some zero cell in a segment of the left child and you should go down to it You should use lazy propagation to guarantee per query Overall complexity 
https://codeforces.com//contest/1342/problem/D,604759,D,1342D,1342,D. Multiple Testcases,So you decided to hold a contest on Codeforces You prepared the problems statements solutions checkers validators tests Suddenly your coordinator asks you to change all your tests to multiple testcases in the easiest problem Initially each test in that problem is just an array The maximum size of an array is k For simplicity the contents of arrays don t matter You have n tests the i th test is an array of size m i 1 le m i le k Your coordinator asks you to distribute all of your arrays into multiple testcases Each testcase can include multiple arrays However each testcase should include no more than c 1 arrays of size ge 1 no more than c 2 arrays of size dots no more than c k arrays of size Also c 1 ge c 2 ge dots ge c k So now your goal is to create the new testcases in such a way that each of the initial arrays appears in testcase for each testcase the given conditions hold the number of testcases is minimum possible Print the minimum possible number of testcases you can achieve and the sizes of arrays included in each testcase ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, a[200020], b[200020], c[200020];\nbool check(int k) {\n    for (int i = 1; i <= k; i++) {\n        int p = 0;\n        for (int j = i; j <= n; j += k)\n                    b[++p] = a[j];\n        for (int j = 1; j <= p; j++)\n                    if (p - j + 1 > c[b[j]])\n                        return false;\n    }\n    return true;\n}\nint find() {\n    int l = 0, r = n, mid;\n    while (l + 1 < r) {\n        mid = (l + r) >> 1;\n        if (check(mid)) r = mid; else            l = mid;\n    }\n    return r;\n}\nvoid print(int k) {\n    printf(""%d\\n"", k);\n    for (int i = 1; i <= k; i++) {\n        printf(""%d "", (n - i) / k + 1);\n        for (int j = i; j <= n; j += k)\n                    printf(""%d "", a[j]);\n        puts("""");\n    }\n}\nint main() {\n    scanf(""%d %d"", &n, &m);\n    for (int i = 1; i <= n; i++)\n            scanf(""%d"", &a[i]);\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= m; i++)\n            scanf(""%d"", &c[i]);\n    print(find());\n    return 0;\n}']",,,"['binary search', 'constructive algorithms', 'data structures', 'greedy', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Multiple Testcases.json,https://codeforces.com//blog/entry/76633,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to be The answer is maximum over all from to You can prove that you can t fit arrays in less than testcases with the pigeonhole principle Let that be called Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the th array indexed in that order to the testcase It s easy to see that for any the number of arrays of size greater than or equal to is always restricted by Overall complexity or if you care enough to do counting sort 
https://codeforces.com//contest/1689/problem/E,1426172,E,1689E,1689,E. ANDfinity,After graduating from computer sciences Vlad has been awarded an array a 1 a 2 ldots a n of n non negative integers As it is natural he wanted to construct a graph consisting of n vertices numbered 1 2 ldots n He decided to add an edge between i and j if and only if a i a j 0 where denotes the bitwise AND operation Vlad also wants the graph to be connected which might not be the case initially In order to satisfy that he can do the following two types of operations on the array Choose some element a i and increment it by 1 Choose some element a i and decrement it by 1 possible only if a i 0 It can be proven that there exists a finite sequence of operations such that the graph will be connected So can you please help Vlad find the minimum possible number of operations to do that and also provide the way how to do that ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (a[i] == 0) a[i] = 1, ++ans;\n        }\n        auto check = [&](vector<int> a) {\n            vector<int> vis(31), f(31);\n            function<int(int)> find = [&](int x) {\n                if (f[x] == x) return f[x];\n                return f[x] = find(f[x]);\n            };\n            for (int i = 0; i <= 30; i++) f[i] = i;\n            for (auto i : a) {\n                int r = -1;\n                for (int b = 0; b <= 30; b++) {\n                    if ((i >> b) & 1) {\n                        vis[b] = 1;\n                        if (r == -1) r = b;\n                        f[find(b)] = find(r);\n                    }\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < 30; i++) {\n                if (vis[i] && find(i) == i) {\n                    ++cnt;\n                }\n            }\n            return cnt == 1;\n        };\n        if (check(a)) {\n            cout << ans << endl;\n            for (auto i : a) cout << i << "" "";\n            cout << endl;\n            continue;\n        }\n        int ok = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 1) {\n                --a[i];\n                if (check(a)) {\n                    cout << ans + 1 << endl;\n                    for (auto i : a) cout << i << "" "";\n                    cout << endl;\n                    ok = 1;\n                    break;\n                }\n                ++a[i];\n            }\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 1 << endl;\n                for (auto i : a) cout << i << "" "";\n                cout << endl;\n                ok = 1;\n                break;\n            }\n            --a[i];\n        }\n        if (ok) continue;\n        vector<int> vis(30), f(30);\n        for (int i = 0; i < 30; i++) f[i] = i;\n        function<int(int)> find = [&](int x) {\n            if (f[x] == x) return f[x];\n            return f[x] = find(f[x]);\n        };\n        for (auto i : a) {\n            int r = -1;\n            for (int b = 0; b <= 29; b++) {\n                if ((i >> b) & 1) {\n                    vis[b] = 1;\n                    if (r == -1) r = b;\n                    int x = find(b), y = find(r);\n                    if (x > y) f[x] = y;\n                    else f[y] = x;\n                }\n            }\n        }\n        for (int i = 29; i >= 0; i--) {\n            if (vis[i] && find(i) == i) {\n                for (int j = 0; j < n; j++) {\n                    if ((a[j] >> i) & 1) {\n                        --a[j];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 2 << endl;\n                for (auto i : a) cout << i << "" "";\n                cout << endl;\n                break;\n            }\n            --a[i];\n        }\n    }\n    return 0;\n}']",,,"['bitmasks', 'brute force', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. ANDfinity.json,https://codeforces.com//blog/entry/103471,SolutionFirslty let s understand how to check whether the graph induced by some array is connected in We create a graph over bits Let s take all elements and add an edge between their adjacent bits all bits of a single will be connected To quickly access the lowest bit we will use in code Now we just check whether the graph over bits is connected We check whether the graph for initial array is connected If it is the answer is 0 Then we wonder if the answer is Check if at least one of the graphs for arrays for every is connected Do the same for arrays If none of the graphs is connected the answer is and otherwise Now let s see how the answer will be at most Let be the sequence of indices denoting that has the highest lowest bit the highest value of if then we can just decrease by and connect everything If and we do the same we might disconnect that number from other numbers having the highest lowest bit thus an additional operation of adding to is needed to keep everything connected The answer is in this case Complexity of this solution is 
https://codeforces.com//contest/1271/problem/C,495883,C,1271C,1271,C. Shawarma Tent,The map of the capital of Berland can be viewed on the infinite coordinate plane Each point with integer coordinates contains a building and there are streets connecting every building to four neighbouring buildings All streets are parallel to the coordinate axes The main school of the capital is located in s x s y There are n students attending this school the i th of them lives in the house located in x i y i It is possible that some students live in the same house but no student lives in s x s y After classes end each student walks from the school to his house along one of the shortest paths So the distance the i th student goes from the school to his house is s x x i s y y i The Provision Department of Berland has decided to open a shawarma tent somewhere in the capital at some point with integer coordinates It is considered that the i th student will buy a shawarma if at least one of the shortest paths from the school to the i th student s house goes through the point where the shawarma tent is located It is forbidden to place the shawarma tent at the point where the school is located but the coordinates of the shawarma tent may coincide with the coordinates of the house of some student or even multiple students You want to find the maximum possible number of students buying shawarma and the optimal location for the tent itself ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 202;\n\nint n, sx, sy, x, y, cnt[4];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> sx >> sy;\n\twhile (n--) {\n\t\tcin >> x >> y;\n\t\tvector<int> a;\n\t\tif (x == sx)\n\t\t\tcnt[2 * (y > sy)]++;\n\t\telse if (y == sy)\n\t\t\tcnt[1 + 2 * (x < sx)]++;\n\t\telse {\n\t\t\tif (x < sx && y < sy)\n\t\t\t\tcnt[0]++, cnt[3]++;\n\t\t\telse if (x < sx && y > sy)\n\t\t\t\tcnt[3]++, cnt[2]++;\n\t\t\telse if (y < sy)\n\t\t\t\tcnt[0]++, cnt[1]++;\n\t\t\telse\n\t\t\t\tcnt[1]++, cnt[2]++;\n\t\t}\n\t}\n\tint dex = max_element(cnt, cnt + 4) - cnt;\n\tcout << cnt[dex] << '\\n';\n\tif (dex == 0)\n\t\tsy--;\n\telse if (dex == 1)\n\t\tsx++;\n\telse if (dex == 2)\n\t\tsy++;\n\telse\n\t\tsx--;\n\tcout << sx << ' ' << sy;\n}\n""]",,,"['brute force', 'geometry', 'greedy', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Shawarma Tent.json,https://codeforces.com/blog/entry/72247,Suppose that the point is the answer If the distance between this point and the school is greater than then there exists at least one point such that the distance between and the school is exactly lies on the shortest path between the school and Now we claim that the can also be the optimal answer That s because if there exists a shortest path from the school to some point going through the shortest path from to going through can be extended to become the shortest path to So we only need to check four points adjacent to the school as possible answers To check whether a point lies on the shortest path from to we need to verify that and 
https://codeforces.com//contest/1067/problem/C,242829,C,1067C,1067,C. Knights,Ivan places knights on infinite chessboard Initially there are n knights If there is free cell which is under attack of at least 4 knights then he places new knight in this cell Ivan repeats this until there are no such free cells One can prove that this process is finite One can also prove that position in the end does not depend on the order in which new knights are placed Ivan asked you to find initial placement of exactly n knights such that in the end there will be at least lfloor frac n 2 10 rfloor knights ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nvector <pii> ruch;\n\npii rusz(pii a, pii b)\n{\n\treturn {a.first+b.first, a.second+b.second};\n}\n\nint powiedz(vector <pii> wek)\n{\n\tset <pii> setel;\n\tqueue <pii> kol;\n\tfor (pii i : wek)\n\t{\n\t\tsetel.insert(i);\n\t\tfor (pii j : ruch)\n\t\t\tkol.push(rusz(i, j));\n\t}\n\twhile(!kol.empty())\n\t{\n\t\tpii v=kol.front();\n\t\tkol.pop();\n\t\tif (setel.count(v))\n\t\t\tcontinue;\n\t\tint li=0;\n\t\tfor (pii i : ruch)\n\t\t\tli+=setel.count(rusz(v, i));\n\t\tif (li>=4)\n\t\t{\n\t\t\tsetel.insert(v);\n\t\t\tfor (pii i : ruch)\n\t\t\t\tkol.push(rusz(v, i));\n\t\t}\n\t}\n\treturn setel.size();\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=-2; i<=2; i++)\n\t\tfor (int j=-2; j<=2; j++)\n\t\t\tif (i*i+j*j==5)\n\t\t\t\truch.push_back({i, j});\n\tvector < pair <int,pii> > wek;\n\tsort(wek.begin(), wek.end());\n\tfor (int i=0; i<=10000; i++)\n\t\tfor (int j=0; j<=10000 && (i<3 || j<3); j++)\n\t\t\tif ((i&1)==(j&1))\n\t\t\t\twek.push_back({i+j, {i, j}});\n\tsort(wek.begin(), wek.end());\n\tvector <pii> chce;\n\tfor (int i=0; i<n; i++)\n\t\tchce.push_back(wek[i].second);\n\t//~ debug() << imie(powiedz(chce)) << "" na "" << n*n/10;\n\t//~ int x=powiedz(chce);\n\t//~ debug() << imie(x-(n*n/10));\n\t//~ assert(x>=(n*n/10));\n\tfor (pii i : chce)\n\t\tprintf(""%d %d\\n"", i.first, i.second);\n\treturn 0;\n}\n']",,,['constructive algorithms'],2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Knights.json,https://codeforces.com/blog/entry/62688,If after some loops of the process we will have two neighboring lines with length total complexity of knights would be not less than In this construction initial placement added knights Would be two neighboring lines with length so total complexity of knights would be The possible way to facilitate the invention this or over solutions is to write process modeling Bonus Solve this problem with complexity 
https://codeforces.com//contest/1716/problem/F,1494205,F,1716F,1716,F. Bags with Balls,There are n bags each bag contains m balls with numbers from 1 to m For every i in 1 m there is exactly one ball with number i in each bag You have to take exactly one ball from each bag all bags are different so for example taking the ball 1 from the first bag and the ball 2 from the second bag is not the same as taking the ball 2 from the first bag and the ball 1 from the second bag After that you calculate the number of balls with numbers among the ones you have taken Let the number of these balls be F Your task is to calculate the sum of F k over all possible ways to take n balls one from each bag ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 2020;\nMint S[N][N];\nMint C[N];\nMint pw[N];\n\nvoid solve() {\n\tint n, m, k;\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tC[0] = 1;\n\tfor (int i = 0; i < k; i++)\n\t\tC[i + 1] = C[i] * Mint(n - i);\n\tpw[0] = 1;\n\tpw[1] = Mint((m + 1) / 2) / Mint(m);\n\tfor (int i = 1; i < k; i++)\n\t\tpw[i + 1] = pw[i] * pw[1];\n\tMint ans = 0;\n\tfor (int p = 1; p <= k; p++)\n\t\tans += S[k][p] * C[p] * pw[p];\n\tans *= Mint(m).pow(n);\n\tprintf(""%u\\n"", ans.x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tS[0][0] = 1;\n\tfor (int n = 1; n < N; n++)\n\t\tfor (int k = 1; k <= n; k++)\n\t\t\tS[n][k] = S[n - 1][k] * k + S[n - 1][k - 1];\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'math', 'number theory']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Bags with Balls.json,https://codeforces.com//blog/entry/105653,The main idea of this problem is to use a technique similar to contribution to the sum We will model the value of as the number of tuples where each element is an index of a bag from which we have taken an odd ball Let be the number of ways to take balls from bags so that all elements from tuple are indices of bags with odd balls then the answer to the problem can be calculated as the sum of over all possible tuples First of all let s obtain a solution in per test case We need to answer the following questions while designing a solution to the problem How do we calculate for a given tuple How do we group tuples and iterate through them The first question is not that difficult Every element from the tuple should be an index of a bag from which we have taken an odd ball so for every bag appearing in the tuple we can take only a ball with odd number but for every bag not appearing in the tuple we can choose any ball So if the number of elements in a tuple is then for the tuple can be calculated as This actually gives as a hint for the answer to the second question since depends on the number of distinct elements in the tuple let s try to group the tuples according to the number of distinct elements in them So the answer will be calculated as where is the number of tuples with exactly different elements How do we calculate First of all if then is obviously Otherwise we can use the following recurrence let be the number of tuples of elements with distinct ones then if and for a tuple with one element there are ways to choose it if and if and there is only one distinct element and it was already chosen if and we either add an element which did not belong to the tuple and there are ways to choose it or we add an already existing element and there are ways to choose it Obviously this recurrence can be calculated in with dynamic programming so we get a solution in per test case How do we speed this up Let s change the way we calculate Instead of considering tuples with values from to we will consider only tuples where values are from to and the first appearance of a value is only after the first appearance of the value So these tuples actually represent a way to split a set of integers into several subsets so they are the Stirling numbers of the second kind and we can calculate them in with dynamic programming outside of processing the test cases How do we calculate using these values If we use distinct integers as the elements of the tuple there are ways to choose the first one ways to choose the second one etc so where is the Stirling number of the second kind for the parameters and We can maintain the values of and while iterating on from to and that gives us a way to solve the problem in per test case Overall complexity for precalculation and per test case 
https://codeforces.com//contest/1187/problem/D,365120,D,1187D,1187,D. Subarray Sorting,You are given an array a 1 a 2 dots a n and an array b 1 b 2 dots b n For one operation you can sort in non decreasing order any subarray a l dots r of the array a For example if a 4 2 2 1 3 1 and you choose subbarray a 2 dots 5 then the array turns into 4 1 2 2 3 1 You are asked to determine whether it is possible to obtain the array b by applying this operation any number of times possibly zero to the array a ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1200*1007;\nconst int n1=(1<<19);\n\nint n;\n\nint a[nax];\nint b[nax];\n\nint gdz[nax];\n\nmap <int,int> sta, kon;\n\nvoid nie()\n{\n\tprintf(""NO\\n"");\n}\n\nvoid tak()\n{\n\tprintf(""YES\\n"");\n}\n\nint drz[nax];\n\nvoid zmien(int v, int w)\n{\n\tv+=n1-1;\n\tdrz[v]=w;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=min(drz[v*2], drz[v*2+1]);\n\t\tv>>=1;\n\t}\n}\n\nint czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\treturn drz[v];\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn 1e9;\n\t}\n\treturn min(\n\t\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\t\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\n\t);\n}\n\nvoid test()\n{\n\tsta.clear();\n\tkon.clear();\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &a[i]);\n\t\tsta[a[i]]++;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &b[i]);\n\t\tkon[b[i]]++;\n\t}\n\tif (sta!=kon)\n\t{\n\t\tnie();\n\t\treturn;\n\t}\n\tvector <pii> raz, dwa;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\traz.push_back({a[i], i});\n\t\tdwa.push_back({b[i], i});\n\t}\n\tsort(raz.begin(), raz.end());\n\tsort(dwa.begin(), dwa.end());\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ta[raz[i-1].second]=i;\n\t\tb[dwa[i-1].second]=i;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tgdz[a[i]]=i;\n\t//~ debug() << range(a+1, a+1+n);\n\t//~ debug() << range(b+1, b+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tzmien(i, a[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x=gdz[b[i]];\n\t\t//~ debug() << imie(x) << czyt(1, 1, n1, 1, x);\n\t\tif (czyt(1, 1, n1, 1, x)<b[i])\n\t\t{\n\t\t\tnie();\n\t\t\treturn;\n\t\t}\n\t\tzmien(x, 1e9);\n\t}\n\ttak();\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['data structures', 'sortings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Subarray Sorting.json,https://codeforces.com//blog/entry/68111,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree 
https://codeforces.com//contest/632/problem/C,50145,C,632C,632,C. The Smallest String Concatenation,You re given a list of strings You d like to concatenate them together in some order such that the resulting string would be lexicographically smallest Given the list of strings output the lexicographically smallest concatenation ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nstring s[60000];\n\nbool cmp(const string& a, const string& b) {\n\treturn (a + b) < (b + a);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> s[i];\n\tsort(s, s + n, cmp);\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << s[i];\n\tcout << ""\\n"";\n\treturn 0;\n}\n\n\n']",,,"['sortings', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. The Smallest String Concatenation.json,https://codeforces.com//blog/entry/43493,The problem was suggested by Lewin Gan Lewin The proof of the transitivity also belongs to him Let s sort all the strings by comparator and concatenate them Let s prove that it s the optimal answer Let that operator be transitive so if Consider an optimal answer with two strings in reverse order by that operator Because of the transitivity of operator we can assume that pair of strings are neighbouring But then we can swap them and get the better answer Let s prove the transitivity of operator Consider the strings as the base numbers Then the relation equivalent to The last is simply the relation between real numbers So we proved the transitivity of the relation C solution by me Python solution by Lewin Complexity where is the maximal string length 
https://codeforces.com//contest/263/problem/A,2516,A,263A,263,A. Beautiful Matrix,You ve got a matrix consisting of zeroes and a single number one Let s index the matrix rows by numbers from to from top to bottom let s index the matrix columns by numbers from to from left to right In one move you are allowed to apply one of the two following transformations to the matrix Swap two neighboring matrix rows that is rows with indexes and for some integer Swap two neighboring matrix columns that is columns with indexes and for some integer You think that a matrix looks if the single number one of the matrix is located in its middle in the cell that is on the intersection of the third row and the third column Count the minimum number of moves needed to make the matrix beautiful ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n\nint mm[10][10], ans;\n\nint abs(int a) {return a>0 ? a : -a;}\n\nint main() {\n    for(int i=0; i<5; i++)\n        for(int j=0; j<5; j++) {\n            scanf(""%d"", &mm[i][j]);\n            if(mm[i][j] == 1) {\n                ans += abs(i-2);\n                ans += abs(j-2);\n            }\n        }\n    printf(""%d\\n"", ans);\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Beautiful Matrix.json,https://codeforces.com//blog/entry/6419,If the single is located on the intersection of the th row and the th column 1 based numeration then the answer is 
https://codeforces.com//contest/1556/problem/G,1093328,G,1556G,1556,G. Gates to Another World,As mentioned previously William really likes playing video games In one of his favorite games the player character is in a universe where every planet is designated by a binary number from 0 to 2 n 1 On each planet there are gates that allow the player to move from planet i to planet j if the binary representations of i and j differ in exactly one bit William wants to test you and see how you can handle processing the following queries in this game universe Destroy planets with numbers from l to r inclusively These planets cannot be moved to anymore Figure out if it is possible to reach planet b from planet a using some number of planetary gates It is guaranteed that the planets a and b are not destroyed ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<ll>\n#define pi pair<ll, ll>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int N = 30000005;\nconst int maxn = 100005;\n\nint ch[N][2];\nint id[N];\nint n;\nll l[maxn], r[maxn];\nint tp[maxn];\nint fa[N];\nint gfa(int x) {\n    if (fa[x] == x) return x;\n    return fa[x] = gfa(fa[x]);\n}\nint u;\nint cnt = 0;\nset<pair<ll, int> > uu; \nint fid(ll x) {\n    auto h = uu.lower_bound(mp(x + 1, 0));\n    h--;\n    return (*h).se;\n}\nint rt = 1;\nint trcnt = 1;\nvoid ins(ll a, int sz, int ids) {\n    int pl = rt;\n    for (int m = u - 1; m >= sz; m--) {\n        int cr = (a >> m) & 1;\n        if (!ch[pl][cr]) ch[pl][cr] = ++trcnt;\n        pl = ch[pl][cr];\n    }\n    assert(trcnt < N * 2 / 3);\n    id[pl] = ids;\n}\nvoid lk(int a, int b) {\n    if (gfa(a) == gfa(b)) return;\n    //cout << ""LK "" << a << \' \' << b << endl;\n    fa[gfa(a)] = gfa(b);\n}\nvoid lk_all(int pl, int ids) {\n    if (!pl) return ;\n    if (id[pl]) {\n        lk(id[pl], ids);\n        return ;\n    }\n    for (int i = 0; i < 2; i++)\n        lk_all(ch[pl][i], ids);\n}\nvoid push_seg(ll a, int sz) {\n    // a ~ (a + (1 << sz) - 1)\n    cnt += 1;\n    //cout << ""ADE_SEG"" << a << \' \' << sz << \' \' << cnt << endl;\n    ins(a, sz, cnt);\n    uu.insert(mp(a, cnt));\n    fa[cnt] = cnt;\n    for (int m = u - 1; m >= sz; m--) {\n        // m  \n        int pl = rt;\n        for (int j = u - 1; j >= sz; j--) {\n            int cr = (a >> j) & 1;\n            if (j == m) cr ^= 1;\n            if (!ch[pl][cr]) {\n                pl = 0;\n                break;\n            }\n            pl = ch[pl][cr];\n            if (id[pl]) {\n            //    cout << ""???"" << m << \' \' << j << \' \' << pl << endl;\n                lk(cnt, id[pl]);\n                break;\n            }\n        }\n        if (pl) lk_all(pl, cnt);\n    }\n}\nvoid add(ll l, ll r) {\n    #define vl vector<ll>\n    //cout << ""ADE "" << l << \' \' << r << endl;\n    vl cr = {0};\n    for (int i = u - 1; i >= 0; i--) {\n        vl ed;\n        for (auto v : cr) {\n            ed.pb(v); ed.pb(v + (1ll << i));\n        }\n        vl ted;\n        for (auto v : ed) {\n            if (v > r || v + (1ll << i) - 1 < l) continue;\n            if (v >= l && (v + (1ll << i) - 1) <= r) push_seg(v, i);\n            else ted.pb(v);\n        }\n        cr = ted;\n    }\n}\nint ans[maxn];\n#undef int \nint main() {\n    #define int long long\n    cin >> u >> n;\n    vector<pair<ll, ll> >  de;\n    for (int i = 1; i <= n; i++) {\n        char inp[5];\n        scanf(""%s"", inp);\n        scanf(""%lld%lld"", &l[i], &r[i]);\n        if (inp[0] == \'b\') de.pb(mp(l[i], r[i])), tp[i] = 0;\n        else tp[i] = 1;\n    }\n    sort(de.begin(), de.end());\n    ll ls = 0;\n    for (auto h : de) {\n        if (ls < h.fi) add(ls, h.fi - 1);\n        chkmax(ls, h.se + 1);\n    }\n    if (ls < (1ll << u))\n        add(ls, (1ll << u) - 1);\n    for (int i = n; i >= 1; i--) {\n        if (tp[i] == 1) {\n            int uf = fid(l[i]), vf = fid(r[i]);\n            //cout << ""ASK"" << uf << \' \' << vf << \' \' << l[i] << \' \' << r[i] << endl;\n            if (gfa(uf) == gfa(vf)) ans[i] = 1;\n            else ans[i] = 0;\n        }\n        else add(l[i], r[i]);\n    }\n    for (int i = 1; i <= n; i++)\n        if (tp[i] == 1) printf(""%d\\n"", ans[i]);\n    return (0-0); //<3\n}']",,,"['bitmasks', 'data structures', 'dsu', 'two pointers']",3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Gates to Another World.json,https://codeforces.com//blog/entry/94384,Let s change the formulation of the problem we will execute queries in reverse order and assign a lifetime to each segment of blocked vertices Lifetime until what moment the segment is blocked Note if we look through the requests in reverse order then for each segment it is possible to determine the moment of time after which the vertices from this segment cease to be blocked Thus the problem looks like this given a graph that is an dimensional hypercube each vertex has edges to adjacent vertices that differ from it by only one coordinate and there are blocked vertex segments that live up to the time Consider the following fact If we take an dimensional hypercube and sequences of vertices and then the numbers in the corresponding positions from these two sequences are neighbours to each other since they differ only in the most significant bit that is in the bit For a better understanding let s depict this for Here denotes that is a neighbour of and is present in the first sequence and in the second For simplicity we will only prohibit movement between a blocked vertex and an unblocked one Let s learn how to get a compressed graph each vertex of which would represent a connected subset of the vertices of the hypercube Also this set which represents a vertex is a set of consecutive vertices that is it is a segment On each edge of this graph is written the time when this edge begins to exist Time makes sense since an edge can be drawn between a vertex that represents a set of blocked vertices and a vertex that represents a set of unblocked vertices And the time on this edge there will be a moment in time when the set of vertices is unblocked Recall that now we are solving a problem in which the vertices are blocked until a certain moment in time The answer to the reachability request is the reachability request for a given compressed graph It is only necessary to correctly determine the reachability of which two vertices of the compressed graph we are interested in Let s learn how to recursively build a given compressed graph Input data for the construction of this graph are the dimension of the hypercube the set of blocked vertices If there are no segments worth blocking then the compressed graph is one vertex which is responsible for the connected set of hypercube vertices If there is one segment then the compressed graph is one vertex representing all vertices and they are all blocked Otherwise we can divide the hypercube into two parts by the most significant bit That is into two hypercubes of dimensions And each segment can go further as input either into two hypercubes or into one of them Having received compressed graphs from each of the two hypercubes we can match the adjacent vertices of these hypercubes as illustrated above It is not difficult to combine two such graphs since each vertex of the graph describes the set of vertices of the hypercube and this set is a segment therefore if we have the vertices of the first and second graphs and respectively in ascending order of the segments for which they answer then it is possible to combine these two graphs in time and create no more than edges and obtain a new graph of size In total the resulting graph will have a size of and the final asymptotics will be where is the cost of the operation in the DSU The DSU is needed to pass queries in reverse order and connect the edges at the right times when the edges begin to exist The asymptotics is as follows since each vertex of the graph may go through all layers of recursion as you may have noticed the solution procedure resembles divide and conquer and at the same time create a new edge in each layer And the graph has such a size since each blocked segment in this procedure can be split into segments For a better understanding see the author s solution 
https://codeforces.com//contest/388/problem/C,6407,C,388C,388,C. Fox and Card Game,Fox Ciel is playing a card game with her friend Fox Jiro There are piles of cards on the table And there is a positive integer on each card The players take turns and Ciel takes the first turn In Ciel s turn she takes a card from the top of any non empty pile and in Jiro s turn he takes a card from the bottom of any non empty pile Each player wants to maximize the total sum of the cards he took The game ends when all piles become empty Suppose Ciel and Jiro play optimally what is the score of the game ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nint b[123456];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  vector <int> a;\n  int x = 0, y = 0;\n  while (n--) {\n    int foo;\n    scanf(""%d"", &foo);\n    for (int i = 0; i < foo; i++) {\n      scanf(""%d"", b + i);\n    }\n    for (int i = 0; i < foo / 2; i++) {\n      x += b[i];\n      y += b[foo - (foo / 2) + i];\n    }\n    if (foo % 2 == 1) {\n      a.push_back(b[foo / 2]);\n    }\n  }\n  sort(a.begin(), a.end());\n  reverse(a.begin(), a.end());\n  for (int i = 0; i < (int)a.size(); i++)\n    if (i % 2 == 0) x += a[i];\n    else y += a[i];\n  printf(""%d %d\\n"", x, y);\n  return 0;\n}\n']",,,"['games', 'greedy', 'sortings']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Fox and Card Game.json,https://codeforces.com//blog/entry/10629,First let s consider the case which all piles have even size In this case we can prove in the optimal play Ciel will gets all top most half cards of each pile and Jiro gets the remain cards We can prove by these facts Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome For Jiro this strategy is easy just pick the card from pile that Ciel have just picked For Ciel it s a little bit harder Why we can conclude they are both the optimal strategy Ciel just can t win more because if she played with Jiro with above strategy Jiro will get the bottom half of each pile Then we come back with cases that contain odd size piles The result is for odd size pile Ciel will get the top s 1 2 cards and Jiro will get the bottom s 1 2 cards Then what about the middle one Let s denote S is all such middle cards Then we define a reduced game In each turn they pick one card from S The optimal play for this game is easy Ciel gets the max one and Jiro gets the 2nd largest one and Ciel gets the 3rd largest one and so on We can prove Ciel have a strategy to get all top half parts cards she will get in the optimal play in the reduced game And Jiro also have a strategy to get all bottom half parts cards he will get in the optimal play in the reduced game And these strategy are optimal 
https://codeforces.com//contest/1221/problem/A,415607,A,1221A,1221,A. 2048 Game,You are playing a variation of game Initially you have a multiset s of n integers Every integer in this multiset is a power of two You may perform any number possibly zero operations with this multiset During each operation you choose two integers from s remove them from s and insert the number equal to their sum into s For example if s 1 2 1 1 4 2 2 and you choose integers 2 and 2 then the multiset becomes 1 1 1 4 4 2 You win if the number 2048 belongs to your multiset For example if s 1024 512 512 4 you can win as follows choose 512 and 512 your multiset turns into 1024 1024 4 Then choose 1024 and 1024 your multiset turns into 2048 4 and you win You have to determine if you can win this game You have to answer q independent queries ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nvoid solve() {\n    cin >> n;\n    vector < int > all;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        if (x > 2048) continue;\n        int y = 0;\n        while ((1 << y) < x) y++;\n        all.push_back(y);\n    }\n    sort(all.begin(), all.end());\n    reverse(all.begin(), all.end());\n    for (int i = 0; i < 11; i++) {\n        vector < int > nall;\n        int cnt = 0;\n        for (int j = 0; j < all.size(); j++) {\n            if (all[j] == i) cnt++;\n            else nall.push_back(all[j]);\n        }\n        for (int p = 0; p < cnt / 2; p++) nall.push_back(i + 1);\n        all = nall;\n    }\n    if (!all.empty()) cout << ""YES"" << \'\\n\';\n    else cout << ""NO"" << \'\\n\';\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    int q;\n    cin >> q;\n    while (q--) {\n        solve();\n    }\n    return 0;\n}']",,,"['brute force', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. 2048 Game.json,https://codeforces.com//blog/entry/69925,It s obvious that we don t need elements that are larger than If the sum of the remaining elements is greater than or equal to 2048 then the answer is and otherwise It s true because for getting a integer that wasn t in the multiset initially we first need to get integer 
https://codeforces.com//contest/1401/problem/B,704914,B,1401B,1401,B. Ternary Sequence,You are given two sequences a 1 a 2 dots a n and b 1 b 2 dots b n Each element of both sequences is either 0 1 or 2 The number of elements 0 1 2 in the sequence a is x 1 y 1 z 1 respectively and the number of elements 0 1 2 in the sequence b is x 2 y 2 z 2 respectively You can rearrange the elements in both sequences a and b however you like After that let s define a sequence c as follows c i begin cases a i b i mbox if a i b i 0 mbox if a i b i a i b i mbox if a i b i end cases You d like to make sum i 1 n c i the sum of all elements of the sequence c as large as possible What is the maximum possible sum ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tint c=min(z1, y2), ans=c;\n\t\tz1-=ans;\n\t\ty2-=ans;\n\t\tc=min(y1, x2);\n\t\ty1-=c;\n\t\tx2-=c;\n\t\tc=min(y1, y2);\n\t\ty1-=c;\n\t\ty2-=c;\n\t\tc=min(z2, x1);\n\t\tz2-=c;\n\t\tx1-=c;\n\t\tc=min(z2, z1);\n\t\tz2-=c;\n\t\tz1-=c;\n\t\tc=min(y1, z2);\n\t\tans-=c;\n\t\tcout << 2*ans << ""\\n"";\n\t}\n\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Ternary Sequence.json,https://codeforces.com//blog/entry/81700,We can find the kind of the value of is three And is only if is and is and is only if is and is Otherwise is So we have to make pair as little as possible and pair as much as possible To do this first we can make pair pair and pair as much as possible After that pairing the remaining values doesn t affect the sum of It in which value is and in which value is are all left we have to pair them although the sum decreases Time complexity 
https://codeforces.com//contest/919/problem/A,152087,A,919A,919,A. Supermarket,We often go to supermarkets to buy some fruits or vegetables and on the tag there prints the price for a kilo But in some supermarkets when asked how much the items are the clerk will say that a for b kilos You don t need to care about what is the same as a b for a kilo Now imagine you d like to buy m kilos of apples You ve asked n supermarkets and got the prices Find the minimum cost for those apples You can assume that there are enough apples in all supermarkets ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,a,b;\ndouble ans=1e20;\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a>>b;\n        ans=min(ans,(double)a/b);\n    }\n    printf(""%.8lf"",ans*m);\n    return 0;\n}']",,,"['brute force', 'greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Supermarket.json,https://codeforces.com//blog/entry/57462,We can use greedy algorithm Obviously if you can pay the least money for per kilo you can pay the least money for kilos So you can find the minimum of we say it is Then is the final answer 
https://codeforces.com//contest/507/problem/E,21018,E,507E,507,E. Breaking Good,Breaking Good is a new video game which a lot of gamers want to have There is a certain level in the game that is really difficult even for experienced gamers Walter William the main character of the game wants to join a gang called Los Hermanos The Brothers The gang controls the whole country which consists of cities with bidirectional roads connecting them There is no road is connecting a city to itself and for any two cities there is at most one road between them The country is connected in the other words it is possible to reach any city from any other city using the given roads The roads aren t all working There are some roads which need some more work to be performed to be completely functioning The gang is going to rob a bank The bank is located in city As usual the hardest part is to escape to their headquarters where the police can t get them The gang s headquarters is in city To gain the gang s trust Walter is in charge of this operation so he came up with a smart plan First of all the path which they are going to use on their way back from city to their headquarters must be since it is important to finish operation as fast as possible Then gang has to blow up all other roads in country that don t lay on this path in order to prevent any police reinforcements In case of non working road they don t have to blow up it as it is already malfunctional If the chosen path has some roads that doesn t work they ll have to repair those roads before the operation Walter discovered that there was a lot of paths that satisfied the condition of being shortest possible so he decided to choose among them a path that minimizes the total number of affected roads both roads that have to be blown up and roads to be repaired Can you help Walter complete his task and gain the gang s trust ,"['#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Node {\n    int u;\n    pair<int, int> dis;\n    bool operator < (const Node &b) const {\n        return dis > b.dis;\n    }\n};\n\npriority_queue<Node> q;\npair<int, int> dis[100010];\nint use[100010];\n\nint uu[100010], vv[100010], ww[100010], pre[100010], preId[100010];\n\nvector<pair<int, int> > g[100010];\n\n\nint main() {\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < m; i ++) {\n        int u, v, w;\n        scanf(""%d%d%d"", &u, &v, &w);\n        uu[i] = u;\n        vv[i] = v;\n        ww[i] = w;\n        g[u].push_back(make_pair(v, i));\n        g[v].push_back(make_pair(u, i));\n    }\n    memset(use, 0, sizeof(use));\n    Node st;\n    st.u = 1;\n    st.dis = make_pair(0, 0);\n    q.push(st);\n    dis[1] = st.dis;\n    use[1] = 1;\n    while (!q.empty()) {\n        Node s = q.top();\n        q.pop();\n        int u = s.u;\n        if (dis[u] != s.dis) {\n            continue;\n        }\n        for (auto x : g[u]) {\n            int v = x.first, id = x.second;\n            pair<int, int> ne = make_pair(dis[u].first + 1, dis[u].second + 1 - ww[id]);\n            if (!use[v] || dis[v] > ne) {\n                use[v] = 1;\n                dis[v] = ne;\n                pre[v] = u;\n                preId[v] = id;\n                Node now;\n                now.u = v;\n                now.dis = ne;\n                q.push(now);\n            }\n        }\n    }\n    memset(use, 0, sizeof(use));\n    int now = n;\n    while (now != 1) {\n        use[preId[now]] = 1;\n        now = pre[now];\n    }\n    int tot = 0;\n    for (int i = 0; i < m; i ++) {\n        if (!use[i] && ww[i] == 1) {\n            tot ++;\n        }\n        if (use[i] && ww[i] == 0) {\n            tot ++;\n        }\n    }\n    printf(""%d\\n"", tot);\n    for (int i = 0; i < m; i ++) {\n        if (!use[i] && ww[i] == 1) {\n            printf(""%d %d %d\\n"", uu[i], vv[i], 0);\n        }\n        if (use[i] && ww[i] == 0) {\n            printf(""%d %d %d\\n"", uu[i], vv[i], 1);\n        }\n    }\n    return 0;\n}']",,,"['dfs and similar', 'dp', 'graphs', 'shortest paths']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Breaking Good.json,https://codeforces.com/blog/entry/15975,Hint Consider we ve chosen a certain path with length where is the length of the shortest path from to and it has edges that are working Assume that is the total number of edges that are working in the whole country So we need to make changes to make the malfunctioning edges on the path work and changes to blow up all other edges that don t lie on the path So we will totally make changes where and are constants So the optimal solution will depend only on number of working edges along the path So we ll have to maximize this number Solution We will use dynamic programming on all nodes that lies on some shortest path In other words every node that satisfies that the shortest path from to the shortest path from to equals where is the length of the shortest path from to Let s define is the maximum number of working edges along some shortest path from to We can calculate the value for all nodes by dynamic programming by traversing the nodes in order of increasing shortest path from node So at the end we ll make changes We can get them easily by retrieving the chosen optimal path Time complexity Implementation 9529272 
https://codeforces.com//contest/961/problem/B,171413,B,961B,961,B. Lecture Sleep,Your friend Mishka and you attend a calculus lecture Lecture lasts minutes Lecturer tells theorems during the th minute Mishka is really interested in calculus though it is so hard to stay awake for all the time of lecture You are given an array of Mishka s behavior If Mishka is asleep during the th minute of the lecture then will be equal to otherwise it will be equal to When Mishka is awake he writes down all the theorems he is being told during the th minute Otherwise he writes nothing You know some secret technique to keep Mishka awake for minutes straight However you can use it You can start using it at the beginning of any minute between and If you use it on some minute then Mishka will be awake during minutes such that and will write down all the theorems lecturer tells You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique to wake him up ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in1[100050];\nint in2[100050];\nll sum1[100050];\nll sum2[100050];\nint main() {\n\tint N, K, i, j;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in1[i]);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in2[i]);\n\tfor (i = 1; i <= N; i++) {\n\t\tsum1[i] = sum1[i - 1] + in1[i] * in2[i];\n\t\tsum2[i] = sum2[i - 1] + in1[i];\n\t}\n\n\tll mx = 0;\n\tfor (i = 1; i <= N - K + 1; i++) {\n\t\tll v = sum1[i - 1] + (sum2[i + K - 1] - sum2[i - 1]) + (sum1[N] - sum1[i + K - 1]);\n\t\tmx = max(mx, v);\n\t}\n\treturn !printf(""%lld\\n"", mx);\n}']",,,"['data structures', 'dp', 'implementation', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Lecture Sleep.json,https://codeforces.com//blog/entry/58743,Let s iterate over all from to and if is equal to then add to the some variable and replace with Then answer will be equal to where can be easily calculated with prefix sums for each 
https://codeforces.com//contest/489/problem/C,17498,C,489C,489,C. Given Length and Sum of Digits...,You have a positive integer and a non negative integer Your task is to find the smallest and the largest of the numbers that have length and sum of digits The required numbers should be non negative integers written in the decimal base without leading zeroes ,"['#include<cstdio>\nusing namespace std;\nint arr[105];\nint main(){\n    int n, m;\n    scanf(""%d %d"", &n, &m);\n    if(n == 1 && m == 0)\n        puts(""0 0"");\n    else if(m == 0 || 9 * n < m)\n        puts(""-1 -1"");\n    else{\n        int tmp = m;\n        for(int i = 0 ; i < n ; i++){\n            if(tmp > 9) arr[i] = 9, tmp -= 9;\n            else arr[i] = tmp - 1 , tmp = 1;\n        }\n        arr[n-1]++;\n        for(int i = n-1 ; i >= 0 ; i--)\n            printf(""%d"", arr[i]);\n        putchar(\' \');\n        tmp = m;\n        int cnt = n;\n        while(cnt--){\n            if(tmp >= 9) printf(""9"");\n            else if(tmp > 0) printf(""%d"", tmp);\n            else putchar(\'0\');\n            tmp -= 9;\n        }\n        puts("""");\n    }\n    return 0;\n}\n']",,,"['dp', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Given Length and Sum of Digits....json,https://codeforces.com//blog/entry/14741,There is a greedy approach to solve the problem Just try first digit from lower values to higher in subtask to minimize number and check if it is possible to construct a tail in such a way that it satisfies rule about length sum You can use a function can m s that answers if it is possible to construct a sequence of length with the sum of digits Using the function can m s you can easily pick up answer digit by digit For the first part of problem to minimize number this part of code is The equation i 0 d 0 m 1 d 0 is needed to be careful with leading zeroes 
https://codeforces.com//contest/94/problem/C,494,C,94C,94,C. Frames,Throughout Igor K s life he has had many situations worthy of attention We remember the story with the virus the story of his mathematical career and of course his famous programming achievements However one does not always adopt new hobbies one can quit something as well This time Igor K got disappointed in one of his hobbies editing and voicing videos Moreover he got disappointed in it so much that he decided to destroy his secret archive for good Igor K use Pindows XR operation system which represents files and folders by small icons At that icons can fit in a horizontal row in any window Igor K s computer contains folders in the D disk s root catalog The folders are numbered from to in the order from the left to the right and from top to bottom see the images At that the folders with secret videos have numbers from to inclusive Igor K wants to delete them forever at that making as few frame selections as possible and then pressing Shift Delete exactly once What is the minimum number of times Igor K will have to select the folder in order to select folders from to and only them Let us note that if some selected folder is selected repeatedly then it is deselected Each selection possesses the shape of some rectangle with sides parallel to the screen s borders ,"['#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n//\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define MP make_pair\n#define VI vector<int>\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n//\n#define rep(i,b) for(int i=(0);i<(b);++i)\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define fore(a,b) for(__typeof((b).begin()) a = (b).begin();a!=(b).end();++a)\n#define vv vector\n#define pb push_back\n#define ll long long\n#define ld long double\n#define ss(a) (int)(a).size()\n#define all(x) (x).begin(),(x).end()\n#define clr(x,a) memset(x,a,sizeof(x))\n#define vi vv<int>\n#define vs vv<string>\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\n\nint cond = (ll)1;\n#define db(x) { if (cond > 0) { cond--; rep (xxx, 1) cerr << __LINE__ << "" "" << #x << "" "" << x << endl; cerr.flush(); } }\n\nvoid _main() {\n    int n, m, a, b;\n    scanf(""%d%d"", &n, &m);\n    scanf(""%d%d"", &a, &b);\n    a--; b--;\n    int r1 = a / m;\n    int c1 = a % m;\n\n    int r2 = b / m;\n    int c2 = b % m;\n    db(r1<<"" ""<<c1);\n    db(r2<<"" ""<<c2);\n    if (r1 == r2) cout << 1 << endl;\n    else {\n        if (r1 == r2 - 1) {\n            cout<< ((c1 != 0 || (c2 != m - 1 && b + 1 != n)) ? 2 : 1)<<endl;\n        }\n        else {\n            int cost = 1;\n            cost += c1 != 0;\n            cost += (c2 != m - 1) && b + 1 != n;\n            if (c2 +1 == c1) cost = min(cost, 2);\n            cout << cost << endl;\n        }\n    }\n}\n\nint main(int argc, char ** argv) {\n    string p = ""../gcj/source/"" + string("""") + argv[0][strlen(argv[0])-1];\n//    if (argc >= 2 && strcmp(argv[1], ""q"") != 0) { freopen(argv[1],""r"",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], ""1n"") == 0) { freopen(""1.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""2n"") == 0) { freopen(""2.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""3n"") == 0) { freopen(""3.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""4n"") == 0) { freopen(""4.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""5n"") == 0) { freopen(""5.in"",""r"",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], ""s0"") == 0) { freopen((p + ""-small-0.in"").c_str(),""r"",stdin);freopen((p + ""-small-0.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""s1"") == 0) { freopen((p + ""-small-1.in"").c_str(),""r"",stdin);freopen((p + ""-small-1.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""s2"") == 0) { freopen((p + ""-small-2.in"").c_str(),""r"",stdin);freopen((p + ""-small-2.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""l0"") == 0) { freopen((p + ""-large-0.in"").c_str(),""r"",stdin);freopen((p + ""-large-0.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""q"") == 0) cond = 1 << 30;\n    _main();\n    return 0;\n}\n\n']",,,['math'],1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Frames.json,https://codeforces.com//blog/entry/2208,So let s solve the problem At first notice that the answer is not greater than 3 because we always can do three selections maybe some of them are empty with first selection we select end of the first row with second one begin of the last row and with last one all remaining folders they form the rectangle The best way is to find all cases with answer 1 and 2 Try to do it If the answer is 1 we can select all folders from a to b with one selection There must be nothing hard to detect these cases first and last folders are in the same row 21 5 7 9 first folder is in the first column and the last folder in the last column 21 5 1 15 ase m 1 is included here first folder is in the first column and the last folder is n 21 5 6 21 Case when we must select all folders is included here I was very surprised when I saw that many contestants forgot about it And these are the cases with answer 2 first and last folders are in the adjacent rows 21 5 8 14 first folder is in the first column 21 5 6 13 last folder is in the last column 21 5 4 15 last folder is n 21 5 4 21 and another tricky case if the column where first folder is located is just at right from the column where the last column is located 21 5 3 12 If no one of these conditions is true answer is 3 
https://codeforces.com//contest/53/problem/C,279,C,53C,53,C. Little Frog,Once upon a time a little frog whose name was Vasya decided to travel around his home swamp Overall there are mounds on the swamp located on one line The distance between the neighboring mounds is one meter Vasya wants to visit all the mounds in one day besides he wants to visit each one exactly once For that he makes a route plan to decide the order in which to jump on the mounds Vasya can pick any mound as the first one He thinks it boring to jump two times at the same distance That s why he wants any two jumps on his route to have different lengths Help Vasya the Frog and make the plan for him ,"['#pragma comment(linker,""/stack:67108864"")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <sstream>\n#include <fstream>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <ctime>\n#include <numeric>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#include <bitset>\n#include <string>\n#include <list>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <typeinfo>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<int(n);++i)\n#define forn1(i,n) for(int i=1;i<=int(n);++i)\n#define ford(i,n) for(int i=int(n)-1;i>=0;--i)\n#define ford1(i,n) for(int i=int(n);i>0;--i)\n#define foran(i,l,r) for(int i=int(l);i<int(r);++i)\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define sqr(x) (x)*(x)\n#define all(v) (v).begin(),(v).end()\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair <ld ,ld > pt;\n\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932384626433832795;\n\nconst int INF=1000*1000*1000;\nconst int CF=1;\n\nint main()\n{\n    if(!CF) freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    int n;\n    cin >>n;\n    deque <int> d;\n    vector <int> v;\n    forn(i,n) \n    {\n        d.push_back(i+1);\n    }\n    while(d.size()>1)\n    {\n        v.push_back(d.front());\n        d.pop_front();\n        v.push_back(d.back());\n        d.pop_back();\n    }\n    if(!d.empty()) v.push_back(d.front());\n    forn(i,n) \n    {\n        cout <<v[i];\n        if(i<n-1) cout <<"" "";\n    }\n    cout <<endl;\n    return 0;\n}']",,,['constructive algorithms'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Little Frog.json,https://codeforces.com//blog/entry/1065,IMHO it s the second difficulty problem If you cannot see solution just after you saw the statement you can write brute force solution rundown all permutation and check run it for n 10 and see beautiful answer Answer is 1 n 2 n 1 3 n 2 4 n 3 Let s define two pointers l and r In the beginning the first one will point to 1 and the second one to n On odd positions write down l and increase it on even r and decrease it Do it while l r Proof is rather easy every jump is shorter than the previous one 
https://codeforces.com//contest/630/problem/Q,48802,Q,630Q,630,Q. Pyramids,IT City administration has no rest because of the fame of the Pyramids in Egypt There is a project of construction of pyramid complex near the city in the place called Emerald Walley The distinction of the complex is that its pyramids will be not only quadrangular as in Egypt but also triangular and pentagonal Of course the amount of the city budget funds for the construction depends on the pyramids volume Your task is to calculate the volume of the pilot project consisting of three pyramids one triangular one quadrangular and one pentagonal The first pyramid has equilateral triangle as its base and all 6 edges of the pyramid have equal length The second pyramid has a square as its base and all 8 edges of the pyramid have equal length The third pyramid has a regular pentagon as its base and all 10 edges of the pyramid have equal length ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 18:55:42       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\nconst dbl PI = acos(-1);\n\n\ndbl get(dbl l, int n)\n{\n    dbl alp = 2 * PI / n;\n    dbl bet = PI / 2 - alp / 2;\n    dbl x = sin(bet) / sin(alp) * l;\n    dbl S = x * x * sin(alp) / 2;\n    dbl h = sqrt(l * l - x * x);\n    dbl V = S * n * h / 3;\n    return V;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    dbl l3, l4, l5;\n    cin >> l3 >> l4 >> l5;\n    dbl res = get(l3, 3) + get(l4, 4) + get(l5, 5);\n    printf(""%.10f\\n"", res);    \n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']",,,"['geometry', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\Q. Pyramids.json,https://codeforces.com//blog/entry/23604?locale=en,The volume of a pyramid can be calculated as where v is the volume s is the area of the base and h is the height from the base to the apex Let s calculate s and h The area of a regular polygon having n sides of length ln can be found the following way A pentagon On the figure above a regular polygon is shown O is the center of the polygon all sides are equal to ln OB is the altitude of AOC triangle As the polygon is a regular one OA OC AOC triangle is a isosceles one and then and AB BC also AOB and COB triangles are right angled ones Also because the polygon is a regular one and can be seen as a union of 2n triangles equal to AOB triangle then AOB triangle is right angled one so Also So and The area of AOB is equal to The area of the polygon is A triangle On the figure above a triangle formed by the pyramid apex H the center of the base O and some vertex of the base A is shown It is a right angled one As all edges of the pyramid are equal AH ln and from calculations above According to Pythagorean theorem OA2 OH2 AH2 So The volume of one piramid is And the final formula is 
https://codeforces.com//contest/1904/problem/F,2374326,F,1904F,1904,F. Beautiful Tree,Lunchbox has a tree of size n rooted at node 1 Each node is then assigned a value Lunchbox considers the tree to be beautiful if each value is distinct and ranges from 1 to n In addition a beautiful tree must also satisfy m requirements of 2 types The node with the smallest value on the path between nodes a and b must be located at c The node with the largest value on the path between nodes a and b must be located at c Now you must assign values to each node such that the resulting tree is beautiful If it is impossible to do so output 1 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e6 + 5;\nconst int M = 3e7 + 5;\nint n, m, op[N], A[N], B[N], C[N];\nvector<int> tr[N];\n\nint dep[N], fa[N], sz[N], son[N];\n\nvoid dfs1(int u, int pre) {\n\tdep[u] = dep[pre] + 1, fa[u] = pre, sz[u] = 1;\n\tfor (int v : tr[u]) {\n\t\tif (v == pre) continue;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t\tif (sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\n\nint st[N], ed[N], id[N], top[N], cnt;\n\nvoid dfs2(int u, int tp) {\n\tst[u] = ++cnt, id[cnt] = u, top[u] = tp;\n\tif (son[u]) dfs2(son[u], tp);\n\tfor (int v : tr[u])\n\t\tif (v != fa[u] && v != son[u])\n\t\t\tdfs2(v, v);\n\ted[u] = cnt;\n}\n\nstruct Edge {\n\tint to, next;\n} e[M];\n\nint head[N], deg[N], cnte;\n\ninline void addedge(int u, int v) {\n\te[++cnte] = Edge{v, head[u]}, head[u] = cnte;\n\t++deg[v];\n}\n\nint prf_in[N], prf_out[N], tot;\n\n#define ls(x) (x << 1)\n#define rs(x) (x << 1 | 1)\n\nint ver_in[N], ver_out[N];\n\nvoid build(int x = 1, int l = 1, int r = n) {\n\tif (l == r) {\n\t\tver_in[x] = ver_out[x] = id[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(x), l, mid);\n\tbuild(rs(x), mid + 1, r);\n\tver_in[x] = ++tot, ver_out[x] = ++tot;\n\taddedge(ver_in[x], ver_in[ls(x)]);\n\taddedge(ver_in[x], ver_in[rs(x)]);\n\taddedge(ver_out[ls(x)], ver_out[x]);\n\taddedge(ver_out[rs(x)], ver_out[x]);\n}\n\nvoid addin(int L, int R, int s, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(s, ver_in[x]);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addin(L, R, s, ls(x), l, mid);\n\tif (R > mid) addin(L, R, s, rs(x), mid + 1, r);\n}\n\nvoid addout(int L, int R, int t, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(ver_out[x], t);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addout(L, R, t, ls(x), l, mid);\n\tif (R > mid) addout(L, R, t, rs(x), mid + 1, r);\n}\n\nint q[N], ans[N];\n\ninline void toposort() {\n\tint l = 1, r = 0, res = 0;\n\tfor (int i = 1; i <= tot; ++i)\n\t\tif (!deg[i]) q[++r] = i;\n\twhile (l <= r) {\n\t\tint u = q[l++];\n\t\tif (u <= n) ans[u] = ++res;\n\t\tfor (int i = head[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\t--deg[v];\n\t\t\tif (!deg[v]) q[++r] = v;\n\t\t}\n\t}\n\tif (r < tot) {\n\t\tcout << ""-1\\n"";\n\t} else {\n\t\tfor (int i = 1; i <= n; ++i) cout << ans[i] << \' \';\n\t\tcout << \'\\n\';\n\t}\n}\n\ninline void treeaddanc(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\telse addedge(prf_out[x], v);\n\t\tx = fa[top[x]];\n\t}\n\tif (y == x) return;\n\tif (op == 1) addin(st[y] + 1, st[x], v);\n\telse addout(st[y] + 1, st[x], v);\n}\n\ninline void treeadd(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] >= dep[top[y]]) {\n\t\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\t\telse addedge(prf_out[x], v);\n\t\t\tx = fa[top[x]];\n\t\t} else {\n\t\t\tif (op == 1) addedge(v, prf_in[y]);\n\t\t\telse addedge(prf_out[y], v);\n\t\t\ty = fa[top[y]];\n\t\t}\n\t}\n\tif (dep[x] < dep[y]) {\n\t\tif (op == 1) addin(st[x], st[y], v);\n\t\telse addout(st[x], st[y], v);\n\t} else {\n\t\tif (op == 1) addin(st[y], st[x], v);\n\t\telse addout(st[y], st[x], v);\n\t}\n} \n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= m; ++i) cin >> op[i] >> A[i] >> B[i] >> C[i];\n\tdfs1(1, 0);\n\tdfs2(1, 1);\n\ttot = n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tprf_in[i] = ++tot;\n\t\tprf_out[i] = ++tot;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\taddedge(prf_in[i], i);\n\t\taddedge(i, prf_out[i]);\n\t\tif (i != top[i]) {\n\t\t\taddedge(prf_in[i], prf_in[fa[i]]);\n\t\t\taddedge(prf_out[fa[i]], prf_out[i]);\n\t\t}\n\t}\n\tbuild();\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (A[i] == B[i]) continue;\n\t\tif (A[i] != C[i]) {\n\t\t\tif (st[A[i]] >= st[C[i]] && ed[A[i]] <= ed[C[i]]) treeaddanc(A[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], A[i], op[i], C[i]);\n\t\t}\n\t\tif (B[i] != C[i]) {\n\t\t\tif (st[B[i]] >= st[C[i]] && ed[B[i]] <= ed[C[i]]) treeaddanc(B[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], B[i], op[i], C[i]);\n\t\t}\n\t}\n\ttoposort();\n\treturn 0;\n}\n']",,,"['data structures', 'dfs and similar', 'graphs', 'implementation', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Beautiful Tree.json,https://codeforces.com//blog/entry/123160,SolutionLets rewrite the condition that node must be smaller than node as a directed edge from to Then we can assign each node a value based on the topological sort of this new directed graph If this directed graph had a cycle it is clear that there is no way to order the nodes With this in mind we can try to construct a graph that would have these properties Once we have the graph we can topological sort to find the answer For now let s consider the problem if it only had type 1 requirements type 2 requirements can be done very similarly Thus the problem reduces to given a path and a node add a directed edge from the node to every node in that path To do this we can use binary lifting For each node create dummy nodes the th of which represents the minimum number from the path between node and the th parent of Now we can draw a directed edge from the the th dummy node of to the th dummy node of and the th dummy node of the th parent of Now to add an edge from any node to a vertical path of the tree we can repeatedly add an edge from that node to the largest node we can This will add edges per requirement The final complexity is time and 
https://codeforces.com//contest/789/problem/A,100712,A,789A,789,A. Anastasia and pebbles,Anastasia loves going for a walk in Central Uzhlyandian Park But she became uninterested in simple walking so she began to collect Uzhlyandian pebbles At first she decided to collect all the pebbles she could find in the park She has only She can put at most pebbles in each pocket at the same time There are different pebble types in the park and there are pebbles of the th type Anastasia is very responsible so she never mixes pebbles of different types in same pocket However she can put different kinds of pebbles in different pockets at the same time Unfortunately she can t spend all her time collecting pebbles so she can collect pebbles from the park only once a day Help her to find the minimum number of days needed to collect all the pebbles of Uzhlyandian Central Park taking into consideration that Anastasia can t place pebbles of different types in same pocket ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint n,k;\n\tscanf(""%d%d"",&n,&k);\n\tint cnt = 0;\n\twhile(n--)\n\t{\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tcnt += (x+k-1)/k;\n\t}\n\tprintf(""%d\\n"",(cnt+1)/2);\n\treturn 0;\n}']",,,"['implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Anastasia and pebbles.json,https://codeforces.com//blog/entry/51312,For every pebble type we can count the minimal number of pockets Anastasia need to collect all pebbles of this type That s easy to notice that this number equals So the answer for the problem is Solution complexity is 
https://codeforces.com//contest/91/problem/A,468,A,91A,91,A. Newspaper Headline,A newspaper is published in Walrusland Its heading is it consists of lowercase Latin letters Fangy the little walrus wants to buy several such newspapers cut out their headings glue them one to another in order to get one big string After that walrus erase several letters from this string in order to get a new word It is considered that when Fangy erases some letter there s no whitespace formed instead of the letter That is the string remains unbroken and it still only consists of lowercase Latin letters For example the heading is If we take two such headings and glue them one to the other one we get If we erase the letters on positions and we get a word Which least number of newspaper headings will Fangy need to glue them erase several letters and get word ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nstring s1, s2;\nchar buf[2000000];\nint next[10000][26];\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf (""%s"", buf);\n\ts1 = buf;\n\tscanf (""%s"", buf);\n\ts2 = buf;\n\tint n = s1.length();\n\tseta (next, 255);\n\tforn (j, 26) \n\t\tif (s1.find (\'a\' + j) != -1) {\n\t\t\tint p = 0;\n\t\t\tchar c = j + \'a\';\n\t\t\tforn (i, n) {\n\t\t\t\tif (i == p) \n\t\t\t\t\tp = (p + 1) % n;\n\t\t\t\twhile (s1[p] != c) \n\t\t\t\t\tp = (p + 1) % n;\n\t\t\t\tnext[i][j] = p;\n\t\t\t}\n\t\t}\n\tint res = 0;\n\tint p = n-1;\n\tforn (i, s2.length()) {\n\t\tchar c = s2[i] - \'a\';\n\t\tif (next[p][c] == -1) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (next[p][c] <= p)\n\t\t\tres ++;\n\t\tp = next[p][c];\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n']",,,"['greedy', 'strings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Newspaper Headline.json,https://codeforces.com//blog/entry/2182,In this problem letters from s1 should be taken greedily take the left letter from the right of the last used letter if there is no necessary letter from the right of the right used letter the the search should be started from the beginning of string s1 and the answer should be increased by one But the brute solution get TL and have complexity O Ans s1 This solution can be optimized using the following way For every position in s1 let s precalculate positions of the closest letters from the right of it from the alphabet It can be done by moving from the right to the left ins s1 and remembering the last position of every type of symbol This solution have complexity O s1 K s2 where K is a size of alphabet 
https://codeforces.com//contest/1348/problem/A,609088,A,1348A,1348,A. Phoenix and Balance,Phoenix has n coins with weights 2 1 2 2 dots 2 n He knows that n is even He wants to split the coins into two piles such that each pile has exactly frac n 2 coins and the difference of weights between the two piles is Formally let a denote the sum of weights in the first pile and b denote the sum of weights in the second pile Help Phoenix minimize a b the absolute value of a b ,"['#include <bits/stdc++.h>\nusing namespace std;\nint t,n;\nint main () {\n\tscanf(""%d"",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(""%d"",&n);\n\t\tlong long ans1=0,ans2=0;\n\t\tfor (int i=1;i<=n-1;i++) {\n\t\t\tif (i<=n/2-1) {ans1+=(1ll<<i);}\n\t\t\telse {ans2+=(1ll<<i);}\n\t\t}\n\t\tans1+=(1ll<<n);\n\t\tprintf(""%lld\\n"",ans1-ans2);\n\t}\n\treturn 0;\n}\n']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Phoenix and Balance.json,https://codeforces.com//blog/entry/76555,We observe that the coin with the weight is greater than the sum of all the other weights combined This is true because Therefore the pile that has the heaviest coin will always weigh more To minimize the weight differences we put the lightest coins into the pile with the heaviest coin The answer will be Time complexity for each test case You can also solve the problem in by simplifying the mathematical expression 
https://codeforces.com//contest/376/problem/B,4241,B,376B,376,B. I.O.U.,Imagine that there is a group of three friends A B and A owes B 20 rubles and B owes C 20 rubles The total sum of the debts is 40 rubles You can see that the debts are not organized in a very optimal manner Let s rearrange them like that assume that A owes C 20 rubles and B doesn t owe anything to anybody The debts still mean the same but the total sum of the debts now equals 20 rubles This task is a generalisation of a described example Imagine that your group of friends has people and you know the debts between the people Optimize the given debts without changing their meaning In other words finally for each friend the difference between the total money he should give and the total money he should take must be the same Print the minimum sum of all debts in the optimal rearrangement of the debts See the notes to the test samples to better understand the problem ,"['#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint a[1000];\n\nint main() {\n    int n, m, x, y, c;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        cin >> x >> y >> c;\n        a[x] += c;\n        a[y] -= c;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        ans += abs(a[i]);\n    }\n    cout << ans / 2 << endl;\n    return 0;\n}\n']",,,['implementation'],1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. I.O.U..json,https://codeforces.com//blog/entry/10084,Let f i j how many money i owes j It can be proved we only need to loop n times Loop n times do Answer will be sum f i j O m n Let owe i 0 for all i Suppose there is an agnecy to help people with debts If you owe someone you give money to the agency If someone owes you you get money from the agency For each ai bi ci Ansewr will be sum owe i owe i 0 
https://codeforces.com//contest/1750/problem/F,1626962,F,1750F,1750,F. Majority,Everyone was happy coding until suddenly a power shortage happened and the best competitive programming site went down Fortunately a system administrator bought some new equipment recently including some UPSs Thus there are some servers that are still online but we need all of them to be working in order to keep the round rated Imagine the servers being a binary string s of length n If the i th server is online then s i 1 and s i 0 otherwise A system administrator can do the following operation called that consists of the following phases Select two servers at positions 1 le i j le n such that both are online i e s i s j 1 The spread starts only from online servers Check if we have enough power to make the spread We consider having enough power if the number of turned on servers in range i j is at least the number of turned off servers in range i j More formally check whether 2 cdot s i s i 1 ldots s j ge j i 1 If the check is positive turn on all the offline servers in range i j More formally make s k 1 for all k from i to j We call a binary string s of length n if we can turn on all servers i e make s i 1 for 1 le i le n using the electricity spread operation any number of times possibly 0 Your task is to find the number of rated strings of length n modulo m ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n/**\n * Description: Barrett reduction computes $a \\% b$ about 4 times faster than\n * usual where $b>1$ is constant but not known at compile time. Division by $b$\n * is replaced by multiplication by $m$ and shifting right 64 bits. Source:\n * KACTL\n * https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h\n * https://en.wikipedia.org/wiki/Barrett_reduction\n * Verification: http://www.usaco.org/index.php?page=viewproblem2&cpid=1045\n */\n\nusing ul = uint64_t;\nusing L = __uint128_t;\nstruct FastMod {\n\tul b, m;\n\tFastMod(ul b) : b(b), m(-1ULL / b) {}\n\tul reduce(ul a) {\n\t\tul q = (ul)((__uint128_t(m) * a) >> 64), r = a - q * b;\n\t\treturn r - (r >= b) * b;\n\t}\n};\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal)\n * https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp\n * Verification:\n * https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int id> struct mint {\n\tstatic FastMod MF;\n\tstatic int mod() { return (int)MF.b; }\n\tstatic void set_mod(int m) {\n\t\tassert(1 <= m);\n\t\tMF = FastMod(m);\n\t}\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) {\n\t\tv = int((-mod() < _v && _v < mod()) ? _v : _v % mod());\n\t\tif (v < 0) v += mod();\n\t}\n\tfriend bool operator==(const mint &a, const mint &b) { return a.v == b.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend void re(mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = mint(x);\n\t}\n\tfriend str ts(mint a) { return ts(a.v); }\n\n\tmint &operator+=(const mint &m) {\n\t\tif ((v += m.v) >= mod()) v -= mod();\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &m) {\n\t\tif ((v -= m.v) < 0) v += mod();\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &m) {\n\t\tv = (int)MF.reduce((ll)v * m.v);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, mod() - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\ntemplate <int id> FastMod mint<id>::MF = FastMod(1);\n\ntypedef mint<0> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi, mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, vmi(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tints(N, M);\n\tmi::set_mod(M);\n\tvmi rated(N + 1), unrated(N + 1);\n\t// unrated.at(0) = 1;\n\tFOR(i, 1, N + 1) {\n\t\trated.at(i) = pow(mi(2), i);\n\t\tunrated.at(i) = unrated.at(i - 1);\n\t\t// first\n\t\tFOR(x, 1, i) if (2 * x + 1 <= i) { unrated.at(i) += rated.at(x); }\n\t\t// continue\n\t\tFOR(x, 1, i) if (3 * x + 1 <= i) {\n\t\t\tunrated.at(i) += rated.at(x) * unrated.at(i - (3 * x + 1));\n\t\t}\n\t\trated.at(i) -= 1; // none\n\t\tFOR(x, 1, i) { rated.at(i) -= rated.at(x) * (i - x + 1); }\n\t\tmi cum = 0;\n\t\tint cur = -1;\n\t\t// more than one\n\t\tROF(x, 1, i) {\n\t\t\twhile (cur + 1 <= i - 2 * x) cum += unrated.at(++cur);\n\t\t\trated.at(i) -= rated.at(x) * cum;\n\t\t\t// F0R(j, i - 2 * x + 1) {\n\t\t\t// \trated.at(i) -= unrated.at(j) * rated.at(x);\n\t\t\t// }\n\t\t}\n\t\t// dbg(i, rated.at(i));\n\t}\n\tps(rated.at(N));\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']",,,"['combinatorics', 'dp', 'math', 'strings']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Majority.json,https://codeforces.com//blog/entry/108504,SolutionFirst off let s try to reduce the given operation to a simpler form We claim that if it is possible to make the string using the specified operation we can make it by doing the following new operation Select two indices such that the substring looks like this and make it all one The proof is just to show that if we can perform operation then it must exist some substring of respecting the propriety of the new operation Let be the number of binary strings of length that in the final form after no more operations can be made begin with a prefix full of ones of length For transitions we have to iterate through the length of the next sequence and the length of the fixable prefix right after it such that we cannot perform an operation to make a bigger prefix because that would break the definition but there is one problem we cannot compute using any recurrence relation Fortunately we can compute it by subtracting the ways we get roadblocks because by definition can be turned into which doesn t have any roadblocks at all This is if implemented naively but one can optimize it to by keeping prefix sums over prefix sums 
https://codeforces.com//contest/2049/problem/B,3095886,B,2049B,2049,B. pspspsps,Given a string s s 1s 2 ldots s n of length n consisting of characters and dot determine whether a permutation text p of length n exists such that for all integers i 1 le i le n If s i is then p 1 p 2 ldots p i forms a permutation of length i If s i is then p i p i 1 ldots p n forms a permutation of length n i 1 If s i is then there is no additional restriction text A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>#define ent \'\\n\'#define int long long\xa0typedef long long ll;using namespace std;\xa0const int mod = 998\'244\'353;const int maxn = 5e3 + 12;\xa0int p[maxn];int n, m, k;\xa0void solve() {    string s;    cin >> n >> s;    int ans = 1;    for(int i = 0; i < n; i++) {        for(int j = i + 1; j < n; j++) {            if(s[i] == \'s\' && s[j] == \'p\') {                ans &= (min(n - i, j + 1) <= j - i + 1);            }            if(s[i] == \'p\' && s[j] == \'s\') ans = 0;        }    }    if(ans) {        cout << ""YES\\n"";    }    else {        cout << ""NO\\n"";    }}\xa0int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int t = 1;\xa0    cin >> t;    while(t--){        solve();    }}']",,,"['brute force', 'constructive algorithms', 'graph matchings', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. pspspsps.json,https://codeforces.com//blog/entry/137273,Since the entire must be a permutation if s we can set and if p we can set After that the answer is YES if and only if all non dot characters in are all p or s If all non dot characters are p we can choose the permutation If all non dot characters are s we can choose Otherwise there exists both a p and a s Suppose for contradiction that there is a solution Let and represent the subarrays represented by the p and s respectively Without loss of generality suppose is the shorter subarray Solution 
https://codeforces.com//contest/581/problem/F,36595,F,581F,581,F. Zublicanes and Mumocrates,It s election time in Berland The favorites are of course parties of zublicanes and mumocrates The election campaigns of both parties include numerous demonstrations on main squares of the capital of Berland Each of the squares certainly can have demonstrations of only one party otherwise it could lead to riots On the other hand both parties have applied to host a huge number of demonstrations so that on all squares demonstrations must be held Now the capital management will distribute the area between the two parties Some pairs of squares are connected by bidirectional roads such that between any pair of squares there is a unique way to get from one square to another Some squares are on the outskirts of the capital meaning that they are connected by a road with only one other square such squares are called squares The mayor of the capital instructed to distribute all the squares between the parties so that the squares had the same number of demonstrations of the first and the second party It is guaranteed that the number of dead end squares of the city is even To prevent possible conflicts between the zublicanes and the mumocrates it was decided to minimize the number of roads connecting the squares with the distinct parties You as a developer of the department of distributing squares should determine this smallest number ,"[""#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint dp[5010][5010][2];\nstruct Bian\n{\n    int s,t,last;\n}bian[10010];\nint last[5010],maxbian=0,d[10010],v[10010],sz[10010];\nvoid addbian(int s,int t)\n{\n    maxbian++;\n    bian[maxbian].s=s;\n    bian[maxbian].t=t;\n    bian[maxbian].last=last[s];\n    last[s]=maxbian;\n    d[s]++;\n    d[t]++;\n}\nvoid dfs(int i)\n{\n    v[i]=1;\n    int f=0;\n    for(int j=0;j<=5000;j++)\n        dp[i][j][1]=dp[i][j][0]=inf;\n    for(int j=last[i];j;j=bian[j].last)\n        if(!v[bian[j].t])\n        {\n            f++;\n            if(f==1)\n            dp[i][0][0]=dp[i][0][1]=0;\n            dfs(bian[j].t);\n            for(int k=sz[i];k>=0;k--)\n                for(int l=sz[bian[j].t];l>=0;l--)\n                    if(k==sz[i]||l==0)\n                    {\n                        dp[i][k+l][0]=min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]);\n                        dp[i][k+l][1]=min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]);\n                    }\n                    else\n                    {\n                        dp[i][k+l][0]=min(dp[i][k+l][0],min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]));\n                        dp[i][k+l][1]=min(dp[i][k+l][1],min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]));\n                    }   \n            sz[i]+=sz[bian[j].t];\n        }\n    if(f==0)\n    {\n        dp[i][1][1]=dp[i][0][0]=0;\n        sz[i]=1;\n    }\n//  for(int j=0;j<=sz[i];j++)\n    //  for(int k=0;k<=1;k++)\n        //  cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n}\nint main()\n{\n    int n,n1,t1,t2;\n    cin>>n;\n    if(n==2)\n    {\n        cout<<1;\n        return 0;\n    }\n    for(n1=1;n1<n;n1++)\n    {\n        cin>>t1>>t2;\n        addbian(t1,t2);\n        addbian(t2,t1);\n    }\n    int f=0;\n    for(n1=1;n1<=n;n1++)\n    {\n        if(d[n1]==2)\n            f++;\n    }\n    for(n1=1;n1<=n;n1++)\n        if(d[n1]>2)\n        {\n            dfs(n1);\n            cout<<min(dp[n1][f/2][0],dp[n1][f/2][1]);\n            return 0;\n        }\n}\n""]",,,"['dp', 'trees', 'two pointers']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Zublicanes and Mumocrates.json,https://codeforces.com//blog/entry/20508,Let the number of leavs in tree vertices with degree 1 is equal to c It said in statement that c is even If in given graph only 2 vertices the answer is equal to 1 Else we have vertex in graph which do not a leaf we hang the three on this vertex Now we need to count 2 dynamics The first z1 v cnt col the least amount of colored edges in the subtree rooted at the vertex v if vertex v already painted in color col col equals to 0 or to 1 and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0 If we are in the leaf it is easy to count this value If we are not in the leaf we count value with help of dynamic z1 v cnt col z2 s cnt col where s the first child int the adjacency list of vertex v We need the second dynamic z2 s cnt col to spread cnt leaves with color 0 among subtrees of childs of vertex v To calc z2 s cnt col we brute the color of child s ncol and the number of childs i with color 0 which will be locate in subtree of vertex s and calc the value in the following way z2 s cnt col min z2 s cnt col z2 ns cnt a col z1 s a ncol ncol col where ns the next child of vertex v after the child s Note that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree sizes because in that case it will not be enough leaves for painting The upper bound of asymptotic for such dynamics O n3 We show that in fact it works with asymptotic O n2 Let s count the number of updates Note that every pair of vertices x y appears in the last sum x y exactly once when v lca x y So we have no more than O n2 updates 
https://codeforces.com//contest/1809/problem/G,1839367,G,1809G,1809,G. Prediction,Consider a tournament with n participants The rating of the i th participant is a i The tournament will be organized as follows First of all organizers will assign each participant an index from 1 to n All indices will be unique Let p i be the participant who gets the index i Then n 1 games will be held In the first game participants p 1 and p 2 will play In the second game the winner of the first game will play against p 3 In the third game the winner of the second game will play against p 4 and so on in the last game the winner of the n 2 th game will play against p n Monocarp wants to predict the results of all n 1 games of course he will do the prediction only after the indices of the participants are assigned He knows for sure that when two participants with ratings x and y play and x y k the participant with the higher rating wins But if x y le k any of the two participants may win Among all n ways to assign the indices to participants calculate the number of ways to do this so that Monocarp can predict the results of n 1 games Since the answer can be large print it modulo 998244353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = 1;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 1;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> p(n);\n    for (int i = 0, j = 0; i < n; i++) {\n        while (a[i] - a[j] > k) {\n            j++;\n        }\n        p[i] = j;\n    }\n    \n    std::vector<Z> dp(n);\n    std::vector<Z> sum(n + 1);\n    for (int i = 0; i < n; i++) {\n        Z val = 0;\n        val += comb.fac(n - 1) * comb.invfac(n - p[i] - 1);\n        val += sum[p[i]] * comb.invfac(n - p[i] - 1);\n        if (p[i] < i) {\n            if (i == n - 1) {\n                val = 0;\n            } else {\n                val *= comb.fac(n - p[i] - 2) * comb.invfac(n - i - 2);\n            }\n        }\n        \n        dp[i] = val;\n        if (i < n - 1) {\n            sum[i + 1] = sum[i] + dp[i] * comb.fac(n - i - 2);\n        }\n    }\n    \n    std::cout << dp[n - 1] << ""\\n"";\n    \n    return 0;\n}']",,,"['combinatorics', 'dp', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Prediction.json,https://codeforces.com//blog/entry/114300,We need some sort of better criterion other than all matches can be predicted first Suppose the ratings of the participants are in the order of their indices Then if all games are predictable the th game should be won by the participant with the rating equal to and in the th game they will play against the participant with rating So in order for each game to be predictable This is the criterion we will use So we will try to count the number of orderings meeting this condition One very important observation we need to make is that if we remove several participants with the lowest ratings from the ordering that ordering still satisfies the condition for each element either the prefix before it is removed completely or the maximum on it is unchanged So this allows us to construct the correct ordering by placing the sportsmen from the maximum rating to the minimum rating and making sure that on every step the order stays correct Okay Let s reverse the ratings array and try to write the following dynamic programming is the number of correct orderings of the first sportsmen the highest rated sportsmen since we reversed the ratings array Let s try to place the next sportsman We run into the following issue for some orderings of the first sportsmen it is possible to place the next one anywhere these orderings are where the first sportsman in the ordering doesn t conflict with the sportsman we are trying to place but for other orderings some positions might be forbidden And to keep track of which positions are forbidden and for which sportsmen we probably need some additional states for the dynamic programming which we don t really want to since states is probably the most we can allow Okay so let s avoid this issue entirely We don t like the orderings where the next sportsman can t be placed anywhere so let s find a way to ignore them discard the previous definition of Now let is the number of correct orderings of the highest rated sportsmen when we place the next sportsman in case it becomes the first element and conflicts with some of the elements we haven t placed yet So this leads to the following transitions in the dynamic programming if we place the th sportsman on any position other than the first one there are ways to do it and we transition from to otherwise if we place the th sportsman on the first position let be the last sportsman conflicting with the sportsman Let s try placing all sportsmen from to before placing the sportsman They cannot be placed on the first position otherwise they will conflict either with each other or with the sportsman so the first one can be placed in ways the second one in ways and so on this product can be easily calculated in by preparing factorials and inverse factorials So then we transition from to There is a special case in our dynamic programming It should start with but what if the st sportsman conflicts with someone Then the ordering of the first sportsmen is incorrect In this case the answer is since the st and the nd sportsmen are conflicting Overall complexity of this solution is or depending on your implementation 
https://codeforces.com//contest/1816/problem/B,1871423,B,1816B,1816,B. Grid Reconstruction,Consider a 2 times n grid where n is an integer You may place the integers 1 2 ldots 2n on the grid using each integer A is a sequence of cells achieved by starting at 1 1 then repeatedly walking either downwards or to the right and stopping when 2 n is reached The path should not extend beyond the grid The of a path is the alternating sum of the numbers written on the cells in a path That is let the numbers written on the cells be a 1 a 2 ldots a k in the order that it is visited the cost of the path is a 1 a 2 a 3 a 4 ldots sum i 1 k a i cdot 1 i 1 Construct a way to place the integers 1 2 ldots 2n on the grid such that the minimum cost over all paths from 1 1 to 2 n is maximized If there are multiple such grids that result in the maximum value output any of them ,"['//\n//  main.cpp\n//  B\n//\n//  Created by Thomas Guo on 2023-04-09.\n//\n\n#include <iostream>\n#define maxn 100002\nusing namespace std;\nint grid[maxn][2];\nint main(){\n    int t;cin>>t;\n    while(t--){\n        int n;cin>>n;\n        grid[0][0] = 2*n;\n        grid[n-1][1] = 2*n-1;\n        int lo = 1, hi = 2*n-2;\n        for(int i=0; i<n-1; i++){\n            if(i%2 == 0){\n                grid[i][1] = lo;\n                grid[i+1][0] = lo+1;\n                lo += 2;\n            }\n            else{\n                grid[i][1] = hi-1;\n                grid[i+1][0] = hi;\n                hi -= 2;\n            }\n        }\n        for(int i=0; i<2; i++){\n            for(int j=0; j<n; j++){\n                cout<<grid[j][i]<<"" "";\n            }\n            cout<<""\\n"";\n        }\n    }\n    return 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Grid Reconstruction.json,https://codeforces.com//blog/entry/114899,EditorialObserve that will be added if is even and will be subtracted otherwise This forms a checkered pattern Obviously it is optimal for all values that will be added to be strictly larger than all values that will be subtracted Also the difference between the value of adjacent grids should be almost equal by some definition of almost We construct array as follows and For and is even and For and is odd and For example when the output will be Insights on how to find the construction This is a very informal proof See Proof below for a formal proof First of all due to the checkered pattern should be filled with and should be filled with In particular and should be and Next as we are trying to maximise the minimum the difference between paths shouldn t be large since the minimum path will be smaller if the difference is larger Notice that a path consists of a prefix of and a suffix of and the difference between adjacent paths is Unable to parse markup type CF MATHJAX depending on the parity of It is optimal for the difference to be as small as possible which is Finally it is optimal that stays constant in the whole array If they are different the difference between paths not adjacent will be larger than which is suboptimal ProofConsider the cost of the top right path and bottom left path The cost of the top right path is The cost of the bottom right path is Summing both values we getwhich is equal toThis value attains maximum when and which is Therefore the upper bound for the maximum cost is We will now show that the construction above meets the upper bound Let be the cost of the path Observe that as the paths differ by exactly grids and from the above construction Calculating Therefore which achieves the upper bound 
https://codeforces.com//contest/71/problem/B,381,B,71B,71,B. Progress Bar,A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed Let s take a look at the following form of such a bar A bar is represented as squares located in line To add clarity let s number them with positive integers from to from the left to the right Each square has saturation for the th square which is measured by an integer from to When the bar for some is displayed squares has the saturation squares has the saturation and the saturation of the square can have any value from to So some first squares of the progress bar always have the saturation Some last squares always have the saturation And there is no more than one square that has the saturation different from and The degree of the process s completion is measured in percents Let the process be ,"['#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint out[110];\n\nmain(){\n\tint n, k, t, i;\n\t\n\tscanf ( ""%d %d %d"", &n, &k, &t );\n\tt = t * n * k;\n\tmemset ( out, 0, sizeof ( out ) );\n\tfor ( i = 0; i <= n * k; i ++ )\n\t\tif ( i * 100 <= t && t < i * 100 + 100 )\n\t\t\tbreak;\n\t\telse\n\t\t\tout[ i / k ] ++;\n\tfor ( i = 0; i < n; i ++ )\n\t\tprintf( ""%d "", out[i] );\n\tprintf( ""\\n"" );\n\t\n\treturn 0;\n}\n']",,,"['implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Progress Bar.json,https://codeforces.com//blog/entry/1624,At first compute It equals mnk 100 where x is rounding down Next we fill first z k squares with a saturation k z k 1 th square if it exists we fill in a saturation z z k k All other squares we leave with a saturation 0 
https://codeforces.com//contest/1703/problem/D,1459218,D,1703D,1703,D. Double Strings,You are given n strings s 1 s 2 dots s n of length at most mathbf 8 For each string s i determine if there exist two strings s j and s k such that s i s j s k That is s i is the concatenation of s j and s k Note that j be equal to k Recall that the concatenation of strings s and t is s t s 1 s 2 dots s p t 1 t 2 dots t q where p and q are the lengths of strings s and t respectively For example concatenation of and is ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""./debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""./input.txt""); ofstream cout(""output.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n    fstart;\n\n    int T; cin >> T;\n    while (T--) {\n        map<string, int> have;\n        int n; cin >> n;\n        vector<string> a(n);\n        for (auto& x : a) {\n            cin >> x;\n            have[x] = 1;\n        }\n\n        for (auto& s : a) {\n            char ok = false;\n            for (int i = 0; i < s.length(); i++) {\n                string before = s.substr(0, i + 1);\n                string after = s.substr(i + 1);\n                ok |= (have[before] && have[after]);\n            }\n            cout << (int)ok;\n        }\n        cout << ""\\n"";\n\n\n\n    }\n\n    finish;\n}\n']",,,"['brute force', 'data structures', 'strings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Double Strings.json,https://codeforces.com//blog/entry/104786,Use some data structure that allows you to answer queries of the form does the string appear in the array For example in C you can use a while in Python you can use a dictionary Afterwards for each string brute force all strings and such that There are at most such strings because has length at most Then check if both and appear in the array using your data structure The time complexity is per test case where is the maximum length of an input string 
https://codeforces.com//contest/461/problem/D,13283,D,461D,461,D. Appleman and Complicated Task,Toastman came up with a very complicated task He gives it to Appleman but Appleman doesn t know how to solve it Can you help him Given a checkerboard Each cell of the board has either character or character or nothing How many ways to fill all the empty cells with or each cell must contain only one character in the end are there such that for each cell the number of adjacent cells with will be even Find the number of ways modulo Two cells of the board are adjacent if they share a side ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <cassert>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\nconst int MOD = int(1e9) + 7;\n\nstruct Edge {\n\tint t, c;\n\tEdge(int t, int c) :\n\t\t\tt(t), c(c) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\nint n, k;\n\nvoid addEdge(int u, int v, int c) {\n\tE[u].push_back(Edge(v, c));\n\tE[v].push_back(Edge(u, c));\n}\n\nbool bad;\n//\t\tconstraint(r, 0, 0);\n//\t\tconstraint(r, n + 1, 0);\n//\t}\n//\tfor (int c = 0; c <= n + 1; ++c) {\n//\t\tconstraint(n + 1, c, 0);\n//\t}\nint col[MAX_N];\n\nvoid dfs(int u, int what) {\n\tif (bad)\n\t\treturn;\n\tif (col[u] != -1) {\n\t\tif (col[u] != what) {\n\t\t\tbad = true;\n\t\t}\n\t\treturn;\n\t}\n\tcol[u] = what;\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tdfs(e->t, what ^ e->c);\n\t}\n}\n\nvoid constraint(int r, int c, int v) {\n\tint d = min(r - 1, c - 1);\n\td = min(d, n - r);\n\td = min(d, n - c);\n\tint cc = abs(r - c) + d + 1;\n\tint L = cc - d, R = cc + d;\n\tL -= 2;\n\tif (L < 0)\n\t\tL = 0;\n\tif (R > n)\n\t\tR = n;\n\taddEdge(L, R, v);\n}\n\n//bitset<200> my[60][60];\n\nint main() {\n\n\t//50 50;\n//\tint N = 11;\n//\tfor (int i = 0; i < N; ++i) {\n//\t\tmy[0][i][i] = true;\n//\t}\n//\tfor (int r = 1; r < N; ++r) {\n//\t\tfor (int c = 0; c < N; ++c) {\n//\t\t\tif (r - 2 >= 0)\n//\t\t\t\tmy[r][c] ^= my[r - 2][c];\n//\t\t\tif (c - 1 >= 0)\n//\t\t\t\tmy[r][c] ^= my[r - 1][c - 1];\n//\t\t\tif (c + 1 < N)\n//\t\t\t\tmy[r][c] ^= my[r - 1][c + 1];\n//\t\t}\n//\t}\n//\n//\tfor (int r = 0; r < N; ++r) {\n//\t\tfor (int c = 0; c < N; ++c) {\n//\t\t\tint a = -1, b;\n//\t\t\tfor (int k = 0; k < N; ++k) {\n//\t\t\t\tif (my[r][c][k]) {\n//\t\t\t\t\tif (a == -1)\n//\t\t\t\t\t\ta = k;\n//\t\t\t\t\tb = k;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tprintf(""%02d,%02d "", a, b);\n////\t\t\tprintf(""%02d "", (b - a) / 2);\n//\t\t\tint d = r;\n//\t\t\td = min(d, c);\n//\t\t\td = min(d, N - 1 - c);\n//\t\t\td = min(d, N - 1 - r);\n//\t\t\tint cc = abs(r - c) + d;\n//\t\t\tassert(a == cc - d && b == cc + d);\n//\t\t}\n//\t\tputs("""");\n//\t}\n\n\tcin >> n >> k;\n\t//1...n\n\twhile (k--) {\n\t\tint r, c, v;\n\t\tscanf(""%d%d"", &r, &c);\n\t\tchar ch;\n\t\tscanf("" "");\n\t\tscanf(""%c"", &ch);\n\t\tif (ch == \'o\')\n\t\t\tv = 1;\n\t\telse\n\t\t\tv = 0;\n\t\tconstraint(r, c, v);\n\t}\n//\tfor (int r = 1; r <= n; ++r) {\n//\t\tconstraint(r, 0, 0);\n//\t\tconstraint(r, n + 1, 0);\n//\t}\n//\tfor (int c = 0; c <= n + 1; ++c) {\n//\t\tconstraint(n + 1, c, 0);\n//\t}\n\tmemset(col, -1, sizeof col);\n\tint cnt = 0;\n\tbad = false;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tif (bad)\n\t\t\tbreak;\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i, 0);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tif (bad) {\n\t\tputs(""0"");\n\t\treturn 0;\n\t}\n\tint ans = 1;\n\t--cnt;\n\twhile (cnt--)\n\t\tans = (ans + ans) % MOD;\n\tcout << ans << endl;\n}\n']",,,"['dsu', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Appleman and Complicated Task.json,https://codeforces.com/blog/entry/13568,First we ignore the already drawn cell and dependence of cells If we decide the first row then the entire board can decided uniquely We call o is 1 and x is 0 Then a i j a i 2 j xor a i 1 j 1 xor a i 1 j 1 For example I ll explain n 5 case Each column of first row is a b c d and e ac means a xor c Each character affects the following cells denoted o Generally we can prove the dependence that a 0 k affects a i j if k i j 2 n 1 k and i j k and k 
https://codeforces.com//contest/1254/problem/B1,475570,B1,1254B1,1254,B1. Send Boxes to Alice  Easy Version ,Christmas is coming and our protagonist Bob is preparing a spectacular present for his long time best friend Alice This year he decides to prepare n boxes of chocolate numbered from 1 to n Initially the i th box contains a i chocolate pieces Since Bob is a typical nice guy he will not send Alice n empty boxes In other words Since Alice dislikes coprime sets she will be happy only if there exists some integer k 1 such that the number of pieces in each box is divisible by k Note that Alice won t mind if there exists some empty boxes Charlie Alice s boyfriend also is Bob s second best friend so he decides to help Bob by rearranging the chocolate pieces In one second Charlie can pick up a piece in box i and put it into either box i 1 or box i 1 if such boxes exist Of course he wants to help his friend as quickly as possible Therefore he asks you to calculate the minimum number of seconds he would need to make Alice happy ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\n\nint n;\nll tab[nax];\n\nll s;\n\nvll pie;\n\nll wyn=inf;\n\nvoid check(ll v)\n{\n\tll ret=0;\n\ts=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ts+=tab[i];\n\t\ts%=v;\n\t\tret+=min(s, v-s);\n\t}\n\twyn=min(wyn, ret);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tif (s==1)\n\t{\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tfor (ll i=2; i*i<=s; i++)\n\t{\n\t\tif (!(s%i))\n\t\t{\n\t\t\tpie.push_back(i);\n\t\t\ts/=i;\n\t\t\ti--;\n\t\t}\n\t}\n\tpie.push_back(s);\n\tfor (ll i : pie)\n\t\tcheck(i);\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'math', 'number theory', 'ternary search', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B1. Send Boxes to Alice  Easy Version .json,https://codeforces.com//blog/entry/71594,Let s start by choosing vertices and as pivots Recall that if the cross product of two vectors and is positive point lies to the left of if the product is negative point lies to the right of and if the product is zero the 3 points are collinear With queries of type 2 we can know which vertices lie to the left or to the right of edge and then solve the two sides separately Consider the left side and there are vertices lie to the left we can use queries of type 1 to calculate the distance from those vertices to edge the distance from vertex to edge is twice the area of the triangle forms by divides by the length of edge Let Y be the farthest from there can be at most 2 such vertices We can use queries of type 2 to see if the others vertices lie between or between then sort them counter clockwise with the asked distances So we will use queries to calculate the distances from vertices to edge and at most for the latter step This solution uses at most queries Another solution is to find the vertex that is consecutive to in queries and do the same as the solution above 
https://codeforces.com//contest/516/problem/A,22477,A,516A,516,A. Drazil and Factorial,Drazil is playing a math game with Varda Let s define for positive integer as a product of factorials of its digits For example First they choose a decimal number consisting of digits that contains at least one digit larger than This number may possibly start with leading zeroes Then they should find maximum positive number satisfying following two conditions 1 doesn t contain neither digit nor digit 2 Help friends find such number ,"['#include <iostream>\nusing namespace std;\nint p[10];\nvoid go(int x, int sign)\n{\n\tfor (int i = 2; i < 10; i++)\n\t\twhile (x % i == 0)\n\t\t{\n\t\t\tx /= i;\n\t\t\tp[i] += sign;\n\t\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tint val = 1;\n\t\tint f = c - \'0\';\n\t\tfor (int j = 1; j <= f; j++)\n\t\t\tval *= j;\n\t\tgo(val, 1);\n\t}\n\tstring ans = """";\n\tfor (int i = 9; i >= 2; i--)\n\t\twhile (p[i] > 0)\n\t\t{\n\t\t\tans += char(i + \'0\');\n\t\t\tint val = 1;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tval *= j;\n\t\t\tgo(val, -1);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['dp', 'greedy', 'implementation', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Drazil and Factorial.json,https://codeforces.com/blog/entry/16468,Conclusion first First we transform each digit of the original number as follows 0 1 empty 2 2 3 3 4 322 5 5 6 53 7 7 8 7222 9 7332 Then sort all digits in decreasing order as a new number then it will be the answer Proof We can observe that our answer won t contain digits 4 6 8 9 because we can always transform digits 4 6 8 9 to more digits as in the conclusion and it makes the number larger Then how can we make sure that the result is the largest after this transformation We can prove the following lemma For any positive integer x if it can be written as the form 2 c2 3 c3 5 c5 7 c7 there will be only one unique way Suppose that there exists two ways to write down x in this form we can assume that the two ways are 2 a2 3 a3 5 a5 7 a7 and 2 b2 3 b3 5 b5 7 b7 We find the largest i such that ai bi Then we know there exists at least one prime number whose factor is different in the two ways But according to the Fundamental Theorem of Arithmetic there is only one prime factorization of each integer So we get a contradiction After getting the result we don t need to worry about other numbers being larger than ours 
https://codeforces.com//contest/687/problem/B,63911,B,687B,687,B. Remainders Game,Today Pari and Arya are playing a game called Remainders Pari chooses two positive integer and and tells Arya but not Arya have to find the value There are ancient numbers and Pari has to tell Arya if Arya wants Given and the ancient values tell us if Arya has a winning strategy independent of value of or not Formally is it true that Arya can understand the value for any positive integer Note that means the remainder of after dividing it by ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef pair<ll,ll> PLL;\nnamespace Factor {\n\tconst int N=1010000;\n\tll C,fac[10010],n,mut,a[1001000];\n\tint T,cnt,i,l,prime[N],p[N],psize,_cnt;\n\tll _e[100],_pr[100];\n\tvector<ll> d;\n\tinline ll mul(ll a,ll b,ll p) {\n\t\tif (p<=1000000000) return a*b%p;\n\t\telse if (p<=1000000000000ll) return (((a*(b>>20)%p)<<20)+(a*(b&((1<<20)-1))))%p;\n\t\telse {\n\t\t\tll d=(ll)floor(a*(long double)b/p+0.5);\n\t\t\tll ret=(a*b-d*p)%p;\n\t\t\tif (ret<0) ret+=p;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid prime_table(){\n\t\tint i,j,tot,t1;\n\t\tfor (i=1;i<=psize;i++) p[i]=i;\n\t\tfor (i=2,tot=0;i<=psize;i++){\n\t\t\tif (p[i]==i) prime[++tot]=i;\n\t\t\tfor (j=1;j<=tot && (t1=prime[j]*i)<=psize;j++){\n\t\t\t\tp[t1]=prime[j];\n\t\t\t\tif (i%prime[j]==0) break;\n\t\t\t}\n\t\t}\n\t}\n\tvoid init(int ps) {\n\t\tpsize=ps;\n\t\tprime_table();\n\t}\n\tll powl(ll a,ll n,ll p) {\n\t\tll ans=1;\n\t\tfor (;n;n>>=1) {\n\t\t\tif (n&1) ans=mul(ans,a,p);\n\t\t\ta=mul(a,a,p);\n\t\t}\n\t\treturn ans;\n\t}\n\tbool witness(ll a,ll n) {\n\t\tint t=0;\n\t\tll u=n-1;\n\t\tfor (;~u&1;u>>=1) t++;\n\t\tll x=powl(a,u,n),_x=0;\n\t\tfor (;t;t--) {\n\t\t\t_x=mul(x,x,n);\n\t\t\tif (_x==1 && x!=1 && x!=n-1) return 1;\n\t\t\tx=_x;\n\t\t}\n\t\treturn _x!=1;\n\t}\n\tbool miller(ll n) {\n\t\tif (n<2) return 0;\n\t\tif (n<=psize) return p[n]==n;\n\t\tif (~n&1) return 0;\n\t\tfor (int j=0;j<=7;j++) if (witness(rand()%(n-1)+1,n)) return 0;\n\t\treturn 1;\n\t}\n\tll gcd(ll a,ll b) {\n\t\tll ret=1;\n\t\twhile (a!=0) {\n\t\t\tif ((~a&1) && (~b&1)) ret<<=1,a>>=1,b>>=1;\n\t\t\telse if (~a&1) a>>=1; else if (~b&1) b>>=1;\n\t\t\telse {\n\t\t\t\tif (a<b) swap(a,b);\n\t\t\t\ta-=b;\n\t\t\t}\n\t\t}\n\t\treturn ret*b;\n\t}\n\tll rho(ll n) {\n\t\tfor (;;) {\n\t\t\tll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY;\n\t\t\tint tmp=20;\n\t\t\tC=rand()%10+3;\n\t\t\tX=mul(X,X,n)+C;*(lY++)=X;lX++;\n\t\t\tY=mul(X,X,n)+C;*(lY++)=Y;\n\t\t\tfor(;X!=Y;) {\n\t\t\t\tll t=X-Y+n;\n\t\t\t\tZ=mul(T,t,n);\n\t\t\t\tif(Z==0) return gcd(T,n);\n\t\t\t\ttmp--;\n\t\t\t\tif (tmp==0) {\n\t\t\t\t\ttmp=20;\n\t\t\t\t\tZ=gcd(Z,n);\n\t\t\t\t\tif (Z!=1 && Z!=n) return Z;\n\t\t\t\t}\n\t\t\t\tT=Z;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tX=*(lX++);\n\t\t\t}\n\t\t}\n\t}\n\tvoid _factor(ll n) {\n\t\tfor (int i=0;i<cnt;i++) {\n\t\t\tif (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];}\n\t\tif (n<=psize) {\n\t\t\tfor (;n!=1;n/=p[n]) fac[cnt++]=p[n];\n\t\t\treturn;\n\t\t}\n\t\tif (miller(n)) fac[cnt++]=n;\n\t\telse {\n\t\t\tll x=rho(n);\n\t\t\t_factor(x);_factor(n/x);\n\t\t}\n\t}\n\tvoid dfs(ll x,int dep) {\n\t\tif (dep==_cnt) d.pb(x);\n\t\telse {\n\t\t\tdfs(x,dep+1);\n\t\t\tfor (int i=1;i<=_e[dep];i++) dfs(x*=_pr[dep],dep+1);\n\t\t}\n\t}\n\tvoid norm() {\n\t\tsort(fac,fac+cnt);\n\t\t_cnt=0;\n\t\trep(i,0,cnt) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1;\n\t\t\telse _e[_cnt-1]++;\n\t}\n\tvector<ll> getd() {\n\t\td.clear();\n\t\tdfs(1,0);\n\t\treturn d;\n\t}\n\tvector<ll> factor(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\treturn getd();\n\t}\n\tvector<PLL> factorG(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\tvector<PLL> d;\n\t\trep(i,0,_cnt) d.pb(mp(_pr[i],_e[i]));\n\t\treturn d;\n\t}\n\tbool is_primitive(ll a,ll p) {\n\t\tassert(miller(p));\n\t\tvector<PLL> D=factorG(p-1);\n\t\trep(i,0,SZ(D)) if (powl(a,(p-1)/D[i].fi,p)==1) return 0;\n\t\treturn 1;\n\t}\n}\n\nint n,k,c;\nint val[10100000];\nint main() {\n\tFactor::init(1000000);\n\tscanf(""%d%d"",&n,&k);\n\trep(i,0,n) {\n\t\tscanf(""%d"",&c);\n\t\tvector<PLL> d=Factor::factorG(c);\n\t\tfor (auto p:d) val[p.fi]=max(val[p.fi],(int)p.se);\n\t}\n\tvector<PLL> d=Factor::factorG(k);\n\tfor (auto p:d) {\n\t\tif (val[p.fi]<p.se) {\n\t\t\tputs(""No""); return 0;\n\t\t}\n\t}\n\tputs(""Yes"");\n}\n']",,,"['chinese remainder theorem', 'math', 'number theory']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Remainders Game.json,https://codeforces.com//blog/entry/45770,Hint Assume the answer of a test is No There must exist a pair of integers x1 and x2 such that both of them have the same remainders after dividing by any ci but they differ in remainders after dividing by k Find more facts about x1 and x2 Solution Consider the x1 and x2 from the hint part We have x1 x2 0 for each 1 i n So We also have As a result We ve found a necessary condition And I have to tell you it s also sufficient Assume we are going to prove there exists x1 x2 such that x1 x2 0 for each 1 i n and A possible solution is x1 lcm c1 c2 cn and x2 2 lcm c1 c2 cn so the sufficiency is also proved So you have to check if lcm c1 c2 cn is divisible by k which could be done using prime factorization of k and ci values For each integer x smaller than MAXC find it s greatest prime divisor gpdx using sieve of Eratosthenes in Then using gpd array you can write the value of each coin as p1q1p2q2 pmqm where pi is a prime integer and 1 qi holds This could be done in by moving from ci to and adding gpdci to the answer And you can factorize k by the same way Now for every prime p that see if there exists any coin i that the power of p in the factorization of ci is not smaller than the power of p in the factorization of k 
https://codeforces.com//contest/330/problem/A,3349,A,330A,330,A. Cakeminator,You are given a rectangular cake represented as an grid Each cell either has an evil strawberry or is empty For example a cake may look as follows The cakeminator is going to eat the cake Each time he eats he chooses a row or a column that does not contain any evil strawberries and contains at least one cake cell that has not been eaten before and eats all the cake cells there He may decide to eat any number of times Please output the maximum number of cake cells that the cakeminator can eat ,"['#include <stdio.h>\n#include <memory.h>\n#define clr(u) memset(u,0,sizeof(u))\n\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n\tint i,j,k;\n\tint ni,nj;\n\tchar s[15][15];\n\tscanf(""%d%d\\n"",&ni,&nj);\n\n\tfor(i=0;i<ni;i++)scanf(""%s"", s[i]);\n\n\tbool vis[15][15];\n\tclr(vis);\n\n\tint ans=0;\n\n\tfor(i=0;i<ni;i++){\n\t\tfor(j=0;j<nj;j++)if(s[i][j]==\'S\')break;\n\t\tif(j==nj){\n\t\t\tfor(j=0;j<nj;j++){\n\t\t\t\tif(!vis[i][j])ans++;\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(j=0;j<nj;j++){\n\t\tfor(i=0;i<ni;i++)if(s[i][j]==\'S\')break;\n\t\tif(i==ni){\n\t\t\tfor(i=0;i<ni;i++){\n\t\t\t\tif(!vis[i][j])ans++;\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Cakeminator.json,https://codeforces.com//blog/entry/8417,Long solution Short solution If there are r rows that cannot be eaten and c columns that cannot be eaten then there are r c cells that cannot be eaten a cell such that both its row and columns cannot be eaten Since all other cells can be eaten answer is R C r c 
https://codeforces.com//contest/235/problem/A,1999,A,235A,235,A. LCM Challenge,Some days ago I learned the concept of LCM least common multiple I ve played with it for several times and I want to make a big number with it But I also don t want to use many numbers so I ll choose three positive integers they don t have to be distinct which are not greater than Can you help me to find the maximum possible least common multiple of these three integers ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nll gcd(ll x, ll y){\n    return x ? gcd(y%x,x) : y;\n}\n\nint main(void){\n    ll N;\n    cin >> N;\n    \n    ll x,y,z;\n    ll ans = 0;\n    \n    for(x=N;x*x*x>ans;x--) for(y=x;x*y*y>ans;y--) for(z=y;x*y*z>ans;z--){\n        if(gcd(x,y) == 1 && gcd(x,z) == 1 && gcd(y,z) == 1) ans = x*y*z;\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']",,,['number theory'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. LCM Challenge.json,https://codeforces.com//blog/entry/5592,It is a simple problem but many competitors used some wrong guesses and failed First of all we should check if n is at most 3 and then we can simply output 1 2 6 Now there are two cases When n is odd the answer is obviously n n 1 n 2 When n is even we can still get at least n 1 n 2 n 3 so these three numbers in the optimal answer would not be very small compared to n So we can just iterate every 3 number triple in n 50 n and update the answer 
https://codeforces.com//contest/1073/problem/G,243302,G,1073G,1073,G. Yet Another LCP Problem,Let text LCP s t be the length of the longest common prefix of strings s and t Also let s x dots y be the substring of s from index x to index y inclusive For example if s then s 1 dots 3 s 2 dots 5 You are given a string s of length n and q queries Each query is a pair of integer sets a 1 a 2 dots a k and b 1 b 2 dots b l Calculate sum limits i 1 i k sum limits j 1 j l text LCP s a i dots n s b j dots n for each query ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <string>\n\nusing namespace std;\n\nstruct SuffixDataStructure {\n  const std::vector<int> &a;\n  std::vector<int> sa;\n  std::vector<int> isa;\n  std::vector<int> lcp;\n  std::vector<int> lg;\n  std::vector<std::vector<int>> rmq;\n\n  // a[i]>=0\n  SuffixDataStructure(const std::vector<int> &a) : a(a) {\n    sa = suffix_array(a);\n    sa.insert(sa.begin(), a.size());\n    build_lcp();\n    build_rmq();\n  }\n\n  int get_lcp(int i, int j) {\n    if (i == j) {\n      return a.size() - std::max(i, j);\n    }\n    i = isa[i];\n    j = isa[j];\n    if (i > j) {\n      std::swap(i, j);\n    }\n    int k = __lg(j - i);\n    return std::min(rmq[k][i], rmq[k][j - (1 << k)]);\n  }\n\n  vector<int> suffix_array(vector<int> a) {\n    const int n = a.size();\n    if (n == 0) return {};\n    const int H = *max_element(begin(a), end(a)) + 1;\n    vector<bool> s(n);\n    vector<int> next(n), ss;\n    for (int i = n - 2; i >= 0; i--) {\n      s[i] = a[i] == a[i + 1] ? s[i + 1] : a[i] < a[i + 1];\n      if (!s[i] && s[i + 1]) ss.push_back(i + 1);\n    }\n    reverse(ss.begin(), ss.end());\n    for (int i = 0; i < ss.size(); i++) {\n      next[ss[i]] = i + 1 < ss.size() ? ss[i + 1] : n;\n    }\n    auto induced_sort = [&]() {\n      vector<int> sa(n, -1), L(H + 1);\n      for (int i = 0; i < n; i++) L[a[i] + 1]++;\n      for (int i = 0; i < H; i++) L[i + 1] += L[i];\n      auto S = L;\n      for (int i = (int)ss.size() - 1; i >= 0; i--) {\n        int j = ss[i];\n        sa[--S[a[j] + 1]] = j;\n      }\n      S = L;\n      sa[L[a[n - 1]]++] = n - 1;\n      for (int i = 0; i < n; i++) {\n        int j = sa[i] - 1;\n        if (j >= 0 && !s[j]) sa[L[a[j]]++] = j;\n      }\n      for (int i = n - 1; i >= 0; i--) {\n        int j = sa[i] - 1;\n        if (j >= 0 && s[j]) sa[--S[a[j] + 1]] = j;\n      }\n      return sa;\n    };\n    vector<int> rank(n);\n    int j = -1;\n    for (int i : induced_sort()) {\n      if (0 < i && s[i] && !s[i - 1]) {\n        if (j != -1) rank[i] = rank[j] + (next[i] - i != next[j] - j || !equal(a.begin() + i, a.begin() + next[i], a.begin() + j));\n        j = i;\n      }\n    }\n    vector<int> b;\n    for (int i : ss) b.push_back(rank[i]);\n    vector<int> tmp(ss);\n    ss.clear();\n    for (int i : suffix_array(b)) ss.push_back(tmp[i]);\n    return induced_sort();\n  }\n\n  void build_lcp() {\n    const int n = a.size();\n    isa.resize(n + 1);\n    lcp.assign(n + 1, 0);\n    for (int i = 0; i <= n; i++) {\n      isa[sa[i]] = i;\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n      int j = sa[isa[i] - 1];\n      k = std::max(0, k - 1);\n      while (i + k < n && j + k < n && a[i + k] == a[j + k]) {\n        k++;\n      }\n      lcp[isa[i] - 1] = k;\n    }\n  }\n\n  void build_rmq() {\n    const int n = lcp.size();\n    lg.resize(n + 1);\n    for (int i = 2; i <= n; i++) {\n      lg[i] = lg[i / 2] + 1;\n    }\n    const int m = lg[n];\n    rmq.assign(m + 1, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      rmq[0][i] = lcp[i];\n    }\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j + (1 << i) < n; j++) {\n        rmq[i + 1][j] = std::min(rmq[i][j], rmq[i][j + (1 << i)]);\n      }\n    }\n  }\n};\n\nconst long long inf = 1e9;\n\nstruct Stack {\n  vector<pair<int, long long>> a;\n  long long sum = 0;\n\n  void push() {\n    sum += inf;\n    a.emplace_back(inf, 1);\n  }\n\n  void cut(int k) {\n    long long s = 0;\n    while (!a.empty() && a.back().first >= k) {\n      s += a.back().second;\n      sum -= a.back().first * a.back().second;\n      a.pop_back();\n    }\n    sum += s * k;\n    a.emplace_back(k, s);\n  }\n\n  int total() {\n    int s = 0;\n    for (auto p : a) s += p.second;\n    return s;\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n  vector<int> a;\n  for (int i = 0; i < n; i++) {\n    a.push_back(s[i] - \'a\');\n  }\n  SuffixDataStructure sa(a);\n\n  while (q--) {\n    int u, v;\n    scanf(""%d %d"", &u, &v);\n    vector<int> a(u);\n    vector<int> b(v);\n    for (int i = 0; i < u; i++) scanf(""%d"", &a[i]), a[i]--, a[i] = sa.isa[a[i]];\n    for (int i = 0; i < v; i++) scanf(""%d"", &b[i]), b[i]--, b[i] = sa.isa[b[i]];\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    int i = 0;\n    int j = 0;\n    Stack A, B;\n    int p = -1;\n    long long ans = 0;\n    while (i < u || j < v) {\n      if (j == v || (i < u && a[i] < b[j])) {\n        int h = p == -1 ? 0 : sa.get_lcp(sa.sa[p], sa.sa[a[i]]);\n        p = a[i];\n        A.cut(h);\n        B.cut(h);\n        ans += B.sum;\n        A.push();\n        i++;\n      } else {\n        int h = p == -1 ? 0 : sa.get_lcp(sa.sa[p], sa.sa[b[j]]);\n        p = b[j];\n        A.cut(h);\n        B.cut(h);\n        ans += A.sum;\n        B.push();\n        j++;\n      }\n    }\n    printf(""%lld\\n"", ans);\n  }\n}\n\n']",,,"['data structures', 'string suffix structures']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Yet Another LCP Problem.json,https://codeforces.com/blog/entry/62742,At first implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough For example it s a Suffix Array linear LCP Sparse Table Now we can compare two suffixes and by finding and comparing with We will process queries online Let current query be a pair of arrays and We will calculate answer in two parts To calculate the first sum we can sort all suffixes in lexicographical order and maintain some information for prefixes of What information we need to maintain We need some Data Structure which will hold of suffixes from When we process some we need just a total sum of all in the DS If we should add to the DS length of th suffix And when we move from to we must recalculate some Since is sorted all we need is to set In fact this Data Structure is just a In this we will hold for each length number of suffixes with we will hold only non zero values When we should add some suffix we manually increase some value by one Setting with can be done with decreasing maximum in while its more than It can be proven that there will be operations with for one query The total sum can be maintained in some global variable which will be recalculated each time changes To calculate the second sum we can just reverse and run the same algorithm So total complexity is 
https://codeforces.com//contest/1215/problem/C,412393,C,1215C,1215,C. Swap Letters,Monocarp has got two strings s and t having equal length Both strings consist of lowercase Latin letters and Monocarp wants to make these two strings s and t equal to each other He can do the following operation any number of times choose an index pos 1 in the string s choose an index pos 2 in the string t and swap s pos 1 with t pos 2 You have to determine the minimum number of operations Monocarp has to perform to make s and t equal and print any optimal sequence of operations or say that it is impossible to make these strings equal ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nchar a[200005],b[200005];\nint n,q1[200005],q2[200005];\nint k,ans1[500005],ans2[500005];\nint main(){\n\tscanf(""%d%s%s"",&n,a+1,b+1);\n\tFor(i,1,n)\n\t\tif (a[i]==\'a\'&&b[i]==\'b\') q1[++*q1]=i;\n\t\telse if (a[i]==\'b\'&&b[i]==\'a\') q2[++*q2]=i;\n\tif (((*q1)+(*q2))%2==1) return puts(""-1""),0;\n\tfor (;*q1>=2;*q1-=2) ans1[++k]=q1[*q1],ans2[k]=q1[(*q1)-1];\n\tfor (;*q2>=2;*q2-=2) ans1[++k]=q2[*q2],ans2[k]=q2[(*q2)-1];\n\tif (*q1){\n\t\tans1[++k]=q1[1]; ans2[k]=q1[1];\n\t\tans1[++k]=q1[1]; ans2[k]=q2[1];\n\t}\n\tprintf(""%d\\n"",k);\n\tFor(i,1,k) printf(""%d %d\\n"",ans1[i],ans2[i]);\n}']",,,"['constructive algorithms', 'greedy']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Swap Letters.json,https://codeforces.com//blog/entry/69815,Let s calculate two vectors and will contain all positions such that Analogically will contain all positions such that If the sizes of these vectors are not equal modulo the answer does not exist because the total number of letters and should be even In the other case we should perform operations in a greedy way In one operation we can make equal to and equal to if both and belong to or if both these positions belong If the sizes of and are even we need only operation In the other case there are two positions and such that We need two operations to make and at first we perform the operation and then the operation After that strings and will be equal to each other 
https://codeforces.com//contest/676/problem/B,60897,B,676B,676,B. Pyramid of Glasses,Mary has just graduated from one well known University and is now attending celebration party Students like to dream of a beautiful life so they used champagne glasses to construct a small pyramid The height of the pyramid is The top level consists of only glass that stands on glasses on the second level counting from the top then glasses on the third level and so on The bottom level consists of glasses Vlad has seen in the movies many times how the champagne beautifully flows from top levels to bottom ones filling all the glasses simultaneously So he took a bottle and started to pour it in the glass located at the top of the pyramid Each second Vlad pours to the top glass the amount of champagne equal to the size of exactly one glass If the glass is already full but there is some champagne flowing in it then it pours over the edge of the glass and is equally distributed over two glasses standing under If the overflowed glass is at the bottom level then the champagne pours on the table For the purpose of this problem we consider that champagne is distributed among pyramid glasses immediately Vlad is interested in the number of completely full glasses if he stops pouring champagne in seconds Pictures below illustrate the pyramid consisting of three levels ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ndouble M[15][15];\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,t;\n\tcin>>n>>t;\n\tdouble x;\n\n\twhile(t--) {\n\t\tM[1][1] += 1;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=i;++j) {\n\t\t\t\tif(M[i][j] > 1) {\n\t\t\t\t\tx = M[i][j] - 1;\n\t\t\t\t\tM[i][j] = 1;\n\t\t\t\t\tM[i+1][j] += x/2;\n\t\t\t\t\tM[i+1][j+1] += x/2;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tx = 0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tif(M[i][j] == 1)\n\t\t\t\t++x;\n\n\tcout<<x<<""\\n"";\n\n\treturn 0;\n}\n']",,,"['implementation', 'math', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Pyramid of Glasses.json,https://codeforces.com/blog/entry/45018,The restrictions in this problem allow to simulate the process Let the volume of one wineglass equals to conventional units So the volume of the champagne surpluses which will stream to bottom level will always integer number So let s pour in the top wineglass units of champagne and then we have following case if in the current wineglass is more champagne than its volume let s make and add of champagne in each of the two bottom wineglasses Asymptotic behavior 
https://codeforces.com//contest/746/problem/B,85370,B,746B,746,B. Decoding,Polycarp is mad about coding that is why he writes Sveta encoded messages He calls the in a word the letter which is in the middle of the word If the word s length is even the median letter is the left of the two middle letters In the following examples the median letter is highlighted If the word consists of single letter then according to above definition this letter is the median letter Polycarp encodes each word in the following way he writes down the median letter of the word then deletes it and repeats the process until there are no letters left For example he encodes the word as You are given an encoding of some word your task is to decode it ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)301*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n;\nstring s;\nchar ans[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>s;\n    ll k=n;\n    for(int i=0;i<n;i++)ans[i]='.';\n    for(int i=0;i<s.size();i++)\n    {\n    \tll x=(k-1)/2;\n    \tfor(int j=0;j<n;j++)\n    \t{\n    \t\tif(x==0 && ans[j]=='.'){ans[j]=s[i];break;}\n    \t\tif(ans[j]=='.')x--;\n\t\t}\n    \tk--;\n\t}\n\tfor(int i=0;i<n;i++)cout<<ans[i];\n    return 0;\n}""]",,,"['implementation', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Decoding.json,https://codeforces.com//blog/entry/49160,To find the answer we can iterate through the given string from the left to the right and add each letter in the answer string one letter to the begin next letter to the end next letter to begin and so on If is even than the first letter must be added to the begin and the second letter to the end In the other case the first letter to the end second to the begin We need to make it until we do not add all letters from the given string 
https://codeforces.com//contest/109/problem/A,572,A,109A,109,A. Lucky Sum of Digits,Petya wonders eagerly what minimum lucky number has the sum of digits equal to Help him cope with the task ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint main(void){\n    int N,i,j;\n    \n    cin >> N;\n    \n    REP(i,7){\n        int M = N - 4*i;\n        if(M >= 0 && M%7 == 0){\n            string ans;\n            REP(j,i) ans += \'4\';\n            REP(j,M/7) ans += \'7\';\n            printf(""%s\\n"",ans.c_str());\n            return 0;\n        }\n    }\n    \n    cout << ""-1"" << endl;\n    \n    return 0;\n}\n']",,,"['brute force', 'implementation']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Lucky Sum of Digits.json,https://codeforces.com/blog/entry/2547,Let result number contains a digits 4 and b digits 7 Obviously that a 4 b 7 n Loop through all values of b If we know b we can calculate a Among all pairs a b we need to choose one with a b minimum Among all that pairs we need to choose one with b minimum Output will be an integer 444 444777 777 here number of digits 4 equal to a number of digits 7 equal to b 
https://codeforces.com//contest/930/problem/C,162260,C,930C,930,C. Teodor is not a liar ,Young Teodor enjoys drawing His favourite hobby is drawing segments with integer borders inside his huge segment One day Teodor noticed that picture he just drawn has one interesting feature there doesn t exist an integer point that belongs each of segments in the picture Having discovered this fact Teodor decided to share it with Sasha Sasha knows that Teodor likes to show off so he never trusts him Teodor wants to prove that he can be trusted sometimes so he decided to convince Sasha that there is no such integer point in his picture which belongs to each segment However Teodor is lazy person and neither wills to tell Sasha all coordinates of segments ends nor wills to tell him their amount so he suggested Sasha to ask him series of questions Given the integer point how many segments in Fedya s picture contain that point promising to tell correct answers for this questions Both boys are very busy studying and don t have much time so they ask you to find out how many questions can Sasha ask Teodor that having only answers on his questions Sasha can t be sure that Teodor isn t lying to him Note that Sasha doesn t know amount of segments in Teodor s picture Sure Sasha is smart person and never asks about same point twice ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 100001;\n\nint fen[MAXN];\nint fl[MAXN];\nint fr[MAXN];\nint c[MAXN];\n\nvoid init() {\n    memset(fen, 0, sizeof(fen));\n}\n\nint n, m;\n\nvoid upd(int x, int y) {\n    for (int i = x; i <= n; i |= (i + 1)) {\n        fen[i] = max(fen[i], y);\n    }\n}\n\nint gt(int x) {\n    int ans = 0;\n    for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n        ans = max(ans, fen[i]);\n    }\n\n    return ans;\n}\n\nint main() {\n#ifdef BZ\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        ++c[a];\n        --c[b + 1];\n    }\n\n    for (int i = 2; i <= m; ++i) {\n        c[i] += c[i - 1];\n    }\n\n    init();\n    for (int i = 1; i <= m; ++i) {\n        upd(c[i], fl[i] = (gt(c[i]) + 1));\n    }\n\n    init();\n    int ans = 0;\n    for (int i = m; i >= 1; --i) {\n        upd(c[i], fr[i] = (gt(c[i]) + 1));\n        ans = max(ans, fl[i] + fr[i] - 1);\n    }\n\n\n    cout << ans << ""\\n"";\n}']",,,"['data structures', 'dp']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Teodor is not a liar .json,https://codeforces.com//blog/entry/58177,Solution Firstly let s calculate cnt xi for each integer point in 1 m One way to do this is scanning line which asymptotics is O m n Other approach uses segment tree supporting segment addition queries In this case asymptotics is O n log m Now we only need to find longest sequence satisfying this property Let s consider all possible xi in previous inequation element that has peak cnt xi Now the answer is length of longest nondecreasing sequence ending in xi length of longest nonincreasing sequence starting in xi 1 Both lengths can be found in O 1 if one precalculates this lengths for each 1 i m using dynamic programming Note that you should use O m log m algorithm for calculating this dp not O m2 otherwise you will end up with TL verdict Total asymptotics of this solution is O m log m for solution using scanning line or O n m log m for solution using segment tree 
https://codeforces.com//contest/698/problem/B,65777,B,698B,698,B. Fix a Tree,A tree is an undirected connected graph without cycles Let s consider a rooted undirected tree with vertices numbered through There are many ways to represent such a tree One way is to create an array with integers where denotes a parent of vertex here for convenience a root is considered its own parent Given a sequence one is able to restore a tree There must be exactly one index that A vertex is a root of the tree For all other vertices there is an edge between vertex and vertex A sequence is called valid if the described procedure generates some any rooted tree For example for sequences and valid You are given a sequence not necessarily valid Your task is to change the minimum number of elements in order to get a valid sequence Print the minimum number of changes and an example of a valid sequence after that number of changes If there are many valid sequences achievable in the minimum number of changes print any of them ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,p[N],vis[N],rt,cnt,T;\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",p+i);\n\t\tif (p[i]==i) rt=i;\n\t}\n\trep(i,1,n+1) if (!vis[i]) {\n\t\tT++;\n\t\tint x=i;\n\t\twhile (!vis[x]) {\n\t\t\tvis[x]=T;\n\t\t\tx=p[x];\n\t\t}\n\t\tif (vis[x]==T) {\n\t\t\tif (!rt) {\n\t\t\t\trt=x; p[x]=x;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (x!=rt) {\n\t\t\t\tp[x]=rt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"",cnt);\n\trep(i,1,n+1) printf(""%d "",p[i]);\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'trees']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Fix a Tree.json,https://codeforces.com//blog/entry/46148,One can easily see that given sequence describes a functional graph thus a directed graph with edges going from i to ai for every i This graph represents a set of cycles and each cycle vertex is a root of its own tree possibly consisting of one vertex Picture above shows an example of a functional graph It consists of two cycles 1 6 3 and 4 Vertex 6 is the root of the tree consisting of vertices 0 2 6 and 8 vertex 3 roots the tree of vertices 3 and 5 vertex 4 root of tree of vertices 4 and 7 and vertex 1 forms a tree of only one vertex In terms of functional graph our goal is to make the graph consisting of exactly one cycle of exactly one vertex looped to itself Operation of change is equivalent to removing some outgoing edge and adding a new one going to somewhat else vertex Let s firstly make our graph containing only one cycle To do so one can choose any of initially presented cycles and say that it will be the only one Then one should consider every other cycle remove any of its in cycle edges and replace it with an edge going to any of the chosen cycle s vertices Thus the cycle will be broken and its vertices along with tree ones will be connected to the only chosen cycle One will need to do exactly cycleCount 1 such operations Note that the removing of any non cycle edge does not make sense because it does not break any cycle The next thing is to make the cycle length be equal to 1 That might be already satisfied if one will choose a cycle of minimal length and this length equals 1 Thus if the initial graph contains any cycle of length 1 we are done with cycleCount 1 operations Otherwise the cycle contains more than one vertex It can be fixed with exactly one operation one just need to break any of in cycle edges say from u to au and add an edge from u to u The graph will remain consisting of one cycle but consisting of one self looped vertex In that case we are done with cycleCount operations To do all the operations above one can use DSU structure or just a series of DFS Note that there is no need in realisation of edge removing and creating one just needs to analyze initial graph 
https://codeforces.com//contest/360/problem/B,3929,B,360B,360,B. Levko and Array,Levko has an array that consists of integers But he doesn t like this array at all Levko thinks that the beauty of the array directly depends on value which can be calculated by the formula The less value is the more beautiful the array is It s time to change the world and Levko is going to change his array for the better To be exact Levko wants to change the values of at most array elements it is allowed to replace the values by any integers Of course the changes should make the array as beautiful as possible Help Levko and calculate what minimum number he can reach ,"['//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""[""#x""] Time : %.3lf s.\\n"", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(""["" x ""] Time : %.3lf s.\\n"", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""B""\n\n#ifdef LOCAL\nstatic struct __timestamper {\n    ~__timestamper(){\n        TIMESTAMP(end);\n    }\n} __TIMESTAMPER;\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst int MAXN = 2100;\n\nint a[MAXN];\nint dp[MAXN];\nint n,k;\n\nint check(int maxv){\n    for (int i = 0; i < n; i++){\n        dp[i] = i;\n        for (int j = 0; j < i; j++)\n            if (abs(a[j] - a[i]) <= maxv * 1LL* (i - j))\n                dp[i] = min(dp[i], dp[j] + i - j - 1);\n//      eprintf(""%d\\n"", dp[i]);\n    }\n\n    for (int i = 0; i < n; i++)\n        if (dp[i] + (n - i - 1) <= k)\n            return true;\n    return false;\n}\n\nint main(){\n  #ifdef LOCAL\n    freopen(TASKNAME"".in"",""r"",stdin);\n    freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n\n    scanf(""%d%d"",&n,&k);\n\n    int cur = 0;\n\n    for (int i = 0; i < n; i++){\n        scanf(""%d"",&a[i]);\n        if (i) cur = max(cur, abs(a[i] - a[i-1]));\n    }\n\n//    check(1);\n//    return 0;\n\n    int l = -1;\n    int r = cur;\n\n\n    while (r - l > 1){\n        int mid = l + (r - l) / 2;\n        if (check(mid))\n            r = mid;\n        else\n            l = mid;\n    }\n\n    printf(""%d\\n"", r);      \n    return 0;\n}']",,,"['binary search', 'dp']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Levko and Array.json,https://codeforces.com//blog/entry/9529,Let s solve this problem using binary search We need to check whether we can achieve an array when will be at most Lets make dp means minimal number of elements with indeces less than which we need to change but we don t change th element Let s iterate next element which we don t change Then we know that we can change all elements between and It is equivalent to such condition Difference between neighboring elements can be at most The maximal possible difference increases by exactly times between elements and so this inequality is correct 
https://codeforces.com//contest/1681/problem/F,1408807,F,1681F,1681,F. Unique Occurrences,You are given a tree consisting of n vertices Each edge has an integer value written on it Let f v u be the number of values that appear on the edges of a simple path between vertices v and u Calculate the sum of f v u over all pairs of vertices v and u such that 1 le v u le n ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:44:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<pair<int, int>>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a; --b; --c;\n    g[c].emplace_back(a, b);\n  }\n  vector<int> p(n);\n  iota(p.begin(), p.end(), 0);\n  vector<int> sz(n, 1);\n  vector<pair<int, int>> ops;\n  auto Get = [&](int i) {\n    while (i != p[i]) {\n      i = p[i];\n    }\n    return i;\n  };\n  auto Unite = [&](int i, int j) {\n    i = Get(i);\n    j = Get(j);\n    if (i != j) {\n      if (sz[i] > sz[j]) {\n        swap(i, j);\n      }\n      ops.emplace_back(i, p[i]);\n      p[i] = j;\n      ops.emplace_back(~j, sz[j]);\n      sz[j] += sz[i];\n    }\n  };\n  auto Rollback = [&](int T) {\n    while ((int) ops.size() > T) {\n      int i = ops.back().first;\n      int j = ops.back().second;\n      ops.pop_back();\n      if (i >= 0) {\n        p[i] = j;\n      } else {\n        sz[~i] = j;\n      }\n    }\n  };\n  long long ans = 0;\n  function<void(int, int)> Dfs = [&](int l, int r) {\n    if (l == r) {\n      for (auto& p : g[l]) {\n        int x = Get(p.first);\n        int y = Get(p.second);\n        ans += (long long) sz[x] * sz[y];\n      }\n      return;\n    }\n    int mid = (l + r) >> 1;\n    {\n      int save = (int) ops.size();\n      bool fail = false;\n      for (int i = mid + 1; i <= r; i++) {\n        for (auto& p : g[i]) {\n          Unite(p.first, p.second);\n        }\n      }\n      Dfs(l, mid);\n      Rollback(save);\n    }\n    {\n      int save = (int) ops.size();\n      bool fail = false;\n      for (int i = l; i <= mid; i++) {\n        for (auto& p : g[i]) {\n          Unite(p.first, p.second);\n        }\n      }\n      Dfs(mid + 1, r);\n      Rollback(save);\n    }\n  };\n  Dfs(0, n - 1);\n  cout << ans << \'\\n\';\n  return 0;\n}\n']",,,"['data structures', 'dfs and similar', 'divide and conquer', 'dp', 'dsu', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Unique Occurrences.json,https://codeforces.com//blog/entry/103163,Let s use contribution to the sum technique to simplify the problem Instead of counting the number of colors that occure only once for each path let s for each color count the number of paths that contain this color exactly once Now we can solve the problem independently for each color and sum up the answers The first intended solution was the following So we want to calculate the answer for some color Mark all edges of color as good the rest are bad Then we can calculate the number of paths up to vertex such that they contain either or good edges The transitions should be pretty easy and the answer should be updated when you consider gluing up paths from different children in each vertex Obviously this is per color so overall However we can only calculate this dynamic programming as easily on a virtual tree of vertices adjacent to all good edges How to calculate the dp for some vertex First push the paths from all virtual children to That was enough in the dp for the entire tree but now there are also removed vertices that could also have paths starting in them All these paths contain good edges otherwise they would have had virtual vertices on them Their amount is the following the size of the real subtree of minus the sizes of real subtrees of all its virtual children The rest is exactly the same as in the dp on the real tree A little fun trick Usually you want to add lca of adjacent vertices to the virtual tree But that s actually not needed here you can just add the root of the tree and link the vertices without a parent to them That won t change the result of the dp That solution works in or The second intended solution is slower complexity wise but not time wise In the first solution we wanted to leave only the good edges in the tree Here we want to remove only them Consider the resulting connected components What s the number of paths that contain only one of the good edges It s actually the product of sizes of the connected components this edge connects So we want to remove edges add edges and maintain the sizes of the connected components of the tree That s basically the same problem as dynamic connectivity The implementation works well enough 
https://codeforces.com//contest/676/problem/C,60898,C,676C,676,C. Vasya and String,High school student Vasya got a string of length as a birthday present This string consists of letters and only Vasya denotes of the string as the maximum length of a consecutive subsequence consisting of equal letters Vasya can change no more than characters of the original string What is the maximum beauty of the string he can achieve ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\n\nint Solve(string str) {\n\tint j = -1, countB = 0, ans = 0;\n\tfor(int i = 0; i < str.size(); ++i) {\n\t\tcountB += (str[i] == \'b\');\n\n\t\twhile(j <= i && countB > k) {\n\t\t\t++j;\n\t\t\tcountB -= (str[j] == \'b\');\n\t\t}\n\n\t\tans = max(ans, i - j);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> k;\n\n\tstring str;\n\tcin >> str;\n\n\tint r = Solve(str);\n\tfor(auto &c : str)\n\t\tc = c ^ \'a\' ^ \'b\';\n\tcout << max(r, Solve(str))<<""\\n"";\n\n\n\treturn 0;\n}\n']",,,"['binary search', 'dp', 'strings', 'two pointers']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Vasya and String.json,https://codeforces.com/blog/entry/45018,This problem can be solved with help of two pointers Let the first pointer is and the second pointer is Then for every position we will move right end until on the substring it is possible to make no more than swaps to make this substring beautiful Then we need to update the answer with length of this substring and move to the right Asymptotic behavior 
https://codeforces.com//contest/1593/problem/E,1142166,E,1593E,1593,E. Gardener and Tree,A tree is an undirected connected graph in which there are no cycles This problem is about non rooted trees A leaf of a tree is a vertex that is connected to vertex The gardener Vitaly grew a tree from n vertices He decided to trim the tree To do this he performs a number of operations In one operation he removes leaves of the tree For example consider the tree shown in the figure above The figure below shows the result of applying exactly one operation to the tree Note the special cases of the operation applying an operation to an empty tree of 0 vertices does not change it applying an operation to a tree of one vertex removes this vertex this vertex is treated as a leaf applying an operation to a tree of two vertices removes both vertices both vertices are treated as leaves Vitaly applied k operations sequentially to the tree How many vertices remain ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=400005;\nqueue<int> q;\nint t,n,k,kt[N],d[N];\nvector<int> a[N];\nint main() {\n  \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>n>>k;\n        for (int i=1;i<=n;i++) {\n            kt[i]=d[i]=0;\n            a[i].clear();\n        }\n        for (int i=1;i<n;i++) {\n            int u,v;\n            cin>>u>>v;\n            a[u].push_back(v);\n            a[v].push_back(u);\n            d[u]++;\n            d[v]++;\n        }\n        int res=n;\n        for (int i=1;i<=n;i++)\n        if (d[i]<=1) {\n            q.push(i);\n            kt[i]=1;\n        }\n        while (!q.empty()) {\n\n            int u=q.front();\n            res--;\n            q.pop();\n            if (kt[u]==k) continue;\n            for (auto v:a[u])\n            if (!kt[v]) {\n                d[v]--;\n                if (d[v]<=1) {\n                    kt[v]=kt[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n        cout<<res<<""\\n"";\n    }\n}\n']",,,"['brute force', 'data structures', 'dfs and similar', 'greedy', 'implementation', 'trees']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Gardener and Tree.json,https://codeforces.com//blog/entry/96034,Let s create two arrays of length The element of the array will contain the operation number at which the vertex which is the index of the array will be deleted The array will contain the number of neighbors of a given vertex at a certain time This array must be initialized with the number of neighbors in the original tree Initially we will suppose that the gardener performs an infinite number of operations and we will simply calculate for each vertex the number of the operation on which it will be deleted Let s create a queue which will store the order of deleting vertices The queue will contain only those vertices whose neighbors except maybe one have been removed i e Let s add all leaves of the original tree to it for each of them let s store the value in the array because all original leaves will be removed during the first operation Next we will take sequentially one vertex from the queue and update the data about its neighbors Consider the neighbors Since we are deleting the current vertex we need to update of its neighbors If the neighbor s is equal to then it s already in the queue and it doesn t need to be considered right now Otherwise we will decrease the neighbor s by If it becomes equal to then the neighbor must be added to the queue The number of the operation during which the neighbor will be deleted is equal to the number of the operation during which the current vertex will be deleted plus After we calculate the numbers of operations for all vertices we need to select among them those that will not be deleted during operations with numbers Thus the answer is the number of vertices such that 
https://codeforces.com//contest/1864/problem/E,2181268,E,1864E,1864,E. Guess Game,Carol has a sequence s of n non negative integers She wants to play the Guess Game with Alice and Bob To play the game Carol will select two integer indices i a and i b within the range 1 n and set a s i a b s i b Please note that i a and i b may coincide Carol will tell the value of a to Alice the value of b to Bob the value of a mid b to both Alice and Bob where denotes the bitwise OR operation Please note that Carol will tell any information about s to either Alice or Bob Then the guessing starts The two players take turns making guesses with Alice starting first The goal of both players is to establish which of the following is true a b a b or a b In their turn a player can do one of the following two things say I don t know and pass the turn to the other player say I know followed by the answer a b a b or a b then the game ends Alice and Bob hear what each other says and can use this information to deduce the answer Both Alice and Bob are smart enough and only say I know when they are completely sure You need to calculate the expected value of the number of turns taken by players in the game Output the answer modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst int d=30;\n\nint n;\nll tab[nax];\n\nll wyn=0;\n\nll inv(ll v)\n{\n\tif (v<=1)\n\t\treturn v;\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nvoid rek(vll wek)\n{\n\tif (wek[0]==wek.back())\n\t{\n\t\twyn+=wek.size()*(ll)wek.size()*(ll)(__builtin_popcountll(wek[0])+1);\n\t\treturn;\n\t}\n\tll r=wek[0]^wek.back();\n\tint x=63-__builtin_clzll(r);\n\tvll a, b;\n\tfor (ll i : wek)\n\t{\n\t\tif (i&(1LL<<x))\n\t\t\ta.push_back(i);\n\t\telse\n\t\t\tb.push_back(i);\n\t}\n\tll kejsy=a.size()*(ll)b.size();\n\tll resz=wek.size()*(ll)wek.size()-kejsy;\n\tll wyz=0;\n\t{\n\t\tll p=wek[0]&(wek[0]^((1LL<<x)-1));\n\t\tp=__builtin_popcountll(p);\n\t\twyz=p+1;\n\t}\n\t//~ debug() << imie(wek) << imie(kejsy) << imie(resz);\n\twyn+=kejsy*(2*wyz+1);\n\twyn%=mod;\n\t//~ wyn+=resz;\n\t//~ wyn%=mod;\n\trek(a);\n\trek(b);\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tsort(tab+1, tab+1+n);\n\twyn=0;\n\t//~ map<ll,ll> mapa;\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ mapa[tab[i]]++;\n\t//~ wyn=0;\n\t//~ for (auto i : mapa)\n\t//~ {\n\t\t//~ wyn+=i.second*i.second*(__builtin_popcountll(i.first)+1);\n\t\t//~ wyn%=mod;\n\t//~ }\n\tvll wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back(tab[i]);\n\trek(wek);\n\t\n\twyn*=inv(n*(ll)n%mod);\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['bitmasks', 'data structures', 'games', 'math', 'probabilities', 'sortings', 'strings', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Guess Game.json,https://codeforces.com//blog/entry/119772,TutorialFirst let s analize a single game for fixed and how many turns it takes Consider the binary representation of We consider bits from highest to lowest For bits with a value of we can ignore it because it firmly tells us that both bits of and are For convenience we assume that all bits of are In the first round if the highest bit of is then Alice can immediately say that Otherwise in the second round of the game Bob knows that the highest bit of is not If the highest or the second highest bit of b is then Bob can immediately say that Otherwise in the third round of the game Alice knows that the highest and the second highest bits of are not and so on Consider only set bits in Let s enumerate these bits from highest to lowest After some observation we can conclude that If and the th bit in is zero then the answer is If then the answer is where is the number of set bits in If and the th bit in is zero then the answer is Now that we have a brute force algorithm for how can we optimize it We can build a bit trie and traverse all nodes We can easily calculate the number of s that pass from a node to the root node as well as the number of numbers prefixed with it and followed by or Use this information to calculate the answer 
https://codeforces.com//contest/1327/problem/A,571324,A,1327A,1327,A. Sum of Odd Integers,You are given two integers n and k Your task is to find if n can be represented as a sum of k not divisible by 2 integers or not You have to answer t independent test cases ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint _;\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tll n,k;\n\t\tscanf(""%lld%lld"",&n,&k);\n\t\tif (n<k*k||(n-k)%2!=0) puts(""NO"");\n\t\telse puts(""YES"");\n\t}\n}\n']",,,['math'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Sum of Odd Integers.json,https://codeforces.com//blog/entry/75147,First of all notice that the sum of the first k odd integers is k 2 If k 2 n then the answer obviously And if n 
https://codeforces.com//contest/679/problem/D,61897,D,679D,679,D. Bear and Chase,Bearland has cities numbered through There are bidirectional roads The th road connects two distinct cities and No two roads connect the same pair of cities It s possible to get from any city to any other city using one or more roads The distance between cities and is defined as the minimum number of roads used to travel between and Limak is a grizzly bear He is a criminal and your task is to catch him or at least to try to catch him You have only two days today and tomorrow and after that Limak is going to hide forever Your main weapon is BCD Bear Criminal Detector Where you are in some city you can use BCD and it tells you the distance between you and a city where Limak currently is Unfortunately BCD can be used only once a day You don t know much about Limak s current location You assume that he is in one of cities chosen uniformly at random each city with probability You decided for the following plan Choose one city and use BCD there After using BCD you can try to catch Limak but maybe it isn t a good idea In this case you choose one city and check it You win if Limak is there Otherwise Limak becomes more careful and you will never catch him you loose Wait hours to use BCD again You know that Limak will change his location during that time In detail he will choose uniformly at random one of roads from his initial city and he will use the chosen road going to some other city Tomorrow you will again choose one city and use BCD there Finally you will try to catch Limak You will choose one city and check it You will win if Limak is there and loose otherwise Each time when you choose one of cities you can choose any of cities Let s say it isn t a problem for you to quickly get somewhere What is the probability of finding Limak if you behave optimally ,"['#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint w[410][410], D[410][410], Deg[410], L[410];\nbool v[410];\ndouble Res, P[410], MM[410];\nint n, m;\nvoid Do(int a){\n    int i, j, k;\n    double S=0.0;\n    for(i=0;i<n;i++){\n        int cnt = 0, cnt2 = 0;\n        double Mx = 0.0, SS;\n        for(j=1;j<=n;j++){\n            P[j] = 0.0;\n            v[j]=false;\n        }\n        for(j=1;j<=n;j++){\n            if(D[a][j] == i){\n                cnt++;\n                double tp = 1.0/Deg[j]/n;\n                for(k=1;k<=n;k++){\n                    if(w[j][k]){\n                        P[k] += tp;\n                        v[k] = true;\n                    }\n                }\n            }\n        }\n        if(cnt){\n            Mx = max(Mx,1.0/n);\n        }\n        for(j=1;j<=n;j++){\n            if(v[j]){\n                L[++cnt2] = j;\n            }\n        }\n        for(j=1;j<=n;j++){\n            SS = 0.0;\n            for(k=1;k<=cnt2;k++){\n                MM[D[j][L[k]]]=max(MM[D[j][L[k]]],P[L[k]]);\n            }\n            for(k=1;k<=cnt2;k++){\n                SS += MM[D[j][L[k]]];\n                MM[D[j][L[k]]]=0.0;\n            }\n            Mx = max(Mx,SS);\n        }\n        S+=Mx;\n    }\n    Res = max(Res,S);\n}\nint main(){\n    int i, j, a, b, k;\n    scanf(""%d%d"",&n,&m);\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            if(i!=j)D[i][j]=9999999;\n        }\n    }\n    for(i=0;i<m;i++){\n        scanf(""%d%d"",&a,&b);\n        Deg[a]++,Deg[b]++;\n        D[a][b]=D[b][a]=1;\n        w[a][b]=w[b][a]=1;\n    }\n    for(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)D[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n    for(i=1;i<=n;i++){\n        Do(i);\n    }\n    printf(""%.11lf\\n"",Res);\n}\n']",,,"['brute force', 'dfs and similar', 'graphs', 'implementation', 'math', 'probabilities']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Bear and Chase.json,https://codeforces.com//blog/entry/45310,Check my code below because it has a lot of comments First in or faster find all distances between pairs of cities Iterate over all the first city in which you use the BCD Then for iterate over all the distance you get Now for all cities calculate the probability that Limak will be there in the second day details in my code below Also in a vector interesting let s store all cities that are at distance from city Then iterate over all the second city in which you use the BCD For cities from interesting we want to iterate over them and for each distinct distance from to choose the biggest probability because we will make the best guess there is Magic the described approach has four loops one in the other but it s Proof is very nice and I encourage you to try to get it yourself Proof hereAfter fixing g1 divide cities by their distance from g1 Then when we get distance d1 in the first day then in the second day all possible cities are at distance d1 1 d1 and d1 1 So we will consider each city at most three times 
https://codeforces.com//contest/1340/problem/B,599366,B,1340B,1340,B. Nastya and Scoreboard,The poor boy was very upset because of that He was so sad that he punched some kind of scoreboard with numbers The numbers are displayed in the same way as on an electronic clock each digit position consists of 7 segments which can be turned on or off to display different numbers The picture shows how all 10 decimal digits are displayed After the punch some segments stopped working that is some segments might stop glowing if they glowed earlier But Denis remembered how many sticks were glowing and how many are glowing now Denis broke k segments and he knows which sticks are working now Denis came up with the question what is the maximum possible number that can appear on the board if you turn on exactly k sticks which are off now It is that the number includes leading zeros ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst string DIGS[10] = {""1110111"", ""0010010"", ""1011101"", ""1011011"", ""0111010"", ""1101011"", ""1101111"", ""1010010"", ""1111111"", ""1111011""};\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint N, K; cin >> N >> K;\n\tvector<string> A(N);\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tvector<vector<bool>> poss(N+1, vector<bool>(K+1));\n\tposs[N][K] = true;\n\n\tvector<vector<int>> diffs(N, vector<int>(10));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tint diff = 0;\n\t\t\tbool good = true;\n\t\t\tfor (int v = 0; v < 7; v++) {\n\t\t\t\tif (DIGS[d][v] < A[i][v]) {\n\t\t\t\t\tgood = false;\n\t\t\t\t} else if (DIGS[d][v] > A[i][v]) {\n\t\t\t\t\tdiff++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiffs[i][d] = (good ? diff : -1);\n\t\t}\n\t}\n\n\tfor (int i = N-1; i >= 0; i--) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tint diff = diffs[i][d];\n\t\t\tif (diff == -1) continue;\n\t\t\tfor (int a = 0; a+diff <= K; a++) {\n\t\t\t\tif (poss[i+1][a+diff]) poss[i][a] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!poss[0][0]) {\n\t\tcout << -1 << \'\\n\';\n\t\texit(0);\n\t}\n\n\tstring ans;\n\tint cur = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tassert(poss[i][cur]);\n\t\tfor (int d = 9; true; d--) {\n\t\t\tassert(d >= 0);\n\t\t\tint diff = diffs[i][d];\n\t\t\tif (diff == -1) continue;\n\t\t\tif (cur+diff <= K && poss[i+1][cur+diff]) {\n\t\t\t\tans += char(\'0\'+d);\n\t\t\t\tcur += diff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \'\\n\';\n\n\treturn 0;\n}\n']",,,"['bitmasks', 'dp', 'graphs', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Nastya and Scoreboard.json,https://codeforces.com//blog/entry/76479,Let dp i j true if at the suffix i n you can turn on exactly j sticks and get the correct sequence of digits and false otherwise It is easy to recalculate this dynamics we will make transitions to all possible digits the mask at position i should be a submask of the digit Asymptotic calculate of the dynamics O 10nd Now let s go in order from 1 to n and will try to eagerly set the maximum possible figure using our dynamics It is easy to understand that in this way we get the maximum possible number of n digits 
https://codeforces.com//contest/356/problem/A,3676,A,356A,356,A. Knight Tournament,Hooray Berl II the king of Berland is making a knight tournament The king has already sent the message to all knights in the kingdom and they in turn agreed to participate in this grand event As for you you re just a simple peasant There s no surprise that you slept in this morning and were late for the tournament it was a weekend after all Now you are really curious about the results of the tournament This time the tournament in Berland went as follows There are knights participating in the tournament Each knight was assigned his unique number an integer from 1 to The tournament consisted of fights in the th fight the knights that were still in the game with numbers at least and at most have fought for the right to continue taking part in the tournament After the th fight among all participants of the fight only one knight won the knight number he continued participating in the tournament Other knights left the tournament The winner of the last the th fight the knight number became the winner of the tournament You fished out all the information about the fights from your friends Now for each knight you want to know the name of the knight he was conquered by We think that the knight number was conquered by the knight number if there was a fight with both of these knights present and the winner was the knight number Write the code that calculates for each knight the name of the knight that beat him ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 600010;\n\nint n, m;\nint s[N], ans[N];\n\nvoid modify(int x, int v) {\n  while (x <= n) {\n    s[x] += v;\n    x = (x | (x - 1)) + 1;\n  }\n}\n\nint findsum(int x) {\n  int v = 0;\n  while (x > 0) {\n    v += s[x];\n    x &= x - 1;\n  }\n  return v;\n}\n\nint main() {\n  scanf(""%d %d"", &n, &m);\n  for (int i = 1; i <= n; i++) s[i] = 0;\n  for (int i = 1; i <= n; i++) modify(i, 1);\n  for (int i = 1; i <= n; i++) ans[i] = 0;\n  while (m--) {\n    int from, to, win;\n    scanf(""%d %d %d"", &from, &to, &win);\n    int dec = findsum(from - 1);\n    int add = findsum(to);\n    while (add > dec) {\n      int ll = from, rr = to;\n      while (ll < rr) {\n        int mid = (ll + rr) >> 1;\n        if (findsum(mid) == dec) ll = mid + 1;\n        else rr = mid;\n      }\n      ans[ll] = win;\n      modify(ll, -1);\n      add--;\n    }\n    ans[win] = 0;\n    modify(win, 1);\n  }\n  for (int i = 1; i < n; i++) printf(""%d "", ans[i]);\n  printf(""%d\\n"", ans[n]);\n  return 0;\n}\n']",,,"['data structures', 'dsu']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Knight Tournament.json,https://codeforces.com/blog/entry/9210,Let s the current fight consists of knights fighting Then all we have to do is to find all these knights in time or There are several ways to do that let s consider some of them The first way is to store the numbers of all alive knights in std set C or TreeSet Java Then in C we can use lower bound method to find the first knight in the fight that is alive and to iterate over this set each time moving to the next alive knight In Java we should use subSet method The second way is to define array next with the following meaning To find the first alive knight starting from the knight we need to follow this links until we find the first knight with In order not to pass the same links too many times we will use the trick known as path compression it is used in Disjoint Set Union Note that you should handle the case when the current knight is the last knight and is out of tournament 
https://codeforces.com//contest/492/problem/B,18579,B,492B,492,B. Vanya and Lanterns,Vanya walks late at night along a straight street of length lit by lanterns Consider the coordinate system with the beginning of the street corresponding to the point and its end corresponding to the point Then the th lantern is at the point The lantern lights all points of the street that are at the distance of at most from it where is some positive number common for all lanterns Vanya wonders what is the minimum light radius should the lanterns have to light the whole street ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint l = 0, r, n;\n\tcin >> n >> r;\n\tvector<int> vec;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tvec.push_back(x);\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tint ans = max(vec[0], r-vec.back()) * 2;\n\tfor(int i = 1 ; i < vec.size() ; i++){\n\t\tans = max(vec[i] - vec[i-1], ans);\n\t}\n\tif(ans&1){\n\t\tcout << ans / 2 << "".5000000000"" << endl;\n\t}\n\telse{\n\t\tcout << ans / 2 << "".0000000000"" << endl;\n\t}\n}']",,,"['binary search', 'implementation', 'math', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Vanya and Lanterns.json,https://codeforces.com/blog/entry/14957,Sort lanterns in non decreasing order Then we need to find maximal distance between two neighbour lanterns let it be Also we need to consider street bounds and count distances from outside lanterns to street bounds it will be and The answer will be Time complexity Jury s solution 8924823 
https://codeforces.com//contest/269/problem/A,2577,A,269A,269,A. Magical Boxes,Emuskald is a well known illusionist One of his trademark tricks involves a set of magical boxes The essence of the trick is in packing the boxes inside other boxes From the top view each magical box looks like a square with side length equal to is an integer units A magical box can be put inside a magical box if side length of is strictly less than the side length of In particular Emuskald can put 4 boxes of side length into one box of side length or as in the following figure Emuskald is about to go on tour performing around the world and needs to pack his magical boxes for the trip He has decided that the best way to pack them would be inside another magical box but magical boxes are quite expensive to make Help him find the smallest magical box that can fit all his boxes ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""A""\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nint main(){\n  #ifdef LOCAL\n    freopen(TASKNAME"".in"",""r"",stdin);\n    freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n    vector<pair<int,int> > a;\n    int n;\n    scanf(""%d"",&n);\n\n    for (int i = 0; i < n; i++){\n        int k,b;\n        cin >> k >> b;\n        a.pb(mp(k,b));\n    }\n\n    sort(a.begin(),a.end());\n\n    int ans = a.back().first+1;\n\n    while (true){\n        bool q = true;\n        for (int i = 0; i < n; i++)\n            if (ans - a[i].first <= 15 && (1<<(2*(ans - a[i].first))) < a[i].second){\n                q = false;\n            }\n        if (q)\n            break;\n        ans++;\n    }\n\n    cout << ans << endl;\n\n      \n  return 0;\n}']",,,"['greedy', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Magical Boxes.json,https://codeforces.com//blog/entry/6596,Suppose we can put all the squares inside a square with side length 2p Then we can insert each ki type squares independently along the grid as shown in the picture No two squares will overlap since 2x divides 2y if x y That means that we can find the smallest square that can hold all the given squares with side length 2ki for each ki separately The answer will be the side length of the largest such square To be able to put ai squares with side length 2ki inside a square with side length 2s the following should hold 2s 2 2ki 2 ai 4s 4ki ai 4s ki ai We can then find the minimum s In a special case if we obtain s ki s should be increased by 1 
https://codeforces.com//contest/1954/problem/C,2586693,C,1954C,1954,C. Long Multiplication,You are given two integers x and y of the same length consisting of digits from 1 to 9 You can perform the following operation any number of times possibly zero swap the i th digit in x and the i th digit in y For example if x 73 and y 31 you can swap the 2 nd digits and get x 71 and y 33 Your task is to maximize the product of x and y using the aforementioned operation any number of times If there are multiple answers print any of them ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    string s,t; cin >> s >> t;    int n=sz(s);    bool flag=0;    rep(n) if(s[i]!=t[i]){        if(!flag){            if(s[i]<t[i]) swap(s[i],t[i]);        }        else{            if(s[i]>t[i]) swap(s[i],t[i]);        }        flag=1;    }    print(s);    print(t);}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}']",,,"['greedy', 'math', 'number theory']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Long Multiplication.json,https://codeforces.com//blog/entry/128421,There are two observations to solve the problem applying the operation does not change the sum of the numbers the smaller the difference of the numbers the greater their product the proof is given below Proof let s denote the sum of the numbers as the smallest number as and the largest number as Then the product is equal to We can see that the smaller the half of difference the larger the product In order to get the minimum difference we can use the following algorithm let be the smallest index the most significant digit such that and set the maximum digit among and to the number and smallest to the number thus is definitely greater than then the less significant digits should be the maximum possible for the number i e the inequality must hold for all 
https://codeforces.com//contest/408/problem/A,7726,A,408A,408,A. Line to Cashier,Little Vasya went to the supermarket to get some groceries He walked about the supermarket for a long time and got a basket full of products Now he needs to choose the cashier to pay for the products There are cashiers at the exit from the supermarket At the moment the queue for the th cashier already has people The th person standing in the queue to the th cashier has items in the basket Vasya knows that the cashier needs 5 seconds to scan one item after the cashier scans each item of some customer he needs 15 seconds to take the customer s money and give him the change Of course Vasya wants to select a queue so that he can leave the supermarket as soon as possible Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers ,"['#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <unordered_set>\n#include <stdio.h>\n#include <string.h>\n#include <unordered_map>\nusing namespace std;\n\n#define MOD 10e9+7\nint m[100000];\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0; i<n; i++)\n        cin>>m[i];\n    int v=1000000000;\n    for(int i=0; i<n; i++){\n        int sum=0;\n        for(int e=0; e<m[i]; e++){\n            int a;\n            cin>>a;\n            sum+=5*a;\n            sum+=15;\n        }\n        v=min(v,sum);\n    }\n    cout<<v<<endl;\n    return 0;\n}\n']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Line to Cashier.json,https://codeforces.com//blog/entry/11333,In this problem you were to find waiting the time for every queue by summing up the purchases of all the people and return the minimum 
https://codeforces.com//contest/743/problem/E,84655,E,743E,743,E. Vladik and cards,Vladik was bored on his way home and decided to play the following game He took cards and put them in a row in front of himself Every card has a positive integer number not exceeding written on it He decided to find the longest subsequence of cards which satisfies the following conditions the number of occurrences of each number from to in the subsequence doesn t differ by more then from the number of occurrences of any other number Formally if there are cards with number on them in the subsequence than for all pairs of integers the condition must hold if there is at least one card with number on it in the subsequence then all cards with number in this subsequence must form a continuous segment in it For example the subsequence satisfies this condition while the subsequence doesn t Note that doesn t satisfy the first condition Please help Vladik to find the length of the longest subsequence that satisfies both conditions ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1024;\nconst int CNT = 10;\nconst int MASK = 1<<9;\nconst int INF = (1e9) + 7;\n\nint n,a[N];\nint cnt;\nint nxt[CNT][N][N];\nint occ;\nbool used[N][MASK];\nint state[N][MASK];\nint ans;\n\nint recurse(int pos, int mask) {\n    if(mask==(1<<8)-1) return 0;\n    if(pos>n) return -INF;\n    if(used[pos][mask]) return state[pos][mask];\n    int ans=-INF;\n    if(mask&(1<<(a[pos]-1))) ans=recurse(pos+1,mask);\n    else {\n        ans=max(ans,recurse(pos+1,mask));\n        if(nxt[a[pos]][pos][occ]) ans=max(ans,occ+recurse(nxt[a[pos]][pos][occ]+1,mask|(1<<(a[pos]-1))));\n        if(nxt[a[pos]][pos][occ+1]) ans=max(ans,occ+1+recurse(nxt[a[pos]][pos][occ+1]+1,mask|(1<<(a[pos]-1))));\n    }\n    used[pos][mask]=true;\n    state[pos][mask]=ans;\n    return ans;\n}\n\nint main() {\n    int i,j,z,cnt;\n    set < int > s;\n\n    scanf(""%d"", &n);\n    for(i=1;i<=n;i++) {\n        scanf(""%d"", &a[i]);\n    }\n    for(z=1;z<=8;z++) {\n        for(i=1;i<=n;i++) {\n            cnt=0;\n            for(j=i;j<=n;j++) {\n                if(a[j]==z) ++cnt,nxt[z][i][cnt]=j;\n            }\n        }\n    }\n    for(i=1;i<=n;i++) s.insert(a[i]);\n    ans=(int)(s.size());\n    for(occ=1;(occ-2)*8<=n;++occ) {\n        memset(used,0,sizeof(used));\n        ans=max(ans,recurse(1,0));\n    }\n    printf(""%d\\n"", ans);\n\n    return 0;\n}\n']",,,"['binary search', 'bitmasks', 'brute force', 'dp']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Vladik and cards.json,https://codeforces.com//blog/entry/49049,Suppose we have taken at least cards of each color and colors of them have cards Then the answer will look like Obviously if our sequence of cards allows us to take cards of each color then it allows to take and so on Lets binary search for value and check allowability this way Define bitmask dynamic programming as the number of colors for which we have taken element if we passed cards in the sequence and the colors which has bit equal to one in bitmask mask We will have two different transitions Iterate the new color which has zero bit in the mask to make the first transition and find its occurrence number in subarray The second transition is completely the same but we have to find occurrence number To find the occurrence number of some color in subarray we should maintain an array of the remaining cards for each color Finally find the maximal allowable and in dp calculated for find the maximal additional cards in This solution for colors of cards 8 in our case has complexity 
https://codeforces.com//contest/2032/problem/B,2994605,B,2032B,2032,B. Medians,You are given an array a 1 2 ldots n where n is and an integer k Your task is to choose an positive integer m and to split a into m subarrays dagger b 1 b 2 ldots b m such that Each element of the array a belongs to exactly one subarray For all 1 le i le m b i is i e the length of each subarray is odd operatorname median operatorname median b 1 operatorname median b 2 ldots operatorname median b m k i e the median ddagger of the array of medians of all subarrays must equal k operatorname median c denotes the median of the array c dagger A subarray of the array a of length n is the array a l a l 1 ldots a r for some integers 1 le l le r le n ddagger A median of the array of odd length is the middle element after the array is sorted in non decreasing order For example operatorname median 1 2 5 4 3 3 operatorname median 3 2 1 2 operatorname median 2 1 2 1 2 2 2 2 ,"['#include <bits/stdc++.h>using namespace std;// #define int long longtypedef pair<int,int> pii;#define all(x) (x).begin(),(x).end()#define fi first#define se second#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\xa0void solve(){\tint n,k; cin>>n>>k;\tint l=k-1,r=n-k;\tif(l%2!=r%2) {cout<<-1<<endl; return;}\tif((!l&&r)||(!r&&l)) {cout<<-1<<endl; return;}\tif(n==1)\t{\t\tcout<<1<<endl;\t\tcout<<1<<endl;\t}\telse if(l%2==0&&r%2==0)\t{\t\tcout<<5<<endl;\t\tcout<<1<<"" ""<<k-1<<"" ""<<k<<"" ""<<k+1<<"" ""<<k+2<<endl;\t}\telse if(l%2!=0&&r%2!=0)\t{\t\tcout<<3<<endl;\t\tcout<<1<<"" ""<<k<<"" ""<<k+1<<endl;\t}}\xa0signed main(){\tIOS;\tint T; cin>>T;\twhile(T--) solve();\treturn 0;}']",,,"['constructive algorithms', 'greedy', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Medians.json,https://codeforces.com//blog/entry/135622,For and as well the obvious answer would be not partitioning anything i e partition with 1 subarray being itself For we see that and cannot yield a satisfactory construction Proof is as follows will yield which will never be equal to or when If considering the case of we see that iff and since the original array is an increasingly sorted permutation we can conclude that This is not possible Similarly also doesn t work with as it ll require Apart from these cases any other can yield an answer with a prefix subarray a middle subarray containing will be centered at of course and a suffix subarray This way the answer will be The length of can be either or depending on the parity of so that and could have odd lengths In detail will have length i e if is an even integer and length i e if is an odd integer Time complexity 
https://codeforces.com//contest/1475/problem/E,877137,E,1475E,1475,E. Advertising Agency,Masha works in an advertising agency In order to promote the new brand she wants to conclude contracts with some bloggers In total Masha has connections of n different bloggers Blogger numbered i has a i followers Since Masha has a limited budget she can only sign a contract with k different bloggers Of course Masha wants her ad to be seen by as many people as possible Therefore she must hire bloggers with the maximum total number of followers Help her find the number of ways to select k bloggers so that the total number of their followers is maximum possible Two ways are considered different if there is at least one blogger in the first way which is not in the second way Masha believes that all bloggers have different followers that is there is no follower who would follow two different bloggers For example if n 4 k 3 a 1 3 1 2 then Masha has two ways to select 3 bloggers with the maximum total number of followers conclude contracts with bloggers with numbers 1 2 and 4 In this case the number of followers will be equal to a 1 a 2 a 4 6 conclude contracts with bloggers with numbers 2 3 and 4 In this case the number of followers will be equal to a 2 a 3 a 4 6 Since the answer can be quite large ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int N = 1005;\nmi fact[N];\nmi ifact[N];\nmi C(int x, int y) {\n    if (x<y) return 0;\n    return fact[x] * ifact[y] * ifact[x-y];\n}\nint main() {\n    setIO("""");\n    fact[0] = ifact[0] = 1;\n    f1r(i, 1, N) {\n        fact[i] = fact[i-1] * i;\n        ifact[i] = ifact[i-1] / i;\n    }\n    int tt; re(tt);\n    while (tt--) {\n        int n, k; re(n, k);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        sort(all(a));\n        reverse(all(a));\n        map<int, int> need;\n        map<int, int> exist;\n        f0r(i, n) need[a[i]] = 0, exist[a[i]]++;\n        f0r(i, k) {\n            need[a[i]]++;\n        }\n        mi ans = 1;\n        trav(t, need) {\n            int have = exist[t.f];\n            int go = t.s;\n            ans *= C(have, go);\n        }\n        ps(ans);\n\n    }\n    return 0;\n}']",,,"['combinatorics', 'math', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Advertising Agency.json,https://codeforces.com//blog/entry/87188,It is obvious that Masha will enter into agreements only with bloggers that have the most subscribers You can sort all the bloggers and greedily select the prefix Let be the minimum number of subscribers for the hired blogger Then we must hire all the bloggers who have more subscribers Let the number of bloggers who have more than subscribers the number of bloggers who have exactly subscribers Then we should select bloggers from The number of ways to do this is equal to the binomial coefficient of by You could calculate it by searching for the inverse element modulo Then you could calculate the factorials and use the equality Alternatively you can use the equation and calculate it using dynamic programming This method is better known as the Pascal triangle 
https://codeforces.com//contest/1398/problem/G,699507,G,1398G,1398,G. Running Competition,A running competition is going to be held soon The stadium where the competition will be held can be represented by several segments on the coordinate plane two horizontal segments one connecting the points 0 0 and x 0 the other connecting the points 0 y and x y n 1 vertical segments numbered from 0 to n The i th segment connects the points a i 0 and a i y 0 a 0 a 1 a 2 dots a n 1 a n x For example here is a picture of the stadium with x 10 y 5 n 3 and a 0 3 5 10 A is a route that goes along the segments starts and finishes at the same point and never intersects itself the only two points of a lap that coincide are its starting point and ending point The length of a lap is a total distance travelled around it For example the red route in the picture representing the stadium is a lap of length 24 The competition will be held in q stages The i th stage has length l i and the organizers want to choose a lap for each stage such that the length of the lap is a The organizers don t want to choose short laps for the stages so for each stage they want to find the maximum possible length of a suitable lap Help the organizers to calculate the maximum possible lengths of the laps for the stages In other words for every l i find the maximum possible integer L such that l i bmod L 0 and there exists a lap of length L If it is impossible to choose such a lap then print 1 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=(\'0\'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntemplate<unsigned mod=998244353>struct mint {\n   unsigned val;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=val,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0)x+=mod; return x;\n   }\n   mint():val(0){}\n   mint(ll x):val(x>=0?x%mod:mod+(x%mod)){}\n   mint pow(ll t){mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n   mint& operator+=(const mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n   mint& operator-=(const mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n   mint& operator*=(const mint& x){val=ll(val)*x.val%mod; return *this;}\n   mint& operator/=(const mint& x){val=ll(val)*x.inv()%mod; return *this;}\n   mint operator+(const mint& x)const{return mint(*this)+=x;}\n   mint operator-(const mint& x)const{return mint(*this)-=x;}\n   mint operator*(const mint& x)const{return mint(*this)*=x;}\n   mint operator/(const mint& x)const{return mint(*this)/=x;}\n   bool operator==(const mint& x)const{return val==x.val;}\n   bool operator!=(const mint& x)const{return val!=x.val;}\n};\ntemplate<unsigned mod=998244353>struct factorial {\n   using Mint=mint<mod>;\n   vector<Mint> Fact, Finv;\npublic:\n   factorial(int maxx){\n      Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);\n      Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;\n   }\n   Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n   Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n   Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\nusing Mint=mint<>;\n\nvector<int> rt,irt;\ntemplate<unsigned mod=998244353>void init(int lg=21){\n   using Mint=mint<mod>; Mint prt=2;\n   while(prt.pow(mod>>1).val==1)prt+=1;\n   rt.resize(1<<lg,1); irt.resize(1<<lg,1);\n   rep(w,0,lg){\n      int mask=(1<<w)-1,t=Mint(-1).val>>w;\n      Mint g=prt.pow(t),ig=prt.pow(mod-1-t);\n      rep(i,0,mask){\n         rt[mask+i+1]=(g*rt[mask+i]).val;\n         irt[mask+i+1]=(ig*irt[mask+i]).val;\n      }\n   }\n}\n\ntemplate<unsigned mod=998244353>struct FPS{\n   using Mint=mint<mod>; vector<Mint> f;\n   FPS():f({1}){}\n   FPS(int _n):f(_n){}\n   FPS(vector<Mint> _f):f(_f){}\n   Mint& operator[](const int i){return f[i];}\n   Mint eval(Mint x){\n      Mint res,w=1;\n      for(Mint v:f)res+=w*v,w*=x; return res;\n   }\n   FPS inv()const{\n      assert(f[0]!=0); int n=f.size();\n      FPS res(n); res.f[0]=f[0].inv();\n      for(int k=1;k<n;k<<=1){\n         FPS g(k*2),h(k*2);\n         rep(i,0,min(k*2,n))g[i]=f[i]; rep(i,0,k)h[i]=res[i];\n         g.ntt(); h.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,0,k)g[i]=0,g[i+k]*=-1;\n         g.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,k,min(k*2,n))res[i]=g[i];\n      } return res;\n   }\n   void ntt(bool inv=0){\n        int n=f.size(); if(n==1)return;\n        if(inv){\n            for(int i=1;i<n;i<<=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        f[i+j+k]*=irt[i*2-1+k];\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp;\n                    }\n                }\n            }\n            Mint mul=Mint(n).inv(); rep(i,0,n)f[i]*=mul;\n        }else{\n            for(int i=n>>1;i;i>>=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp*rt[i*2-1+k];\n                    }\n                }\n            }\n        }\n   }\n   FPS operator+(const FPS& g)const{return FPS(*this)+=g;}\n   FPS operator-(const FPS& g)const{return FPS(*this)-=g;}\n   FPS operator*(const FPS& g)const{return FPS(*this)*=g;}\n   template<class T>FPS operator*(T t)const{return FPS(*this)*=t;}\n   FPS operator/(const FPS& g)const{return FPS(*this)/=g;}\n   template<class T>FPS operator/(T t)const{return FPS(*this)/=t;}\n   FPS operator%(const FPS& g)const{return FPS(*this)%=g;}\n   FPS& operator+=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]+=g[i]; return *this;\n   }\n   FPS& operator-=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]-=g[i]; return *this;\n   }\n   FPS& operator*=(FPS g){\n      int m=f.size()+g.f.size()-1,n=1; while(n<m)n<<=1;\n      f.resize(n); g.f.resize(n);\n      ntt(); g.ntt(); rep(i,0,n)f[i]*=g[i]; \n      ntt(1); f.resize(m); return *this;\n   }\n   template<class T>FPS& operator*=(T t){for(Mint x:f)x*=t; return *this;}\n   FPS& operator/=(FPS g){\n      if(g.f.size()>f.size())return *this=FPS({0});\n      reverse(ALL(f)); reverse(ALL(g.f));\n      int n=f.size()-g.f.size()+1;\n      f.resize(n); g.f.resize(n); FPS mul=g.inv();\n      *this*=mul; f.resize(n); reverse(ALL(f)); return *this;\n   }\n   template<class T>FPS& operator/=(T t){for(Mint x:f)x/=t; return *this;}\n   FPS& operator%=(FPS g){\n      *this-=*this/g*g;\n      while(!f.empty()&&f.back()==0)f.pop_back();\n      return *this;\n   }\n   FPS sqrt(){\n      int n=f.size(); FPS res(1); res[0]=1;\n      for(int k=1;k<n;k<<=1){\n         FPS ff=*this; res.f.resize(k*2);\n         res+=ff/res; res/=2;\n      } res.f.resize(n); return res;\n   }\n   FPS diff(){\n      FPS res=*this; rep(i,0,res.f.size()-1)res[i]=res[i+1]*(i+1);\n      res.f.pop_back(); return res;\n   }\n   FPS inte(){\n      FPS res=*this; res.f.push_back(0);\n      rrep(i,res.f.size()-1,0)res[i]=res[i-1]/i;\n      res[0]=0; return res;\n   }\n   FPS log(){\n      assert(f[0]==1); FPS res=diff()*inv(); \n      res.f.resize(f.size()-1); res=res.inte(); return res;\n   }\n   FPS exp(){\n      assert(f[0]==0); int m=f.size(),n=1; while(n<m)n<<=1;\n      f.resize(n); FPS d=diff(),res(n); vector<FPS> pre;\n      for(int k=n;k;k>>=1){\n         FPS g=d; g.f.resize(k);\n         g.ntt(); pre.push_back(g);\n      }\n      auto dfs=[&](auto dfs,int l,int r,int dep)->void{\n         if(r-l==1){if(l>0)res[l]/=l; return;}\n         int m=(l+r)>>1; dfs(dfs,l,m,dep+1);\n         FPS g(r-l); rep(i,0,m-l)g[i]=res[l+i];\n         g.ntt(); rep(i,0,r-l)g[i]*=pre[dep][i]; g.ntt(1);\n         rep(i,m,r)res[i]+=g[i-l-1]; dfs(dfs,m,r,dep+1);\n      }; res[0]=1; dfs(dfs,0,n,0); res.f.resize(m); return res;\n   }\n};//need to initialize\n\nint n,t; int a[1010000];\nint cnt[501000]={};\nfactorial<> fact(501000);\nMint inv[501000];\n\nFPS<> substituteXplus(FPS<> A, Mint w) {\n   int n = (int)A.f.size();\n   for (int i = 0; i < n; i++)\n      A[i] *= fact.fact(i, 0);\n   vector<Mint> B(n);\n   Mint pw = 1;\n   for (int i = 0; i < n; i++) {\n      B[i] = pw * fact.fact(i, 1);\n      pw *= w;\n   }\n   reverse(all(B));\n   FPS<> C = A * FPS<>(B);\n   B = C.f;\n   rotate(B.begin(), B.begin() + n - 1, B.end());\n   B.resize(n);\n   for (int i = 0; i < n; i++)\n      B[i] *= fact.fact(i, 1);\n   return FPS<>(B);\n}\n/*\n   CALL INIT !!!\n*/\n\nconst int N = 500500;\nbool good[N];\nint ans[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tinit();\n\n\tint n, x, y;\n\tscanf(""%d%d%d"", &n, &x, &y);\n\tvector<Mint> a(x + 1);\n\tn++;\n\tfor (int i = 0; i <= x; i++)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint z;\n\t\tscanf(""%d"", &z);\n\t\ta[z] = 1;\n\t}\n\tvector<Mint> b = a;\n\treverse(all(b));\n\tFPS<> c = FPS<>(a) * FPS<>(b);\n\n\tfor (int i = 1; i <= x; i++)\n\t\tif (c[x + i].val != 0)\n\t\t\tgood[y + i] = 1;\n\n\tfor (int i = 0; i < N; i++)\n\t\tans[i] = -1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (!good[i]) continue;\n\t\tfor (int j = i; j < N; j += i)\n\t\t\tans[j] = 2 * i;\n\t}\n\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint z;\n\t\tscanf(""%d"", &z);\n\t\tz /= 2;\n\t\tprintf(""%d "", ans[z]);\n\t}\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']",,,"['bitmasks', 'fft', 'math', 'number theory']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Running Competition.json,https://codeforces.com//blog/entry/81506,First of all let s find all possible lengths of the laps after doing that we can just check every divisor of to find the maximum possible length of a lap for a given query A lap is always a rectangle you can t construct a lap without using any vertical segments or using an odd number of vertical segments and if you try to use or more vertical segments you can t go back to the point where you started because both horizontal segments are already partially visited So a lap is a rectangle bounded by two vertical segments and if we use vertical segments and the perimeter of this rectangle is Let s find all values that can be represented as A naive approach will be too slow we have to speed it up somehow Let s build an array of numbers where is some integer greater than Each number that can be represented as can also be represented as so we have to find all possible sums of two elements belonging to different arrays The key observation here is that if and are small we can treat each array as a polynomial let and similarly Let s look at the product of that polynomials The coefficient for is non zero if and only if there exist and such that so finding all possible sums and all possible differences can be reduced to multiplying two polynomials which can be done faster than using Karatsuba s algorithm or FFT 
https://codeforces.com//contest/933/problem/D,156721,D,933D,933,D. A Creative Cutout,Big Banban has got a piece of paper with endless lattice points where lattice points form squares with the same area His most favorite closed shape is the circle because of its beauty and simplicity Once he had obtained this piece of paper he prepares it for paper cutting He drew concentric circles on it and numbered these circles from to such that the center of each circle is the same lattice point and the radius of the th circle is times the length of a lattice edge Define the degree of beauty of a lattice point as the summation of the of circles such that this lattice point is inside them or on their bounds Banban wanted to ask you the total degree of beauty of all the lattice points but changed his mind Defining the total degree of beauty of all the lattice points on a piece of paper with circles as you are asked to figure out ,"['#include <iostream>#include <cstdio>#include <cstdlib>#include <algorithm>#include <cmath>#include <vector>#include <set>#include <map>#include <unordered_set>#include <unordered_map>#include <queue>#include <ctime>#include <cassert>#include <complex>#include <string>#include <cstring>using namespace std;\xa0#ifdef LOCAL\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)#else\t#define eprintf(...) 42#endif\xa0typedef long long ll;typedef pair<int, int> pii;#define mp make_pair\xa0const ll MOD = (ll)1e9 + 7;ll add(ll x, ll y) {\tx = (x + y) % MOD;\tif (x < 0) x += MOD;\treturn x;}ll sub(ll x, ll y) {\tx = (x - y) % MOD;\tif (x < 0) x += MOD;\treturn x;}ll mult(ll x, ll y) {\treturn ((x % MOD) * (y % MOD)) % MOD;}\xa0ll ANS = 0;\xa0const int N = 100;ll rev[N];ll M;\xa0ll get1(ll s) {\tll res = s - 1;\tres = mult(res, s);\tres = mult(res, 3 * M - 2 * s + 4);\treturn mult(res, rev[6]);}\xa0ll getC0(ll A) {\tll res = (A * A - 1) % MOD;\tres = mult(res, A * A);\tres = mult(res, 3 * M - 2 * A * A + 4);\treturn res;}ll getC1(ll A) {\tll res = 0;\tres = add(res, mult(A * A, 3 * M - 2 * A * A + 4));\tres = add(res, mult(A * A - 1, 3 * M - 2 * A * A + 4));\tres = sub(res, mult(2 * A * A, A * A - 1));\treturn res;}ll getC2(ll A) {\tll res = 3 * M - 2 * A * A + 4 - 2 * A * A - 2 * (A * A - 1);\treturn (res % MOD + MOD) % MOD;}\xa0ll getSum2(ll L) {\tll res = L;\tres = mult(res, L + 1);\tres = mult(res, 2 * L + 1);\treturn mult(rev[6], res);}ll getSum4(ll L) {\tll res = L;\tres = mult(res, L + 1);\tres = mult(res, 2 * L + 1);\tres = mult(res, 3 * mult(L, L) + 3 * L - 1);\treturn mult(rev[30], res);}ll getSum6(ll L) {\tll res = 1;\tres = sub(res, 3 * L);\tres = add(res, 6 * mult(L, L) * L);\tres = add(res, 3 * mult(mult(L, L), mult(L, L)));\tres = mult(res, L);\tres = mult(res, L + 1);\tres = mult(res, 2 * L + 1);\treturn mult(rev[42], res);}\xa0int main(){//\tfreopen(""input.txt"", ""r"", stdin);//\tfreopen(""output.txt"", ""w"", stdout);\xa0\trev[1] = 1;\tfor (ll x = 2; x < N; x++) {\t\trev[x] = (MOD - rev[MOD % x] * (MOD / x) % MOD) % MOD;\t}\xa0\tscanf(""%lld"", &M);\tll L = 0;\tfor (ll A = (ll)1e6 + 3; A > 0; A--) {\t\tif (A * A > M) continue;\t\tANS = add(ANS, mult(4, sub(get1(M + 1), get1(A * A))));\t\twhile(A * A + (L + 1) * (L + 1) <= M) L++;\t\t//cerr << A << "" "" << L << endl;\t\t//for (ll x = 1; A * A + x * x <= M; x++)\t\t//\tANS = add(ANS, mult(4, sub(get1(M + 1), get1(A * A + x * x))));\t\t\t\tll cur = mult(L, get1(M + 1));\t\tll C0 = getC0(A), C1 = getC1(A), C2 = getC2(A);\t\tcur = sub(cur, mult(rev[6], mult(C0, L)));\t\tcur = sub(cur, mult(rev[6], mult(C1, getSum2(L))));\t\tcur = sub(cur, mult(rev[6], mult(C2, getSum4(L))));\t\tcur = add(cur, mult(rev[3], getSum6(L)));\t\tANS = add(ANS, mult(4, cur));\t\t\t}\tANS = add(ANS, get1(M + 1));\tprintf(""%lld\\n"", ANS);\xa0\treturn 0;}']",,,"['brute force', 'combinatorics', 'math']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. A Creative Cutout.json,https://codeforces.com//blog/entry/57763,For the sake of explanation let s use to represent the binomial coefficient and construct a coordinate system such that each coordinate axis parallels to one of the lattice edges the origin is the center of concentric circles and each unit of length in this system is as long as the length of a lattice edge For we could figure out the contribution of each lattice point is Defining as we could conclude for the answer the contribution of each lattice point is which is a small degree polynomial of Tips prove with mathematical induction or others By using we could form the answer as where is the coefficient calculated from the original polynomial The remaining part to solve this problem is just to enumerate all the possible integers and then calculate in constant time The total complexity is By the way the standard solution has hardcoded some closed forms to calculate the partial sum of small powers fast but you can precalculate and then enumerate Please be careful with 64 bit integer overflow for example Although there is a pretest in case of to reject brute force and some solutions with obvious overflow it is highly probable to fail in the case of large input such as The probability of failure is increasing when the number increases Take care Solve the problem with 
https://codeforces.com//contest/299/problem/C,2893,C,299C,299,C. Weird Game,Yaroslav Andrey and Roman can play cubes for hours and hours But the game is for three so when Roman doesn t show up Yaroslav and Andrey play another game Roman leaves a word for each of them Each word consists of binary characters or After that the players start moving in turns Yaroslav moves first During a move a player must choose an integer from 1 to which hasn t been chosen by anybody up to that moment Then the player takes a piece of paper and writes out the corresponding character from his string Let s represent Yaroslav s word as Similarly let s represent Andrey s word as Then if Yaroslav choose number during his move then he is going to write out character on the piece of paper Similarly if Andrey choose number during his move then he is going to write out character on the piece of paper The game finishes when no player can make a move After the game is over Yaroslav makes some integer from the characters written on his piece of paper Yaroslav can arrange these characters as he wants Andrey does the same The resulting numbers can contain leading zeroes The person with the largest number wins If the numbers are equal the game ends with a draw You are given two strings and Determine the outcome of the game provided that Yaroslav and Andrey play optimally well ,"['//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define fi first\n#define se second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,1,-1};\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << "" = "" << (x) << endl;\n#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;\n\nint n;\nstring s, t;\nint a, b, c;\nint p, q, now;\n\nstring win(){\n    if(p > q) return ""First"";\n    else if(p < q) return ""Second"";\n    else return ""Draw"";\n}\n\nint main(){\n    cin >> n >> s >> t;\n    rep(i, n * 2){\n\tif(s[i] == \'1\' && t[i] == \'1\') ++a;\n\telse if(s[i] == \'1\' && t[i] == \'0\') ++b;\n\telse if(s[i] == \'0\' && t[i] == \'1\') ++c;\n    }\n    p = (a + 1) / 2;\n    q = a - p;\n    now = a;\n    if(now & 1){\n\tif(c){\n\t    --c;\n\t    ++q;\n\t    ++now;\n\t}\n\telse if(b){\n\t    --b;\n\t    ++now;\n\t}else{\n\t    cout << win() << endl;\n\t    return 0;\n\t}\n    }\n    while(now < n * 2){\n\trep(i, 2){\n\t    if(i == 0){\n\t\tif(b){\n\t\t    --b;\n\t\t    ++p;\n\t\t    ++now;\n\t\t}\n\t\telse if(c){\n\t\t    --c;\n\t\t    ++now;\n\t\t}else{\n\t\t    cout << win() << endl;\n\t\t    return 0;\n\t\t}\n\t    }else{\n\t\tif(c){\n\t\t    --c;\n\t\t    ++q;\n\t\t    ++now;\n\t\t}\n\t\telse if(b){\n\t\t    --b;\n\t\t    ++now;\n\t\t}else{\n\t\t    cout << win() << endl;\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n    }\n    cout << win() << endl;\n    return 0;\n}\n']",,,"['games', 'greedy']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Weird Game.json,https://codeforces.com/blog/entry/7516,The first observation we don t care about the actual strings all information we need number of pairs 0 0 0 1 1 0 1 1 Count that and then just follow the greedy algorithm for the first player try to get a index with 1 1 if there are some than 1 0 than 0 1 and than 0 0 For the second player similar strategy first 1 1 than 0 1 than 1 0 than 0 0 After that just compare who has more 1 
https://codeforces.com//contest/1648/problem/B,1318590,B,1648B,1648,B. Integral Array,You are given an array a of n positive integers numbered from 1 to n Let s call an array if for any two not necessarily different numbers x and y from this array x ge y the number left lfloor frac x y right rfloor x divided by y with rounding down is also in this array You are guaranteed that all numbers in a do not exceed c Your task is to check whether this array is integral ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, c;\n    std::cin >> n >> c;\n    \n    std::vector<int> cnt(c + 1), sum(c + 1);\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        cnt[x]++;\n    }\n    for (int i = 1; i <= c; i++) {\n        sum[i] = sum[i - 1] + cnt[i];\n    }\n    \n    for (int y = 1; y <= c; y++) {\n        if (!cnt[y]) {\n            continue;\n        }\n        \n        for (int i = 1; i * y <= c; i++) {\n            int r = std::min(c, i * y + y - 1);\n            if (sum[r] - sum[i * y - 1] > 0) {\n                if (cnt[i] == 0) {\n                    std::cout << ""No\\n"";\n                    return;\n                }\n            }\n        }\n    }\n    \n    std::cout << ""Yes\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'data structures', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Integral Array.json,https://codeforces.com//blog/entry/100592,Let s consider and If then but is not in so the answer is No Let s suggest that and are already given We can check if there exists such from the mentioned segment in It is done by considering array the amount of occurrences of in and prefix sums for that array Now we only need to run this check for each and To do that we can iterate through all and in increasing order If then there is definitely no such so we can consider the next This optimization speeds up the process and makes the whole solution work in 
https://codeforces.com//contest/582/problem/E,37189,E,582E,582,E. Boolean Function,In this problem we consider Boolean functions of four variables Variables and are logical and can take values 0 or 1 We will define a function using the following grammar Here large letters represent variables and small letters represent their negations For example if then character corresponds to value 1 and value character corresponds to value 0 Here character corresponds to the operation of logical AND character corresponds to the operation of logical OR You are given expression defining function where some operations and variables are missing Also you know the values of the function for some distinct sets of variable values Count the number of ways to restore the elements that are missing in the expression so that the resulting expression corresponded to the given information about function in the given variable sets As the value of the result can be rather large print its remainder modulo ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7;\n\nconst int V = 4;\n\nint L;\nchar S[600];\n// stored by a\nint dp[510][(1 << 16) + 10];\n\nint tmp[(1 << 16) + 10];\n\n// [a,b]\nvoid dfs(int a, int b) {\n\t// S[a,b] is a valid expression\n\tassert(a <= b);\n\tif(a == b) {\n\t\tassert(S[a] == '?' || ('A' <= S[a] && S[a] <= 'D') || ('a' <= S[a] && S[a] <= 'd'));\n\t\tif(S[a] == 'A' || S[a] == '?') dp[a][0b1111111100000000] = 1;\n\t\tif(S[a] == 'B' || S[a] == '?') dp[a][0b1111000011110000] = 1;\n\t\tif(S[a] == 'C' || S[a] == '?') dp[a][0b1100110011001100] = 1;\n\t\tif(S[a] == 'D' || S[a] == '?') dp[a][0b1010101010101010] = 1;\n\t\tif(S[a] == 'a' || S[a] == '?') dp[a][0b0000000011111111] = 1;\n\t\tif(S[a] == 'b' || S[a] == '?') dp[a][0b0000111100001111] = 1;\n\t\tif(S[a] == 'c' || S[a] == '?') dp[a][0b0011001100110011] = 1;\n\t\tif(S[a] == 'd' || S[a] == '?') dp[a][0b0101010101010101] = 1;\n\t} else {\n\t\t// dfs\n\t\tint m = a;\n\t\tfor(int i = 0; true; m++) {\n\t\t\tif(S[m] == '(') i++;\n\t\t\telse if(S[m] == ')') i--;\n\t\t\telse if(i == 0) break;\n\t\t}\n\t\tassert(S[m] == '?' || S[m] == '&' || S[m] == '|');\n\t\tdfs(a + 1, m - 2);\n\t\tdfs(m + 2, b - 1);\n\t\tint l = a + 1, r = m + 2;\n\t\tif(S[m] == '&' || S[m] == '?') {\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\t\tif(!(s & (1 << i))) {\n\t\t\t\t\t\tdp[l][s] += dp[l][s + (1 << i)];\n\t\t\t\t\t\tdp[l][s] %= MOD;\n\t\t\t\t\t\tdp[r][s] += dp[r][s + (1 << i)];\n\t\t\t\t\t\tdp[r][s] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\ttmp[s] = (ll(dp[l][s]) * ll(dp[r][s])) % MOD;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\t\tif(!(s & (1 << i))) {\n\t\t\t\t\t\ttmp[s] -= tmp[s + (1 << i)];\n\t\t\t\t\t\ttmp[s] %= MOD;\n\t\t\t\t\t\tdp[l][s] -= dp[l][s + (1 << i)];\n\t\t\t\t\t\tdp[l][s] %= MOD;\n\t\t\t\t\t\tdp[r][s] -= dp[r][s + (1 << i)];\n\t\t\t\t\t\tdp[r][s] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\tdp[a][s] += tmp[s];\n\t\t\t}\n\t\t}\n\t\tif(S[m] == '|' || S[m] == '?') {\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\t\tif(s & (1 << i)) {\n\t\t\t\t\t\tdp[l][s] += dp[l][s - (1 << i)];\n\t\t\t\t\t\tdp[l][s] %= MOD;\n\t\t\t\t\t\tdp[r][s] += dp[r][s - (1 << i)];\n\t\t\t\t\t\tdp[r][s] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\ttmp[s] = (ll(dp[l][s]) * ll(dp[r][s])) % MOD;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\t\tif(s & (1 << i)) {\n\t\t\t\t\t\ttmp[s] -= tmp[s - (1 << i)];\n\t\t\t\t\t\ttmp[s] %= MOD;\n\t\t\t\t\t\tdp[l][s] -= dp[l][s - (1 << i)];\n\t\t\t\t\t\tdp[l][s] %= MOD;\n\t\t\t\t\t\tdp[r][s] -= dp[r][s - (1 << i)];\n\t\t\t\t\t\tdp[r][s] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\t\tdp[a][s] += tmp[s];\n\t\t\t}\n\t\t}\n\t\tfor(int s = 0; s < (1 << 16); s++) {\n\t\t\tdp[a][s] %= MOD;\n\t\t\tif(dp[a][s] < 0) dp[a][s] += MOD;\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> S;\n\tL = int(strlen(S));\n\n\tdfs(0, L - 1);\n\tint N; cin >> N;\n\tint msk = 0;\n\tint val = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tint a, b, c, d, v;\n\t\tcin >> a >> b >> c >> d >> v;\n\t\tmsk |= (1 << (8 * a + 4 * b + 2 * c + d));\n\t\tval |= (v << (8 * a + 4 * b + 2 * c + d));\n\t}\n\tll res = 0;\n\tfor(int v = 0; v < (1 << 16); v++) {\n\t\tif((v & msk) == val) {\n\t\t\tres += dp[0][v];\n\t\t}\n\t}\n\tres %= MOD;\n\tif(res < 0) res += MOD;\n\tcout << res << '\\n';\n\treturn 0;\n}\n""]",,,"['bitmasks', 'dp', 'expression parsing']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Boolean Function.json,https://codeforces.com//blog/entry/20692,One could prove that the number of binary functions on 4 variables is equal to 224 and can be coded by storing a 24 bit binary mask in which every bit is storing function value for corresponding variable set It is true that if maskf and maskg are correspond to functions f A B C D and g A B C D then function f g A B C D corresponds to maskf maskg bitmask Now we could parse expression given input into binary tree I should notice that the number of non list nodes of such tree is about Now let s calculate dynamic programming on every vertex v dp v mask is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations dp v lmask rmask dp l lmask dp r rmask But all the task is how to make it faster One could calculate s mask where s mask is equal to sum of all its submasks the masks containing 1 bits only in positions where mask contains 1 bits in 24 224 operations using following code for int mask 0 mask 1 16 mask s mask dp x mask for int i 0 i 16 i for int mask 0 mask 1 16 mask if mask 1 i s mask 1 i s mask Let s calculate sl mask and sr mask for dp l mask and dp r mask respectively If we will find s mask sl mask sr mask s mask will contain multiplications of values of pairs of masks from left and right dp s which are submasks of mask As soon as we need pairs which in bitwise OR will give us exactly mask we should exclude pairs which in bitwise OR gives a submask of mask not equal to mask This gives us exclusion inclusion principle idea The formula of this will be where p is the parity of number of bits in mask submask Such sum could be calculated with approach above but subtracting instead of adding for int mask 0 mask 1 16 mask s mask sl mask sr mask for int i 0 i 16 i for int mask 0 mask 1 16 mask if mask 1 i s mask 1 i s mask In such way we will recalculate dynamic for one vertex in about 3 24 216 operations 
https://codeforces.com//contest/990/problem/C,188992,C,990C,990,C. Bracket Sequences Concatenation Problem,A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters 1 and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are 1 1 1 1 1 and and are not You are given n bracket sequences s 1 s 2 dots s n Calculate the number of pairs i j 1 le i j le n such that the bracket sequence s i s j is a regular bracket sequence Operation means concatenation i e If s i s j and s j s i are regular bracket sequences and i ne j then both pairs i j and j i must be counted in the answer Also if s i s i is a regular bracket sequence the pair i i must be counted in the answer ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 800015;\nconst int nil = 400005;\n\nchar tmp[Maxn];\nint n;\nint st[Maxn], mn[Maxn];\nvector <int> V[Maxn];\nll res;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%s"", tmp); int tlen = strlen(tmp);\n\t\tmn[i] = Maxn;\n\t\tfor (int j = 0; j < tlen; j++) {\n\t\t\tif (tmp[j] == \'(\') st[i]++;\n\t\t\telse st[i]--;\n\t\t\tmn[i] = min(mn[i], st[i]);\n\t\t}\n\t\tV[st[i] + nil].push_back(mn[i]);\n\t}\n\tfor (int i = 0; i < Maxn; i++) if (V[i].size())\n\t\tsort(V[i].begin(), V[i].end());\n\tfor (int i = 0; i < n; i++) if (mn[i] >= 0) {\n\t\tint ost = nil - st[i];\n\t\tint add = V[ost].end() - lower_bound(V[ost].begin(), V[ost].end(), -st[i]);\n\t\tres += add;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}']",,,['implementation'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Bracket Sequences Concatenation Problem.json,https://codeforces.com//blog/entry/59962,Let be the mirror reflection of the string For example Let string be good if it does not have a prefix which have more closing brackets than opening ones For example are good and are not The balance of the string is the difference between number of opening and closing brackets in For example 1 0 Let be the number of good strings with a balance The answer to the problem is 
https://codeforces.com//contest/433/problem/A,9707,A,433A,433,A. Kitahara Haruki s Gift,Kitahara Haruki has bought apples for Touma Kazusa and Ogiso Setsuna Now he wants to divide all the apples between the friends Each apple weights 100 grams or 200 grams Of course Kitahara Haruki doesn t want to offend any of his friend Therefore the total weight of the apples given to Touma Kazusa must be equal to the total weight of the apples given to Ogiso Setsuna But unfortunately Kitahara Haruki doesn t have a knife right now so he cannot split any apple into some parts Please tell him is it possible to divide all the apples in a fair way between his friends ,"['#include<cstdio>\n#include<cstring>\n\nint f[210], n;\n\nint main(){\n\tscanf(""%d"", &n);\n\tf[0] = 1;\n\tint sum = 0;\n\tfor(int i = 1; i <= n; i ++){\n\t\tint v;\n\t\tscanf(""%d"", &v);\n\t\tv /= 100;\n\t\tfor(int j = (n << 1); j >= 0; j --)\n\t\t\tif(f[j])\n\t\t\t\tf[j + v] = 1;\n\t\tsum += v;\n\t}\n\tif(sum & 1)\n\t\tfputs(""NO\\n"", stdout);\n\telse if(f[sum >> 1])\n\t\tfputs(""YES\\n"", stdout);\n\telse\n\t\tfputs(""NO\\n"", stdout);\n\n\treturn 0;\n}\n\n\n\n']",,,"['brute force', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Kitahara Haruki s Gift.json,https://codeforces.com//blog/entry/12397,Denote as the sum of the weight of the apples If is not an even number then the answer is obviously NO Otherwise we need to check if there is a way of choosing apples so that the sum of the weight of the chosen apples is exactly A simple approach would be to enumerate how many 200 gram apples do we choose and check if we can fill the rest with 100 gram apples We can also solve this problem using a classic knapsack DP Solution 6712942 
https://codeforces.com//contest/616/problem/D,45347,D,616D,616,D. Longest k-Good Segment,The array with integers is given Let s call the sequence of one or more consecutive elements in Also let s call the segment if it contains no more than different values Find any longest good segment As the input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\nconst int MAXN = 510000;\n\n\nint n, k;\nint arr[MAXN];\n\nint cc[1000010];\n\nint main() {\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%d"", arr + i);\n\tint bl = 0;\n\tint br = 0;\n\tint now = 0;\n\tint nk = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (now < n && (nk < k || (nk == k && cc[arr[now]] != 0))) {\n\t\t\tif (cc[arr[now]] == 0)\n\t\t\t\t++nk;\n\t\t\t++cc[arr[now]];\n\t\t\t++now;\n\t\t}\n\t\tif (now - i > br - bl)\n\t\t\tbl = i, br = now;\n\t\t--cc[arr[i]];\n\t\tif (cc[arr[i]] == 0)\n\t\t\t--nk;\n\t}\n\n\tprintf(""%d %d\\n"", bl + 1, br);\n\n\treturn 0;\n}\n\n\n']",,,"['binary search', 'data structures', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Longest k-Good Segment.json,https://codeforces.com//blog/entry/22712,This problem is given because on the Codeforces pages we often see questions like What is the method of the two pointers This problem is a typical problem that can be solved using two pointers technique Let s find for each left end the maximal right end that is a good segment Note if is a good segment then is also a good segment So the search of the maximal right end for we can start from the maximal right end for The only thing that we should do is to maintain in the array for each number the number of it s occurrences in the current segment and the number of different numbers in We should move the right end until the segment became bad and then move the left end Each of the ends will be moved exactly times C solution Complexity 
https://codeforces.com//contest/1062/problem/E,254598,E,1062E,1062,E. Company,The company X has n employees numbered from 1 through n Each employee u has a direct boss p u 1 le p u le n except for the employee 1 who has no boss It is guaranteed that values p i form a tree Employee u is said to be of employee v if u is the direct boss of v or there is an employee w such that w is in charge of v and u is the direct boss of w Also any employee is considered to be in charge of himself In addition for each employee u we define it s lv u as follow lv 1 0 lv u lv p u 1 for u neq 1 In the near future there are q possible plans for the company to operate The i th plan consists of two integers l i and r i meaning that all the employees in the range l i r i and only they are involved in this plan To operate the plan smoothly there must be a project manager who is an employee in charge of the involved employees To be precise if an employee u is chosen as the project manager for the i th plan then for every employee v in l i r i u must be in charge of v Note that u is not necessary in the range l i r i Also u is always chosen in such a way that lv u is as large as possible the higher the level is the lower the salary that the company has to pay the employee Before any plan is operated the company has JATC take a look at their plans After a glance he tells the company that for every plan it s possible to reduce the number of the involved employees by one without affecting the plan Being greedy the company asks JATC which employee they should kick out of the plan so that the level of the project manager required is as large as possible JATC has already figured out the answer and challenges you to do the same ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200006;\n\nint pin[N],pout[N];\n\nvector<int> G[N];\nint stamp=0;\nint rev[N];\nint depth[N];\nint right[N];\n\nvoid dfs(int now) {\n\t++stamp;\n\tpin[now] = stamp;\n\trev[stamp] = now;\n\tfor (int i:G[now]) {\n\t\tdepth[i] = depth[now] + 1;\n\t\tdfs(i);\n\t}\n\t++stamp;\n\tpout[now] = stamp;\n\trev[stamp] = now;\n}\n\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n\npii operator+(const pii &p1,const pii &p2) {\n\treturn make_pair(min(p1.F,p2.F),max(p1.S,p2.S));\n}\n\nconst pii ee = make_pair(1000000007,-1000000007);\n\nstruct Node {\n\tNode *lc,*rc;\n\tpii val;\n\tNode():lc(NULL),rc(NULL),val(ee){}\n\tvoid pull() {\n\t\tval = (lc->val + rc->val);\n\t}\n};\n\nNode* Build(int L,int R) {\n\tNode* node = new Node();\n\tif (L == R) {\n\t\tnode->val = make_pair(pin[L],pout[L]);\n\t\treturn node;\n\t}\n\tint mid=(L+R)>>1;\n\tnode->lc = Build(L,mid);\n\tnode->rc = Build(mid+1,R);\n\tnode->pull();\n\treturn node;\n}\n\nvoid modify(Node* node,int L,int R,int pos,pii val) {\n\tif (L==R) {\n\t\tnode->val = val;\n\t\treturn;\n\t}\n\tint mid=(L+R)>>1;\n\tif (pos <= mid) modify(node->lc,L,mid,pos,val);\n\telse modify(node->rc,mid+1,R,pos,val);\n\tnode->pull();\n\treturn;\n}\n\npii query(Node* node,int L,int R,int l,int r) {\n\tif (l>R || L>r) return ee;\n\telse if (l<=L && R<=r) return node->val;\n\tint mid=(L+R)>>1;\n\treturn (query(node->lc,L,mid,l,r) + query(node->rc,mid+1,R,l,r));\n}\nconst int P = 19;\nint lca[P][N];\n\nint Q(int L,int R) {\n\t//return id\n\tint x = rev[L];\n\tif (pin[x] <= L && R <= pout[x]) return depth[x];\n\t// cout << ""ori x = "" << x << endl;\n\tfor (int i=P-1;i>=0;--i) {\n\t\tint y = lca[i][x];\n\t\t// cout << ""y = "" << y << "" , i = "" << i << endl;\n\t\t// cout << ""pin = "" << pin[y] << "" , pout = "" << pout[y] << endl;\n\t\t// cout << ""x = "" << x << endl;\n\t\tif (pin[y] <= L && R <= pout[y]) ;\n\t\telse x = lca[i][x];\n\t}\n\t// cout << ""x = "" << x << endl;\n\treturn depth[lca[0][x]];\n}\n\nint main () {\n\tint n,q;\n\tscanf(""%d %d"",&n,&q);\n\tmap<pii,int> mp;\n\tlca[0][1] = 1;\n\tfor (int i=2;i<=n;++i) {\n\t\tint p;\n\t\tscanf(""%d"",&p);\n\t\tG[p].push_back(i);\n\t\tlca[0][i] = p;\n\t}\n\tfor (int i=1;i<P;++i) {\n\t\tfor (int j=1;j<=n;++j) {\n\t\t\tlca[i][j] = lca[i-1][ lca[i-1][j] ];\n\t\t}\n\t}\n\tdfs(1);\n\tNode* root = Build(1,n);\n\twhile (q--) {\n\t\tint l,r;\n\t\tscanf(""%d %d"",&l,&r);\n\t\tpii ret = query(root,1,n,l,r);\n\t\t// cerr << ""finish query "" << endl;\n\t\t// cerr << ""ret = "" <<ret.F << "" , "" << ret.S << endl;\n\t\tint lvl = Q(ret.F,ret.S), del = l;\n\t\t// cerr << ""lvl = "" << lvl << "" , del = "" << del << endl;\n\t\t//delete with id ret.F\n\t\tint del1 = rev[ret.F];\n\t\tpii ret1 = (query(root,1,n,l,del1-1)+query(root,1,n,del1+1,r));\n\t\tint tmplvl=Q(ret1.F,ret1.S);\n\t\tif (tmplvl > lvl) {\n\t\t\tlvl = tmplvl;\n\t\t\tdel = del1;\n\t\t}\n\t\tint del2 = rev[ret.S];\n\t\t// cerr << ""del1 = "" << del1 << "" , del2 = "" << del2 << endl;\n\t\tpii ret2 = (query(root,1,n,l,del2-1)+query(root,1,n,del2+1,r));\n\t\t// cout << ""ret2 = "" << ret2.F << "" , "" << ret2.S << endl;\n\t\t// cout << ""tmplv; = "" << tmplvl << endl;\n\t\ttmplvl = Q(ret2.F,ret2.S);\n\t\tif (tmplvl > lvl) {\n\t\t\tlvl = tmplvl;\n\t\t\tdel = del2;\n\t\t}\n\t\tprintf(""%d %d\\n"",del,lvl);\n\t}\n}']",,,"['binary search', 'data structures', 'dfs and similar', 'greedy', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Company.json,https://codeforces.com/blog/entry/63199,Let s call the time that we reach the node in depth first search and where is a child of If node is in charge of node is an ancestor of then Suppose we don t have to ignore any node then the answer to each query is the LCA of two nodes and where and are chosen so that and Proof Let be the LCA of and then For every node is an ancestor of Therefore the node that needs to be ignored is either or Suppose we ignore the query splits into two halves We find the LCA to each half and get the LCA of them We do similarly for and optimize the answer Complexity 
https://codeforces.com//contest/1312/problem/G,557983,G,1312G,1312,G. Autocompletion,You are given a set of strings S Each string consists of lowercase Latin letters For each string in this set you want to calculate the minimum number of seconds required to type this string To type a string you have to start with an empty string and transform it into the string you want to type using the following actions if the current string is t choose some lowercase Latin letter c and append it to the back of t so the current string becomes t c This action takes 1 second use autocompletion When you try to autocomplete the current string t a list of all strings s in S such that t is a prefix of s is shown to you and the strings are ordered lexicographically You can transform t into the i th string from this list in i seconds Note that you may choose any string from this list you want it is not necessarily the string you are trying to type What is the minimum number of seconds that you have to spend to type each string from S ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = (int)1e6 + 10;\nvector < pair < char, int > > g[maxN];\nint n;\nbool can[maxN];\nint dp[maxN];\nconst int INF = (int)1e9;\nint bal[maxN];\nint k;\nbool used[maxN];\nint a[maxN];\nvoid dfs(int v, int& cur) {\n    bal[v] = cur;\n    if (used[v]) {\n        cur++;\n    }\n    sort(g[v].begin(), g[v].end());\n    for (auto it : g[v]) {\n        dfs(it.second, cur);\n    }\n}\nint h[maxN];\nvoid calc(int v, int val, int sec) {\n    dp[v] = min(dp[v], val + h[v]);\n    if (used[v]) {\n        dp[v] = min(dp[v], sec + bal[v] + 1);\n    }\n    for (auto it : g[v]) {\n        h[it.second] = h[v] + 1;\n        calc(it.second, min(val, dp[v] - h[v]), min(sec, dp[v] - bal[v]));\n    }\n}\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int p;\n        char c;\n        cin >> p >> c;\n        g[p].emplace_back(c, i);\n    }\n    cin >> k;\n    for (int i = 0; i <= n; i++) {\n        dp[i] = INF;\n    }\n    for (int i = 1; i <= k; i++) {\n        cin >> a[i];\n        used[a[i]] = true;\n    }\n    dp[0] = 0;\n    int p = 1;\n    dfs(0, p);\n    calc(0, INF, INF);\n    for (int i = 1; i <= k; i++) cout << dp[a[i]] << "" "";\n    cout << \'\\n\';\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    int tst = 1;\n//    cin >> tst;\n    while (tst--) solve();\n    return 0;\n}']",,,"['data structures', 'dfs and similar', 'dp']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Autocompletion.json,https://codeforces.com//blog/entry/74640,First of all the information given in the input is the structure of a trie built on and some other strings so we can store this information in the same way as we store a trie Okay now let s calculate the number of seconds required to type each string with dynamic programming let be the number of seconds required to arrive to the th vertex of the trie For regular vertices where is the parent of vertex for vertices corresponding to strings from values should be updated with the time required to autocomplete some of the parents to the current vertex To do these updates let s calculate the answers for all strings in lexicographical order We will run DFS on the trie and maintain a segment tree on the path from the root to the current vertex In the segment tree we will store the values of where is the number of seconds required to autocomplete from to the current vertex Obviously if we are currently in a vertex representing a word from then we have to find the minimum in this segment tree and that will be the cost to get to current vertex using autocompletion How to maintain Recall that we are running DFS on trie in lexicographical order When we want to compute the answer for the first string the value of for all vertices is since our string will be the first in all autocompletion lists And here s a trick to maintain these values for other strings whenever we compute the answer for some string add on the whole tree For vertices that are ancestors of both current string and some next string this will stay and increase the cost to autocomplete the next string accordingly but for vertices which are not on the path to some next string the values of will be already deleted from the segment tree and replaced by new values so this addition does not affect them Overall this works in but it can be written in with a vector instead of a segment tree since all additions and minimum queries affect the whole structure 
https://codeforces.com//contest/301/problem/A,2969,A,301A,301,A. Yaroslav and Sequence,Yaroslav has an array consisting of integers In a single operation Yaroslav can change the sign of exactly elements in the array In other words in one operation Yaroslav can select exactly array elements and multiply each of them by 1 Yaroslav is now wondering what maximum sum of array elements can be obtained if it is allowed to perform any number of described operations Help Yaroslav ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nint a,b,c,d,n,m,k;\nint mas[202];\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\tscanf(""%d"", &n);\n\tc = 0; a = 0;\n\tb = INF;\n\trept(i, 2 * n - 1) {\n\t\tscanf(""%d"", &mas[i]);\n\t\tc += abs(mas[i]);\n\t\tif (mas[i] < 0) ++a;\n\t\tb = min(b, abs(mas[i]));\n\t}\n\tif (a >= n) {\n\t\ta -= n;\n\t}\n\tif (n % 2 == 1 || a % 2 == 0) printf(""%d\\n"", c); else\n\tprintf(""%d\\n"", c - 2 * b);\n}\n']",,,['constructive algorithms'],1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Yaroslav and Sequence.json,https://codeforces.com//blog/entry/7560,Using dfs we will find number of numbers that we can set as positive Note that we can either set all of the numbers as positive or leave one number any as negative If we can obtain all numbers as positive we just return sum of modules of the numbers but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum 
https://codeforces.com//contest/1464/problem/E,839214,E,1464E,1464,E. No Game No Life,Let s consider the following game of Alice and Bob on a directed acyclic graph Each vertex may contain an arbitrary number of chips Alice and Bob make turns alternating Alice goes first In one turn player can move exactly one chip along any edge outgoing from the vertex that contains this chip to the end of this edge The one who cannot make a turn loses Both players play optimally Consider the following process that takes place every second on a given graph with n vertices An integer v is chosen equiprobably from 1 n 1 If v leq n we add a chip to the v th vertex and go back to step 1 If v n 1 Alice and Bob play the game with the current arrangement of chips and the winner is determined After that the process is terminated Find the probability that Alice will win the game It can be shown that the answer can be represented as frac P Q where P and Q are coprime integers and Q not equiv 0 pmod 998 244 353 Print the value of P cdot Q 1 bmod 998 244 353 ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\nconst ll MOD = 998244353;\nconst ll Inv2 = (MOD + 1) / 2;\n\nint n,m,N;\nint SG[MAXN];\n\nll p[MAXN << 2];\nll q[MAXN << 2];\n\nvector<int> e[MAXN];\n\nll power(ll a,ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nvoid dfs(int u)\n{\n\tif (~SG[u])\n\t\treturn;\n\tvector<int> nxt;\n\tfor (int i = 0;i < e[u].size();i++)\n\t{\n\t\tdfs(e[u][i]);\n\t\tnxt.push_back(SG[e[u][i]]);\n\t}\n\tsort(nxt.begin(),nxt.end());\n\tint i = 0;\n\tfor (int j = 0;j < nxt.size();j++)\n\t\tif (i == nxt[j])\n\t\t\ti++;\n\tSG[u] = i;\n}\n\nvoid FWT(ll *a,bool inv)\n{\n\tfor (int i = 1;i < N;i <<= 1)\n\t\tfor (int j = 0;j < N;j += i << 1)\n\t\t\tfor (int k = 0;k < i;k++)\n\t\t\t{\n\t\t\t\tll x = a[j + k],y = a[j + k + i];\n\t\t\t\ta[j + k] = (inv ? (x + y) * Inv2 % MOD : (x + y) % MOD);\n\t\t\t\ta[j + k + i] = (inv ? (x - y) * Inv2 % MOD : (x - y) % MOD);\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"",&n,&m);\n\tN = 1;\n\twhile (N - 1 < n)\n\t\tN <<= 1;\n\tfor (int u,v,i = 1;i <= m;i++)\n\t{\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].push_back(v);\n\t}\n\tmemset(SG,-1,sizeof(SG));\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tdfs(i);\n\t\tp[SG[i]]++;\n\t}\n\tll Inv = power(n + 1,MOD - 2);\n\tfor (int i = 0;i < N;i++)\n\t\t(p[i] *= Inv) %= MOD;\n\tp[0]--;\n\tq[0] = -Inv;\n\tFWT(p,0);\n\tFWT(q,0);\n\tfor (int i = 0;i < N;i++)\n\t\tq[i] = q[i] * power(p[i],MOD - 2) % MOD;\n\tFWT(q,1);\n\tprintf(""%lld\\n"",(MOD + 1 - q[0]) % MOD);\n\treturn 0;\n}']",,,"['bitmasks', 'dp', 'games', 'math', 'matrices', 'probabilities']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. No Game No Life.json,https://codeforces.com//blog/entry/85792,The winner of the game is determined by xor of Grundy values for all chips vertices Notice that every Grundy value m so xor doesn t exceed 512 Let Pv be a probability of Alice s victory if the current xor is v Pv Pto prob v to v 0 1n 1 In the second term we got n 1 and the process ended It is clear that prob v to cnt v to n 1 where cnt x is the number of vertices with the Grundy value equal to x Now we have a system of 512 linear equations with variables Pv We can solve it using the Gauss method The answer is in P0 The proof that Gauss won t break along the way is left to the reader as an exercise There is also a solution using the Hadamard transform 
https://codeforces.com//contest/365/problem/A,4036,A,365A,365,A. Good Number,Let s call a number good if it contains all digits not exceeding You ve got a number and an array containing numbers Find out how many good numbers are in count each number every time it occurs in array ,"['#include <stdio.h>\n#include <string.h>\n\nint main(){\n\n    int test;\n    int k;\n    bool flag[10];\n    int in,ans=0;\n\n    for( scanf(""%d%d"",&test,&k) ; test-- ; ){\n        memset(flag,0,sizeof(flag));\n        for( scanf(""%d"",&in); in ; in/=10 ){\n            flag[in%10]=1;  \n        }\n        \n        for( int i=0 ; i<=k ; i++ ) if(flag[i]==false ) goto fail;\n        \n        ans++;\n        fail:;\n        \n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n']",,,['implementation'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Good Number.json,https://codeforces.com//blog/entry/9657,Task was to find the least digit that is not contained in the given number and compare with given k 
https://codeforces.com//contest/1695/problem/D1,1432674,D1,1695D1,1695,D1. Tree Queries  Easy Version ,You are given an unrooted tree with n vertices There is some hidden vertex x in that tree that you are trying to find To do this you may ask k queries v 1 v 2 ldots v k where the v i are vertices in the tree After you are finished asking all of the queries you are given k numbers d 1 d 2 ldots d k where d i is the number of edges on the shortest path between v i and x Note that you know which distance corresponds to which query What is the minimum k such that there exists some queries v 1 v 2 ldots v k that let you always uniquely identify x no matter what x is Note that you don t actually need to output these queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5, INF = 1e9;\n\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int fa) {\n    int cnt = 0, cnt2 = 0;\n    for (auto v : adj[u]) {\n        if (v == fa) continue;\n        cnt += dfs(v, u);\n        ++cnt2;\n    }\n    if (cnt != cnt2 && adj[u].size() >= 3) --ans;\n    return (cnt > 0) | (adj[u].size() >= 3);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n;\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        \n        if (n == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        for (int i = 0; i < n; i++) adj[i].clear();\n\n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        ans = 0;\n        for (int i = 0; i < n; i++) ans += (adj[i].size() == 1);\n\n        int id = -1;\n        for (int i = 0; i < n; i++) {\n            if (adj[i].size() >= 3) {\n                id = i;\n                break;\n            }\n        }\n        if (id == -1) {\n            cout << 1 << endl;\n            continue;\n        }\n        dfs(id, id);\n        cout << ans << endl;\n    }\n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'dfs and similar', 'dp', 'greedy', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D1. Tree Queries  Easy Version .json,https://codeforces.com//blog/entry/103996,If then no queries are needed because there is only one vertex Otherwise we need at least one query If we fix a node and force it to be a query we can root the tree at and do a greedy DFS to compute the answer Note that because we guarantee that the root is a query when we are computing the answer for any node in this DFS we can assume that either or some vertex not in the subtree of has already been queried We define to be the minimal number of queries to distinguish all vertices in the subtree of given that or some vertex not in the subtree of has been queried Note that for each child of we need to be able to distinguish all vertices in the subtree of so we have Additionally there can be at most one child of with no queries in its subtree otherwise all of these children will be indistinguishable by the queries If there are such children of we can query the first of them which will be enough to differentiate all vertices in these subtrees So using this definition of our final formula isFor each possible root we do a DFS to recursively compute these answers The answer is the minimum where the is to account for the fact that we are querying the root Complexity O n 2 
https://codeforces.com//contest/148/problem/A,879,A,148A,148,A. Insomnia cure,One dragon Two dragon Three dragon the princess was counting She had trouble falling asleep and she got bored of counting lambs when she was nine However just counting dragons was boring as well so she entertained herself at best she could Tonight she imagined that all dragons were here to steal her and she was fighting them off Every th dragon got punched in the face with a frying pan Every th dragon got his tail shut into the balcony door Every th dragon got his paws trampled with sharp heels Finally she threatened every th dragon to call her mom and he withdrew in panic How many imaginary dragons suffered moral or physical damage tonight if the princess counted a total of dragons ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint n;\nstring s="""";\nint main()\n{\n    int i,j,k;\n    int ans=0;\n    int a,b,c,d,x=0;\n    cin>>a>>b>>c>>d>>k;\n    for (i=1;i<=k;i++)\n    {\n        x=0;\n        if (i%a==0)x++;\n        else if (i%b==0)x++;\n        else if (i%c==0)x++;\n        else if (i%d==0)x++;\n        ans+=x;\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}']",,,"['constructive algorithms', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Insomnia cure.json,https://codeforces.com//blog/entry/3819,The number of dragons D can be quite small so the problem can be solved in a straightforward way by iterating over dragons 1 through D and checking each dragon individually Time complexity of such solution is O D There exists a smarter solution with O 1 complexity based on inclusion exclusion principle You ll have to count the numbers of dragons which satisfy at least one two three or four of the damage conditions i e dragons who have index divisible by LCM of the corresponding sets of numbers Remember that the number of numbers between 1 and D which are divisible by T equals Finally the number of dragons that get damaged equals You d have to use this method if the total number of dragons was too large for iterating over it 
https://codeforces.com//contest/144/problem/C,783,C,144C,144,C. Anagram Search,A string is called an of the string if it is possible to rearrange letters in so that it is identical to the string For example the string is an anagram of the string and the string is not The string is called a of the string if it can be read starting from some position in the string For example the string has six substrings You are given a string consisting of lowercase Latin letters and characters You are also given a string consisting of lowercase Latin letters only Let s assume that a string is if you can obtain an anagram of the string from it replacing the characters by Latin letters Each can be replaced by exactly one character of the Latin alphabet For example if the string then the string is good and the string is not Your task is to find the number of good substrings of the string identical substrings must be counted in the answer several times ,"[""#include <string>\n#include <algorithm>\n#include <utility>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <utility>\n#include <time.h>\n#include <string.h>\nusing namespace std;\n\n\nint main( void )\n{\n\tvector<char> S;\n\tvector<int> P(26);\n\tvector<int> cur(26);\n\tint Plen = 0;\n\n\tint c;\n\twhile( (c = getchar()) != '\\n' ){\n\t\tS.push_back(c);\n\t}\n\twhile( (c = getchar()) != '\\n' ){\n\t\tP[c-'a'] ++;\n\t\tPlen ++;\n\t}\n\tif( Plen > S.size() ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\t// Plen <= S.size()\n\tfor( int j = 0; j < Plen; j ++ )\n\t\tif( S[j] != '?' )\n\t\t\tcur[S[j]-'a'] ++;\n\n\tint ans = 0;\n\tfor( int i = 0; i < S.size(); i ++ ){\n\t\tfor( int t = 0; t < 26; t ++ )\n\t\t\tif( cur[t] > P[t] ) goto NG;\n\t\t++ ans;\n\t\tNG:;\n\t\tif( S[i] != '?' )\n\t\t\tcur[S[i]-'a'] --;\n\t\tint j = i + Plen;\n\t\tif( j >= S.size() ) break;\n\t\tif( S[j] != '?' )\n\t\t\tcur[S[j]-'a'] ++;\n\t}\n\tcout << ans << endl;\n\n}\n""]",,,"['implementation', 'strings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Anagram Search.json,https://codeforces.com//blog/entry/3693,Let s count number of each letter in the second string and save it for example in array a 1 26 For the first strings prefix of length n where n is the length of second string it s the first substring we count number of each letter in array b 1 26 We don t count characters texttt If there are b i a i for all i then it s good substring Then go to the second substring subtract from the array b the first character b s 1 a 1 and add n 1 character b s n 1 a 1 If some of these characters is texttt then we shouldn t do for it the subtraction or addition Then repeat the showed check and go to the next substring Let s repeat this procedure for all substrings of length n 
https://codeforces.com//contest/1858/problem/D,2166169,D,1858D,1858,D. Trees and Segments,The teachers of the Summer Informatics School decided to plant n trees in a row and it was decided to plant only oaks and firs To do this they made a plan which can be represented as a binary string s of length n If s i 0 then the i th tree in the row should be an oak and if s i 1 then the i th tree in the row should be a fir The day of tree planting is tomorrow and the day after tomorrow an inspector will come to the School The inspector loves nature very much and he will evaluate the beauty of the row as follows First he will calculate l 0 as the maximum number of consecutive oaks in the row the maximum substring consisting of zeros in the plan s If there are no oaks in the row then l 0 0 Then he will calculate l 1 as the maximum number of consecutive firs in the row the maximum substring consisting of ones in the plan s If there are no firs in the row then l 1 0 Finally he will calculate the of the row as a cdot l 0 l 1 for some a the inspector s favourite number The teachers know the value of the parameter a but for security reasons they cannot tell it to you They only told you that a is an integer from 1 to n Since the trees have not yet been planted the teachers decided to change the type of no more than k trees to the opposite i e change s i from 0 to 1 or from 1 to 0 in the plan in order to maximize the beauty of the row of trees according to the inspector For each integer j from 1 to n answer the following question What is the maximum beauty of the row of trees that the teachers can achieve by changing the type of no more than k trees if the inspector s favourite number a is equal to j ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""debug.h""\n#else\n#define debug(...)\n#endif\n\nconst int N = 3005;\n\nint n, k;\nstring s;\nint mx1[N + 1];\nint ps[N + 1];\nint f[N + 1][N];\nint g[N + 1][N];\n\nint sum(int l, int r) { return ps[r + 1] - ps[l]; }\n\nvoid solve() {\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == \'1\');\n  for (int op = 0; op <= k; op++) {\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n      while (j <= i && sum(j, i) > op) j++;\n      if (j <= i) {\n        f[op][i] = i - j + 1;\n      } else {\n        f[op][i] = -1e9;\n      }\n      if (i > 0) f[op][i] = max(f[op][i], f[op][i - 1]);\n    }\n  }\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == \'0\');\n  for (int op = 0; op <= k; op++) {\n    int j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n      while (j >= i && sum(i, j) > op) j--;\n      if (j >= i) {\n        g[op][i] = j - i + 1;\n      } else {\n        g[op][i] = -1e9;\n      }\n      if (i < n - 1) g[op][i] = max(g[op][i], g[op][i + 1]);\n    }\n  }\n  for (int u = 0; u <= k; u++) {\n    if (f[u][n - 1] >= 0) {\n      mx1[f[u][n - 1]] = max(mx1[f[u][n - 1]], 0);\n    }\n    if (g[u][0] >= 0) {\n      mx1[0] = max(mx1[0], g[u][0]);\n    }\n    for (int i = 0; i < n - 1; i++) {\n      if (f[u][i] >= 0) {\n        mx1[f[u][i]] = max(mx1[f[u][i]], g[k - u][i + 1]);\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    cin >> s;\n    for (int i = 0; i <= n; i++) {\n      mx1[i] = -1e9;\n    }\n    solve();\n    reverse(s.begin(), s.end());\n    solve();\n    for (int a = 1; a <= n; a++) {\n      int ans = 0;\n      for (int i = 0; i <= n; i++) ans = max(ans, i * a + mx1[i]);\n      cout << ans << "" \\n""[a == n];\n    }\n  }\n}']",,,"['brute force', 'data structures', 'dp', 'greedy', 'two pointers']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Trees and Segments.json,https://codeforces.com//blog/entry/119398,There are many various dynamic programming solutions of this problem We will describe one of them Let s calculate the dynamics the length of the longest subsegment of zeros that can be obtained on the prefix up to which ends at index and costs exactly operations Similarly is the length of the longest subsegment of zeros on the suffix starting at which starts at index and costs exactly operations Such dynamics can be easily computed In the first case we simply prolong the existing subsegment of zeros in the second case we change the current to spending one operation on it so if have operations left we cannot do anything and the value of the dynamics is meaning the segment has ended can be calculated similarly Let s update both dynamics in such a way that will mean the maximum length of a subsegment of zeros that ends no later than and costs no more than operations This can be easily done by updating with the value of and then with Similarly we update the second dynamics Now let s consider a subsegment that we want to convert into a segment of ones We can easily calculate the number of operations that we will need we ll just need to calculate the number of zeros in such a segment Now calculate the new dynamics for the length of the segment of ones which equals the maximum length of a subsegment of zeros that we can obtain Update this value with Then to answer the question for a fixed number we can iterate over the length of the segment of ones that will be in our answer and update the answer with the value if there exists a value for in the dynamics The complexity is Solutions with complexity and using various optimizations of the dynamics also exist 
https://codeforces.com//contest/27/problem/A,124,A,27A,27,A. Next Test,Polygon is a system which allows to create programming tasks in a simple and professional way When you add a test to the problem the corresponding form asks you for the test index As in most cases it is clear which index the next test will have the system suggests the default value of the index It is calculated as the smallest positive integer which is not used as an index for some previously added test You are to implement this feature Create a program which determines the default index of the next test given the indexes of the previously added tests ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<list>\n#include<set>\n#include<queue>\n#include<cassert>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define LET(x,a) \t__typeof(a) x(a)\n#define IFOR(i,a,b) \tfor(LET(i,a);i!=(b);++i)\n#define EACH(it,v)  \tIFOR(it,v.begin(),v.end())\n#define FOR(i,a,b)  \tfor(int i=(int)(a) ; i < (int)(b);++i)\n#define REP(i,n) \tFOR(i,0,n)\n#define PB\t\tpush_back\n#define MP \t\tmake_pair\n#define EPS\t\t1e-9\n#define INF 2000000000\n\ntypedef vector<int>\tVI;\ntypedef long long\tLL;\ntypedef pair<int,int>\tPI;\n\nbool visited[5000];\n\nint main(){\n\tint n;cin>>n;\n\tmemset(visited,false,sizeof(visited));\n\tREP(i,n){\n\t\tint tmp;cin>>tmp;\n\t\tvisited[tmp]=true;\n\t}\n\tint ans;\n\tFOR(i,1,4000){\n\t\tif(!visited[i]){\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']",,,"['implementation', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Next Test.json,https://codeforces.com//blog/entry/653,We will create an array of boolean used 1 3001 ans fill it with false values For each of n given number we will assign corresponding used value to true After that the index of first element of used with false value is the answer to the problem 
https://codeforces.com//contest/1669/problem/D,1375141,D,1669D,1669,D. Colorful Stamp,A row of n cells is given all initially white Using a stamp you can stamp any two neighboring cells such that one becomes red and the other becomes blue A stamp can be rotated i e it can be used in both ways as color blue texttt B color red texttt R and as color red texttt R color blue texttt B During use the stamp must completely fit on the given n cells it cannot be partially outside the cells The stamp can be applied multiple times to the same cell Each usage of the stamp recolors both cells that are under the stamp For example one possible sequence of stamps to make the picture color blue texttt B color red texttt R color blue texttt B color blue texttt B texttt W could be texttt WWWWW to texttt WW color brown underline color red texttt R color blue texttt B texttt W to color brown underline color blue texttt B color red texttt R color red texttt R color blue texttt B texttt W to color blue texttt B color brown underline color red texttt R color blue texttt B color blue texttt B texttt W Here texttt W color red texttt R and color blue texttt B represent a white red or blue cell respectively and the cells that the stamp is used on are marked with an underline Given a final picture is it possible to make it using the stamp zero or more times ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  bool ok1 = 0, ok2 = 0;\n  for(int i = 0; i < s.size(); ++i){\n    if(s[i] == \'R\') ok1 = 1;\n    else if(s[i] == \'B\') ok2 = 1;\n  \n    if(i == sz(s) - 1 || s[i] == \'W\'){\n      if(ok1 != ok2){\n        cout << ""NO\\n"";\n        return;\n      }\n      ok1 = ok2 = 0;\n    }\n  }\n  cout << ""YES\\n"";\n}\n\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << ""Case #"" << i << "": "";\n      solve();\n    }\n    return 0;\n}   ']",,,['implementation'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Colorful Stamp.json,https://codeforces.com//blog/entry/102101,First note that parts of the picture separated by are independent That is any stamps used on one part doesn t have any impact on the other since a character means no stamp has been placed on that cell So let s split the string by s for example with method in Python and consider the resulting strings containing only and Call one of these parts In the final stamp we place on we must have placed so it should have both the characters and Therefore if the string has only or only the answer is Otherwise the answer is Let s show it As we have just shown we must have next to for the string to be possible Consider the way to make The final stamp can be For the rest of the cells we can make them one by one as below so now we have made the prefix of the string before the final stamp Similarly Now we have made the prefix and the suffix by stamping one character at a time actually we stamp two characters but then cover it up with another stamp Finally we can put the final stamp to make the whole string This method easily generalizes to any string We can find the final stamp and then make the prefix and suffix one by one The solution runs in 
https://codeforces.com//contest/2013/problem/B,2890587,B,2013B,2013,B. Battle for Survive,Eralim being the mafia boss manages a group of n fighters Fighter i has a rating of a i Eralim arranges a tournament of n 1 battles in each of which two not yet eliminated fighters i and j are chosen and as a result of the battle fighter i is eliminated from the tournament and the rating of fighter j is reduced by the rating of fighter i That is a j is decreased by a i Note that fighter j s rating can become negative The fighters indexes do not change Eralim wants to know what maximum rating the last remaining fighter can preserve if he chooses the battles optimally ,"['#include <bits/stdc++.h>using namespace std;\xa0typedef long long ll;using vi = vector<int>;using vvi = vector<vector<int>>;using vll = vector<ll>;using vvll = vector<vector<ll>>;\xa0#define all(x) x.begin(), x.end()#define ckmin(a,b) a = min(a,b)#define ckmax(a,b) a = max(a,b)\xa0void solve() {    int N;    cin >> N;        vll A(N);    for (int i=0;i<N;i++) cin >> A[i];\xa0    ll ans = 0;    for (ll a : A) ans += a;    ans -= 2 * A[N-2];    cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(NULL);\xa0    int T;    cin >> T;    for (int t=0;t<T;t++) solve();\xa0\xa0    return 0;}']",,,"['constructive algorithms', 'greedy', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Battle for Survive.json,https://codeforces.com/blog/entry/134170,SolutionIt can be noted that the value of will always be negative in the final result Therefore we can subtract the sum from and then subtract from Thus the final sum will be This value cannot be exceeded because will always be negative 
https://codeforces.com//contest/1216/problem/E1,416604,E1,1216E1,1216,E1. Numerical Sequence  easy version , You are given an sequence of form which consist of blocks of all consecutive positive integers written one after another The first block consists of all numbers from 1 to 1 the second one from 1 to 2 the third one from 1 to 3 dots the i th block consists of all numbers from 1 to i So the first 56 elements of the sequence are Elements of the sequence are numbered from one For example the 1 st element of the sequence is 1 the 3 rd element of the sequence is 2 the 20 th element of the sequence is 5 the 38 th element is 2 the 56 th element of the sequence is 0 Your task is to answer q independent queries In the i th query you are given one integer k i Calculate the digit at the position k i of the sequence ,"['//#pragma GCC optimize(2)\n//#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define LL long long\n#define re register\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\n#define lson (node<<1)\n#define rson (node<<1|1)\nusing namespace std;\nconst int N=400004;\nconst int p=998244353;\n\nvoid read(int &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<\'0\'||ch>\'9\';ch=getchar());\n\tfor(;ch>=\'0\'&&ch<=\'9\';ch=getchar()) x=(x<<3)+(x<<1)+ch-\'0\';\n}\n\nvoid read(LL &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<\'0\'||ch>\'9\';ch=getchar());\n\tfor(;ch>=\'0\'&&ch<=\'9\';ch=getchar()) x=(x<<3)+(x<<1)+ch-\'0\';\n}\n\nLL cal(LL x,LL y){\n\tif (x>y) return 0;\n\treturn (x+y)*(y-x+1)/2;\n}\n\nLL check(LL n){\n\tif (n==0) return 0;\n\tLL x=10,s=1,ans=0;\n\twhile(x-1<=n){\n\t\tans+=s*cal(n+1-(x-1),n+1-(x/10));\n\t\tx*=10;s++;\n\t}\n\tans+=s*cal(n+1-n,n+1-(x/10));\n\treturn ans;\n}\n\nLL check2(LL n){\n\tif (n==0) return 0;\n\tLL x=10,s=1,ans=0;\n\twhile(x-1<=n){\n\t\tans+=s*(x-x/10);\n\t\tx*=10;s++;\n\t}\n\tans+=s*(n-x/10+1);\n\treturn ans;\n}\n\nint s[N],len;\nvoid prt(LL n,int w){\n\tlen=0;\n\twhile(n) s[++len]=n%10,n/=10;\n\tprintf(""%d\\n"",s[len-w+1]);\n}\n\nvoid solve(LL n){\n\tLL L=0,r=1e9;\n\twhile(L<r){\n\t\tLL mid=(L+r+1)>>1;\n\t\tif (check(mid)<n) L=mid;\n\t\t else r=mid-1;\n\t}\n\tn-=check(L);\n\t//cout<<check(L)<<endl;\n\tr=L+1,L=0;\n\twhile(L<r){\n\t\tLL mid=(L+r+1)>>1;\n\t\tif (check2(mid)<n) L=mid;\n\t\t else r=mid-1;\n\t}\n\tn-=check2(L);\n\tprt(L+1,n);\n}\n\nint main(){\n\tint T;LL n;\n\t//cout<<check(1)<<endl;\n\t//cout<<check(2)<<endl;\n\t//cout<<check(10)<<endl;\n\tread(T);\n\twhile(T--){\n\t\tread(n);\n\t\tsolve(n);\n\t}\n\treturn 0;\n}']",,,"['binary search', 'brute force', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E1. Numerical Sequence  easy version .json,https://codeforces.com//blog/entry/69954,Let s take a look on the upper bound of the number where is the maximum possible number of block which can be asked If we assume that each number has length then the sum of lengths will be equal to And as we know this value equals So the maximum value of is not greater than Now we can just iterate over all from to where is no more than and carry the length of the last block If this length is greater than or equal to indexed then let s decrease by this length increase the length of the last block and continue Otherwise our answer lies in the current block So then let s iterate over all from to and if the decimal length of is greater than or equal to then decrease by this length otherwise our answer lies in the current number and we just need to print indexed Time complexity per query 
https://codeforces.com//contest/1660/problem/A,1349755,A,1660A,1660,A. Vasya and Coins,Vasya decided to go to the grocery store He found in his wallet a coins of 1 burle and b coins of 2 burles He does not yet know the total cost of all goods so help him find out s s 0 the positive integer amount of money he pay without change or pay at all using only his coins For example if a 1 and b 1 he has one 1 burle coin and one 2 burle coin then he can pay 1 burle without change paying with one 1 burle coin he can pay 2 burle without change paying with one 2 burle coin he can pay 3 burle without change by paying with one 1 burle coin and one 2 burle coin he cannot pay 4 burle without change moreover he cannot pay this amount at all So for a 1 and b 1 the answer is s 4 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  int a, b;\n  cin >> a >> b;\n  if (a == 0) {\n    cout << ""1\\n"";\n  } else {\n    cout << 2 * b + a + 1 << \'\\n\';\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Vasya and Coins.json,https://codeforces.com//blog/entry/101526,If Vasya has coins of burles then he can collect amounts of burls If Vasya does not have burles coins then he cannot collect the amount of burle If he has at least one coin in burl he can score odd amounts up to The following burl coins increase the maximum amount he can make If Vasya has coins for burle he can make up the amount of burles and not anymore 
https://codeforces.com//contest/1213/problem/F,399405,F,1213F,1213,F. Unstable String Sort,Authors have come up with the string s consisting of n lowercase Latin letters You are given two permutations of its indices not necessary equal p and q both of length n Recall that the permutation is the array of length n which contains each integer from 1 to n exactly once For all i from 1 to n 1 the following properties hold s p i le s p i 1 and s q i le s q i 1 It means that if you will write down all characters of s in order of permutation indices the resulting string will be sorted in the non decreasing order Your task is to restore such string s of length n consisting of which suits the given permutations If there are multiple answers you can print any of them ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint p[N], q[N], idx[N];\n\nint dsu[N], rmax[N];\n\nint root(int u) {\n    return ((u == dsu[u]) ? u : dsu[u] = root(dsu[u]));\n}\n\nvoid uni(int u,int v) {\n    u = root(u), v = root(v);\n    if(u == v) return;\n    dsu[v] = u;\n}\n\nvoid connect(int i1,int i2) {\n    while(i2 > i1) {\n        uni(i2 - 1, i2);\n        i2 = dsu[i2];\n    }\n}\n\nchar val[N], ans[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n, k;\n    cin >> n >> k;\n    fr(i, 1, n) {\n        dsu[i] = i;\n    }\n    fr(i, 1, n) {\n        cin >> p[i];\n        idx[p[i]] = i;\n    }\n    fr(i, 1, n) {\n        cin >> q[i];\n    }\n    fr(i, 1, n - 1) {\n        int i1 = idx[q[i]], i2 = idx[q[i + 1]];\n        if(i2 < i1) {\n            connect(i2, i1);\n        }\n    }\n    int c = 0;\n    char ch = \'a\';\n    fr(i ,1, n) {\n        if(dsu[i] == i) {\n            c++;\n            val[i] = ch;\n            if(ch < \'z\') ch++;\n        }\n    }\n    if(c < k) {\n        cout << ""NO"";\n        return 0;\n    }\n    fr(i, 1, n) {\n        ans[p[i]] = val[root(i)];\n    }\n    cout << ""YES"" << endl;\n    fr(i, 1, n) {\n        cout << ans[i];\n    }\n    return 0;\n}']",,,"['data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'strings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Unstable String Sort.json,https://codeforces.com//blog/entry/69464,Because if we write down all characters of in order of both permutations and this string will be sorted it is obvious that these two strings are equal Let s try the maximum possible number of distinct characters and then replace extra characters with How to find the maximum number of distinct characters Let s iterate over all values of and in order from left to right If we staying at the position now let s add to the set the value and to the set the value And when these sets become equal the first time let s say that the block of positions such that values are in the set right now have the same letter and then clear both sets We can see that this segment of positions is the minimum by inclusion set that can contain equal letters We don t need to compare sets naively and clear them naively you can see implementation details in author s solution If the number of such segments is less than then the answer is otherwise the answer is and we can fill the string with letters in order of these segments if the segment is then all characters of with indices has the same letter the first segment has the letter the second one has the letter and so on all segments after th has the letter Time complexity 
https://codeforces.com//contest/1556/problem/C,1093324,C,1556C,1556,C. Compressed Bracket Sequence,William has a favorite bracket sequence Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c 1 c 2 dots c n where c i is the number of consecutive brackets if i is an odd number or the number of consecutive brackets if i is an even number For example for a bracket sequence a corresponding sequence of numbers is 3 2 1 3 You need to find the total number of continuous subsequences subsegments l r l le r of the original bracket sequence which are regular bracket sequences A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 1005;\nint x[maxn];\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) scanf(""%d"", &x[i]);\n    ll ans = 0;\n    for (int i = 1; i <= n; i += 2) {\n        ll sum = 0, lb = 0;\n        for (int j = i + 1; j <= n; j++) {\n            if (j % 2 == 0) {\n                ll dif = -sum;\n                ll l = -lb;\n                chkmax(l, 1ll);\n                chkmax(l, 1 + dif);\n                ll r = x[i];\n                chkmin(r, x[j] + dif);\n                if (r >= l) ans += r - l + 1;\n            }\n            if (j % 2) sum += x[j];\n            else sum -= x[j];\n            chkmin(lb, sum);\n            if (j % 2) continue;\n        }\n    }\n    cout << ans << endl;\n    return (0-0); //<3\n}']",,,"['brute force', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Compressed Bracket Sequence.json,https://codeforces.com//blog/entry/94384,Let s examine a compressed sequence and fix two indexes l r l 2 0 r 2 1 Note that it makes no sense to examine other indexes because the correct bracket sequence always begins with the opening bracket and ends with the closing one Next we can calculate the minimum bracket balance on the segment from l 1 to r 1 The minimum bracket balance is the minimum number of opening brackets that we must put before the sequence of brackets in order for it to be regular provided that we can put any number of closing brackets at the end Let s denote this number as minBalance and denote the sum of cl 1 cl 2 cl 2 as balance The next observation is that if we fix the number of opening brackets taken from cl then we can count the number of brackets that we should take from cr Using these observations we can calculate the answer for l r using the following formula min cl cr balance max 1 minBalance 1 Note that this problem could also be solved in O n but this was not required 
https://codeforces.com//contest/1038/problem/C,216023,C,1038C,1038,C. Gambling,Two players A and B have a list of n integers each They both want to maximize the subtraction between their score and their opponent s score In one turn a player can either add to his score any element from his list assuming his list is not empty the element is removed from the list afterward Or remove an element from his opponent s list assuming his opponent s list is not empty Note that in case there are equal elements in the list only one of them will be affected in the operations above For example if there are elements 1 2 2 3 in a list and you decided to choose 2 for the next turn only a single instance of 2 will be deleted and added to the score if necessary The player A starts the game and the game stops when both lists are empty Find the difference between A s score and B s score at the end of the game if both of the players are playing optimally Optimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves In this problem it means that each player each time makes a move which maximizes the final difference between his score and his opponent s score knowing that the opponent is doing the same ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(""%lld"", &x); return x;}\nvoid read(char *s){scanf(""%s"", s);}\nvoid no(){printf(""No""); exit(0);}\n\n#define maxn 120000\n#define maxm\n\nmultiset<LL, greater<int> > a, b;\n\nint main(){\n\tLL ans = 0;\n\tint n = read();\n\tfor(int i = 0; i < n; i += 1) a.insert(read());\n\tfor(int i = 0; i < n; i += 1) b.insert(read());\n\tfor(int i = 0; i < n; i += 1){\n\t\tif(a.empty()) b.erase(b.begin());\n\t\telse{\n\t\t\tif(b.empty()){\n\t\t\t\tans += *a.begin();\n\t\t\t\ta.erase(a.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(*a.begin() < *b.begin()) b.erase(b.begin());\n\t\t\t\telse{\n\t\t\t\t\tans += *a.begin();\n\t\t\t\t\ta.erase(a.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(b.empty()) a.erase(a.begin());\n\t\telse{\n\t\t\tif(a.empty()){\n\t\t\t\tans -= *b.begin();\n\t\t\t\tb.erase(b.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(*b.begin() < *a.begin()) a.erase(a.begin());\n\t\t\t\telse{\n\t\t\t\t\tans -= *b.begin();\n\t\t\t\t\tb.erase(b.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"", ans);\n}']",,,"['greedy', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Gambling.json,https://codeforces.com/blog/entry/61692,This problem was greedy First it is obvious that both the players will try to either take their own maximum value or remove the opponent s maximum value Hence the arrays should be sorted and two pointers should be maintained to keep track of how many elements from each array have been counted removed already In every move if the person has a choice to either take his own value or remove his opponent s value then he will make the choice dependent on the values of and In fact it turns out that it is optimal just to select the choice with a greater number in case of tie any will do How to prove it One can show by induction that it does the same as the dynamic programming of size However there is a more nice way Let s say that initially each player gets of all numbers in his list This way when you choose a number from your own list you add the rest of it to the score And when you remove the number from opponent s list you remove the of it from your opponent s score Clearly all moves become symmetrical to both players now So each player can make a decision just based on which of the moves is greater If then he will take his number If he will discard the opponent s number If he can make either of the above moves it will not make a difference Complexity 
https://codeforces.com//contest/1535/problem/E,1005286,E,1535E,1535,E. Gold Transfer,You are given a rooted tree Each vertex contains a i tons of gold which costs c i per one ton Initially the tree consists only a root numbered 0 with a 0 tons of gold and price c 0 per ton There are q queries Each query has one of two types Add vertex i where i is an index of query as a son to some vertex p i vertex i will have a i tons of gold with c i per ton It s guaranteed that c i c p i For a given vertex v i consider the simple path from v i to the root We need to purchase w i tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy x tons of gold in some vertex v the remaining amount of gold in it decreases by x of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst int LOG = 19;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int q, a0, c0;\n  cin >> q >> a0 >> c0;\n  vector<int> A(1), C(1);\n  A[0] = a0;\n  C[0] = c0;\n  int N = 1;\n  vector<int> d(1, 0);\n  vector<int> P(1, -1);\n  vector<vector<int>> pp(LOG, vector<int>(1, -1));\n  vector<int> id(q + 1, -1);\n  id[0] = 0;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 1){\n      id[i + 1] = N;\n      int p, a, c;\n      cin >> p >> a >> c;\n      p = id[p];\n      P.push_back(p);\n      A.push_back(a);\n      C.push_back(c);\n      int d2 = d[p] + 1;\n      d.push_back(d2);\n      pp[0].push_back(p);\n      for (int j = 0; j < LOG - 1; j++){\n        if (pp[j][N] == -1){\n          pp[j + 1].push_back(-1);\n        } else {\n          pp[j + 1].push_back(pp[j][pp[j][N]]);\n        }\n      }\n      N++;\n    }\n    if (t == 2){\n      int v, w;\n      cin >> v >> w;\n      v = id[v];\n      if (A[v] == 0){\n        cout << 0 << ' ' << 0 << endl;\n      } else {\n        int p = v;\n        for (int j = LOG - 1; j >= 0; j--){\n          int p2 = pp[j][p];\n          if (p2 != -1){\n            if (A[p2] > 0){\n              p = p2;\n            }\n          }\n        }\n        int D = d[v] - d[p];\n        int ans1 = 0;\n        long long ans2 = 0;\n        for (int j = D; j >= 0; j--){\n          int v2 = v;\n          for (int k = 0; k < LOG; k++){\n            if ((j >> k & 1) == 1){\n              v2 = pp[k][v2];\n            }\n          }\n          int a = min(A[v2], w);\n          ans1 += a;\n          ans2 += (long long) C[v2] * a;\n          w -= a;\n          A[v2] -= a;\n          if (w == 0){\n            break;\n          }\n        }\n        cout << ans1 << ' ' << ans2 << endl;\n      }\n    }\n  }\n}""]",,,"['binary search', 'data structures', 'dp', 'greedy', 'interactive', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Gold Transfer.json,https://codeforces.com//blog/entry/91481,Note that for each vertex So if we consider a path from some vertex to the closer you are to the cheaper the cost In other words it s always optimal to choose the highest vertex on the path with Suppose we can find such vertex for a given How many times we will repeat this search operation If we need to buy tons and has tons then it s optimal to buy tons in After we buy tons either becomes or becomes Since for each vertex can become equal to zero at most once and since after is zero we stop buying then there will be searches in total The next question is how to find efficiently for a given Consider the path from to some vertex Since we prefer to buy from higher vertices all empty vertices on this path will form some prefix of it possibly empty prefix So we can make some sort of binary search to find the first non empty vertex But instead of binary search we will use binary lifting technique If we know for each which vertex on the path from to on distance from then we can efficiently jump up the path Let s firstly jump at distance if then we jump too high let s not jump But if then we can safely jump or Now we know that we don t need a second jump so we try jump and so on In other words using binary lifting we can find the highest vertex with in steps Also we can calculate array for vertex right after we add vertex to the tree since and The resulting complexity is 
https://codeforces.com//contest/1849/problem/E,2121802,E,1849E,1849,E. Max to the Right of Min,You are given a permutation p of length n an array consisting of integers from 1 to n all distinct Let p l r denote a subarray an array formed by writing down elements from index l to index r inclusive Let mathit maxpos l r denote the of the maximum element on p l r Similarly let mathit minpos l r denote the index of the minimum element on it Calculate the number of subarrays p l r such that mathit maxpos l r mathit minpos l r ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n    }\n    \n    std::vector<int> lmin(n, -1), rmin(n, n), lmax(n, -1), rmax(n, n);\n    std::vector<int> smin, smax;\n    for (int i = 0; i < n; i++) {\n        while (!smin.empty() && p[i] < p[smin.back()]) {\n            rmin[smin.back()] = i;\n            smin.pop_back();\n        }\n        if (!smin.empty()) {\n            lmin[i] = smin.back();\n        }\n        smin.push_back(i);\n        \n        while (!smax.empty() && p[i] > p[smax.back()]) {\n            rmax[smax.back()] = i;\n            smax.pop_back();\n        }\n        if (!smax.empty()) {\n            lmax[i] = smax.back();\n        }\n        smax.push_back(i);\n    }\n    \n    i64 ans = 0;\n    std::vector<int> s{-1};\n    std::vector<i64> sum{0LL};\n    for (int i = 0; i < n; i++) {\n        while (s.size() > 1 && p[i] < p[s.back()]) {\n            rmin[s.back()] = i;\n            s.pop_back();\n            sum.pop_back();\n        }\n        int l = std::upper_bound(s.begin(), s.end(), lmax[i]) - s.begin();\n        if (l < s.size()) {\n            ans += 1LL * (s[l] - std::max(s[l - 1], lmax[i]))\n                * (std::min(rmax[i], rmin[s[l]]) - i);\n            l++;\n            int m = std::partition_point(s.begin() + l, s.end(), [&](int x) {\n                return rmin[x] > rmax[i];\n            }) - s.begin();\n            ans += 1LL * (s[m - 1] - s[l - 1]) * rmax[i];\n            ans -= 1LL * (s.back() - s[l - 1]) * i;\n            ans += sum.back() - sum[m - 1];\n        }\n        sum.push_back(sum.back() + 1LL * (i - s.back()) * rmin[i]);\n        s.push_back(i);\n    }\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']",,,"['binary search', 'data structures', 'divide and conquer', 'dp', 'dsu', 'two pointers']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Max to the Right of Min.json,https://codeforces.com//blog/entry/118752,The problem was originally prepared as part of the lecture on a monotonic stack Thus I will omit its explanation First recall a common technique of counting all segments satisfying some property You can count the segments that have the same right border at the same time Consider all segments with a fixed How do the minimums and the maximums on them change from each other If you look at the segments in the order of decreasing we can write down the sequence of the following events the minimum becomes smaller or the maximum becomes larger In fact we can maintain both of these types with two monotonic stacks Now which correspond to good segments with regard to the events Consider two adjacent events and where is the index of the event and is the type for min for max It s easy to see that if then all segments that have from to are good It means that while going from right to left the last event we encountered was the minimum getting smaller Thus the index of the minimum becomes to the left from the index of the maximum As for the implementation we will maintain these events in a set of pairs index of the event type of the event This way it s not that hard to maintain the sum of distances from each event of type to the left to the previous event When you erase an event only a few distances can be affected the distance from the next one to the current one from the current one to the previous one and the newly created distance from the next one to the previous one Just check for the types When you add an event you only add it to the very end of the set so it s trivial to recalculate That will be just from the set the monotonic stacks by themselves are linear You can optimize this solution to by using a doubly linked list but it really was not necessary for the problem There s also a different solution for which you can maintain the intervals of good values explicitly First compress them in such a way that the segments don t touch at borders Now you can notice that by going from to we can only affect the rightmost ones of them possibly remove some then change the last one and add a new one So we can actually simulate this behavior with another stack The details are left as an exercise to a reader With the correct implementation this solution will be 
https://codeforces.com//contest/687/problem/A,63910,A,687A,687,A. NP-Hard Problem,Recently Pari and Arya did some research about NP Hard problems and they found the problem very interesting Suppose the graph is given Subset of its vertices is called a of this graph if for each edge there is at least one endpoint of it in this set i e or or both Pari and Arya have won a great undirected graph as an award in a team contest Now they have to split it in two parts but both of them want their parts of the graph to be a vertex cover They have agreed to give you their graph and you need to find two subsets of its vertices and such that both and are vertex cover or claim it s impossible Each vertex should be given to no more than one of the friends or you can even keep it for yourself ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\n\nint n,m,u,v,col[N];\nVI e[N],vec[10];\nvoid dfs(int u) {\n\tfor (auto v:e[u]) {\n\t\tif (col[v]==0) {\n\t\t\tcol[v]=3-col[u];\n\t\t\tdfs(v);\n\t\t} else if (col[u]+col[v]!=3) {\n\t\t\tputs(""-1"");\n\t\t\texit(0);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\trep(i,1,n+1) if (col[i]==0) {\n\t\tcol[i]=1;\n\t\tdfs(i);\n\t}\n\trep(i,1,n+1) vec[col[i]].pb(i);\n\tprintf(""%d\\n"",SZ(vec[1]));\n\tfor (auto p:vec[1]) printf(""%d "",p);\n\tputs("""");\n\tprintf(""%d\\n"",SZ(vec[2]));\n\tfor (auto p:vec[2]) printf(""%d "",p);\n\tputs("""");\n}\n']",,,"['dfs and similar', 'graphs']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. NP-Hard Problem.json,https://codeforces.com//blog/entry/45770,Hint Try to use all of the vertices Then look at the two vertex covers together in the graph and see how it looks like Solution Looking at the two vertex covers in the graph you see there must be no edge uv that u and v are in the same vertex cover So the two vertex covers form a bipartition of the graph so the graph have to be bipartite And being bipartite is also sufficient you can use each part as a vertex cover Bipartition can be found using your favorite graph traversing algorithm BFS or DFS Here is a tutorial for bipartition of undirected graphs 
https://codeforces.com//contest/827/problem/C,113847,C,827C,827,C. DNA Evolution,Everyone knows that DNA strands consist of nucleotides There are four types of nucleotides A DNA strand is a sequence of nucleotides Scientists decided to track evolution of a rare species which DNA strand was string initially Evolution of the species is described as a sequence of changes in the DNA Every change is a change of some nucleotide for example the following change can happen in DNA strand the second nucleotide can change to so that the resulting DNA strand is Scientists know that some segments of the DNA strand can be affected by some unknown infections They can represent an infection as a sequence of nucleotides Scientists are interested if there are any changes caused by some infections Thus they sometimes want to know the value of impact of some infection to some segment of the DNA This value is computed as follows Let the infection be represented as a string and let scientists be interested in DNA strand segment starting from position to position inclusive Prefix of the string i e the string that consists of infinitely many repeats of string is written under the string from position to position inclusive The value of impact is the number of positions where letter of string coincided with the letter written under it Being a developer Innokenty is interested in bioinformatics also so the scientists asked him for help Innokenty is busy preparing VK Cup so he decided to delegate the problem to the competitors Help the scientists ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct fenw{\n  VI fw;\n  in n;\n  void ini(in pn){\n    n=pn;\n    fw.clear();\n    fw.resize(n,0);\n  }\n  void ad(in l, in x){\n    while(l<n){\n      fw[l]+=x;\n      l|=(l+1);\n    }\n  }\n  in sm(in l){\n    in r=0;\n    while(l>=0){\n      r+=fw[l];\n      l&=(l+1);\n      --l;\n    }\n    return r;\n  }\n};\nmap<char,in> dcd;\nconst in mx=1e5+9;\nvector<vector<vector<fenw> > > fw; // fw[a][b][c] has 1 at i if letter a is at i*b+c\nvoid adt(in l, in typ, in f){\n  for(in lt=1;lt<=10;++lt){\n    fw[typ][lt][l%lt].ad(l/lt,f);\n  }\n}\nstring s;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  dcd[\'A\']=0;\n  dcd[\'C\']=1;\n  dcd[\'G\']=2;\n  dcd[\'T\']=3;\n  fw.resize(4);\n  forn(i,4){\n    fw[i].resize(11);\n    for(in j=1;j<=10;++j){\n      fw[i][j].resize(j);\n      forn(k,j){\n\tfw[i][j][k].ini(mx/j+9);\n      }\n    }\n  }\n  cin>>s;\n  forv(i,s){\n    adt(i,dcd[s[i]],1);\n  }\n  in q;\n  cin>>q;\n  in typ,x,l,r;\n  char c;\n  string e;\n  in sm;\n  in lt;\n  in loc;\n  forn(z,q){\n    cin>>typ;\n    if(typ==1){\n      cin>>x>>c;\n      --x;\n      adt(x,dcd[s[x]],-1);\n      s[x]=c;\n      adt(x,dcd[s[x]],1);\n    }\n    else{\n      cin>>l>>r>>e;\n      --l;\n      --r;\n      sm=0;\n      lt=sz(e);\n      forv(i,e){\n\tloc=(l+i)%lt;\n\tif(r-loc>=0)\n\t  sm+=fw[dcd[e[i]]][lt][loc].sm((r-loc)/lt);\n\tif(l-1-loc>=0)\n\t  sm-=fw[dcd[e[i]]][lt][loc].sm((l-1-loc)/lt);\n      }\n      cout<<sm<<""\\n"";\n    }\n  }\n  return 0;\n}\n']",,,"['data structures', 'strings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. DNA Evolution.json,https://codeforces.com//blog/entry/53268,Note that there are only different characters and queries lengths are only up to How does this help Let s make arrays of length for each of the possible letters putting where the letter in is that letter and otherwise We can update these arrays easily with update queries Consider a letter in a query string It appears equidistantly in the string we write down under the string Thus we should count the number of ones in one of our four arrays at positions which indices form an arithmetic progression and bounded by some segment the query segment This sounds hard but we can note that the difference between the indices i e the common difference of the arithmetic progression is not larger than Thus we can store copies of each of four arrays we created above For the th copy of some letter we reorder the elements so that first we put all positions for which then all positions for which and so on This will make possible to change each query on an arithmetic progression to a sum query on a segment Thus we can just sum up answers for each letter in string 
https://codeforces.com//contest/1750/problem/H,1626964,H,1750H,1750,H. BinaryStringForces,You are given a binary string s of length n We define a as a substring that cannot be extended while keeping all elements equal For example in the string 11000111 there are three maximal substrings 11 000 and 111 In one operation you can select two maximal adjacent substrings Since they are maximal and adjacent it s easy to see their elements must have different values Let a be the length of the sequence of ones and b be the length of the sequence of zeros Then do the following If a ge b then replace b selected zeros with b ones If a b then replace a selected ones with a zeros As an example for 1110000 we make it 0000000 for 0011 we make it 1111 We call a string being if it can be turned into 1111 1111 using the aforementioned operation any number of times possibly zero Find the number of good substrings among all frac n n 1 2 non empty substrings of s ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng(0);\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nV<vpi> end_with_one(str S) {\n\tconst int N = sz(S);\n\tvi prv(N + 1), nxt(N + 1);\n\t{\n\t\tint cur = -1;\n\t\tF0R(i, N + 1) {\n\t\t\tif (i == N || S.at(i) == \'1\') cur = i;\n\t\t\tprv.at(i) = cur;\n\t\t}\n\t}\n\t{\n\t\tnxt.at(N) = N;\n\t\tR0F(i, N) {\n\t\t\tif (S.at(i) == \'1\') nxt.at(i) = i;\n\t\t\telse nxt.at(i) = nxt.at(i + 1);\n\t\t}\n\t}\n\tV<vpi> ival(N + 1);\n\tR0F(i, N) {\n\t\tint lst = i;\n\t\tint cur = S.at(i) == \'1\' ? i : i - 1;\n\t\tbool good = (S.at(i) == \'1\');\n\t\t// dbg(""GOING"", i);\n\t\twhile (true) {\n\t\t\tif (good) {\n\t\t\t\t// [lst, cur] is good\n\t\t\t\tint next_one = prv.at(min(2 * cur + 2 - i, N));\n\t\t\t\tif (next_one > cur) {\n\t\t\t\t\tcur = next_one;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// dbg(""HA"", S, i, lst, cur);\n\t\t\t\tassert((lst == N || S.at(lst) == \'1\') &&\n\t\t\t\t\t   (cur == N || S.at(cur) == \'1\'));\n\t\t\t\tival.at(i).pb({lst, cur});\n\t\t\t\tgood = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cur == N) break;\n\t\t\t// dbg(""OOPS"", i, cur);\n\t\t\tint next_one = nxt.at(cur + 1);\n\t\t\tint need_r = 2 * next_one - 2 - cur;\n\t\t\t// dbg(""HA"", cur, next_one, need_r);\n\t\t\tassert(need_r >= next_one);\n\t\t\tint idx = fstTrue(0, sz(ival.at(next_one)) - 1, [&](int x) {\n\t\t\t\treturn ival.at(next_one).at(x).s >= need_r;\n\t\t\t});\n\t\t\tif (idx == sz(ival.at(next_one))) break;\n\t\t\tlst = cur = nxt.at(max(ival.at(next_one).at(idx).f, need_r));\n\t\t\tgood = 1;\n\t\t\t// dbg(""SET"", lst, cur);\n\t\t}\n\t\t// dbg(i, ival.at(i));\n\t}\n\treturn ival;\n}\n\nstr rev(str S) {\n\treverse(all(S));\n\treturn S;\n}\n\n/**\n * Description: 1D range minimum query. Can also do queries\n * for any associative operation in $O(1)$ with D\\&C\n * Source: KACTL\n * Verification:\n * https://cses.fi/problemset/stats/1647/\n * http://wcipeg.com/problem/ioi1223\n * https://pastebin.com/ChpniVZL\n * Memory: O(N\\log N)\n * Time: O(1)\n */\n\ntcT > struct RMQ {\n\tint level(int x) { return 31 - __builtin_clz(x); }\n\tV<T> v;\n\tV<vi> jmp;\n\tint cmb(int a, int b) {\n\t\treturn v[a] == v[b] ? min(a, b) : (v[a] > v[b] ? a : b);\n\t}\n\tvoid init(const V<T> &_v) {\n\t\tv = _v;\n\t\tjmp = {vi(sz(v))};\n\t\tiota(all(jmp[0]), 0);\n\t\tfor (int j = 1; 1 << j <= sz(v); ++j) {\n\t\t\tjmp.pb(vi(sz(v) - (1 << j) + 1));\n\t\t\tF0R(i, sz(jmp[j]))\n\t\t\tjmp[j][i] = cmb(jmp[j - 1][i], jmp[j - 1][i + (1 << (j - 1))]);\n\t\t}\n\t}\n\tint index(int l, int r) {\n\t\tassert(l <= r);\n\t\tint d = level(r - l + 1);\n\t\treturn cmb(jmp[d][l], jmp[d][r - (1 << d) + 1]);\n\t}\n\tT query(int l, int r) { return v[index(l, r)]; }\n};\n\n/**\n * Author: Lukas Polacek\n * Date: 2009-10-30\n * License: CC0\n * Source: folklore/TopCoder\n * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], and\n * updates single elements a[i], taking the difference between the old and new\n * value. Time: Both operations are $O(\\log N)$. Status: Stress-tested\n */\n\ntcT > struct BIT {\n\tint N;\n\tV<T> data;\n\tvoid init(int _N) {\n\t\tN = _N;\n\t\tdata.rsz(N);\n\t}\n\tvoid add(int p, T x) {\n\t\tfor (++p; p <= N; p += p & -p) data[p - 1] += x;\n\t}\n\tT sum(int l, int r) { return sum(r + 1) - sum(l); }\n\tT sum(int r) {\n\t\tT s = 0;\n\t\tfor (; r; r -= r & -r) s += data[r - 1];\n\t\treturn s;\n\t}\n\tint lower_bound(T sum) {\n\t\tif (sum <= 0) return -1;\n\t\tint pos = 0;\n\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {\n\t\t\tint npos = pos + pw;\n\t\t\tif (npos <= N && data[npos - 1] < sum)\n\t\t\t\tpos = npos, sum -= data[pos - 1];\n\t\t}\n\t\treturn pos;\n\t}\n};\n\nvoid solve(int N, str S) {\n\tauto l_to_r = end_with_one(S);\n\tauto r_to_l = end_with_one(rev(S));\n\tvi cum{0};\n\teach(c, S) cum.pb(cum.bk + (c == \'1\'));\n\tll ans = 0;\n\tF0R(i, N) { // end with 1\n\t\tfor (auto [a, b] : l_to_r.at(i)) {\n\t\t\tckmin(b, N - 1);\n\t\t\tans += cum.at(b + 1) - cum.at(a);\n\t\t}\n\t}\n\tdbg(l_to_r);\n\tdbg(""ANS END WITH 1"", ans);\n\tF0R(i, N) if (S.at(i) == \'0\') { // begin with 1, end with 0\n\t\tfor (auto [a, b] : r_to_l.at(N - 1 - i)) {\n\t\t\tckmin(b, N - 1);\n\t\t\t// N-1-b, N-1-a\n\t\t\tans += cum.at(N - a) - cum.at(N - 1 - b);\n\t\t}\n\t}\n\tdbg(""ANS BEGIN WITH 1, END WITH 0"", ans);\n\tconst AR<int, 3> ID{-2, -2, -2};\n\tV<AR<int, 3>> query_l, query_r;\n\tvi tot_l, tot_r;\n\tRMQ<int> zeros_starting, zeros_ending;\n\t{\n\t\tvi tmp(N);\n\t\tint cnt = 0;\n\t\tR0F(i, N) {\n\t\t\tif (S.at(i) == \'0\') ++cnt;\n\t\t\telse cnt = 0;\n\t\t\ttmp.at(i) = cnt;\n\t\t}\n\t\tzeros_starting.init(tmp);\n\t}\n\t{\n\t\tvi tmp(N);\n\t\tint cnt = 0;\n\t\tF0R(i, N) {\n\t\t\tif (S.at(i) == \'0\') ++cnt;\n\t\t\telse cnt = 0;\n\t\t\ttmp.at(i) = cnt;\n\t\t}\n\t\tzeros_ending.init(tmp);\n\t}\n\tvi cum_zero{0};\n\teach(c,S) cum_zero.pb(cum_zero.bk + (c == \'0\'));\n\tauto zeros_in_range = [&](int l, int r) {\n\t\treturn cum_zero.at(r+1) - cum_zero.at(l);\n\t};\n\t\n\tF0R(r, N) {\n\t\tif (S.at(r) == \'1\') continue;\n\t\tint l = r;\n\t\twhile (r < N && S.at(r) == \'0\') ++r;\n\t\t--r;\n\t\t{\n\t\t\t// l ... r\n\t\t\tint L = fstTrue(0, l - 1, [&](int x) {\n\t\t\t\treturn zeros_starting.query(x, l - 1) < r - l + 1;\n\t\t\t});\n\t\t\tint R = lstTrue(r + 1, N - 1, [&](int x) {\n\t\t\t\treturn zeros_ending.query(r + 1, x) <= r - l + 1;\n\t\t\t});\n\t\t\ttot_l.pb(zeros_in_range(L, l));\n\t\t\tquery_l.pb({L, 2 * l - r - 1, l - 1});\n\t\t\ttot_r.pb(zeros_in_range(r, R));\n\t\t\tquery_r.pb({2 * r - l + 1, R, r + 1});\n\t\t\t// count # x in [L, 2*l-r-1] such that [x, l-1] is good\n\t\t\t// count # x in [2*r-l+1, R] such that [r+1, R] is good\n\t\t\t// dbg(l, r, query_l.bk, query_r.bk);\n\t\t}\n\t\tFOR(small_r, l, r) {\n\t\t\tint L = fstTrue(0, l - 1, [&](int x) {\n\t\t\t\treturn zeros_starting.query(x, l - 1) < small_r - l + 1;\n\t\t\t});\n\t\t\ttot_l.pb(zeros_in_range(L, l));\n\t\t\tquery_l.pb({L, 2 * l - small_r - 1, l - 1});\n\t\t\ttot_r.pb(1);\n\t\t\tquery_r.pb(ID);\n\t\t\t// dbg(l, small_r, query_l.bk, query_r.bk);\n\t\t}\n\t\tFOR(small_l, l + 1, r + 1) {\n\t\t\tint R = lstTrue(r + 1, N - 1, [&](int x) {\n\t\t\t\treturn zeros_ending.query(r + 1, x) <= r - small_l + 1;\n\t\t\t});\n\t\t\ttot_l.pb(1);\n\t\t\tquery_l.pb(ID);\n\t\t\ttot_r.pb(zeros_in_range(r, R));\n\t\t\tquery_r.pb({2 * r - small_l + 1, R, r + 1});\n\t\t\tdbg(small_l, r, query_l.bk, query_r.bk);\n\t\t}\n\t}\n\tvi ans_l(sz(query_l)), ans_r(sz(query_r));\n\t{ // do query l\n\t\tV<AR<int, 4>> offline_queries;\n\t\tF0R(i, sz(query_l)) if (query_l.at(i) != ID) {\n\t\t\tauto [l, r, pos] = query_l.at(i);\n\t\t\tif (l > r) continue;\n\t\t\toffline_queries.pb({l - 1, pos, -1, i});\n\t\t\toffline_queries.pb({r, pos, 1, i});\n\t\t}\n\t\tsor(offline_queries);\n\t\t// dbg(offline_queries);\n\t\tBIT<int> B;\n\t\tB.init(N + 5);\n\t\tint nxt = 0;\n\t\tfor (auto [l, pos, mul, id] : offline_queries) {\n\t\t\tfor (; nxt <= l; ++nxt)\n\t\t\t\tif (S.at(nxt) == \'0\') {\n\t\t\t\t\tfor (auto [a, b] : l_to_r.at(nxt)) {\n\t\t\t\t\t\tassert(a <= b);\n\t\t\t\t\t\tB.add(a, 1);\n\t\t\t\t\t\tB.add(b + 1, -1);\n\t\t\t\t\t}\n\t\t\t\t\t// dbg(""ANS L"", l, pos, mul, id, B.sum(pos + 1));\n\t\t\t\t}\n\t\t\tans_l.at(id) += mul * B.sum(pos + 1);\n\t\t}\n\t}\n\t{ // do_query_r\n\t\tV<AR<int, 4>> offline_queries;\n\t\tF0R(i, sz(query_r)) if (query_r.at(i) != ID) {\n\t\t\tauto [l, r, pos] = query_r.at(i);\n\t\t\tif (l > r) continue;\n\t\t\toffline_queries.pb({N - 2 - r, N - 1 - pos, -1, i});\n\t\t\toffline_queries.pb({N - 1 - l, N - 1 - pos, 1, i});\n\t\t}\n\t\tsor(offline_queries);\n\t\tBIT<int> B;\n\t\tB.init(N + 5);\n\t\tint nxt = 0;\n\t\tfor (auto [l, pos, mul, id] : offline_queries) {\n\t\t\tfor (; nxt <= l; ++nxt)\n\t\t\t\tif (S.at(N - 1 - nxt) == \'0\') {\n\t\t\t\t\tfor (auto [a, b] : r_to_l.at(nxt)) {\n\t\t\t\t\t\tB.add(a, 1);\n\t\t\t\t\t\tB.add(b + 1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tans_r.at(id) += mul * B.sum(pos + 1);\n\t\t}\n\t}\n\t// dbg(ans_l);\n\t// dbg(ans_r);\n\teach(t, ans_l) assert(t >= 0);\n\teach(t, ans_r) assert(t >= 0);\n\tdbg(""ans before"", ans);\n\tF0R(i, sz(ans_l)) {\n\t\tauto bad_l = tot_l.at(i) - ans_l.at(i);\n\t\tauto bad_r = tot_r.at(i) - ans_r.at(i);\n\t\t// dbg(i, tot_l.at(i), bad_l, tot_r.at(i), bad_r);\n\t\tans += (ll)tot_l.at(i) * tot_r.at(i) - (ll)bad_l * bad_r;\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\t// rep(10000) {\n\t// \t// int N = 6;\n\t// \t// str S; rep(N) S += char(\'0\'+(rng()&1));\n\t// \t// dbg(N, S);\n\t// \t// int N, S; re(N, S);\n\t// \tsolve(N,S);\n\t// }\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) {\n\t\tint N; str S;\n\t\tre(N,S);\n\t\tsolve(N,S);\n\t}\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']",,,"['constructive algorithms', 'data structures', 'dp']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. BinaryStringForces.json,https://codeforces.com//blog/entry/108504,Solution We call a maximal sequence of a block a maximal sequence of a block For each store some disjoint intervals with the following property For each that and j is in one of the intervals if and only if is a good substring We can prove the number of intervals for each is Let s start from to and consider when good substring become bad and bad substring become good Assume we are at If it is a good substring and ending with 1 it become bad when it meet a longer 0 block so we get one interval and go to a bad substring ending with 0 If it is a bad substring and ending with 0 suppose the next 1 is at k then the next good intervals start at the smallest j with three properties 1 is good 2 3 is not shorter than the last 0 block Proof Property 2 is obvious because we only care about substrings ending with 1 If is shorter than the last block it is impossible to change this block so is bad If is bad if it starts with a 1 block not shorter than the last block after some operations then is smaller than and has those three properties otherwise it is impossible to change the last block If it has all three properties in substring is good and can change the last block and then change to so we go to a good substring ending with 1 When good substring become bad the length is doubled so the number of intervals for each i is To know when good substring become bad for every 0 block if is longer than then is bad we can preprocess those i in To know when bad substring become good we go with from to and for each search in intervals times So we get those intervals in Now we can check each substring ending with is good or not Do the above algorithm on the reversed string so we can check each substring starting with 1 is good or not But we can not check substring starting and ending with 0 Suppose is the longest block in then is good if at least one of and is good and not shorter than Proof After changing the longest block we can change all other blocks So for any substring it is good if and only if we can change its longest block If is good and not shorter it can change so is good If is good assume the longest 0 block is changed from left So after some operations in there is a substring become all and not shorter than Then can make good as there is no longer block Similarly we can prove for So for each substring we consider its longest block substrings with no are always good For convenience if there are multiple maximum we take the rightmost The longest block in substrings can be either a block in the original string or part of block in the original string We can ignore substring in one block so the longest block can only be a prefix or suffix the number of possible longest block is For each possible 0 block assume the longest substring that is the longest block is we need to count answer for substring that it is equivalent to count the number of that and is good and the number of that and is good Notice that we can calculate them by above intervals We can use persistent segment tree directly or use segment tree or binary index tree after sorting queries We need modifications and queries Thus we have solved our problem in 
https://codeforces.com//contest/1465/problem/B,839217,B,1465B,1465,B. Fair Numbers,We call a positive integer number if it is divisible by each of its nonzero digits For example 102 is fair because it is divisible by 1 and 2 but 282 is not because it isn t divisible by 8 Given a positive integer n Find the minimum integer x such that n leq x and x is fair ,"['#include<bits/stdc++.h>\nnamespace mem{ //v2.10.1 => size: 15.80KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)        \\\n      func(float)                     \\\n      func(double)                    \\\n      func(long double)\n  \n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n  \n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::find;\n    using std::copy;\n    using std::fill;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n    using std::next_permutation;\n  }\n  \n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori\'s Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    \n    template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n    template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  }\n  \n  namespace modint{\n    template<const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x<0&&(x+=mod);}\n      \n      inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n      \n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n    };\n    \n    template<const int mod> inline Z<mod> finv(Z<mod> x){\n      if(x.x<2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n      Z<mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&1)s=s*a;\n      return s;\n    }\n    \n    template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n  \n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template<class T> inline T abs(T x){return x<0?-x:x;}\n    template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n    \n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n      \n      inline bool divide(u64 n){return n*i<=t;}\n      inline bool divide(i64 n){return u64(n<0?-n:n)*i<=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i<5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n  \n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)<<64)/b)),b(b){}\n      \n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n  \n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::multiset;\n    using std::unordered_set;\n    using std::unordered_multiset;\n    using std::map;\n    using std::multimap;\n    using std::unordered_map;\n    using std::unordered_multimap;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    using std::deque;\n    using std::bitset;\n    \n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n    \n    template<class T> struct vector:std::vector<T>{\n      using std::vector<T>::vector;\n      using iterator=typename std::vector<T>::iterator;\n      using const_iterator=typename std::vector<T>::const_iterator;\n      vector():std::vector<T>(){}\n      explicit vector(const std::vector<T> &plain):std::vector<T>(plain){}\n      \n      inline void reverse(){std::reverse(this->begin(),this->end());}\n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n      \n      inline iterator find(const T &x){return std::find(this->begin(),this->end(),x);}\n      inline iterator lower_bound(const T &x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator find(const T &x)const{return std::find(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &x)const{return std::upper_bound(this->begin(),this->end(),x);}\n\n      inline void sort(){std::sort(this->begin(),this->end());}\n      template<class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n      \n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n        vector rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set<T> &src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template<class R,class Function> inline vector<R> _map(Function func) const{\n        vector<R> res(this->size());\n        for(size_t i=0;i<this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n      template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n    };\n    \n    struct string:std::string{\n      using std::string::string;\n      string():std::string(""""){}\n      string(const std::string &plain):std::string(plain){}\n      \n      template<class T> inline string join(const vector<T> &vet) const;\n            \n      inline string slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return string(this->begin()+l,this->begin()+r);\n        string rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n      \n      vector<string> split(const string &dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector<string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n      \n      template<class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template<class... Args> static inline string format(const string &fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n  \n  #define __to_string(T)                   \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n    \n    inline string to_string(const string &s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &s){return string(s);}\n    template<const int mod> inline string to_string(const modint::Z<mod> &v){return std::to_string(v.x);}\n    \n    template<class T> inline string to_string(const vector<T> &ctn){return ""[""+string("","").join(ctn)+""]"";}\n    template<class T> inline string to_string(const set<T> &ctn){\n      string result=""{"";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+="","";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+""}"";\n    }\n    template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n      string result=""{"";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+="","";\n        flag=true;\n        result+=to_string(it.first)+"":""+to_string(it.second);\n      }\n      return result+""}"";\n    }\n    \n    template<class T> inline string string::join(const vector<T> &vet) const{\n      if(!vet.size())return """";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i<vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n    \n    inline string operator """" _s(const char *s){return string(s);}\n    inline string operator """" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator """" _s(long double x){return to_string(x);}\n    inline string operator """" _s(unsigned long long int x){return to_string(x);}\n  }\n  \n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1<<18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n    inline void flush(){fastio::flush(),fflush(stdout);}\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n    inline void flush(){fflush(stdout);}\n  #endif\n    \n    template<class T> inline void read_digit(T &x){x=getc(); while(!isdigit(x))x=getc();}\n    template<class T> inline void read_alpha(T &x){x=getc(); while(!isalpha(x))x=getc();}\n    template<class T> inline void read_lower(T &x){x=getc(); while(!islower(x))x=getc();}\n    template<class T> inline void read_upper(T &x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n  \n  #define __read(T)                             \\\n      inline void read(T &x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c==\'-\',c=getc();   \\\n        while(isdigit(c))x=x*10+c-\'0\',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n    #ifdef MEM_INT128\n      __read(__int128_t)\n      __read(__uint128_t)\n    #endif\n  #undef __read\n    \n    inline void read(char &x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&&!isspace(c))*s++=c,c=getc();\n      *s++=\'\\0\';\n    }\n    inline void read(container::string &s){\n      char c=getc();\n      s="""";\n      while(~c&&!isspace(c))s+=c,c=getc();\n    }\n    template<const int mod> inline void read(const modint::Z<mod> &x){read(x.x);}\n    \n    template<class T=int> inline T read(){T x; read(x); return x;}\n    template<class T,class... Args> inline void read(T &x,Args &... args){\n      read(x),read(args...);\n    }\n  \n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x<0)putc(\'-\'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc(\'0\'+x%10);        \\\n      }\n    __integer_mapper(__print)\n    #ifdef MEM_INT128\n      __print(__int128_t)\n      __print(__uint128_t)\n    #endif\n  #undef __print\n    \n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i<len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &s){\n      for(size_t i=0;i<s.length();i++)putc(s[i]);\n    }\n    template<const int mod> inline void print(const modint::Z<mod> &x){print(x.x);}\n    \n    template<class T,class... Args> inline void print(const T &x,Args... args){\n      print(x),print(args...);\n    }\n    template<class... Args> inline void println(Args... args){\n      print(args...),putc(\'\\n\');\n    }\n    \n    template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n  \n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,""\\033[%dm"",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\033[0m"");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,""\\033[%dm"",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\033[0m\\n"");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\n"");\n      }\n  #endif\n    }\n    template<class T> inline void logs(const T &x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template<class T,class... Args> inline void logs(const T &x,Args... args){\n      logs(x),logs(args...);\n    }\n    template<class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,""\\n"");\n  #endif\n    }\n  }\n  \n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,""r"",stdin);}\n    inline void file_output(const char *dir){freopen(dir,""w"",stdout);}\n    inline void file_input(const std::string &dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &dir){file_output(dir.c_str());}\n\n    template<class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+"".in""_s);\n      file_output(name+"".out""_s);\n    }\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\nusing namespace mem;\nint T;\nlong long n;\nbool is_fair(long long n){\n  for(long long t=n;t;t/=10)\n    if(t%10&&n%(t%10)){\n      return false;\n    }\n  return true;\n}\nint main(){\n#ifdef memset0\n  freopen(""1.in"",""r"",stdin);\n#endif\n  read(T);\n  while(T--){\n    read(n);\n    while(!is_fair(n)){\n      ++n;\n    }\n    println(n);\n  }\n}']",,,"['brute force', 'math', 'number theory']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Fair Numbers.json,https://codeforces.com//blog/entry/85792,Let s call a number super fair if it is divisible by each of the numbers 1 9 It is fair to say that super fair numbers are also divisible by LCM 1 9 which is equal to 2520 The answer isn t larger than the nearest super fair number which means that you can increase the original n by one until it becomes fair We will determine if the number is fair by checking each of its digits separately 
https://codeforces.com//contest/1907/problem/E,2365625,E,1907E,1907,E. Good Triples,Given a non negative integer number n n ge 0 Let s say a triple of non negative integers a b c is good if a b c n and digsum a digsum b digsum c digsum n where digsum x is the sum of digits of number x For example if n 26 then the pair 4 12 10 is good because 4 12 10 26 and 4 1 2 1 0 2 6 Your task is to find the number of good triples for the given number n The order of the numbers in a triple matters For example the triples 4 12 10 and 10 12 4 are two different triples ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<array>\n#include<set>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\nlong long g[10] = { 1,3,6,10,15,21,28,36,45,55 };\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i ^ s.size(); ++i)\n\t\t\tans *= g[s[i] - '0'];\n\t\tcout << ans << '\\n';\n\t}\n}""]",,,"['brute force', 'combinatorics', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Good Triples.json,https://codeforces.com//blog/entry/123012,A triplet is considered good only if each digit of the number was obtained without carrying over during addition For example consider the sum of the digits is and the sum of the digits of their sum is This means that whenever there is a carry in one of the digits the sum always increases more than This allows us to consider each digit separately and multiply their answers The answer for each digit will be the number of digit triplets with the sum These values do not depend on the input data so they can be precalculated but this is not necessary to pass the tests 
https://codeforces.com//contest/1498/problem/F,939727,F,1498F,1498,F. Christmas Game,Alice and Bob are going to celebrate Christmas by playing a game with a tree of presents The tree has n nodes numbered 1 to n with some node r as its root There are a i presents are hanging from the i th node Before beginning the game a special integer k is chosen The game proceeds as follows Alice begins the game with moves alternating each turn in any move the current player may choose some node for example i which has depth at least k Then the player picks some positive number of presents hanging from that node let s call it m 1 le m le a i the player then places these m presents on the k th ancestor let s call it j of the i th node the k th ancestor of vertex i is a vertex j such that i is a descendant of j and the difference between the depth of j and the depth of i is exactly k Now the number of presents of the i th node a i is decreased by m and correspondingly a j is increased by m Alice and Bob both play optimally The player unable to make a move loses the game of the tree find who among Alice or Bob wins the game Note The depth of a node i in a tree with root r is defined as the number of edges on the simple path from node r to node i The depth of root r itself is zero ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002],k,f[100002][42],g[100002][42];\ninline void add(re int x,re int y){e[++cnt]=(edge){y,head[x]},head[x]=cnt;}\ninline void dfs(re int x,re int y,re int d){\n\tif((d/k)&1)ans^=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to^y)dfs(e[i].to,x,d+1);\n}\ninline void dfs1(re int x,re int y){\n\tf[x][0]=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to^y){\n\t\t\tdfs1(e[i].to,x);\n\t\t\tfor(re int j=0;j<k*2;++j)f[x][j+1]^=f[e[i].to][j];\n\t\t\tf[x][0]^=f[x][k*2],f[x][k*2]=0;\n\t\t}\n}\ninline void dfs2(re int x,re int y){\n\tif(y){\n\tfor(re int j=0;j<k*2;++j)g[x][j+1]^=g[y][j];\n\tg[x][0]^=g[x][k*2],g[x][k*2]=0;\n\tg[x][1]^=a[y];\n\tfor(re int j=0;j<k*2;++j)f[y][j+1]^=f[x][j];\n\tf[y][0]^=f[y][k*2],f[y][k*2]=0;\n\tfor(re int j=0;j<k*2;++j)g[x][j+1]^=f[y][j];\n\tg[x][0]^=g[x][k*2],g[x][k*2]=0;\n\tfor(re int j=0;j<k*2;++j)f[y][j+1]^=f[x][j];\n\tf[y][0]^=f[y][k*2],f[y][k*2]=0;\n\t}\n\tg[x][0]^=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)if(e[i].to^y)dfs2(e[i].to,x);\n}\nsigned main(){\n\tn=read(),k=read();\n\tfor(re int i=1,x,y;i<n;++i)x=read(),y=read(),add(x,y),add(y,x);\n\tfor(re int i=1;i<=n;++i)a[i]=read();\n\tdfs1(1,1),dfs2(1,0);\n\tfor(re int i=1;i<=n;++i){\n\t\tans=0;\n\t\tfor(re int j=k;j<k*2;++j)ans^=f[i][j]^g[i][j];\n\t\tif(ans)printf(""1 "");\n\t\telse printf(""0 ""); \n\t}\n}\n']",,,"['bitmasks', 'data structures', 'dfs and similar', 'dp', 'games', 'math', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Christmas Game.json,https://codeforces.com//blog/entry/89137,How do we solve a standard Nim game on arrays By the Sprague Grundy theorem we know that the current player has a winning strategy if xorsum of sizes of the existing piles is non zero For a proof read details on CP algorithms 
https://codeforces.com//contest/1241/problem/A,432400,A,1241A,1241,A. CME,Let s denote we will denote it as CME an equation a b c there all integers a b and c are greater than zero For example equations 2 2 4 and 1 2 3 are CME but equations 1 2 4 2 2 3 and 0 1 1 are not Now you have n matches You want to assemble a CME using your matches Unfortunately it is possible that you can t assemble the CME using all matches But you can buy some extra matches and then assemble CME For example if n 2 you can buy two matches and assemble and if n 5 you can buy one match and assemble Calculate the minimum number of matches which you have to buy for assembling CME Note that you have to answer q independent queries ,"['// Code by H~$~C\n//#pragma comment(linker, ""/STACK:1024000000,1024000000"")\n//#pragma GCC optimize(""Ofast"", ""unroll-loops"")\n//#pragma target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#define rint register int\n#define rep(i, n) for (rint i = 0; i < (n); ++i)\n#define rep1(i, n) for (rint i = (1); i <= (n); ++i)\n#define Rep(i, a, b) for (rint i = (a); i <= (b); ++i)\n#define per(i, n) for (rint i = ((n) - 1); ~i; --i)\n#define per1(i, n) for (rint i = (n); i; --i)\n#define Per(i, a, b) for (rint i = (a); i >= (b); --i)\n#define repit(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define eprintf(...) (fprintf(stderr, __VA_ARGS__) & fflush(stderr))\n#define fillset(a, val) memset(a, val, sizeof(a))\n#define All(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n#define fi first\n#define se second\n#define pb push_back\n#define y0 y19260817\n#define y1 y19268107\n#define j0 j19260817\n#define j1 j19268107\n#define x0 x19260817\n#define x1 x19268107\nusing namespace std;\n#ifndef LOCAL_JUDGE\n#define Debug(...)\n#else\ntemplate <typename T> inline void _debug(const char *names, T &&t) {\n(cerr << names << "" = "" << t << endl).flush();}\ntemplate <typename T1, typename ...T>\ninline void _debug(const char *names, T1 &&t1, T &&... t) {\nconst char *comma = strchr(names, \',\');\n(cerr.write(names, comma - names) << "" = "" << t1 << "", "").flush();\n_debug(comma + 1, t ...);}\n#define Debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)\n#endif\nstruct __STARTER_OF_PROGRAM__ { __STARTER_OF_PROGRAM__() {\n#ifndef ONLINE_JUDGE\n  cerr << ""Code by H~$~C: \\n"" << flush;\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr), cout.tie(nullptr);\n  cout << fixed << setprecision(12);\n} } __starter_of_program__;\n#ifdef LOCAL_JUDGE\nstruct __ENDDER_OF_PROGRAM__ { ~__ENDDER_OF_PROGRAM__() {\n  cerr << ""\\n\\nTime elasped: "" << clock() * 1000.0 / CLOCKS_PER_SEC << "" ms\\n"" << flush;\n} } __endder_of_program__;\n#endif\nusing ll = long long; using ull = unsigned long long; using uint = unsigned int;\nusing ld = long double; using pii = pair<int, int>; using pll = pair<ll, ll>;\nusing pli = pair<ll, int>; using pil = pair<int, ll>;\ntemplate <typename T> using min_queue = priority_queue<T, vector <T>, greater <T> >;\ntemplate <typename T> using max_queue = priority_queue<T>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\nstatic uniform_int_distribution<int> __disint__;\ninline int randint(void) { return __disint__(gen); }\ninline int randint(int l, int r) { return __disint__(gen) % (r - l + 1) + l; }\ntemplate <typename T> inline void reinit(T &t) { t.~T(); new (&t) T(); }\ntemplate <typename T> inline T chmax(T &x, T y) { return x = max(x, y); }\ntemplate <typename T> inline T chmin(T &x, T y) { return x = min(x, y); }\ntemplate <typename T> inline T chmax(T &x, initializer_list <T> i) { return x = max(x, max(i)); }\ntemplate <typename T> inline T chmin(T &x, initializer_list <T> i) { return x = min(x, min(i)); }\ninline void read() { } inline void write() { }\ntemplate <typename T> inline void read(T &x) { cin >> x; }\ntemplate <typename T> inline void write(const T &x) { cout << x; }\ntemplate <typename T, typename U>\ninline void write(const pair<T, U> &x) { write(x.first), cout.put(\' \'), write(x.second);}\ntemplate <typename T, typename U>\ninline void read(pair<T, U> &x) { read(x.first), read(x.second);}\ntemplate <typename T, typename ...Ts> inline void read(T &x, Ts &...y) { read(x), read(y...); }\ntemplate <typename T, typename ...Ts> inline void write(const T &x, const Ts &...y) {\nwrite(x), (sizeof...(y) && (cout.put(\' \'), 0)), write(y...); }\n#define writeln(...) (write(__VA_ARGS__), cout.put(\'\\n\'), 0)\ntemplate <typename It> inline void _write(It a, It b) {\nregister char flag = 0; while (a != b) { flag && (cout.put(\' \'), 0); write(*a ++), flag = 1; } }\n#define _writeln(...) (_write(__VA_ARGS__), cout.put(\'\\n\'), 0)\nconst int mod1 = 1000000007, mod2 = 998244353, mod3 = 1000000009;\nconst double EPS = 1e-9, PI = acos(-1.0), _E_ = exp(1.0);\nconst int inf = 0x3f3f3f3f;\nconst ll lnf = 0x3f3f3f3f3f3f3f3f;\n\nsigned main(int argc, const char *argv[]) {\n  int tests;\n  read(tests);\n  while (tests--) {\n    int n;\n    read(n);\n    if (n == 1) writeln(3);\n    else if (n == 2) writeln(2);\n    else if (n == 3) writeln(1);\n    else if (n == 4) writeln(0);\n    else writeln(n % 2);\n  }\n\treturn 0;\n}']",,,['math'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. CME.json,https://codeforces.com/blog/entry/70358,If n is odd then we have to buy at least one match because integers a b and c a b and c is elements of equation a b c must be of the same parity so integer a b c is always even If n is even then we can assemble an equation 1 n 22 n2 But there is one corner case If n 2 then we have to buy two matches because all integers a b and c must be greater than zero In this way the answer is equal 2 if n 2 1 if n is odd 0 if n is even and greater than 2 
https://codeforces.com//contest/1303/problem/G,538606,G,1303G,1303,G. Sum of Prefix Sums,We define the of an array s 1 s 2 dots s k as s 1 s 1 s 2 s 1 s 2 s 3 dots s 1 s 2 dots s k You are given a tree consisting of n vertices Each vertex i has an integer a i written on it We define the value of the path from vertex u to vertex v as follows consider all vertices appearing on the path from u to v write down all the numbers written on these vertices in the order they appear on the path and compute the of the resulting sequence Your task is to calculate the maximum value over all paths in the tree ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=1.5e5;\nint n, s[mxN], ctp[mxN], a[mxN];\nvector<int> adj[mxN];\nll ans;\nvector<vector<ar<ll, 2>>> v1, v2;\n\nstruct line {\n\tll m, b;\n\tmutable function<const line *()> succ;\n\tbool operator<(const line &o) const {\n\t\tif(o.b^LLONG_MAX)\n\t\t\treturn m<o.m;\n\t\tconst line *s=succ();\n\t\treturn s?b-s->b<(s->m-m)*o.m:0;\n\t}\n};\nstruct dynamic_hull : public multiset<line> {\n\tbool bad(auto y) {\n\t\tauto z=next(y);\n\t\tif(y==begin())\n\t\t\treturn z==end()?0:y->m==z->m&&y->b<=z->b;\n\t\tauto x=prev(y);\n\t\treturn z==end()?y->m==x->m&&y->b<=x->b:(x->b-y->b)*(z->m-y->m)>=(y->b-z->b)*(y->m-x->m);\n\t}\n\tvoid upd(ll m, ll b) {\n\t\tauto y=insert({m, b});\n\t\ty->succ=[=] {\n\t\t\treturn next(y)==end()?0:&*next(y);\n\t\t};\n\t\tif(bad(y)) {\n\t\t\terase(y);\n\t\t\treturn;\n\t\t}\n\t\twhile(next(y)!=end()&&bad(next(y)))\n\t\t\terase(next(y));\n\t\twhile(y!=begin()&&bad(prev(y)))\n\t\t\terase(prev(y));\n\t}\n\tll qry(ll x) {\n\t\tline l=*lower_bound((line){x, LLONG_MAX});\n\t\treturn l.m*x+l.b;\n\t}\n};\n\nvoid dfs2(int u, int p=-1) {\n\ts[u]=1;\n\tfor(int v : adj[u]) {\n\t\tif(v^p&&ctp[v]==-1) {\n\t\t\tdfs2(v, u);\n\t\t\ts[u]+=s[v];\n\t\t}\n\t}\n}\n\nint dfs4(int u, int n, int p=-1) {\n\tfor(int v : adj[u])\n\t\tif(v^p&&ctp[v]==-1&&s[v]>n/2)\n\t\t\treturn dfs4(v, n, u);\n\treturn u;\n}\n\nvoid dfs5(int u, int d, ll s10, ll s11, ll s20, ll s21, int p=-1) {\n\tint nc=0;\n\ts10+=a[u];\n\ts11+=(ll)a[u]*(d+1);\n\ts20+=a[u];\n\ts21+=s20;\n\tfor(int v : adj[u]) {\n\t\tif(v==p||~ctp[v])\n\t\t\tcontinue;\n\t\t++nc;\n\t\tdfs5(v, d+1, s10, s11, s20, s21, u);\n\t}\n\tif(!nc) {\n\t\tv1.back().push_back({s10, s11});\n\t\tv2.back().push_back({d, s21});\n\t}\n}\n\nvoid dfs3(int u=0, int p=-2) {\n\tint c=dfs4(u, s[u]);\n\tctp[c]=p;\n\tdfs2(c);\n\tv1.push_back({{a[c], a[c]}});\n\tv2.push_back({{0, 0}});\n\tfor(int v : adj[c]) {\n\t\tif(~ctp[v])\n\t\t\tcontinue;\n\t\tv1.push_back({});\n\t\tv2.push_back({});\n\t\tdfs5(v, 1, a[c], a[c], 0, 0);\n\t}\n\tfor(int k : {0, 1}) {\n\t\tdynamic_hull d;\n\t\td.upd(0, 0);\n\t\tfor(int i=0; i<v1.size(); ++i) {\n\t\t\tfor(ar<ll, 2> a : v2[i])\n\t\t\t\tans=max(d.qry(a[0])+a[1], ans);\n\t\t\tfor(ar<ll, 2> a : v1[i])\n\t\t\t\td.upd(a[0], a[1]);\n\t\t}\n\t\treverse(v1.begin(), v1.end());\n\t\treverse(v2.begin(), v2.end());\n\t}\n\tv1.clear();\n\tv2.clear();\n\tfor(int v : adj[c])\n\t\tif(ctp[v]==-1)\n\t\t\tdfs3(v, c);\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor(int i=1, u, v; i<n; ++i) {\n\t\tcin >> u >> v, --u, --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> a[i];\n\tmemset(ctp, -1, 4*n);\n\tdfs2(0);\n\tdfs3();\n\tcout << ans;\n}']",,,"['data structures', 'divide and conquer', 'geometry', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Sum of Prefix Sums.json,https://codeforces.com//blog/entry/73872,Let s use centroid decomposition to solve the problem We need to process all the paths going through each centroid somehow Consider a path from vertex to vertex going through vertex which is an ancestor of both and in the centroid decomposition tree Suppose the sequence of numbers on path from to including both these vertices is and the sequence of numbers on path from to including but excluding is Let and We can show that the sum of prefix sums of is equal to Now suppose we fix the second part of the path and are fixed and we want to find the best first part for this second part Each possible first part is represented by a linear function and our goal is to find the maximum over all these linear functions in the point and add to this maximum This can be done with the help of convex hull or Li Chao tree The most difficult part of implementation is how to process each centroid s subtree It s easy to obtain all first parts and second parts of paths going through the centroid but pairing them up can be complicated for each second part we have to build a convex hull or Li Chao tree on all first parts going to this centroid excluding those which go through the same child of the centroid as the second part we are considering One of the best ways to implement this is the following Suppose our centroid has children is the set of first parts going from the th child of the centroid and is the set of second parts going to the th child We will create a new data structure initially empty process all second parts from add all first parts from process all second parts from add all first parts from and so on After that we will clear our data structure process all second parts from add all first parts from process all second parts from add all first parts from and so on until we add all first parts from That way we will consider all possible first parts for each second part we are trying to use 
https://codeforces.com//contest/1924/problem/E,2447861,E,1924E,1924,E. Paper Cutting Again,There is a rectangular sheet of paper with initial height n and width m Let the current height and width be h and w respectively We introduce a xy coordinate system so that the four corners of the sheet are 0 0 w 0 0 h and w h The sheet can then be cut along the lines x 1 2 ldots w 1 and the lines y 1 2 ldots h 1 In each step the paper is cut randomly along any one of these h w 2 lines After each vertical and horizontal cut the right and bottom piece of paper respectively are discarded Find the expected number of steps required to make the area of the sheet of paper strictly less than k It can be shown that this answer can always be expressed as a fraction dfrac p q where p and q are coprime integers Calculate p cdot q 1 bmod 10 9 7 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nvoid solve() {\n    int n, m;\n    i64 k;\n    std::cin >> n >> m >> k;\n    \n    if (1LL * n * m < k) {\n        std::cout << 0 << ""\\n"";\n        return;\n    }\n    \n    Z ans = 1;\n    for (int i = 1; i < n; i++) {\n        if (1LL * i * m >= k) {\n            ans += comb.inv(i + m - 1);\n        }\n    }\n    for (int i = 1; i < m; i++) {\n        if (1LL * i * n >= k) {\n            ans += comb.inv(i + n - 1);\n        }\n    }\n    for (int s = 2, i = -1; s <= n + m - 2; s++) {\n        if (1LL * (s / 2) * ((s + 1) / 2) < k) {\n            continue;\n        }\n        if (i == -1) {\n            i = s / 2;\n        }\n        while (1LL * (i - 1) * (s - (i - 1)) >= k) {\n            i -= 1;\n        }\n        int l = std::max(i, s - (m - 1));\n        int r = std::min(s - i, n - 1);\n        ans += std::max(0, r - l + 1) * comb.inv(s) * comb.inv(s - 1) * 2;\n    }\n    \n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['combinatorics', 'probabilities']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Paper Cutting Again.json,https://codeforces.com//blog/entry/125137,TutorialFor the given problem we can solve it by dividing it into 4 cases Only Vertical Cuts Let the largest integer for which be The probability of achieving the goal using only vertical cuts is since one of the lines needs to be cut before all the horizontal lines Now we will multiply this with the sum of conditional probabilities for each of the vertical line Sum of conditional probabilities of being cut for all lines from to is exactly since for area to be smaller than one of them needs to be cut and as soon as one is cut the area becomes less than so no further cuts are required Now for the lines from to their conditional probabilities will form the following harmonic progression This is due to the fact that for a line to be cut it needs to occur before all horizontal lines and all vertical lines smaller than it Case with only horizontal cuts can be handled similarly Case when the overall last cut is a horizontal one and there is at least one vertical cut For this we iterate over the last cut among all the vertical cuts Let the last vertical cut be We now find the largest such that Let this value be The objective can be achieved using this case if the vertical line occurs before all the horizontal lines from to and all the vertical lines from to and after that any one of the horizontal line from to occur before all the vertical lines from to The probability of this happening is Now we just add the the conditional probabilities of being cut for every line and multiply this with the above probability to find the contribution of this case to the final answer a Firstly the conditional probability of the vertical line being cut is b The sum of conditional probabilities for horizontal lines to is also The order of the first vertical cuts and the first horizontal cuts for the given case would look like vertical lines and horizontal lines in any relative ordering Total elements in the sequence denotes the vertical cut denotes the horizontal cut which occurs first among all the first horizontal cuts c Vertical cuts from to For the cut we can look at this like it needs to occur before the vertical cut or it has one gap in the sequence to choose from a total of gaps So the probability is For the cut we can first place the cut with probability now we need to place the cut after of this which will happen with the probability of So the overall probability is the product i e Similarly the probability for cut is The sum of this Harmonic Progression can be computed in using pre computation d Horizontal cuts from to Trickiest Case imo Let us see the case for the cut It has optimal gaps before and the gap between and so the probability is Now for finding the probability for cut we first place this cut into one of the gaps and handle both cases separately Gap before this case is similar to case 3c and the answer is just Gap between and Here we again have to ensure that all lines from to occur after So we multiply since after we place the cut we have good gaps among a total of and so on for all the other lines we place Their relative ordering does not matter since we are only concerned with cut The final term for cut occurs out to be This forms a quadratic Harmonic Progression the sum of which can be computed in using precomputation Case when the overall last cut is a vertical one and there is at least one horizontal cut This case can be handled in a similar way as the previous case 
https://codeforces.com//contest/115/problem/C,604,C,115C,115,C. Plumber,Little John aspires to become a plumber Today he has drawn a grid consisting of rows and columns consisting of square cells In each cell he will draw a pipe segment He can only draw four types of segments numbered from to illustrated as follows Each pipe segment has two ends illustrated by the arrows in the picture above For example segment has ends at top and left side of it Little John considers the piping system to be leaking if there is at least one pipe segment inside the grid whose end is not connected to another pipe s end or to the border of the grid The image below shows an example of leaking and non leaking systems of size Now you will be given the grid that has been partially filled by Little John Each cell will either contain one of the four segments above or be empty Find the number of possible different non leaking final systems after Little John finishes filling of the empty cells with pipe segments Print this number modulo Note that rotations or flipping of the grid are not allowed and so two configurations that are identical only when one of them has been rotated or flipped either horizontally or vertically are considered two different configurations ,"['#include <vector>\n#include <cstring>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <stdlib.h>\n#include <ctime>\n#include <string>\n#include <complex>\n#ifdef __ASD__\n#include <windows.h>\n#endif\nusing namespace std;\n#define all(a) a.begin(),a.end()\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define fornn(i,n) for(i=0;i<(n);++i)\n#define lng long long\n#define SQ(a) ((a)*(a))\n#define forv(i,v) for(int i=0;i<(int)v.size();++i)\n#define mp make_pair\n#define pb push_back\n#define ABS(a) ((a)<0?-(a):(a))\n#define iinf 1000000000\n#define linf 1000000000000000000LL\n#define dinf 1e200\n#define left asdleft\n#define prev asdprev\n#define eps 1e-12\n#define y1 asdy1\n#define y2 asdy2\n#define EQ(a,b) abs((a)-(b))<eps\n#define PI 3.1415926535897932384626433832795\n#define DEG2RAD PI/180\n#define ulng unsigned lng\n#define next asdnext\n#define prev asdprev\nvoid mytimer(string task){\n#ifdef __ASD__\n        static LARGE_INTEGER prev;      LARGE_INTEGER cur,freq; QueryPerformanceCounter(&cur);  QueryPerformanceFrequency(&freq);       if(task!="""")            cout<<task<<"" took ""<<(cur.QuadPart-prev.QuadPart)*1.0/freq.QuadPart<<endl;     prev=cur;\n#endif\n}\nvoid ext(int c){\n#ifdef __ASD__\n        exit(c);\n#endif\n}\n\nbool was[2][510000][2];\nchar line[510000];\n\nconst int mod=1000003;\n\n#define taska ""burai""\nint main(){\n#ifdef __ASD__\n    freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#else\n    //freopen(taska"".in"",""r"",stdin);freopen(taska"".out"",""w"",stdout);\n#endif\n\n    int n,m;\n    cin>>n>>m;\n    gets(line);\n    forn(i,n){\n        gets(line);\n        forn(j,m){\n            char c=line[j];\n            if(c==\'.\')\n                continue;\n            int v=c-\'1\';\n            int v1=v/2;\n            int v2=(v+1)%4/2;\n            was[0][i][(j%2)^v1]=true;\n            was[1][j][(i%2)^v2]=true;\n        }\n    }\n    int len[]={n,m};\n\n    int res=1;\n    forn(q,2){\n        forn(i,len[q]){\n            bool w1=was[q][i][0];\n            bool w2=was[q][i][1];\n            if(w1&&w2)\n                res=0;\n            else if(!w1&&!w2)\n                res=res*2%mod;\n        }\n    }\n\n    cout<<res;\n\n    return 0;\n}\n']",,,['math'],2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Plumber.json,https://codeforces.com/blog/entry/2584,To solve this problem let s imagine that the left and top sides of the grid also determines whether the pipe adjacent to that side has an end connecting it to the side or not There are 2 N M ways to pick them We claim that if we fix them i e pick one of the possible 2 N M ways then the entire grid s pipes are fixed To see this notice that each pipe segment will have either one vertical end it either have end on the top or end on the bottom and one horizontal end left or right We can pick any 4 combinations of them Suppose we pick a row and determine whether the leftmost pipe should have an end to the left of it or not Suppose it doesn t have an opening to the left It means that the leftmost pipe should have an opening to the right the next pipe should have an opening to the left the next pipe to the right and so on Continuing this way we have fixed the horizontal ends for an entire row and only that Hence if we pick one of the possible 2 N M ways to pick the ends then the horizontal ends of each row and vertical ends of each column is fixed Since there is exactly one pipe segment that has a particular configuration of ends there is exactly one possible completed grid for each of the 2 N M ways to pick the ends Hence the solution works by first checking if a solution exists Any pre assigned pipe simply sets whether or not its corresponding row and column has an end at the left and top side We need to check that no two pipes sets this value contradictorily If any of them are contradictory then we return the answer as 0 Otherwise we return 2 number of rows without preassigned cell number of columns without preassigned cell 
https://codeforces.com//contest/1539/problem/B,1021671,B,1539B,1539,B. Love Song,Petya once wrote a sad love song and shared it to Vasya The song is a string consisting of lowercase English letters Vasya made up q questions about this song Each question is about a subsegment of the song starting from the l th letter to the r th letter Vasya considers a substring made up from characters on this segment and repeats each letter in the subsegment k times where k is the index of the corresponding letter in the alphabet For example if the question is about the substring then Vasya repeats letter once each of the letters twice letter three times so that the resulting string is its length is 10 Vasya is interested about the length of the resulting string Help Petya find the length of each string obtained by Vasya ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\nconst int MAXN=100005;\n\nint n;\nchar a[MAXN];\nint f[MAXN];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint q;readint(n),readint(q);scanf(""%s"",a+1);\n\tfor(int i=1;i<=n;++i)f[i]=f[i-1]+a[i]-\'a\'+1;\n\twhile(q--)\n\t{\n\t\tint l,r;readint(l),readint(r);\n\t\tprintf(""%d\\n"",f[r]-f[l-1]);\n\t}\n\treturn 0;\n}\n']",,,"['dp', 'implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Love Song.json,https://codeforces.com//blog/entry/91906,One can notice that letter with number will add exactly to the answer So all we have to do is calculate the sum of numbers of letters in our substring This can be done using prefix sums 
https://codeforces.com//contest/1152/problem/E,335384,E,1152E,1152,E. Neko and Flashback,A of length k is a sequence of k integers from 1 to k containing each integer exactly once For example the sequence 3 1 2 is a permutation of length 3 When Neko was five he thought of an array a of n positive integers and a permutation p of length n 1 Then he performed the following Constructed an array b of length n 1 where b i min a i a i 1 Constructed an array c of length n 1 where c i max a i a i 1 Constructed an array b of length n 1 where b i b p i Constructed an array c of length n 1 where c i c p i For example if the array a was 3 4 6 5 7 and permutation p was 2 4 1 3 then Neko would have constructed the following arrays b 3 4 5 5 c 4 6 6 7 b 4 5 3 5 c 6 7 4 6 Then he wrote two arrays b and c on a piece of paper and forgot about it 14 years later when he was cleaning up his room he discovered this old piece of paper with two arrays b and c written on it However he can t remember the array a and permutation p he used In case Neko made a mistake and there is no array a and permutation p resulting in such b and c print Otherwise help him recover any possible array a ,"['#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000000007 \n#define N 200005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nint n,cnt;\nint val[N];\nmap<int,int> mp;\nint vis[N];\nstack<int> s;\nmultiset<int> v[N];\n\nvoid dfs(int node) {\n\n\tvis[node]=1;\n\n\twhile(sz(v[node])) {\n\n\t\tint go=*v[node].begin();\n\n\t\tv[node].erase(v[node].begin());\n\n\t\tv[go].erase(v[go].find(node));\n\n\t\tdfs(go);\n\n\t}\n\n\ts.push(node);\n\n}\n\nint main() {\n\n\tscanf(""%d"",&n);\n\n\tvector<int> a(n+1),b(n+1);\n\n\tfor(int i=1;i<n;i++) {\n\n\t\tscanf(""%d"",&a[i]);\n\n\t\tif(!mp[a[i]]) {\n\n\t\t\tmp[a[i]]=++cnt;\n\n\t\t\tval[cnt]=a[i];\n\n\t\t}\n\n\t}\n\n\tfor(int i=1;i<n;i++) {\n\n\t\tscanf(""%d"",&b[i]);\n\n\t\tif(!mp[b[i]]) {\n\n\t\t\tmp[b[i]]=++cnt;\n\n\t\t\tval[cnt]=b[i];\n\n\t\t}\n\n\t\tif(b[i]<a[i]) {\n\n\t\t\tprintf(""-1"");\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tv[mp[a[i]]].insert(mp[b[i]]);\n\t\tv[mp[b[i]]].insert(mp[a[i]]);\n\n\t}\n\n\tvector<int> odd;\n\n\tfor(int i=1;i<=cnt;i++) {\n\n\t\tif(sz(v[i])&1) odd.pb(i);\n \n\t}\n\n\tif(sz(odd)>2) {\n\n\t\tprintf(""-1"");\n\n\t\treturn 0;\n\n\t}\n\n\tif(!sz(odd)) odd.pb(1);\n\n\tdfs(odd[0]);\n\n\tfor(int i=1;i<=cnt;i++) {\n\n\t\tif(!vis[i]) {\n\n\t\t\tprintf(""-1"");\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\twhile(sz(s)) {\n\n\t\tprintf(""%d "",val[s.top()]);\n\n\t\ts.pop();\n\n\t}\n\n}']",,,"['constructive algorithms', 'dfs and similar', 'graphs']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Neko and Flashback.json,https://codeforces.com/blog/entry/66696,Obviously if for some then the answer is 1 From the statement we have and For this to happen either one of the following must happen and and In order word one of the two following pairs or will match the pair From the statement we also have and Therefore one of the two following pairs or will match the pair Consider a graph with vertices For each from to we will add an undirected edge between and The following figure show such graph for the third example Consider the path Each edge will correspond to exactly one edge between and for some j In other word correspond to an Eulerian path on the graph The following figure show the path for the third example For implementation we need to do the following step For all elements of and we need to replace them with corresponding value from to where is the number of distinct value in and This part can be done using an balanced BST C map or Java TreeMap or by sorting in Build the graph as above Finding an Eulerian path in using Hierholzer s algorithm in or detect that such path does not exists Complexity 
https://codeforces.com//contest/1142/problem/A,322161,A,1142A,1142,A. The Beatles,Recently a Golden Circle of Beetlovers was found in Byteland It is a circle route going through n cdot k cities The cities are numerated from 1 to n cdot k the distance between the neighboring cities is exactly 1 km Sergey does not like beetles he loves burgers Fortunately for him there are n fast food restaurants on the circle they are located in the 1 st the k 1 st the 2k 1 st and so on the n 1 k 1 st cities i e the distance between the neighboring cities with fast food restaurants is k km Sergey began his journey at some city s and traveled along the circle making stops at cities each l km l 0 until he stopped in s once again Sergey then forgot numbers s and l but he remembers that the distance from the city s to the nearest fast food restaurant was a km and the distance from the city he stopped at after traveling the first l km from s to the nearest fast food restaurant was b km Sergey always traveled in the same direction along the circle but when he calculated distances to the restaurants he considered both directions Now Sergey is interested in two integers The first integer x is the minimum number of stops excluding the first Sergey could have done before returning to s The second integer y is the maximum number of stops excluding the first Sergey could have done before returning to s ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tll n, k, a, b;\n\tcin >> n >> k >> a >> b;\n\tll ans1 = n * k + 1, ans2 = 0;\n\n\tfor (int f = 0; f < 2; f++)\n\t\tfor (int g = 0; g < 2; g++) {\n\t\t\tll x = a, y = b;\n\t\t\tif (f == 1) x = (k - a) % k;\n\t\t\tif (g == 1) y = (k - b) % k;\n\t\t\tx -= y;\n\t\t\tif (x < 0) x += k;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ty = x + i * k;\t\n\t\t\t\ty = gcd(y, n * k);\n\t\t\t\ty = (n * k) / y;\n\t\t\t\tans1 = min(ans1, y);\n\t\t\t\tans2 = max(ans2, y);\n\t\t\t}\n\t\t}\n\tcout << ans1 << "" "" << ans2 << endl;\n\n\treturn 0;\n}\n']",,,"['brute force', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. The Beatles.json,https://codeforces.com//blog/entry/66301,Let s assume that we know the length of the jump and it is equal to Then in order to be back at the starting point Sergey will need to make exactly moves where is the greatest common divider Let where and are non negative integers So if we know and than can only take values where means modulo It is clear that only can be considered Then we iterate over all the variants of the pair and for each we find the number of moves to the starting point The minimum and maximum of the resulting numbers will be the answer 
https://codeforces.com//contest/966/problem/E,179479,E,966E,966,E. May Holidays,It s May in Flatland and there are m days in this month Despite the fact that May Holidays are canceled long time ago employees of some software company still have a habit of taking short or long vacations in May Of course not all managers of the company like this There are n employees in the company that form a tree like structure of subordination each employee has a unique integer id i between 1 and n and each employee with id i except the head manager whose id is 1 has exactly one direct manager with id p i The structure of subordination is not cyclic i e if we start moving from any employee to his direct manager then we will eventually reach the head manager We define that an employee u is a subordinate of an employee v if v is a direct manager of u or the direct manager of u is a subordinate of v Let s i be the number of subordinates the i th employee has for example s 1 n 1 because all employees except himself are subordinates of the head manager Each employee i has a bearing limit of t i which is an integer between 0 and s i It denotes the maximum number of the subordinates of the i th employee being on vacation at the same moment that he can bear If at some moment strictly more than t i subordinates of the i th employee are on vacation and the i th employee himself is not on a vacation he becomes In each of the m days of May exactly one event of the following two types happens either one employee leaves on a vacation at the beginning of the day or one employee returns from a vacation in the beginning of the day You know the sequence of events in the following m days Your task is to compute for each of the m days the number of displeased employees on that day ,"['#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nconst int M=400,inf=1000000000;\nusing namespace std;\nint n,m,w[100010],ww[100010],f[255][200010],g[255];\nvector<int> a[100010];\nint x[100010],y[100010],p,v[100010],fa[100010],ff[100010],q;\ninline void dp(int i,int j)\n{\n    v[i]=1;\n    for(auto k:a[i])\n      if(k!=j)\n        {\n         fa[k]=i;\n         dp(k,i);\n         v[i]+=v[k];\n        }\n}\ninline void lp(int i,int j,int k)\n{\n    ff[i]=k;\n    x[++p]=i;\n    y[i]=p;\n    int u=0;\n    for(auto l:a[i])\n      if(l!=j && v[l]>v[u])\n        u=l;\n    if(u)\n      lp(u,i,k);\n    for(auto l:a[i])\n      if(l!=j && l!=u)\n        lp(l,i,l);\n}\ninline void add1(int i)\n{\n    g[i]--;\n    q-=f[i][g[i]];\n}\ninline void del1(int i)\n{\n    q+=f[i][g[i]];\n    g[i]++;\n}\ninline void add2(int i,int k)\n{\n    if(w[k]>1e8)\n      {\n       w[k]++;\n       return;\n      }\n    f[i][w[k]]--;\n    w[k]++;\n    f[i][w[k]]++;\n    if(w[k]==g[i])\n      q--;\n}\ninline void del2(int i,int k)\n{\n    if(w[k]>1e8)\n      {\n       w[k]--;\n       return;\n      }\n    f[i][w[k]]--;\n    w[k]--;\n    f[i][w[k]]++;\n    if(w[k]==g[i]-1)\n      q++;\n}\ninline void orz1(int k)\n{\n    int i=k/M;\n    if(w[k]<g[i])\n      q--;\n    f[i][w[k]]--;\n    w[k]+=inf;\n}\ninline void orz2(int k)\n{\n    int i=k/M;\n    w[k]-=inf;\n    f[i][w[k]]++;\n    if(w[k]<g[i])\n      q++;\n}\ninline void add(int l,int r)\n{\n    int i=l/M,j=r/M,k;\n    if(i==j)\n      {\n       for(k=l;k<=r;k++)\n         add2(i,k);\n       return;\n      }\n    for(k=i+1;k<j;k++)\n      add1(k);\n    for(k=l;k<(i+1)*M && k<=n;k++)\n      add2(i,k);\n    for(k=j*M;k<=r && k<=n;k++)\n      add2(j,k);\n}\ninline void del(int l,int r)\n{\n    int i=l/M,j=r/M,k;\n    if(i==j)\n      {\n       for(k=l;k<=r;k++)\n         del2(i,k);\n       return;\n      }\n    for(k=i+1;k<j;k++)\n      del1(k);\n    for(k=l;k<(i+1)*M && k<=n;k++)\n      del2(i,k);\n    for(k=j*M;k<=r && k<=n;k++)\n      del2(j,k);\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k;\n\tscanf(""%d%d"",&n,&m);\n\tfor(i=2;i<=n;i++)\n\t  {\n       scanf(""%d"",&j);\n       a[j].pb(i);\n      }\n    for(i=1;i<=n;i++)\n      {\n       scanf(""%d"",&ww[i]);\n      }\n    dp(1,0);\n    lp(1,0,1);\n    for(i=1;i<=n;i++)\n      {\n       w[i]=ww[x[i]];\n       w[i]+=n;\n       f[i/M][w[i]]++;\n      }\n    for(i=0;i<=n/M;i++)\n      g[i]=n;\n    //for(i=1;i<=n;i++)\n      //cout<<i<<"" ""<<fa[i]<<"" ""<<ff[i]<<""\\n"";\n    while(m--)\n      {\n       scanf(""%d"",&i);\n       if(i>0)\n         k=0;\n       else\n         i=-i,k=1;\n       if(k)\n         orz2(y[i]);\n       else\n         orz1(y[i]);\n       for(;i>0;i=fa[j])\n         {\n          j=ff[i];\n          //cout<<i<<"" ""<<j<<""\\n"";\n          if(k)\n            add(y[j],y[i]);\n          else\n            del(y[j],y[i]);\n         }\n       printf(""%d "",q);\n      }\n\treturn 0;\n}\n']",,,"['data structures', 'trees']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. May Holidays.json,https://codeforces.com//blog/entry/59173,In terms of trees we have a rooted tree whose vertices may be activated and deactivated and each vertex has a limit for the number of deactivated vertices among its descendants We are required to switch the state of some vertex and after each query we report the number of activated vertices unsatisfied vertices Let the balance of a vertex be equal to the difference between its limit of deactivated descendants and the actual number of deactivated vertices among its descendants In such terms we are interested in the number of activated vertices with the negative balance Let s utilize the idea of sqrt optimization Consider a block of k consecutive queries let us answer all of them Suppose this query affects the state of vertices v1 v2 vl l k let us call such vertices interesting Then during the current query block the balance will change only for the vertices that have at least one interesting vertex in its subtree Let s perform a classical trick of building the condensed tree containing the given interesting vertices Namely sort all the interesting vertices in order of their visit when doing DFS and add all vertices of form lca vi vi 1 for all 1 i l to the set of interesting vertices After such procedure all vertices whose balance may change may be splitted into O k vertical paths each of which ends in an interesting vertex Now we are going to consider separately the interesting vertices and the interior vertices of all paths between interesting vertices In each of the paths the balance of all vertices is changed simultaneously thus we may sort all the vertices in each path by balance and then group all vertices having the same balance together Introduce a pointer that initially stands at the first satisfied group with non negative balance When the balance of all groups is changed by 1 instead of actually changing the value of balance we may just shift the pointer by at most one position to the left or to the right artificially changing the origin and accounting at most one group the pointer has passed in the answer On each query we have to perform such an operation with every path and interesting vertex that is located above the queried vertex Since each vertex and each path is processed in O 1 processing a single query takes O k time and processing all queries inside a block takes O k2 time It is possible to build all paths and groups in running time of a single DFS plus sort time std sort or counting sort for grouping vertices of equal balance This part of solution takes O n per each query block or O nlogn depending on used sorting algorithm If we use count sort the resulting complexity will be O mk k2 n finally we can take k n and get O mn running time 
https://codeforces.com//contest/832/problem/A,115517,A,832A,832,A. Sasha and Sticks,It s one more school day now Sasha doesn t like classes and is always bored at them So each day he invents some game and plays in it alone or with friends Today he invented one simple game to play with Lena with whom he shares a desk The rules are simple Sasha draws sticks in a row After that the players take turns crossing out exactly sticks from left or right in each turn Sasha moves first because he is the inventor of the game If there are less than sticks on the paper before some turn the game ends Sasha wins if he makes strictly more moves than Lena Sasha wants to know the result of the game before playing you are to help him ,"['#include <iostream>\n\nusing namespace std;\n\nint main() {\n  cin.sync_with_stdio(false);\n  cin.tie(nullptr);\n  int64_t n, k;\n  cin >> n >> k;\n  if (n / k % 2 == 1) {\n    cout << ""YES"" << endl;\n  } else {\n    cout << ""NO"" << endl;\n  }\n  return 0;\n}\n']",,,"['games', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Sasha and Sticks.json,https://codeforces.com//blog/entry/53461,Note that it s not important from which side sticks are being crossing out Players will make summary turns If this number is odd Sasha made more turn than Lena and won Otherwise Sasha and Lena made same number of turns and Sasha didn t win 
https://codeforces.com//contest/2060/problem/F,3147475,F,2060F,2060,F. Multiplicative Arrays,You re given integers k and n For each integer x from 1 to k count the number of integer arrays a such that all of the following are satisfied 1 leq a leq n where a represents the length of a 1 leq a i leq k for all 1 leq i leq a a 1 times a 2 times dots times a a x i e the product of all elements is x Note that two arrays b and c are different if either their lengths are different or if there exists an index 1 leq i leq b such that b i neq c i Output the answer modulo 998 244 353 ,"[""#include <bits/stdc++.h>using namespace std;\xa0static const int MOD = 998244353;static const int MAXK = 100000;\xa0inline long long modAdd(long long a, long long b) {\tlong long r = a + b;\tif (r >= MOD) r -= MOD;\treturn r;}inline long long modSub(long long a, long long b) {\tlong long r = a - b;\tif (r < 0) r += MOD;\treturn r;}inline long long modMul(long long a, long long b) {\treturn (a % MOD) * (b % MOD) % MOD;}long long modExp(long long base, long long exp) {\tlong long result = 1 % MOD;\tbase %= MOD;\twhile (exp > 0) {\t\tif (exp & 1) result = (result * base) % MOD;\t\tbase = (base * base) % MOD;\t\texp >>= 1;\t}\treturn result;}inline long long modInv(long long x) {\treturn modExp(x, MOD-2);}\xa0static int spf[MAXK+1];  void build_spf() {\tfor (int i = 2; i <= MAXK; i++) {\t\tif (!spf[i]) { \t\t\t// i is prime\t\t\tfor (long long j = (long long)i; j <= MAXK; j += i) {\t\t\t\tif (!spf[j]) spf[j] = i;\t\t\t}\t\t}\t}}\xa0vector<pair<int,int>> factor_small(int x) {\tvector<pair<int,int>> f;\twhile (x > 1) {\t\tint p = spf[x];\t\tint cnt = 0;\t\twhile (spf[x] == p) {\t\t\tx /= p;\t\t\tcnt++;\t\t}\t\tf.push_back({p,cnt});\t}\treturn f;}\xa0typedef long long ll;typedef vector<ll> Poly;Poly polyMul(const Poly &A, const Poly &B) {\tPoly C(A.size()+B.size()-1, 0LL);\tfor (size_t i=0; i<A.size(); i++){\t\tfor (size_t j=0; j<B.size(); j++){\t\t\tC[i+j] = modAdd(C[i+j], modMul(A[i], B[j]));\t\t}\t}\treturn C;}\xa0// P(m) = ( (m + 0)*(m + 1)*...*(m + a-1) ) / a!Poly bino(int a) {\tif (a == 0) {\t\treturn Poly(1, 1LL);\t}\tPoly res(1, 1LL); // constant 1\tfor(int j=0; j<a; j++){\t\tPoly tmp(res.size()+1, 0LL);\t\tfor (size_t i=0; i<res.size(); i++){\t\t\tll coeff = res[i];\t\t\t// (m + j) => \t\t\t//    newPoly[i+1] += coeff (coefficient for m^(i+1))\t\t\t//    newPoly[i]   += j*coeff\t\t\ttmp[i+1] = modAdd(tmp[i+1], coeff);\t\t\ttmp[i]   = modAdd(tmp[i], modMul(coeff, j));\t\t}\t\tres.swap(tmp);\t}\xa0\t// divide by a! mod\tstatic bool factInit = false;\tstatic ll fact[40], invfact[40];\tif (!factInit) {\t\tfactInit = true;\t\tfact[0]=1; for(int i=1;i<40;i++) fact[i]=modMul(fact[i-1], i);\t\tinvfact[39] = modInv(fact[39]);\t\tfor(int i=38;i>=0;i--){\t\t\tinvfact[i] = modMul(invfact[i+1], i+1);\t\t}\t}\tll invA = invfact[a]; // 1/(a!) mod\tfor (auto &c : res) {\t\tc = modMul(c, invA);\t}\treturn res;}static const int MAXP = 16; \xa0static vector<ll> sumPoly[MAXP+1];long long evalPoly(const Poly &poly, long long x) {\tlong long ans = 0;\tfor (int i=(int)poly.size()-1; i>=0; i--){\t\tans = modMul(ans, x);\t\tans = modAdd(ans, poly[i]);\t}\treturn ans;}long long sumpow(long long n, int p) {\tif (n < 0) return 0; // safety\treturn evalPoly(sumPoly[p], n);}void bsp() {\tfor(int p=0; p<=MAXP; p++){\t\tvector<long long> X(p+2), Y(p+2);\t\tX[0] = 0; Y[0] = 0;\t\tfor(int i=1; i<=p+1; i++){\t\t\tX[i] = i;\t\t\t// i^p mod\t\t\tlong long ipow = 1;\t\t\tfor(int r=0;r<p;r++){\t\t\t\tipow = modMul(ipow, i);\t\t\t}\t\t\tY[i] = modAdd(Y[i-1], ipow); \t\t}\t\tint L = p+2; // number of points\t\tvector<vector<long long>> F(L, vector<long long>(L,0LL));\t\tfor(int i=0;i<L;i++){\t\t\tF[i][0] = Y[i] % MOD;\t\t}\t\tfor(int j=1;j<L;j++){\t\t\tfor(int i=0; i<L-j;i++){\t\t\t\tlong long num = modSub(F[i+1][j-1], F[i][j-1]);\t\t\t\tlong long den = modSub(X[i+j], X[i]); // X[i+j] - X[i]\t\t\t\tlong long invDen = modInv((den+MOD)%MOD);\t\t\t\tF[i][j] = modMul(num, invDen);\t\t\t}\t\t}\t\tPoly res(1, 0LL);\t\tPoly curTerm(1, 1LL);\t\tfor(int j=0;j<L;j++){\t\t\tlong long coeff = F[0][j];\t\t\tPoly polyTerm(curTerm.size());\t\t\tfor(size_t u=0; u<curTerm.size(); u++){\t\t\t\tpolyTerm[u] = modMul(curTerm[u], coeff);\t\t\t}\t\t\tif (polyTerm.size() > res.size())\t\t\t\tres.resize(polyTerm.size(), 0);\t\t\tfor(size_t u=0; u<polyTerm.size(); u++){\t\t\t\tres[u] = modAdd(res[u], polyTerm[u]);\t\t\t}\t\t\tif (j+1 < L) {\t\t\t\tPoly newCur(curTerm.size()+1, 0LL);\t\t\t\tfor(size_t i=0; i<curTerm.size(); i++){\t\t\t\t\tnewCur[i+1] = modAdd(newCur[i+1], curTerm[i]);\t\t\t\t\tlong long tmp = modMul(curTerm[i], (MOD - (X[j] % MOD)));\t\t\t\t\tnewCur[i] = modAdd(newCur[i], tmp);\t\t\t\t}\t\t\t\tcurTerm.swap(newCur);\t\t\t}\t\t}\t\tsumPoly[p] = res;  // store\t}}\xa0int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr);\xa0\tbuild_spf();\tbsp();\tint t;\tcin >> t;\twhile(t--){\t\tlong long n;\t\tint k;\t\tcin >> k >> n;\xa0\t\tvector<long long> ans(k+1, 0);\xa0\t\tfor(int x=1; x<=k; x++){\t\t\tauto factx = factor_small(x);\t\t\tPoly polyRes(1, 1LL);\t\t\tfor (auto &pe : factx) {\t\t\t\tint expnt = pe.second;\t\t\t\tPoly pf = bino(expnt); \t\t\t\tpolyRes = polyMul(polyRes, pf);\t\t\t}\t\t\tlong long total = 0;\t\t\tfor (int i=0; i<(int)polyRes.size(); i++){\t\t\t\tif (polyRes[i] != 0) {\t\t\t\t\tlong long c = polyRes[i];\t\t\t\t\tlong long sp = sumpow(n, i);\t\t\t\t\ttotal = modAdd(total, modMul(c, sp));\t\t\t\t}\t\t\t}\t\t\tans[x] = total;\t\t}\t\tfor(int x=1; x<=k; x++){\t\t\tcout << ans[x];\t\t\tif (x<k) cout << ' ';\t\t}\t\tcout << '\\n';\t}\treturn 0;}""]",,,"['combinatorics', 'dp', 'number theory']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Multiplicative Arrays.json,https://codeforces.com/blog/entry/138342,The naive solution is to define fk n as the number of arrays containing n elements with a product of k We could then try to compute this by considering the last element of the array among the divisors of k giving us fk n j kfj n 1 with fk 1 1 The answers would then be ni 1f1 i ni 1f2 i ni 1fk i However this leads to an O nklogk solution which exceeds our time constraints We need to optimize this approach We can prove that there are at most 16 non 1 elements in our arrays This is because The prime factorization of k p1p2 pt divides k into the most non 1 elements With 17 non 1 elements the smallest possible value would be k 217 131072 105 Based on this observation we can define our dynamic programming state as Let dp i j represent the number of arrays with product i containing only j non 1 elements The recurrence relation becomes dp i j p i p 1dp ip j 1 Base case dp i 1 1 for i 1 This computation has a time complexity of O klog2k as we perform kj 1d j O klogk additions for each i To calculate fk n we Enumerate the number of non 1 elements from 1 to 16 For j non 1 elements in the array We have n j elements that are 1 We need to choose j positions for non 1 elements Fill these positions with dp k j possible sequences This gives us fk n 16j 1 nj dp k j Therefore i 1nfk n i 1n j 116 ij dp k j j 116 dp k j i 1n ij j 116 n 1j 1 dp k j Note that ni 1 ij n 1j 1 is given by the Hockey Stick Identity Each answer can be calculated in O log2k time giving an overall time complexity of O klog2k 
https://codeforces.com//contest/1710/problem/C,1478269,C,1710C,1710,C. XOR Triangle,You are given a positive integer n Since n may be very large you are given its binary representation You should compute the number of triples a b c with 0 leq a b c leq n such that a oplus b b oplus c and a oplus c are the sides of a non degenerate triangle Here oplus denotes the bitwise XOR operation You should output the answer modulo 998 244 353 Three positive values x y and z are the sides of a non degenerate triangle if and only if x y z x z y and y z x ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=222222,mod=998244353;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<\'0\' || ch>\'9\') f|=ch==\'-\',ch=getchar();\n\twhile(ch>=\'0\' && ch<=\'9\') x=x*10+ch-\'0\',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint n,f[maxn][8][8],a[maxn];\nchar s[maxn];\nint main(){\n\tscanf(""%s"",s+1);\n\tn=strlen(s+1);\n\tFOR(i,1,n) a[i]=s[i]-\'0\';\n\tf[0][7][7]=1;\n\tFOR(i,0,n-1) FOR(j,0,7) FOR(k,0,7) if(f[i][j][k]){\n\t\tint x=(j&1)?a[i+1]:1,y=(j&2)?a[i+1]:1,z=(j&4)?a[i+1]:1;\n\t\tFOR(p,0,x) FOR(q,0,y) FOR(r,0,z){\n\t\t\tint jj=j,kk=k;\n\t\t\tif(p!=x) jj&=~1;\n\t\t\tif(q!=y) jj&=~2;\n\t\t\tif(r!=z) jj&=~4;\n\t\t\tint pp=p^q,qq=q^r,rr=p^r;\n\t\t\tif(pp&qq) kk&=~1;\n\t\t\tif(qq&rr) kk&=~2;\n\t\t\tif(pp&rr) kk&=~4;\n\t\t\tf[i+1][jj][kk]=(f[i+1][jj][kk]+f[i][j][k])%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tFOR(i,0,7) ans=(ans+f[n][i][0])%mod;\n\tprintf(""%d\\n"",ans);\n}']",,,"['bitmasks', 'brute force', 'constructive algorithms', 'dp', 'greedy', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. XOR Triangle.json,https://codeforces.com//blog/entry/105232,Define cnti1i2i3 as j th bit of cnti1i2i3 is 1 iif i1 aj i2 bj i3 cj e g a 10 2 b 11 2 c 01 2 then cnt110 10 2 cnt011 01 2 other cnt is 0 a cnt100 cnt101 cnt110 cnt111 b cnt010 cnt011 cnt110 cnt111 c cnt001 cnt011 cnt101 cnt111 a b cnt010 cnt011 cnt100 cnt101 a c cnt001 cnt011 cnt100 cnt110 b c cnt001 cnt010 cnt101 cnt110 a b a c b c cnt011 cnt100 0 similar cnt101 cnt010 0 cnt110 cnt001 0 then we use digit dp dp n i j means when we consider first n bits state of reaching the upper bound is i state of conditions is j Enumerate ajbjcj for j from n 1 to 0 and make transition Time complexity is O 29 n where n is the length of input 
https://codeforces.com//contest/1608/problem/G,1223929,G,1608G,1608,G. Alphabetic Tree,You are given m strings and a tree on n nodes Each edge has some letter written on it You have to answer q queries Each query is described by 4 integers u v l and r The answer to the query is the total number of occurrences of str u v in strings with indices from l to r str u v is defined as the string that is made by concatenating letters written on the edges on the shortest path from u to v in order that they are traversed ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//yosupo\n//TKPPC G\nstruct SA{\n\tint n;\n\tvi sa,as,lcp;\n\tSA(){}\n\ttemplate<class t> SA(t s):n(s.size()),sa(n),as(n),lcp(n-1){\n\t\trep(i,n)sa[i]=n-1-i;\n\t\tstable_sort(all(sa),[&](int a,int b){return s[a]<s[b];});\n\t\tvi c(n);\n\t\trep(i,n)c[i]=s[i];\n\t\tfor(int w=1;w<n;w*=2){\n\t\t\tvi d(c);\n\t\t\trep(i,n){\n\t\t\t\tif(i&&sa[i-1]+w<n&&d[sa[i-1]]==d[sa[i]]&&d[sa[i-1]+w/2]==d[sa[i]+w/2])\n\t\t\t\t\tc[sa[i]]=c[sa[i-1]];\n\t\t\t\telse\n\t\t\t\t\tc[sa[i]]=i;\n\t\t\t}\n\t\t\tvi e(sa),f(n);\n\t\t\tiota(all(f),0);\n\t\t\trep(i,n){\n\t\t\t\tint j=e[i]-w;\n\t\t\t\tif(j>=0)sa[f[c[j]]++]=j;\n\t\t\t}\n\t\t}\n\t\t//as\n\t\trep(i,n)as[sa[i]]=i;\n\t\t//lcp\n\t\tint w=0;\n\t\tfor(auto i:as){\n\t\t\tif(w)w--;\n\t\t\tif(i<n-1){\n\t\t\t\twhile(max(sa[i],sa[i+1])+w<n&&s[sa[i]+w]==s[sa[i+1]+w])w++;\n\t\t\t\tlcp[i]=w;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//CF530F\n//returns the suffix tree\n//the i-th (0<=i<=n-1) element corresponds to the lexicographically i-th suffix\nstruct ste{\n\tint to,l,r;\n\toperator int()const{return to;}\n};\nostream&operator<<(ostream&os,const ste&a){\n\treturn os<<""ste{""<<a.to<<"",[""<<a.l<<"",""<<a.r<<""]}"";\n}\npair<vvc<ste>,int> stree(const SA&sa){\n\tint n=sa.n,s=n*2-1;\n\tvi len(s);\n\trep(i,n)len[i]=n-sa.sa[i];\n\trep(i,n-1)len[i+n]=sa.lcp[i];\n\tvi idx(n-1);\n\tiota(all(idx),n);\n\tstable_sort(all(idx),[&](int a,int b){return len[a]>len[b];});\n\tunionfind uf(s);\n\tvi par(s,-1),c(s,-1);\n\trep(i,n)c[i]=sa.sa[i];\n\tfor(auto i:idx){\n\t\tint a=uf.find(i-n),b=uf.find(i-n+1);\n\t\tuf.unite(i,a);\n\t\tuf.unite(i,b);\n\t\tpar[a]=i;\n\t\tpar[b]=i;\n\t\tc[i]=c[a];\n\t}\n\tpar[n==1?0:idx.back()]=s++;\n\tlen.pb(0);\n\tuf=unionfind(s);\n\trep(i,s-1)if(len[i]==len[par[i]])\n\t\tuf.unite(i,par[i]);\n\tvi vs;\n\trep(i,s)if(uf.find(i)==i)vs.pb(i);\n\tauto z=[&](int i){return lower_bound(all(vs),uf.find(i))-vs.bg;};\n\tvvc<ste> res(vs.size());\n\trep(ii,s-1){\n\t\tint i=ii/2+ii%2*n;\n\t\tint a=z(i),b=z(par[i]);\n\t\tif(a==b)continue;\n\t\tres[b].pb(ste{a,c[i]+len[par[i]],c[i]+len[i]});\n\t}\n\treturn make_pair(res,z(s-1));\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.clear();buf.resize(s=n,0);}\n\tvoid init(const vc<t>&a){\n\t\ts=si(a);\n\t\tbuf.resize(s);\n\t\trep(i,s)buf[i]=a[i];\n\t\trep(i,s){\n\t\t\tint j=i+((i+1)&(-i-1));\n\t\t\tif(j<s)buf[j]+=buf[i];\n\t\t}\n\t}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tvoid add_range(int b,int e,t v){\n\t\tadd(b,v);\n\t\tadd(e,-v);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\ntemplate<class t>\nstruct Point1D{\n\tBIT<t> bit;\n\tvi pos;\n\tvoid addp(int p){\n\t\tpos.pb(p);\n\t}\n\tvoid init(){\n\t\tmkuni(pos);\n\t\tbit.init(pos.size());\n\t}\n\tint idx(int p){\n\t\treturn lwb(pos,p);\n\t}\n\tvoid addv(int p,t v){\n\t\tbit.add(idx(p),v);\n\t}\n\tt sum(int b,int e){\n\t\treturn bit.sum(idx(b),idx(e));\n\t}\n\t//[-inf,p)\n\tt getpref(int p){\n\t\treturn bit.get(idx(p)-1);\n\t}\n};\n\ntemplate<class t>\nstruct Point2D{\n\tvc<Point1D<t>> buf;\n\tvi pos,xs,ys;\n\tvoid addp(int x,int y){\n\t\txs.pb(x);\n\t\tys.pb(y);\n\t}\n\tint idx(int p){\n\t\treturn lwb(pos,p);\n\t}\n\tvoid init(){\n\t\tpos=xs;\n\t\tmkuni(pos);\n\t\tbuf.resize(pos.size());\n\t\trep(i,xs.size())\n\t\t\tfor(int j=idx(xs[i]);j<int(buf.size());j+=(j+1)&(-j-1))\n\t\t\t\tbuf[j].addp(ys[i]);\n\t\tfor(auto&b:buf)b.init();\n\t}\n\tvoid addv(int x,int y,t v){\n\t\tfor(int j=idx(x);j<int(buf.size());j+=(j+1)&(-j-1))\n\t\t\tbuf[j].addv(y,v);\n\t}\n\t//[x1,x2)*[y1,y2)\n\tt rect(int x1,int x2,int y1,int y2){\n\t\tt res=0;\n\t\tfor(int j=idx(x1)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres-=buf[j].sum(y1,y2);\n\t\tfor(int j=idx(x2)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres+=buf[j].sum(y1,y2);\n\t\treturn res;\n\t}\n\t//NOT VERIFIED\n\t//[-inf,x)*[-inf,y)\n\tt getpref(int x,int y){\n\t\tt res=0;\n\t\tfor(int j=idx(x)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres+=buf[j].getpref(y);\n\t\treturn res;\n\t}\n};\n\n\n//KUPC 2020 C\n//\n// (a,b) LCA  a LCA  b \n// N \n//N() \n//N.extend(e)  e \n//N  extend \ntemplate<class E,class N>\nstruct cdecomp{\n\tconst vvc<E>&g;\n\tint n;\n\tvi rem;\n\t\n\tint ts(int v,int p){\n\t\tint res=1;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e])\n\t\t\tres+=ts(e,v);\n\t\treturn res;\n\t}\n\tint fc(int v,int p,int s){\n\t\tint ret=1,mx=0;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e]){\n\t\t\tint f=fc(e,v,s);\n\t\t\tif(f<=0)\n\t\t\t\treturn f;\n\t\t\telse{\n\t\t\t\tret+=f;\n\t\t\t\tmx=max(mx,f);\n\t\t\t}\n\t\t}\n\t\tmx=max(mx,s-ret);\n\t\tif(mx*2<=s)\n\t\t\treturn -v;\n\t\telse\n\t\t\treturn ret;\n\t}\n\t\n\tcdecomp(const vvc<E>&gg):g(gg),n(g.size()),rem(n){\n\t}\n\t\n\tvc<N> buf0;\n\tvc<N> buf1;\n\tvi tp;\n\tvvc<tuple<int,int,int>> bucket;\n\t\n\tvoid dfs1(int v,int p,int i,N cur0,N cur1){\n\t\tbuf0[v]=cur0;\n\t\tbuf1[v]=cur1;\n\t\ttp[v]=i;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e]){\n\t\t\tdfs1(e,v,i==-1?e:i,cur0.extend(e),cur1.extend(e));\n\t\t}\n\t}\n\t\n\ttemplate<class F>\n\tvoid con(int r,const vc<tuple<int,int,int>>&qs,F f){\n\t\tr=-fc(r,-1,ts(r,-1));\n\t\t\n\t\tN ini0,ini1;\n\t\tini0.init(0);\n\t\tini1.init(1);\n\t\tdfs1(r,-1,-1,ini0,ini1);\n\t\tfor(const auto&w:qs){\n\t\t\tint a,b,i;tie(a,b,i)=w;\n\t\t\tif(tp[a]!=tp[b]){\n\t\t\t\tf(i,buf0[a],buf1[b],r);\n\t\t\t}else{\n\t\t\t\tbucket[tp[a]].pb(w);\n\t\t\t}\n\t\t}\n\t\t\n\t\trem[r]=1;\n\t\tfor(auto e:g[r])if(!rem[e]){\n\t\t\tvc<tuple<int,int,int>> tmp;\n\t\t\ttmp.swap(bucket[e]);\n\t\t\tcon(e,tmp,f);\n\t\t}\n\t}\n\t\n\t//f(idx,N lf,N rt,int lca) \n\t//[qs[i].a,lca)  lf [qs[i].b,lca)  rt \n\ttemplate<class F>\n\tvoid slv(const vc<pi>&qs,F f){\n\t\tfill(all(rem),0);\n\t\tbuf0.resize(n);\n\t\tbuf1.resize(n);\n\t\ttp.resize(n);\n\t\tbucket.resize(n);\n\t\t\n\t\tvc<tuple<int,int,int>> tmp(si(qs));\n\t\trep(i,si(qs))\n\t\t\ttmp[i]=mt(qs[i].a,qs[i].b,i);\n\t\tcon(0,tmp,f);\n\t}\n};\n\nstruct E{\n\tint to;\n\tchar c;\n\toperator int()const{return to;}\n};\n\nSA sa[2];\nvvc<ste> st[2];\nint stroot[2];\nvi in[2],out[2];\nint ord[2];\n\nvoid dfs(int k,int v){\n\tin[k][v]=ord[k]++;\n\tfor(auto e:st[k][v])\n\t\tdfs(k,e.to);\n\tout[k][v]=ord[k];\n}\n\nstring z[2];\n\nstruct N{\n\tint k,v,dig,len;\n\tvoid init(int kk){\n\t\tk=kk;\n\t\tv=stroot[k];\n\t\tdig=-1;\n\t\tlen=-1;\n\t}\n\tN extend(const E&e)const{\n\t\tif(v==-1)return N{-1,-1,-1,-1};\n\t\tN res=*this;\n\t\tif(res.dig==-1){\n\t\t\trep(i,si(st[k][v])){\n\t\t\t\tif(z[k][st[k][v][i].l]==e.c){\n\t\t\t\t\tres.dig=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res.dig==-1){\n\t\t\t\treturn N{-1,-1,-1,-1};\n\t\t\t}\n\t\t\tres.len=0;\n\t\t}\n\t\tconst auto&f=st[k][v][res.dig];\n\t\tif(z[k][f.l+res.len]!=e.c)return N{-1,-1,-1,-1};\n\t\tres.len++;\n\t\tif(f.r-f.l==res.len){\n\t\t\treturn N{k,f.to,-1,-1};\n\t\t}else{\n\t\t\treturn res;\n\t\t}\n\t}\n\tpi getlr(){\n\t\tif(v==-1)return pi(-1,-1);\n\t\tint w=v;\n\t\tif(len>0){\n\t\t\tw=st[k][v][dig].to;\n\t\t}\n\t\treturn pi(in[k][w],out[k][w]);\n\t}\n};\n\n/*\n//example\nauto slv=[&](int dst,N x,N y,int lca){\n\tx.off^=y.off;\n\trep(i,y.s)x.add(y.vs[i]);\n\tif(cv[lca]!=-1)x.add(cv[lca]);\n\tans[dst]=x.getans(ks[dst]);\n};\n*/\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\t\n\tvvc<E> tr(n);\n\trep(i,n-1){\n\t\tint u,v;cin>>u>>v;\n\t\tu--;v--;\n\t\tstring s;cin>>s;\n\t\ttr[u].pb(E{v,s[0]});\n\t\ttr[v].pb(E{u,s[0]});\n\t}\n\t\n\tz[0]=""$"";\n\tvi off(m),len(m);\n\trep(i,m){\n\t\toff[i]=si(z[0]);\n\t\tstring s;cin>>s;\n\t\tlen[i]=si(s);\n\t\tz[0]+=s;\n\t\tz[0]+=\'$\';\n\t}\n\tz[1]=z[0];\n\treverse(all(z[1]));\n\t\n\trep(k,2){\n\t\ttie(st[k],stroot[k])=stree(sa[k]=SA(z[k]));\n\t\tin[k].resize(si(st[k]));\n\t\tout[k].resize(si(st[k]));\n\t\tdfs(k,stroot[k]);\n\t\tdmp(k);\n\t\tdmp(st[k]);\n\t\tdmp(in[k]);\n\t}\n\t\n\tusing P=pair<pi,pi>;\n\tvc<pi> uv(q);\n\tvvc<int> baka(m+1);\n\tvc<P> ls(q);\n\trep(i,q){\n\t\tint u,v,l,r;cin>>u>>v>>l>>r;\n\t\tu--,v--,l--;\n\t\tuv[i]=pi(v,u);\n\t\tbaka[l].pb(i*2);\n\t\tbaka[r].pb(i*2+1);\n\t}\n\t\n\tauto unko=[&](int idx,N lf,N rt,int){\n\t\tls[idx]=P(lf.getlr(),rt.getlr());\n\t};\n\t\n\tcdecomp<E,N> cd(tr);\n\tcd.slv(uv,unko);\n\t\n\tdmp(ls);\n\t\n\tPoint2D<int> p2d;\n\trep(i,m){\n\t\trng(j,off[i],off[i]+len[i]+1){\n\t\t\tint x=in[0][sa[0].as[j]];\n\t\t\tint y=in[1][sa[1].as[si(z[1])-j]];\n\t\t\tdmp2(x,y);\n\t\t\tp2d.addp(x,y);\n\t\t}\n\t}\n\tp2d.init();\n\t\n\tvi ans(q);\n\t\n\trep(i,m+1){\n\t\tfor(auto w:baka[i]){\n\t\t\tauto [xl,xr]=ls[w/2].a;\n\t\t\tauto [yl,yr]=ls[w/2].b;\n\t\t\tans[w/2]+=p2d.rect(xl,xr,yl,yr)*(w%2==0?-1:1);\n\t\t}\n\t\tif(i<m){\n\t\t\trng(j,off[i],off[i]+len[i]+1){\n\t\t\t\tint x=in[0][sa[0].as[j]];\n\t\t\t\tint y=in[1][sa[1].as[si(z[1])-j]];\n\t\t\t\tp2d.addv(x,y,1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,q)print(ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['binary search', 'data structures', 'dfs and similar', 'hashing', 'string suffix structures', 'strings', 'trees']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\G. Alphabetic Tree.json,https://codeforces.com//blog/entry/97782,Let s concatenate the input strings separated by some character not in the input into a string and build the suffix array over it If we could lexicographically compare to some suffix of we could use binary search to find the left and right boundary of suffixes that start with in the suffix array Knowing how to find the longest common prefix of a path in the tree and a suffix of would help us in comparing them since we would know the first position where these string differ Letters on the tree are still unrelated to the letters in concatenated string so let s append them to in some helpful way Let s split the tree into chains using heavy light decomposition and append the chains and reversed chains to the string This way every path in the tree can be split into parts which are substrings of Let s build LCP array of from it s suffix array and then sparse table over the LCP array to be able to answer queries for longest common prefix of two suffixes of in With such queries we can get longest common prefix of a path and a suffix of in by querying LCP for parts of the path and corresponding suffixes of Now we know how to find the range of suffixes which have as a prefix Out of these suffixes we have to count only these for which first position belongs to a string with index in the set We can do the counting offline sweeping through strings from the first to the last and maintaining binary indexed tree over suffix array In iteration we store for suffixes of strings with indices and for the rest A query can be solved by taking the difference of sums on suffix array range in iteration and in iteration Building suffix array can be done in or depending on the chosen algorithm LCP array can be constructed from the suffix array in using Kasai s algorithm while the sparse table construction works in and uses memory Searching for the ranges can be done in as described above and the last offline sweeping part takes time The overall time complexity is with memory 
https://codeforces.com//contest/738/problem/B,81056,B,738B,738,B. Spotlights,Theater stage is a rectangular field of size The director gave you the stage s plan which actors will follow For each cell it is stated in the plan if there would be an actor in this cell or not You are to place a spotlight on the stage in some position The spotlight will project light in one of the four directions if you look at the stage from above left right up or down Thus the spotlight s position is a cell it is placed to and a direction it shines A position is if two conditions hold there is no actor in the cell the spotlight is placed to there is at least one actor in the direction the spotlight projects Count the number of positions for placing the spotlight Two positions of spotlight are considered to be different if the location cells or projection direction differ ,"['#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <unordered_map>\nusing namespace std;\n\nint n;\nint a[2001][2001];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int g = 1; g <= m; g++)\n        {\n            cin >> a[i][g];\n        }\n    }\n\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        bool t = false;\n        for (int g = 1; g <= m; g++)\n        {\n            if (!a[i][g])\n                ans += t;\n            if (a[i][g])\n            {\n                t = true;\n            }\n        }\n\n        t = false;\n        for (int g = m; g >= 1; g--)\n        {\n            if (!a[i][g])\n                ans += t;\n            if (a[i][g])\n            {\n                t = true;\n            }\n        }\n    }\n\n    for (int g = 1; g <= m; g++)\n    {\n        bool t = false;\n        for (int i = 1; i <= n; i++)\n        {\n            if (!a[i][g])\n            {\n                ans += t;\n            }\n\n            if (a[i][g])\n            {\n                t = true;\n            }\n        }\n\n        t = false;\n        for (int i = n; i >= 1; i--)\n        {\n            if (!a[i][g])\n            {\n                ans += t;\n            }\n\n            if (a[i][g])\n            {\n                t = true;\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n']",,,"['brute force', 'dp', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Spotlights.json,https://codeforces.com//blog/entry/48501,Let s find the number of good positions where projector directed to the left It can be done separately for each row To make it we need to iterate through the row from the left to the right and store information about we met 1 for example in the variable f Then if we process the current value if it is equal to 0 add one to the answer if f equals to true if it is equal to 1 then f true We can find the answer for the 3 remaining directions in the same way 
https://codeforces.com//contest/1355/problem/B,621792,B,1355B,1355,B. Young Explorers,Young wilderness explorers set off to their first expedition led by senior explorer Russell Explorers went into a forest set up a camp and decided to split into groups to explore as much interesting locations as possible Russell was trying to form groups but ran into some difficulties Most of the young explorers are inexperienced and sending them alone would be a mistake Even Russell himself became senior explorer not long ago Each of young explorers has a positive integer parameter e i his inexperience Russell decided that an explorer with inexperience e can only join the group of e or more people Now Russell needs to figure out how many groups he can organize It s not necessary to include every explorer in one of the groups some can stay in the camp Russell is worried about this expedition so he asked you to help him ,"['#include <bits/stdc++.h>\n#define ld long double\n#define endl ""\\n""\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n//#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\n\n\nvoid solve(){\n  int n;\n  cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++){\n    cin>>v[i];\n  }\n  sort(v.begin(),v.end());\n  int tot=0;\n\n  for(int i=0;i<v.size();){\n    int inside = 1;\n    int mx = v[i];\n    i++;\n    while(i<n and inside < mx){\n      inside++;\n      mx = max(mx,v[i]);\n      i ++;\n    }\n    if(inside==mx){\n      tot++;\n    }\n\n  }\n  cout << tot << endl;\n}\n\nint32_t main(){\n  fastio;\n  int t=1;\n  cin>>t;\n  while(t--){\n    solve();\n  }\n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}']",,,"['dp', 'greedy', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Young Explorers.json,https://codeforces.com//blog/entry/77491,Let s sort all the explorers by non decreasing inexperience Suppose we have formed some group how can we check is this group is valid Inexperience of all the explorers in the group should be not greater than the group size But we have sorted all the explorers so the last explorer from the group has the largest inexperience Therefore to check the group for validity it is necessary and sufficient to check that inexperience of the last explorer is not greater than the group size We can notice that we don t even look at all the explorers except the last one the only important thing is their number In fact we can organize the creation of groups in this way first choose the explorers that will be the last in their groups then assign sufficient number of other explorers to corresponding groups It is not profitable to assign more explorers than needed for this particular last explorer because we can always leave them at the camp So how should we choose the last explorers We want to make more groups so the groups themselves should me smaller It is tempting to use the following greedy algorithm let s greedily pick the leftmost which means with the smallest necessary group size explorer such that they have enough explorers to the left of them to create a valid group The idea is that we spend the smallest number of explorers and leave the most potential last explorers in the future Let s strictly prove this greedy The solution is defined by positions of the last explorers in their corresponding groups 1 le p 1 p 2 ldots p k le n Notice that the solution is valid if and only if e p 1 e p 2 ldots e p i le p i for all 1 le i le k we always have enough explorers to form first i groups Let 1 le p 1 p 2 ldots p k le n be the greedy solution and 1 le q 1 q 2 ldots q m le n be the optimal solution such that it has the largest common prefix with greedy one among all optimal solutions Let t be the position of first difference in these solutions t le k since otherwise the greedy algorithm couldn t add one more group but it was possible p t q t since otherwise the greedy algorithm would take q t instead of p t Since the explorers are sorted we have e p t le e q t But then 1 le q 1 q 2 ldots q t 1 p t q t 1 ldots q m le n is a valid optimal solution and it has strictly larger common prefix with the greedy one which contradicts the choosing of our optimal solution To implement this solution it is enough to sort the explorers by the non decreasing inexperience then go from left to right and maintain the number of unused explorers As soon as we encounter the possibility to create a new group we do it 
https://codeforces.com//contest/1845/problem/F,1986293,F,1845F,1845,F. Swimmers in the Pool,There is a pool of length l where n swimmers plan to swim People start swimming at the same time at the time moment 0 but you can assume that they take different lanes so they don t interfere with each other Each person swims along the following route they start at point 0 and swim to point l with constant speed which is equal to v i units per second for the i th swimmer After reaching the point l the swimmer instantly in negligible time turns back and starts swimming to the point 0 with the same constant speed After returning to the point 0 the swimmer starts swimming to the point l and so on Let s say that some moment of time is a if there are swimmers that are in the same point of the pool at that moment of time that point may be 0 or l as well as any other real point inside the pool The pool will be open for t seconds You have to calculate the number of meeting moments while the pool is open Since the answer may be very large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\ntypedef long long ll;\nconst int p=998244353;\nint po(int a,int b) {if(b==0) return 1; if(b==1) return a; if(b%2==0) {int u=po(a,b/2);return (u*1LL*u)%p;} else {int u=po(a,b-1);return (a*1LL*u)%p;}}\nint inv(int x) {return po(x,p-2);}\ntemplate<int M, int K, int G> struct Fft {\n  // 1, 1/4, 1/8, 3/8, 1/16, 5/16, 3/16, 7/16, ...\n  int g[1 << (K - 1)];\n  Fft() : g() { //if tl constexpr...\n    static_assert(K >= 2, ""Fft: K >= 2 must hold"");\n    g[0] = 1;\n    g[1 << (K - 2)] = G;\n    for (int l = 1 << (K - 2); l >= 2; l >>= 1) {\n      g[l >> 1] = (static_cast<long long>(g[l]) * g[l]) % M;\n    }\n    assert((static_cast<long long>(g[1]) * g[1]) % M == M - 1);\n    for (int l = 2; l <= 1 << (K - 2); l <<= 1) {\n      for (int i = 1; i < l; ++i) {\n        g[l + i] = (static_cast<long long>(g[l]) * g[i]) % M;\n      }\n    }\n  }\n  void fft(vector<int> &x) const {\n    const int n = x.size();\n    assert(!(n & (n - 1)) && n <= 1 << K);\n    for (int h = __builtin_ctz(n); h--; ) {\n      const int l = 1 << h;\n      for (int i = 0; i < n >> 1 >> h; ++i) {\n        for (int j = i << 1 << h; j < ((i << 1) + 1) << h; ++j) {\n          const int t = (static_cast<long long>(g[i]) * x[j | l]) % M;\n          if ((x[j | l] = x[j] - t) < 0) x[j | l] += M;\n          if ((x[j] += t) >= M) x[j] -= M;\n        }\n      }\n    }\n    for (int i = 0, j = 0; i < n; ++i) {\n      if (i < j) std::swap(x[i], x[j]);\n      for (int l = n; (l >>= 1) && !((j ^= l) & l); ) {}\n    }\n  }\n  vector<int> convolution(const vector<int> &a, const vector<int> &b) const {\n    if(a.empty() || b.empty()) return {};\n    const int na = a.size(), nb = b.size();\n    int n, invN = 1;\n    for (n = 1; n < na + nb - 1; n <<= 1) invN = ((invN & 1) ? (invN + M) : invN) >> 1;\n    vector<int> x(n, 0), y(n, 0);\n    std::copy(a.begin(), a.end(), x.begin());\n    std::copy(b.begin(), b.end(), y.begin());\n    fft(x);\n    fft(y);\n    for (int i = 0; i < n; ++i) x[i] = (((static_cast<long long>(x[i]) * y[i]) % M) * invN) % M;\n    std::reverse(x.begin() + 1, x.end());\n    fft(x);\n    x.resize(na + nb - 1);\n    return x;\n  }\n};\nFft<998244353,23,31> muls;\nvector<int> form(vector<int> v,int n)\n{\n    while(v.size()<n) v.push_back(0);\n    while(v.size()>n) v.pop_back();\n    return v;\n}\nvector<int> operator *(vector<int> v1,vector<int> v2)\n{\n    return muls.convolution(v1,v2);\n}\nvector<int> operator +(vector<int> v1,vector<int> v2)\n{\n    while(v2.size()<v1.size()) v2.push_back(0); while(v1.size()<v2.size()) v1.push_back(0);\n    for(int i=0;i<v1.size();++i) {v1[i]+=v2[i];if(v1[i]>=p) v1[i]-=p; else if(v1[i]<0) v1[i]+=p;}\n    return v1;\n}\nvector<int> operator -(vector<int> v1,vector<int> v2)\n{\n    int sz=max(v1.size(),v2.size());while(v1.size()<sz) v1.push_back(0); while(v2.size()<sz) v2.push_back(0);\n    for(int i=0;i<sz;++i) {v1[i]-=v2[i];if(v1[i]<0) v1[i]+=p; else if(v1[i]>=p) v1[i]-=p;} return v1;\n}\nvector<int> trmi(vector<int> v)\n{\n    for(int i=1;i<v.size();i+=2) {if(v[i]>0) v[i]=p-v[i]; else v[i]=(-v[i]);}\n    return v;\n}\nvector<int> deriv(vector<int> v)\n{\n    if(v.empty()) return{};\n    vector<int> ans(v.size()-1);\n    for(int i=1;i<v.size();++i) ans[i-1]=(v[i]*1LL*i)%p;\n    return ans;\n}\nvector<int> integ(vector<int> v)\n{\n    vector<int> ans(v.size()+1);ans[0]=0;\n    for(int i=1;i<v.size();++i) ans[i-1]=(v[i]*1LL*i)%p;\n    return ans;\n}\nvector<int> mul(vector<vector<int> > v)\n{\n    if(v.size()==1) return v[0];\n    vector<vector<int> > v1,v2;for(int i=0;i<v.size()/2;++i) v1.push_back(v[i]); for(int i=v.size()/2;i<v.size();++i) v2.push_back(v[i]);\n    return muls.convolution(mul(v1),mul(v2));\n}\nvector<int> inv1(vector<int> v,int n)\n{\n    assert(v[0]!=0);\n    int sz=1;v=form(v,n);vector<int> a={inv(v[0])};\n    while(sz<n)\n    {\n        vector<int> vsz;for(int i=0;i<min(n,2*sz);++i) vsz.push_back(v[i]);\n        vector<int> b=((vector<int>) {1})-muls.convolution(a,vsz);\n        for(int i=0;i<sz;++i) assert(b[i]==0);\n        b.erase(b.begin(),b.begin()+sz);\n        vector<int> c=muls.convolution(b,a);\n        for(int i=0;i<sz;++i) a.push_back(c[i]);\n        sz*=2;\n    }\n    return form(a,n);\n}\nvector<int> inv(vector<int> v,int n)\n{\n    v=form(v,n);assert(v[0]!=0);if(v.size()==1) {return {inv(v[0])};} vector<int> v1=trmi(v);\n    vector<int> a=v1*v;a=form(a,2*n);\n    vector<int> b((n+1)/2);for(int i=0;i<b.size();++i) b[i]=a[2*i];\n    vector<int> ans1=inv(b,b.size());vector<int> ans2(n);for(int i=0;i<n;++i) {if(i%2==0) ans2[i]=ans1[i/2]; else ans2[i]=0;}\n    return form(v1*ans2,n);\n}\nvector<int> operator/(vector<int> a,vector<int> b)\n{\n    while(!a.empty() && a.back()==0) a.pop_back(); while(!b.empty() && b.back()==0) b.pop_back();\n    int n=a.size();int m=b.size();if(n<m) return {};\n    reverse(a.begin(),a.end());reverse(b.begin(),b.end());vector<int> ans=a*inv(b,n-m+1);while(ans.size()>n-m+1) ans.pop_back();\n    reverse(ans.begin(),ans.end());while(!ans.empty() && ans.back()==0) ans.pop_back();return ans;\n}\nvector<int> operator%(vector<int> a,vector <int> b)\n{\n    vector<int> ans=a-b*(a/b);while(!ans.empty() && ans.back()==0) ans.pop_back(); return ans;\n}\nconst int mod=1e9+7;\nconst int maxn=4e5+5;\nint o=maxn/2;\nbool ok[maxn];\nint answ[maxn];\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int l,t1;cin>>l>>t1;\n    int n;\n    cin>>n;\n    vector<int> a(maxn);\n    for(int i=0;i<n;++i)\n    {\n        int v;cin>>v;a[v]=1;\n    }\n    vector<int> a1=a*a;\n    for(int i=0;i<maxn;++i)\n    {\n        int h=a1[i];if(i%2==0 && a[i/2]) h--;\n        if(h) {ok[i]=true;}\n    }\n    vector<int> b=a;\n    reverse(b.begin(),b.begin()+o);\n    vector<int> a2=a*b;\n    for(int i=0;i<o;++i)\n    {\n        if(a2[i])\n        {\n            ok[o-i-1]=true;\n        }\n    }\n    //for(int j=0;j<10;++j) cout<<ok[j]<<\' \'; cout<<endl;\n    for(int g=1;g<maxn;++g)\n    {\n        answ[g]=(t1*g)/(2*l);\n    }\n    int res=0;\n    for(int g=1;g<maxn;++g)\n    {\n        bool ok1=false;\n        for(int k=g;k<maxn;k+=g)\n        {\n            if(ok[k]) ok1=true;\n            if(k!=g) answ[k]-=answ[g];\n        }\n        //if(ok1) cout<<g<<"" g ""<<answ[g]<<"" answ[g] ""<<endl;\n        if(ok1) {res+=answ[g];res%=mod;}\n    }\n    cout<<(res%mod+mod)%mod;\n    return 0;\n}\n']",,,"['dp', 'fft', 'math', 'number theory']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Swimmers in the Pool.json,https://codeforces.com//blog/entry/117791,Firstly note that there are two different situations when some two swimmers meet they either move in the same direction or in opposite directions Suppose swimmers and meet while moving in the same direction We can write some easy system of equation and get that they will meet each seconds Analogically if they meet while moving in the opposite directions they will meet each seconds Let s create array that will contain all possible values exactly once If then values and we can calculate all of them using FFT fast multiplication two times for sums and for differences Okay we got all possible how to calculate the answer For a fixed value meeting moments are for all in segment is the upper bound and can be calculated as We found that for each there are exactly meeting points but since in one meeting moment more than two swimmers may meet we need to calculate each value exactly once Note that iff And we can rephrase our task as following calculate the number of unique fractions where The key idea here is to calculate only irreducible fractions Suppose we have fractions Let s add to the answer only irreducible fractions among them we will discuss how to do it later For any other fraction and is a divisor of If we fix some divisor of there will be exactly fractions with Moreover numerators will also form a segment So instead of calculating them now we will just pass that task to In total we iterate in decreasing order add only the number of irreducible fractions to the answer Then iterate over all divisors of and update value for with value How to calculate the number of irreducible fractions with With M bius function of course since for each divisor of there are exactly fractions where by Both passing calculations and M bius inversion works in And since we iterate over all the total complexity is Both FFT and next part works in so the total complexity is P S If you note that if then is always equal to then you can not only simplify the part with passing down calculations but get rid of M bius inversion at all replacing it with Sieve like two for s iterations 
https://codeforces.com//contest/979/problem/C,183085,C,979C,979,C. Kuro and Walking Route,Kuro is living in a country called Uberland consisting of n towns numbered from 1 to n and n 1 bidirectional roads connecting these towns It is possible to reach each town from any other Each road connects two towns a and b Kuro loves walking and he is planning to take a walking marathon in which he will choose a pair of towns u v u neq v and walk from u using the shortest path to v note that u v is considered to be different from v u Oddly there are 2 special towns in Uberland named Flowrisa denoted with the index x and Beetopia denoted with the index y Flowrisa is a town where there are many strong scent flowers and Beetopia is another town where many bees live In particular Kuro will avoid any pair of towns u v if on the path from u to v he reaches Beetopia after he reached Flowrisa since the bees will be attracted with the flower smell on Kuro s body and sting him Kuro wants to know how many pair of city u v he can take as his route Since he s not really bright he asked you to help him with this problem ,"['#include <bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=3e5+7;\n\nint n, x, y;\nVI gr[N];\n\nvector <LL> mywek;\n\nLL res;\n\nint dfs(int v, int par){\n\tint si=1;\n\tfor(int i : gr[v])\n\t\tif (i!=par)\n\t\t\tsi+=dfs(i,v);\n\tif (v==y)\n\t\tmywek.pb(si);\n\treturn si;\n}\n\nint main()\n{\n\tscanf(""%d%d%d"", &n, &x, &y);\n\tFOR(i,1,n-1){\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgr[a].pb(b);\n\t\tgr[b].pb(a);\n\t}\n\tFOR(i,0,1){\n\t\tswap(x, y);\n\t\tdfs(x, 0);\n\t}\n\tres=(LL)n*(n-1)-mywek[0]*mywek[1];\n\tprintf(""%lld\\n"", res);\n    return 0;\n}\n']",,,"['dfs and similar', 'trees']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Kuro and Walking Route.json,https://codeforces.com//blog/entry/59462,SolutionWe can consider the city as a graph in which every town is a vertex and every road connecting two towns is an edge Since we can deduce that this graph is a tree Now instead of finding the number of pairs that Kuro can choose we can find the number of pairs that Kuro cannot choose In other words we must find the number of pairs of vertices in which the shortest path from to passes through and then through But how can we do this If we take vertex as the root of the tree we can see that every pair of vertices that Kuro cannot choose begins from any node within the subtree of node and finishes at any node but within the subtree of node which is a direct child of lying on the shortest path from to In total the number of pairs of vertices that we are looking for is equal of which denotes the size of the subtree of node We can implement this using simple DFS Time complexity 
https://codeforces.com//contest/1395/problem/B,697390,B,1395B,1395,B. Boboniu Plays Chess,Boboniu likes playing chess with his employees As we know no employee can beat the boss in the chess game so Boboniu has never lost in any round You are a new applicant for his company Boboniu will test you with the following chess question Consider a n times m grid rows are numbered from 1 to n and columns are numbered from 1 to m You have a chess piece and it stands at some cell S x S y which is not on the border i e 2 le S x le n 1 and 2 le S y le m 1 From the cell x y you can move your chess piece to x y 1 le y le m y neq y or x y 1 le x le n x neq x In other words the chess piece moves as a rook From the cell you can move to any cell on the same row or column Your goal is to visit each cell exactly once Can you find a solution Note that cells on the path between two adjacent cells in your route are not counted as visited and it is not required to return to the starting point ,"['#include<bits/stdc++.h>\nusing namespace std;\nint a,b,c,d;\nint main(){\n\tscanf(""%d%d%d%d"",&a,&b,&c,&d);\n\tprintf(""%d %d\\n"",c,d);\n\tfor(int i=1;i<=a;i++)if(i!=c)printf(""%d %d\\n"",i,d);\n\tfor(int i=1;i<=b;i++){\n\t\tif(i==d)continue;\n\t\tbool dir=(i&1);\n\t\tif(i>d)dir^=1;\n\t\tif(dir==1)for(int j=a;j;j--)printf(""%d %d\\n"",j,i);\n\t\telse for(int j=1;j<=a;j++)printf(""%d %d\\n"",j,i);\n\t}\n\treturn 0;\n}\n']",,,['constructive algorithms'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Boboniu Plays Chess.json,https://codeforces.com//blog/entry/81355,There are many solutions and I will describe one of them Let say Iterate from to if is odd print Else print 
https://codeforces.com//contest/618/problem/B,46785,B,618B,618,B. Guess the Permutation,Bob has a permutation of integers from to Denote this permutation as The th element of will be denoted as For all pairs of distinct integers between and he wrote the number He writes for all integer from to Bob gave you all the values of that he wrote down Your job is to reconstruct any permutation that could have generated these values The input will be formed so that it is guaranteed that there is at least one solution that is consistent with the information given ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 60;\nint n;\nint a[N];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(""%d"", &x);\n\t\t\ta[i] = max(a[i], x);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] == n - 1)\n\t\t{\n\t\t\ta[i] = n;\n\t\t\tbreak;\n\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", a[i]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}']",,,['constructive algorithms'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Guess the Permutation.json,https://codeforces.com//blog/entry/23142,One solution is to look for the column row that contains only 1s and 0s We know that this index must be the index for the element 1 Then we can repeat this for 2 through n See the example code for more details The runtime of this solution is O n 3 However there is an easier solution One answer is to just take the max of each row which gives us a permutation Of course the element n 1 will appear twice but we can replace either occurrence with n and be done See the other code for details Example code for first http codeforces com contest 618 submission 15669492 Example code for second http codeforces com contest 618 submission 15669483 Comment Originally I wanted to set it so it wasn t guaranteed that there was a solution But this seemed a bit tedious to me so I didn t include this case 
https://codeforces.com//contest/403/problem/A,7183,A,403A,403,A. Searching for Graph,Let s call an undirected graph of vertices if the following conditions fulfill the graph contains exactly edges the graph doesn t contain self loops and multiple edges for any integer any subgraph consisting of vertices contains at most edges A of a graph is some set of the graph vertices and some set of the graph edges At that the set of edges must meet the condition both ends of each edge from the set must belong to the chosen set of vertices Your task is to find a graph consisting of vertices ,"['#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<"" = ""<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\nint g[50][50];\n\nvoid lemon()\n{\n\tint n,p; scanf(""%d%d"",&n,&p);\n\tmemset(g,0,sizeof g);\n\tint t=n/5;\n\trep(i,1,t)\n\t\trep(j,i*5-4,i*5)\n\t\t\trep(k,i*5-4,i*5)\n\t\t\t\tg[j][k]=1;\n\t\n\trep(i,t*5+1,n)\n\t{\n\t\tg[i][1]=1;\n\t\tg[1][i]=1;\n\t\tg[i][2]=1;\n\t\tg[2][i]=1;\n\t}\n\t\n\trep(k,1,p)\n\t{\n\t\tint flag=0;\n\t\trep(i,1,n)\n\t\t{\n\t\t\tif (flag) break;\n\t\t\trep(j,1,n)\n\t\t\t\tif (i!=j && !g[i][j])\n\t\t\t\t{\n\t\t\t\t\tg[i][j]=1; g[j][i]=1; flag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,1,n)\n\t\trep(j,i+1,n)\n\t\t\tif (g[i][j])\n\t\t\t\tprintf(""%d %d\\n"",i,j);\n\t\n\t\t\t\t\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""B.in"",""r"",stdin);\n\t#endif\n\tint tcase; scanf(""%d"",&tcase);\n\twhile (tcase--) lemon();\n\treturn 0;\n}\n\n']",,,"['constructive algorithms', 'graphs']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Searching for Graph.json,https://codeforces.com//blog/entry/10972,I will describe two solutions First Consider all pairs After you should ouput the first pairs in lexicographical order It s clear to understand that it is enough to prove that interesting graph is correct or interesting graph is correct We will prove for interesting graph that it is correct This graph consists of triangles which have an common edge Let s fix some subset of vertexes which does not contains vertexes and In such sets there are no edges Let s fix some subset which contains exactly one vertex or In such subsets there are exactly edges where is the size of such subset In other subset there are exactly 2 k 2 1 edges where is the size of such subset Second Let s use some brute force to build graphs with interesting graphs with sizes vertexes Now to build interesting graph with vertexes We will build interesting graph and after that we will add to it another edges which is not in the graph We will build interesting graphs using the following approach Let s took disjointed components from graphs with number of vertexes from to in such way that there are exactly vertexes in graph 
https://codeforces.com//contest/1175/problem/F,354218,F,1175F,1175,F. The Number of Subpermutations,You have an array a 1 a 2 dots a n Let s call some subarray a l a l 1 dots a r of this array a if it contains all integers from 1 to r l 1 exactly once For example array a 2 2 1 3 2 3 1 contains 6 subarrays which are subpermutations a 2 dots a 3 a 2 dots a 4 a 3 dots a 3 a 3 dots a 5 a 5 dots a 7 a 7 dots a 7 You are asked to calculate the number of subpermutations ,"[""#include <iostream>\n#include <vector>\n#include <tuple>\n#include <map>\nusing namespace std;\nusing ll = long long;\n\nstruct SegTree {\n\tconst int INF = 1e9;\n\tvector<pair<int, int>> max_vc;\n\tvector<int> add;\n\tint h = 1;\n\n\tpair<int, int> combine(pair<int, int> a, pair<int, int> b) {\n\t\tif (a.first == b.first) return {a.first, a.second + b.second};\n\t\telse return max(a, b);\n\t}\n\tvoid push(int i) {\n\t\tmax_vc[i].first += add[i];\n\t\tif (i < h) {\n\t\t\tadd[2*i] += add[i];\n\t\t\tadd[2*i+1] += add[i];\n\t\t}\n\t\tadd[i] = 0;\n\t}\n\n\tSegTree(int n, int v) {\n\t\twhile(h < n) h <<= 1;\n\t\tmax_vc.resize(2*h, {v, 1});\n\t\tadd.resize(2*h, 0);\n\t\tfor (int i = h-1; i > 0; --i) max_vc[i] = combine(max_vc[2*i], max_vc[2*i+1]);\n\t}\n\n\tvoid recAdd(int a, int b, int v, int i, int ia, int ib) {\n\t\tpush(i);\n\t\tif (ib < a || b < ia) return;\n\t\tif (a <= ia && ib <= b) {\n\t\t\tadd[i] += v;\n\t\t\tpush(i);\n\t\t} else {\n\t\t\tint im = (ia + ib) >> 1;\n\t\t\trecAdd(a, b, v, 2*i, ia, im);\n\t\t\trecAdd(a, b, v, 2*i+1, im+1, ib);\n\t\t\tmax_vc[i] = combine(max_vc[2*i], max_vc[2*i+1]);\n\t\t}\n\t}\n\n\tpair<int, int> recGet(int a, int b, int i, int ia, int ib) {\n\t\tpush(i);\n\t\tif (ib < a || b < ia) return {-INF, 0};\n\t\tif (a <= ia && ib <= b) return max_vc[i];\n\t\tint im = (ia + ib) >> 1;\n\t\treturn combine(recGet(a, b, 2*i, ia, im), recGet(a, b, 2*i+1, im+1, ib));\n\t}\n\n\tvoid addInt(int a, int b, int v) {\n\t\trecAdd(a, b, v, 1, 0, h-1);\n\t}\n\tpair<int, int> getInt(int a, int b) {\n\t\treturn recGet(a, b, 1, 0, h-1);\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t// Must have max == len == active\n\t// active <= max, len\n\t// 2*active - max - len <= 0\n\n\t// Move end of current interval. Keep only last occurence of value alive\n\t// Store in each position active_[i,a] - max(x_[i, a])\n\t// These values are always <= 0 since only unique values are active. So we can just count the number of\n\t// zeroes in the range to find answer.\n\n\tint n;\n\tcin >> n;\n\tSegTree seg(n, 0);\n\tvector<pair<int, int>> maxes;\n\tmap<int, int> prevs; // Previous occurrences of numbers\n\n\tll res = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a;\n\t\tcin >> a;\n\n\t\tif (prevs.find(a) != prevs.end()) {\n\t\t\tint p = prevs[a];\n\t\t\tseg.addInt(p+1, i, 2);\n\t\t} else {\n\t\t\tseg.addInt(0, i, 2);\n\t\t}\n\t\tseg.addInt(0, i, -1); // Len\n\n\t\tprevs[a] = i;\n\n\t\tseg.addInt(i, i, -a);\n\t\tpair<int, int> maxes_add = {a, i};\n\t\twhile((! maxes.empty()) && (maxes.back().first <= a)) {\n\t\t\tseg.addInt(maxes.back().second, maxes_add.second - 1, -(a - maxes.back().first));\n\t\t\tmaxes_add.second = maxes.back().second;\n\t\t\tmaxes.pop_back();\n\t\t}\n\t\tmaxes.push_back(maxes_add);\n\n\t\tpair<int, int> sub = seg.getInt(0, i);\n\t\tif (sub.first == 0) res += sub.second;\n\t}\n\tcout << res << '\\n';\n}\n""]",,,"['brute force', 'data structures', 'divide and conquer', 'hashing', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. The Number of Subpermutations.json,https://codeforces.com/blog/entry/67484,At first let s represent permutations in the next form We assign to all numbers from to random 128 bit strings so the th number gets the string Then the permutation of length can be hashed as where is bitwise exclusive OR for example This representation is convenient because if we have two sets of numbers with a total number of elements equal to let s represent them as and we can easily check whether their union is a permutation of length condition must be hold Let s denote as Now let s iterate over position such that and calculate the number of permutations that contain this element To do it let s iterate over the right boundary and suppose that maximum element of permutation and its length at the same time is one of positions If it s true then the subpermutation should be on the positions And to check that this segment is a subpermutation we should just compare and Thus we will calculate all permutations in which the position of the maximum is to the right of the position of the To calculate all permutations we need to reverse array and repeat this algorithm and then add the number of ones in the array 
https://codeforces.com//contest/906/problem/B,140845,B,906B,906,B. Seating of Students,Students went into a class to write a test and sat in some way The teacher thought Probably they sat in this order to copy works of each other I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating The class can be represented as a matrix with rows and columns with a student in each cell Two students are neighbors if cells in which they sit have a common side Let s enumerate students from to in order of rows So a student who initially sits in the cell in row and column has a number You have to find a matrix with rows and columns in which all numbers from to appear exactly once and adjacent numbers in the original matrix are not adjacent in it or determine that there is no such matrix ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,p[N],px[N],py[N],q[N];\n\nbool adj(int u,int v) {\n\tif (u>v) swap(u,v);\n\tif (px[u]==px[v]&&py[u]+1==py[v]) return 1;\n\tif (py[u]==py[v]&&px[u]+1==px[v]) return 1;\n\treturn 0;\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,n*m) px[i]=i/m,py[i]=i%m;\n\twhile (clock()<=1.9*CLOCKS_PER_SEC) {\n\t\trep(i,0,n*m) p[i]=i;\n\t\trandom_shuffle(p,p+n*m);\n\t\tset<PII> hs;\n\t\trep(i,0,n*m) hs.insert(mp(p[i],i));\n\t\tbool val=1;\n\t\trep(i,0,n*m) {\n\t\t\tint x=i/m,y=i%m;\n\t\t\tauto it=hs.begin();\n\t\t\tbool suc=0;\n\t\t\twhile (1) {\n\t\t\t\tsuc=1;\n\t\t\t\tq[i]=it->se;\n\t\t\t\tif (y&&adj(q[i],q[i-1])) { suc=0; }\n\t\t\t\tif (x&&adj(q[i],q[i-m])) { suc=0; }\n\t\t\t\tif (suc) { hs.erase(it); break; }\n\t\t\t\tit++;\n\t\t\t\tif (it==hs.end()) break;\n\t\t\t}\n\t\t\tif (suc==0) { val=0; break; }\n\t\t}\n\t\tif (val) {\n\t\t\tputs(""YES"");\n\t\t\trep(i,0,n*m) {\n\t\t\t\tprintf(""%d "",q[i]+1);\n\t\t\t\tif (i%m==m-1) puts("""");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""NO"");\n}\n']",,,"['brute force', 'constructive algorithms', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Seating of Students.json,https://codeforces.com//blog/entry/56601,The problem has many solutions including random ones Consider one of deterministic solutions Without loss of generality assume that There are a couple of corner cases In this case good seating exists In this case seating does not exist obviously In any seating one of neighbours of student 2 will be one of his former neighbours so correct seating does not exist Only student 4 can be a neighbour of student 1 but there should be 2 neighbours for student 1 then correct seating does not exist Both students 5 and 2 have 3 neighbours in the initial seating then in new seating these students should be in non neighbouring corner cells Moreover these corner cells can not be in one row because in this case it s impossible to find a student for cell between 2 and 5 So without loss of generality let 5 be in lower left corner and 2 in upper right corner Then only students 1 and 3 can seat on lower middle cell but if sduent 1 seats in the cell then student 4 is impossible to seat at any of the remaining cells so do student 6 in case of student 3 seating at the cell So correct seating does not exist in this case too In this case one of correct seatings is In this case let students with odd numbers in increasing order will be in first half of the row and others in increasing order in second half For example for the seating will be One of possible correct seatings is If then shift each even row cyclically on two symbols in the right and then shift each even column cyclically on one symbol upwards If students are vertical neighbours in the initial seating then in new seating they will be in different columns on the distance 2 possibly through the edge of the table but if students are horizontal neighbours in the initial seating then in new seating they will be in neighbouring rows and neighbouring columns possibly thorugh the edges again So for case we build a correct seating 
https://codeforces.com//contest/1344/problem/C,600703,C,1344C,1344,C. Quantifier Question,Logical quantifiers are very useful tools for expressing claims about a set For this problem let s focus on the set of real numbers specifically There are two kinds of quantifiers universal forall and existential exists You can read more about them here The universal quantifier is used to make a claim that a statement holds For example forall x x 100 is read as for all real numbers x x is less than 100 This statement is false forall x x x 1 is read as for all real numbers x x is greater than x 1 This statement is true The existential quantifier is used to make a claim that for which the statement holds For example exists x x 100 is read as there exists a real number x such that x is less than 100 This statement is true exists x x x 1 is read as there exists a real number x such that x is greater than x 1 This statement is true Moreover these quantifiers can be nested For example forall x exists y x y is read as for all real numbers x there exists a real number y such that x is less than y This statement is true since for every x there exists y x 1 exists y forall x x y is read as there exists a real number y such that for all real numbers x x is less than y This statement is false because it claims that there is a maximum real number a number y larger than every x There are n variables x 1 x 2 ldots x n and you are given some formula of the form f x 1 dots x n x j 1 x k 1 land x j 2 x k 2 land cdots land x j m x k m where land denotes logical AND That is f x 1 ldots x n is true if every inequality x j i x k i holds Otherwise if at least one inequality does not hold then f x 1 ldots x n is false Your task is to assign quantifiers Q 1 ldots Q n to either universal forall or existential exists so that the statement Q 1 x 1 Q 2 x 2 ldots Q n x n f x 1 ldots x n is true and or determine that the statement is false for every possible assignment of quantifiers For example if f x 1 x 2 x 1 x 2 then you are not allowed to make x 2 appear first and use the statement forall x 2 exists x 1 x 1 x 2 If you assign Q 1 exists and Q 2 forall it will be interpreted as exists x 1 forall x 2 x 1 x 2 ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? ""true"" : ""false""; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = ""{"";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += "", "";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += ""}""; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n/**\n * Description: sorts vertices such that if there exists an edge x->y, then x goes before y\n * Source: KACTL\n * Verification: https://open.kattis.com/problems/quantumsuperposition\n */\n\ntemplate<int SZ> struct TopoSort {\n\tint N, in[SZ];\n\tvi res, adj[SZ];\n\tvoid ae(int x, int y) { adj[x].pb(y), in[y] ++; }\n\tbool sort(int _N) {\n\t\tN = _N; queue<int> todo;\n\t\tFOR(i,1,N+1) if (!in[i]) todo.push(i);\n\t\twhile (sz(todo)) {\n\t\t\tint x = todo.front(); todo.pop(); res.pb(x);\n\t\t\ttrav(i,adj[x]) if (!(--in[i])) todo.push(i);\n\t\t}\n\t\treturn sz(res) == N;\n\t}\n};\n\nTopoSort<MX> T;\nint n,m,mn[MX], mn2[MX];\n\nint main() {\n\tsetIO(); re(n,m);\n\tF0R(i,m) {\n\t\tint j,k; re(j,k);\n\t\tT.ae(j,k);\n\t}\n\tif (!T.sort(n)) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\tFOR(i,1,n+1) mn[i] = mn2[i] = i;\n\ttrav(t,T.res) {\n\t\ttrav(u,T.adj[t]) ckmin(mn[u],mn[t]);\n\t}\n\treverse(all(T.res));\n\ttrav(t,T.res) {\n\t\ttrav(u,T.adj[t]) ckmin(mn2[t],mn2[u]);\n\t}\n\tstr ans;\n\tint cnt = 0;\n\tFOR(i,1,n+1) if (min(mn[i],mn2[i]) >= i) {\n\t\tans += ""A"";\n\t\tcnt ++;\n\t} else ans += ""E"";\n\tps(cnt); ps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']",,,"['dfs and similar', 'dp', 'graphs', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Quantifier Question.json,https://codeforces.com//blog/entry/76819,Build a directed graph of variables where an edge xi xj corresponds to an inequality xi xj Say that two variables are comparable if there is a directed path from one variable to the other Suppose xi and xj are comparable with i j Then xj cannot be universal since xi is determined before xj in the order and their comparability restricts the value of xj So a requirement for universality is that the variable is only comparable with larger indexed variables If there is a cycle of inequalities then there is no solution since the formula is contradictory Otherwise the graph is acyclic so we can find a topological order For each variable we can find the minimum index of a node comparable to it by doing DP in forward and reverse topological order Then for every variable not comparable to a smaller indexed variable let it be universal All other variables must be existential Our requirement of universality proves this is optimal Let s prove this assignment gives a true statement other than proof by AC First we can decrease the index of existential variables which only strengthens the statement So let s decrease the index of each existential variable to appear just after its largest indexed comparable universal variable An existential variable xi may be comparable to many universal variables but xi must be either greater than them all or less than them all Otherwise we would have two comparable universals Without loss of generality say xi is greater than its comparable universals And suppose xi is less than another existential variable xj Then xj is comparable to the same universals as xi so we can determine the value of xj later such that it depends on xi Therefore each existential variable is only restricted by a lower bound or an upper bound of smaller indexed variables We can properly assign values to them satisfying all inequalities 
https://codeforces.com//contest/2049/problem/F,3095890,F,2049F,2049,F. MEX OR Mania,An integer sequence b 1 b 2 ldots b n is if operatorname mex b 1 b 2 ldots b n b 1 b 2 ldots b n 1 Here operatorname mex c denotes the MEX text of the collection c and is the bitwise OR operator Shohag has an integer sequence a 1 a 2 ldots a n He will perform the following q updates on a i x increase a i by x After each update help him find the length of the longest good subarray text of a text The minimum excluded MEX of a collection of integers c 1 c 2 ldots c k is defined as the smallest non negative integer y which does not occur in the collection c text An array d is a subarray of an array f if d can be obtained from f by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include<bits/stdc++.h>\xa0using namespace std;\xa0#pragma GCC optimize(""O3,unroll-loops"")#pragma GCC optimize(""Ofast"",""inline"",""-ffast-math"")\xa0#define int long long #define F first #define S second #define pb push_backconst int mol=998244353;\xa0\xa0const int N = 1e5+5;multiset<int, greater<>>ans;struct Dsu{    int dsu[N], sz[N];    map<int, int>ha[N];    void init(int n){        for(int i=1;i<=n;i++) dsu[i]=i, sz[i]=1, ha[i].clear();    }\xa0    int find(int g){        if(g==dsu[g]) return g;        return dsu[g]=find(dsu[g]);    }    void un(int g, int h, int id){        g=find(g), h=find(h);                if(sz[g]>sz[h]) swap(g, h);        if(ha[g].size()==(1ll<<id)){            ans.erase(ans.find(sz[g]));        }        if(ha[h].size()==(1ll<<id)){            ans.erase(ans.find(sz[h]));        }                dsu[g]=h, sz[h]+=sz[g];        for(auto t: ha[g]){            ha[h][t.F]+=t.S;        }        if(ha[h].size()==(1ll<<id)){            ans.insert(sz[h]);        }    }}iu[20];int a[N], id[N];void solve(){    int n, q;    cin>>n>>q;    ans.clear();    ans.insert(0);    for(int i=0;i<20;i++) iu[i].init(n);    for(int i=1;i<=n;i++){        cin>>a[i];        id[i]=20;    }\xa0    vector<pair<int, int>>qq;    for(int i=1;i<=q;i++){        int g, h;        cin>>g>>h;        a[g]+=h;        qq.pb({g, h});    }\xa0    for(int i=19;i>=0;i--){        for(int j=1;j<=n;j++) if(a[j]<(1ll<<i)){            id[j]=i;            if(i==0) ans.insert(1);            iu[i].ha[j][a[j]]=1;        }        for(int j=1;j<n;j++){            if(a[j]<(1ll<<i)&&a[j+1]<(1ll<<i)){                iu[i].un(j, j+1, i);            }        }    }    vector<int>ansq(q+1);    for(int i=q;i>=1;i--){        ansq[i]=*ans.begin();        auto g=qq.back();qq.pop_back();        a[g.F]-=g.S;        for(int i=id[g.F];i<20;i++){            int t=iu[i].find(g.F);            iu[i].ha[t][a[g.F]+g.S]--;            if(iu[i].ha[t][a[g.F]+g.S]==0){                if(iu[i].ha[t].size()==(1ll<<i)) ans.erase(ans.find(iu[i].sz[t]));                iu[i].ha[t].erase(a[g.F]+g.S);            }            iu[i].ha[t][a[g.F]]++;            if(iu[i].ha[t].size()==(1ll<<i)&&iu[i].ha[t][a[g.F]]==1) ans.insert(iu[i].sz[t]);        }        while(id[g.F]>0){            if((1ll<<(id[g.F]-1))>a[g.F]){                id[g.F]--;                iu[id[g.F]].ha[g.F][a[g.F]]=1;                if(id[g.F]==0) ans.insert(1);                if(g.F>1&&a[g.F-1]<(1ll<<(id[g.F]))){                    iu[id[g.F]].un(g.F, g.F-1, id[g.F]);                }                if(g.F<n&&a[g.F+1]<(1ll<<(id[g.F]))){                    iu[id[g.F]].un(g.F, g.F+1, id[g.F]);                }            }            else break;        }    }\xa0    for(int i=1;i<=q;i++) cout<<ansq[i]<<""\\n"";}signed main(){    ios::sync_with_stdio(0);cin.tie(0);    int t;    cin>>t;    while(t--)    solve();    return 0;}']",,,"['bitmasks', 'brute force', 'data structures', 'dsu', 'implementation']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. MEX OR Mania.json,https://codeforces.com//blog/entry/137273,Let s figure out when a sequence is good Let be the maximum element of the sequence Notice that the bitwise OR of the sequence is at least and as MEX OR that means MEX has to be at least Which means all elements from to has to be present in the sequence As MEX can t be greater than the MEX has to be exactly Now we need to check for which the bitwise OR of the elements from to is exactly It s not hard to see that this is true for for some integer The reason is that all bits from to have to be set in for the OR to be and it s only possible if is of the form So a sequence is good if the maximum element is for some integer and all elements from to are present in the sequence Now let s see how to answer the queries without any updates To find the longest good subarray we can use a two pointers approach But a better way to do this is to fix the power and find the longest good subarray with maximum element To do this ignore the elements greater than and then split the array into segments of consecutive numbers where each segment has elements from to To check if a segment is good we can track the number of distinct elements in the segment If the number of distinct elements is then the segment is good So to sum it up for each power we will track some segments components and the number of distinct elements in them and also the lengths of the segments to get the longest one during queries Now regarding the updates it is hard to track everything if we do the updates normally But its s easier if we look at them in reverse order Then each update will be decreasing the value of by Then for each power we will have to add a new element to a component or merge two components For tracking distinct elements we can use a map or unordered map and to merge we can use DSU with small to large merging And that s pretty much it Please check my code for more details Overall complexity is or depending on if you use an unordered map or a map Solution 
https://codeforces.com//contest/2051/problem/G,3099580,G,2051G,2051,G. Snakes,Suppose you play a game where the game field looks like a strip of 1 times 10 9 square cells numbered from 1 to 10 9 You have n snakes numbered from 1 to n you need to place into some cells Initially each snake occupies exactly one cell and you can t place more than one snake into one cell After that the game starts The game lasts for q seconds There are two types of events that may happen each second snake s i if snake s i occupied cells l r it enlarges to a segment l r 1 snake s i if snake s i occupied cells l r it shrinks to a segment l 1 r Each second exactly one of the events happens If at any moment of time any snake runs into some obstacle either another snake or the end of the strip you lose Otherwise you win with the score equal to the maximum cell occupied by any snake so far What is the minimum possible score you can achieve ,"['#include <bits/stdc++.h>#define ll long longusing namespace std;\xa0static const ll INF = LLONG_MAX / 2;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\xa0    int n, q;    cin >> n >> q;\xa0    vector<vector<int>> e(n, vector<int>(q+1, 0));    vector<vector<int>> s(n, vector<int>(q+1, 0));\xa0    for(int i = 0; i < n; i++){        for(int t = 1; t <= q; t++){            e[i][t] = e[i][t-1];            s[i][t] = s[i][t-1];        }    }\xa0    for(int i = 0; i < n; i++){        for(int t = 0; t <= q; t++){            e[i][t] = 0;            s[i][t] = 0;        }    }\xa0    vector<vector<int>> de(n, vector<int>(q+1,0));    vector<vector<int>> ds(n, vector<int>(q+1,0));\xa0    for(int k = 1; k <= q; k++){        int si;        char c;        cin >> si >> c;        si -= 1;        if(c == \'+\'){            de[si][k] += 1;        } else {            ds[si][k] += 1;        }    }\xa0    for(int i=0; i<n; i++){        for(int t=1; t<=q; t++){            e[i][t] = e[i][t-1] + de[i][t];            s[i][t] = s[i][t-1] + ds[i][t];        }    }\xa0    vector<vector<ll>> cost(n, vector<ll>(n, 0LL));    for(int i = 0; i < n; i++){        for(int j = 0; j < n; j++){            if(i == j){                cost[i][j] = 0LL;                continue;            }            ll mx = LLONG_MIN;\xa0            for(int t=0; t<=q; t++){                ll diff = (ll)e[i][t] - (ll)s[j][t];                if(diff > mx) mx = diff;            }            cost[i][j] = mx + 1LL;        }    }\xa0    vector<ll> maxRight(n,0LL);    for(int i=0; i<n; i++){        ll mr = 0;        for(int t=0; t<=q; t++){            mr = max(mr, (ll)e[i][t]);        }        maxRight[i] = mr;    }\xa0    static ll dpLeft[1<<20][20];    static ll dpAns[1<<20][20];    int fullMask = (1 << n) - 1;\xa0    for(int mask=0; mask<(1<<n); mask++){        for(int i=0; i<n; i++){            dpLeft[mask][i] = INF;            dpAns[mask][i] = INF;        }    }\xa0    for(int i=0; i<n; i++){        int m = (1<<i);        dpLeft[m][i] = 1LL;        dpAns[m][i] = 1LL + maxRight[i];    }\xa0    for(int mask=0; mask<(1<<n); mask++){        for(int last=0; last<n; last++){            if( dpLeft[mask][last] == INF ) continue;\xa0            ll curL = dpLeft[mask][last];            ll curM = dpAns[mask][last];\xa0            int notUsed = (~mask) & fullMask;            while(notUsed){                int j = __builtin_ctz(notUsed);                notUsed ^= (1<<j);\xa0                ll newLeft = curL + cost[last][j];                ll newMax = max( curM, newLeft + maxRight[j] );\xa0                int newMask = mask | (1<<j);\xa0                if( (newMax < dpAns[newMask][j]) ||                    (newMax == dpAns[newMask][j] && newLeft < dpLeft[newMask][j]) ){                    dpAns[newMask][j] = newMax;                    dpLeft[newMask][j]    = newLeft;                }            }        }    }\xa0    ll ans = INF;\xa0    for(int i=0; i<n; i++){        ans = min(ans, dpAns[fullMask][i]);    }\xa0    cout << ans << ""\\n"";    return 0;}']",,,"['bitmasks', 'dp', 'dsu', 'graphs']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Snakes.json,https://codeforces.com//blog/entry/137623,Note that when you place snakes on the strip in some order they form some permutation And when you fix that permutation you can place them greedily In other words when you know in what order you ll place snakes it s always optimal to place them as close to each other as possible Since the bigger the initial distance the bigger the resulting distance of the farthest snake or the bigger the final score We can even calculate that final score precisely it s equal to So we can solve the task in two steps First let s calculate the minimum possible distance between snakes and if we plan to place snake right after snake Suppose the initial between these snakes is Let s skim through all events each time the th snake enlarges our gap decreases or each time the th snake shrinks our gap increases or if at any moment becomes negative then we lose In other words we needed bigger initial We can rephrase what happens more formally for each event let if increases if decreases or otherwise Then after the th event the current gap will be equal to The following inequality should hold for each or So if we will find the minimum then we can set the initial distance to this minimum gap plus one or Now we know the minimum distances between neighboring snakes so we can find the optimal order Let s do it with bitmask dp since all we need to know in each state is the set of already placed snakes and the last snake Transitions are straightforward let s just choose the next snake to place and place it at distance The initial states are for each The answer is i e we just choose the last snake The time complexity is for the first part or if written more optimally plus for the second part 
https://codeforces.com//contest/1511/problem/C,955214,C,1511C,1511,C. Yet Another Card Deck,You have a card deck of n cards numbered from top to bottom i e the top card has index 1 and bottom card index n Each card has its color the i th card has color a i You should process q queries The j th query is described by integer t j For each query you should find the highest card in the deck with color t j i e the card with minimum index print the position of the card you found take the card and place it on top of the deck ,"['#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int q = scan();\n  vector pos(50, n);\n  for (int i : Rep(n)) chmin(pos[scan() - 1], i);\n  while (q--) {\n    int t = scan() - 1;\n    cout << pos[t] + 1 << "" \\n""[q == 0];\n    for (auto&& e : pos) e += e < pos[t];\n    pos[t] = 0;\n  }\n}\n']",,,"['brute force', 'data structures', 'implementation', 'trees']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Yet Another Card Deck.json,https://codeforces.com//blog/entry/89634,Let s look at one fixed color When we search a card of such color we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index It means that for each color we take and move the same card one card for each color In other words we need to keep track of only cards where is the number of colors As a result if is the position of a card of color then we can simulate a query in the following way for each color such that we increase by one since the card will move down and then set Complexity is But if we look closely we may note that we don t even need array We can almost manually find the first card of color and move it to the first position either by series of swaps or for example using function present in C and it will work fast Why Let s look at one color For the first time it will cost operations to search the corresponding card and move it to the position But after that at any moment of time the position of the card won t exceed since all cards before are pairwise different due to the nature of queries So all next moves the color costs only time As a result the complexity of such almost naive solution is 
https://codeforces.com//contest/1473/problem/B,864970,B,1473B,1473,B. String LCM,Let s define a multiplication operation between a string a and a positive integer x a cdot x is the string that is a result of writing x copies of a one after another For example cdot 2 cdot 5 A string a is divisible by another string b if there exists an integer x such that b cdot x a For example is divisible by but is not divisible by or LCM of two strings s and t defined as LCM s t is the shortest non empty string that is divisible by both s and t You are given two strings s and t Find LCM s t or report that it does not exist It can be shown that if LCM s t exists it is unique ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        std::string a, b;\n        std::cin >> a >> b;\n        int d = std::gcd(a.length(), b.length());\n        std::string a1, b1;\n        for (int i = 0; i < int(b.length()) / d; i++) {\n            a1 += a;\n        }\n        for (int i = 0; i < int(a.length()) / d; i++) {\n            b1 += b;\n        }\n        if (a1 == b1) {\n            std::cout << a1 << ""\\n"";\n        } else {\n            std::cout << ""-1\\n"";\n        }\n    }\n    return 0;\n}']",,,"['brute force', 'math', 'number theory', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. String LCM.json,https://codeforces.com//blog/entry/86827,We should notice that if some string is a multiple of string then is a multiple of This fact leads us to the conclusion that should be a common multiple of and Since we want to minimize the length of the string then its length is So we have to check that copies of the string equal to copies of the string If such strings are equal print them otherwise there is no solution 
https://codeforces.com//contest/356/problem/D,3679,D,356D,356,D. Bags and Coins,When you were a child you must have been told a puzzle of bags and coins Anyway here s one of its versions The answer is quite simple The third bag contains a coin and two other bags This problem is a generalization of the childhood puzzle You have bags You know that the first bag contains coins the second bag contains coins the th bag contains coins In total there are coins Find the way to arrange the bags and coins so that they match the described scenario or else state that it is impossible to do ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 4 * 77777;\n\nunsigned int one = 1;\nunsigned int f[N], nf[N];\npair <int, int> a[N];\nint last[N], inside[N], A[N];\nbool used[N];\n\nint main() {\n  int n, s;\n  scanf(""%d %d"", &n, &s);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", &a[i].first);\n    A[i] = a[i].first;\n    a[i].second = i;\n  }\n  sort(a, a + n);\n  reverse(a, a + n);\n  if (a[0].first > s) {\n    printf(""%d\\n"", -1);\n    return 0;\n  }\n  s -= a[0].first;\n  int nn = (s >> 5) + 1;\n  for (int i = 0; i < nn; i++) f[i] = 0;\n  for (int i = 0; i <= s; i++) last[i] = -1;\n  last[0] = 0;\n  f[0] |= (one << 0);\n  for (int q = 1; q < n; q++) {\n    int w = a[q].first;\n    for (int i = 0; i < nn; i++) nf[i] = 0;\n    int els = (w >> 5);\n    int shift = (w & 31);\n    for (int i = 0; i < nn; i++) {\n      int j = i + els;\n      if (j < nn) {\n        nf[j] |= (f[i] << shift);\n        if (j + 1 < nn && shift != 0) {\n          nf[j + 1] |= (f[i] >> (32 - shift));\n        }\n      }\n      else break;\n    }\n    for (int i = 0; i < nn; i++)\n      if ((f[i] | nf[i]) != f[i]) {\n        for (int j = 0; j < 32; j++)\n          if (nf[i] & (one << j)) {\n            if (!(f[i] & (one << j))) {\n              int id = (i << 5) + j;\n              last[id] = q;\n            }\n          }\n        f[i] |= nf[i];\n      }\n  }\n  if (last[s] == -1) {\n    printf(""%d\\n"", -1);\n    return 0;\n  }\n  for (int i = 1; i < n; i++) used[i] = false;\n  while (s > 0) {\n    used[last[s]] = true;\n    s -= a[last[s]].first;\n  }\n  for (int i = 0; i < n; i++) inside[i] = -1;\n  int prev = 0;\n  for (int i = 1; i < n; i++) {\n    if (!used[i]) {\n      inside[a[prev].second] = a[i].second;\n      prev = i;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (inside[i] == -1) {\n      printf(""%d 0\\n"", A[i]);\n    } else {\n      printf(""%d 1 %d\\n"", A[i] - A[inside[i]], inside[i] + 1);\n    }\n  }\n  return 0;\n}\n']",,,"['bitmasks', 'constructive algorithms', 'dp', 'greedy']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Bags and Coins.json,https://codeforces.com/blog/entry/9210,It s easy to see that bags and their relations lies directly in should form directed forest Each vertex should be given value the number of coins in the corresponding bag Let s denote the sum of values in the subtree of vertex as The following conditions should be met It s clear that one of the bags with largest must be the root of some tree It s quite easy to see that the solution exists if and only if there exists a subset such that and this subset contains at least one bag with the largest It s obvious that it is necessary condition the sufficiency is also easy to see let s suppose we have such subset Then all bags from the subset except one of the largest will be roots of the signle vertex trees i e for them All bags that are not in the subset we will consequentially put into the largest bag forming the russian doll this tree will be directed chain So we reduced the task to the well known subset sum problem from the items find the subset with the given sum This problem is NP Complete and with these constraints is solved in a following way let if it is possible to obtain sum using some of the first items and otherwise Then The th row of this table depends only on the previous row so we don t have to store the whole table in memory Also we should use the fact that the values of the table are zeroes and ones and we can use bit compression and store each row in an array of int s of size To get the th row we should calculate the bitwise OR of the previous row and the previous row shifted to the left by positions That is we can find out whether it possible to obtain the sum in approximately operations To find the actual way to obtain we need to use the following trick for every possible sum we will remember the value the number of such item that after considering this item it became possible to obtain This allows us to restore the solution 
https://codeforces.com//contest/1307/problem/C,542679,C,1307C,1307,C. Cow and Message,Bessie the cow has just intercepted a text that Farmer John sent to Burger Queen However Bessie is sure that there is a secret message hidden inside The text is a string s of lowercase Latin letters She considers a string t as hidden in string s if t exists as a subsequence of s whose indices form an arithmetic progression For example the string is hidden in string because it occurs at indices 1 3 and 5 which form an arithmetic progression with a common difference of 2 Bessie thinks that any hidden string that occurs the most times is the secret message Two occurrences of a subsequence of S are distinct if the sets of indices are different Help her find the number of occurrences of the secret message For example in the string is hidden 3 times is hidden 2 times is hidden 6 times is hidden 3 times is hidden 1 time is hidden 2 times is hidden 1 time is hidden 1 time is hidden 1 time is hidden 1 time and is hidden 1 time The number of occurrences of the secret message is 6 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nchar s[N];\nll cnt[40][40],cc[40],ans;\nint main() {\n\tscanf(""%s"",s);\n\tint n=strlen(s);\n\trep(i,0,n) {\n\t\tint w=s[i]-\'a\';\n\t\trep(j,0,26) cnt[w][j]+=cc[j];\n\t\tcc[w]++;\n\t}\n\trep(i,0,26) rep(j,0,26) ans=max(ans,cnt[i][j]);\n\trep(i,0,26) ans=max(ans,cc[i]);\n\tprintf(""%lld\\n"",ans);\n}\n']",,,"['brute force', 'dp', 'math', 'strings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Cow and Message.json,https://codeforces.com//blog/entry/73953,We observe that if the hidden string that occurs the most times has length longer than then there must exist one that occurs just as many times of length exactly This is true because we can always just take the first letters there can t be any collisions Therefore we only need to check strings of lengths and Checking strings of length is easy To check strings of length we can iterate across from left to right and update the number of times we have seen each string of length and using DP Time Complexity c is length of alphabet 
https://codeforces.com//contest/845/problem/G,119177,G,845G,845,G. Shortest Path Problem ,You are given an undirected graph with weighted edges The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path if some edge is traversed more than once then it is included in bitwise xor the same number of times You have to find the minimum length of path between vertex and vertex ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=100005;\nvector<pair<int,ll> > e[MAXN];\nvector<ll> base;\nvoid add(ll x)\n{\n    for(int i=0;i<(int)base.size();i++)\n        x=min(x,x^base[i]);\n    if(x)base.push_back(x);\n}\nint vis[MAXN];\nll t[MAXN];\nvoid dfs(int u,ll now)\n{\n    vis[u]=1,t[u]=now;\n    for(int i=0;i<(int)e[u].size();i++)\n    {\n        int v=e[u][i].first;\n        if(vis[v])add(now^e[u][i].second^t[v]);\n        else dfs(v,now^e[u][i].second);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(""%d%d"",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;\n        ll w;\n        scanf(""%d%d%lld"",&x,&y,&w);\n        e[x].push_back(make_pair(y,w));\n        e[y].push_back(make_pair(x,w));\n    }\n    dfs(1,0);\n    for(int i=0;i<(int)base.size();i++)\n        t[n]=min(t[n],t[n]^base[i]);\n    return 0*printf(""%lld\\n"",t[n]);\n}\n']",,,"['dfs and similar', 'graphs', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Shortest Path Problem .json,https://codeforces.com//blog/entry/53986,Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination 
https://codeforces.com//contest/1852/problem/B,2099133,B,1852B,1852,B. Imbalanced Arrays,Ntarsis has come up with an array a of n non negative integers Call an array b of n integers if it satisfies the following n le b i le n b i ne 0 there are no two indices i j 1 le i j le n such that b i b j 0 for each 1 leq i leq n there are a i indices j 1 le j le n such that b i b j 0 where i and j are not necessarily distinct Given the array a Ntarsis wants you to construct some imbalanced array Help him solve this task or determine it is impossible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> p(n);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(), [&](int i, int j) {\n        return a[i] < a[j];\n    });\n    \n    int l = 0, r = n - 1;\n    int pos = 0;\n    std::vector<int> ans(n);\n    for (int i = n; i > 0; i--) {\n        if (a[p[l]] - pos == 0) {\n            ans[p[l]] = -i;\n            l++;\n        } else if (a[p[r]] - pos == i) {\n            ans[p[r]] = i;\n            pos++;\n            r--;\n        } else {\n            std::cout << ""NO\\n"";\n            return;\n        }\n    }\n    std::cout << ""YES\\n"";\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'graphs', 'greedy', 'math', 'sortings', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Imbalanced Arrays.json,https://codeforces.com//blog/entry/116940,Analysis buffering nsqrtlog SolutionAt the start let be an index such that has the greatest absolute value If is negative we have and else Moreover we can t have for any indices and because that implies is both positive and negative contradiction Hence the necessary and sufficient condition to check if we can determine an element in array with maximum absolute value is there exists an element of array equal to xor there exists an element of array equal to Then we can remove that element and re calculate the array leading to an solution If the check fails at any moment there is no valid solution To optimize it further note that we can sort array at the start and keep track of them in a deque like structure We only need to check the front and end of the deque to see if our key condition holds Finally we can use a variable to record the number of positive elements deleted so far and subtract it from the front and end of the deque when checking our condition so that each check is The overall complexity becomes due to sorting 
https://codeforces.com//contest/1370/problem/D,652386,D,1370D,1370,D. Odd-Even Subsequence,Ashish has an array a of size n A subsequence of a is defined as a sequence that can be obtained from a by deleting some elements possibly none without changing the order of the remaining elements Consider a subsequence s of a He defines the cost of s as the minimum between The maximum among all elements at odd indices of s The maximum among all elements at even indices of s Note that the index of an element is its index in s rather than its index in a The positions are numbered from 1 So the cost of s is equal to min max s 1 s 3 s 5 ldots max s 2 s 4 s 6 ldots For example the cost of 7 5 6 is min max 7 6 max 5 min 7 5 5 Help him find the minimum cost of a subsequence of size k ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint const maxn = 2e5 + 5;\nint a[maxn], good[maxn], pref[maxn], suff[maxn];\npair < int, int > b[maxn];\n\ninline int oks(int n, int k, int x) {\n    for (int i = 1; i <= n; ++i) good[i] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (b[i].first <= x) good[b[i].second] = 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        if (good[i]) {\n            pref[i] = max(pref[i], 1);\n            if (i >= 2) pref[i] = max(pref[i], pref[i - 2] + 2);\n        }\n    }\n    for (int i = n; i >= 1; --i) {\n        suff[i] = suff[i + 1];\n        if (good[i]) {\n            suff[i] = max(suff[i], 1);\n            if (i + 1 <= n) suff[i] = max(suff[i], suff[i + 2] + 2);\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] >= x) {\n            if (pref[i - 1] + 1 + suff[i + 1] >= k) return 1;\n        }\n    }\n    return 0;\n}\n\nmain() {\n    //freopen(""input.txt"", ""r"", stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) b[i] = {a[i], i};\n    sort(b + 1, b + n + 1);\n    set < int > Q;\n    for (int i = 1; i <= n; ++i) Q.insert(a[i]);\n    vector < int > t;\n    for (auto key : Q) t.push_back(key);\n    int lef = -1, righ = (int)t.size();\n    while (righ - lef > 1) {\n        int mid = (righ + lef) / 2;\n        if (oks(n, k, t[mid])) righ = mid;\n        else lef = mid;\n    }\n    cout << t[righ];\n    return 0;\n}\n\n\n']",,,"['binary search', 'dp', 'dsu', 'greedy', 'implementation']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Odd-Even Subsequence.json,https://codeforces.com//blog/entry/79107, Binary search over the answer and check if given it is possible to form a subsequence of length at least such that either all elements at odd indices or even indices are Let us binary search over the answer and fix if the answer comes from elements at odd or even indices in the subsequence Suppose we want to find if there exists a subsequence of length at least such that the elements at odd indices are We will construct the subsequence greedily Let s iterate on the array from left to right Suppose we are at index in the array and the current length of the subsequence formed is If is odd the next added element would be at an even index In this case we do not care about what this element is as we only want elements at odd indices to be So in this case we add to the subsequence If is even then the next added element would be at an odd index so it must be If we can add to the subsequence otherwise we do not add to the subsequence and continue to the next element in Note that we can do a similar greedy construction for elements at even indices If the length of the subsequence formed is either by construction from odd indices or even indices then the answer can be equal to and we can reduce the upper bound of the binary search otherwise we increase the lower bound Time Complexity or 
https://codeforces.com//contest/1079/problem/C,257673,C,1079C,1079,C. Playing Piano,Little Paul wants to learn how to play piano He already has a melody he wants to start with For simplicity he represented this melody as a sequence a 1 a 2 ldots a n of key numbers the more a number is the closer it is to the right end of the piano keyboard Paul is very clever and knows that the essential thing is to properly assign fingers to notes he s going to play If he chooses an inconvenient fingering he will then waste a lot of time trying to learn how to play the melody by these fingers and he will probably not succeed Let s denote the fingers of hand by numbers from 1 to 5 We call a any sequence b 1 ldots b n of fingers numbers A fingering is if for all 1 leq i leq n 1 the following holds if a i a i 1 then b i b i 1 because otherwise Paul needs to take his hand off the keyboard to play the i 1 st note if a i a i 1 then b i b i 1 because of the same if a i a i 1 then b i neq b i 1 because using the same finger twice in a row is dumb Please provide any convenient fingering or find out that there is none ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint a[(int)2e5];\nint dp[(int)2e5][6];\nint u[(int)2e5][6];\nint p[(int)2e5][6];\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    u[1][1] = 1;\n    u[1][2] = 1;\n    u[1][3] = 1;\n    u[1][4] = 1;\n    u[1][5] = 1;\n    for(int i = 1; i < n; i++)\n    {\n        for(int t = 1; t <= 5; t++)\n        {\n            if(!u[i][t])continue;\n            if(a[i + 1] > a[i])\n            {\n                for(int j = t + 1; j <= 5;j++)\n                {\n                    p[i + 1][j] = t;\n                    u[i + 1][j] = 1;\n                }\n            }\n            if(a[i + 1] < a[i])\n            {\n                for(int j = 1; j < t;j++)\n                {\n                    p[i + 1][j] = t;\n                    u[i +1][j] = 1;\n                }\n            }\n            if(a[i + 1]==a[i])\n            {\n                for(int j = 1; j <= 5;j++)\n                {\n                    if(j == t)\n                        continue;\n                    p[i + 1][j] = t;\n                    u[i +1][j] = 1;\n                }\n            }\n        }\n    }\n    int e = 0;\n    for(int j = 1; j<=5;j++)\n        if(u[n][j])\n            e = j;\n    if(e == 0)\n    {\n        cout << -1;\n        return 0;\n    }\n    vector<int> ans;\n    //return 0;\n    for(int i = n; i >=1;i--)\n    {\n        ans.push_back(e);\n        e = p[i][e];\n    }\n    reverse(ans.begin(),ans.end());\n    for(auto x: ans)\n        cout << x << ' ';\n}\n""]",,,['dp'],1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Playing Piano.json,https://codeforces.com//blog/entry/63324,Let dp i j be 1 if we cannot play the first i notes in such a way that the i th note is played by the j th finger otherwise let this be the number of the previous finger in any of possible fingerings This dp can be easily calculated for about 5n 5 operations 
https://codeforces.com//contest/216/problem/A,1597,A,216A,216,A. Tiling with Hexagons,Several ages ago Berland was a kingdom The King of Berland adored math That s why when he first visited one of his many palaces he first of all paid attention to the floor in one hall The floor was tiled with hexagonal tiles The hall also turned out hexagonal in its shape The King walked along the perimeter of the hall and concluded that each of the six sides has and adjacent tiles correspondingly To better visualize the situation look at the picture showing a similar hexagon for and According to the legend as the King of Berland obtained the values and he almost immediately calculated the total number of tiles on the hall floor Can you do the same ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\nint main()\n{\n  int i,a,b,c,tmp,tot;\n  scanf(""%d%d%d"",&a,&b,&c);\n  tot=0;\n  tmp=a*2;\n  for (i=0;i<b+c-1;i++)\n  {\n    tot+=(tmp/2);\n    if (i+1<b) tmp++;\n    else tmp--;\n    if (i+1<c) tmp++;\n    else tmp--;\n  } \n  printf(""%d\\n"",tot);\n}\n']",,,"['implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Tiling with Hexagons.json,https://codeforces.com//blog/entry/5066,For solving this problem you might find some formula like res abc a 1 b 1 c 1 res ab bc ca a b c 1 or something else Also the problem can be solved in O a b c time you can move from the top line to the bottom line of hexagon and sum number of tiles in every line 
https://codeforces.com//contest/420/problem/A,8698,A,420A,420,A. Start Up,Recently a start up by two students of a state university of city F gained incredible popularity Now it s time to start a new company But what do we call it The market analysts came up with a very smart plan the name of the company should be identical to its reflection in a mirror In other words if we write out the name of the company on a piece of paper in a line horizontally from left to right with large English letters then put this piece of paper in front of the mirror then the reflection of the name in the mirror should perfectly match the line written on the piece of paper There are many suggestions for the company name so coming up to the mirror with a piece of paper for each name wouldn t be sensible The founders of the company decided to automatize this process They asked you to write a program that can given a word determine whether the word is a mirror word or not ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define LLD long long\nusing namespace std;\n\nint ok, n;\nchar s[100005], v[300];\n\nint main(){\n\tscanf(""%s"", s);\n\tv[\'A\'] = v[\'H\'] = v[\'I\'] = v[\'M\'] = v[\'O\'] = v[\'T\'] = v[\'U\'] =\n\tv[\'V\'] = v[\'W\'] = v[\'X\'] = v[\'Y\'] = 1;\n\t\n\tn = strlen(s);\n\tok = 1;\n\tFOR(i,0,n){\n\t\tif (!v[s[i]]) ok = 0;\n\t\tif (s[i] != s[n - i - 1]) ok = 0;\n\t}\n\t\n\tputs(ok ? ""YES"" : ""NO"");\n\treturn 0;\n}\n']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Start Up.json,https://codeforces.com//blog/entry/11871,One should firstly recognize that the required string should be palindrome and each character of the string should be symmetric All the symmetric characters are 
https://codeforces.com//contest/364/problem/D,4044,D,364D,364,D. Ghd,John Doe offered his sister Jane Doe find the gcd of some set of numbers Gcd is a positive integer such that all number from the set are evenly divisible by and there isn t such that all numbers of the set are evenly divisible by Unfortunately Jane couldn t cope with the task and John offered her to find the ghd of the same subset of numbers Ghd is a positive integer such that at least half of numbers from the set are evenly divisible by and there isn t such that at least half of the numbers from the set are evenly divisible by Jane coped with the task for two hours Please try it too ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <ctime>\n\nlong long ni() {\n  int c = getchar();\n  while (c < \'0\' || c > \'9\') c = getchar();\n  long long ret = 0;\n  while (c >= \'0\' && c <= \'9\') {\n    ret = ret * 10 + c - \'0\';\n    c = getchar();\n  }\n  return ret;\n}\n\nlong long gcd(long long a, long long b) {\n  while (b > 0) {\n    long long t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\n\nlong long a[1234567];\nlong long d[123456];\nint cc[123456];\n\nint main() {\n  srand(time(NULL));\n  int n = ni();\n  for (int i = 0; i < n; i++) {\n    a[i] = ni();\n  }\n  long long ans = 1;\n  for (int it = 0; it < 10; it++) {\n    long long x = a[((rand() << 15) ^ rand()) % n];\n    int cnd = 0;\n    for (long long i = 1; i * i <= x; i++) {\n      if (x % i != 0) {\n        continue;\n      }\n      d[cnd++] = i;\n      if (i * i != x) d[cnd++] = x / i;\n    }\n    for (int i = 0; i < cnd; i++) cc[i] = 0;\n    std::sort(d, d + cnd);\n    for (int i = 0; i < n; i++) {\n      long long g = gcd(x, a[i]);\n      cc[std::lower_bound(d, d + cnd, g) - d]++;\n    }\n    for (int i = 0; i < cnd; i++) {\n      for (int j = i + 1; j < cnd; j++) {\n        if (d[j] % d[i] == 0) {\n          cc[i] += cc[j];\n        }\n      }\n      if (2 * cc[i] >= n && d[i] > ans) {\n        ans = d[i];\n      }\n    }\n  }\n  printf(""%I64d\\n"", ans);\n}']",,,"['brute force', 'math', 'probabilities']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Ghd.json,https://codeforces.com//blog/entry/9657,Consider random element ar of a With probabillity where g is ghd of a Let xi gcd ai ar There are no more than d distinct xi where d is number of divisors of ar We can find number of ai such as for every k in O d2 D is set of divisors of ar Repeat item 1 x times we will get correct solution with probabillity 1 2 x There is the way to solve this problem O n plog d 2plog for iteration where plog is the maximal number of distinct primes in factorisation of ar 
https://codeforces.com//contest/2051/problem/F,3099579,F,2051F,2051,F. Joker,Consider a deck of n cards The positions in the deck are numbered from 1 to n from top to bottom A joker is located at position m q operations are applied sequentially to the deck During the i th operation you need to take the card at position a i and move it either to the beginning or to the end of the deck For example if the deck is 2 1 3 5 4 and a i 2 then after the operation the deck will be either 1 2 3 5 4 the card from the second position moved to the beginning or 2 3 5 4 1 the card from the second position moved to the end Your task is to calculate the number of distinct positions where the joker can be after each operation ,"['#include <bits/stdc++.h>#define ll long longusing namespace std;\xa0\xa0static vector<pair<ll,ll>> solve(vector<pair<ll,ll>> &arr) {   vector<pair<ll,ll>> ans;   ans.reserve(arr.size());   for (auto &iv : arr) {       if (ans.empty() || ans.back().second < iv.first - 1) {           ans.push_back(iv);       } else {           ans.back().second = max(ans.back().second, iv.second);       }   }   return ans;}\xa0int main(){   ios::sync_with_stdio(false);   cin.tie(nullptr);\xa0   int t;   cin >> t;   while(t--){       ll n, m;       int q;       cin >> n >> m >> q;\xa0       vector<pair<ll,ll>> arr;       arr.push_back({m,m});\xa0       while(q--){           ll a;           cin >> a;\xa0           vector<pair<ll,ll>> res;           res.reserve(arr.size()*2 + 2);\xa0           for (auto &iv : arr) {               ll l = iv.first, r = iv.second;               if (r < a) {                   res.push_back({l, r});\xa0                   ll l2 = l+1, r2 = r+1;                   if (r2 >= 1 && l2 <= n) {                       l2 = max(l2, 1LL);                       r2 = min(r2, n);                       if (l2 <= r2) {                           res.push_back({l2,r2});                       }                   }               }               else if (l > a) {                   res.push_back({l,r});\xa0                   ll l2 = l-1, r2 = r-1;                   if (r2 >= 1 && l2 <= n) {                       l2 = max(l2, 1LL);                       r2 = min(r2, n);                       if (l2 <= r2) {                           res.push_back({l2,r2});                       }                   }               }               else {                   if (l <= a-1) {                       ll lsub = l, rsub = a-1;                       res.push_back({lsub, rsub});                       ll l2 = lsub+1, r2 = rsub+1;                       if (l2<=r2 && l2<=n && r2>=1) {                           l2 = max(l2,1LL);                           r2 = min(r2,n);                           if (l2<=r2) {                               res.push_back({l2,r2});                           }                       }                   }\xa0                   if (l <= a && a <= r) {                       res.push_back({1,1});                       res.push_back({n,n});                   }\xa0                   if (a+1 <= r) {                       ll ls = a+1;                       ll rs = r;                       res.push_back({ls, rs});                       ll l2 = ls-1, r2 = rs-1;                       if (l2<=r2 && l2>=1 && r2<=n) {                           res.push_back({l2,r2});                       }                   }               }           }\xa0           sort(res.begin(), res.end());           arr = solve(res);\xa0           ll ans = 0;\xa0           for (auto &iv : arr) {               ans += (iv.second - iv.first + 1);           }\xa0           cout << ans << "" "";       }       cout << ""\\n"";   }\xa0   return 0;}']",,,"['brute force', 'greedy', 'implementation', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Joker.json,https://codeforces.com//blog/entry/137623,Let s represent the positions where the joker can be as a set of non overlapping segments Let s consider what happens to the segment after applying the th operation if the possible positions segment becomes since moving the th card to the front does not change the joker s positions while moving it to the back shifts the positions up by if the possible positions segment becomes since moving the th card to the front shifts the positions down by while moving it to the back does not change the joker s positions if let s consider subsegments where the joker can be located positions from the subsegment moves to similarly to the case positions from the subsegment moves to similarly to the case the joker from position moves to one of two positions or Thus in this case the segment remains but we need to add two new segments and to the set Note that when the current segment disappears At first glance it seems that this solution works in since the number of segments can be and we need to update each of them However it is not difficult to notice that there cannot be more than segments Specifically the initial segment which expands to the left and right the segment which expands only to the right and the segment which expands only to the left 
https://codeforces.com//contest/1181/problem/E1,359264,E1,1181E1,1181,E1. A Story of One Country  Easy ,Petya decided to visit Byteland during the summer holidays It turned out that the history of this country is quite unusual Initially there were n different countries on the land that is now Berland Each country had its own territory that was represented as a rectangle on the map The sides of the rectangle were parallel to the axes and the corners were located at points with integer coordinates Territories of no two countries intersected but it was possible that some territories touched each other As time passed sometimes two countries merged into one It only happened if the union of their territories was also a rectangle In the end only one country remained Byteland Initially each country had a rectangular castle inside its territory Its sides were parallel to the axes and its corners had integer coordinates Some castles might touch the border of the corresponding country and sides or other castles Miraculously after all the unions the castles are still intact Unfortunately their locations are the only information we have to restore the initial territories of the countries The possible formation of Byteland The castles are shown in blue Petya wonders why no information about the initial countries remained He suspected that the whole story is a fake You were recommended to him as a smart person Please check whether or not there exists a possible set of initial territories that could make the story true ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=1e3;\nint n, a[mxN], b[mxN], c[mxN], d[mxN];\n\nbool dc(vector<int> &v, int tr=0) {\n\tif(v.size()<3)\n\t\treturn 1;\n\tvector<int> x1{INT_MAX}, x2{INT_MAX};\n\tfor(int i : v) {\n\t\tx1.push_back(a[i]);\n\t\tx2.push_back(c[i]);\n\t}\n\tsort(x1.begin(), x1.end());\n\tsort(x2.begin(), x2.end());\n\tint px;\n\tfor(int i=0, j=0, s=0; i<x1.size()-1||j<x2.size()-1; ) {\n\t\tint cx;\n\t\tif(x2[j]<=x1[i]) {\n\t\t\t--s;\n\t\t\tcx=x2[j++];\n\t\t} else {\n\t\t\t++s;\n\t\t\tcx=x1[i++];\n\t\t}\n\t\tif(!s) {\n\t\t\tpx=cx;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(px<x2[x2.size()-2]) {\n\t\tvector<int> p1, p2;\n\t\tfor(int i : v) {\n\t\t\tif(a[i]<px)\n\t\t\t\tp1.push_back(i);\n\t\t\telse\n\t\t\t\tp2.push_back(i);\n\t\t}\n\t\treturn dc(p1)&&dc(p2);\n\t}\n\tif(!tr) {\n\t\tfor(int i : v) {\n\t\t\tswap(a[i], b[i]);\n\t\t\tswap(c[i], d[i]);\n\t\t}\n\t\treturn dc(v, 1);\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvector<int> v(n);\n\tiota(v.begin(), v.end(), 0);\n\tcout << (dc(v)?""YES"":""NO"");\n}']",,,"['brute force', 'divide and conquer', 'sortings']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. A Story of One Country  Easy .json,https://codeforces.com//blog/entry/67727,We can rephrase the problem as follows There is a set of non intersecting rectangles on the plane Let s say that some rectangular area on the plane is good if it contains exactly one rectangle in it or there exists a vertical or horizontal cut which cuts the area into two good areas You are asked to check whether the area 0 109 0 109 is good It s easy to see that it is exactly the same process as in the statement except we don t merge countries into one we look at the reversed process where we split one country into many Also let s notice that when we found some cutting line which doesn t goes through inner part of any rectangle we can always apply it to separate our area into two We can do that since our predicate of set of rectangles being nice is monotonic if we replace set of rectangles with its subset it only can make better Now let s analyze when the cut is good This already gives us a solution in O n2log which passes the easy version of the problem Simply solve the problem recursively sorting rectangles as shown above and symmetrically for horizontal cuts and try finding a cut Once we find it solve the problem recursively Now we have working time T n T x T n x O nlogn where x is a size of one part of the cut The worse case is x 1 so T n O n2log For the full version we need a faster solution The key idea is let s cut always smaller from larger Suppose we are magically able to find any valid cut in O 1 basically the number x Then we could have spent O x to cut out the smaller part into new recursive call While we can continue the process of cutting with the remaining rectangles in this recursion call This solution works in O nlogn Each time the size of problem reduces at least twice when we go into recursion so there are only log levels However we need to handle magic here For example one could have used a segment tree to implement all mentioned above it would give a O nlog2 time But there is a simpler solution Let s sort rectangles using all 4 possible sortings And let s iterate over all this sortings simultaneously We need 4 directions instead of 2 because if we would e g only iterate from let to right we wouldn t be able to cut out the smaller from larger in case the smaller is to the right of larger So we want to both go from left to right and from right to left When in one of the directions we see a valid place to make a cut we remove all the rectangles into the separate recursion call We also mark all those rectangles in the current recursion call as deleted and start the procedure of cutting again We can simply skip the rectangles marked as deleted when we encounter them For example we could use a linked list for that So now we got a solution in O nlog2 one logarithm is from cutting smaller from larger and one logarithm is from sorting One could drop the second logarithm For that we should sort all rectangles at the beginning and then carefully pass the correct ordering down the recursion But that wasn t required 
https://codeforces.com//contest/1294/problem/D,521710,D,1294D,1294,D. MEX maximizing,Recall that of an array is a that does not belong to the array Examples for the array 0 0 1 0 2 MEX equals to 3 because numbers 0 1 and 2 are presented in the array and 3 is the minimum non negative integer not presented in the array for the array 1 2 3 4 MEX equals to 0 because 0 is the minimum non negative integer not presented in the array for the array 0 1 4 3 MEX equals to 2 because 2 is the minimum non negative integer not presented in the array You are given an empty array a in other words a zero length array You are also given a positive integer x You are also given q queries The j th query consists of one integer y j and means that you have to append one element y j to the array The array length increases by 1 after a query In one move you can choose any index i and set a i a i x or a i a i x i e increase or decrease any element of the array by x The only restriction is that Since initially the array is empty you can perform moves only after the first query You have to maximize the minimum excluded of the array if you can perform any number of such operations you can even perform the operation multiple times with one element You have to find the answer after each of q queries i e the j th answer corresponds to the array of length j ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nint tr[N];\nvoid add(int id,int x){\n    //if(id==0)return;\n    for(;id<=n+1;id+=id&-id)tr[id]+=x;\n}\nint query(int id){\n    int re=0;\n    for(;id;id-=id&-id)re+=tr[id];\n    return re;\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1,x;i<=n;i++){\n        scanf(""%d"",&x);\n        x%=m;\n        int l=0,r=n/m;\n        int ans=n+2;\n        while(l<=r){\n            int mid=l+r>>1;\n            if(mid*m+x+1>n+1)r=mid-1;\n            else if(query(mid*m+x+1)-query(mid*m+x)==0)ans=mid,r=mid-1;\n            else l=mid+1;\n        }\n        if(ans<=n+1)\n        add(ans*m+x+1,1);\n        //cout<<""fuck ""<<ans<<\' \'<<x<<\' \'<<ans*m+x<<endl;\n        l=1,r=n+1;\n        ans=n+1;\n        while(l<=r){\n            int mid=l+r>>1;\n            if(query(mid)<mid)ans=mid,r=mid-1;\n            else l=mid+1;\n        }\n        printf(""%d\\n"",ans-1);\n\n    }\n    return 0;\n}\n']",,,"['data structures', 'greedy', 'implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. MEX maximizing.json,https://codeforces.com//blog/entry/73274,Firstly let s understand what the operation does It changes the element but holds the remainder modulo So we can consider all elements modulo Let be the number of elements with the value modulo be the number of elements with the value modulo and so on Let s understand where is the bottleneck of MEX Obviously we can always fill exactly full blocks so MEX is at least MEX will be among all elements such that Among all such elements MEX will be the minimum such Let it be So the final value of MEX is How to deal with queries Let s maintain the sorted set of pairs for all and change it with respect to appended values During each query let s change the set correspondingly and take the answer as the first element of this set using the formula above Time complexity There is also an easy linear solution that uses the same idea but in a different way 
https://codeforces.com//contest/915/problem/F,146473,F,915F,915,F. Imbalance Value of a Tree,You are given a tree consisting of vertices A number is written on each vertex the number written on vertex is Let s denote the function as the difference between maximum and minimum value of on a simple path connecting vertices and Your task is to calculate ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\nint n;\nvector<int>edges[1100000];\nint par[1100000];\nint siz[1100000];\nint find(int a) {\n\tif (par[a] == a)return a;\n\tpar[a] = find(par[a]);\n\treturn par[a];\n}\nvoid unite(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b)return;\n\tsiz[a] += siz[b];\n\tpar[b] = a;\n}\nll w[1100000];\npll p[1100000];\nbool vis[1100000];\nll solve() {\n\tfori1(n) {\n\t\tvis[i] = false;\n\t\tpar[i] = i;\n\t\tsiz[i] = 1;\n\t}\n\tll answer = 0;\n\tfori1(n) {\n\t\tp[i] = mp(w[i], i);\n\t}\n\tsort(p + 1, p + 1 + n);\n\n\tfork1(n) {\n\t\tint a = p[k].second;\n\t\tanswer += w[a];\n\t\tll have = 1;\n\t\tfor (auto x : edges[a]) {\n\t\t\tif (!vis[x])continue;\n\t\t\tanswer += have*siz[find(x)] * w[a];\n\t\t\thave += siz[find(x)];\n\t\t\tunite(a, x);\n\t\t}\n\t\tvis[a] = true;\n\t}\n\treturn answer;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tcin >> n;\n\tfori1(n)cin >> w[i];\n\tfori(n - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tll ans = solve();\n\tfori1(n)w[i] = -w[i];\n\tans += solve();\n\tcout << ans;\n\treturn 0;\n}']",,,"['data structures', 'dsu', 'graphs', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Imbalance Value of a Tree.json,https://codeforces.com//blog/entry/57123,Let s calculate the answer as the difference between sum of maxima and sum of minima over all paths These sums can be found by the following approach Consider the sum of maxima Let s sort all vertices in ascending order of values of if two vertices have equal values their order doesn t matter This order has an important property that we can use for every path the maximum on this path is written on the vertex that has the greatest position in sorted order This allows us to do the following Let s denote as a tree rooted at vertex that is formed by the set of such vertices that are directly connected to or some other vertex from the set and have Consider the vertices that are connected to in this tree Let s denote them as the order doesn t matter and denote by the size of the subtree of in the tree Let s try to calculate the number of paths going through in this tree paths that have as its endpoint paths connecting a vertex from subtree of to a vertex from subtree of So vertex adds the sum of these values multiplied by to the sum of maxima To calculate these sums we will use the following algorithm Initialize a DSU disjoint set union making a set for each vertex Process the vertices in sorted order When we process some vertex find all its already processed neighbours they will be in For every neighbour denote the size of its set in DSU as Then calculate the number of paths going through using aforementioned formulas to do it in linear time use partial sums Add this number multiplied by to the sum of maxima and merge with in DSU To calculate the sum of minima you can do the same while processing vertices in reversed order Time complexity of this solution is 
https://codeforces.com//contest/1989/problem/D,2721697,D,1989D,1989,D. Smithing Skill,You are playing a famous computer game that just works where you have various skills you can level up Today you focused on the Smithing skill Your tactic is obvious forging weapons from ingots and then melting them back to return the materials partially For simplicity every time you create an item you get 1 experience point and every time you melt an item you also get 1 experience point There are n classes of weapons you can forge and m types of metal ingots You can create one weapon of the i th class spending a i ingots of metal of Melting a weapon of the i th class which you crafted earlier returns you b i ingots of the type of metal You have c j metal ingots of the j th type and you know that you can craft a weapon of any class from any metal type Each combination of a weapon class and a metal type can be used any number of times What is the maximum total amount of experience you can earn by crafting and melting weapons ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    int n,m; cin >> n >> m;    vc<pii> a(n);    rep(n) cin >> a[i].first;    rep(n) cin >> a[i].second,a[i].second=a[i].first-a[i].second;    sort(all(a));    vc<pii> b;    for(auto &[x,y]: a){        if(sz(b)&&y>=b.back().second) continue;        b.pb({x,y});    }    vi dp(1000005);    int cur=0;    rep(i,1,sz(dp)){        while(cur+1<sz(b)&&b[cur+1].first<=i) cur++;        if(b[cur].first<=i){            dp[i]=dp[i-b[cur].second]+1;        }    }    ll res=0;    rep(_,m){        ll x; cin >> x;        if(x>=sz(dp)){            ll y=(x-sz(dp)+1+b.back().second-1)/b.back().second;            res+=y;            x-=y*b.back().second;        }        if(x>=0) res+=dp[x];    }    print(res*2);}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}']",,,"['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Smithing Skill.json,https://codeforces.com/blog/entry/130988,It s quite obvious that we should melt every weapon we forge and we can do it as soon as we forge it So let s do these actions in pairs forge a weapon then instantly melt it Since you can t use two types of metal while forging one weapon we can solve our task independently for each metal type Suppose you have x ingots of the chosen metal You can act greedily you can forge only weapons of classes with ai x but among them it s optimal to chose one that makes us lose the minimum number of ingots by forging it and melting it so we need to minimize the value of ai bi However this greedy solution is too slow when implemented naively Let s define A maxai and look at two cases x A or x A If x A let s just precalculate answers ans x for all x from 0 to A To do so let s precalculate another value best x as the minimum ai bi among all classes i where ai x In other words best x will be equal to the minimum amount of ingots you ll lose if you have x ingots and you need to forge melt one weapon We can precalculate best x in two steps for each class i we can set best ai min best ai ai bi using approach similar to prefix minima or dynamic programming we can also update best x min best x best x 1 for all x from 1 to A Using the array best we can calculate ans easily with dynamic programming ans x 2 ans x best x for all x from 1 to A In case x A we can forge melt a weapon with minimum ai bi as many times as we can until x A Once x becomes less or equal to A we can take the value ans x and finish processing that metal type Knowing that the minimum ai bi is just best A we can reformulate our first step as finding minimum k such that x k best A A or k x Abest A In other words we ll make the first step exactly k x Abest A times So we can calculate the final answer as 2k ans x k best A As a result we run precalculating in O n A time and process each metal type in O 1 time The total complexity is O n m A time and space 
https://codeforces.com//contest/1095/problem/B,275102,B,1095B,1095,B. Array Stabilization,You are given an array a consisting of n integer numbers Let of the array be the following value max limits i 1 n a i min limits i 1 n a i You have to remove element from this array to minimize of the resulting n 1 elements array Your task is to calculate the minimum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint main(){\n\tfast_io;\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n);\n\tint ans=1e6;\n\tif(n==2){\n\t\tpret(0);\n\t}\n\tans=min(ans,a[n-1]-a[1]);\n\tans=min(ans,a[n-2]-a[0]);\n\tshow(ans);\n\treturn 0;\n}']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Array Stabilization.json,https://codeforces.com//blog/entry/64130,It is easy to see that we always have to remove either minimum or maximum of the array So we can sort the array and the answer will be We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time 
https://codeforces.com//contest/1903/problem/E,2355506,E,1903E,1903,E. Geo Game,Theofanis and his sister are playing the following game They have n points in a 2D plane and a starting point s x s y Each player starting from the first player chooses one of the n points that wasn t chosen before and adds to the sum which is initially 0 the of the Euclidean distance from the previous point which is either the starting point or it was chosen by the other person to the new point that the current player selected The game ends after exactly n moves after all the points are chosen The first player wins if the sum is even in the end Otherwise the second player wins Theofanis is a very competitive person and he hates losing Thus he wants to choose whether he should play first or second Can you show him which player to choose and how he should play to beat his sister ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 20;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector <set <int>> bucket(2);\n        int sx, sy; cin >> sx >> sy;\n        int bg = (sx ^ sy) & 1;\n        for (int i = 1, x, y; i <= n; ++i) {\n            cin >> x >> y;\n            bucket[(x ^ y) & 1].insert(i);\n        }\n        // first want bg as last\n        // second want bg ^ 1 as last\n        int choose = 0, tot = n;\n        auto computer = [&]() {\n            int x; cin >> x;\n            bucket[0].erase(x), bucket[1].erase(x), tot--;\n        };\n        auto user = [&]() {\n            int cur = choose;\n            if (bucket[choose].empty()) {\n                cur ^= 1;\n            }\n            int x = *bucket[cur].begin();\n            bucket[cur].erase(bucket[cur].begin()), tot--;\n            cout << x << endl;\n        };\n        if (bucket[bg].size() >= bucket[bg ^ 1].size()) {\n            cout << ""First"" << endl;\n            choose = bg ^ 1;\n        } else {\n            cout << ""Second"" << endl;\n            choose = bg;\n            computer();\n        }\n        while (tot) {\n            user();\n            if (!tot) {\n                break;\n            }\n            computer();\n        }\n    }\n}']",,,"['greedy', 'interactive', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Geo Game.json,https://codeforces.com//blog/entry/122820,If we went from point to then we will add to the sum which is equal to mod is bitwise xor For each point we find mod mod Let the number of mod mod the number of mod mod and mod mod Let s say that we create a binary string starting with and has another zeros and ones If the number of is odd then the sum will be odd otherwise the sum will be even If you are the first player then you want to have an even number of That holds iff the first element of is the same as the last element of Thus the second player will want to put all occurrences of before the end so that the last element is not equal to the first He can do this iff rounded down this means that If you play as the first player and you choose occurrences of until there aren t anyand else you play as the second player and you choose occurrences of until there aren t any 
https://codeforces.com//contest/1398/problem/B,699502,B,1398B,1398,B. Substring Removal Game,Alice and Bob play a game They have a binary string s a string such that each character in it is either 0 or 1 Alice moves first then Bob then Alice again and so on During their move the player can choose any number not less than one of in s and delete them For example if the string is 10110 there are 6 possible moves deleted characters are bold textbf 1 0110 to 0110 1 textbf 0 110 to 1110 10 textbf 1 10 to 1010 101 textbf 1 0 to 1010 10 textbf 11 0 to 100 1011 textbf 0 to 1011 After the characters are removed the characters to the left and to the right of the removed block become adjacent I e the following sequence of moves is valid 10 textbf 11 0 to 1 textbf 00 to 1 The game ends when the string becomes empty and the score of each player is Each player wants to maximize their score Calculate the resulting score of Alice ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 5555;\nint n;\nchar s[N];\n\nvoid solve() {\n\n\tscanf(""%s"", s + 1);\n\ts[0] = \'0\';\n\tn = strlen(s);\n\ts[n++] = \'0\';\n\tvector<int> a;\n\tint len = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == \'0\') {\n\t\t\tif (len > 0) a.push_back(len);\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\tlen++;\n\t\t}\n\t}\n\tsort(all(a));\n\treverse(all(a));\n\tint ans = 0;\n\tfor (int i = 0; i < (int)a.size(); i += 2)\n\t\tans += a[i];\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']",,,"['games', 'greedy', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Substring Removal Game.json,https://codeforces.com//blog/entry/81506,The following greedy strategy works during each turn delete the largest possible substring consisting of characters So we have to find all blocks of characters sort them according to their length and model which blocks are taken by Alice and which by Bob Why does the greedy strategy work It s never optimal to delete some part of the block of ones because we either have to spend an additional turn to delete the remaining part or allow our opponent to take it which is never good Why don t we need to delete zeroes If we delete a whole block of zeroes our opponent can take the newly formed block of s during their turn and it is obviously worse than taking a part of that block And deleting some part of a block of zeroes doesn t do anything our opponent will never delete the remaining part because it s suboptimal 
https://codeforces.com//contest/936/problem/C,159978,C,936C,936,C. Lock Puzzle,Welcome to another task about breaking the code lock Explorers Whitfield and Martin came across an unusual safe inside of which according to rumors there are untold riches among which one can find the solution of the problem of discrete logarithm Of course there is a code lock is installed on the safe The lock has a screen that displays a string of lowercase Latin letters Initially the screen displays string Whitfield and Martin found out that the safe will open when string will be displayed on the screen The string on the screen can be changed using the operation In order to apply this operation explorers choose an integer from 0 to inclusive After that the current string changes to where the length of is and the length of is In other words the suffix of the length of string is reversed and moved to the beginning of the string For example after the operation the string will be changed with string since Explorers are afraid that if they apply too many operations the lock will be locked forever They ask you to find a way to get the string on the screen using no more than operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N;\n  cin >> N;\n\n  string s, t;\n  cin >> s >> t;\n\n  vector<int> Ops;\n\n  auto doOp = [&](int x) {\n    s = s.substr(N - x) + s.substr(0, N - x);\n    reverse(s.begin(), s.begin() + x);\n    Ops.PB(x);\n  };\n\n  int NumOK = 0;\n  while (s != t) {\n    char What = t[NumOK];\n    int Loc = -1;\n    for (int i = 0; i < N - NumOK; ++i)\n      if (s[i] == What) {\n        Loc = i;\n        break;\n      }\n\n    if (Loc == -1) {\n      cout << ""-1\\n"";\n      return 0;\n    }\n\n    int a = Loc,\n        b = N - Loc - NumOK - 1,\n        u = NumOK;\n\n    doOp(b + u);\n    doOp(1);\n    doOp(a + b + u);\n\n    ++NumOK;\n    debug(s, t, NumOK);\n  }\n\n  cout << SZ(Ops) << ""\\n"";\n  for (int v : Ops) { cout << v << "" ""; }\n  cout << ""\\n"";\n}\n\n']",,,"['constructive algorithms', 'implementation', 'strings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Lock Puzzle.json,https://codeforces.com//blog/entry/58056,The answer is only in the case when multisets of letters in and differ In all other cases there is a solution Let s construct the solution uses operations To do that you need to add two symbols to current already built substring using five operations You can do it for example using the following method the underlined string is chosen as If we had as suffix after these operations we get which is two symbols longer Choosing and accordingly we can maintain maintain the invariant that the suffix of current string always contains monotone increasing or decreasing sequence After we make this sequence have length the entire string is either a cyclic shift or a reversed cyclic shift of You can do cyclic shift by in three operations This way we get a solution 
https://codeforces.com//contest/1434/problem/A,773398,A,1434A,1434,A. Perform Easily,After battling Shikamaru Tayuya decided that her flute is too predictable and replaced it with a guitar The guitar has 6 strings and an infinite number of frets numbered from 1 Fretting the fret number j on the i th string produces the note a i j Tayuya wants to play a melody of n notes Each note can be played on different string fret combination The easiness of performance depends on the difference between the maximal and the minimal indices of used frets The less this difference is the easier it is to perform the technique Please determine the minimal possible difference For example if a 1 1 2 2 3 3 and the sequence of notes is 4 11 11 12 12 13 13 corresponding to the second example we can play the first note on the first string and all the other notes on the sixth string Then the maximal fret will be 10 the minimal one will be 3 and the answer is 10 3 7 as shown on the picture ,"[""/**\n *    author:  tourist\n *    created: 25.10.2020 14:04:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n = 6;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  int m;\n  cin >> m;\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  vector<vector<int>> x(m, vector<int>(n));\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      x[i][j] = b[i] - a[j];\n    }\n    sort(x[i].begin(), x[i].end());\n  }\n  vector<pair<int, int>> p;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      p.emplace_back(x[i][j], i);\n    }\n  }\n  sort(p.begin(), p.end());\n  multiset<int> s;\n  for (int i = 0; i < m; i++) {\n    s.insert(x[i][0]);\n  }\n  vector<int> ptr(m, 0);\n  int ans = (int) 2e9;\n  {\n    int mn = *s.begin();\n    int mx = *prev(s.end());\n    ans = min(ans, mx - mn);\n  }\n  for (auto& q : p) {\n    int i = q.second;\n    s.erase(s.find(x[i][ptr[i]]));\n    ++ptr[i];\n    if (ptr[i] == n) {\n      break;\n    }\n    s.insert(x[i][ptr[i]]);\n    int mn = *s.begin();\n    int mx = *prev(s.end());\n    ans = min(ans, mx - mn);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]",,,"['binary search', 'brute force', 'data structures', 'dp', 'greedy', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Perform Easily.json,https://codeforces.com//blog/entry/84056,Consider all possible frets we may need to use To do this we sort all the pairs bj ai j lexicographically Now we need to find a subsegment with the minimal range containing the first fields and also so that all numbers from 1 to n occur among the second fields so it will mean that for each note there is at least one string fret combination For each l denote the minimal right l so that l right l is a valid subsegment It s easy to see that right l right l 1 because if l 1 right l 1 contains all numbers from 1 to n among the second fields then so does l right l 1 So to find all right l one can just use two pointers maintaining the set of notes that occur on the segment Once we calculated it we just print the minimal difference between the first fields of the endpoints of all possible segments l right l The final complexity is O nmlog nm 
https://codeforces.com//contest/862/problem/C,123158,C,862C,862,C. Mahmoud and Ehab and the xor,Mahmoud and Ehab are on the third stage of their adventures now As you know Dr Evil likes sets This time he won t show them any set from his large collection but will ask them to create a new set to replenish his beautiful collection of sets Dr Evil has his favorite evil integer He asks Mahmoud and Ehab to find a set of distinct non negative integers such the bitwise xor sum of the integers in it is exactly Dr Evil doesn t like big numbers so any number in the set shouldn t be greater than ,"['#include <cstdio>\nint N, X;\nint main()\n{\n\tscanf(""%d%d"", &N, &X);\n\tif (N == 1)\n\t{\n\t\tprintf(""YES\\n%d\\n"", X);\n\t\treturn 0;\n\t}\n\tif (N == 2)\n\t{\n\t\tif (X == 0)\n\t\t\tputs(""NO"");\n\t\telse\n\t\t\tprintf(""YES\\n0 %d\\n"", X);\n\t\treturn 0;\n\t}\n\tif (N == 3)\n\t{\n\t\tif (X == 0)\n\t\t\tprintf(""YES\\n1 2 3\\n"");\n\t\telse if (X == 1)\n\t\t\tprintf(""YES\\n0 2 3\\n"");\n\t\telse\n\t\t\tprintf(""YES\\n0 1 %d\\n"", X ^ 1);\n\t\treturn 0;\n\t}\n\tputs(""YES"");\n\tfor (int i = 0; i < N - 4; i++)\n\t{\n\t\tX ^= i;\n\t\tprintf(""%d "", i);\n\t}\n\tif (1 <= X && X <= 3)\n\t{\n\t\tfor (int i = 0; i <= 10; i++)\n\t\t\tfor (int j = 0; j <= 10; j++)\n\t\t\t\tif (i != j)\n\t\t\t\t\tfor (int k = 0; k <= 10; k++)\n\t\t\t\t\t\tif (i != k && j != k)\n\t\t\t\t\t\t\tfor (int l = 0; l <= 10; l++)\n\t\t\t\t\t\t\t\tif (i != l && j != l && k != l)\n\t\t\t\t\t\t\t\t\tif ((i ^ j ^ k ^ l) == X)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tprintf(""%d %d %d %d\\n"", 262144 + i, 262144 + j, 262144 + k, 262144 + l);\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t}\n\t}\n\telse\n\t\tprintf(""262144 262145 262146 %d\\n"", X ^ 262144 ^ 262145 ^ 262146);\n\treturn 0;\n}\n']",,,['constructive algorithms'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Mahmoud and Ehab and the xor.json,https://codeforces.com//blog/entry/54590,is the only case with answer NO Let First print The first positive integers Let their bitwise xor sum be If You can add and Otherwise you can add and We handled the case in a different way because if we add and in this case Then it s like adding and appears twice so we ll get wrong answer Handle print and print and Solution link mahmoudbadawy https pastebin com w67KUY5u 
https://codeforces.com//contest/1605/problem/B,1182995,B,1605B,1605,B. Reverse Sort,Ashish has a binary string s of length n that he wants to sort in non decreasing order He can perform the following operation Choose a subsequence of any length such that its elements are in non increasing order Formally choose any k such that 1 leq k leq n and any sequence of k indices 1 le i 1 lt i 2 lt ldots lt i k le n such that s i 1 ge s i 2 ge ldots ge s i k Reverse this subsequence in place Formally swap s i 1 with s i k swap s i 2 with s i k 1 ldots and swap s i lfloor k 2 rfloor with s i lceil k 2 rceil 1 Here lfloor x rfloor denotes the largest integer not exceeding x and lceil x rceil denotes the smallest integer not less than x Find the minimum number of operations required to sort the string in non decreasing order It can be proven that it is always possible to sort the given binary string in at most n operations ,"['// Problem: B. Reverse Sort\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/B\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nchar s[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tscanf(""%s"",s+1);\n\t\tint c=0;\n\t\tfor(int i=1; i<=n; ++i) if(s[i]==\'0\') ++c;\n\t\tvector<int> v;\n\t\tfor(int i=1; i<=n; ++i) if(s[i]==\'0\')\n\t\t{\n\t\t\tif(i>c) v.push_back(i);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(i<=c) v.push_back(i);\n\t\t}\n\t\tif(!v.empty()) \n\t\t{\n\t\t\tputs(""1"");\n\t\t\tprintf(""%lld "",(int)v.size());\n\t\t\tfor(int i:v) printf(""%lld "",i);\n\t\t\tputs("""");\n\t\t}\n\t\telse puts(""0"");\n\t}\n\treturn 0;\n}']",,,"['greedy', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Reverse Sort.json,https://codeforces.com//blog/entry/96866,Any binary string can be sorted in at most operation Let the number of s in be and the number of s in be The first positions of the final sorted string will be and the remaining positions will be since it is sorted in non decreasing order For every that is in the first positions of there is a that is in the last positions of Why If the string is not already sorted in one operation pick the subsequence consisting of all s among the first positions of as well as all s among the last positions of It can be shown that this will correctly sort the string since the number of such s and s are equal 
https://codeforces.com//contest/1709/problem/D,1473247,D,1709D,1709,D. Rorororobot,There is a grid consisting of n rows and m columns The rows are numbered from 1 to n from bottom to top The columns are numbered from 1 to m from left to right The i th column has the bottom a i cells blocked the cells in rows 1 2 dots a i the remaining n a i cells are unblocked A robot is travelling across this grid You can send it commands move up right down or left If a robot attempts to move into a blocked cell or outside the grid it explodes However the robot is broken it executes each received command k times So if you tell it to move up for example it will move up k times k cells You can t send it commands while the robot executes the current one You are asked q queries about the robot Each query has a start cell a finish cell and a value k Can you send the robot an arbitrary number of commands possibly zero so that it reaches the finish cell from the start cell given that it executes each command k times The robot must stop in the finish cell If it visits the finish cell while still executing commands it doesn t count ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint a[N];\nint n, m;\nint sparse[LOG][N];\nint p2[N];\n\nint getMax(int l, int r) {\n\tint k = p2[r - l];\n\treturn max(sparse[k][l], sparse[k][r - (1 << k)]);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &m, &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tsparse[0][i] = a[i];\n\t}\n\tfor (int k = 0; k < LOG - 1; k++) {\n\t\tfor (int i = 0; i + (1 << (k + 1)) <= n; i++)\n\t\t\tsparse[k + 1][i] = max(sparse[k][i], sparse[k][i + (1 << k)]);\n\t}\n\tfor (int i = 2; i < N; i++)\n\t\tp2[i] = p2[i / 2] + 1;\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint x1, y1, x2, y2, k;\n\t\tscanf(""%d%d%d%d%d"", &y1, &x1, &y2, &x2, &k);\n\t\tif (abs(x1 - x2) % k) {\n\t\t\tprintf(""NO\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif (abs(y1 - y2) % k) {\n\t\t\tprintf(""NO\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 > x2) swap(x1, x2);\n\t\tint mx = getMax(x1 - 1, x2);\n\t\tint y = m - (m % k);\n\t\ty += y1 % k;\n\t\twhile(y <= m) y += k;\n\t\ty -= k;\n\t\tif (y <= mx) {\n\t\t\tprintf(""NO\\n"");\n\t\t} else {\n\t\t\tprintf(""YES\\n"");\n\t\t}\n\t}\n\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'greedy', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Rorororobot.json,https://codeforces.com//blog/entry/105164,What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example 
https://codeforces.com//contest/103/problem/A,542,A,103A,103,A. Testing Pants for Sadness,The average miner Vaganych took refresher courses As soon as a miner completes the courses he should take exams The hardest one is a computer test called Testing Pants for Sadness The test consists of questions the questions are to be answered strictly in the order in which they are given from question to question Question contains answer variants exactly one of them is correct A click is regarded as selecting any answer in any question The goal is to select the correct answer for each of the questions If Vaganych selects a wrong answer for some question then all selected answers become unselected and the test starts from the very beginning from question again But Vaganych remembers everything The order of answers for each question and the order of questions remain unchanged as well as the question and answers themselves Vaganych is very smart and his memory is superb yet he is unbelievably unlucky and knows nothing whatsoever about the test s theme How many clicks will he have to perform in the worst case ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint64 x;\nint64 res;\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tres = 0;\n\tcin >> n;\n\tforn (i, n) {\n\t\tcin >> x;\n\t\tres += (x-1) * (int64)(i+1) + 1;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n']",,,"['greedy', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Testing Pants for Sadness.json,https://codeforces.com/blog/entry/2426?locale=en,We can t move to the th question before clicking all answers at th question We will move to the very beginning clicking at answers and only one will move us to the next step Every way from beginning to th question have length equal to plus one for click There is a simple formula for th question 1 based numeration Let s summarize all values of for making the answer 
https://codeforces.com//contest/596/problem/E,40909,E,596E,596,E. Wilbur and Strings,Wilbur the pig now wants to play with strings He has found an by table consisting only of the digits from to where the rows are numbered to and the columns are numbered to Wilbur starts at some square and makes certain moves If he is at square and the digit is written at position move to the square if that square lies within the table and he stays in the square otherwise Before Wilbur makes a move he can choose whether or not to write the digit written in this square on the white board All digits written on the whiteboard form some string Every time a new digit is written it goes to the end of the current string Wilbur has strings that he is worried about For each string Wilbur wants to know whether there exists a starting position so that by making finitely many moves Wilbur can end up with the string written on the white board ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 249 * 249;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nstring mat[maxN], qs;\nint n, m, topo[maxN], h, t;\nvector<int> in[maxN], out[maxN];\nint ax[10], bx[10], deg[maxN], mark[maxN], dp[maxN], has[maxN], vis[maxN], dig[maxN], ms[(int) 1e6 + 9];\n\nint check (int i, int j) {\n\treturn (0 <= i) && (i < n) && (0 <= j) && (j < m);\t\n}\n\nint get (int i, int j) {\n\treturn i * m + j;\n}\n\nint f (int i, int j) {\n\tif (!check(i + ax[mat[i][j] - \'0\'], j + bx[mat[i][j] - \'0\']))\n\t\treturn get(i, j);\n\treturn get(i + ax[mat[i][j] - \'0\'], j + bx[mat[i][j] - \'0\']);\n}\n\nvoid dfs (int v) {\n\tif (vis[v]++) return;\n\tfor (int u : out[v]) {\n\t\tdfs(u);\n\t\thas[v] |= has[u];\t\n\t}\n\tif (!mark[v])\n\t\thas[v] |= 1 << dig[v];\n}\n\nvoid build () {\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint v = get(i, j), u = f(i, j);\n\t\t\tdig[v] = mat[i][j] - \'0\';\n\t\t\tout[v].push_back(u);\n\t\t\tin[u].push_back(v);\n\t\t\tdeg[u]++;\n\t\t}\n\tn = n * m;\n\tfor (int i = 0; i < n; i++)\n\t\tif (deg[i] == 0)\n\t\t\ttopo[t++] = i;\n\twhile (h != t) {\n\t\tint v = topo[h++];\n\t\tmark[v] = 1;\n\t\tfor (int u : out[v]) if ((--deg[u]) == 0) {\n\t\t\ttopo[t++] = u;\t\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (!vis[i])\n\t\tdfs(i);\n}\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tint q; cin >> q;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> mat[i];\n\tfor (int i = 0; i < 10; i++)\n\t\tcin >> ax[i] >> bx[i];\n\tbuild();\n\twhile (q--) {\n\t\tcin >> qs;\n\t\tm = (int) qs.size();\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tms[i] = 0;\n\t\tfor (int i = m - 1; i >= 0; i--)\n\t\t\tms[i] = ms[i + 1], ms[i] |= 1 << (qs[i] - \'0\');\n\t\tmemset(dp, 0, sizeof (dp));\n\t\tbool flag = 0;\n\t\tfor (int _ = 0; _ < t; _++) {\n\t\t\tint v = topo[_];\n\t\t\tfor (int u : in[v]) if (mark[u]) {\n\t\t\t\tsmax(dp[v], dp[u]);\n\t\t\t}\n\t\t\tif (dp[v] != m) {\n\t\t\t\tif (dig[v] == qs[dp[v]] - \'0\')\n\t\t\t\t\tdp[v]++;\n\t\t\t}\n\t\t\tif ((has[v] & ms[dp[v]]) == ms[dp[v]]) {\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!flag && (has[i] & ms[0]) == ms[0]) {\n\t\t\t\tflag = 1;\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\tif (!flag)\n\t\t\tcout << ""NO\\n"";\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",,,"['dfs and similar', 'dp', 'graphs', 'strings']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Wilbur and Strings.json,https://codeforces.com//blog/entry/21599,Solution 1 Suppose that is a string in the query Reverse and the direction of all the moves that can be made on the table Note that starting at any point that is part of a cycle there is a loop and then edges that go out of the loop So for every point it can be checked by dfs whether the can be made by starting at that point by storing what is in the cycle Moreover note that in the reversed graph each point can only be a part of one cycle Therefore the total time for the dfs in a query is This is good enough for queries to run in time Complexity where is the number of distinct characters in the table and is the query string for the th query Code Solution Solution 2 Actually too slow see comment by waterfalls below for more details For each string dfs from every node that has in degree equal to in the original graph There will be a path which leads into a cycle after which anything in the cycle can be used any number of times in Only every node with in degree equal to has to be checked because every path which leads to a cycle is part of a larger path which starts with a vertex of in degree that leads into a cycle This solution is slower but it works in practice since it is really hard for a string to match so many times in the table Each query will take time but it is much faster in practice Complexity where is the number of distinct characters in the table and is the query string of the th query 
https://codeforces.com//contest/1245/problem/E,456078,E,1245E,1245,E. Hyakugoku and Ladders,Hyakugoku has just retired from being the resident deity of the South Black Snail Temple in order to pursue her dream of becoming a cartoonist She spent six months in that temple just playing Cat s Cradle so now she wants to try a different game Snakes and Ladders Unfortunately she already killed all the snakes so there are only ladders left now The game is played on a 10 times 10 board as follows At the beginning of the game the player is at the bottom left square The objective of the game is for the player to reach the Goal the top left square by following the path and climbing vertical ladders Once the player reaches the Goal the game ends The path is as follows if a square is not the end of its row it leads to the square next to it along the direction of its row if a square is the end of its row it leads to the square above it The direction of a row is determined as follows the direction of the bottom row is to the right the direction of any other row is opposite the direction of the row below it See Notes section for visualization of path During each turn the player rolls a standard six sided dice Suppose that the number shown on the dice is r If the Goal is less than r squares away on the path the player doesn t move but the turn is performed Otherwise the player advances exactly r squares along the path and then stops If the player stops on a square with the bottom of a ladder the player that ladder If she chooses not to climb then she stays in that square for the beginning of the next turn Some squares have a ladder in them Ladders are only placed vertically each one leads to the same square of some of the upper rows In order for the player to climb up a ladder after rolling the dice she must stop at the square containing the bottom of the ladder After using the ladder the player will end up in the square containing the top of the ladder She cannot leave the ladder in the middle of climbing And if the square containing the top of the ladder also contains the bottom of another ladder she is not allowed to use that second ladder The numbers on the faces of the dice are 1 2 3 4 5 and 6 with each number having the same probability of being shown Please note that it is possible for ladders to overlap but the player cannot switch to the other ladder while in the middle of climbing the first one it is possible for ladders to go straight to the top row but not any higher it is possible for two ladders to lead to the same tile it is possible for a ladder to lead to a tile that also has a ladder but the player will not be able to use that second ladder if she uses the first one the player can only climb up ladders not climb down Hyakugoku wants to finish the game as soon as possible Thus on each turn she chooses whether to climb the ladder or not optimally Help her to determine the minimum expected number of turns the game will take ,"['#include<bits/stdc++.h>\nusing namespace std;\nint p2i(int x, int y)\n{\n    if(x%2 == 0) return x*10+y;\n    return x*10+9-y;\n}\nint arr[10][10];\nint flatten[100];\ndouble dp[100];\nint main()\n{\n    for(int i=0; i<10; ++i)\n        for(int j=0; j<10; ++j)\n        {\n            scanf(""%d"", &arr[i][j]);\n            int c = p2i(i, j);\n            flatten[c] = -1;\n            if(arr[i][j])\n            {\n                int ni = i-arr[i][j];\n                int nj = j;\n                flatten[c] = p2i(ni, nj);\n            }\n        }\n    dp[0] = 0;\n    for(int i=1; i<100; ++i)\n    {\n        double ans = 0;\n        int pass = 0;\n        for(int j=1; j<=6; ++j)\n        {\n            if(j>i)\n            {\n                ++pass; continue;\n            }\n            int dest = i-j;\n            double cost = dp[dest];\n            \n            if(flatten[dest] != -1)\n                cost = min(cost, dp[flatten[dest]]);\n            ans += cost;\n        }\n        dp[i] = (ans+6)/(6-pass);\n    }\n    printf(""%.12f\\n"", dp[99]);\n}']",,,"['dp', 'probabilities', 'shortest paths']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Hyakugoku and Ladders.json,https://codeforces.com/blog/entry/71080,To make implementation easier flatten the board into an array such that the th tile on the path is Define a function as follows if has no ladder otherwise where is such that the ladder from leads to Then do dp Define to be the minimum expected number of turns before the game ends when the player is at Then since is the Goal Next use the formula where if and otherwise Thus for transition should be And for transition is the same as the formula Answer is Alternatively instead of doing dp we can use numerical methods Initialize and Then repeat the following several times from to assign to After each iteration will get closer to the answer For this problem 1000 iterations is more than enough to get AC using this method 
https://codeforces.com//contest/1969/problem/F,2619522,F,1969F,1969,F. Card Pairing,There is a deck of n cards each card has one of k types You are given the sequence a 1 a 2 dots a n denoting the types of cards in the deck from top to bottom Both n and k are even numbers You play a game with these cards First you draw k topmost cards from the deck Then the following happens each turn of the game you choose two cards from your hand and play them If these cards have the same type you earn a coin then if the deck is not empty you draw two top cards from it then if both your hand and your deck are empty the game ends Otherwise the new turn begins You have to calculate the maximum number of coins you can earn during the game ,"['#include ""bits/stdc++.h""#pragma GCC optimize (""O3"")#pragma GCC target (""sse4"") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\xa0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\xa0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}void __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}void __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}void __print(bool x) {cerr << (x ? ""true"" : ""false"");}\xa0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}template<typename T>void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}void _print() {cerr << ""]\\n"";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;#else#define dbg(x...)#endif\xa0\xa0const int MOD = 1000000007;const char nl = \'\\n\';const int MX = 100001; \xa0set<int> cur;\xa0void flip(int X) {    if (cur.count(X)) {        cur.erase(X);    } else cur.ins(X);}\xa0void solve() {    int N, K; cin >> N >> K;    vi A(N); F0R(i, N) cin >> A[i];    F0R(i, N) A[i]--;    F0R(i, K) flip(A[i]);    int dp[(N-K)/2 + 1];    F0R(i, (N-K)/2 + 1) dp[i] = MX;    F0R(i, (N-K)/2) {        if (sz(cur) == K) {            dp[i] = 0;            goto done;        }        flip(A[K+i*2]); flip(A[K+i*2+1]);    }    dp[(N-K)/2] = 0;    done:    ;\xa0    F0R(i, (N-K)/2) {        bool ev[K]; F0R(j, K) ev[j] = false;        FOR(j, K+i*2, N) {            ev[A[j]] = !ev[A[j]];        }        cur.clear();        int cOdd = K, cEv = 0;        F0R(i, K) if (ev[i]) {            cEv++; cOdd--;        }        int c0 = (cOdd * (cOdd - 1)) / 2;        int c1 = cOdd * cEv;        int c2 = (cEv * (cEv - 1)) / 2;        set<pi> used;        FOR(j, i+1, (N-K)/2) {            flip(A[K+j*2-2]); flip(A[K+j*2-1]);            if (sz(cur) == 2) {                pi cp = {*cur.begin(), *cur.rbegin()};                if (used.count(cp)) continue;                if (!ev[cp.f] && !ev[cp.s]) {                    c0--;                } else if (ev[cp.f] && ev[cp.s]) {                    c2--;                } else c1--;                used.ins(cp);                int cv = dp[i];                if (ev[*cur.begin()]) cv++;                if (ev[*cur.rbegin()]) cv++;                ckmin(dp[j], cv);            }        }        if (c0) {            ckmin(dp[(N-K)/2], dp[i]);        } else if (c1) {            ckmin(dp[(N-K)/2], dp[i] + 1);        } else if (c2) {            ckmin(dp[(N-K)/2], dp[i] + 2);        }    }\xa0    cur.clear();    F0R(i, N) flip(A[i]);    cout << (N-sz(cur))/2 - dp[(N-K)/2] << nl;\xa0\xa0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\xa0    int T = 1;//    cin >> T;    while(T--) {        solve();    }\xa0\treturn 0;}\xa0\xa0']",,,"['dp', 'greedy', 'hashing', 'implementation']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Card Pairing.json,https://codeforces.com//blog/entry/129022,It s pretty obvious that every time we have a pair of equal cards in hand we should play one of these pairs If you re interested in a formal proof please read the paragraph in italic otherwise skip it Whenever we have a pair of equal cards we will always play it at some moment and earn a coin and it does not matter in which order we play different pairs So we have to make a meaningful choice about which cards we play only when all cards in our hand are different In the ideal situation if there are cards of type we want to earn coins by playing these cards But whenever we play only one card of type and there is an odd number of cards of type left both in hand and in deck we lose a coin because the number of pairs we can make decreases by Let s calculate the answer as the maximum possible number of pairs we can form equal to minus the minimum number of coins we lose in such a way Since we play a pair when we have at least one pair we can lose coins only when all cards in our hand are different So let s try to use a dynamic programming of the form is the minimum number of coins we could lose when we have drawn first cards from the deck and all cards in our hand are different Let s analyze the transitions of this dynamic programming When transitioning out of we can iterate on the pair of cards we play since we consider the situation when all cards in our hand are different we can play any pair of different cards for each of these two cards check if we lose a coin by playing them and try to find the next moment when all cards in our hand will be different or update the answer if there is no such moment However when implemented naively it is too slow might take up to We can use the following optimizations to improve it this is one of my favorite techniques Let s assign each card type a random bit number let it be for type Then let be the XOR of the numbers assigned to the first cards in the deck Suppose we are considering transitions from we try to play cards of type and when will be the next moment when we have all types of cards If this moment is then we need to take an odd number of cards of type and from moment to moment and an even number of cards for all other types So we can see that and this allows us to locate the next moment when we have different cards more easily in or even we have up to pairs of cards we can play from each state but only different states we can go into and no two transitions lead to the same state Let s try to make only transitions from each state When considering a state we can split all cards into two types the ones that make us lose a coin when we play them group and all the others group First let s try to play two cards from the group if we find a combination of them such that after playing it we never have different cards in our hand because this transition updates the answer directly without any increases Otherwise perform all transitions with pairs of cards from group and try to play a pair of cards from different groups If we find a combination that updates the answer directly we again can stop considering transitions the next transitions we use won t be more optimal And then we do the same with transitions where we use a pair of cards of group This way we will consider at most transitions from each state Combining these two optimizations results in a solution in or but there are other optimizations you can try 
https://codeforces.com//contest/1999/problem/E,2800023,E,1999E,1999,E. Triple Operations,On the board Ivy wrote down all integers from l to r inclusive In an operation she does the following pick two numbers x and y on the board erase them and in their place write the numbers 3x and lfloor frac y 3 rfloor Here lfloor bullet rfloor denotes rounding down to the nearest integer What is the minimum number of operations Ivy needs to make all numbers on the board equal 0 We have a proof that this is always possible ,"['/*Though leaves are many , the root is one.Through all the lying days of my youthI swayed my leaves and flowers in the sun.Now I may wither into the truth.\t  \t  \t- William Butler Yeats*///#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2"")#include<bits/stdc++.h>//#include<ext/pb_ds/assoc_container.hpp>using namespace std;//using namespace __gnu_pbds;const int inf=0x3f3f3f3f;const double eps=1e-6;const int mod=1e9+7;typedef long long ll;#ifndef LOCAL#define cerr if(0)cout#define eprintf(...) 0#else#define eprintf(...) fprintf(stderr, __VA_ARGS__)#endifinline string getstr(string &s,int l,int r){string ret="""";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}int modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}inline int Rand(){return rand()*32768+rand();}int lg[200005],sum[200005];int main(){\tlg[0]=0;lg[1]=1;\tfor(int i=2;i<=2e5;i++)lg[i]=lg[i/3]+1;\tfor(int i=1;i<=2e5;i++)sum[i]=sum[i-1]+lg[i];\tint T;cin>>T;\twhile(T--){\t\tint l,r;\t\tcin>>l>>r;\t\tcout<<lg[l]+sum[r]-sum[l-1]<<endl;\t}\treturn 0;}']",,,"['dp', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Triple Operations.json,https://codeforces.com//blog/entry/132373,Consider writing the numbers in ternary it is like binary but instead we use three digits and for clarity we will use digit in the solution instead of bit or trit In the operation we will add a 0 to the end of the number x and remove the last digit of y For example if x 8 and y 11 then in ternary the numbers are 223 and 1023 After the operation x 24 and y 3 and indeed in ternary they are 2203 and 103 This is because multiplying by 3 is multiplying by 103 and similarly dividing by 3 is like dividing by 103 This means that the total number of digits across all numbers does not change since we add one digit and remove one digit So how is it possible to make all numbers 0 Well there is one exception to the above rule when we use the operation with x 0 we add a 0 to the end of the number 0 but this added digit doesn t count because 3 0 0 This means that if we ever do the operation with x 0 then we will lose one digit total since x doesn t gain a digit but y loses a digit This means the solution is as follows first we make one of the numbers equal to 0 Then we will use this 0 to remove all the digits of all other numbers To use the fewest number of operations possible we should do the first step on the minimum number since it has the fewest digits Let f x denote the number of ternary digits in the number x actually f x log3 x 1 Then the first step takes f l operations since l is the smallest number in the range l r and the second step takes f l f r operations since we need to remove all the digits which is the total number of digits from l to r This means the answer for each test case is f l f l f r To find this sum quickly we can compute prefix sums on f so that the answer is simply f l psum r psum l 1 which takes O 1 time per test case with O n precomputation 
https://codeforces.com//contest/1714/problem/G,1490433,G,1714G,1714,G. Path Prefixes,You are given a rooted tree It contains n vertices which are numbered from 1 to n The root is the vertex 1 Each edge has two positive integer values Thus two positive integers a j and b j are given for each edge Output n 1 numbers r 2 r 3 dots r n where r i is defined as follows Consider the path from the root vertex 1 to i 2 le i le n Let the sum of the costs of a j along this path be A i Then r i is equal to the length of the maximum prefix of this path such that the sum of b j along this prefix does not exceed A i Consider an example In this case r 2 0 since the path to 2 has an amount of a j equal to 5 only the prefix of this path of length 0 has a smaller or equal amount of b j r 3 3 since the path to 3 has an amount of a j equal to 5 9 5 19 the prefix of length 3 of this path has a sum of b j equal to 6 10 1 17 the number is 17 le 19 r 4 1 since the path to 4 has an amount of a j equal to 5 9 14 the prefix of length 1 of this path has an amount of b j equal to 6 this is the longest suitable prefix since the prefix of length 2 already has an amount of b j equal to 6 10 16 which is more than 14 r 5 2 since the path to 5 has an amount of a j equal to 5 9 2 16 the prefix of length 2 of this path has a sum of b j equal to 6 10 16 this is the longest suitable prefix since the prefix of length 3 already has an amount of b j equal to 6 10 1 17 what is more than 16 r 6 1 since the path up to 6 has an amount of a j equal to 2 the prefix of length 1 of this path has an amount of b j equal to 1 r 7 1 since the path to 7 has an amount of a j equal to 5 3 8 the prefix of length 1 of this path has an amount of b j equal to 6 this is the longest suitable prefix since the prefix of length 2 already has an amount of b j equal to 6 3 9 which is more than 8 r 8 2 since the path up to 8 has an amount of a j equal to 2 4 6 the prefix of length 2 of this path has an amount of b j equal to 1 3 4 r 9 3 since the path to 9 has an amount of a j equal to 2 4 1 7 the prefix of length 3 of this path has a sum of b j equal to 1 3 3 7 ,"['/*\nDiv 3, I literally don\'t care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=2e5+5,mod=1e9+7;\nll n,c,k,a[N],b[N],g[N][21],p[N],h[N];\nll s[N],t[N];\nvector<ll> ke[N];\nvoid dfs (ll u){\n    rv(v,ke[u]){\n        h[v]=h[u]+1;\n        s[v]=s[u]+a[v];\n        t[v]=t[u]+b[v];\n        dfs(v);\n    }\n}\nvoid prep(){\n    rep(i,1,19)\n    rep(j,1,n) g[j][i]=g[g[j][i-1]][i-1];\n}\nll par (ll u, ll h){\n    rep(i,0,19) if (h&(1<<i)) u=g[u][i];\n    return u;\n}\nvoid solo()\n{\n   cin>>n;\n   rep(i,2,n){\n       cin>>p[i]>>a[i]>>b[i];\n       ke[p[i]].pb(i);\n       g[i][0]=p[i];\n   }\n   prep();\n   dfs(1);\n   rep(i,2,n){\n       ll l=0,r=h[i],res=0;\n       while (l<=r){\n           ll mid=(l+r)/2;\n           if (t[par(i,mid)]<=s[i]) res=mid,r=mid-1;\n           else l=mid+1;\n       }\n       res=h[i]-res;\n       cout<<res<<"" "";\n   }\n   rep(i,0,n)\n   rep(j,0,20) g[i][j]=0;\n   rep(i,1,n) ke[i].clear(),h[i]=0;\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']",,,"['binary search', 'data structures', 'dfs and similar', 'trees']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Path Prefixes.json,https://codeforces.com//blog/entry/105549,Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting 
https://codeforces.com//contest/1179/problem/C,361546,C,1179C,1179,C. Serge and Dining Room,Serge came to the school dining room and discovered that there is a big queue here There are m pupils in the queue He s not sure now if he wants to wait until the queue will clear so he wants to know which dish he will receive if he does As Serge is very tired he asks you to compute it instead of him Initially there are n dishes with costs a 1 a 2 ldots a n As you already know there are the queue of m pupils who have b 1 ldots b m togrogs respectively pupils are enumerated by queue order i e the first pupil in the queue has b 1 togrogs and the last one has b m togrogs Pupils think that the most expensive dish is the most delicious one so every pupil just buys the most expensive dish for which he has money every dish has a single copy so when a pupil has bought it nobody can buy it later and if a pupil doesn t have money for any dish he just leaves the queue so brutal capitalism But money isn t a problem at all for Serge so Serge is buying the most expensive dish if there is at least one remaining Moreover Serge s school has a very unstable economic situation and the costs of some dishes or number of togrogs of some pupils can change More formally you must process q queries change a i to x It means that the price of the i th dish becomes x togrogs change b i to x It means that the i th pupil in the queue has x togrogs now Nobody leaves the queue during those queries because a saleswoman is late After every query you must tell Serge price of the dish which he will buy if he has waited until the queue is clear or 1 if there are no dishes at this point according to rules described above ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=2200*1007;\nconst int n1=(1<<20);\n\nint n, m;\n\nint ta[nax];\nint tb[nax];\n\nint narz[nax];\nint pod[nax];\n\nint daj(int v)\n{\n\treturn narz[v]+pod[v];\n}\n\nvoid upd(int v)\n{\n\tpod[v]=max(daj(v*2), daj(v*2+1));\n}\n\nvoid pisz(int v, int a, int b, int graa, int grab, int w)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tnarz[v]+=w;\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tpisz((v<<1), a, (a+b)>>1, graa, grab, w);\n\tpisz((v<<1)^1, (a+b+2)>>1, b, graa, grab, w);\n\tupd(v);\n}\n\nint szuk(int v, int a, int b, int wie)\n{\n\tif (a==b)\n\t\treturn a;\n\twie-=narz[v];\n\tif (daj(v*2+1)>wie)\n\t\treturn szuk((v<<1)^1, (a+b+2)>>1, b, wie);\n\treturn szuk((v<<1), a, (a+b)>>1, wie);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &ta[i]);\n\t\tpisz(1, 1, n1, 1, ta[i], 1);\n\t}\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tscanf(""%d"", &tb[i]);\n\t\tpisz(1, 1, n1, 1, tb[i], -1);\n\t}\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--)\n\t{\n\t\tint typ, a, b;\n\t\tscanf(""%d%d%d"", &typ, &a, &b);\n\t\tif (typ==1)\n\t\t{\n\t\t\tpisz(1, 1, n1, 1, ta[a], -1);\n\t\t\tta[a]=b;\n\t\t\tpisz(1, 1, n1, 1, ta[a], 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpisz(1, 1, n1, 1, tb[a], 1);\n\t\t\ttb[a]=b;\n\t\t\tpisz(1, 1, n1, 1, tb[a], -1);\n\t\t}\n\t\tif (daj(1)<=0)\n\t\t\tprintf(""-1\\n"");\n\t\telse\n\t\t\tprintf(""%d\\n"", szuk(1, 1, n1, 0));\n\t}\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'graph matchings', 'greedy', 'implementation', 'math', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Serge and Dining Room.json,https://codeforces.com//blog/entry/67891,The main idea of the task is that the answer is minimal which satisfies the condition that the number of dishes with cost is strictly more than the number of pupils who have more than togrogs It can be proved using the fact that we can change every neighbor pair for pupils and we don t change the final set of dishes Exact prove is left as an exercise Now to find the answer we can use a segment tree that maintains a balance between the number of dishes and the number of pupils for all suffices of values Now change query transforms to add in the segment tree the answer should be found searching the last element which is less than standard descent in the segment tree Complexity is 
https://codeforces.com//contest/1487/problem/E,897751,E,1487E,1487,E. Cheap Dinner,Ivan wants to have a good dinner A good dinner should consist of a first course a second course a drink and a dessert There are n 1 different types of first courses Ivan can buy the i th of them costs a i coins n 2 different types of second courses the i th of them costs b i coins n 3 different types of drinks the i th of them costs c i coins and n 4 different types of desserts the i th of them costs d i coins Some dishes don t go well with each other There are m 1 pairs of first courses and second courses that don t go well with each other m 2 pairs of second courses and drinks and m 3 pairs of drinks and desserts that don t go well with each other Ivan wants to buy exactly one first course one second course one drink and one dessert so that they go well with each other and the total cost of the dinner is the minimum possible Help him to find the cheapest dinner option ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 150001; //check the limits, dummy\n\nvoid solve() {\n\n    int N[4]; F0R(i, 4) cin >> N[i];\n    ll A[4][MX]; F0R(i, 4) F0R(j, N[i]) cin >> A[i][j];\n    vector<set<int>> graph[3];\n    F0R(i, 3) {\n        graph[i] = vector<set<int>>(N[i+1]);\n        int M; cin >> M;\n        F0R(j, M) {\n            int X, Y; cin >> X >> Y; X--; Y--; graph[i][Y].ins(X);\n        }\n    }\n\n    set<pl> cost[4];\n    F0R(i, N[0]) cost[0].ins({A[0][i], i});\n    FOR(i, 1, 4) {\n        F0R(j, N[i]) {\n            auto it = cost[i-1].begin();\n            while (it != cost[i-1].end() && graph[i-1][j].count(it->s)) {\n                it++;\n            }\n            if (it != cost[i-1].end()) {\n                cost[i].ins({it->f + A[i][j], j});\n            }\n        }\n    }\n    if (sz(cost[3]) == 0) {\n        cout << -1 << nl;\n    } else {\n        cout << cost[3].begin()->f << nl;\n    }\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['brute force', 'data structures', 'graphs', 'greedy', 'implementation', 'sortings', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Cheap Dinner.json,https://codeforces.com//blog/entry/87873,The main solution is dynamic programming let for every possible dish be the minimum cost to assemble a prefix of a dinner ending with the dish here can be a dish of any type first course second course drink or dessert Then the answer to the problem is the minimum value among all desserts The number of transitions in this dynamic programming is too big since for example when transitioning from first courses to second courses we need to check options To speed this up we need some sort of data structure built over the values of for all first courses that allows to recalculate for a second course quickly There are two main approaches to this build any version of RMQ over the values of dynamic programming for the first courses Then when we want to calculate the answer for some second course sort all types of first courses which don t go well with it and make several RMQ queries to find the minimum value over all non forbidden first courses store all values of in a data structure that supports adding an element deleting an element and finding the minimum element this DS should allow duplicate elements as well When we want to calculate the answer for some second course remove all values of corresponding to the first courses that don t go well with it from the data structure query the minimum in it and insert the removed elements back The same approach can be used to advance from second courses to drinks and from drinks to desserts you can even use the same code in a for loop with iterations so the resulting solution is actually short and simple 
https://codeforces.com//contest/987/problem/B,186076,B,987B,987,B. High School  Become Human,Year 2118 Androids are in mass production for decades now and they do all the work for humans But androids have to go to school to be able to solve creative tasks Just like humans before It turns out that high school struggles are not gone If someone is not like others he is bullied Vasya 8800 is an economy class android which is produced by a little known company His design is not perfect his characteristics also could be better So he is bullied by other androids One of the popular pranks on Vasya is to force him to compare x y with y x Other androids can do it in milliseconds while Vasya s memory is too small to store such big numbers Please help Vasya Write a fast program to compare x y with y x for Vasya maybe then other androids will respect him ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint p(int x, int y) {\n\tint r=1;\n\twhile (y--)\n\t\tr*=x;\n\treturn r;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tint x, y;\n\tcin >> x >> y;\n\tif (x == y || (x*1ll*y == 8 && x+y == 6)) {\n\t\tcout << ""="";\n\t} else if (min(x, y) >= 3) {\n\t\tif (x > y) {\n\t\t\tcout << ""<"";\n\t\t} else {\n\t\t\tcout << "">"";\n\t\t}\n\t} else if (x == 2 && y == 3) {\n\t\tcout << ""<"";\n\t} else if (x == 3 && y == 2) {\n\t\tcout << "">"";\n\t} else if (min(x, y) == 1) {\n\t\tcout << (x < y ? ""<"" : "">"");\n\t} else if (min(x, y) == 2) {\n\t\tcout << (x < y ? "">"" : ""<"");\n\t}\n}']",,,['math'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. High School  Become Human.json,https://codeforces.com//blog/entry/59758,We need to compare x y with y x Let s take logarithms of both sides Now we need to compare y ln x with x ln y If you will compare this numbers with appropriate epsilon it will get AC but let s analyze a bit more and get solution in integers Let s divide both sides by xy now we need to compare frac ln x x with frac ln y y That s the values of some function f x frac ln x x taken in two points Let s take a closer look on this function You can take derivative or just look at the plot at WolframAlpha It s clear that this function have maximum at point e and it is increasing on 1 e and decreasing on e infty Considering only integer points f 1 0 f 3 is maximal f 2 f 4 because 2 4 4 2 16 and values in points greater than 4 are decreasing but always positive So the order of x from larger f x to smaller f x is 3 2 4 5 6 ldots infty 1 
https://codeforces.com//contest/1680/problem/E,1398259,E,1680E,1680,E. Moving Chips,You are given a board of size 2 times n 2 rows n columns Some cells of the board contain chips The chip is represented as and an empty space is represented as It is guaranteed that there is at least one chip on the board In one move you can choose chip and move it to any adjacent by side cell of the board if this cell is inside the board It means that if the chip is in the first row you can move it left right or down but it shouldn t leave the board Same if the chip is in the second row you can move it left right or up If the chip moves to the cell with another chip the chip in the destination cell disappears i e our chip captures it Your task is to calculate the number of moves required to leave one chip on the board You have to answer t independent test cases ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<string> s(2);\n\tfor(string& x : s) cin >> x;\n\tvector<int> dp(4, 1e9);\n\tdp[3] = 0;\n\t// e1, e2, conn\n\tint last_cell = 0;\n\tint first_cell = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[0][i] == '*' || s[1][i] == '*'){\n\t\t\tlast_cell = i;\n\t\t\tif(first_cell == -1) first_cell = i;\n\t\t}\n\t}\n\tfor(int i = first_cell; i <= last_cell; i++){\n\t\tvector<int> ndp(4, 1e9);\n\t\tfor(int g = 0; g < 4; g++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tif((g & a) == 0) continue;\n\t\t\t\tif(!(a & 1) && s[0][i] == '*') continue;\n\t\t\t\tif(!(a & 2) && s[1][i] == '*') continue;\n\t\t\t\tndp[a] = min(ndp[a], dp[g] + __builtin_popcount(a));\n\t\t\t}\n\t\t}\n\t\tdp = ndp;\n\t}\n\tint ans = 1e9;\n\tfor(int x : dp){\n\t\tans = min(ans, x);\n\t}\n\tcout << (ans - 1) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]",,,"['bitmasks', 'dp', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Moving Chips.json,https://codeforces.com//blog/entry/102852,Firstly I want to say a few words about the difficulty of this problem Till the last moment we didn t know easy to prove and easy to write solutions so we decided that this is a good problem E But now we realized it is a lot easier than we expected Now let s talk about the solution At the beginning let s remove redundant columns from the beginning and from the end i e columns without chips and change the value correspondingly Now let be if is and otherwise This array needed to make the implementation easier Let s calculate the dynamic programming where is the index of the last processed column and is the number of the row where our chip is standing This seems a bit suspicious why we can calculate such a dynamic programming so let s explain some things about it It can be shown that in the optimal answer there will be some column where the last move happens And if the number of this column is then all chips to the left of will move only to the right and all chips to the right of will move only to the left Actually we can always consider that is the last column Consider paths of two chips that will survive till the last move The first chip is to the left of and will move only to the right and the second one is to the right of and will move only to the left Then we can replicate the path of the second chip in the reverse order using the first chip So the second chip can stay still until the last move In the optimal answer it is always better to have exactly one chip in the current column because moving two chips to the right is always worse than just eat one of them and move the remaining one Initial states of are except the values of the first column For the first column and The answer will be Okay how to make transitions from For all from to let s consider four cases here we need one move to go to the next column and probably one more move to delete the figure in the second row in the column So the transition seems like same as the previous transition because the cost of this transition is always the distance between these cells is we just go firstly to the right and then down to ensure that we eat the figure in the first row So the transition is same as the previous transition Time complexity 
https://codeforces.com//contest/403/problem/C,7185,C,403C,403,C. Strictly Positive Matrix,You have matrix of size Let s number the rows of the matrix from to from top to bottom let s number the columns from to from left to right Let s use to represent the element on the intersection of the th row and the th column Matrix meets the following two conditions for any numbers the following inequality holds Matrix is if for any numbers the inequality holds You task is to determine if there is such integer that matrix is strictly positive ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\ninline void die(int a) {\n\tif (!a) printf(""NO\\n""); else\n\t\tprintf(""YES\\n"");\n\texit(0);\n}\nint a, b, c, d, n, m, k;\nbool sm[2002][2002];\nbool used[2002];\nint dfs(int v) {\n\tif (used[v]) return 0;\n\tused[v] = 1;\n\tint ans = 1;\n\trept(i, n) {\n\t\tif (sm[v][i]) ans += dfs(i);\n\t}\n\treturn ans;\n}\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\n\tscanf(""%d"", &n);\n\trept(i, n) {\n\t\trept(j, n) {\n\t\t\tscanf(""%d"", &a);\n\t\t\tif (a) sm[i][j] = 1;\n\t\t}\n\t}\n\n\tC(used);\n\tif (dfs(0) != n) die(0);\n\tC(used);\n\trept(i, n) {\n\t\trept(j, i) {\n\t\t\tswap(sm[i][j], sm[j][i]);\n\t\t}\n\t}\n\tif (dfs(0) != n) die(0);\n\tdie(1);\n}']",,,"['graphs', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Strictly Positive Matrix.json,https://codeforces.com//blog/entry/10972,Let s look at the matrix as a connectivity matrix of some graph with n vertices Moreover if then we have directed edge in the graph between nodes Otherwise if that graph does not contains directed edge between pair of nodes Let What does means is the number of paths of length exactly in our graph from vertex to vertex Let is an integer such that That is we have a loop in the graph So if from the vertex achievable all other vertexes and vice versa from all other vertices reachable vertex then the answer is otherwise the answer is If reachability is missing it is clear that for any If reachability there we will be able to reach self loop use self loop to twist and after that we will go to some another vertex 
https://codeforces.com//contest/2014/problem/E,2892477,E,2014E,2014,E. Rendez-vous de Marian et Robin,The travel network is represented as n vertices numbered from 1 to n and m edges The i th edge connects vertices u i and v i and takes w i seconds to travel all w i are even Marian starts at vertex 1 Market and Robin starts at vertex n Major Oak In addition h of the n vertices each has a single horse available Both Marian and Robin are capable riders and could mount horses in no time i e in 0 seconds Travel times are halved when riding Once mounted a horse lasts the remainder of the travel Meeting must take place on a vertex i e not on an edge Either could choose to wait on any vertex Output the earliest time Robin and Marian can meet If vertices 1 and n are disconnected output 1 as the meeting is cancelled ,"[""#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 4e5 + 5;const int mod = 1e9 + 7;int n, m, h, a[N], dis1[N], dis2[N];vector<PII> e[N];bool vis[N];void solve(){    cin >> n >> m >> h;    for (int i = 1; i <= 2 * n; i++)        e[i].clear(), a[i] = 0, vis[i] = 0;    for (int i = 1; i <= h; i++)    {        int x;        cin >> x;        a[x] = 1;    }    for (int i = 1; i <= m; i++)    {        int u, v, w;        cin >> u >> v >> w;        if (a[u])            e[u].push_back({v + n, w / 2});        e[u].push_back({v, w});        e[u + n].push_back({v + n, w / 2});        if (a[v])            e[v].push_back({u + n, w / 2});        e[v].push_back({u, w});        e[v + n].push_back({u + n, w / 2});    }    fill(dis1 + 1, dis1 + 1 + 2 * n, 1e18);    fill(dis2 + 1, dis2 + 1 + 2 * n, 1e18);    priority_queue<array<int, 2>, vector<array<int, 2>>, greater<array<int, 2>>> q;    q.push({0, 1});    dis1[1] = 0;    while (!q.empty())    {        auto [d, u] = q.top();        q.pop();        if (vis[u])            continue;        vis[u] = 1;        for (auto [to, w] : e[u])        {            if (dis1[u] + w < dis1[to])            {                dis1[to] = dis1[u] + w;                q.push({dis1[to], to});            }        }    }    for (int i = 1; i <= 2 * n; i++)        vis[i] = 0;    q.push({0, n});    dis2[n] = 0;    while (!q.empty())    {        auto [d, u] = q.top();        q.pop();        if (vis[u])            continue;        vis[u] = 1;        for (auto [to, w] : e[u])        {            if (dis2[u] + w < dis2[to])            {                dis2[to] = dis2[u] + w;                q.push({dis2[to], to});            }        }    }    int ans = 1e18;    for (int i = 1; i <= n; i++)        ans = min(ans, max(min(dis1[i], dis1[i + n]), min(dis2[i + n], dis2[i])));    cout << (ans == 1e18 ? -1 : ans) << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}""]",,,"['dfs and similar', 'graphs', 'shortest paths']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Rendez-vous de Marian et Robin.json,https://codeforces.com/blog/entry/134093,This problem builds on the standard Dijkstra algorithm So please familiarise yourself with the algorithm if not already In Dijkstra algorithm a distance vector list is used to store travel times to all vertices here we need to double the vector list to store travel times to vertices arriving with and without a horse If a vertex has a horse then it s possible to transition from without horse to with horse there The Dijkstra algorithm is then run as standard What if a horse has already been taken by Marian when Robin arrives and vice versa Well the optimal solution would not require the second person to arrive to use the horse because the first to arrive could simply wait for the second to arrive giving an earlier meeting than whatever is possible if the second to arrive had to use the horse and go elsewhere Therefore for any vertex 1 horse is sufficient We run Dijkstra algorithm twice to find the fastest time Robin and Marian could reach any vertex i as tR i and tM i The earliest meeting time at a given vertex i is max tR i tM i and we need to check all vertices The time complexity is that of Dijkstra algorithm which in this problem is O nlogn 
https://codeforces.com//contest/1642/problem/B,1306239,B,1642B,1642,B. Power Walking,Sam is a kindergartener and there are n children in his group He decided to create a team with some of his children to play brawl go 2 Sam has n power ups the i th has type a i A child s strength is equal to the number of types among power ups he has For a team of size k Sam will distribute all n power ups to k children in such a way that each of the k children receives at least one power up and each power up is given to someone For each integer k from 1 to n find the sum of strengths of a team of k children Sam can get ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define inline __attribute((always_inline))\n\n#define cmax(x,y) x=max(x,y)\n#define cmin(x,y) x=min(x,y)\n#define eb emplace_back\n#define MP make_pair\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int,int> Pair;\n\ninline ll read(){\n\tll x=0,c; bool f=0;\n\tfor (;(c=getchar())<\'0\'||c>\'9\';f|=c==\'-\');\n\tfor (;c>=\'0\'&&c<=\'9\';c=getchar()) x=x*10+c-48;\n\treturn f?-x:x;\n}\n\n#define N 300005\n\nint n;\nint a[N];\n\nvoid init(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n}\n\nvoid solve(){\n\tsort(a+1,a+1+n);\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (a[i]!=a[i-1]) ans++;\n\tfor (int i=1;i<=ans;i++) printf(""%d "",ans);\n\tfor (int i=ans+1;i<=n;i++) printf(""%d "",i);\n\tputs("""");\n}\n\nint main(){\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tint cas=read();\n\tfor (;cas--;){\n\t\t//printf(""Case #%d: "",v);\n\t\tinit();\n\t\tsolve();\n\t}\n\treturn 0;\n}\n']",,,['greedy'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Power Walking.json,https://codeforces.com//blog/entry/100249,It is quite easy to understand that every multiset s power is at least 1 The final answer is at east the number of distict integers in the multiset It is possible to proof that the answer to the problem for is equal to where is the number of distinct integers If the number of distinct interest is equal to is is obvious that we can create multisets th multiset Will only contain integers which are equal to We can create multisets of size 1 The answer in this case is equal to If the number of distinct integers is at least we can divide the integers into groups in such way that for each all occurrences of are located in the same multiset The answer in this case is equal to In the first case the answer is in the second case Thus the answer is equal to 
https://codeforces.com//contest/1186/problem/A,364214,A,1186A,1186,A. Vus the Cossack and a Contest,Vus the Cossack holds a programming competition in which n people participate He decided to award them all with pens and notebooks It is known that Vus has exactly m pens and k notebooks Determine whether the Cossack can reward participants giving each of them at least one pen and at least one notebook ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=100005;\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    //freopen(""code.in"",""r"",stdin);\n    //freopen(""code.out"",""w"",stdout);\n    #endif\n    ll a,b,c;\n    cin>>a>>b>>c;\n    printf((b>=a && c>=a)?""Yes\\n"":""No\\n"");\n    return 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Vus the Cossack and a Contest.json,https://codeforces.com/blog/entry/68027,Since a pen and a notebook would be given to each participant the answer is if and only if and The answer is otherwise 
https://codeforces.com//contest/1440/problem/A,798720,A,1440A,1440,A. Buy the String,You are given four integers n c 0 c 1 and h and a binary string s of length n A binary string is a string consisting of characters 0 and 1 You can change any character of the string s the string should be still binary after the change You should pay h coins for each change After some changes possibly zero you want to buy the string To buy the string you should buy all its characters To buy the character 0 you should pay c 0 coins to buy the character 1 you should pay c 1 coins Find the minimum number of coins needed to buy the string ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tint n, c0, c1, h;\n\t\tcin >> n >> c0 >> c1 >> h;\n\t\tstring s; cin >> s;\n\n\t\tint o = 0, z = 0;\n\t\tfor (char c: s) {\n\t\t\to += (c == '1');\n\t\t\tz += (c == '0');\n\t\t}\n\n\t\tint ans = o*c1 + z*c0;\n\t\tfor (int one = 0; one <= s.size(); one++) {\n\t\t\tint zero = s.size() - one;\n\t\t\tans = min(ans, one*c1 + zero*c0 + h*abs(o - one));\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\t\n\treturn 0;\n}\n""]",,,"['implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Buy the String.json,https://codeforces.com//blog/entry/84731,We will consider each character seperately Look at the th character if it is originally a we can either change it to a and pay coins for this specific character or we can not change it and pay coins for it Since we want to pay as little as possible we take the minimum of these two So if the th character is a we will have to pay coins for it A similar logic can be used for the zeroes if the th character is a we will have to pay coins So we iterate over and for each character we add the required minimum to the sum depending on whether it s a or Time complexity 
https://codeforces.com//contest/1810/problem/D,1858189,D,1810D,1810,D. Climbing the Tree,The snails are climbing a tree The tree height is h meters and snails start at position 0 Each snail has two attributes a and b a b Starting from the 1 st day one snail climbs the tree like this during the daylight hours of the day he climbs up a meters during the night the snail rests and he slides down b meters If on the n th day the snail reaches position h for the first time that is the top of the tree he will finish climbing and we say that the snail spends n days climbing the tree Note that on the last day of climbing the snail doesn t necessarily climb up a meters in case his distance to the top is smaller than a Unfortunately you don t know the exact tree height h at first but you know that h is a positive integer There are q events of two kinds Event of type 1 a snail with attributes a b comes and claims that he spent n days climbing the tree If this message contradicts previously adopted information i e there is no tree for which all previously adopted statements and this one are true ignore it Otherwise adopt it Event of type 2 a snail with attributes a b comes and asks you how many days he will spend if he climbs the tree You can only give the answer based on the information you have adopted so far If you cannot determine the answer precisely report that You need to deal with all the events in order ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int q;\n    std::cin >> q;\n    \n    i64 lo = 1, hi = 1E18;\n    \n    while (q--) {\n        int t;\n        std::cin >> t;\n        \n        if (t == 1) {\n            int a, b, n;\n            std::cin >> a >> b >> n;\n            \n            i64 x, y;\n            if (n == 1) {\n                x = 1;\n                y = a;\n            } else {\n                x = 1LL * a * (n - 1) - 1LL * b * (n - 2) + 1;\n                y = 1LL * a * n - 1LL * b * (n - 1);\n            }\n            if (x <= hi && lo <= y) {\n                lo = std::max(lo, x);\n                hi = std::min(hi, y);\n                std::cout << 1 << "" "";\n            } else {\n                std::cout << 0 << "" "";\n            }\n        } else {\n            int a, b;\n            std::cin >> a >> b;\n            \n            i64 t1 = lo <= a ? 1LL : (lo - b + a - b - 1) / (a - b);\n            i64 t2 = hi <= a ? 1LL : (hi - b + a - b - 1) / (a - b);\n            \n            if (t1 == t2) {\n                std::cout << t1 << "" "";\n            } else {\n                std::cout << -1 << "" "";\n            }\n        }\n    }\n    std::cout << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['binary search', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Climbing the Tree.json,https://codeforces.com//blog/entry/114521,TutorialThe main idea is to that for each the possible is a interval We will show how to calculate that In the first days the snail will climb meters And in the daytime of the th day the snail will climb meters So after days the snail climbs at most meters which means Also the snail can not reach before days which means So is a special case where Now after each operation we can maintain a possible interval When a snail comes we let the new be where is the possible interval for the new snail If the new interval is empty we ignore this information otherwise adopt it Now let s focus on another problem for a fixed how to calculate the number of days the snail needs to climb We can solve the equation and get which means equals to Still special judge for where in this case Then for each query of type we just calculate the number of days we need for and If they are the same output that number Otherwise output 
https://codeforces.com//contest/779/problem/B,95636,B,779B,779,B. Weird Rounding,Polycarp is crazy about round numbers He especially likes the numbers divisible by In the given number of Polycarp wants to remove the least number of digits to get a number that is divisible by For example if in the number it is enough to delete a single digit In this case the result is that is divisible by Write a program that prints the minimum number of digits to be deleted from the given integer number so that the result is divisible by The result should not start with the unnecessary leading zero i e zero can start only the number which is required to be written as exactly one digit It is guaranteed that the answer exists ,"['#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <stack>\n#define sz size()\n#define pb push_back\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll exp(ll t,ll x){if(x==0) return 1;if(x==1) return t;if(x%2==1) return (t*exp((t*t)%mod,x/2))%mod;if(x%2==0) return exp((t*t)%mod,x/2);} \nll gcd(ll x,ll y){return x%y==0?y:gcd(y,x%y);}\nll lcm(ll x,ll y){return x*(y/gcd(x,y));}\nll bsum(ll u,ll b){return u<b?u:bsum(u/b,b)+u%b;}\nll prival(ll u,ll p){int cn=0;while(u%p==0){cn++;u=u/p;}return cn;}\nbool isprime(ll x){for(ll i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\nvoid YAY(void){cout<<""YES""<<endl;}\nvoid NAY(void){cout<<""NO""<<endl;}\nstring s;\nint cz, n, k;\nint main(void)\n{\n\tint i, j;\n\tcin>>s>>k;\n\tn=s.size();\n\tfor(i=0 ; i<n ; i++)\n\t{\n\t\tif(s[i]==\'0\')\n\t\t{\n\t\t\tcz++;\n\t\t}\n\t}\n\tif(cz>=k)\n\t{\n\t\tint cc=0;\n\t\tint ans=0;\n\t\tfor(i=n-1 ; i>=0 ; i--)\n\t\t{\n\t\t\tif(s[i]==\'0\')\n\t\t\t{\n\t\t\t\tcc++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(cc>=k)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tcout<<n-1;\n\t}\n\t\n}\n']",,,"['brute force', 'greedy']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Weird Rounding.json,https://codeforces.com//blog/entry/50724,To solve this problem we need to make zeroes in the end of number Let s look on the given number as on the string and iterate through it beginning from the end i e from the low order digit Let equals to the number of digits which we reviewed If the current digit does not equal to zero we need to increase the answer on one If became equal to and we reviewed not all digits we need to print the answer In the other case we need to remove from the string all digits except one which equals to zero if there are more than one such digit we left only one of them Such digit always exists because the problem statement guaranteed that the answer exists 
https://codeforces.com//contest/1926/problem/D,2485154,D,1926D,1926,D. Vlad and Division,Vladislav has n non negative integers and he wants to divide of them into several groups so that in any group any pair of numbers does not have matching bit values among bits from 1 st to 31 st bit i e considering the 31 least significant bits of the binary representation For an integer k let k 2 i denote the i th bit in its binary representation from right to left indexing from 1 For example if k 43 since 43 101011 2 then 43 2 1 1 43 2 2 1 43 2 3 0 43 2 4 1 43 2 5 0 43 2 6 1 43 2 7 0 43 2 8 0 dots 43 2 31 0 What is the minimum number of groups Vlad needs to achieve his goal Each number must fall into exactly one group ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve()\n{\n\tint n;\n\tcin>>n;\n\tint ans=0;\n\tmap<int,int>cnt;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tif(!cnt[x])\n\t\t{\n\t\t\tans++,cnt[((1<<31)-1)^x]++;\n\t\t//\tcnt[x]++;\n\t\t}\n\t\telse cnt[x]--;\n\t\t//if(!cnt[x]) ++ans, ++cnt[((1 << 31) - 1) ^ x];\n\t}\n\tcout<<ans<<""\\n"";\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t}\n\treturn 0;\n}']",,,"['bitmasks', 'greedy']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Vlad and Division.json,https://codeforces.com//blog/entry/126132,We can notice that a group contains either one or two numbers Now we check how many numbers we can pair together The condition that all bits in a pair differ is equivalent to the pair resulting in a number which has all bits set as when we XOR the numbers So we need to see the number of pairs for which their XOR is equal to As this is the number with all bits set Now we iterate through the numbers in order from left to right we check if we can pair the current number with some existing previous one We can check if the number can be paired with some previous one if we encountered the value of XOR in the past If we have we mark that value and the current value as taken and don t start a new group otherwise we start a new group and continue the process 
https://codeforces.com//contest/202/problem/A,1460,A,202A,202,A. LLPS,You are given string consisting of lowercase English letters only Find its lexicographically largest palindromic subsequence We ll call a non empty string a of string where is the length of string For example strings and are subsequences of string String is than string if either and or there exists such number that and Characters in the strings are compared according to their ASCII codes For example string is lexicographically larger than string and string is lexicographically larger than string String is a if it matches string In other words a string is a palindrome if it reads the same way from left to right and from right to left For example palindromic strings are and ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#ifndef LEEWINGS_DEBUG\n#define LEEWINGS_DEBUG 0\n#endif\n\n#define debug(x) if (LEEWINGS_DEBUG) cerr << #x << "" = "" << (x) << endl\n\n#define debug_line(a, n) do {                                                \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << ""["" << #n << ""]:"" << endl;                             \\\n        for (int i = 0; i < (n); i++) cerr << (a)[i] << "" "";                 \\\n        cerr << endl;                                                        \\\n    }                                                                        \\\n} while (0)\n\n#define debug_mat(a, n, m) do {                                              \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << ""["" << #n << ""]["" << #m ""]:"" << endl;                  \\\n        for (int i = 0; i < (n); i++) {                                      \\\n            for (int j = 0; j < (m); j++) cerr << (a)[i][j] << "" "";          \\\n            cerr << endl;                                                    \\\n        }                                                                    \\\n    }                                                                        \\\n} while(0)\n\ntypedef pair<int, int> pii;\ntypedef vector<int>::const_iterator vci;\ntypedef map<int, int>::const_iterator mci;\n\nconst int INF = 0x3f3f3f3f;\nconst long long LLINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1.0/0.0f;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n\ninline int LC(int x) { return x << 1; }\ninline int RC(int x) { return (x << 1) | 1; }\ninline bool eq0(double x) { return fabs(x) < eps; }\ninline bool eq(double x, double y) { return fabs(x - y) < eps; }\ninline bool ls(double x, double y) { return x + eps < y; }\ninline bool gr(double x, double y) { return x - eps > y; }\ninline bool greq(double x, double y) { return x + eps >= y; }\ninline bool lseq(double x, double y) { return x - eps <= y; }\ninline double fmax(double x, double y) { return gr(x, y) ? x : y; }\ninline double fmin(double x, double y) { return ls(x, y) ? x : y; }\n\ntemplate<class T> inline T sqr(T x) { return x * x; }\n\nint main()\n{\n    string s;\n    cin >> s;\n    char c = *max_element(s.begin(), s.end());\n    int cnt = count(s.begin(), s.end(), c);\n    while (cnt--) cout << c;\n    cout << endl;\n\n    return 0;\n}\n\n']",,,"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. LLPS.json,https://codeforces.com/blog/entry/4808,It s assumed that this problem can be solved just looking at the samples and without reading the statement itself Let s find the letter in the given string which comes last in the alphabet denote this letter by z If this letter occurs p times in the given string then the answer is string a consisting of letter z repeated p times Why is it so Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it s easy to understand that if some other subsequence b of the given string is lexicographically larger than a then string b should be longer than a and moreover a should be a prefix of b that is b should start with a But string b must be a palindrome therefore its last letter must be z In this case string b must contain more occurrences of letter z than the original string s does which is impossible as b is a subsequence of s Besides that the constraint on the length of the string was very low so the problem could be solved using brute force For every subsequence of the given string it s necessary to check whether it s a palindrome and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer The complexity of such a solution is O 2n n where n is the length of the string unlike the solution above with complexity O n 
https://codeforces.com//contest/1804/problem/G,1824146,G,1804G,1804,G. Flow Control,Raj has a single physical network line that connects his office to the Internet This line bandwidth is b bytes per millisecond There are n users who would like to use this network line to transmit some data The i th of them will use the line from millisecond s i to millisecond f i inclusive His initial data rate will be set to d i That means he will use data rate equal to d i for millisecond s i and then it will change according to the procedure described below The flow control will happen as follows Suppose there are m users trying to transmit some data via the given network line during millisecond x Denote as t i the data rate that the i th of these m users has at the beginning of this millisecond All t i are non negative integer values If m 0 i e there are no users trying to transmit data during this millisecond nothing happens If the sum of all t i is less than or equal to b each active user successfully completes his transmission the i th active user transmits t i bytes After that the data rate of each active user grows by 1 i e each t i is increased by 1 If the sum of all t i is greater than b the congestion occurs and no data transmissions succeed this millisecond at all If that happens each t i decreases twice i e each t i is replaced with lfloor frac t i 2 rfloor Raj knows all the values n b s i f i and d i he wants to calculate the total number of bytes transmitted by all the users in the aggregate ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    const int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    void half(int p, int l, int r) {\n        if (info[p].act == 0) {\n            return;\n        }\n        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {\n            apply(p, {-(info[p].min + 1) / 2});\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        half(2 * p, l, m);\n        half(2 * p + 1, m, r);\n        pull(p);\n    }\n    void half() {\n        half(1, 0, n);\n    }\n};\n\nconstexpr i64 inf = 1E18;\n\nstruct Tag {\n    i64 add = 0;\n    \n    void apply(Tag t) {\n        add += t.add;\n    }\n};\n\nstruct Info {\n    i64 min = inf;\n    i64 max = -inf;\n    i64 sum = 0;\n    i64 act = 0;\n    \n    void apply(Tag t) {\n        min += t.add;\n        max += t.add;\n        sum += act * t.add;\n    }\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.min = std::min(a.min, b.min);\n    c.max = std::max(a.max, b.max);\n    c.sum = a.sum + b.sum;\n    c.act = a.act + b.act;\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b;\n    std::cin >> n >> b;\n    \n    i64 ans = 0;\n    \n    std::vector<std::array<int, 3>> events;\n    for (int i = 0; i < n; i++) {\n        int s, f, d;\n        std::cin >> s >> f >> d;\n        s--;\n        events.push_back({s, i, d});\n        events.push_back({f, i, 0});\n    }\n    \n    std::sort(events.begin(), events.end());\n    \n    LazySegmentTree<Info, Tag> seg(n);\n    int cur = 0;\n    for (auto [t, i, d] : events) {\n        Info last = {-1, -1, -1, -1};\n        i64 lastc = -1;\n        i64 lastans = -1;\n        while (cur < t) {\n            auto info = seg.rangeQuery(0, n);\n            if (info.act == 0) {\n                cur = t;\n                break;\n            }\n            if (info.min == last.min && info.max == last.max && info.sum == last.sum && info.max - info.min <= 1) {\n                i64 dt = cur - lastc;\n                i64 dans = ans - lastans;\n                i64 phase = (t - cur) / dt;\n                cur += phase * dt;\n                ans += phase * dans;\n            }\n            last = info;\n            lastc = cur;\n            lastans = ans;\n            i64 u = (b - info.sum + info.act) / info.act;\n            if (u > t - cur) {\n                u = t - cur;\n            }\n            if (u < 0) {\n                u = 0;\n            }\n            cur += u;\n            ans += (info.sum + info.sum + info.act * (u - 1)) * u / 2;\n            seg.rangeApply(0, n, {u});\n            if (t == cur) {\n                break;\n            }\n            cur += 1;\n            seg.half();\n        }\n        if (d != 0) {\n            seg.modify(i, {d, d, d, 1});\n        } else {\n            seg.modify(i, Info());\n        }\n    }\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}\n']",,,"['data structures', 'dsu', 'implementation']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Flow Control.json,https://codeforces.com//blog/entry/113830,The problem is inspired by AIMD algorithm for TCP flow and congestion control The key solution idea comes from a real world networking every time the congestion happens the difference between the maximum active t i and the minimum active t i halves Thus if all users were to start and to stop at the same time there will be no more than two distinct values of t i in just log C congestions Here C stands for the upper limit on values d i and b Let s store all the unique values of active t i in a hash map together with a supplementary information Information we need is the sum of all t i right after the last congestion the number of milliseconds past since the last congestion and so on Using this information we can compute the time of the next congestion in O 1 The processing of one congestion will work in O d time where d is the current number of distinct values of t i We also need to be able to merge two groups when congestion happens this information will be used to process delete operations That can be done using DSU with path compression and doesn t add much to the total complexity We will call the period between two consecutive congestions an epoch There are epochs of two types general and repetitive A repetitive epoch is an epoch that goes in exactly the same way as the previous epoch That means no new users appear no users turn off the epoch starts with exactly the same values of t i as the previous epoch and gets to exactly the same state after the closest congestion happens All other epochs are called general Though the total number of epochs can be large up to max f i there will be no more than n log C general epochs Indeed if no users start or finish data transmission the process will converge to a repetitive epoch in no more than log C congestions Here C is the upper bound for b and values d i Repetitive epochs contain no more than two distinct value of t i they can be identified and simulated efficiently How do we simulate general epochs There is no need to this efficiently doing this in O d d is the number of distinct t i will be efficient enough One can prove this using amortized analysis with the following potential function Let d be the number of distinct values of t i and t 0 t 1 ldots t d 1 be the sequence of these values P epoch d sum i 0 d 2 log t i 1 t i The total complexity is O n log C n log n 
https://codeforces.com//contest/94/problem/A,492,A,94A,94,A. Restoring Password,Igor K always used to trust his favorite Kashpirovsky Antivirus That is why he didn t hesitate to download the link one of his groupmates sent him via QIP Infinium The link was said to contain some real funny stuff about swine influenza The antivirus had no objections and Igor K run the flash application he had downloaded Immediately his QIP Infinium said invalid login password Igor K entered the ISQ from his additional account and looked at the info of his main one His name and surname changed to H1N1 and Infected correspondingly and the Additional Information field contained a strange looking binary code characters in length consisting of zeroes and ones I ve been hacked thought Igor K and run the Internet Exploiter browser to quickly type his favourite search engine s address Soon he learned that it really was a virus that changed ISQ users passwords Fortunately he soon found out that the binary code was actually the encrypted password where each group of characters stood for one decimal digit Accordingly the original password consisted of decimal digits Help Igor K restore his ISQ account by the encrypted password and encryption specification ,"['#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n//\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define MP make_pair\n#define VI vector<int>\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n//\n#define rep(i,b) for(int i=(0);i<(b);++i)\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define fore(a,b) for(__typeof((b).begin()) a = (b).begin();a!=(b).end();++a)\n#define vv vector\n#define pb push_back\n#define ll long long\n#define ld long double\n#define ss(a) (int)(a).size()\n#define all(x) (x).begin(),(x).end()\n#define clr(x,a) memset(x,a,sizeof(x))\n#define vi vv<int>\n#define vs vv<string>\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\n\nint cond = (ll)1;\n#define db(x) { if (cond > 0) { cond--; rep (xxx, 1) cerr << __LINE__ << "" "" << #x << "" "" << x << endl; cerr.flush(); } }\n\nvoid _main() {\n    string in;\n    cin>>in;\n    string let[10];\n    rep (i, 10) {\n        cin>>let[i];\n        db(let[i]);\n    }\n    rep (i, 8) {\n        rep (j, 10) {\n            int ok = 0;\n            rep (g, 10) if (in[i*10 + g] != let[j][g]) ok++;\n            db(i<<"" ""<<j<<"" ""<<ok);\n            if (ok == 0) {\n                db(i<<"" ""<<j);\n                cout << j;\n                break;\n            }\n        }\n    }\n    cout << endl;\n}\n\nint main(int argc, char ** argv) {\n    string p = ""../gcj/source/"" + string("""") + argv[0][strlen(argv[0])-1];\n//    if (argc >= 2 && strcmp(argv[1], ""q"") != 0) { freopen(argv[1],""r"",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], ""1n"") == 0) { freopen(""1.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""2n"") == 0) { freopen(""2.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""3n"") == 0) { freopen(""3.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""4n"") == 0) { freopen(""4.in"",""r"",stdin);}\n    rep (i, argc) if (strcmp(argv[i], ""5n"") == 0) { freopen(""5.in"",""r"",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], ""s0"") == 0) { freopen((p + ""-small-0.in"").c_str(),""r"",stdin);freopen((p + ""-small-0.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""s1"") == 0) { freopen((p + ""-small-1.in"").c_str(),""r"",stdin);freopen((p + ""-small-1.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""s2"") == 0) { freopen((p + ""-small-2.in"").c_str(),""r"",stdin);freopen((p + ""-small-2.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""l0"") == 0) { freopen((p + ""-large-0.in"").c_str(),""r"",stdin);freopen((p + ""-large-0.out"").c_str(),""w"",stdout); }\n    rep (i, argc) if (strcmp(argv[i], ""q"") == 0) cond = 1 << 30;\n    _main();\n    return 0;\n}\n\n']",,,"['implementation', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Restoring Password.json,https://codeforces.com//blog/entry/2208,Password was very easy to restore You should just iterate over groups of 10 characters in the first string and over all codes Then if some number s code is equal to the group print that number 
https://codeforces.com//contest/1701/problem/D,1455052,D,1701D,1701,D. Permutation Restoration,Monocarp had a permutation a of n integers 1 2 n a permutation is an array where each element from 1 to n occurs exactly once Then Monocarp calculated an array of integers b of size n where b i left lfloor frac i a i right rfloor For example if the permutation a is 2 1 4 3 then the array b is equal to left left lfloor frac 1 2 right rfloor left lfloor frac 2 1 right rfloor left lfloor frac 3 4 right rfloor left lfloor frac 4 3 right rfloor right 0 2 0 1 Unfortunately the Monocarp has lost his permutation so he wants to restore it Your task is to find a permutation a that corresponds to the given array b If there are multiple possible permutations then print any of them The tests are constructed in such a way that least one suitable permutation exists ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:40:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> b(n);\n    vector<int> L(n), R(n);\n    for (int i = 0; i < n; i++) {\n      cin >> b[i];\n      // floor((i + 1) / a[i]) = b[i]\n      // b[i] <= (i + 1) / a[i] < b[i] + 1\n      // a[i] <= (i + 1) / b[i]\n      // a[i] > (i + 1) / (b[i] + 1)\n      R[i] = (b[i] == 0 ? n : (i + 1) / b[i]);\n      L[i] = (i + 1) / (b[i] + 1) + 1;\n    }\n    vector<vector<int>> at(n + 1);\n    for (int i = 0; i < n; i++) {\n      at[L[i]].push_back(i);\n    }\n    set<pair<int, int>> s;\n    vector<int> p(n, -1);\n    for (int i = 1; i <= n; i++) {\n      for (int j : at[i]) {\n        s.emplace(R[j], j);\n      }\n      assert(!s.empty());\n      p[s.begin()->second] = i;\n      s.erase(s.begin());\n    }\n    for (int i = 0; i < n; i++) {\n      cout << p[i] << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']",,,"['binary search', 'data structures', 'greedy', 'math', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Permutation Restoration.json,https://codeforces.com//blog/entry/104671,We have for each we can rewrite this as follows or From here we can see that for each there is a segment of values that can be assigned to So we have to match each number from to with one of these segments To solve this problem we can iterate from to Let the current number be then it can be paired with a segment without a pair such that and the right bound is minimum among all such segments because it will be the first to end among these segments To do this it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound Before running this method you can sort the segments by their left border so they can be easily added to this set when we go from to we will need to insert all segments that begin with that s why it s convenient to have them sorted by their left border beforehand 
https://codeforces.com//contest/533/problem/A,26202,A,533A,533,A. Berland Miners,The biggest gold mine in Berland consists of caves connected by transitions The entrance to the mine leads to the cave number it is possible to go from it to any remaining cave of the mine by moving along the transitions The mine is being developed by the InMine Inc miners work for it Each day the corporation sorts miners into caves so that each cave has at most one miner working there For each cave we know the height of its ceiling in meters and for each miner we know his height also in meters If a miner s height doesn t exceed the height of the cave ceiling where he is then he can stand there comfortably otherwise he has to stoop and that makes him unhappy Unfortunately miners typically go on strike in Berland so InMine makes all the possible effort to make miners happy about their work conditions To ensure that no miner goes on strike you need make sure that no miner has to stoop at any moment on his way from the entrance to the mine to his cave in particular he must be able to stand comfortably in the cave where he works To reach this goal you can choose exactly one cave and increase the height of its ceiling by several meters However enlarging a cave is an expensive and complex procedure That s why InMine Inc asks you either to determine the minimum number of meters you should raise the ceiling of some cave so that it is be possible to sort the miners into the caves and keep all miners happy with their working conditions or to determine that it is impossible to achieve by raising ceiling in exactly one cave ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 500100\nint n;\nset<int> skal;\nmap<int,int> m;\nint h[MAX];\nvector<int> d[MAX];\nint k;\nint s[MAX];\nvector<int> prze;\nconst int MAXX = 1<<20;\nstruct node{\n  int sum,suf;\n  void licz(node a,node b){\n    sum = a.sum + b.sum;\n    suf = min(b.suf,a.suf + b.sum);\n  }\n  void add(int il){\n    sum += il;\n    suf = min(0,sum);\n  }\n}dp[MAXX*2 + 5];\nint add(int a,int il){\n  a += MAXX;\n  dp[a].add(il);\n  while(1){\n    a/=2;\n    dp[a].licz(dp[a*2],dp[a*2+1]);\n    if(a == 1)break;\n  }\n}\nvoid dfs(int nr,int oj,int war){\n  MI(war,h[nr]);\n  prze.PB(war);\n  R(i,(int)d[nr].size())\n    if(d[nr][i]!=oj)\n      dfs(d[nr][i],nr,war);\n}\nint wyn = -1;\nint nowa;\nint stara;\nvector<int> wart;\nvoid dfsw(int nr,int oj,int war){\n  MI(war,h[nr]);\n  if(war <= stara)return;\n  wart.PB(war);\n  R(i,(int)d[nr].size())\n    if(d[nr][i]!=oj)\n      dfsw(d[nr][i],nr,war);\n}\nvoid dfsn(int nr,int oj,int war){\n  MI(war,h[nr]);\n  if(war < nowa){\n    stara = h[nr];\n    h[nr] = nowa;\n    wart.clear();\n    dfsw(nr,oj,nowa);\n    R(i,wart.size())\n      add(wart[i],1);\n    add(stara,(int)wart.size() * -1);\n    if(dp[1].suf == 0){\n      MA(wyn,stara);\n    }\n    R(i,wart.size())\n      add(wart[i],-1);\n    add(stara,(int)wart.size());\n    h[nr] = stara;\n  }else{\n    R(i,(int)d[nr].size())\n      if(d[nr][i]!=oj)\n        dfsn(d[nr][i],nr,war);\n  }\n}\nvoid licz(){\n  dfsn(0,-1,1e9);\n}\nint wyc(int szu){\n  int nr=0;\n  for(int a:skal){\n    if(nr == szu)return a;\n    nr++;\n  }\n}\nmain(){\n  make(n);\n  R(i,n){\n    make(h[i]);\n    skal.insert(h[i]);\n  }\n  R(i,n-1){\n    int a,b;\n    make2(a,b);\n    a--;b--;\n    d[a].PB(b);\n    d[b].PB(a);\n  }\n  make(k);\n  R(i,k){\n    make(s[i]);\n    skal.insert(s[i]);\n  }\n  int nr=0;\n  for(int a:skal){\n    m[a] = nr;\n    nr++;\n  }\n  R(i,n)h[i] = m[h[i]];\n  R(i,k)s[i] = m[s[i]];\n  dfs(0,-1,nr);\n  R(i,prze.size())add(prze[i],1);\n  R(i,k)add(s[i],-1);\n  if(dp[1].suf == 0){\n    puts(""0"");\n    return 0;\n  }\n  sort(s,s+k,greater<int>());\n  sort(ALL(prze),greater<int>());\n  R(i,k){\n    if(prze[i] < s[i]){\n      nowa = s[i];\n      licz();\n      if(wyn == -1){\n        puts(""-1"");\n        return 0;\n      }\n      printf(""%d\\n"",wyc(nowa) - wyc(wyn));\n      return 0;\n    }\n  }\n  assert(0);\n}']",,,"['binary search', 'data structures', 'dfs and similar', 'greedy', 'trees']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Berland Miners.json,https://codeforces.com//blog/entry/17458,We can add n k miners with height 0 and it won t affect answer So we can assume that numbers of miners and caves are the same For every cave let s define ti as maximal possible height of miner working in cave i if we wouldn t change any cave We can calculate it from root to leaves with line ti min tfather hi Let s say we don t change anything We will try to assign all workers if it s possible or to do the best possible assignment otherwise the one where there are few free not occupied caves and they are high value ti is big I will say later why we want them to be high Formal definition you don t have to read the next paragraph For every assignment let s sort free caves by ti In the best assignment number of free caves is minimal possible And for every position in such a list free cave in the best assignment has value ti not lower than in any other assignment It can be proven that best possible assignment exists it s not so obvious though How to find the best possible assignment Let s sort caves ascending by ti and for every cave let s assign the tallest free miner who can work here It will give us the best possibble assignment Why Let s say we ve just made first bad decision different than in the best assignment It doesn t make sense to leave a cave empty if we can assign here someone So we put a worker somewhere and we won t be able to do assignment now we assumed that we ve just made bad decision From definition we put here tallest possible miner we know that we couldn t assign here taller guy Maybe we want to assign here shorter miner and this highest possible goes somewhere else But we can swap them and everything will be ok So there remains last option we don t want to put anyone here But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here To sum up it s ok to assign highest possible free worker with iterating over caves sorted by ti Almost the same sentences are the proof for other lemma If we want to have few free not assigned miners and we want them to be short it s optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave It works for every order of iterating over caves And every order gives us the same set of free miners but not necessarily the same set of free caves Why did we want free caves to be high Because to assign everyone we must change height of cave not higher than the lowest free cave Why In short otherwise that lowest free cave will remain free after running our assignment algo described above on new tree But we managed to find maximal possible height of lowest free cave Let s call this value as LIM And we know minimal set of free miners Changing height of cave i from a to something bigger does something only when ti a LIM And then in set of ti some changes happen There were caves blocked before by cave i so they had t equal to a These caves will have bigger t so in set of values t we have change e g from 5 5 5 to 7 10 8 a was equal to 5 Let s throw out miners from caves with changed tc maybe some of these caves were empty anyway If we can t assign free miners we found them before to new caves then assigning everything isn t possible Otherwise it is we assign them in these caves with changed t and there are some threw out miners But all of them were in caves with t a LIM so they are not higher than LIM And we know that every free cave has tfree LIM because LIM is height of lowest free cave So we can put them there Solution is to find result with binary search and to answer question can we assign miners to caves with changing one cave by at most D With our assignment algo we calculate optimal lowest free cave and set of free miners Then for every cave we try to increase its height by D if it had t not higher than LIM It s also important that checking change of every cave has amortized linear complexity If increasing height of cave A affects t of cave B below then later changing height of B does nothing B is blocked by A anyway 
https://codeforces.com//contest/674/problem/C,59814,C,674C,674,C. Levels and Regions,Radewoosh is playing a computer game There are levels numbered through Levels are divided into regions groups Each region contains some positive number of consecutive levels The game repeats the the following process If all regions are beaten then the game ends immediately Otherwise the system finds the first region with at least one non beaten level Let denote this region The system creates an empty bag for tokens Each token will represent one level and there may be many tokens representing the same level For each already beaten level in the region the system adds tokens to the bag tokens representing the th level Let denote the first non beaten level in the region The system adds tokens to the bag Finally the system takes a uniformly random token from the bag and a player starts the level represented by the token A player spends one hour and beats the level even if he has already beaten it in the past Given and values your task is to split levels into regions Each level must belong to exactly one region and each region must contain non empty consecutive set of levels What is the minimum possible expected number of hours required to finish the game ,"['#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef long double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000;\ni64 a[maxn], ps[maxn];\nld sinv[maxn], P[maxn];\nld dp[2][maxn];\n\nld conv(pair<ld, ld> a, pair<ld, ld> b) {\n    return a.fi * b.fi + a.se * b.se;\n}\n\nbool ccw(pair<ld, ld> a, pair<ld, ld> b, pair<ld, ld> c) {\n    return (b.first - a.first) * (c.se - a.second) - (c.first - a.first) * (b.second - a.second) > 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int n, k;\n    cin >> n >> k;\n    forn(i, n) {\n        cin >> a[i];\n        ps[i + 1] = ps[i] + a[i];\n        sinv[i + 1] = sinv[i] + 1.0 / a[i];\n        P[i + 1] = P[i] + 1.0 * ps[i + 1] / a[i];\n    }\n    forn(i, n + 1) dp[0][i] = 1e18;\n    dp[0][0] = 0.0;\n    forn(j, k) {\n//        cerr << j << \'\\n\';\n        forn(i, n + 1) dp[1][i] = 1e18;\n        vector< pair<ld, ld> > st;\n        st.pb(mp(ps[j], dp[0][j] + ps[j] * sinv[j] - P[j]));\n        int opt = 0;\n        for (int i = j + 1; i <= n; ++i) {\n            pair<ld, ld> x = mp(-sinv[i], 1.0);\n            while (opt + 1 < st.size() && conv(x, st[opt]) > conv(x, st[opt + 1])) ++opt;\n            dp[1][i] = P[i] + conv(x, st[opt]);\n//            cerr << dp[1][i] << \' \';\n            pair<ld, ld> z = mp(ps[i], dp[0][i] + ps[i] * sinv[i] - P[i]);\n            while (st.size() > 1 && (!ccw(st[st.size() - 2], st.back(), z))) st.pop_back();\n            st.pb(z);\n        }\n//        cerr << \'\\n\';\n        forn(i, n + 1) dp[0][i] = dp[1][i];\n    }\n    cout << (double)dp[0][n] << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",,,"['divide and conquer', 'dp']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Levels and Regions.json,https://codeforces.com//blog/entry/44754,When we repeat something and each time we have probability p to succeed then the expected number or tries is till we succeed How to calculate the expected time for one region low high For each i in some moment we will try to beat this level and then there will be S tlow tlow 1 ti tokens in the bag including ti tokens allowing us to beat this new level The probability to succeed is so the expected time is So in total we should sum up values for i j Ok we managed to understand the actual problem You can now stop and try to find a slow solution in O n2 k Hint use the dynamic programming Let dp i j denote the optimal result for prefix of i levels if we divide them into j regions Let pre i denote the result for region containing levels 1 2 i think how to calculate it easily with one loop Let sum i denote the sum of tj for all 1 j i Let rev i denote the sum of for all 1 j i Now let s write formula for dp i j as the minimum over l denoting the end of the previous region So we can use convex hull trick to calculate it in O n k You should also get AC with a bit slower divide conquer trick if it s implemented carefully 
https://codeforces.com//contest/1512/problem/G,953480,G,1512G,1512,G. Short Task,Let us denote by d n the sum of all divisors of the number n i e d n sum limits k n k For example d 1 1 d 4 1 2 4 7 d 6 1 2 3 6 12 For a given number c find the minimum n such that d n c ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=10000010;\nconst int mod=1000000007;\nusing namespace std;\n\nll ans[def],sum[def];\n\nint main()\n{\tint _=1,__=1,n;\n\tfor(int i=1;i<def;i++)\n\t\tfor(int j=1;i*j<def;j++)\n\t\t\tsum[i*j]+=i;\n\tfor(int i=1;i<def;i++)\n\t\tif(sum[i]<def&&!ans[sum[i]])ans[sum[i]]=i;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tprintf(""%lld\\n"",ans[n]?ans[n]:-1);\n\t}\n\treturn 0;\n}']",,,"['brute force', 'dp', 'math', 'number theory']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Short Task.json,https://codeforces.com//blog/entry/89535,Note that is the maximum value of in the problem so it is enough for every to calculate the value of To calculate the value of you can use the sieve of Eratosthenes and get the solution for Also you can use the linear sieve of Eratosthenes to find the minimum divisor for each and use the multiplicativity of the function if 
https://codeforces.com//contest/373/problem/B,4178,B,373B,373,B. Making Sequences is Fun,We ll define for positive integer as follows the number of the s digits in the decimal base For example You want to make a consecutive integer sequence starting from number But you need to pay to add the number to the sequence You can spend a cost up to and you want to make the sequence as long as possible Write a program that tells sequence s maximum length ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 100000000000000000LL;\n\nLL w, M, k;\nLL ans;\n\nLL calcS(LL x)\n{\n\tif (x < 10) return x;\n\tLL ret = 0;\n\tLL i = 1, bit = 1;\n\tfor (; i * 10 <= x; i *= 10, ++bit) ret += bit * i * 9;\n\tLL digit = x / i % 10;\n\tret += (digit - 1) * i * bit;\n\tret += (x % i + 1)* bit;\n\treturn ret;\n}\n\nint main()\n{\n\tcin >> w >> M >> k;\n\tfor (LL l = 0, r = INF - M; l <= r;) {\n\t\tLL m = (l + r) / 2;\n\t\tif ((calcS(M + m - 1) - calcS(M - 1)) <= w / k) ans = m, l = m + 1;\n\t\telse r = m - 1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']",,,"['binary search', 'implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Making Sequences is Fun.json,https://codeforces.com//blog/entry/9944,Naive simulation subtracting S i k from w while w 0 won t finish in 2 seconds At first these two facts will make it easier to solve the problem 1 k doesn t matter for solving this problem so you can simply divide w with k at the first point 2 S 10 x S 10 x 1 S 10 x 1 1 9 x 10 x There are many ways to solve this problem and I ll show you 2 ways Binary Search Let s define f n as sum k 1 n S n This problem can be solved by finding largest x that satisfies f x f m 1 w If x satisfies the given inequation also x 1 x 2 satisfies inequation since S x is always positive So it can be solved by using binary search By using fact2 you can quickly simulate the value of f n The answer can be rather large so be careful not to cause overflow by too large upper bound Overall complexity is O log upper bound lower bound Cumulative Sums Let s think to speed up naive solutions that I ve written at first If you use fact 2 the number of simulation will reduce from O answer to O 1 Also simulation will be much easier if you add S 1 S m 1 to w Please see my source code for further detail DEGwer s solution Solution 1 http ideone com cU78oe My solution Solution 2 http ideone com NjxlwP 
https://codeforces.com//contest/1157/problem/E,336208,E,1157E,1157,E. Minimum Array,You are given two arrays a and b both of length n All elements of both arrays are from 0 to n 1 You can reorder elements of the array b if you want you may leave the order of elements as it is After that let array c be the array of length n the i th element of this array is c i a i b i ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tprintf(""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n\n// Optimize\n#define abs(a) ((a)<0?(~(a)+1):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) {a=a^b;b=a^b;a=a^b;}\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define MOD 998244353\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 262144\n\nint n;\nint cnt[MAXN];\nint a[MAXN];\nint nxtnum[MAXN];\n\nint Nxt( int x ){\n\treturn nxtnum[x] == x ? x : nxtnum[x] = Nxt(nxtnum[x]);\n}\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) Read(a[i]);\n\tFor(i,n){\n\t\tiRead(x);\n\t\t++cnt[x];\n\t}\n\n\tFor0(i,n) nxtnum[i] = cnt[i] ? i : (i+1)%n;\n\n\tFor(i,n){\n\t\tint u = a[i];\n\t\tint v = Nxt((n-u)%n);\n\t\tprintf(""%d "",(u+v)%n);\n\t\t--cnt[v];\n\t\tif(!cnt[v]) nxtnum[v] = (v+1)%n;\n\t}\n\tputchar(10);\n\n\tEND();\n}\n']",,,"['binary search', 'data structures', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Minimum Array.json,https://codeforces.com/blog/entry/66737,Let s maintain all elements of the array in a set that allows multiple copies of equal elements for C Then let s iterate from left to right over the array and try to minimize the current element in array This order will minimize the resulting array by lexicographical comparing definition So for the th element let s find the minimum element greater than or equal to in the set because will give us remainder will give us remainder and so on If there is no greater or equal element in the set then let s take the minimum element of the set and take it as a pair for otherwise let s take this greater or equal element and remove it from the set Time complexity 
https://codeforces.com//contest/333/problem/C,3371,C,333C,333,C. Lucky Tickets,Gerald has a friend Pollard Pollard is interested in lucky tickets ticket is a sequence of digits At first he thought that a ticket is lucky if between some its digits we can add arithmetic signs and brackets so that the result obtained by the arithmetic expression was number 100 But he quickly analyzed all such tickets and moved on to a more general question Now he explores lucky tickets Pollard sais that a ticket is lucky if we can add arithmetic operation signs between its digits to the left or right of them i e and brackets so as to obtain the correct arithmetic expression whose value would equal For example ticket 224201016 is 1000 lucky as Pollard was so carried away by the lucky tickets that he signed up for a seminar on lucky tickets and as far as Gerald knows Pollard will attend it daily at 7 pm in some famous institute and will commute to it in the same tram for days In this tram tickets have eight digits And Gerald wants to make a surprise for Pollard each day Pollard will receive a tram lucky ticket The conductor has already agreed to give Pollard certain tickets during all these days and he only wants Gerald to tell him what kind of tickets to give out In this regard help Gerald pick exactly distinct lucky tickets ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring> \n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nint a,b,c,d,n,m,k;\nmap<pii, set<int> > q;\ninline void un(set<int> &s1, set<int> &s2, set<int> &ans, int rt) {\n    for (set<int>::iterator it1 = s1.begin(); it1 != s1.end(); ++it1) {\n        for (set<int>::iterator it2 = s2.begin(); it2 != s2.end(); ++it2) {\n            int a = *it1;\n            rept(j, rt) a *= 10;\n            a += *it2;\n            ans.insert(a);\n            if (L(ans) >= 300000) return;\n        }\n        if (L(ans) >= 300000) return;\n    }\n}\nset<int> rec(int len, int res) {\n    res = abs(res);\n    if (q.count(mp(len, res))) return q[mp(len, res)];\n    set<int> ans;\n    int t = 1;\n    rept(i, len) t *= 10;\n    if (res < t) ans.insert(res);\n    if (len == 1) return q[mp(len, res)] = ans;\n    \n    rep(lf, len - 1) {\n        if (lf > 3) break;\n        rept(j, 10) {\n            set<int> s1 = rec(lf, j);\n            if (s1.empty()) continue;\n            set<int> s2 = rec(len - lf, res - j);\n            \n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            s2 = rec(len - lf, res + j);\n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            s2 = rec(len - lf, j - res);\n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            s2 = rec(len - lf, -res - j);\n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            if (j && res % j == 0) {\n                s2 = rec(len - lf, res / j);\n                un(s1, s2, ans, len - lf);\n            }\n            if (L(ans) >= 300000) break;\n        }\n        if (L(ans) >= 300000) break;\n    }\n    return q[mp(len, res)] = ans;\n}\nint main() {\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    scanf(""%d%d"", &k, &m);\n\n    set<int> ans = rec(8, k);\n\n    rept(h, m) {\n        int t = *ans.begin();\n        ans.erase(ans.begin());\n        string s = """";\n        rept(j, 8) {\n            s += (char)(t % 10 + \'0\');\n            t /= 10;\n        }\n        reverse(all(s));\n        printf(""%s\\n"", s.c_str());\n    }\n}']",,,"['brute force', 'constructive algorithms']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Lucky Tickets.json,https://codeforces.com//blog/entry/8418,In this problem we can find the right amount of lucky tickets Lets consider amount of different numbers we can get from one four digit ticket number It is easy to iterate all this tickets since it amount only It happened that we can get almost 60 numbers from ticket on the average Suppose we can get number from ticket It is clearly that either or If we can write eight digit ticket number who will have in the first four digits and in the last four digits It is clearly that such ticket is lucky This method allows us to get almost lucky tickets and it is enough 
https://codeforces.com//contest/716/problem/B,71756,B,716B,716,B. Complete the Word,ZS the Coder loves to read the dictionary He thinks that a word is if there exists a contiguous segment of letters of it of length where each letter of English alphabet appears exactly once In particular if the string has length strictly less than no such substring exists and thus it is not nice Now ZS the Coder tells you a word where some of its letters are missing as he forgot them He wants to determine if it is possible to fill in the missing letters so that the resulting word is nice If it is possible he needs you to find an example of such a word as well Can you help him ,"['/*AMETHYSTS*/\n#pragma comment(linker, ""/STACK:1000000000"")\n#include <cstdio>\n#include <iostream>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <climits>\n#include <string>\n#include <queue>\n#include <memory.h>\n#include <unordered_map>\n#include <random>\n\n#define ll long long\n#define ld double\n#define pii pair <int, int>\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define ui unsigned ll\n\nusing namespace std;\n\nconst int maxn = (int)1e5 + 10;\nchar s[maxn];\nbool used[maxn];\n\nint main() {\n\tscanf(""%s"", s);\n\n\tint len = strlen(s);\n\n\tfor (int i = 0; i <= len - 26; i++) {\n\t\tmemset(used, 0, sizeof used);\n\t\tbool st = true;\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tif (s[i + j] != \'?\') {\n\t\t\t\tif (used[s[i + j] - \'A\']) {\n\t\t\t\t\tst = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tused[s[i + j] - \'A\'] = true;\n\t\t\t}\n\t\t}\n\n\t\tif (st) {\n\t\t\tint pos = 0;\n\n\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\tif (s[i + j] == \'?\') {\n\t\t\t\t\twhile (pos < 26 && used[pos]) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tused[pos] = true;\n\n\t\t\t\t\ts[i + j] = \'A\' + pos;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tif (s[j] == \'?\') {\n\t\t\t\t\ts[j] = \'A\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(""%s\\n"", s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << -1 << endl;\n\n\treturn 0;\n}\n']",,,"['greedy', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Complete the Word.json,https://codeforces.com//blog/entry/47169,Prerequisites None Firstly if the length of the string is less than output immediately We want to make a substring of length have all the letters of the alphabet Thus the simplest way is to iterate through all substrings of length there are such substrings then for each substring count the number of occurrences of each alphabet ignoring the question marks After that if there exist a letter that occurs twice or more this substring cannot contain all letters of the alphabet and we process the next substring Otherwise we can fill in the question marks with the letters that have not appeared in the substring and obtain a substring of length which contains all letters of the alphabet After iterating through all substrings either there is no solution or we already created a nice substring If the former case appears output Otherwise fill in the remaining question marks with random letters and output the string Note that one can optimize the solution above by noting that we don t need to iterate through all letters of each substring we consider but we can iterate through the substrings from left to right and when we move to the next substring remove the front letter of the current substring and add the last letter of the next substring This optimization is not required to pass We can still optimize it further and make the complexity purely We use the same trick as above when we move to the next substring we remove the previous letter and add the new letter We store a frequency array counting how many times each letter appear in the current substring Additionally store a counter which we will use to detect whether the current substring can contain all the letters of the alphabet in When a letter first appear in the frequency array increment the counter by If a letter disappears is removed in the frequency array decrement the counter by When we add a new question mark increment the counter by When we remove a question mark decrement the counter by To check whether a substring can work we just have to check whether the counter is equal to This solution works in Time Complexity or Code O 26 2 s 
https://codeforces.com//contest/982/problem/D,183674,D,982D,982,D. Shark,For long time scientists study the behavior of sharks Sharks as many other species alternate short movements in a certain location and long movements between locations Max is a young biologist For n days he watched a specific shark and now he knows the distance the shark traveled in each of the days All the distances are distinct Max wants to know now how many locations the shark visited He assumed there is such an integer k that if the shark in some day traveled the distance strictly less than k then it didn t change the location otherwise if in one day the shark traveled the distance greater than or equal to k then it was changing a location in that day Note that it is possible that the shark changed a location for several consecutive days in each of them the shark traveled the distance at least k The shark never returned to the same location after it has moved from it Thus in the sequence of n days we can find consecutive nonempty segments when the shark traveled the distance less than k in each of the days each such segment corresponds to one location Max wants to choose such k that the lengths of all such segments are equal Find such integer k that the number of locations is as large as possible If there are several such k print the smallest one ,"['#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#define rep(i,n) for(int i=1;i<=n;++i)\n#define pb push_back\nusing namespace std;\n\nusing namespace std;\n\nstruct node\n{\n\tint v,p;\n\tfriend bool operator <(node x,node y)\n\t{\n\t\treturn x.v<y.v;\n\t}\n}a[210000];\n\nstruct node2\n{\n\tint l,r;\n\tint cnt,sum;\n}st[210000*36];\n\nint v[210000],father[210000],num[210000],seq[210000];\nint n;\nint ll,ans,root,tot,sum;\n\nint getfather(int x)\n{\n\tif (x==father[x]) return x;\n\treturn father[x]=getfather(father[x]);\n}\n\nvoid modify(int &x,int l,int r,int p,int k)\n{\n\tif (x==0) \n\t{\n\t\tx=++tot; \n\t\tst[x].l=st[x].r=st[x].cnt=st[x].sum=0; \n\t}\n\tif (l==r) \n\t{\n\t    st[x].sum=st[x].sum+k; \n\t\tst[x].cnt=(st[x].sum>0);\n\t    return;\n\t}\n\tint mid=(l+r)/2;\n\tif (p<=mid)modify(st[x].l,l,mid,p,k);\n\telse modify(st[x].r,mid+1,r,p,k);\n\n\tst[x].cnt=st[st[x].l].cnt+st[st[x].r].cnt;\n}\nvoid init()\n{\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)father[i]=i,num[i]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d"",&v[i]);\n\t\ta[i].v=v[i]; \n\t\ta[i].p=i;\n\t}\n\tsort(a+1,a+n+1);\n}\nint main()\n{\n\tinit();\n\n\trep(i,n)\n\t{\n\t    int p=a[i].p; \n\t    seq[p]=1;\n\t    if (p>1) \n\t    {\n\t    \tif (seq[p-1]==1) \n\t    \t{\n\t    \t\tint tx=getfather(p-1); \n\t    \t\tint ty=getfather(p);\n    \t\t    modify(root,1,n,num[tx],-1);\n    \t\t    father[tx]=ty;\n    \t\t    num[ty]=num[ty]+num[tx];\n    \t\t    sum++;\n\t    \t}\n\t    }\n\t    if (p<n) \n\t    {\n\t    \tif (seq[p+1]==1) \n\t    \t{\n\t    \t\tint tx=getfather(p+1); \n\t    \t\tint ty=getfather(p);\n    \t\t    modify(root,1,n,num[tx],-1);\n    \t\t    father[tx]=ty;\n    \t\t    num[ty]=num[ty]+num[tx];\n    \t\t    sum++;\n\t    \t}\n\t    }\n\t    int tx=getfather(p);\n\t    modify(root,1,n,num[tx],1);\n\t    if (st[root].cnt==1 && i-sum>ll)\n\t\t{\n\t\t\t\tll=i-sum;\n\t\t\t\tans=a[i].v+1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']",,,"['brute force', 'data structures', 'dsu', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Shark.json,https://codeforces.com//blog/entry/59551,Let s sort the array and insert the numbers in the sort order from smaller to larger Using the data structure disjoint set union we can easily maintain information about the current number of segments as well as using the map within the function of union and information about the current size of segments locations too Then it remains only to update the answer when it s needed 
https://codeforces.com//contest/956/problem/E,168083,E,956E,956,E. Wardrobe,Olya wants to buy a custom wardrobe It should have boxes with heights stacked one on another in some order In other words we can represent each box as a vertical segment of length and all these segments should form a single segment from to without any overlaps Some of the boxes are important in this case others are not then Olya defines the of the wardrobe as the number of important boxes such that their bottom edge is located between the heights and inclusive You are given information about heights of the boxes and their importance Compute the maximum possible convenience of the wardrobe if you can reorder the boxes arbitrarily ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 10010;\nbool dp[N][2];\nint a[N];\nint n, m;\nint L, R;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &n, &L, &R);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tm = 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tif (t == 0) {\n\t\t\tfor (int x = R; x >= a[i]; x--)\n\t\t\t\tdp[x][0] |= dp[x - a[i]][0];\n\t\t} else {\n\t\t\ta[m++] = a[i];\n\t\t}\n\t}\n\tn = m;\n\tsort(a, a + n);\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += a[i];\n\tfor (int it = n - 1; it >= 0; it--) {\n\t\tfor (int x = R; x >= a[it]; x--)\n\t\t\tdp[x][1] |= dp[x - a[it]][1];\n\t\tfor (int x = 0; x <= R; x++)\n\t\t\tdp[x][1] |= dp[x][0];\n\t\tfor (int x = R; x >= a[it]; x--)\n\t\t\tdp[x][0] |= dp[x - a[it]][0];\n\t\tsum -= a[it];\n\t\tbool ans = false;\n\t\tfor (int x = L; x <= R - sum; x++) {\n\t\t\tif (dp[x][1]) {\n\t\t\t\tprintf(""%d\\n"", it + 1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans |= dp[x][0];\n\t\t}\n\t\tif (ans) {\n\t\t\tprintf(""%d\\n"", it);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""0\\n"");\n\n\treturn 0;\n}\n']",,,"['dp', 'greedy']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Wardrobe.json,https://codeforces.com//blog/entry/58544,The first idea of the author s solution is to reverse the problem change l to H r and r to H l where H is the total height of the wardrobe Now an important box is counted in the answer if and only if its top edge is within the segment l r We ll see later the profit of this operation Now we ll build a wardrobe of arbitrary height using only a subset of the boxes and choose the maximum possible answer Why can we remove the constraint to use all boxes We can always assume that we add all the boxes we don t take at the top of the boxes we take and the answer won t decrease So we can do some kind of knapsack where not taking a box means putting it on the top after considering all boxes What we don t know is how to compute the answer and in which order to consider the boxes in the knapsack Ok if we consider them in such an order that there is an optimal answer in which the boxes we take in the knapsack always come in this order then computing the answer is easy we can always assume that we put a new box on the top of already taken ones and add 1 to the current answer if it is an important box and its top edge falls in the range l r Now we should find such an order Note that in an optimal answer we can always arrange boxes in this order some number of unimportant boxes then some number of important boxes that don t increase the answer then some number of important boxes that increase the answer and after that a mix of important and unimportant boxes which don t count in the answer and that we consider as not taken in the knapsack This means that we can first consider all unimportant boxes in the knapsack and then all important ones It s also easy to see that the order of unimportant boxes does not matter However it turns out that the order of important boxes matters To choose the order of important boxes we can use an old but good trick Suppose two important boxes with heights ai and aj stand one on the other Answer the question What is the condition such that if it is satisfied then it is always better to put aj on the top of ai and not vice versa Here we consider only the boxes that count in the answer and those under them because other we simply don t take in the knapsack It turns out that the condition is simple aj ai no matter do these boxes count in the answer or not Here we used the fact that we inversed the problem and the position of the top edge matters not the bottom one So as we now know that it is always optimal to put the important boxes from largest to smallest in the inversed problem we can sort them in that order and perform the knapsack 
https://codeforces.com//contest/678/problem/F,62344,F,678F,678,F. Lena and Queries,Lena is a programmer She got a task to solve at work There is an empty set of pairs of integers and queries to process Each query is one of three types Add a pair to the set Remove a pair added in the query number All queries are numbered with integers from to For a given integer find the maximal value over all pairs from the set Help Lena to process the queries ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <set>\nusing namespace std;\ntypedef long long LL;\nconst int N = 300005;\nstruct Point {\n    int x , y;\n    Point (int _x = 0 , int _y = 0) {\n        x = _x;\n        y = _y;\n    }\n    Point operator - (const Point& R) const {\n        return Point(x - R.x , y - R.y);\n    }\n    LL operator ^ (const Point& R) const {\n        return (LL)x * R.y - (LL)y * R.x;\n    }\n    LL operator % (const Point& R) const {\n        return (LL)x * R.x + (LL)y * R.y;\n    }\n    bool operator < (const Point &R) const {\n        if (x != R.x)\n            return x < R.x;\n        return y < R.y;\n    }\n};\nint n , m , p;\nPoint W[N] , K[N];\nmap<Point , int> Hash;\nLL res[N] , ans[N];\nint a[N];\n\nbool cmpP(const int &A , const int &B) {\n    return W[A] < W[B];\n}\nbool cmpQ(const int &A , const int &B) {\n    return (LL)K[A].x * K[B].y < (LL)K[B].x * K[A].y;\n}\nvoid update(vector<int>& P , vector<int>& Q) {\n    if (P.empty() || Q.empty())\n        return;\n    sort(P.begin() , P.end() , cmpP);\n    vector<int> A , B;\n    for (int i = 0 ; i < Q.size() ; ++ i)\n        if (K[Q[i]].y >= 0) {\n            A.push_back(Q[i]);\n        } else {\n            B.push_back(Q[i]);\n        }\n    sort(A.begin() , A.end() , cmpQ);\n    sort(B.begin() , B.end() , cmpQ);\n    vector<Point> s(P.size() + 1);\n    int t = 0;\n    for (int i = 0 ; i < P.size() ; ++ i) {\n        Point D = W[P[i]];\n        while (t > 1 && ((D - s[t - 2]) ^ (s[t - 1] - s[t - 2])) <= 0)\n            -- t;\n        s[t ++] = D;\n    }\n    for (int i = 0 , j = 0 ; i < A.size() ; ++ i) {\n        while (j + 1 < t && (K[A[i]] % s[j + 1]) >= (K[A[i]] % s[j]))\n            ++ j;\n        res[A[i]] = max(res[A[i]] , K[A[i]] % s[j]);\n    }\n\n    t = 0;\n    for (int i = 0 ; i < P.size() ; ++ i) {\n        Point D = W[P[i]];\n        while (t > 1 && ((D - s[t - 2]) ^ (s[t - 1] - s[t - 2])) >= 0)\n            -- t;\n        s[t ++] = D;\n    }\n    reverse(A.begin() , A.end());\n    reverse(B.begin() , B.end());\n    for (int i = 0 , j = 0 ; i < B.size() ; ++ i) {\n        while (j + 1 < t && (K[B[i]] % s[j + 1]) >= (K[B[i]] % s[j]))\n            ++ j;\n        res[B[i]] = max(res[B[i]] , K[B[i]] % s[j]);\n    }\n}\nint del[N];\nvoid divide(const vector<int> &A) {\n    if (A.size() <= 1)\n        return;\n    vector<int> P , Q;\n    int r = A.size() , mid = r / 2;\n    for (int i = 0 ; i < mid ; ++ i)\n        P.push_back(A[i]);\n    divide(P);\n    P.clear();\n    for (int i = 0 ; i < r ; ++ i)\n        if (A[i] > 0 && (A[i] & 1))\n            del[A[i] >> 1] = 1;\n    for (int i = 0 ; i < mid ; ++ i)\n        if (A[i] > 0 && (~A[i] & 1)) {\n            if (!del[A[i] >> 1])\n                P.push_back(A[i] >> 1);\n            else\n                del[A[i] >> 1] = 2;\n        }\n    for (int i = mid ; i < r ; ++ i)\n        if (A[i] < 0)\n            Q.push_back(-A[i]);\n    update(P , Q);\n    Q.clear();\n    int c1 = 0 , c2 = 0;\n    for (int i = r - 1 ; i >= mid ; -- i) {\n        if (A[i] > 0 && (A[i] & 1) && del[A[i] >> 1] == 2) {\n            Q.push_back(A[i] ^ 1);\n            ++ c1;\n        } else if (A[i] < 0) {\n            Q.push_back(A[i]);\n            ++ c2;\n        }\n    }\n    for (int i = 0 ; i < r ; ++ i)\n        if (A[i] > 0 && (A[i] & 1))\n            del[A[i] >> 1] = 0;\n    if (c1 && c2)\n        divide(Q);\n    P.clear();\n    for (int i = mid ; i < r ; ++ i)\n        P.push_back(A[i]);\n    divide(P);\n}\nint iid[N];\nvoid work() {\n    scanf(""%d"" , &n);\n    vector<int> A;\n    for (int i = 0; i < n ; ++ i) {\n        Point S;\n        scanf(""%d"" , &a[i]);\n        if (a[i] == 3) {\n            scanf(""%d"" , &S.x);\n            S.y = 1;\n            ++ m;\n            res[m] = -1LL << 60;\n            K[m] = S;\n            a[i] = -m;\n        } else {\n            if (a[i] == 1) {\n                scanf(""%d%d"" , &S.x , &S.y);\n                W[++ p] = S;\n                iid[i] = p;\n                //Hash[S] = p;\n                a[i] = p << 1;\n            } else {\n                int j;\n                scanf(""%d"" , &j);\n                a[i] = iid[j - 1] << 1 | 1;\n                //Hash.erase(S);\n            }\n        }\n        A.push_back(a[i]);\n    }\n    divide(A);\n    for (int i = 1 ; i <= m ; ++ i) {\n        if (res[i] == -1LL << 60) {\n            puts(""EMPTY SET"");\n        } else {\n            printf(""%lld\\n"" , res[i]);\n        }\n    }\n}\n\nint main() {\n    work();\n    return 0;\n}']",,,"['data structures', 'divide and conquer', 'geometry']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Lena and Queries.json,https://codeforces.com//blog/entry/45405,The problem was suggested by AmirMohammad Dehghan PrinceOfPersia Let s interpret the problem geometrically the pairs from the set are the lines and the problem to find to topmost intersection of the vertical line with the lines from the set Let s split the queries to blocks Consider the lines added before the current block and that will not deleted in the current block Let s build the lower envelope by that lines Now to calculate the answer to the query we should get maximum over the lines from the envelope and the lines from the block before the current query that is not deleted yet There are no more than lines from the block so we can iterate over them Let s find the answers from the envelope for all queries of the third type from the block at once we should sort them and iterate over envelope using two pointers technique C solution 
https://codeforces.com//contest/303/problem/C,2985,C,303C,303,C. Minimum Modular,You have been given distinct integers You can remove at most of them Find the minimum modular so that for every pair of the remaining integers the following unequality holds ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nvector<int> df[1000005];\n\nbool taken[1000005];\nbool used[1000005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n    for (int i = 0; i <= 1000000; ++i) {\n        df[i].reserve(10);\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (i != j) {\n                int c = abs(v[i] - v[j]);\n                if ((int) df[c].size() < 2 * (k + 1)) {\n                    df[c].PB(v[i]);\n                    df[c].PB(v[j]);\n                }\n            }\n        }\n    }\n    for (int m = 1; m <= 1000001; ++m) {\n        vector<int> cused;\n        int res = 0;\n        for (int d = 0; d <= 1000000; d += m) {\n            if ((int) df[d].size() >= 2 * (k + 1)) {\n                res = k + 1;\n                break;\n            }\n            FORE (it, df[d]) {\n                if (used[*it]) {\n                    continue;\n                }\n                int a = *it % m;\n                if (taken[a]) {\n                    ++res;\n                } else {\n                    taken[a] = true;\n                }\n                used[*it] = true;\n                cused.PB(*it);\n            }\n            if (res > k) {\n                break;\n            }\n        }\n        if (res <= k) {\n            cout << m << endl;\n            return 0;\n        }\n        FORE (it, cused) {\n            used[*it] = false;\n            taken[*it % m] = false;\n        }\n    }\n}\n']",,,"['brute force', 'graphs', 'math', 'number theory']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Minimum Modular.json,https://codeforces.com//blog/entry/7641,Math Graph theory Brute force Congruent It is hard to solve this problem at once so at first let us consider on k 0 this easier case can be solved by enumerate on the ans Let us define a bool array diff which diff x is weather there are two number ai aj such that abs ai aj x So ans is legal diff ans diff 2 ans are false The time complexity O n2 mlogm Here m is the maximum ai Consider on k 0 we need to know how many pairs which has difference x Store them in vector pair int int diff x Then use a dsu to maintain the how many a i are congruent when enumerate on the ans 
https://codeforces.com//contest/671/problem/D,60095,D,671D,671,D. Roads in Yusland,Mayor of Yusland just won the lottery and decided to spent money on something good for town For example repair all the roads in the town Yusland consists of intersections connected by bidirectional roads One can travel from any intersection to any other intersection using only these roads There is only one road repairing company in town named RC company Company s center is located at the intersection RC company doesn t repair roads you tell them Instead they have workers at some intersections who can repair only some specific paths The th worker can be paid coins and then he repairs on a path from to some that from to intersection Mayor asks you to choose the cheapest way to hire some subset of workers in order to repair all the roads in Yusland It s allowed that some roads will be repaired more than once If it s impossible to repair all roads print ,"['#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 311111\n\n#define TASK ""1""\n\nusing namespace std;\n\nvector<int> v[N], ch[N];\nvector<pair<int, int> > z[N];\nint n, m;\n\nint d[N];\n\n\nvoid dfs(int x, int pr, int de) {\n\td[x] = de;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tint to = v[x][i];\n\t\tif (to != pr) {\n\t\t\tdfs(to, x, de + 1);\n\t\t\tch[x].pb(to);\n\t\t}\n\t}\n}\n\n\nlong long dp[N];\n\nset<pair<long long, int > > Q[N];\nlong long ad[N];\nint bad = 0;\n\nvoid calc(int x) {\n\tif (ch[x].size() == 0) {\n\t\tad[x] = 0;\n\t\tfor (int i = 0; i < z[x].size(); i++) Q[x].insert(mp(z[x][i].S, z[x][i].F));\n\t\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\t\tif (Q[x].size() == 0) {\n\t\t\tbad = 1;\n\t\t\tdp[x] = 0;\n\t\t} else {\n\t\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < ch[x].size(); i++) calc(ch[x][i]);\n\tlong long sum = 0;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tsum += dp[ch[x][i]];\n\t}\n\tint la = -1;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tad[ch[x][i]] += sum - dp[ch[x][i]];\n\t\tif (la == -1 || Q[ch[x][i]].size() > Q[la].size()) la = ch[x][i];\n\t}\n\n\tfor (int i = 0; i < ch[x].size(); i++) if (ch[x][i] != la) {\n\t\tint u = ch[x][i];\n\t\tfor (auto it = Q[u].begin(); it != Q[u].end(); ++it) {\n\t\t\tlong long cost = (*it).F + ad[u] - ad[la];\n\t\t\tQ[la].insert(mp(cost, (*it).S));\n\t\t}\n\t}\n\tfor (int i = 0; i < z[x].size(); i++) {\n\t\tlong long cost = z[x][i].S + sum - ad[la];\n\t\tQ[la].insert(mp(cost, z[x][i].F));\n\t}\n\tswap(Q[la], Q[x]);\n\tad[x] = ad[la];\n\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\tif (Q[x].size() == 0) {\n\t\tbad = 1;\n\t\tdp[x] = 0;\n\t} else {\n\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t}\n}\n\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK"".in"",""r"",stdin);\t\n\t\tfreopen(TASK"".out"",""w"",stdout);\n\t#endif\t\t\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(0, 0, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, co;\n\t\tscanf(""%d%d%d"", &x, &y, &co);\n\t\tx--;\n\t\ty--;\n\t\tif (d[x] < d[y]) swap(x, y);\n\n\t\tz[x].pb(mp(d[y], co));\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tcalc(v[0][i]);\n\t\tans += dp[v[0][i]];\n\t}\n\tif (bad) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}']",,,"['data structures', 'dp', 'greedy']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Roads in Yusland.json,https://codeforces.com//blog/entry/44821,I want to thank GlebsHP i originally came up with another problem similar to it GlebsHP suggested to use this one in stead of it Let s look for a optimal subset of paths paths may intersect To prevent from this let s change the problem litte bit A worker can repair all nodes between and some where is in the path between and with cost also paths must not intersect In this way we will never find better solution from original problem and we can express optimal subset in original problem without any path intersections in new problem Let s keep a array keeps minimum cost to cover all edges in subtree of node also the edge between and How to find answer of some Let s choose a worker which is in the subtree of and is a parent of node Then if we choose this worker answer must be where is child of a node in the path from to for all s Of course we have to exclude nodes chosen as and in the path from to since we will cover them with th worker We will construct a segment tree by dfs travel times so that for all nodes workers which start his path in subtree of this node can be reached by looking a contiguous segment in tree In node segment will keep values what will be equal to if we choose this worker to cover path between and We will travel our tree with dfs in each after we calculated node s children dp s we will update our segment in following way add all workers to segment where with value sum of node s children dp s For all workers equal to we must delete it from segment this is assigning to it The only thing we didn t handle is what to do with workers under this node Imagine all updates in subtree of node where is a child of node We have to increase all of them by sum of node s children dp s After applying all of this operations answer will be minimum value of workers start their path from a node in subtree of in segment tree Overall complexity will be Please look at the code to be more clear 
https://codeforces.com//contest/1195/problem/B,373877,B,1195B,1195,B. Sport Mafia,Each evening after the dinner the SIS s students gather together to play the game of Sport Mafia For the tournament Alya puts candies into the box which will serve as a prize for a winner To do that she performs n actions The first action performed is to put a single candy into the box For each of the remaining moves she can choose from two options the first option in case the box contains at least one candy is to take This way the number of candies in the box decreased by 1 the second option is to put candies in the box In this case Alya will put 1 more candy than she put in the previous time Thus if the box is empty then it can only use the second option For example one possible sequence of Alya s actions look as follows put one candy into the box put two candies into the box eat one candy from the box eat one candy from the box put three candies into the box eat one candy from the box put four candies into the box eat one candy from the box put five candies into the box This way she will perform 9 actions the number of candies at the end will be 11 while Alya will eat 4 candies in total You know the total number of actions n and the number of candies at the end k You need to find the total number of sweets Alya ate That is the number of moves of the first option It s guaranteed that for the given n and k the answer always exists Please note that during an action of the first option Alya takes out and eats exactly one candy ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main() {\n    LL n, k;\n    cin >> n >> k;\n    LL x = (n + k) * 2;\n    LL d = round(sqrt(9 + 4 * x));\n    cout << n-(d-3)/2 << endl;    \n}']",,,"['binary search', 'brute force', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Sport Mafia.json,https://codeforces.com/blog/entry/68471,In fact we need to solve the following equation and when we will find we need to print as the answer is the number of candies Alya will put into the box with turns sum of arithmetic progression This equation can be solved mathematically The only problem is getting the square root it can be avoided with binary search or taking square root in non integer numbers and checking some amount of integers in small range nearby the obtained root The other solution is the binary search by 
https://codeforces.com//contest/1676/problem/B,1394654,B,1676B,1676,B. Equal Candies,There are n boxes with different quantities of candies in each of them The i th box has a i candies inside You also have n friends that you want to give the candies to so you decided to give each friend a box of candies But you don t want any friends to get upset so you decided to eat some possibly none candies from each box so that all boxes have the same quantity of candies in them Note that you may eat a different number of candies from different boxes and you cannot add candies to any of the boxes What s the minimum total number of candies you have to eat to satisfy the requirements ,"['#include <iostream>\n\nusing namespace std;\n\nconst int N = 100;\n\nlong long a[N];\n\nint main()\n{\n\tint t;\n\tint n;\n\tint i;\n\tlong long mn;\n\tlong long ans;\n\t\n\tcin >> t;\n\twhile(t --)\n\t{\n\t\tcin >> n;\n\t\tfor(i = 1; i <= n; i ++)\n\t\t\tcin >> a[i];\n\t\t\n\t\tfor(i = 1, mn = 1e7; i <= n; i ++)\n\t\t\tmn = min(mn, a[i]);\n\t\tfor(i = 1, ans = 0; i <= n; i ++)\n\t\t\tans += a[i] - mn;\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n']",,,"['greedy', 'math', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\B. Equal Candies.json,https://codeforces.com//blog/entry/102710,Because we can only eat candies from boxes The only way to make all boxes have the same quantity of candies in them would be to make all candies contain a number of candies equal to the minimum quantity of candies a box initially has So we should find this minimum number let s denote it as and then for each box there should be eaten candies So the answer would be the sum of over all s 
https://codeforces.com//contest/1206/problem/A,390603,A,1206A,1206,A. Choose Two Numbers,You are given an array A consisting of n positive integers a 1 a 2 dots a n and an array B consisting of m positive integers b 1 b 2 dots b m Choose some element a of A and some element b of B such that a b doesn t belong to A and doesn t belong to B For example if A 2 1 7 and B 1 3 4 we can choose 1 from A and 4 from B as number 5 1 4 doesn t belong to A and doesn t belong to B However we can t choose 2 from A and 1 from B as 3 2 1 belongs to B It can be shown that such a pair exists If there are multiple answers print any Choose and print any such two numbers ,"['#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n; scanf(""%d"",&n);\n\tint mx1=0,mx2=0;\n\tfor (int i=1,x;i<=n;++i) scanf(""%d"",&x),mx1=max(mx1,x);\n\tscanf(""%d"",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(""%d"",&x),mx2=max(mx2,x);\n\tprintf(""%d %d\\n"",mx1,mx2);\n}']",,,"['math', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Choose Two Numbers.json,https://codeforces.com//blog/entry/69158,Let be the largest number in the array be the largest number in the array Then the number isn t present neither in the array nor in the array Indeed and is the largest number in the array so is not included in Similarly is not included in Thus you can select from from The asymptotics is if you find the largest element by sorting which many did or if you find it linearly 
https://codeforces.com//contest/1907/problem/D,2365626,D,1907D,1907,D. Jumping Through Segments,Polycarp is designing a level for a game The level consists of n segments on the number line where the i th segment starts at the point with coordinate l i and ends at the point with coordinate r i The player starts the level at the point with coordinate 0 In one move they can move to any point that is within a distance of no more than k After their i th move the player must land within the i th segment that is at a coordinate x such that l i le x le r i This means After the first move they must be inside the first segment from l 1 to r 1 After the second move they must be inside the second segment from l 2 to r 2 After the n th move they must be inside the n th segment from l n to r n The level is considered completed if the player reaches the n th segment following the rules described above After some thought Polycarp realized that it is impossible to complete the level with some values of k Polycarp does not want the level to be too easy so he asks you to determine the minimum integer k with which it is possible to complete the level ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<array>\n#include<set>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\nint n;\nlong long L[200000], R[200000];\ninline bool check(int x) {\n\tlong long cl = 0, cr = 0;\n\tfor (int i = 0; i ^ n; ++i) {\n\t\tif (cl - x > R[i] || cr + x < L[i])\n\t\t\treturn 0;\n\t\tcl = max(cl - x, L[i]);\n\t\tcr = min(cr + x, R[i]);\n\t}\n\treturn 1;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tcin >> n;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> L[i] >> R[i];\n\t\tint l = 0, r = 1000000000, mid;\n\t\tfor (; l < r;) {\n\t\t\tmid = l + r >> 1;\n\t\t\tif (check(mid))\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid + 1;\n\t\t}\n\t\tcout << l << '\\n';\n\t}\n}""]",,,"['binary search', 'constructive algorithms']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Jumping Through Segments.json,https://codeforces.com//blog/entry/123012,First let s note that if we can pass a level with some value of then we can make all the same moves and pass it with a larger value This allows us to use binary search for the answer To check whether it is possible to pass the level with a certain we will maintain a segment in which we can find ourselves After each move it expands by in both directions and is reduced to the intersection with the segment where the player must be at that move If at any point the intersection becomes empty then it is impossible to pass the level with such 
https://codeforces.com//contest/1453/problem/D,821025,D,1453D,1453,D. Checkpoints,Gildong is developing a game consisting of n stages numbered from 1 to n The player starts the game from the 1 st stage and should beat the stages in increasing order of the stage number The player wins the game after beating the n th stage There is at most one checkpoint on each stage and there is always a checkpoint on the 1 st stage At the beginning of the game only the checkpoint on the 1 st stage is activated and all other checkpoints are deactivated When the player gets to the i th stage that has a checkpoint that checkpoint is activated For each try of a stage the player can either beat the stage or fail the stage If they beat the i th stage the player is moved to the i 1 st stage If they fail the i th stage the player is moved to the most recent checkpoint they activated and they have to beat the stages after that checkpoint again For example assume that n 4 and the checkpoints are on the 1 st and 3 rd stages The player starts at the 1 st stage If they fail on the 1 st stage they need to retry the 1 st stage because the checkpoint on the 1 st stage is the most recent checkpoint they activated If the player beats the 1 st stage they re moved to the 2 nd stage If they fail it they re sent back to the 1 st stage again If they beat both the 1 st stage and the 2 nd stage they get to the 3 rd stage and the checkpoint on the 3 rd stage is activated Now whenever they fail on the 3 rd stage or the 4 th stage after beating the 3 rd stage they re sent back to the 3 rd stage If they beat both the 3 rd stage and the 4 th stage they win the game Gildong is going to build the stages to have equal difficulty He wants you to find any series of stages and checkpoints using at most 2000 stages where the expected number of tries over all stages is exactly k for a player whose probability of beating each stage is exactly cfrac 1 2 ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nvector<int>ans;\nint _;\nll n;\nll f[100];\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(_);\n    f[1]=2;\n    F(i,2,59)f[i]=f[i-1]*2+2;\n\twhile(_--){\n\t\tread(n);\n\t\tif(n&1){\n\t\t\tcout<<-1<<\'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\tans.clear();\n\t\tD(i,59,1){\n\t\t\twhile(n>=f[i]){\n\t\t\t\tn-=f[i];\n\t\t\t\tans.PB(1);\n\t\t\t\tF(j,1,i-1)ans.PB(0);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.size()<<\'\\n\';\n\t\tRep(y,ans)cout<<y<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'greedy', 'math', 'probabilities']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Checkpoints.json,https://codeforces.com//blog/entry/85288,As already explained in the notes and is quite obvious the expected number of tries to beat stage with a checkpoint where stage also has a checkpoint or is the end of the game is What if stage doesn t have a checkpoint and stage has a checkpoint We can think of it like this It takes tries in expectation to get to stage and the player needs to add one more try trying times in total But this also has a probability of to succeed so the expected number of tries to actually get to stage is multiplied by making it in total This can be extended indefinitely Let s say is the expected number of tries to beat consecutive stages with only one checkpoint at the beginning If we extend it to consecutive stages it takes tries If this is not intuitive we can always use Monte Carlo method to simulate how many tries each takes The general term for this sequence is and it is introduced in OEIS A000918 with a similar example As each checkpoint makes the stages after that checkpoint independent of the previous stages we can just add up appropriate s to make it equal to Using means we append the stages in form where the number of s is As every term of the sequence is even the answer is if is odd Otherwise we can show that there always exists an answer for all even There are two simple strategies to make it with at most stages The first strategy is to greedily take the greatest where is the remaining number then append and subtract it from This works because either can be exactly or we can use once and repeat the process with The worst case for this strategy is to use all of and another which sums up to total of stages Another strategy is to use and if bit indexed is Since there can be at most bits the worst case for this strategy is still far less than Time complexity 
https://codeforces.com//contest/1407/problem/C,718473,C,1407C,1407,C. Chocolate Bunny,We hid from you a permutation p of length n consisting of the elements from 1 to n You want to guess it To do that you can give us 2 different indices i and j and we will reply with p i bmod p j remainder of division p i by p j We have enough patience to answer at most 2 cdot n queries so you should fit in this constraint Can you do it As a reminder a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1E4 + 5;\n\nint n, a[N];\n\nint ask(int x, int y) {\n    cout << ""? "" << x << "" "" << y << endl;\n    int ret; cin >> ret; return ret;\n}\n\nint main() {\n    cin >> n;\n    int cur = 1;\n    for (int i = 2; i <= n; i++) {\n        int le = ask(cur, i), ri = ask(i, cur);\n        if (le < ri) {\n            a[i] = ri;\n        } else {\n            a[cur] = le;\n            cur = i;\n        }\n    }\n    a[cur] = n;\n    cout << ""!"";\n    for (int i = 1; i <= n; i++) {\n        cout << "" "" << a[i];\n    }\n    cout << endl;\n}\n']",,,"['constructive algorithms', 'interactive', 'math', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Chocolate Bunny.json,https://codeforces.com//blog/entry/82417,Observation Proof if then If then Let s maintain index of maximal number on the reviewed prefix initially Let s consider index Ask two queries and We ll know the less from both of them and either guess and update or guess In the end all numbers will be guessed except that obviously equals In total we ll make queries 
https://codeforces.com//contest/600/problem/B,41574,B,600B,600,B. Queries about less or equal elements,You are given two arrays of integers and For each element of the second array you should find the number of elements in array that are less than or equal to the value ,"['/*\nMass inclination will fuel my frustration\nAnd keep all redemption at bay\nAll indications prove your all mutations\nAnd you all have nothing to say\n\nHate\nDown on me\nBreak\nDown on me\nSlave\nDown on me\nPlague\nDown on me\n\nI can\'t believe everything you believe perceive\nIs rightfully coming your way\n\nTake me back to where I need to go (Inside me)\nShow me how to question all I know (Excite me)\nYou\'ll come around (And reveal yourself)\nYou come down (In this best education)\nI\'ll fall down (As we kill ourselves)\nWhen it all goes down (Are you ready to suffer it all?)\n\nMy aggravation is manifestation\nOf all of the shit that you say\nThis complication will lead to this damnation\nOf all those who stand in my way\n\nHate\nDown on me\nBreak\nDown on me\nSlave\nDown on me\nPlague\nDown on me\n\nI can\'t believe everything you believe perceive\nIs rightfully coming your way\n\nTake me back to where I need to go (Inside me)\nShow me how to question all I know (Excite me)\nYou\'ll come around (And reveal yourself)\nYou come down (In this best education)\nI\'ll fall down (As we kill ourselves)\nWhen it all goes down (Are you ready to suffer it all?)\n\nTake me back to where I need to go (Inside me)\nShow me how to question all I know (Excite me)\nYou\'ll come around (And reveal yourself)\nYou come down (In this best education)\nI\'ll fall down (As we kill ourselves)\nWhen it all goes down (Are you ready to suffer it all?)\n\nI\'ll be ready to suffer it all\nI\'ll be ready to suffer it all\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 200005;\n\nusing namespace std;\n\nint ar[N];\nint n,m;\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin>>n>>m;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tcin>>ar[i];\n\t}\n\tsort(ar,ar+n);\n\t\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tint val;\n\t\tcin>>val;\n\t\tint cnt=lower_bound(ar,ar+n,val+1)-ar;\n\t\tif (i)\n\t\t\tcout<<"" "";\n\t\tcout<<cnt;\n\t}\n\tcout<<endl;\n\treturn 0;\n}']",,,"['binary search', 'data structures', 'sortings', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Queries about less or equal elements.json,https://codeforces.com//blog/entry/21827,Let s sort all numbers in a Now let s iterate over elements of and for element find the index of lowest number that is greater than We can do that using binary search That index will be the answer for value Complexity 
https://codeforces.com//contest/1562/problem/D1,1090690,D1,1562D1,1562,D1. Two Hundred Twenty One  easy version ,Stitch likes experimenting with different machines with his friend Sparky Today they built another machine The main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive Each of these rods must carry an electric charge quantitatively equal to either 1 or 1 otherwise the machine will not work Another condition for this machine to work is that the sign variable sum of the charge on all rods must be zero More formally the rods can be represented as an array of n numbers characterizing the charge either 1 or 1 Then the condition must hold a 1 a 2 a 3 a 4 ldots 0 or sum limits i 1 n 1 i 1 cdot a i 0 Sparky charged all n rods with an electric current but unfortunately it happened that the rods were not charged correctly the sign variable sum of the charge is not zero The friends decided to leave only some of the rods in the machine Sparky has q questions In the ith question Sparky asks if the machine consisted only of rods with numbers l i to r i inclusive what minimal number of rods could be removed from the machine so that the sign variable sum of charges on the remaining ones would be zero Perhaps the friends got something wrong and the sign variable sum is already zero In that case you don t have to remove the rods at all If the number of rods is zero we will assume that the sign variable sum of charges is zero that is we can always remove all rods Help your friends and answer all of Sparky s questions ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint t,n,m,l,r,a[300005];\nstring s;\nsigned main(){\n    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n>>m>>s;\n        for(register int i=1;i<=n;i++)a[i]=a[i-1]+pow(-1,i-1)*(s[i-1]=='+'?1:-1);\n        while(m--){\n            cin>>l>>r;\n            if((a[r]-a[l-1])%2==0)cout<<(a[r]-a[l-1]==0?0:2)<<endl;\n            else cout<<1<<endl;\n        }\n    }\n    return 0;\n}""]",,,"['data structures', 'dp', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D1. Two Hundred Twenty One  easy version .json,https://codeforces.com//blog/entry/94278,Let s prove everything for a particular segment of length And at the end we ll show how to quickly solve the problem for many segments Let the length of the segment and let the array corresponding to the segment if is at the th position in the segment and if is at the th position in the segment Introduce a new array with being equal to the signed sum on the whole array if the th element was removed from it Then The parity of the length of the segment and the parity of the number of elements to be removed from it are the same It is not difficult to show that if or otherwise Proof of this fact Let Then it is easy to see that when is removed the segment will look exactly the same as when is removed So Now let Denote by the sign variable sum on the interval to taking into account the sign i e if is odd the first number is taken with the plus sign otherwise with the minus sign Then it is easy to see that and Hence if we consider the two cases and we see that If is odd then there exists such that Let us prove this If or then the statement is proved Now let and Then since the neighboring values in the array differ by no more than and all elements are even then there is bound to be zero between the first and last element The case is proved similarly If then there cannot be such a case that and and there cannot be such a case that and In fact let the sign variable sum of the whole segment be Then and Since and are even numbers therefore either at least one of them is zero or they are of different signs Thus the final result is if the sign variable sum is already zero output zero otherwise if the segment is of odd length output otherwise output To quickly determine the sign variable sum we use the prefix sum Asymptotics per test case 
https://codeforces.com//contest/1728/problem/B,1534223,B,1728B,1728,B. Best Permutation,Let s define the value of the permutation p of n integers 1 2 n a permutation is an array where each element from 1 to n occurs exactly once as follows initially an integer variable x is equal to 0 if x p 1 then add p 1 to x set x x p 1 otherwise assign 0 to x if x p 2 then add p 2 to x set x x p 2 otherwise assign 0 to x if x p n then add p n to x set x x p n otherwise assign 0 to x the value of the permutation is x at the end of this process For example for p 4 5 1 2 3 6 the value of x changes as follows 0 4 9 0 2 5 11 so the value of the permutation is 11 You are given an integer n Find a permutation p of size n with the maximum possible value among all permutations of size n If there are several such permutations you can print any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 2; i <= n - 2; i += 2) printf(""%d %d "", i, i - 1);\n\t\t\tprintf(""%d %d\\n"", n - 1, n);\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(""1 2 3 "");\n\t\tfor (int i = 5; i <= n - 2; i += 2) printf(""%d %d "", i, i - 1);\n\t\tprintf(""%d %d\\n"", n - 1, n);\n\t}\n}\n']",,,"['constructive algorithms', 'greedy']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Best Permutation.json,https://codeforces.com//blog/entry/106805,Let be the value of the variable after steps Note that should be less than for to be not equal to It means that does not exceed It turns out that for there is always a permutation such that is equal to The only thing left is to find out how to build such a permutation There are many suitable permutations let s consider one of the possible options For an even a suitable permutation is You can see that in such a permutation changes as follows For an odd there is a similar permutation where changes as follows 
https://codeforces.com//contest/1268/problem/E,499896,E,1268E,1268,E. Happy Cactus,You are given a cactus graph in this graph each edge lies on at most one simple cycle It is given as m edges a i b i weight of i th edge is i Let s call a path in cactus if the weights of edges on this path are increasing Let s call a pair of vertices u v if there exists an increasing path that starts in u and ends in v For each vertex u find the number of other vertices v such that pair u v is happy ,"['/**\n *    author:  tourist\n *    created: 21.12.2019 15:33:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector<vector<int>> find_cycles(const graph<T> &g, int bound_cnt = 1 << 30, int bound_size = 1 << 30) {\n  vector<int> was(g.n, -1);\n  vector<int> st;\n  vector<vector<int>> cycles;\n  int total_size = 0;\n  function<void(int, int)> dfs = [&](int v, int pe) {\n    if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n      return;\n    }\n    was[v] = (int) st.size();\n    for (int id : g.g[v]) {\n      if (id == pe) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ v;\n      if (was[to] >= 0) {\n        vector<int> cycle(1, id);\n        for (int j = was[to]; j < (int) st.size(); j++) {\n          cycle.push_back(st[j]);\n        }\n        cycles.push_back(cycle);\n        total_size += (int) cycle.size();\n        if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n          return;\n        }\n        continue;\n      }\n      if (was[to] == -1) {\n        st.push_back(id);\n        dfs(to, id);\n        st.pop_back();\n      }\n    }\n    was[v] = -2;\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (was[i] == -1) {\n      dfs(i, -1);\n    }\n  }\n  return cycles;\n  // cycles are given by edge ids, all cycles are simple\n  // breaks after getting bound_cnt cycles or total_size >= bound_size\n  // digraph: finds at least one cycle in every connected component (if not broken)\n  // undigraph: finds cycle basis\n}\n\ntemplate <typename T>\nvector<int> edges_to_vertices(const graph<T> &g, const vector<int> &edge_cycle) {\n  int sz = (int) edge_cycle.size();\n  vector<int> vertex_cycle;\n  if (sz <= 2) {\n    vertex_cycle.push_back(g.edges[edge_cycle[0]].from);\n    if (sz == 2) {\n      vertex_cycle.push_back(g.edges[edge_cycle[0]].to);\n    }\n  } else {\n    for (int i = 0; i < sz; i++) {\n      int j = (i + 1) % sz;\n      auto &e = g.edges[edge_cycle[i]];\n      auto &other = g.edges[edge_cycle[j]];\n      if (other.from == e.from || other.to == e.from) {\n        vertex_cycle.push_back(e.to);\n      } else {\n        vertex_cycle.push_back(e.from);\n      }\n    }\n  }\n  return vertex_cycle;\n  // only for simple cycles!\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  undigraph<int> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  vector<vector<int>> cycles = find_cycles(g);\n  vector<vector<int>> events(m);\n  for (auto& cycle : cycles) {\n    int sz = (int) cycle.size();\n    int pos = (int) (min_element(cycle.begin(), cycle.end()) - cycle.begin());\n    rotate(cycle.begin(), cycle.begin() + pos, cycle.end());\n    pos = (int) (max_element(cycle.begin(), cycle.end()) - cycle.begin());\n    bool ok = true;\n    for (int i = 0; i < pos - 1; i++) {\n      if (cycle[i] > cycle[i + 1]) {\n        ok = false;\n        break;\n      }\n    }\n    for (int i = pos; i < sz - 1; i++) {\n      if (cycle[i] < cycle[i + 1]) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      events[cycle[pos]].push_back(cycle[0]);\n    }\n  }\n  vector<int> sub(m, 0);\n  vector<int> ans(n, 1);\n  for (int i = m - 1; i >= 0; i--) {\n    auto& e = g.edges[i];\n    int x = e.from;\n    int y = e.to;\n    int cur = ans[x] + ans[y] - sub[i];\n    ans[x] = ans[y] = cur;\n    for (int j : events[i]) {\n      sub[j] += cur;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << ans[i] - 1;\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']",,,['dp'],3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Happy Cactus.json,https://codeforces.com//blog/entry/72358,At first let s solve for the tree Let be the number of answer for vertex Let s look at edges in the order of decreasing weight How is changing when you are looking at edge I claim that for and And Why I like this thinking about this problem in each vertex sitting a rat initially th rat is infected by th type of infection After that rats and and and bite each other When two rats bite each other they have a union of their infections I claim that the number of infections of th vertex in the end is equal to the required value So on the tree it is easy to see that the infections are not intersecting when two rats bite each other so they just change the number to sum But on the cactus they may have some non empty intersection Now it is easy to see that Let s say that is equal to the number of infections of same as the number of infections of after the moment when you meet this edge Similar to the tree case when th edge connects different connected components is just equal to the sum of the number of infections When th edge connects connected components is equal to the sum of the number of infections let s call this value Or is equal to where is some edge on the path between and note that it is a cactus so this path is unique This is always the largest edge on the path and it is subtracted if and only if the path from it to and from it to is decreasing So we can solve the problem in 
https://codeforces.com//contest/14/problem/E,66,E,14E,14,E. Camels,Bob likes to draw camels with a single hump two humps three humps etc He draws a camel by connecting points on a coordinate plane Now he s drawing camels with humps representing them as polylines in the plane Each polyline consists of vertices with coordinates The first vertex has a coordinate the second etc Coordinates might be any but should satisfy the following conditions there should be humps precisely i e such indexes so that there should be precisely such indexes so that no segment of a polyline should be parallel to the axis all are integers between 1 and 4 For a series of his drawings of camels with humps Bob wants to buy a notebook but he doesn t know how many pages he will need Output the amount of different polylines that can be drawn to represent camels with humps for a given number ,"['#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint n , t;\n\nlong long dp[21][2][5][30] , ans;\n\nlong long dodp(int cur , int last , int where , int cnt)\n{\n    if(cur == n + 1)\n    {\n        if(cnt == 2 * t - 1)\n            return 1;\n        else\n            return 0;\n    }\n    if(dp[cur][last][where][cnt] >= 0)\n        return dp[cur][last][where][cnt];\n    dp[cur][last][where][cnt] = 0;\n    for(int i = 1 ; i <= 4 ; i++)\n    {\n        int th = -1;\n        if(i > where)\n            th = 0;\n        if(i < where)\n            th = 1;\n        if(th + last == 1)\n            dp[cur][last][where][cnt] += dodp(cur + 1 , th , i , cnt + 1);\n        if(th == last)\n            dp[cur][last][where][cnt] += dodp(cur + 1 , th , i , cnt);\n        \n    }\n    return dp[cur][last][where][cnt];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(cin>>n>>t)\n    {\n        ans = 0;\n        memset(dp , 0xff , sizeof(dp));\n        for(int i = 1 ; i < 4 ; i++)\n            for(int j = i + 1 ; j <= 4 ; j++)\n                ans += dodp(3 , 0 , j , 0);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n']",,,['dp'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Camels.json,https://codeforces.com//blog/entry/389,Let us call an index j such that yj 1 yj yj 1 a cavity Also we ll call humps and cavities by the common word break Then there must be exactly T 2t 1 breaks and the first one must be a hump Denote by fnth the number of ways in which a camel with t breaks ending at the point n h can be extended to the end the vertical xN N so that the total number of breaks was equal to T Note that 1 fNTh 1 if h 1 2 3 4 We have already finished the camel and it has T breaks 2 fNth 0 if 0 t T h 1 2 3 4 We have already finished the camel but it has less than T breaks 3 fn T 1 h 0 if 1 n N h 1 2 3 4 The camel has already more than T breaks Now we find the recurrent formula for fnth Suppose that t is even Then the last break was a cavity and we are moving up currently We can continue moving up then the number of breaks stays the same and we move to one of the points n 1 h 1 n 1 h 2 n 1 4 Or we can move down then the number of breaks increases by 1 and we move to one of the points n 1 h 1 n 1 h 2 n 1 1 This gives us the formula If t is odd then the last break was a hump and similar reasoning leads to the formula We can calculate fnth by dynamic programming Consider now the point 2 h on a camel There are h 1 ways to get to this point starting from points 1 1 1 h 1 and f2 0 h ways to extend the camel to the end So the answer to the problem is 
https://codeforces.com//contest/2032/problem/F,2994609,F,2032F,2032,F. Peanuts,Having the magical beanstalk Jack has been gathering a lot of peanuts lately Eventually he has obtained n pockets of peanuts conveniently numbered 1 to n from left to right The i th pocket has a i peanuts Jack and his childhood friend Alice decide to play a game around the peanuts First Alice divides the pockets into some boxes each box will have a non zero number of pockets and each pocket will obviously belong to exactly one box At the same time Alice does not change the order of the boxes that is the boxes are numbered in ascending order of the indices of the pockets in them After that Alice and Jack will take turns alternately with Alice going first At each turn the current player will remove a positive number of peanuts from pocket which belongs to the i e the leftmost box containing at least one non empty pocket In other words if we number the boxes from left to right then each player can only pick peanuts from the pocket in the j th box j ge 2 only if the j 1 th box has no peanuts left The player who cannot make a valid move loses Alice is sure she will win since she has the advantage of dividing the pockets into boxes herself Thus she wanted to know how many ways there are for her to divide the peanuts into boxes at the start of the game so that she will win assuming both players play optimally Can you help her with the calculation As the result can be very large output it modulo 998 244 353 ,"['#include <bits/stdc++.h>using namespace std;const int mod = 998244353;int t, n;int a[1000020];int s[1000020];int c[1000020];long long f[1000020];long long g[1000020];int main(){\tscanf(""%d"", &t);\tfor (int tt = 0; tt < t; tt++)\t{\t\tscanf(""%d"", &n);\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\tscanf(""%d"", &a[i]);\t\t\ts[i + 1] = s[i] ^ a[i];\t\t\tc[i + 1] = c[i] + (a[i] == 1);\t\t}\t\tfor (int i = 0; i <= n; i++)\t\t{\t\t\tf[i] = 0;\t\t\tg[i] = 0;\t\t}\t\tunordered_map<int, long long> ff;\t\tunordered_map<int, long long> gg;\t\tunordered_map<int, long long> ggg;\t\tint sf = 0;\t\tint sg = 0;\t\tf[n] = 1;\t\tg[n] = 0;\xa0\t\tff[s[n]] = 1;\t\tsf = (sf + f[n]) % mod;\t\tint onej = n;\t\tfor (int i = n - 1; i >= 0; i--)\t\t{\t\t\t// long long debugf = 0;\t\t\t// long long debugg = 0;\t\t\tif (a[i] != 1)\t\t\t{\t\t\t\tfor (int j = onej; j > i; j--)\t\t\t\t{\t\t\t\t\tgg[s[j]] = (gg[s[j]] + g[j]) % mod;\t\t\t\t\tsg = (sg + g[j]) % mod;\t\t\t\t}\t\t\t\tonej = i;\t\t\t\tggg.clear();\t\t\t}\t\t\tg[i] = (g[i] + sg - gg[s[i]]) % mod;\t\t\tf[i] = (f[i] + gg[s[i]]) % mod;\xa0\t\t\t// for (int j = onej + 1; j <= n; j++)\t\t\t// {\t\t\t// \tif ((s[i] ^ s[j]) != 0)\t\t\t// \t{\t\t\t// \t\tg[i] += g[j];\t\t\t// \t}\t\t\t// \telse\t\t\t// \t{\t\t\t// \t\tf[i] += g[j];\t\t\t// \t}\t\t\t// }\xa0\t\t\tg[i] = (g[i] + ggg[i % 2]) % mod;\t\t\tf[i] = (f[i] + ggg[1 - i % 2]) % mod;\xa0\t\t\tg[i] = (g[i] + sf - ff[s[i]]) % mod;\t\t\tf[i] = (f[i] + ff[s[i]]) % mod;\t\t\tggg[i % 2] = (ggg[i % 2] + g[i]) % mod;\t\t\tff[s[i]] = (ff[s[i]] + f[i]) % mod;\t\t\tsf = (sf + f[i]) % mod;\t\t}\t\tif (g[0] < 0)\t\t{\t\t\tg[0] += mod;\t\t}\t\tprintf(""%lld\\n"", g[0]);\t}\treturn 0;}']",,,"['combinatorics', 'dp', 'games', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Peanuts.json,https://codeforces.com//blog/entry/135622,Let s get the trivial case out of the way If the peanut pockets always contain nut each then partitioning the pockets doesn t affect the game s outcome at all Alice will always win if is odd and there are ways to partition pockets Jack will always win if is even Proof for the trivial case is indeed trivial For the main problem we see that this is a derivative of a game of Nim To be exact each box is a vanilla Nim game To determine the winner of a vanilla Nim game when both players play optimally is trivial if not for you I strongly suggest reading about the game and the Sprague Grundy theorem before continuing In short the Nim sum of a Nim game is the xor sum of all values presented and if that value is at least the first player will win if they play optimally The original game of this problem is a series of consecutive Nim games with the loser of the previous game becoming the first player of the next game Clearly trying to win all the boxes isn t a correct approach one of the simplest counterexamples is a partition with two boxes both with the first player winning if played optimally so of course if the first player wins the first box they immediately lose the second one and thus lose the whole game In short sometimes tactically losing some boxes might be required But how to know which player would lose if they both aimed for it Now introducing the mirrored version of a Nim game a Mis re Nim game where the winning condition is the original Nim game s losing condition If the peanut pockets always contain nut each then the winner of a Mis re Nim game can be easily declared by the parity of Otherwise the winner of a Mis re Nim game can be decided using the same nimber used in a regular Nim game if the nimber is not the first player wins both the original and the Mis re version otherwise the second player wins the optimal strategies to acquire such outcome have the exact mirror intents of those in a regular Nim game Also surpassing the leading s in array both Alice and Jack have the rights to tactically lose Thus any of them would win the game if and only if they could win the first box containing non trivial pockets here defined as pockets with more than nut we ll call a box having at least one non trivial pocket a non trivial box if both play optimally until there as proven above if they could theoretically win it they could also tactically lose it thus they would have full control of the game and they could make a decision in accordance with whatever partition coming next in the remaining pockets We ll denote as the number of trivial pockets i e pockets with nut each standing at the left side of array i e the pocket will be the leftmost one to have more than nut We ll consider all possible options for first boxes containing non trivial pockets and thus we ll iterate in range First we denote as the xor sum of all elements of the prefix of array up until the element This value will determine how much control Alice would have If Alice will lose in all cases with the first non trivial box ending at Proof is simple if this box has an even amount of s before it obviously Alice will be the starting player of a game with nimber of and thus cannot control it to her will and if the amount of preceding s is odd then the first non trivial box is a game with nimber of and Jack as first player thus Jack retains full control If Alice will win in all cases with the first non trivial box ending at Proof is literally the reverse of the above case If both Alice and Jack have full control to win it thus Alice will win if and only if she is the starting player of the game at the first non trivial box So we have the detailed winning condition Now towards the maths First whatever pockets after the first non trivial box doesn t matter Thus for each there exists different partitions of the pockets following the one We don t consider cases with obviously If all partitions involving only the first pockets are allowed In fact there are items here trivial pockets and the first non trivial blob always coming last thus the number of different partitions of the pockets preceding the one in this case is If we ll consider all even in range with denoting the number of s not within the first non trivial box Clearly for each the number of different partitions would be And since is fixed and this process has no relation with this value could be pre calculated In more details denoting that value as we have All powers of could be pre calculated as well saving a considerable amount of runtime All pre calculations have time complexity in linear order of the maximum size of array Time complexity 
https://codeforces.com//contest/1285/problem/E,512930,E,1285E,1285,E. Delete a Segment,There are n segments on a Ox axis l 1 r 1 l 2 r 2 l n r n Segment l r covers all points from l to r inclusive so all x such that l le x le r Segments can be placed be inside each other coincide and so on Segments can degenerate into points that is l i r i is possible of the set of segments is such a set of segments which covers exactly the same set of points as the original set For example if n 3 and there are segments 3 6 100 100 5 8 then their union is 2 segments 3 8 and 100 100 if n 5 and there are segments 1 2 2 3 4 5 4 6 6 6 then their union is 2 segments 1 3 and 4 6 Obviously a union is a set of pairwise non intersecting segments You are asked to erase exactly one segment of the given n so that the number of segments in the union of the rest n 1 segments is maximum possible For example if n 4 and there are segments 1 4 2 3 3 6 5 7 then erasing the first segment will lead to 2 3 3 6 5 7 remaining which have 1 segment in their union erasing the second segment will lead to 1 4 3 6 5 7 remaining which have 1 segment in their union erasing the third segment will lead to 1 4 2 3 5 7 remaining which have 2 segments in their union erasing the fourth segment will lead to 1 4 2 3 3 6 remaining which have 1 segment in their union Thus you are required to erase the third segment to get answer 2 Write a program that will find the maximum number of segments in the union of n 1 segments if you erase any of the given n segments ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nconst int maxn = 800400;\nstruct node {\n\tint pl, pr, cn;\n\tnode(){\n\t\tpl = pr = cn = 0;\n\t}\n\tnode(int pl, int pr, int cn): pl(pl), pr(pr), cn(cn){}\n};\nnode operator + (node a, node b){\n\tint cn = a.cn + b.cn;\n\tif(a.pr && b.pl) cn--;\n\treturn (node){a.pl, b.pr, cn};\n}\nnode tr[maxn<<2];\nvoid upd(int id, int l, int r, int p){\n\tif(l == r) tr[id] = (node){1, 1, 1};\n\telse {\n\t\tint mid = (l + r)>>1;\n\t\tif(p <= mid) upd(id<<1, l, mid, p);\n\t\telse upd(id<<1|1, mid + 1, r, p);\n\t\ttr[id] = tr[id<<1] + tr[id<<1|1];\n\t}\n}\nvoid rst(int id, int l, int r, int p){\n\tif(l == r) tr[id] = (node){0, 0, 0};\n\telse {\n\t\tint mid = (l + r)>>1;\n\t\tif(p <= mid) rst(id<<1, l, mid, p);\n\t\telse rst(id<<1|1, mid + 1, r, p);\n\t\ttr[id] = tr[id<<1] + tr[id<<1|1];\n\t}\n}\nnode get(int id, int l, int r, int x, int y){\n\tif(l > y || r < x) return (node){0, 0, 0};\n\tif(x <= l && r <= y) return tr[id];\n\tint mid = (l + r)>>1;\n\tif(y <= mid) return get(id<<1, l, mid, x, y);\n\tif(x > mid) return get(id<<1|1, mid + 1, r, x, y);\n\treturn get(id<<1, l, mid, x, y) + get(id<<1|1, mid + 1, r, x, y);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n; cin >> n;\n\t\tvector<pair<int,int>> all(n);\n\t\tvector<int> pts;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> all[i].first >> all[i].second;\n\t\t\tall[i].first *= 2;\n\t\t\tall[i].second *= 2;\n\t\t\tpts.push_back(all[i].first - 1);\n\t\t\tpts.push_back(all[i].first);\n\t\t\tpts.push_back(all[i].second);\n\t\t\tpts.push_back(all[i].second + 1);\n\t\t}\n\t\tconst int inf = INT_MAX - 30;\n\t\tpts.push_back(-inf);\n\t\tpts.push_back(inf);\n\t\tsort(pts.begin(), pts.end());\n\t\tpts.erase(unique(pts.begin(), pts.end()), pts.end());\n\t\tint len = pts.size();\n\t\tvector<int> acc(2 * len, 0);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pl = lower_bound(pts.begin(), pts.end(), all[i].first) - pts.begin();\n\t\t\tint pr = lower_bound(pts.begin(), pts.end(), all[i].second) - pts.begin();\n\t\t\tacc[pl]++;\n\t\t\tacc[pr+1]--;\n\t\t}\n\t\tfor(int i = 1; i < len; i++){\n\t\t\tacc[i] += acc[i - 1];\n\t\t}\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tif(acc[i] == 1){\n\t\t\t\tupd(1, 0, len, i);\n\t\t\t}\n\t\t}\n\t\tint tot = 0;\n\t\tfor(int i = 0, j = 0; i < len; i = j){\n\t\t\twhile(j < len && acc[j] == 0) j++;\n\t\t\tif(acc[i]){\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\ttot++;\n\t\t\t}\n\t\t}\n\t\ttot -= 2;\n\t\tint best = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pl = lower_bound(pts.begin(), pts.end(), all[i].first) - pts.begin();\n\t\t\tint pr = lower_bound(pts.begin(), pts.end(), all[i].second) - pts.begin();\n\t\t\tnode at = get(1, 0, len, pl, pr);\n\t\t\tint here = tot + at.cn;\n\t\t\tif(acc[pl - 1] == 0 && at.pl) here--;\n\t\t\tif(acc[pr + 1] == 0 && at.pr) here--;\n\t\t\tbest = max(best, here + 1);\n\t\t}\n\t\tfor(int i = 0; i <= len; i++){\n\t\t\trst(1, 0, len, i);\n\t\t}\n\t\tcout << best << '\\n';\n\t}\n\treturn 0;\n}\n""]",,,"['brute force', 'constructive algorithms', 'data structures', 'dp', 'graphs', 'sortings', 'trees', 'two pointers']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Delete a Segment.json,https://codeforces.com//blog/entry/72950,Ok looking for a new number of segments in a union is actually hard Let be the union of segments after erasing the th one Obviously each of the segments in has its left and right borders Let me show you how to calculate the number of any of these two kinds Let s choose left borders I will call the set of left borders of the set of segments Build the initial union of all segments that is a standart algorithm google it if you want Call it We are asked to find but let s instead find that is the difference of sizes of the initial union and the new one for Surely adding to this value will be the answer Moreover and that s what we are going to calculate Call that difference Let s do the following sweep line Add queries of form and Process them in sorted order Maintain the set of the open segments This sweepline will add segment on a query of the first type and remove segment on a query of the second type Initialize all the with zeroes this sweepline will help us to calculate all the values altogether Look at the all updates on the same coordinate The only case we care about is the current set of open segments contain exactly one segment and there is at least one adding update Let this currently open segment be Consider what happens with is not in the because at least that segment covers it is also in because after erasing segment becomes a left border of some segment of the union you are adding a segment with the left border and points slightly to the left of are no longer covered by segment Thus increases by The other possible cases are there are no open segments currently this is not important because was a left border and stays as a left border there are more than two open segments not important because will still be covered by at least one of them after erasing some other there are no adding updates was a left border but doesn t become a new one Thus we handled all the left border count increasing cases But there are also a decreasing case Left border can get removed if the segment you are erasing had its left border in the initial union and was the only segment with such left border You can get while getting Then for each of you can count how many segments start in it Finally iterate over and decrease by one if the value for the left border of the segment is exactly Finally is obtained is the answer Overall complexity 
https://codeforces.com//contest/1907/problem/C,2365624,C,1907C,1907,C. Removal of Unattractive Pairs,Vlad found a string s consisting of n lowercase Latin letters and he wants to make it as short as possible To do this he can remove pair of adjacent characters from s any number of times provided they are For example if s then by removing one pair of characters he can obtain the strings and but he cannot obtain because the removed letters were the same or because the removed letters were not adjacent What is the minimum length Vlad can achieve by applying any number of deletions ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<array>\n#include<set>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\nint cnt[26];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tfor (int i = 0; i ^ 26; ++i)\n\t\t\tcnt[i] = 0;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\t++cnt[s[i] - 'a'];\n\t\tpriority_queue<int>q;\n\t\tfor (int i = 0; i ^ 26; ++i) {\n\t\t\tif (cnt[i])\n\t\t\t\tq.emplace(cnt[i]);\n\t\t}\n\t\tfor (; q.size() > 1;) {\n\t\t\tint u = q.top();\n\t\t\tq.pop();\n\t\t\tint v = q.top();\n\t\t\tq.pop();\n\t\t\tif (--u)\n\t\t\t\tq.emplace(u);\n\t\t\tif (--v)\n\t\t\t\tq.emplace(v);\n\t\t}\n\t\tcout << (q.size() ? q.top() : 0) << '\\n';\n\t}\n}""]",,,"['constructive algorithms', 'greedy', 'math', 'strings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Removal of Unattractive Pairs.json,https://codeforces.com//blog/entry/123012,Consider a finite string obviously all characters in it are the same as otherwise we could remove some pair of characters If some character occurs in the string more than times then the final string will always consist only of it because with one deletion we can only get rid of one occurrence To minimize the number of these characters we need to remove one occurrence each time We can always do this until the string is left with only such a character Otherwise we can remove all possible pairs regardless of the order of deletions 
https://codeforces.com//contest/1230/problem/B,419096,B,1230B,1230,B. Ania and Minimizing,Ania has a large integer S Its decimal representation has length n and doesn t contain any leading zeroes Ania is allowed to change at most k digits of S She wants to do it in such a way that S still won t contain any leading zeroes and it ll be minimal possible What integer will Ania finish with ,"['// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n        assert(~c);\n    }\n    if (c == \'-\') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2e5 + 5;\n\nchar s[N];\n\nint main() {\n    int n, k;\n    scanf(""%d%d%s"", &n, &k, s);\n    for (int i = 0; i < n; ++i) {\n        char aim = (i || n == 1) ? \'0\' : \'1\';\n        if (k && s[i] != aim) {\n            s[i] = aim;\n            --k;\n        }\n    }\n    puts(s);\n    return 0;\n}\n']",,,"['greedy', 'implementation']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Ania and Minimizing.json,https://codeforces.com//blog/entry/70008,There are a couple of corner cases if we cannot change Otherwise if we can change into Now assume that and A simple greedy approach works here we can iterate over the digits from left to right and change them to the lowest possible digits as long as we still can change anything The leftmost digit can be only changed to and all the remaining digits should be changed to We need to remember not to fix the digits that are currently the lowest possible For instance if the number will be changed to the modified digits are marked blue The algorithm can be easily implemented in time 
https://codeforces.com//contest/167/problem/A,1060,A,167A,167,A. Wizards and Trolleybuses,In some country live wizards They love to ride trolleybuses A city in this country has a trolleybus depot with trolleybuses Every day the trolleybuses leave the depot one by one and go to the final station The final station is at a distance of meters from the depot We know for the th trolleybus that it leaves at the moment of time seconds can go at a speed of no greater than meters per second and accelerate with an acceleration no greater than meters per second squared A trolleybus can decelerate as quickly as you want magic It can change its acceleration as fast as you want as well Note that the maximum acceleration is the same for all trolleys Despite the magic the trolleys are still powered by an electric circuit and cannot overtake each other the wires are to blame of course If a trolleybus catches up with another one they go together one right after the other until they arrive at the final station Also the drivers are driving so as to arrive at the final station as quickly as possible You as head of the trolleybuses fans club are to determine for each trolley the minimum time by which it can reach the final station At the time of arrival at the destination station the trolleybus does not necessarily have zero speed When a trolley is leaving the depot its speed is considered equal to zero From the point of view of physics the trolleybuses can be considered as material points and also we should ignore the impact on the speed of a trolley bus by everything except for the acceleration and deceleration provided by the engine ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ndouble ans[100010];\n\ndouble func(double a, double d, double v){\n    if(d < v*v / 2.0 / a) return sqrt(2.0 * d / a);\n    return v / a + (d - v*v / 2.0 / a) / v;\n}\n\nint main(void){\n    int N,a,d,t,v,i;\n    \n    scanf(""%d%d%d"",&N,&a,&d);\n    REP(i,N){\n        scanf(""%d%d"",&t,&v);\n        ans[i] = t + func(a,d,v);\n    }\n    \n    REP(i,N-1) ans[i+1] = max(ans[i+1],ans[i]);\n    REP(i,N) printf(""%.9f\\n"",ans[i]);\n    \n    return 0;\n}\n']",,,"['implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Wizards and Trolleybuses.json,https://codeforces.com//blog/entry/4214,This was the first problem where you had a little bit away from translating statements to a programming language Because acceleration trolleybuses are all the same and they can slow down immediately the answer for the next trolleybus is the maximum of the time when it would come if it were not to stop when he reach the rest trolleybuses which was traveling in front of him and the arrival time of the previous trolleybus It remains only to calculate the arrival time of each trolleybus if ignore others Here the easiest way to analyze two cases If then trolley should accelerate as long as it can and the answer is equal to Otherwise the trolley should accelerate all the time and the answer is equal to 
https://codeforces.com//contest/1946/problem/C,2546663,C,1946C,1946,C. Tree Cutting,You are given a tree with n vertices Your task is to find the maximum number x such that it is possible to remove exactly k edges from this tree in such a way that the size of each remaining connected component dagger is at least x dagger Two vertices v and u are in the same connected component if there exists a sequence of numbers t 1 t 2 ldots t k of arbitrary length k such that t 1 v t k u and for each i from 1 to k 1 vertices t i and t i 1 are connected by an edge ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=1e5+5;\nint n,k;\nvector<int> edg[MAXN];\nint siz[MAXN],cnt=0;\nvoid dfs(int u,int fa,int x){\n\tsiz[u]=1;\n\tfor(int v:edg[u]) if(v!=fa){\n\t\tdfs(v,u,x);\n\t\tsiz[u]+=siz[v];\n\t}\n\tif(siz[u]>=x){\n\t\tcnt++;\n\t\tsiz[u]=0;\n\t}\n}\nint check(int x){\n\tcnt=0;\n\tdfs(1,0,x);\n\treturn cnt-1;\n}\nvoid solve(){\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) edg[i].clear();\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;\n\t\tedg[u].push_back(v);\n\t\tedg[v].push_back(u);\n\t}\n\tint l=1,r=n,mid;\n\twhile(l<r){\n\t\tmid=l+r+1>>1;\n\t\tif(check(mid)>=k) l=mid;\n\t\telse r=mid-1;\n\t}\n\tcout<<l<<\'\\n\';\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(""Otomachi_Una.in"",""r"",stdin);\n\t// freopen(""Otomachi_Una.out"",""w"",stdout);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}']",,,"['binary search', 'dp', 'greedy', 'implementation', 'trees']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Tree Cutting.json,https://codeforces.com//blog/entry/127439,Let s hang the tree from an arbitrary vertex for definiteness let s hang the tree from vertex proof is given below First of all notice that if we can obtain some answer then we can also obtain the answer exactly the same way as for so we can do a binary search for To check the condition for a fixed we will use a greedy algorithm We will find the maximum number of connected components into which we can cut our tree so that each component has at least vertices We will start a dfs from vertex let s say we are currently at vertex and the number of vertices in its subtree is greater than or equal to then it is advantageous for us to remove the edge from vertex to its parent If after this process there are at least connected components then the condition is satisfied for this otherwise it is not Proof that it doesn t matter which vertex to hang the tree from We need to prove that the greedy algorithm will obtain the same number of cuts for all roots We will prove this in the order of depth first search It is also important to note that it doesn t matter in which order to run the greedy algorithm from the children Let the initial root be and we want to prove it for its child Then let s see how the greedy algorithm will act in the first case it will start from vertex and then from all its adjacent vertices except and remove some edges When we run the greedy algorithm in the second case we can reorder the vertices and first run it from all adjacent vertices except and there will be the same removals Then we will run the greedy algorithm from vertex it will perform the same removals as in the first case if we made vertex the last one So the only edge that may not coincide in these removals is If this edge did not participate in the removals the first time then the size of the remaining part of vertex so we cannot remove it now If the edge was removed in the first variant then the size of the component was and there were no vertices of subtree in it Then when running the greedy algorithm from the second vertex it will cut the edge because the size of this part became so the set of edges coincides 
https://codeforces.com//contest/1777/problem/B,1746202,B,1777B,1777,B. Emordnilap,A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array There are n n cdot n 1 cdot n 2 cdot ldots cdot 1 different permutations of length n Given a permutation p of n numbers we create an array a consisting of 2n numbers which is equal to p concatenated with its reverse We then define the beauty of p as the number of inversions in a The number of inversions in the array a is the number of pairs of indices i j such that i j and a i a j For example for permutation p 1 2 a would be 1 2 2 1 The inversions in a are 2 4 and 3 4 assuming 1 based indexing Hence the beauty of p is 2 Your task is to find the sum of beauties of all n permutations of size n Print the remainder we get when dividing this value by 1 000 000 007 10 9 7 ,"['//114514min\n//ACM \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nnamespace _fac\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll p=1e9+7;\n\tll fac[N];\n\tll ifac[N];\n\tll inv[N];\n\tll ksm(ll x,int y)\n\t{\n\t\tll r=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) r=(ll)r*x%p;\n\t\t\tx=(ll)x*x%p;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll C(int n,int m)\n\t{\n\t\tif (n<m||m<0) return 0;\n\t\treturn (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;\n\t}\n\tvoid init_fac()\n\t{\n\t\tint i;\n\t\tfac[0]=1;\n\t\tfor (i=1; i<N; i++) fac[i]=(ll)fac[i-1]*i%p;\n\n\t\tifac[N-1]=ksm(fac[N-1],p-2);\n\t\tfor (i=N-1; i; i--) ifac[i-1]=(ll)ifac[i]*i%p;\n\n\t\tll x; inv[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tx=p/i;\n\t\t\tinv[i]=(ll)x*(p-inv[p-x*i])%p;\n\t\t}\n\t}\n}\nusing _fac::init_fac; using _fac::fac; using _fac::ifac; using _fac::inv;\nusing _fac::ksm; using _fac::C; using _fac::p;\n\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tinit_fac();\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tcout<<fac[n]*C(n,2)*2%p<<\'\\n\';\n\t}\n}\n']",,,"['combinatorics', 'greedy', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Emordnilap.json,https://codeforces.com//blog/entry/111729,Every permutation has the same beauty Consider two indices and in a permutation These elements appear in the order in array Now we have two cases The first appears before both s in this case accounting for inversions Both the s appear before the second accounting for inversions again Hence any pair of indices in account for inversions in Thus beauty of every permutation Sum of beauties of all permutations 
https://codeforces.com//contest/238/problem/A,2111,A,238A,238,A. Not Wool Sequences,A sequence of non negative integers of length is called a if and only if there exists two integers and such that In other words each wool sequence contains a subsequence of consecutive elements with xor equal to 0 The expression means applying the operation of a bitwise xor to numbers and The given operation exists in all modern programming languages for example in languages and it is marked as in as In this problem you are asked to compute the number of sequences made of integers from 0 to that are not a wool sequence You should print this number modulo ,"['#include <stdio.h>\n#include <ctype.h>\n#include <iostream>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <time.h>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <utility>\n#include <assert.h>\n\n#define MPI 3.141592653589793238462643\n#define eps 1e-8\n#define inf ((int)1e9)\n#define pb push_back\n#define mp make_pair\n#define mod (1000000009ll)\n\nusing namespace std;\n\nlong long res=1ll, d=1ll;\n\nint main()\n{\n  int i, n, m;\n  //freopen("".in"", ""r"", stdin);\n  //freopen("".out"", ""w"", stdout);\n  cin>>n>>m;\n  for (i=0; i<m; i++)\n    d*=2ll, d%=mod;\n  for (i=1; i<=n; i++)\n    res*=(d+mod-i), res%=mod;\n  cout<<res<<endl;\n  return 0;\n}\n']",,,"['constructive algorithms', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Not Wool Sequences.json,https://codeforces.com//blog/entry/5765,Let a1 an be a not wool sequence We define another sequence called b in which bi is xor of the first i elements of a and b0 0 Now xor of elements of a consecutive subsequence like ai aj will be equal to So we know that all elements of b should be different Therefore b is a sequence of distinct integers of length n 1 starting with 0 made of numbers 0 to 2m 1 The number of such sequences is and this is the answer to problem 
https://codeforces.com//contest/321/problem/C,3265,C,321C,321,C. Ciel the Commander,Now Fox Ciel becomes a commander of Tree Land Tree Land like its name said has cities connected by undirected roads and for any two cities there always exists a path between them Fox Ciel needs to assign an officer to each city Each officer has a rank a letter from to So there will be 26 different ranks and is the topmost so is the bottommost There are enough officers of each rank But there is a special rule must obey if and are two distinct cities and their officers have the same rank then on the simple path between and there must be a city that has an officer with higher rank The rule guarantee that a communications between same rank officers will be monitored by higher rank officer Help Ciel to make a valid plan and if it s impossible output ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\n\nstruct Edge {\n\tint t;\n\tEdge(int t) :\n\t\t\tt(t) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\n\nbool del[MAX_N];\n\nint n;\n\nint size[MAX_N], opt[MAX_N];\nvector<int> all;\n\nvoid dfs(int u, int par) {\n\tall.push_back(u);\n\tsize[u] = 1;\n\topt[u] = 0;\n\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tif (e->t != par && !del[e->t]) {\n\t\t\tdfs(e->t, u);\n\t\t\tsize[u] += size[e->t];\n\t\t\topt[u] = max(opt[u], size[e->t]);\n\t\t}\n\t}\n}\n\nchar how[MAX_N];\n\nvoid solve(int rt, char ch) {\n\n\tall.clear();\n\tdfs(rt, -1);\n\n\tint minOpt = int(1e9), who = -1;\n\n\tfor (int i = 0; i < (int) all.size(); ++i) {\n\t\tint u = all[i];\n\t\topt[u] = max(opt[u], size[rt] - size[u]);\n\t\tif (opt[u] < minOpt) {\n\t\t\tminOpt = opt[u];\n\t\t\twho = u;\n\t\t}\n\t}\n\n\trt = who;\n\thow[rt] = ch;\n\tdel[rt] = true;\n\n\tfor (vector<Edge>::iterator e = E[rt].begin(); e != E[rt].end(); ++e) {\n\t\tif (!del[e->t]) {\n\t\t\tsolve(e->t, ch + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\t--a, --b;\n\t\tE[a].push_back(Edge(b));\n\t\tE[b].push_back(Edge(a));\n\t}\n\n\tsolve(0, \'A\');\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(""%c "", how[i]);\n\t}\n\tputs("""");\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'divide and conquer', 'greedy', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Ciel the Commander.json,https://codeforces.com//blog/entry/8192,This is a problem with construction on trees And for these kind of problems we usually use two method up down or down up So we have 1 solution for each method 1 up down construction Suppose we assign an officer with rank A at node x Then for two distinct subtree rooted by x says T1 and T2 There can t be any invalid path cross T1 and T2 because it is blocked by node x It s clear that we can t make 2 rank A officer So we can solve these subtree independently the only different is that we can t use rank A anymore Then the question is which node should x be It could be good if any subtree will has a small size And if you have the knowledge of centroid of tree then you can quickly find that if x be the centroid of this tree the subtree s size will be no more than half of the original tree So we only needs about log2 n nodes and 26 is enough 2 down up construction The above solution involves the concept of centroid of tree but you might not heard about that don t worry we have another solution can solve this problem without knowing that and it s easier to implement Suppose we choose 1 as the root and consider it as a directed tree and on some day we have the following problem We have some subtree rooted at T1 T2 Tk and they are already assigned an officer we need to assign an officer to node x and link them to this node Well a normal idea is we choose one with lowest possible rank The rank of x should satisfy So we can use this rule to choose the lowest possible rank But can it passes Yes it can but the proof is not such easy I ll introduce the main idea here 
https://codeforces.com//contest/353/problem/B,3644,B,353B,353,B. Two Heaps,Valera has cubes each cube contains an integer from to He arbitrarily chooses cubes and puts them in the first heap The remaining cubes form the second heap Valera decided to play with cubes During the game he takes a cube from the first heap and writes down the number it has Then he takes a cube from the second heap and write out its two digits near two digits he had written to the right of them In the end he obtained a single fourdigit integer the first two digits of it is written on the cube from the first heap and the second two digits of it is written on the second cube from the second heap Valera knows arithmetic very well So he can easily count the number of distinct fourdigit numbers he can get in the game The other question is how to split cubes into two heaps so that this number the number of distinct fourdigit integers Valera can get will be as large as possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nint poc[100];\n\nint main() {\n    cin.sync_with_stdio(0);\n    int N,a;\n    cin >> N;\n    vector<int> V(2*N);\n    vector< vector<int> > pos(100);\n    for(int i =0; i < 2*N; i++) {\n        cin >> a;\n        V[i] =a;\n        pos[a].push_back(i);\n        poc[a]++;}\n    \n    int ansA =0, ansB =0;\n    vector<int> S(2*N);\n    for(int i =0; i < 100; i++) if(poc[i] > 1) {\n        ansA++, ansB++;\n        S[pos[i][0]] =0;\n        S[pos[i][1]] =1;}\n    for(int i =0; i < 100; i++) if(poc[i] == 1) {\n        if(ansA < ansB) {ansA++; S[pos[i][0]] =0;}\n        else {ansB++; S[pos[i][0]] =1;}}\n    cout << ansA*ansB << ""\\n"";\n\n    for(int i =0; i < 100; i++) for(int j =2; j < poc[i]; j++) {\n        if(ansA < N) {ansA++; S[pos[i][j]] =0;}\n        else {ansB++; S[pos[i][j]] =1;}}\n    for(int i =0; i < 2*N; i++) cout << S[i]+1 << ((i == 2*N-1)?""\\n"":"" "");\n    return 0;}\n']",,,"['combinatorics', 'constructive algorithms', 'greedy', 'implementation', 'math', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Two Heaps.json,https://codeforces.com/blog/entry/9145,Let s say for shortness that we put numbers that are painted on cubes in piles instead of cubes themselves Note that the answer is the product of where is the number of different numbers in the th pile Let s consider that all numbers are different In this case the answer is Now let s suppose that we have two equal numbers and all the other are different Then if we put them in different piles the answer will be but if we put them in one Obviously the first case give greater product Thinking in similar manner you can conclude that we should do the following Take numbers that appear more than once and put one of them in the first pile one of them in the second pile and the other put aside After that divide the numbers that appears once in two equal part and put the first part in the first pile and second part in the second pile Finally take the numbers that we put aside and separate them in two pile in any kind 
https://codeforces.com//contest/355/problem/A,3661,A,355A,355,A. Vasya and Digital Root,Vasya has recently found out what a digital root of a number is and he decided to share his knowledge with you Let s assume that is the sum of digits of number for example Then the digital root of number equals to if if For example Vasya is afraid of large numbers so the numbers he works with are at most For all such numbers he has proved that Now Vasya wants to quickly find numbers with the given digital root The problem is he hasn t learned how to do that and he asked you to help him You task is given numbers and find the number consisting of exactly digits the leading zeroes are not allowed with digital root equal to or else state that such number does not exist ,"['#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tint k,d;\n\tcin >> k >> d;\n\tif (k>1 && d==0) {cout << ""No solution""; return 0;}\n\tcout << d;\n\tfor(int i=0; i<k-1; i++) cout << ""0"";\n\tcin >> k;\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Vasya and Digital Root.json,https://codeforces.com//blog/entry/8672,If the there is the only number with so if the answer is otherwise If then one of correct numbers is Time complexity for the output 
https://codeforces.com//contest/997/problem/D,194453,D,997D,997,D. Cycles in product,Consider a tree that is an undirected connected graph without loops T 1 and a tree T 2 Let s define their T 1 times T 2 in a following way Let V be the set of vertices in T 1 and U be the set of vertices in T 2 Then the set of vertices of graph T 1 times T 2 is V times U that is a set of ordered pairs of vertices where the first vertex in pair is from V and the second from U Let s draw the following edges Between v u 1 and v u 2 there is an undirected edge if u 1 and u 2 are adjacent in U Similarly between v 1 u and v 2 u there is an undirected edge if v 1 and v 2 are adjacent in V Please see the notes section for the pictures of products of trees in the sample tests Let s examine the graph T 1 times T 2 How much cycles not necessarily simple of length k it contains Since this number can be very large print it modulo 998244353 The sequence of vertices w 1 w 2 w k where w i in V times U called cycle if any neighboring vertices are adjacent and w 1 is adjacent to w k Cycles that differ only by the cyclic shift or direction of traversal are still considered ,"['#pragma GCC optimize(""-O3"",""-funroll-all-loops"")\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint k;\n#define SZ 233333\nll fac[SZ],rfac[SZ];\nconst int MOD=998244353;\nll kk[SZ];\nstruct Tree\n{\nint n; Edg\nvoid inpe()\n{\n\tfor(int i=1,a,b;i<n;++i)\n\t\tscanf(""%d%d"",&a,&b),adde(a,b);\n}\nll cd[4005][88],cu[4005][88];\nint fa[4005];\nvoid d1(int x,int f=0)\n{\n\tfa[x]=f;\n\tfor esb(x,e,b) if(b!=f) d1(b,x);\n\tfor(int i=0;i<=k;++i) kk[i]=0;\n\tfor esb(x,e,b) if(b!=f)\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\tcd[x][0]=1;\n\tfor(int i=0;i<=k;++i)\n\t\tfor(int j=0;j<=i-2;++j)\n\t\t\t(cd[x][i]+=cd[x][i-j-2]*kk[j])%=MOD;\n}\nvoid d2(int x,int f=0)\n{\n\tfor(int i=0;i<=k;++i) kk[i]=cu[x][i];\n\tfor esb(x,e,b) if(b!=f)\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\tfor esb(x,e,b) if(b!=f)\n\t{\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]-=cd[b][i])%=MOD;\n\t\tcu[b][0]=1;\n\t\tfor(int i=0;i<=k;++i)\n\t\t\tfor(int j=0;j<=i-2;++j)\n\t\t\t\t(cu[b][i]+=cu[b][i-j-2]*kk[j])%=MOD;\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\t}\n\tfor esb(x,e,b) if(b!=f) d2(b,x);\n}\nll cyc[4005][88];\nvoid gencyc()\n{\n\td1(1); d2(1);\n\tfor(int x=1;x<=n;++x)\n\t{\n\t\tfor(int i=0;i<=k;++i) kk[i]=cu[x][i];\n\t\tfor esb(x,e,b) if(b!=fa[x])\n\t\t\tfor(int i=0;i<=k;++i)\n\t\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\t\tcyc[x][0]=1;\n\t\tfor(int i=0;i<=k;++i)\n\t\t\tfor(int j=0;j<=i-2;++j)\n\t\t\t\t(cyc[x][i]+=cyc[x][i-j-2]*kk[j])%=MOD;\n\t}\n}\n}T1,T2;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nll s1[88],s2[88];\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i) fac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i;--i) rfac[i-1]=rfac[i]*i%MOD;\n\tscanf(""%d%d%d"",&T1.n,&T2.n,&k);\n\tif(k&1)\n\t{\n\t\tputs(""0"");\n\t\treturn 0;\n\t}\n\tT1.inpe(); T2.inpe(); T1.gencyc(); T2.gencyc();\n\tll ans=0;\n\tfor(int i=1;i<=T1.n;++i)\n\t\tfor(int t=0;t<=k;++t)\n\t\t\t(s1[t]+=T1.cyc[i][t])%=MOD;\n\tfor(int i=1;i<=T2.n;++i)\n\t\tfor(int t=0;t<=k;++t)\n\t\t\t(s2[t]+=T2.cyc[i][t])%=MOD;\n\tfor(int t=0;t<=k;++t)\n\t\tans+=s1[t]*s2[k-t]%MOD\n\t\t*rfac[t]%MOD*rfac[k-t]%MOD,ans%=MOD; \n\tans=ans*fac[k]%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<""\\n"";\n}\n']",,,"['combinatorics', 'divide and conquer', 'trees']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Cycles in product.json,https://codeforces.com/blog/entry/60357,Consider an arbitrary cycle in a graph product Due to the definition of the product the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree This way if you write the edges corresponding to one tree in a separate list you will get a cycle in this tree Also if we have a cycle in one tree of length and a cycle of length in the second tree we can make cycles in the product Thus the problem is reduced to calculating for each length up to the number of cycles in each tree separately and then mixing them into cycles in the product Let s select the centroid of the tree and count all cycles which go through it delete centroid and then recursively count in remaining components How looks cycle which goes through We need to start in some vertex then go to not going through in between and then go back to possibly going through Let s define two dp s number of ways to go from to by exactly steps not going through in between number of ways to go from to but without previous limitation This way the answer for through centroid in convolution of Case where should be processed separately in this case we can simply How much time it takes to compute dp In fact it is is equal to sum of where is neighbor of Since the graph is tree there are neighbors in total and transitions is counted the same way but with removed transitions through The final complextiy is is for centroid decomposition On one level we need to compute dp and then compute convolution so it is Solution can be optimized with fast polynomial multiplication leading to complexity but it wasn t required 
https://codeforces.com//contest/277/problem/A,2667,A,277A,277,A. Learning Languages,The BerCorp company has got employees These employees can use approved official languages for the formal correspondence The languages are numbered with integers from to For each employee we have the list of languages which he knows This list could be empty i e an employee may know no official languages But the employees are willing to learn any number of official languages as long as the company pays their lessons A study course in one language for one employee costs berdollar Find the minimum sum of money the company needs to spend so as any employee could correspond to any other one their correspondence can be indirect i e other employees can help out translating ,"[""#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define MAXV 110\n\nint parent[MAXV],rank[MAXV];\n\nvoid init(int n){\n    int i;\n    REP(i,n) {parent[i] = i; rank[i] = 1;}\n}\n\nint root(int x){\n    if(parent[x] != x) parent[x] = root(parent[x]);\n    return parent[x];\n}\n\nvoid connect(int x, int y){\n    int rx=root(x),ry=root(y);\n    if(rx == ry) return;\n    if(rank[rx] > rank[ry]) {parent[ry] = rx; rank[rx] += rank[ry];}\n    if(rank[rx] <= rank[ry]) {parent[rx] = ry; rank[ry] += rank[rx];}\n}\n\nbool a[110][110];\n\nint main(void){\n    int N,M,K,i,j,k,x;\n    \n    cin >> N >> M;\n    REP(i,N){\n        cin >> K;\n        REP(j,K){\n            cin >> x;\n            a[i][x-1] = true;\n        }\n    }\n    \n    bool nonzero = false;\n    REP(i,N) REP(j,M) if(a[i][j]) nonzero = true;\n    if(!nonzero){\n        cout << N << endl;\n        return 0;\n    }\n    \n    init(N);\n    \n    REP(i,N) REP(j,N) if(i < j){\n        bool found = false;\n        REP(k,M) if(a[i][k] && a[j][k]) found = true;\n        if(found){\n            connect(i, j);\n        //  cout << i << ' ' << j << endl;\n        }\n    }\n    \n    int comp = 0;\n    REP(i,N) if(root(i) == i) comp++;\n    cout << comp - 1 << endl;\n    \n    return 0;\n}\n""]",,,"['dfs and similar', 'dsu']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Learning Languages.json,https://codeforces.com//blog/entry/6815,Build bipartite graph with nodes for employees and nodes for languages If an employee initially knows a language than there will be an edge between corresponding nodes Now the problem is simple add the minimal number of edges in such a way that all the employees will be in the same connected component Obviously this number equals to the number of initially connected components containing at least one employee minus one But there is one exception pretest 4 if initially everyone knows no languages we ll have to add edges because we can t add the edges between employees remember that the graph is bipartite 
https://codeforces.com//contest/2043/problem/B,3103847,B,2043B,2043,B. Digits,Artem wrote the digit d on the board exactly n times in a row So he got the number dddddd dots ddd exactly n digits Now he is curious about which digits from 1 to 9 divide the number written on the board ,"['#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(""1.in"", ""r"", stdin);  freopen(""1.out"", ""w"", stdout);}using ll = long long;\xa0void Solve() {  int n, d;  cin >> n >> d;  vector<int> ans;  ans.push_back(1);  if((d % 3 == 0) || (n >= 3)) ans.push_back(3);  if(d == 5) ans.push_back(5);  if((d == 7) || (n >= 3)) ans.push_back(7);  if(d % 9 == 0) ans.push_back(9);  else if(d % 3 == 0) {    if(n >= 3) ans.push_back(9);  }else {    if(n >= 6) ans.push_back(9);  }  for(int x : ans) cout << x << "" "";  cout << ""\\n"";}\xa0int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T;  cin >> T;  while(T--) Solve();  return 0;}']",,,"['math', 'number theory']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Digits.json,https://codeforces.com//blog/entry/137801,There are several ways to solve this problem I will describe two of them We can try divisibility rules for all odd integers from to and find out whether they work for our numbers is always the answer since every integer is divisible by a number is divisible by iff its sum of digits is divisible by Since our number consists of digits then either or should be divisible by so or a number is divisible by iff its sum of digits is divisible by This is a bit trickier than the case with because it is possible that both and are divisible by not and it makes the sum of digits divisible by a number is divisible by iff its last digit is or Just check that and that s it probably the trickiest case a number is divisible by iff when this number is split into blocks of digits possibly with the first block shorter than digits the sign alternating sum of these blocks is divisible by Like is divisible by because is divisible by If we apply this rule to our numbers from the problem we can use the fact that when the number can be split into several blocks of length and each such block changes the alternating sum by So if or our number is divisible by First we actually need a little bit of math If you take a number consisting of digits equal to it is always divisible by digits equal to This is because if you write some integer repeatedly the resulting number will be divisible by the original number like for example is divisible by So if for some the number is divisible by some digit then for the number will also be divisible for some digit This means that there exists an integer such that for all integers the results are the same if you use the same digit So we can set and if is small enough use brute force What is the value of The samples tell us that the number consisting of ones is divisible by and and divisibility by depends only on so you can actually use It is also possible to reduce to but this is not required So the solution is reduce to something like if it is greater than then use brute force You can either calculate the remainder of a big number modulo small number using a for loop or if you code in Java or Python use built in big integers just be careful with Python modern versions of it forbid some operations with integers longer than digits you might need to override that behavior 
https://codeforces.com//contest/935/problem/E,158425,E,935E,935,E. Fafa and Ancient Mathematics,Ancient Egyptians are known to have understood difficult concepts in mathematics The ancient Egyptian mathematician Ahmes liked to write a kind of arithmetic expressions on papyrus paper which he called as An can be defined as is an Ahmes arithmetic expression where is a one digit positive integer is an Ahmes arithmetic expression where and are valid Ahmes arithmetic expressions without spaces and is either plus or minus For example and are valid Ahmes arithmetic expressions On his trip to Egypt Fafa found a piece of papyrus paper having one of these Ahmes arithmetic expressions written on it Being very ancient the papyrus piece was very worn out As a result all the operators were erased keeping only the numbers and the brackets Since Fafa loves mathematics he decided to challenge himself with the following task Given the number of plus and minus operators in the original expression find out the maximum possible value for the expression on the papyrus paper after putting the plus and minus operators in the place of the original erased operators ,"['#pragma GCC optimize(""inline"")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int maxn = 1e4, maxk = 100;\nconst int inf = 1e9;\n\ninline void Min(int &a, int b) {\n  if (b < a) a = b;\n}\n\ninline void Max(int &a, int b) {\n  if (b > a) a = b;\n}\n\nstruct Node {\n  int lc, rc;\n} node[maxn];\n\nint cnt_node, n;\nchar s[maxn + 1];\n\nint size[maxn];\nint dpmax[maxn][maxk + 2];\nint dpmin[maxn][maxk + 2];\n\nint cntplus, cntminus;\nchar special;\n\nint cur;\n\nint Build(void) {\n  if (isdigit(s[cur])) {\n    node[cnt_node] = {-1, s[cur++] - \'0\'};\n    return cnt_node++;\n  }\n  int u = cnt_node++;\n  ++cur;\n  node[u].lc = Build();\n  ++cur;\n  node[u].rc = Build();\n  ++cur;\n  return u;\n}\n\nvoid Calc(int u) {\n  if (node[u].lc == -1) {\n    size[u] = 0;\n    dpmax[u][0] = dpmin[u][0] = node[u].rc;\n  } else {\n    int a = node[u].lc, b = node[u].rc;\n    size[u] = min(size[a] + size[b] + 1, maxk);\n    for (int i = 0; i <= size[u]; ++i) {\n      dpmax[u][i] = -inf;\n      dpmin[u][i] = inf;\n    }\n    for (int i = 0; i <= size[a]; ++i) {\n      for (int j = 0; j <= size[b]; ++j) {\n        if (i + j > size[u]) continue;\n        // take min\n        Min(dpmin[u][i + j + (special == \'+\')],\n            dpmin[a][i] + dpmin[b][j]);\n        Min(dpmin[u][i + j + (special == \'-\')],\n            dpmin[a][i] - dpmax[b][j]);\n        // take max\n        Max(dpmax[u][i + j + (special == \'+\')],\n            dpmax[a][i] + dpmax[b][j]);\n        Max(dpmax[u][i + j + (special == \'-\')],\n            dpmax[a][i] - dpmin[b][j]);\n      }\n    }\n  }\n}\n\nint main(void) {\n  scanf(""%s"", s);\n  n = strlen(s);\n  Build();\n  scanf(""%d%d"", &cntplus, &cntminus);\n  if (cntplus < cntminus) {\n    special = \'+\';\n  } else {\n    special = \'-\';\n  }\n  for (int i = cnt_node - 1; i >= 0; --i) {\n    Calc(i);\n  }\n  printf(""%d\\n"", dpmax[0][min(cntplus, cntminus)]);\n  return 0;\n}\n']",,,"['dfs and similar', 'dp', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Fafa and Ancient Mathematics.json,https://codeforces.com//blog/entry/57889,We can represent the arithmetic expression as a binary tree where each leaf node is a digit each non leaf node is an operator and the left and right subtrees are the operands To maximize the value of the sub expression represented by a subtree rooted at we will either put a plus operator at and maximize the values of and subtrees or put a minus operator at and maximize the value of subtree and minimize the value of subtree We can solve this task using DP keeping in mind the number of remaining operators of each type The DP state will be However this state will not fit in time or memory limits Since we can drop the larger of the last two parameters and implicitly calculate it from the other parameter and the subtree size 
https://codeforces.com//contest/1407/problem/A,718471,A,1407A,1407,A. Ahahahahahahahaha,Alexandra has an even length array a consisting of 0s and 1s The elements of the array are enumerated from 1 to n She wants to remove frac n 2 elements where n length of array in the way that alternating sum of the array will be equal 0 i e a 1 a 2 a 3 a 4 dotsc 0 In other words Alexandra wants sum of all elements at the odd positions and sum of all elements at the even positions to become equal The elements that you remove don t have to be consecutive For example if she has a 1 0 1 0 0 0 and she removes 2nd and 4th elements a will become equal 1 1 0 0 and its alternating sum is 1 1 0 0 0 Help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\n\nint n, te, x, cnt[2];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> te;\n    while (te--) {\n        cin >> n;\n        cnt[0] = cnt[1] = 0;\n        for (int i = 1; i <= n; i++) {\n            cin >> x;\n            cnt[x]++;\n        }\n        if (cnt[0] >= cnt[1]) {\n            cout << n / 2 << \'\\n\';\n            for (int i = 1; i <= n / 2; i++) {\n                cout << 0 << "" \\n""[i == n / 2];\n            }\n        } else {\n            int cur = cnt[1] / 2 * 2;\n            cout << cur << \'\\n\';\n            for (int i = 1; i <= cur; i++) {\n                cout << 1 << "" \\n""[i == cur];\n            }\n        }\n    }\n}\n']",,,"['constructive algorithms', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Ahahahahahahahaha.json,https://codeforces.com//blog/entry/82417,Let be the count of zeroes in the array count of ones Then if we remove all ones and alternating sum obliously equals Otherwise we remove all zeroes and if is odd plus another In this case alternating sum equals because count of remaining ones if even and we ll remove not more than 
https://codeforces.com//contest/1805/problem/F1,1861356,F1,1805F1,1805,F1. Survival of the Weakest  easy version ,Let a 1 a 2 ldots a n be an array of non negative integers Let F a 1 a 2 ldots a n be the sorted in the non decreasing order array of n 1 smallest numbers of the form a i a j where 1 le i j le n In other words F a 1 a 2 ldots a n is the sorted in the non decreasing order array of n 1 smallest sums of all possible pairs of elements of the array a 1 a 2 ldots a n For example F 1 2 5 7 1 2 1 5 2 5 3 6 7 You are given an array of non negative integers a 1 a 2 ldots a n Determine the single element of the array underbrace F F F ldots F n 1 a 1 a 2 ldots a n ldots Since the answer can be quite large output it modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(""YES"");\n\telse\n\t\tputs(""NO"");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(""yes"");\n\telse\n\t\tputs(""no"");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(""Yes"");\n\telse\n\t\tputs(""No"");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<\'0\'||c>\'9\')\n\t{\n\t\tif(c==\'-\')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>=\'0\'&&c<=\'9\')\n\t{\n\t\tx=x*10+c-\'0\';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar(\'-\'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+\'0\');\n//\tputchar(\'\\n\');\n}\ninline void fre()\n{\n\tfreopen("".in"",""r"",stdin);\n\tfreopen("".out"",""w"",stdout);\n}\nconstexpr int mod=1000000007;\nstruct node\n{\n\tint px,py,v;\n\tfriend bool operator<(node x,node y)\n\t{\n\t\treturn x.v>y.v;\n\t}\n};\nint ans=0;\nvector<int>f(vector<int>a)\n{\n\tvector<int>res;\n\tpriority_queue<node>q;\n\tfor(int i=1;i<a.size();i++)\n\t\tq.push({i-1,i,a[i-1]+a[i]});\n\tint t=a.size()-1;\n\twhile(t--)\n\t{\n\t\tres.push_back(q.top().v);\n\t\tnode x=q.top();\n\t\tq.pop();\n\t\tif(x.py+1<a.size())\n\t\t\tq.push({x.px,x.py+1,a[x.px]+a[x.py+1]});\n\t}\n\tans=(ans*2+res[0])%mod;\n\tint x=res[0];\n\tfor(int i=0;i<res.size();i++)\n\t\tres[i]-=x;\n\treturn res;\n}\nvoid work()\n{\n\tint n;\n\tvector<int>v;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tv.push_back(x);\n\t}\n\tsort(v.begin(),v.end());\n\twhile(v.size()>1)\n\t\tv=f(v);\n\tcout<<(ans)%mod;\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n//\tcases();\n\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n']",,,"['binary search', 'brute force', 'implementation', 'math', 'sortings']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F1. Survival of the Weakest  easy version .json,https://codeforces.com//blog/entry/114644,Firstly we will sort the array a1 a2 an and in the future we will always assume that all arrays in this problem are sorted Let s solve the problem for n 200 It may seem that with such constraints the problem is solved quite trivially we implement the function F for O n2logn and run it n 1 times to get an answer But there is one nuance with each iteration of F the numbers in the array can increase by 2 times for example if the array consists entirely of identical numbers which means that after only 40 operations we may have an overflow Note that it is impossible to take the numbers by modulo in the function F itself since then the sorted order will be lost and it will be impossible or very difficult to restore it using the remainder when dividing by 109 7 instead of the numbers themselves To avoid this we note an important property of the function F F a1 a2 an F a1 x a2 x an x x 2n 1 The intuition of this property is that if you subtract the same number from all the elements then the relative order of the elements will not change and will not change when using the F function Just after the first iteration of F 2x will be subtracted from all the numbers then 4x 8x etc in the end the original answer will be minus x 2n 1 This property can be proved more strictly by induction on n What does this wonderful property give us Now we can subtract the same number x from all the elements by first adding x 2n 1 to the answer It would be logical enough in any situation to subtract the minimum of the array from all its elements Thanks to this the minimum of the array will always be 0 and now we can work only with arrays whose minimum element is 0 which greatly simplifies our life This is one of the two key ideas in this problem So let s notice something interesting about the array F 0 a1 a2 an Observation F 0 a1 a2 an 1 a1 The proof is obvious let me remind you that the array is sorted Observation F 0 a1 a2 an n an Proof since 0 a1 a2 an has length n 1 F 0 a1 a2 an has length n Among all pairs of array elements 0 a1 a2 an there are n pairs of the form 0 ai and a1 a2 an This means that the original array has n pairs in which the sum is an So observation is proved These two observations give us that F 0 a1 a2 an a1 an And after subtracting the minimum a1 0 an a1 Thus if we always subtract the minimum each time after applying the F function the maximum in the array will be not increase Which allows us to work only with arrays of numbers from 0 to 109 where there naturally can be no problems with overflow So we got the solution for O n3logn Let s improve it to O n2logn The cornerstone in our previous solution is that we implement the function F for O n2logn which is pretty slow Let s learn how to implement it for O nlogn This is a fairly standard problem Note that if some pair of the form ai aj is included in the array F a1 a2 an then all pairs ai ai 1 ai ai 2 ai aj 1 will also be included in the array F a1 a2 an since the sum in these pairs is no more than ai aj We will build the array F a1 a2 an one element at a time starting with the smallest Let s denote the array in which we will add these numbers for B initially B is empty For each index i we will store the minimum index ji i such that the pair ai aj is still not taken in B Initially ji i 1 We will mantain all numbers of the form ai aji in std priority queue Then to add the next element to B we will remove the minimum element from the queue then increase the corresponding ji by one and add the element ai aji to the queue again After n 1 of such iteration we will get F a1 a2 an Each iteration takes O logn which means that the asymptotics of finding the function F is O nlogn In total we learned how to solve the problem in O n2logn Now we move on to the full solution for n 2 105 First we will show what the solution looks like and intuition behind it and a more strict proof will be at the end Let s ask ourselves when does the last element of the array 0 a1 a2 an affect the answer to the problem Very often we will lose any mention of the an element after the first transition 0 a1 an F 0 a1 an The minimum sum of a pair of elements including an is 0 an And there is an n 1 pair with not bigger sum 0 a1 0 a2 0 an 1 So the only case when an will enter the array F 0 a1 an is if a1 a2 an because otherwise the pair a1 a2 will be less than 0 an and there will be n pairs with a sum less than an n 1 pairs of the form 0 ai and the pair a1 a2 Well let s assume it really happened that a1 a2 an Then F 0 a1 an 0 a1 0 a2 0 an After subtracting the minimum 0 a2 a1 a3 a1 an a1 If we run F on this array again we get a2 a1 an a1 After subtracting the minimum 0 an a2 But remember that a1 a2 an Which means 2 a2 an Which means an a2 an2 It turns out that if an somehow remains in the array after two applications of the F functions then the last element of the array will be reduced by at least half This means that after just 2 log2an iterations of the F function either the an element will be completely evicted from the array or the array will shrink into 0 0 0 In both cases the original element an in no way will be taken into account in the final answer In no way The total number of times when the maximum is halved is no more than log2an which means intuitively it is approximately clear that elements with indexes greater than 2 log2an will not affect the answer in any way Therefore the full solution would be to leave the first K 64 elements of the array a a little more than 2 log2109 Then apply the function F to this array n K times but writing out K minimal elements not K 1 After that the length of the real array will also be equal to K and it remains only to run the function F K 1 times to get the final answer Final asymptotics O n KlogK where K 2log2an 2 64 Now let s give a strict proof that this solution works We are following K minimal elements 0 a1 aK 1 Technically there are also aK alen elements in the array But we have no information about their values However we know that all these elements are aK 1 since we maintain sorted order This means that the minimum sum of a pair of elements about which we have no information is also aK 1 The whole proof is based on this simple observation Firstly it is not difficult to understand that K minimum elements are exactly enough to recalculate K 1 minimum element in F a Since we have pairs of elements 0 a1 0 a2 0 aK 1 And the sum in each of these pairs is no more than aK 1 which means no more than the sum in any pair about which we have no information Therefore in any incomprehensible situation we can recalculate with the loss of one of the elements Let s see when it is possible to recalculate all K minimal elements Again the minimum element about which we have no information from 0 a1 aK 1 is 0 aK 0 aK 1 So if we find K elements that aK 1 then we can recalculate K minimal elements of F a through K minimal elements of a We have a K 1 pair of the form 0 ai as well as a pair a1 a2 So if a1 a2 aK 1 then we can recalculate all K minimal elements And if recalculation is not possible then a1 a2 aK 1 is executed Then having encountered such a situation we will recalculate twice with the loss of the last element thus reducing K by 2 After such a recalculation the last element will be at least half as small as it was before this is part of the main tutorial So after 2log2 A of such element removals the array will slide into 0 0 0 and everything is clear And if the number of removals is less than 2log2 A then one of the K elements will certainly live to the end and will be the answer to the problem Thus the correctness of the solution has been successfully proved Bonus for those who are still alive find a more accurate estimate for K and build a test on which this solution but keeping track of the K 1 minimum element one less than necessary will give the wrong answer 
https://codeforces.com//contest/1804/problem/C,1824142,C,1804C,1804,C. Pull Your Luck,While James is gone on business Vesper takes her time and explores what the legendary Casino Royale has to offer to people who are fond of competitive programming Her attention was grabbed by the very new Pull Your Luck roulette which functions in a pretty peculiar way The roulette s wheel consists of n sectors number from 0 to n 1 There is no ball and the winning sector is determined by a static arrow pointing to one of the sectors Sectors indexes go in the natural order and the wheel always spins in the direction of indexes increment That means that sector i 1 goes right after sector i for all i from 0 to n 2 and sector 0 goes right after sector n 1 After a bet is made the player is allowed to pull the triggering handle herself and cause the wheel to spin If the player s initial pull is made with the force equal to positive integer f the wheel will spin for f seconds During the first second it will advance f sectors the next second it will advance f 1 sectors then f 2 sectors and so on until it comes to a complete stop After the wheel comes to a complete stop the sector which the arrow is pointing to is the winning one The roulette s arrow currently points at sector x Vesper knows that she can pull the handle with any integer force from 1 to p inclusive Note that it is not allowed to pull the handle with force 0 i e not pull it all The biggest prize is awarded if the winning sector is 0 Now Vesper wonders if she can make sector 0 win by pulling the triggering handle exactly once ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, x, p;\n    std::cin >> n >> x >> p;\n    \n    for (int i = 1; i <= std::min(p, 2 * n); i++) {\n        if ((x + 1LL * i * (i + 1) / 2) % n == 0) {\n            std::cout << ""Yes\\n"";\n            return;\n        }\n    }\n    std::cout << ""No\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['brute force', 'greedy', 'math', 'number theory']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Pull Your Luck.json,https://codeforces.com//blog/entry/113830,Assuming the constraint on the the sum of n over all test cases we might want to simulate the process for each test case However we need an O n or other quasilinear complexity solution The key observation is that the sum of all integers from 1 to 2n inclusive is divisible by n Indeed sum i 1 2n i frac 2n 1 cdot 2n 2 2n 1 cdot n As the remainders of x of modulo n will repeat after 2n steps there is no point in trying values of x for more than min 2n p Question can you build the test that required Vesper to use x more than 100k There is exactly one such test 
https://codeforces.com//contest/1362/problem/C,640964,C,1362C,1362,C. Johnny and Another Rating Drop,The last contest held on Johnny s favorite competitive programming platform has been received rather positively However Johnny s rating has dropped again He thinks that the presented tasks are lovely but don t show the truth about competitors skills The boy is now looking at the ratings of consecutive participants written in a binary system He thinks that the more such ratings differ the more unfair is that such people are next to each other He defines the difference between two numbers as the number of bit positions where one number has zero and another has one we suppose that numbers are padded with leading zeros to the same length For example the difference of 5 101 2 and 14 1110 2 equals to 3 since 0101 and 1110 differ in 3 positions Johnny defines the unfairness of the contest as the sum of such differences counted for neighboring participants Johnny has just sent you the rating sequence and wants you to find the unfairness of the competition You have noticed that you ve got a sequence of integers from 0 to n That s strange but the boy stubbornly says that everything is right So help him and find the desired unfairness for received numbers ,"['#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint t; cin >> t;\n\n\twhile (t--) {\n\t\tll n; cin >> n;\n\t\tll res = 0;\n\t\twhile (n) {\n\t\t\tres += n;\n\t\t\tn /= 2;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}']",,,"['bitmasks', 'greedy', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Johnny and Another Rating Drop.json,https://codeforces.com//blog/entry/78355,Let us start by calculating the result for It can be quickly done by calculating the results for each bit separately and summing these up For th bit the result is equal to as this bit is different in and iff is a multiple of Summing these up we get that the result for is equal to How to compute the answer for arbitrary Let us denote as set bits in the binary representation of I claim that the answer is equal to the sum of answers for Why We can compute results for intervals We can notice that the result for interval where is a multiple of is equal to the answer for so we can just compute the results for intervals This allows us to compute the answer for arbitrary in just iterate over all bits and add if is set Equivalently we can just write down as the answer Final complexity is 
https://codeforces.com//contest/1829/problem/A,1910845,A,1829A,1829,A. Love Story,Timur loves codeforces That s why he has a string s having length 10 made containing only lowercase Latin letters Timur wants to know how many indices string s from the string For example string s differs from in 4 indices shown in bold Help Timur by finding the number of indices where string s differs from Note that you can t reorder the characters in the string s ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n\nstring a = ""codeforces"";\nstring b;\n\nvoid solve() {\n    cin >> b;\n    int res = 0;\n    rep(i, 0, min(a.size(), b.size()) - 1) {\n        res += (a[i] != b[i]);\n    }\n    cout << res << ""\\n"";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']",,,"['implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\A. Love Story.json,https://codeforces.com//blog/entry/116108,You need to implement what is written in the statement You need to compare the given string with the string character by character counting the number of differences We know that the length of is so we can simply iterate through both strings and compare each character at the same index If the characters are the same we move on to the next index If they are different we count it as a difference and move on to the next index Once we have compared all characters we output the number of differences 
https://codeforces.com//contest/1430/problem/D,755156,D,1430D,1430,D. String Deletion,You have a string s consisting of n characters Each character is either or You can perform operations on the string Each operation consists of two steps select an integer i from 1 to the length of the string s then delete the character s i the string length gets reduced by 1 the indices of characters to the right of the deleted one also get reduced by 1 if the string s is not empty delete the maximum length prefix consisting of the same characters the indices of the remaining characters and the string length get reduced by the length of the deleted prefix Note that both steps are mandatory in each operation and their order cannot be changed For example if you have a string s the first operation can be one of the following select i 1 we ll get rightarrow rightarrow select i 2 we ll get rightarrow rightarrow select i 3 we ll get rightarrow rightarrow select i 4 we ll get rightarrow rightarrow select i 5 we ll get rightarrow rightarrow select i 6 we ll get rightarrow rightarrow You finish performing operations when the string s becomes empty What is the maximum number of operations you can perform ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nchar s[200005];\nint q[200005],n;\nint rem[200005];\nbool check(int v){\n\tint p=1;\n\tFor(i,1,*q) rem[i]=q[i]-(i<=v);\n\tFor(i,1,v-1){\n\t\tp=max(p,i);\n\t\tfor (;p<=*q&&!rem[p];++p);\n\t\tif (p>*q) return 0;\n\t\t--rem[p];\n\t}\n\treturn 1;\n}\nvoid solve(){\n\tscanf(""%d\\n%s"",&n,s+1);\n\t//n=strlen(s+1);\n\tq[0]=1; q[1]=1;\n\tFor(i,2,n)\n\t\tif (s[i]==s[i-1])\n\t\t\t++q[*q];\n\t\telse q[++*q]=1;\n\t//For(i,1,*q) cout<<q[i]<<endl;\n\tint l=1,r=*q,ans=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(mid))\n\t\t\tans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']",,,"['binary search', 'data structures', 'greedy', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. String Deletion.json,https://codeforces.com//blog/entry/83614,Suppose the string consists of characters and each character is different from the adjacent ones so the string looks like or It s easy to see that we can t make more than operations each operation deletes at least two characters except for the case when the string consists of only one character And there is an easy way to perform exactly operations always choose the last character and delete it Okay what about the case when some adjacent characters in the string are equal It s never optimal to delete a character that s different from both adjacent characters since the second part of each operation always deletes the left block of equal characters this action merges two blocks so they will be deleted in one second part of the operation which decreases the total number of operations So we should always delete a character from a block with at least two equal characters From which of the blocks if there are more than one It s easy to see that we should choose a character from the leftmost such block since that block is the earliest to be deleted and if we want to make the same action later we might be unable to do it So the solution is greedy during each action we have to find the leftmost block consisting of at least equal characters and delete a character from it or the last character of the string if there are no such blocks Since the length of the string is up to and the number of operations is up to we should do it efficiently for example by storing the eligible blocks in some data structure 
https://codeforces.com//contest/955/problem/F,167748,F,955F,955,F. Heaps,You re given a tree with vertices rooted at We say that there s a ary heap of depth located at if the following holds For itself is a ary heap of depth For vertex is a ary heap of depth if of its children are ary heaps of depth Denote as maximum depth of ary heap in the subtree of including Your goal is to compute ,"['#include<bits/stdc++.h>\n#define RAN(v)v.begin(),v.end()\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\nusing namespace std;\ntemplate<class T1,class T2>\ninline void upd1(T1&a,T2 b){a>b?a=b:0;}\ntemplate<class T1,class T2>\ninline void upd2(T1&a,T2 b){a<b?a=b:0;}\ntypedef long long ll;\nstruct ano{\n\toperator ll(){\n\t\tll x=0,y=0,c=getchar();\n\t\twhile(c<48)\n\t\t\ty=c==45,c=getchar();\n\t\twhile(c>47)\n\t\t\tx=x*10+c-48,c=getchar();\n\t\treturn y?-x:x;\n\t}\n}buf;\nconst int N=3e5+5;\nvector<int>t[N];\nll s=0;\nint n,f[20][N],g[20][N];\nint dfs(int u,int p){\n\tint l=1;\n\tfor(int v:t[u])\n\t\tif(v!=p)\n\t\t\tupd2(l,dfs(v,u)+1);\n\ts+=l;\n\tf[1][u]=n;\n\tg[1][u]=n;\n\tfor(int i=2;;++i){\n\t\tvector<int>a;\n\t\tfor(int v:t[u])\n\t\t\tif(v!=p)\n\t\t\t\ta.pb(-f[i-1][v]);\n\t\tsort(RAN(a));\n\t\tf[i][u]=1;\n\t\tfor(int k=a.size();k>1;--k)\n\t\t\tif(-a[k-1]>=k){\n\t\t\t\tf[i][u]=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(f[i][u]==1)\n\t\t\tbreak;\n\t}\n\tfor(int i=2;;++i){\n\t\tfor(int v:t[u])\n\t\t\tif(v!=p)\n\t\t\t\tupd2(g[i][u],g[i][v]);\n\t\tupd2(g[i][u],f[i][u]);\n\t\ts+=(i-1)*(g[i-1][u]-g[i][u]);\n\t\tif(g[i][u]==1)\n\t\t\tbreak;\n\t}\n\treturn l;\n}\nint main(){\n\tn=buf;\n\tfor(int i=2;i<=n;++i){\n\t\tint u=buf,v=buf;\n\t\tt[u].pb(v);\n\t\tt[v].pb(u);\n\t}\n\tdfs(1,0);\n\tprintf(""%lld\\n"",s);\n}\n']",,,"['dp', 'trees']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Heaps.json,https://codeforces.com//blog/entry/58547,Denote as maximum depth of ary heap rooted at and as maximum depth of ary heap in the subtree of including Let children of vertex sort them in order of descending Then and So we can calculate dp for fixed in or in if we will use so we can solve the problem in For simplicity denote as Let s suppose that Note three facts when So we can solve the problem in Let s solve task in when For other s let s go in descending order and set the value of dp to and push this value up to the root for each vertices that have exactly children Note that the total number of vertices visited in pushes does not exceed Because if we arrive at vertex with it is useless to go up because everything there has already been updated Each vertex will be added exactly one time so complexity of this part is Let s use this idea to solve the problem in For each let s solve in and for let s use the idea above And when does not exceed Let will be minimal such that is equal to By definition will have at least children which are the heaps of depth 2 that is also vertices with at least children Let s sort by number of their children Then answer for will be maximal such that Let s precalculate it and when let s go in descending order by pushing up value from each with The total number of vertices visited in pushes does not exceed At worst case in each vertex will be pushed at first with value and then with value So we can solve the problem in which is better but still not enough Let maximal such that vertex contain ary heap of depth or if there are no such vertex This dp have states To recalculate we need to sort by descending order and find maximal such that So with sort complexity of this solution will be Let s go in descending order by pushing up value from each with The total number of vertices visited in pushes does not exceed because So the complexity of this solution wil be 
https://codeforces.com//contest/229/problem/C,1892,C,229C,229,C. Triangles,Alice and Bob don t play games anymore Now they study properties of all sorts of graphs together Alice invented the following task she takes a complete undirected graph with vertices chooses some edges and keeps them Bob gets the remaining edges Alice and Bob are fond of triangles in graphs that is cycles of length 3 That s why they wonder what total number of triangles is there in the two graphs formed by Alice and Bob s edges correspondingly ,"['/*\n * c.cpp\n *\n *  Created on: 2012-10-1\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = 1000000 + 10;\nint cnt[MAX_N];\ntypedef long long int64;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\t--a, --b;\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tlong long tot = 1LL * n * (n - 1) * (n - 2) / 6;\n\tlong long bad = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tbad += 1LL * cnt[i] * (n - 1 - cnt[i]);\n\t}\n\tcout << tot - bad / 2 << endl;\n\treturn 0;\n}\n']",,,"['combinatorics', 'graphs', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Triangles.json,https://codeforces.com//blog/entry/5437,Let s call Alice s edges simply edges and Bob s edges the antiedges For each edge pair of the initial complete graph that pass through the same vertices assign a weight for each pair of edges the weight 2 for each pair of edge and antiedge 1 and for each pair of antiedges 2 Now calculate the sum of all the weights Observe that each Alice s or Bob s triangle adds exactly 6 to the sum and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex If the degree of the vertex is then we should add to the final sum Since each triangle adds 6 to the sum then the answer is equal to the sum divided by 6 The complexity of the solution is Sample solution http pastie org 4897512 archived copy 
https://codeforces.com//contest/846/problem/D,121000,D,846D,846,D. Monitor,Recently Luba bought a monitor Monitor is a rectangular matrix of size But then she started to notice that some pixels cease to work properly Luba thinks that the monitor will become broken the first moment when it contains a square consisting entirely of broken pixels She knows that pixels are already broken and for each of them she knows the moment when it stopped working Help Luba to determine when the monitor became broken or tell that it s still not broken even after all pixels stopped working ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 514\n#define Q (N * N)\nint n , m , k , q , x[ Q ] , y[ Q ] , t[ Q ];\nint s[ N ][ N ] , c[ N ][ N ];\nbool broken( int cur ){\n  for( int i = 0 ; i <= n ; i ++ )\n    for( int j = 0 ; j <= m ; j ++ )\n      c[ i ][ j ] = 0;\n  for( int i = 0 ; i < q ; i ++ )\n    if( t[ i ] <= cur )\n      c[ x[ i ] ][ y[ i ] ] = 1;\n  for( int i = 1 ; i <= n ; i ++ )\n    for( int j = 1 ; j <= m ; j ++ )\n      if( c[ i ][ j ] ){\n        s[ i ][ j ] = min( s[ i - 1 ][ j ] ,\n                           min( s[ i ][ j - 1 ] , s[ i - 1 ][ j - 1 ] ) ) + 1;\n        if( s[ i ][ j ] >= k )\n          return true;\n      }else\n        s[ i ][ j ] = 0;\n  return false;\n}\nint main(){\n  cin >> n >> m >> k >> q;\n  for( int i = 0 ; i < q ; i ++ )\n    cin >> x[ i ] >> y[ i ] >> t[ i ];\n  int bl = 0 , br = 1000000000 , ba = -1;\n  while( bl <= br ){\n    int bmid = (bl + br) >> 1;\n    if( broken( bmid ) ) ba = bmid , br = bmid - 1;\n    else bl = bmid + 1;\n  }\n  cout << ba << endl;\n}\n']",,,"['binary search', 'data structures']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Monitor.json,https://codeforces.com//blog/entry/54357,At first let s sort broken pixels in non descending order by times they appear Obviously if the first broken pixels make monitor broken pixel won t fix it Thus binary search on answer will work Let s search for the first moment in time when the monitor becomes broken The function to check if in some moment monitor is broken looks the following way As we want to check if there is a submatrix of size which consists only of broken pixels let s precalc the array of partial sums is the number of broken pixels on submatrix from to is calculated as if is broken pixel otherwise Sum on submatrix of size then looks like Check all possible and from to and find out if there exists submatrix with sum equal to Overall complexity 
https://codeforces.com//contest/1905/problem/F,2384305,F,1905F,1905,F. Field Should Not Be Empty,You are given a permutation dagger p of length n We call index x if for all y x it holds that p y p x and for all y x it holds that p y p x We call f p the number of good indices in p You can perform the following operation pick 2 indices i and j and swap elements p i and p j Find the maximum value of f p after applying the aforementioned operation dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['// Problem: F. Field Should Not Be Empty\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/F\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#pragma GCC optimize(""Ofast,inline,unroll-loops"")\n// #define _GLIBCXX_DEBUG //T\n#include<bits/stdc++.h>\n#define File(s) freopen(#s"".in"",""r"",stdin),freopen(#s"".out"",""w"",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<""@""<<__LINE__<<""=""<<(x)<<\'\\n\')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=233333,M=1000000007;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\nnamespace SegTree{\n\tstruct Node;\n\tusing Tree=Node*;\n\tusing CTree=const Node*;\n\tstruct Info{\n\t\tint res,max;\n\t};\n\tstruct Node{\n\t\tInfo info;\n\t\tTree ls,rs;\n\t}pool[N<<1];\n\tTree pptr=pool;\n\tvoid clear(){\n\t\tpptr=pool;\n\t}\n\tint search(const CTree&a,const CTree&b){\n\t\tif(b->ls==nullptr)return a->info.max<b->info.max?b->info.res:0;\n\t\tif(a->info.max<b->ls->info.max)return search(a,b->ls)+b->info.res-b->ls->info.res;\n\t\treturn search(a,b->rs);\n\t}\n\tInfo operator+(const Node&a,const Node&b){\n\t\treturn {a.info.res+search(&a,&b),std::max(a.info.max,b.info.max)};\n\t}\n\t#define lchild id->ls,l,mid\n\t#define rchild id->rs,mid+1,r\n\tvoid build(Tree&id,int l,int r){\n\t\tid=new(pptr++)Node{0,-M,nullptr,nullptr};\n\t\tif(l==r){\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tbuild(lchild);\n\t\tbuild(rchild);\n\t\t// std::cerr<<id<<\' \'<<l<<\' \'<<r<<\' \'<<id->ls<<\' \'<<id->rs<<\'\\n\';\n\t\tid->info=*(id->ls)+*(id->rs);\n\t}\n\tvoid modify(int pos,const int&x,int flag,Tree id,int l,int r){\n\t\t// std::cerr<<pos<<\' \'<<id<<\' \'<<l<<\' \'<<r<<\'\\n\';\n\t\tif(l==r){\n\t\t\tid->info.res=flag;\n\t\t\tid->info.max=x;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tif(pos<=mid)modify(pos,x,flag,lchild);\n\t\telse modify(pos,x,flag,rchild);\n\t\t\n\t\tid->info=*(id->ls)+*(id->rs);\n\t}\n}\n\nsigned main(){\n\tusing namespace SegTree;\n\t// int n=g90,m=g90;\n\t// Tree rt;\n\t// build(rt,0,n);\n\t// // std::cerr<<rt<<\' \'<<rt->ls<<\' \'<<rt->rs<<\'\\n\';\n\t// for(;m--;){\n\t\t// int x=g90,y=g90;\n\t\t// modify(x,Frac(y,x),rt,0,n);\n\t\t// printf(""%d\\n"",rt->info.res-1);\n\t// }\n\tTree rt;\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tint n=g90;\n\t\tclear();\n\t\tbuild(rt,0,n);\n\t\tvi p=rvec(n,1);\n\t\tfor(int x=1;x<=n;++x){\n\t\t\tmodify(x,p[x],p[x]==x,rt,0,n);\n\t\t}\n\t\tint ans=0;\n\t\t// deb(rt->info.res);\n\t\tauto op=[&](int x,int y){\n\t\t\tassert(x!=y);\n\t\t\tmodify(x,p[y],p[y]==x,rt,0,n);\n\t\t\tmodify(y,p[x],p[x]==y,rt,0,n);\n\t\t\t// std::cerr<<x<<\' \'<<y<<\' \'<<rt->info.res<<\'\\n\';\n\t\t\tans=std::max(ans,rt->info.res);\n\t\t\tmodify(x,p[x],p[x]==x,rt,0,n);\n\t\t\tmodify(y,p[y],p[y]==y,rt,0,n);\n\t\t};\n\t\t\n\t\tvi pmx(n+2),smn(n+2);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tpmx[i]=(!pmx[i-1]||p[pmx[i-1]]<p[i]?i:pmx[i-1]);\n\t\t}\n\t\tfor(int i=n;i;--i){\n\t\t\tsmn[i]=(!smn[i+1]||p[smn[i+1]]>p[i]?i:smn[i+1]);\n\t\t}\n\t\tfor(int i=1;i<n;++i){\n\t\t\top(pmx[i],smn[i+1]);\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}();\n}']",,,"['brute force', 'data structures', 'divide and conquer']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Field Should Not Be Empty.json,https://codeforces.com//blog/entry/123384,SolutionThe key observation to this problem is that most swaps are useless In fact we can find that only swaps can increase our initial cost The first type of meaningful swaps is For each consider and such that and The second type is The reason why this is true is because the first type of swap can create a new good index since every good index must be a fixed point and the second type of swap can fix an already good index It s obvious that if a swap does neither of the above it can t increase our current cost Calculating after each swap can be done with a segment tree Consider adding one on the ranges Now an index is good if and only if its value is which is also the minimum value an index can have Thus our segment tree has to find the number of minimums while performing range additions which can be easily maintained by lazy propagation This solution works in time complexity 
https://codeforces.com//contest/1788/problem/A,1767771,A,1788A,1788,A. One and Two,You are given a sequence a 1 a 2 ldots a n Each element of a is 1 or 2 Find out if an integer k exists so that the following conditions are met 1 leq k leq n 1 and a 1 cdot a 2 cdot ldots cdot a k a k 1 cdot a k 2 cdot ldots cdot a n If there exist multiple k that satisfy the given condition print the smallest ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n    int x;\n    scanf(""%d"",&x);\n    return x;\n}\nconst int N=1e5+5;\nint n,a[N];\nvoid solve(){\n    n=in();\n    int cnt=0;\n    for(int i=1;i<=n;i++)a[i]=in(),cnt+=a[i]==2;\n    for(int i=1;i<=n;i++){\n        cnt-=(a[i]==2)*2;\n        if(cnt==0){cout<<i<<endl;return;}\n    }\n    cout<<-1<<endl;\n}\nint main(){\n    int T=in();\n    while(T--)solve();\n    return 0;\n}']",,,"['brute force', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. One and Two.json,https://codeforces.com//blog/entry/112584,There should be same number of at and By checking every we can solve the problem at By sweeping from to we can solve the problem in Not counting the number of but naively multiplying using sweeping in python was accepted since it has time complexity Checking every and naively multiplying solutions are so those solutions won t fit in time limit 
https://codeforces.com//contest/629/problem/A,48976,A,629A,629,A. Far Relatives Birthday Cake,Door s family is going celebrate Famil Doors s birthday party They love Famil Door so they are planning to make his birthday cake weird The cake is a square consisting of equal squares with side length Each square is either empty or consists of a single chocolate They bought the cake and randomly started to put the chocolates on the cake The value of Famil Door s happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake Famil Doors s family is wondering what is the amount of happiness of Famil going to be Please note that any pair can be counted no more than once as two different cells can t share both the same row and the same column ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define pll pair < ll, ll >\n#define all(s) s.begin(), s.end()\n#define sz(s) (int) s.size()\n#define vi vector < int >\n\nconst int inf = (int)1e9;\nconst int mod = (int) 1e9 + 7;\n\nint n;\nstring s[1111];\n\nint main () {\n    #ifdef LOCAL\n    freopen (""a.in"", ""r"", stdin);\n    freopen (""a.out"", ""w"", stdout);\n    #endif\n    cin >> n;\n    for(int i = 0; i < n; i++){\n    \tcin >> s[i];\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n    \tint cnt= 0;\n    \tfor(int j = 0; j < n; j++){\n    \t\tif(s[i][j] == \'C\') cnt++;\n    \t}\n    \tans += cnt * (cnt - 1)/2;\n    }\n    for(int i = 0; i < n; i++){\n    \tint cnt= 0;\n    \tfor(int j = 0; j < n; j++){\n    \t\tif(s[j][i] == \'C\') cnt++;\n    \t}\n    \tans += cnt * (cnt - 1)/2;\n    }\n    cout << ans << endl;\n    \n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n    #endif\n    return 0;\n}\n\n\n']",,,"['brute force', 'combinatorics', 'constructive algorithms', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Far Relatives Birthday Cake.json,https://codeforces.com//blog/entry/43227,Consider that we have chocolates in the row and chocolates in the column The answer to the problem would be It is obvious that every pair would be calculated exactly once as we have no more than one chocolate in the same square Time Complexity C Solution 
https://codeforces.com//contest/1201/problem/C,383826,C,1201C,1201,C. Maximum Median,You are given an array a of n integers where n is odd You can make the following operation with it Choose one of the elements of the array for example a i and increase it by 1 that is replace it with a i 1 You want to make the median of the array the largest possible using at most k operations The median of the odd sized array is the middle element after the array is sorted in non decreasing order For example the median of the array 1 5 2 3 5 is 3 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nint a[maxn];\n\nint main() {\n    int n, k; scanf(""%d%d"", &n, &k);\n    for (int i = 0; i < n; ++i) scanf(""%d"", &a[i]);\n    sort(a, a + n);\n\n    auto check = [&](int dt) {\n        long long sum = dt;\n        int p = a[n / 2] + dt;\n        for (int i = n / 2 + 1; i < n; ++i) {\n            if (a[i] < p) sum += p - a[i];\n        }\n        return sum <= k;\n    };\n\n    int ans = 0;\n    for (int d = 30; d >= 0; --d) {\n        if (ans + (1 << d) > k) continue;\n        if (check(ans + (1 << d))) ans += (1 << d);\n    }\n    printf(""%d\\n"", a[n / 2] + ans);\n    return 0;\n}\n']",,,"['binary search', 'greedy', 'math', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Maximum Median.json,https://codeforces.com/blog/entry/68911,Sort the array in non decreasing order In the new array you can make binary search with the maximum median value For a given median value it is required to make operations If this value is more than can t be median otherwise it can Time complexity 
https://codeforces.com//contest/1461/problem/C,829208,C,1461C,1461,C. Random Events,Ron is a happy owner of a permutation a of length n A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array Ron s permutation is subjected to m experiments of the following type r i p i This means that elements in range 1 r i in other words the prefix of length r i have to be sorted in ascending order with the probability of p i All experiments are performed in the same order in which they are specified in the input data As an example let s take a look at a permutation 4 2 1 5 3 and an experiment 3 0 6 After such an experiment with the probability of 60 ,"['//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<"" "";cout<<""\\n"";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int t;\n    cin>>t;\n    while(t--)\n    {\n       int n, m;\n       cin>>n>>m;\n       int ar[n+1];\n       for(int i=1;i<=n;i++)\n       cin>>ar[i];\n       int l=0;\n       for(int i=n;i>0;i--)\n       {\n           if(ar[i]!=i)\n           {\n               l=i;\n               break;\n           }\n       }\n       lld ans=1.0, ad=1.0;\n       while(m--)\n       {\n           int r;\n           lld p;\n           cin>>r>>p;\n           if(r>=l)\n           ans*=(ad-p);\n       }\n       if(l==0)\n       cout<<1<<""\\n"";\n       else\n       cout<<ad-ans<<""\\n"";\n    }\n}']",,,"['dp', 'math', 'probabilities']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Random Events.json,https://codeforces.com//blog/entry/85491,Let s first define some variable which will be equal to the last unsorted number the largest for which Now we can see that we are not interested in experiments with To get the answer we just need to multiply the remaining This number will indicate the probability that all the remaining experiments failed Since we need to deduce the probability of success we can subtract the resulting number from one 
https://codeforces.com//contest/208/problem/B,1578,B,208B,208,B. Solitaire,A boy named Vasya wants to play an old Russian solitaire called Accordion In this solitaire the player must observe the following rules A deck of cards is carefully shuffled then all cards are put on the table in a line from left to right Before each move the table has several piles of cards lying in a line initially there are piles each pile has one card Let s number the piles from left to right from 1 to During one move a player can take the whole pile with the maximum number that is the rightmost of remaining and put it on the top of pile if it exists or on the top of pile if it exists The player can put one pile on top of another one only if the piles top cards have the same suits or values Please note that if pile goes on top of pile then the top card of pile becomes the top card of the resulting pile Also note that each move decreases the total number of piles by 1 The solitaire is considered completed if all cards are in the same pile Vasya has already shuffled the cards and put them on the table help him understand whether completing this solitaire is possible or not ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<cstring>\n#include<iostream>\n#include<ctype.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<iomanip>\n#include<complex>\n#include<utility>\n\n#define X first\n#define Y second\n#define REP_0(i,n) for(int i=0;i<(n);++i)\n#define REP_1(i,n) for(int i=1;i<=(n);++i)\n#define REP_2(i,a,b) for(int i=(a);i<(b);++i)\n#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))\n#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)\n#define DOW_1(i,n) for(int i=(n);0<i;--i)\n#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)\n#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)\n#define FOREACH(a,b) for(typeof(b.begin()) a=(b).begin();a!=(b).end();++a)\n#define RFOREACH(a,b) for(typeof(b.rbegin()) a=(b).rbegin();a!=b.rend();++a)\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define IS insert\n#define ES erase\n#define IT iterator\n#define RI reserve_iterator\n#define PQ priority_queue\n#define LB lower_bound\n#define UB upper_bound\n\n#define PI 3.1415926535897932384626433832795\n#define EXP 2.7182818284590452353602874713527\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef double DB;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef pair<int,PII> PIII;\ntypedef pair<LD,int> PLDI;\ntypedef vector<PII> VII;\n\ntemplate<class T>\nT By(T x,T y,T P){\n\tT F1=0;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1+=x;\n\t\t\tif(F1<0||F1>=P)F1-=P;\n\t\t}\n\t\tx<<=1;\n\t\tif(x<0||x>=P)x-=P;\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Mul(T x,T y,T P){\n\tT F1=1;x%=P;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1=By(F1,x,P);\n\t\t}\n\t\tx=By(x,x,P);\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Gcd(T x,T y){\n\tif(y==0)return x;\n\tT z;\n\twhile(z=x%y){\n\t\tx=y,y=z;\n\t}\n\treturn y;\n}\n\nstruct EDGE{\n\tint T;EDGE *Nxt;\n};\n\ntemplate<class T>\nvoid UpdataMin(T &x,T y){\n\tif(y<x)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nvoid UpdataMax(T &x,T y){\n\tif(x<y)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nT Sqr(const T x){\n\treturn x*x;\n}\n\n#define MaxBuffer 20000000\nclass ReadBuffer{\n\tchar buff[MaxBuffer];\n\tchar *buf;\n\tvoid init(int size=MaxBuffer)\n\t{\n\t\tfread(buff,1,size,stdin);\n\t}\n\ttemplate<class T>\n\tbool readInterger(T &x)\n\t{\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag;\n\t\tflag=0;\n\t\tif(*buf==\'-\') flag=true;\n\t\telse x=*buf-\'0\';\n\t\twhile(isdigit(*++buf)) x=x*10+*buf-\'0\';\n\t\tif(flag) x=-x;\n\t\treturn true;\n\t}\n\ttemplate<class T>\n\tbool readFloat(T &x)\n\t{\n\t\tlong double nowpos=0.1;\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag,decimal;\n\t\tdecimal=flag=0;\n\t\tif(*buf==\'-\') flag=true,++buf;\n\t\telse if(*buf==\'.\') decimal=true;\n\t\twhile(isdigit(*buf)||*buf==\'.\')\n\t\t{\n\t\t\tif(*buf==\'.\') decimal=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(decimal)\n\t\t\t\t{\n\t\t\t\t\tx+=nowpos*(*buf-\'0\');\n\t\t\t\t\tnowpos*=0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx=x*10+*buf-\'0\';\n\t\t\t\t}\n\t\t\t}\n\t\t\t++buf;\n\t\t}\n\t\treturn true;\n\t}\n\tbool readChar(char c)\n\t{\n\t\tif(*buf==0) return 0;\n\t\treturn c=*buf++,1;\n\t}\n\tbool readString(char *s)\n\t{\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(!*buf) return false;\n\t\twhile(!isspace(*buf)) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn true;\n\t}\n\tint countSpacetonext(){\n\t\tint total=0;\n\t\twhile(*buf&&*buf==\' \') ++total,++buf;\n\t\treturn total;\n\t}\n\tbool splitBycharactor(char *s,char Split=\'\\n\'){\n\t\twhile(*buf&&*buf!=Split) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn *buf!=0;\n\t}\n};\n\nbool dp[55][55][55][55];\n\nchar card[55][5];\nint n;\n\nbool check(int i,int j){\n\treturn card[i][0]==card[j][0]||card[i][1]==card[j][1];\n}\nbool check3(){\n\tREP_1(i,n) if(!check(i,n)) return false;\n\treturn true;\n}\nbool checkall(){\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tif(dp[1][i][j][k]&&check(i,k)&&check(j,k))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n//\tfreopen(""a.out"",""w"",stdout);\n\tscanf(""%d"",&n);\n\tREP_1(i,n)\n\t{\n\t\tscanf(""%s"",card[i]);\n\t}\n\tif(n<=3)\n\t{\n\t\tprintf(""%s\\n"",check3()?""YES"":""NO"");\n\t}\n\telse\n\t{\n\t\tdp[n-2][n-2][n-1][n]=1;\n\t\tfor(int i=n-2;i>1;--i)\n\t\t{\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=1;l<=n;++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(dp[i][j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(check(i-1,l)) dp[i-1][l][j][k]=1;\n\t\t\t\t\t\t\tif(check(k,l)) dp[i-1][i-1][j][l]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(""%s\\n"",checkall()?""YES"":""NO"");\n\t}\n\tcin>>card[0];\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dp']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Solitaire.json,https://codeforces.com/blog/entry/4930,In this problem you could write breadth first search The state is the following four elements number of remaining piles and three strings three rightmost cards on the top of three rightmost piles We have two transitions in general case We can take the rightmost pile and shift it left by or on another pile If the number of remaining piles become at some moment print else print The number of states is the number of transitions so the complexity of solution is 
https://codeforces.com//contest/1936/problem/B,2503246,B,1936B,1936,B. Pinball,There is a one dimensional grid of length n The i th cell of the grid contains a character s i which is either or When a pinball is placed on one of the cells it moves according to the following rules If the pinball is on the i th cell and s i is the pinball moves one cell to the left in the next second If s i is it moves one cell to the right After the pinball has moved the character s i is inverted i e if s i used to be it becomes and vice versa The pinball stops moving when it leaves the grid either from the left border or from the right one You need to answer n queries In the i th query a pinball will be placed on the i th cell Note that we always place a pinball on the initial grid For each query calculate how many seconds it takes the pinball to leave the grid It can be shown that the pinball will always leave the grid within a finite number of steps ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nvector<pll> lew, pra;\n\nll wyn[nax];\n\nll suma(vector<pll> &wek, int ile)\n{\n\tint r=wek.size();\n\treturn wek.back().second-wek[r-ile-1].second;\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tlew.clear();\n\tpra.clear();\n\tlew.push_back({0, 0});\n\tpra.push_back({n+1, 0});\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (wcz[i]==\'<\')\n\t\t{\n\t\t\tll x=i+pra.back().second;\n\t\t\tpra.push_back({i, x});\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (pra.back().first==i)\n\t\t\tpra.pop_back();\n\t\tint l=(int)lew.size()-1;\n\t\tint p=(int)pra.size()-1;\n\t\tif (wcz[i]==\'<\')\n\t\t{\n\t\t\tif (l<=p)\n\t\t\t{\n\t\t\t\twyn[i]=i+suma(pra, l)*2-suma(lew, l)*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn[i]=n+1+i+suma(pra, p)*2-suma(lew, p+1)*2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l>=p)\n\t\t\t{\n\t\t\t\twyn[i]=n+1-i+suma(pra, p)*2-suma(lew, p)*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn[i]=-i+suma(pra, l+1)*2-suma(lew, l)*2;\n\t\t\t}\n\t\t}\n\t\tif (wcz[i]==\'>\')\n\t\t{\n\t\t\tll x=i+lew.back().second;\n\t\t\tlew.push_back({i, x});\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%lld "", wyn[i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'implementation', 'math', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Pinball.json,https://codeforces.com//blog/entry/126513,We observe that in fact only the to the left of and the to the right of change the direction of the pinball placed at position initially For convenience let s assume is and the pinball leaves from the left boundary for other situations we can handle them in a similar way We can obtain and through prefix sum binary search where represents the indices of to the left of in decreasing order and represents the indices of to the right of in increasing order We use and to describe the trace of the pinball The first segment the pinball moves from to The second segment the pinball moves from to The third segment the pinball moves from to The th segment the pinball moves from to the left boundary It is not difficult to observe that we can use prefix sum to store the sum of indices and then quickly calculate the time when the pinball moves 
https://codeforces.com//contest/313/problem/E,3097,E,313E,313,E. Ilya and Two Numbers,Ilya has recently taken up archaeology He s recently found two numbers written in the based notation Each of the found numbers consisted of exactly digits Ilya immediately started looking for information about those numbers He learned that the numbers are part of a cyphered code and the one who can decypher it can get the greatest treasure After considerable research Ilya understood that to decypher the code he should do the following Rearrange digits in the first number in some manner Similarly rearrange digits in the second number in some manner As a result of this operation the numbers can get leading zeroes Add numbers digit by digit modulo In other words we need to get the third number of length each digit of the number is the sum of the respective numbers of the found numbers For example suppose there are two numbers recorded in the ternary notation 001210 and 012111 then if you add them to each other digit by digit modulo 3 you will get number 010021 The key to the code is the maximum possible number that can be obtained in the previous step Help Ilya find the key to the code ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nint a[111111], b[111111];\nint la[111111], ra[111111];\nint Next[111111], Prev[111111];\nbool ma[111111], mb[111111];\n\nstruct data {\n    int i, j;\n    data (int _i, int _j) {\n        i = _i; j = _j;\n    }\n    inline friend bool operator < (data x, data y) {\n        return (a[x.i] + b[x.j]) % m < (a[y.i] + b[y.j]) % m;\n    }\n};\n\npriority_queue<data> f;\nset<int> idx;\n\nint main() {\n    // freopen(""E.in"", ""r"", stdin);\n\n    scanf(""%d%d"", &n, &m);\n    for(int i = 1; i <= n; i++) scanf(""%d"", a+i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", b+i);\n\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+n);\n    b[n+1] = m;\n    for(int i = 1; i <= n; i++)\n        idx.insert(-i);\n\n    memset(ma, 0, sizeof ma);\n    memset(mb, 0, sizeof mb);\n\n    for(int i = 1; i <= n; i++) {\n        int need = m-a[i]-1;\n        int l = 1, r = n+1;\n        while (l < r) {\n            int mid = (l+r)/2;\n            if (b[mid] <= need) l = mid+1;\n            else r = mid;\n        }\n        l--;\n        if (l) f.push(data(i, l));\n        if (l < n) f.push(data(i, n));\n    }\n\n    while (!f.empty()) {\n        data t = f.top(); f.pop();\n        if (!ma[t.i]) {\n            if (!mb[t.j]) {\n                printf(""%d "", (a[t.i] + b[t.j]) % m);\n                ma[t.i] = 1;\n                mb[t.j] = 1;\n                idx.erase(-t.j);\n            }\n            else {\n                set<int>::iterator it = idx.lower_bound(-t.j);\n                if (it != idx.end()) {\n                    t.j = -(*it);\n                    f.push(t);  \n                }\n                \n            }\n        }\n    }\n    return 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'dsu', 'greedy']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Ilya and Two Numbers.json,https://codeforces.com//blog/entry/7826, 1 Get the number of our sequences in sorted by frequencies Thus from the first sequence hereinafter the first type in a direct order from the second to the contrary 2 These numbers are put on the stack where if recording onto the stack of the second type we find the number at the top of the first type then this pair of extract and add to the answer 3 At the end obviously the stack we can find a number of properties of the second type and the first bottom on Then their grouping in response pairs with the start and end For better understanding you can look at solution 
https://codeforces.com//contest/1702/problem/G1,1456432,G1,1702G1,1702,G1. Passable Paths  easy version ,Polycarp grew a tree from n vertices We remind you that a tree of n vertices is an undirected connected graph of n vertices and n 1 edges that does not contain cycles He calls a set of vertices if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice The path can visit other vertices not from this set In other words a set of vertices is called if there is a simple path that passes through all the vertices of this set and possibly some other For example for a tree below sets 3 2 5 1 5 4 1 4 are and 1 3 5 1 2 3 4 5 are not Polycarp asks you to answer q queries Each query is a set of vertices For each query you need to determine whether the corresponding set of vertices is ,"['/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll int\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,m,g[21][N],h[N];\nvector<ll> ke[N],have[2];\nvoid dfs (ll u, ll p){\n    rv(v,ke[u]) if (v!=p){\n        h[v]=h[u]+1;\n        g[0][v]=u;\n        for (ll i=1;(1<<i)<=h[v];i++) g[i][v]=g[i-1][g[i-1][v]]; \n        dfs(v,u);\n    }\n}\nll lca (ll u, ll v){\n    if (u==v) return u;\n    if (h[u]<h[v]) swap(u,v);\n    reb(i,20,0) if ((h[u]-(1<<i)>=h[v])) u=g[i][u];\n    if (u==v) return u;\n    reb(i,20,0) if (g[i][u]!=g[i][v]) u=g[i][u],v=g[i][v];\n    return g[0][u]; \n}\nll park (ll u, ll k){\n    ll v=u;\n    reb(i,20,0) if (k&(1<<i)) v=g[i][v];\n    return v;\n}\nbool cmp (ll u, ll v){\n    return (h[u]>h[v]);\n}\nvector<ll> a;\nset<ll> st;\nvoid solo()\n{\n    cin>>n;\n    rep(i,1,n-1){\n        ll u,v;\n        cin>>u>>v;\n        ke[u].pb(v);\n        ke[v].pb(u);\n    }\n    dfs(1,0);\n    cin>>q;\n    while (q--){\n        cin>>m;\n        a.clear();\n        rep(i,1,m){\n            ll x;\n            cin>>x;\n            a.pb(x);\n        }\n        if (m==1){\n            cout<<""YES\\n""; continue;\n        }\n        ll all=a[0];\n        rv(i,a) all=lca(all,i);\n        st.clear();\n        rv(i,a) if (all!=i) st.insert(park(i,h[i]-h[all]-1));\n        if (st.size()>2){\n            cout<<""NO\\n""; continue;\n        }\n        ll S=*st.begin(),T=*st.rbegin();\n        sort(a.begin(),a.end(),cmp);\n        have[0].clear();\n        have[1].clear();\n        rv(i,a) if (i!=all){\n            if (lca(i,S)==S) have[0].pb(i);\n            else have[1].pb(i);\n        }\n        bool ok=1;\n        rep(i,0,1) if (!have[i].empty()){\n            ll c=have[i][0];\n            rv(u,have[i]) if (lca(u,c)!=u) ok=0;\n        }\n        if (ok) cout<<""YES\\n"";\n        else cout<<""NO\\n"";\n    }\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   //cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']",,,"['dfs and similar', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G1. Passable Paths  easy version .json,https://codeforces.com//blog/entry/104763,If the answer is then we can choose a subset of the tree vertices forming a simple path and containing all the vertices of our set Let s choose the minimum possible path its ends vertices from the set The constraints allow us to answer the query in hang the tree by one of the ends and check if it is true that there is only one selected vertex that does not have any selected ones in the subtree if there is one such vertex then it is the second end To make it easier to search for one of the ends we will hang the tree by any vertex before the queries calculate their depths and take the deepest of the set 
https://codeforces.com//contest/1077/problem/F1,256065,F1,1077F1,1077,F1. Pictures with Kittens  easy version ,Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of n consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the i th picture has beauty a i Vova wants to repost exactly x pictures in such a way that each segment of the news feed of at least k consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if k 1 then Vova has to repost all the pictures in the news feed If k 2 then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,"[""#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,k,a[N];\nll f[N][N];\nint main()\n{\n\tn=read(),k=read(),m=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tmemset(f,200,sizeof(f));\n\tf[0][0]=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tfor (int x=i-1;x>=max(0,i-k);x--)\n\t\t\tf[i][j]=max(f[i][j],f[x][j-1]+a[i]);\n\t\t}\n\t}\n\tfor (int i=n-1;i>=max(0,n-k+1);i--) f[n][m]=max(f[n][m],f[i][m]);\n\tif (f[n][m]<0) cout<<-1;\n\telse cout<<f[n][m];\n\treturn 0;\n}\n""]",,,['dp'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F1. Pictures with Kittens  easy version .json,https://codeforces.com//blog/entry/63274,Let s solve the problem using dynamic programming Let be the maximum total beauty of pictures if Vova is at the th picture now the number of remaining reposts is and Vova reposted the th picture Initially and all other values of are Let s learn to do some transitions to calculate this dynamic programming What is the way to do it Let s iterate over the position of the previously reposted picture and try to update using previously calculated values Obviously this position can be from to So let s iterate over the position let it be and if we need one more repost to repost the th picture is not then try to update pictures are indexed So where can we find the answer The answer is If this value is then the answer is Overall complexity is 
https://codeforces.com//contest/2007/problem/C,2845542,C,2007C,2007,C. Dora and C++,Dora has just learned the programming language C However she has completely misunderstood the meaning of C She considers it as two kinds of adding operations on the array c with n elements Dora has two integers a and b In one operation she can choose one of the following things to do Choose an integer i such that 1 leq i leq n and increase c i by a Choose an integer i such that 1 leq i leq n and increase c i by b Note that a and b are and they can be the same Let s define a of array d as max d i min d i For instance the range of the array 1 2 3 4 is 4 1 3 the range of the array 5 2 8 2 2 1 is 8 1 7 and the range of the array 3 3 3 is 3 3 0 After any number of operations possibly 0 Dora calculates the range of the new array You need to help Dora minimize this value but since Dora loves exploring all by herself you only need to tell her the minimized value ,"[""#include <bits/stdc++.h>using namespace std;\xa0const int maxN = 110000;int c[maxN];\xa0int main() {\tios::sync_with_stdio(0);\tcin.tie(0); cout.tie(0);\tint T;\tfor (cin >> T; T; T--) {\t\tint n, a, b; cin >> n >> a >> b;\t\tint g = __gcd(a, b);\t\tfor (int i = 0; i < n; i++) {\t\t\tcin >> c[i];\t\t\tc[i] %= g;\t\t}\t\tsort(c, c + n);\t\tint mn = c[n - 1] - c[0];\t\tfor (int i = 1; i < n; i++) {\t\t\tmn = min(mn, c[i - 1] + g - c[i]);\t\t}\t\tcout << mn << '\\n';\t}\treturn 0;}""]",,,"['math', 'number theory']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Dora and C++.json,https://codeforces.com//blog/entry/133382,Read the hints Consider First the answer is less than Otherwise you can always increase the minimum value by so that all elements are greater than Let s go over all possible minimum values say and we can do the operations so that all elements are in the range Then we can calculate the range and compare it with the answer There are possible minimum values so the process is too slow Consider first letting be the minimum and we do the operations to make in the range Then sort the array and try as the minimum in turn Suppose is the current minimum and is the largest integer such that If exists then is the maximum That s because for all and for all So we can do this in after sorting In the case of We can prove that this is equivalent to according to the Bezout s Identity Please search it yourself on https en wikipedia org wiki for the character cannot be displayed inside a link First the changes in value of each element must be a multiple of since are both multiples of Second we can always construct integers such that so we can perform some operations such that we only increase decrease an element by Time complexity 
https://codeforces.com//contest/479/problem/B,15734,B,479B,479,B. Towers,As you know all the kids in Berland love playing with cubes Little Petya has towers consisting of cubes of the same size Tower with number consists of cubes stacked one on top of the other Petya defines the of a set of towers as a value equal to the difference between the heights of the highest and the lowest of the towers For example if Petya built five cube towers with heights 8 3 2 6 3 the instability of this set is equal to 6 the highest tower has height 8 the lowest one has height 2 The boy wants the instability of his set of towers to be as low as possible All he can do is to perform the following operation several times take the top cube from some tower and put it on top of some other tower of his set Please note that Petya would never put the cube on the same tower from which it was removed because he thinks it s a waste of time Before going to school the boy will have time to perform no more than such operations Petya does not want to be late for class so you have to help him accomplish this task ,"['#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<cstring>\n#define rep(i,a,b) for (int i=a;i<=b;++i)\n#define dep(i,a,b) for (int i=a;i>=b;--i)\n#define For(i,u) for (int i=H[u];i;i=nxt[i])\n#define re(i,x) for (i=x.begin();i!=x.end();++i)\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 100005\nusing namespace std;\ntemplate<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c==\'-\')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-\'0\';if(fu)x=-x;};\ntemplate<class T> inline void read(T&x,T&y){read(x);read(y);}\ntemplate<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct S{int x,id;} a[N];\n//head\nint n,k;\nbool cmp(S a,S b) {return a.x<b.x;}\nstruct ass{int x,y;} q[N];int ans[N];\nint main() {\n\tread(n,k);rep(i,1,n)read(a[i].x),a[i].id=i;\n\tsort(a+1,a+n+1,cmp);ans[0]=a[n].x-a[1].x;\n\trep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}\n\tint pos=0,mx=ans[0];\n\trep(i,1,k) if (ans[i]<mx) mx=ans[i],pos=i;\n\tprintf(""%d %d\\n"",mx,pos);\n\trep(i,1,pos) printf(""%d %d\\n"",q[i].x,q[i].y);\n\treturn 0;\n}']",,,"['brute force', 'constructive algorithms', 'greedy', 'implementation', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Towers.json,https://codeforces.com//blog/entry/14351,The task is solved greedily In each iteration move the cube from the tallest tower to the shortest one To do this each time find the position of minimum and maximum in the array of heights in linear time 
https://codeforces.com//contest/1987/problem/A,2726560,A,1987A,1987,A. Upload More RAM,You want to upload n GBs of RAM Every second you will upload either 0 or 1 GB of RAM However there is a restriction on your network speed in any k consecutive seconds you can upload only at most 1 GB of RAM in total Find the minimum number of seconds needed to upload n GBs of RAM ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, ""/stack:200000000"")#pragma GCC optimize(""O3"")//~ #pragma GCC target (""avx2"")//~ #pragma GCC optimize(""Ofast"")//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")//~ #pragma GCC optimize(""unroll-loops"")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>\xa0using namespace __gnu_pbds;using namespace std;\xa0template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\xa0#define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << ""("" << d.first << "", "" << d.second << "")"";}sim dor(rge<c> d) {  *this << ""["";  for (auto it = d.b; it != d.e; ++it)    *this << "", "" + 2 * (it == d.b) << *it;  ris << ""]"";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\xa0#define shandom_ruffle random_shuffle\xa0using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=1000*1007;\xa0\xa0void test(){\tll n, k;\tscanf(""%lld%lld"", &n, &k);\tprintf(""%lld\\n"", n+(n-1)*(k-1));}\xa0int main(){\tint t;\tscanf(""%d"", &t);\twhile(t--)\t\ttest();\treturn 0;}']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. Upload More RAM.json,https://codeforces.com//blog/entry/131053,First of all note that you can upload GBs of RAM if you upload on the seconds taking seconds in total Let s show that it s impossible to do better Suppose there is a solution where you upload on the times taking seconds to upload GBs Then for all Furthermore Thus we have the following inequalities Using them we get the inequalities So so the answer is at least Since there is always a way to upload in exactly this many seconds this is the answer to our problem Complexity 
https://codeforces.com//contest/1775/problem/E,1730877,E,1775E,1775,E. The Human Equation,Petya and his friend the robot Petya went to BFDMONCON where the costume contest is taking place today While walking through the festival they came across a scientific stand named after Professor Oak and Golfball where they were asked to solve an interesting problem Given a sequence of numbers a 1 a 2 dots a n you can perform several operations on this sequence Each operation should look as follows You choose some subsequence dagger Then you call all the numbers at odd positions in this subsequence and all the numbers at even positions in this subsequence In this case only the position of the number in the subsequence is taken into account not in the original sequence For example consider the sequence 1 4 2 8 5 7 3 6 9 and its subsequence shown in bold 1 mathbf 4 mathbf 2 8 mathbf 5 7 3 mathbf 6 9 Then the numbers 4 and 5 are and the numbers 2 and 6 are After that you can do one of the following add 1 to all northern numbers and subtract 1 from all south numbers or add 1 to all southern numbers and subtract 1 from all northern numbers Thus from the sequence 1 mathbf 4 mathbf 2 8 mathbf 5 7 3 mathbf 6 9 if you choose the subsequence shown in bold you can get either 1 mathbf 5 mathbf 1 8 mathbf 6 7 3 mathbf 5 9 or 1 mathbf 3 mathbf 3 8 mathbf 4 7 3 mathbf 7 9 Then the operation ends Note also that all operations are independent i e the numbers are no longer called or when one operation ends It is necessary to turn all the numbers of the sequence into zeros using the operations described above Since there is very little time left before the costume contest the friends want to know what is the minimum number of operations required for this The friends were unable to solve this problem so can you help them dagger A sequence c is a subsequence of a sequence d if c can be obtained from d by the deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n;\nint arr[200005];\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tcin>>n;\n\t\trep(x,1,n+1) cin>>arr[x];\n\t\t\n\t\tint add=0,sub=0;\n\t\trep(x,1,n+1){\n\t\t\tif (arr[x]>0){\n\t\t\t\tadd=max(add,arr[x]);\n\t\t\t\tadd-=arr[x];\n\t\t\t\tsub+=arr[x];\n\t\t\t}\n\t\t\tif (arr[x]<0){\n\t\t\t\tarr[x]=-arr[x];\n\t\t\t\tsub=max(sub,arr[x]);\n\t\t\t\tsub-=arr[x];\n\t\t\t\tadd+=arr[x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<add+sub<<endl;\n\t}\n}\n']",,,"['greedy', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The Human Equation.json,https://codeforces.com//blog/entry/111286,Let s calculate an array of prefix sums What do the operations look like in this case If we calculate the array of prefix sums we ll see that the operations now look like add 1 on a subsequence or take away 1 on a subsequence Why If we take the indices and and apply our operation to them i e and it will appear that we added on the segment in the prefix sums array We still need to make the array all zeros How We will add to all elements that are less than zero then subtract from all elements that are greater than From this we get that the answer is the difference between the maximum and minimum prefix sums 
https://codeforces.com//contest/528/problem/B,24748,B,528B,528,B. Clique Problem,The clique problem is one of the most well known NP complete problems Under some simplification it can be formulated as follows Consider an undirected graph It is required to find a subset of vertices of the maximum size such that any two of them are connected by an edge in graph Sounds simple doesn t it Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph However as with many other NP complete problems the clique problem is easier if you consider a specific type of a graph Consider distinct points on a line Let the th point have the coordinate and weight Let s form graph whose vertices are these points and edges connect exactly the pairs of points such that the distance between them is not less than the sum of their weights or more formally Find the size of the maximum clique in such graph ,"['#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x "": "" << x << "" ""\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << ""{""; for(const T &a : v) out << a << "", ""; out << ""}""; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << ""("" << p.st << "", "" << p.nd << "")""; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int INF = 1000000000;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint n, res;\nint X[200010];\nint W[200010];\nint R[200010];\n\nstruct event {\n\tint i, type, x;\n};\n\nbool cmp(event a, event b){\n\tif(a.x != b.x) return a.x < b.x;\n\treturn a.type < b.type;\n}\n\nvector<event> E;\n\nint main(){\n\tscanf(""%d"", &n);\n\tevent e;\n\tFWD(i,0,n){\n\t\tscanf(""%d %d"", &X[i], &W[i]);\n\t\te.i = i;\n\t\te.type = 1;\n\t\te.x = X[i] - W[i];\n\t\tE.push_back(e);\n\t\te.type = -1;\n\t\te.x = X[i] + W[i];\n\t\tE.push_back(e);\n\t}\n\tsort(ALL(E), cmp);\n\tFWD(i,0,SIZE(E)){\n\t\te = E[i];\n//\t\tprintf(""event %d %d %d\\n"", e.i, e.type, e.x);\n\t\tif(e.type == -1) res = max(res, R[e.i]);\n\t\telse R[e.i] = res + 1;\n\t}\n\tprintf(""%d\\n"", res);\n\treturn 0;\n}\n\n']",,,"['dp', 'greedy']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Clique Problem.json,https://codeforces.com//blog/entry/17020,One may think that this task is about graph theory but it after some investigation and several equivalent changes in task statement it can be reduced to the well known greedy problem Initially you have that points may lie together in a set if they are not too close i e This is obviously equivalent to the following condition Let s consider interval of radius with center in point and call this interval to be the interval of point i Then the statement actually says that no two such intervals should be intersecting This task is well known and can be solved greedily after sorting segments in ascending order of right endpoint It s easy to prove that this solution is correct Among all ways to choose first segments the best way is the one that minimizes x coordinate of the right endpoint of the last segment since it restricts us in the least possible way Problem legend asks you to add minimum number of edges to the given connected undirected graph possibly with loops and duplicating edges and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even First idea is that the resulting graph before we choose the direction but after we added some edges will contain Euler circuit since all degrees are even That s almost what we need if we have an Euler circuit that contains even number of edges we may direct them like following a b c d e It s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree so the resulting degrees will be even But if the Euler circuit is odd meaning that there is odd number of edges in the graph we must add some extra edge to the graph before we continue the easiest way is to add a loop from vertex 0 to itself since it doesn t affect the Euler tour but now tour length is even so everything is ok Now we should think how to add edges optimally It s easy to see that the optimal way is to first fix all odd degrees of vertices i e combine all odd vertices by pairs and put an edge in each pair and then possibly add an extra loop as described above The last part is to actually find an Euler circuit and to print the answer There were issues with this task Intended constraints were actually and the intended solution was using Fast Fourier Transformation that leads to running time But unfortunately the statement contained wrong constraints so we reduced input size during the tour Nevertheless we will add the harder version of this task and you will be able to submit it shortly Key idea is to reduce this task to a polynomial multiplication Let s solve the task in following manner For each position i of the S for each character c from ATGC we will calculate match c i that is equal to the number of c characters that have matching symbol in S if we put string T in position i Then the criteria for us to have an occurrence at position i is that match A i match T i match G i match C i T that means exactly that each character from T being put at position i has a corresponding character in S Now let s find out how to calculate match c i Let s keep only c characters and not c characters in both strings and denote them by 1 and 0 respectively Let s also spread each 1 in string S by the distance k to the left and to the right For example k 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111 and for the character C it will be 0111001110 This bitvector can be calculated in by putting two events 1 and 1 in string S in positions and for each in original string S and then sweeping from left to right over the string S and processing those events Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S In constraints this can be done by using bitsets in Nevertheless this task can be seen as calculation of polynomials S and reversed T product We will keep this as an exercise for those who decide to submit the harder version of this task Let s draw a bounding box that contains all intersection points Let s fix a triangle and consider three angles shown on the picture Calculate area of intersection of those area with the bounding box and call this area to be the area of an angle Then it s easy to see that those three angles are complement to the triangle itself in the bounding box i e triangle area is bounding box area minus three angle areas This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane how much times does it appear in total answer if we sum all values like over all triples of lines Actually the angle is considered as many times as many lines there are that intersect both sides of its right adjacent angle So our task is reduced to calculate for each angle on plane how much lines intersect its sides i e its rays This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right Key idea is that the exact of four angles formed by the pair of lines that is crossed by some third line c can be determined by two numbers its polar angle alpha and its crossing with a coordinate x Further details are shown on the picture below There is also a nice short solution from enot110 here 
https://codeforces.com//contest/698/problem/D,65779,D,698D,698,D. Limak and Shooting Points,Bearland is a dangerous place Limak can t travel on foot Instead he has magic teleportation stones Each stone can be used The th stone allows to teleport to a point Limak can use stones There are monsters in Bearland The th of them stands at The given points are pairwise distinct After each teleportation Limak can shoot an arrow in some direction An arrow will hit the first monster in the chosen direction Then both an arrow and a monster disappear It s dangerous to stay in one place for long so Limak can shoot only one arrow from one place A monster should be afraid if it s possible that Limak will hit it How many monsters should be afraid of Limak ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint k,n,ax[N],ay[N],px[N],py[N];\nvector<PII> vec[N];\nmap<PII,int> hs;\nVI pr[10][N];\nint sht[N],vis[N];\nint gcd(int x,int y) { return x?gcd(y%x,x):y; }\nbool dfs(int rm,VI c) {\n/*\tputs(""-----state begin-----"");\n\tprintf(""%d\\n"",rm);\n\tfor (auto v:c) printf(""%d "",v); puts("""");\n\trep(i,0,n) printf(""%d "",sht[i]); puts("""");\n\trep(i,0,k) printf(""%d "",vis[i]); puts("""");\n\tputs(""-----state end-----"");*/\n\tif (SZ(c)==0) return 1;\n\tif (SZ(c)>rm) return 0;\n\tfor (auto v:c) {\n\t\tsht[v]=1;\n\t\trep(j,0,k) if (!vis[j]&&SZ(pr[j][v])<=7) {\n\t\t\tvis[j]=1;\n\t\t\tbool val=1;\n\t\t\tset<int> d(all(c)); d.erase(v);\n\t\t\tfor (auto pp:pr[j][v]) {\n//\t\t\t\tprintf(""%d %d %d\\n"",j,v,pp);\n\t\t\t\tif (sht[pp]) {\n\t\t\t\t\tval=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td.insert(pp);\n\t\t\t\tif (SZ(d)>rm) {\n\t\t\t\t\tval=0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (val) {\n\t\t\t\tif (dfs(rm-1,VI(all(d)))) return 1;\n\t\t\t}\n\t\t\tvis[j]=0;\n\t\t}\n\t\tsht[v]=0;\n\t}\n\treturn 0;\n}\nint main() {\n\tscanf(""%d%d"",&k,&n);\n\trep(i,0,k) scanf(""%d%d"",ax+i,ay+i);\n\trep(i,0,n) scanf(""%d%d"",px+i,py+i);\n\trep(z,0,k) {\n\t\trep(j,0,n+1) vec[j].clear();\n\t\ths.clear();\n\t\tint tot=0;\n\t\trep(j,0,n) {\n\t\t\tint x=px[j]-ax[z];\n\t\t\tint y=py[j]-ay[z];\n\t\t\tint d=gcd(x,y);\n\t\t\td=abs(d);\n\t\t\tx/=d; y/=d;\n\t\t\tif (!hs.count(mp(x,y))) hs[mp(x,y)]=tot++;\n\t\t\tvec[hs[mp(x,y)]].pb(mp(d,j));\n\t\t}\n\t\trep(i,0,tot) {\n\t\t\tsort(all(vec[i]));\n\t\t\tVI v;\n\t\t\tfor (auto p:vec[i]) {\n\t\t\t\tpr[z][p.se]=v;\n//\t\t\t\tprintf(""%d "",p.se);\n\t\t\t\tv.pb(p.se);\n\t\t\t}\n//\t\t\tputs("""");\n\t\t}\n//\t\tputs(""----"");\n\t}\n\tint ret=0;\n\trep(i,0,n) {\n\t\tmemset(sht,0,sizeof(sht));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(k,VI{i}))ret++;\n\t}\n\tprintf(""%d\\n"",ret);\n}\n']",,,"['brute force', 'geometry', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Limak and Shooting Points.json,https://codeforces.com//blog/entry/46148,Spoiler There are places and monsters For each of places let s sort monsters by angle Thanks to that for each pair place monster we will be able to know which monsters don t allow us do directly hit this monster from this place Let s iterate over monsters and for each of them independently check if it can be hit We want to get the complexity or We fixed a monster We want it to be hit in some moment So let s iterate over places considering which place will eventually hit a monster We fixed a place which will hit Thanks to the preprocessing sorting by angle at the beginning we are able to check if the fixed place can directly hit While we can t hit directly we find any blocking monster it may be e g the first monster in this direction looking from the fixed place Let s call it If we want to succeed then some place must hit Iterate over which place will hit Again check if it can directly hit now If yes then mark this place as used and as killed and go back to checking but with monster killed and thus not blocking us anymore Otherwise find any monster in this direction and again iterate over a place to hit it in the future While checking if a monster may be directly hit by some place remember that some monsters may be already killed and thus they don t block anything The above should give you the rough understanding of the solution Let s talk about the details and the implementation Iterate over a monster to check and over permutations of places Create a recursive function rec int monster to kill list int permutation Take the first place from the list and remove it for ever from the list This will be a place to eventually kill monster to kill maybe not now While there are any alive monsters between the fixed place and monster to kill choose any of those alive monsters and run rec that monster permutation Don t treat permutation as the order of teleportation stones to use It s only the order in which we take them from some stack list It only allows us to nicely simulate iterating over a place from which we want to get rid of some blocking monster Some words about the correctness Is it possible that the described solution isn t able to find a way to kill a monster while there exists a way In such a way there is some place from which Limak will hit the monster We simulated iterating over such a place We can t hit directly at the beginning only if there are some blocking monsters between the place and the monster Each of them must be hit from some place We don t assume anything about the order of monsters or about the order of places from which we hit In the optimal way every monster initially blocking us must be hit in some moment by some place so we can and must iterate over a place from which it will be hit If there are some new blocking monsters then again in the optimal way some place hits it and we iterate over it 
https://codeforces.com//contest/1051/problem/B,222358,B,1051B,1051,B. Relatively Prime Pairs,You are given a set of all integers from l to r inclusive l r r l 1 le 3 cdot 10 5 and r l is always odd You want to split these numbers into exactly frac r l 1 2 pairs in such a way that for each pair i j the greatest common divisor of i and j is equal to 1 Each number should appear in exactly one of the pairs Print the resulting pairs or output that no solution exists If there are multiple solutions print any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll L,R;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>L>>R;\n\tcout<<""YES""<<endl;\n\twhile(L<R) {\n\t\tcout<<L<<"" ""<<(L+1)<<endl;\n\t\tL+=2;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']",,,"['greedy', 'math', 'number theory']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Relatively Prime Pairs.json,https://codeforces.com//blog/entry/61969,Numbers with the difference of are always relatively prime That s the only thing I should mention for this editorial Overall complexity 
https://codeforces.com//contest/1464/problem/C,839212,C,1464C,1464,C. Poman Numbers,You ve got a string S consisting of n lowercase English letters from your friend It turned out that this is a number written in numerals The poman numeral system is long forgotten All that s left is the algorithm to transform number from poman numerals to the numeral system familiar to us Characters of S are numbered from 1 to n from left to right Let s denote the value of S as f S it is defined as follows If S 1 an arbitrary integer m 1 le m S is chosen and it is defined that f S f S 1 m f S m 1 S where S l r denotes the substring of S from the l th to the r th position inclusively Otherwise S c where c is some English letter Then f S 2 pos c where pos c is the position of letter c in the alphabet pos 0 pos 25 Note that m is chosen independently on each step Your friend thinks it is possible to get f S T by choosing the right m on every step Is he right ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\nint cnt[27];\n\nll T;\nll w[27];\n\nchar s[MAXN];\n\nint main()\n{\n\tscanf(""%d%lld%s"",&n,&T,s + 1);\n\tw[0] = 1;\n\tfor (int i = 1;i <= 26;i++)\n\t\tw[i] = w[i - 1] * 2;\n\tT -= w[s[n] - \'a\'];\n\tT += w[s[n - 1] - \'a\'];\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tT -= w[s[i] - \'a\'];\n\tif (T > 0)\n\t{\n\t\tputs(""No"");\n\t\treturn 0;\n\t}\n\tT = -T;\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tcnt[s[i] - \'a\' + 1]++;\n\tfor (int i = 26;i >= 0;i--)\n\t\twhile (cnt[i] && T >= w[i])\n\t\t{\n\t\t\tT -= w[i];\n\t\t\tcnt[i]--;\n\t\t}\n\tputs(!T ? ""Yes"" : ""No"");\n\treturn 0;\n}']",,,"['bitmasks', 'constructive algorithms', 'dp', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Poman Numbers.json,https://codeforces.com//blog/entry/85792,First note that the last digit will always be taken with a plus sign and the one before the last with a minus sign It turns out that all other digits may be taken with any sign Let s prove it Suppose we want to get the mask All minuses on the left can be obtained by simply splitting one character at a time We are left with the mask split it as follows That is we left in the left part only one minus from the last segment of consecutive minuses Change the signs in the left part We reduced it to a smaller problem Doing this we will end up with masks of the form Now the problem is reduced to whether we can get the number X using the first n 2 letters Since the weights of the items are powers of two we can choose them greedily 
https://codeforces.com//contest/1076/problem/C,253927,C,1076C,1076,C. Meme Problem,Try guessing the statement from this picture You are given a non negative integer d You have to find two non negative real numbers a and b such that a b d and a cdot b d ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 1e5 + 7;\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint d;\n\nvoid solve(){\n\tcin >> d;\n\tif(d == 1 || d == 2 || d == 3){\n\t\tputs(""N"");\n\t\treturn;\n\t}\n\t\n\tlong double delta = d * d - 4.0 * d;\n\tlong double b = (d - sqrt(delta)) / 2.0;\n\tlong double a = d - b;\n\tprintf(""Y %.12Lf %.12Lf\\n"", a, b);\n}\n\nint main(){\n//\tios_base::sync_with_stdio(false);\n//\tcin.tie(NULL);\n//\tcout.tie(NULL);\n\n\tint cases;\n\tcin >> cases;\n\twhile(cases--)\n\t\tsolve();\n\treturn 0;\n}\n']",,,"['binary search', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Meme Problem.json,https://codeforces.com/blog/entry/63151,To solve this problem we need to use some math and solve the equation on the paper If then and transforms to or Then where So if then or if there is no answer Since values are small calculating answer in was enough all we need to do is just output answer with sufficient number of digits after the decimal point 
https://codeforces.com//contest/1066/problem/D,235862,D,1066D,1066,D. Boxes Packing,Maksim has n objects and m boxes each box has size exactly k Objects are numbered from 1 to n in order from left to right the size of the i th object is a i Maksim wants to pack his objects into the boxes and he will pack objects by the following algorithm he takes one of the empty boxes he has goes from left to right through the objects and if the i th object fits in the current box the remaining size of the box is greater than or equal to a i he puts it in the box and the remaining size of the box decreases by a i Otherwise he takes the new empty box and continues the process above If he has no empty boxes and there is at least one object not in some box then Maksim cannot pack the chosen set of objects Maksim wants to know the maximum number of objects he can pack by the algorithm above To reach this target Your task is to say the maximum number of objects Maksim can pack in boxes he has Each time when Maksim tries to pack the objects into the boxes he will make empty all the boxes he has before do it and the relative order of the remaining set of objects will not change ,"['#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << \'=\' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << "" = {""; FOR(_, l, r) cerr << \' \' << a[_]; cerr << ""}\\n""; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl \'\\n\'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname """"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N];\nint main() {\n    #ifdef NERO\n    freopen(""test.inp"",""r"",stdin);\n    freopen(""test.out"",""w"",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname"".inp"",""r"",stdin);\n        //freopen(taskname"".out"",""w"",stdout);\n    #endif //NERO\n    IO;\n    int n, m, k;\n    cin >> n >> m >> k;\n    FOR(i, 1, n) cin >> a[i];\n    int cnt = 0;\n    int sum = 0;\n    FORD(i, n, 1) {\n        if (sum + a[i] > k) {\n            cnt++;\n            sum = 0;\n        }\n        if (cnt == m || a[i] > k) {\n            cout << n - i;\n            return 0;\n        }\n        sum += a[i];\n    }\n    cout << n;\n    #ifdef NERO\n    double etime = clock();\n    cerr << ""Execution time: "" << (etime - stime) / CLOCKS_PER_SEC * 1000 << "" ms.\\n"";\n    #endif // NERO\n}\n']",,,"['binary search', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Boxes Packing.json,https://codeforces.com//blog/entry/62419,The first solution is some kind of a straight forward understanding the problem Let s do binary search on the answer So our problem is to find the smallest such that the suffix of the array starting from the position can be packed in boxes It is easy to see that if we can do it for some then we always can do it for And to find the answer for the fixed we have to simulate the process described in the problem statement starting from the position Okay this is solution The second solution is more interesting than the first one The approach is to reverse the initial array simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all Why it works Let s take a look on the last box in the best answer if we will go from left to right in the initial array Let objects in this box be What do we see So all these objects are fit in the last box obviously Now if we will iterate over objects from right to left these objects will fit also It means that we cannot do worse by such a transform reversing at least for the last box But what will happen if we can put some of the previous objects in this box Well it will not make worse for this box but what about next boxes previous boxes in straight notation Let objects in the penultimate box be What do we see These objects are fit in this box obviously again What will happen if we will put in the last box one or more objects of this box Then the border of objects which we will put in it will not increase because we the number of object in this box So we can see that for previous boxes this condition is also satisfied So we can solve the problem with this approach Time complexity of this solution is 
https://codeforces.com//contest/1082/problem/C,64163,C,1082C,1082,C. Multi-Subject Competition,A multi subject competition is coming The competition has m different subjects participants can choose from That s why Alex the coach should form a competition delegation among his students He has n candidates For the i th person he knows subject s i the candidate specializes in and r i a skill level in his specialization this level can be negative The rules of the competition require each delegation to choose some subset of subjects they will participate in The only restriction is that the participating in each of the subjects should be the Alex decided that each candidate would participate only in the subject he specializes in Now Alex wonders whom he has to choose to maximize the total sum of skill levels of all delegates or just skip the competition this year if every valid non empty delegation has negative sum Of course Alex doesn t have any spare money so each delegate he chooses must participate in the competition ,"['/*\nI am Iron Man\n\nHas he lost his mind?\nCan he see or is he blind?\nCan he walk at all\nOr if he moves will he fall?\n\nIs he alive or dead?\nHas he thoughts within his head?\nWe\'ll just pass him there\nWhy should we even care?\n\nHe was turned to steel\nIn the great magnetic field\nWhen he traveled time\nFor the future of mankind\n\nNobody wants him\nHe just stares at the world\nPlanning his vengeance\nThat he will soon unfurl\n\nNow the time is here\nFor Iron Man to spread fear\nVengeance from the grave\nKills the people he once saved\n\nNobody wants him\nThey just turn their heads\nNobody helps him\nNow he has his revenge\n\nHeavy boots of lead\nFill his victims full of dread\nRunning as fast as they can\nIron Man lives again!\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 200031;\n\nint n,m;\nvector<int> v[N];\nlong long C[N],ans;\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++){\n\t\tint id,val;\n\t\tcin>>id>>val;\n\t\tv[id].push_back(val);\n\t}\n\n\tfor (int i=1;i<=m;i++){\n\t\tsort(v[i].begin(),v[i].end());\n\t\treverse(v[i].begin(),v[i].end());\n\t\tlong long s=0;\n\t\tfor (int j=0;j<v[i].size();j++){\n\t\t\ts+=v[i][j];\n\t\t\tif (s>0)\n\t\t\t\tC[j+1]+=s;\n\t\t}\n\t}\n\n\tfor (int i=1;i<=n;i++){\n\t\tans=max(ans,C[i]);\n\t}\n\n\tcout<<ans<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']",,,"['greedy', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Multi-Subject Competition.json,https://codeforces.com/blog/entry/63544,At first it s optimal to take candidates with maximal levels for a fixed subject At second if we fix number of participants in each subject for some delegation then it s always optimal to choose all subjects with positive sum of levels It leads us to a following solution Let s divide all candidates by it s and sort each group in non increasing order In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value 
https://codeforces.com//contest/985/problem/B,184583,B,985B,985,B. Switches and Lamps,You are given switches and lamps The th switch turns on some subset of the lamps This information is given as the matrix consisting of rows and columns where if the th switch turns on the th lamp and if the th switch is not connected to the th lamp Initially all lamps are turned off Switches change state only from off to on It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards It is guaranteed that if you push all switches then Your think that you have too many switches and you would like to ignore one of them Your task is to say if there exists such a switch that if you will ignore not use it but press all the other switches then all the lamps will be turned on ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n, m, co[2000];\nchar g[2000][2000];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    F0R(i,n) F0R(j,m) {\n        cin >> g[i][j];\n        if (g[i][j] == \'1\') co[j] ++;\n    }\n    F0R(i,n) {\n        bool need = 0;\n        F0R(j,m) if (co[j] == 1 && g[i][j] == \'1\') need = 1;\n        if (!need) {\n            cout << ""YES"";\n            exit(0);\n        }\n    }\n    cout << ""NO"";\n    \n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)']",,,['implementation'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Switches and Lamps.json,https://codeforces.com//blog/entry/59623,Let s maintain an array of size where will be equal to the number of switches that are connected to the th lamp Then answer will be if and only if there exists some switch such that for each lamp that is connected to this switch Otherwise the answer will be 
https://codeforces.com//contest/1109/problem/B,298870,B,1109B,1109,B. Sasha and One More Name,Reading books is one of Sasha s passions Once while he was reading one book he became acquainted with an unusual character The character told about himself like that Many are my names in many countries Mithrandir among the Elves Thark n to the Dwarves Ol rin I was in my youth in the West that is forgotten in the South Inc nus in the North Gandalf to the East I go not And at that moment Sasha thought how would that character be called in the East In the East all names are palindromes A string is a palindrome if it reads the same backward as forward For example such strings as and are palindromes but strings and are not Sasha believed that the hero would be named after one of the gods of the East As long as there couldn t be two equal names so in the East people did the following they wrote the original name as a string on a piece of paper then cut the paper minimum number of times k so they got k 1 pieces of paper with substrings of the initial string and then unite those pieces together to get a new string Pieces they could be shuffled In this way it s possible to achive a string from the string using 3 cuts by swapping papers with substrings and The string can t be received using the same cuts More formally Sasha wants for the given s find such minimum k that you can cut this string into k 1 parts and then unite them in such a way that the final string will be a palindrome and it won t be equal to the initial string s It there is no answer then print without quotes ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nbool isPal(string s) {\n\tint n = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] != s[n - 1 - i])\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tstring s;\n\tcin >> s;\n\tbool allEq = true;\n\tint n = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tif (n % 2 == 0 || i != n / 2)\n\t\t\tallEq &= s[0] == s[i];\n\tif (allEq) {\n\t\tcout << ""Impossible\\n"";\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t\tstring p = s.substr(i, n - i) + s.substr(0, i);\n\t\tif (p == s || !isPal(p)) continue;\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tcout << 2 << endl;\n\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'hashing', 'strings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Sasha and One More Name.json,https://codeforces.com//blog/entry/65295,Let s be the given string it s length If consists of or when is odd equal characters then there is no way to get the answer Otherwise let s prove that the answer can be always reached in two cuttings Let s the longest prefix of that consists of equal characters has the length equal to Cut and and call the remaining piece as Swap and then unite all three parts together The central part will stay unchanged and then So now we can get the answer in two cuttings Finally you must chech if it is possible to get the result by making just one cutting As soon as one cutting is equal to some cyclic shift then our task is to check if there is a cyclic shift which is a palindrome and not equal to It can be done by fixing each cyclic shift and checking each one separately Complexity 
https://codeforces.com//contest/668/problem/A,57059,A,668A,668,A. Little Artem and Matrix,Little Artem likes electronics He can spend lots of time making different schemas and looking for novelties in the nearest electronics store The new control element was delivered to the store recently and Artem immediately bought it That element can store information about the matrix of integers size There are inputs in that element i e each row and each column can get the signal When signal comes to the input corresponding to some row this row cyclically shifts to the left that is the first element of the row becomes last element second element becomes first and so on When signal comes to the input corresponding to some column that column shifts cyclically to the top that is first element of the column becomes last element second element becomes first and so on Rows are numbered with integers from to from top to bottom while columns are numbered with integers from to from left to right Artem wants to carefully study this element before using it For that purpose he is going to set up an experiment consisting of turns On each turn he either sends the signal to some input or checks what number is stored at some position of the matrix Artem has completed his experiment and has written down the results but he has lost the chip Help Artem find any initial matrix that will match the experiment results It is guaranteed that experiment data is consistent which means at least one valid matrix exists ,"['#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nint main() {\n\tint n; int m; int q;\n\twhile(~scanf(""%d%d%d"", &n, &m, &q)) {\n\t\tvector<vi> id(n, vi(m));\n\t\trep(i, n) rep(j, m)\n\t\t\tid[i][j] = i * m + j;\n\t\tvector<int> val(n * m, 0);\n\t\tvi tmp(n + m);\n\t\tfor(int ii = 0; ii < q; ++ ii) {\n\t\t\tint ty;\n\t\t\tscanf(""%d"", &ty);\n\t\t\tif(ty == 1) {\n\t\t\t\tint r;\n\t\t\t\tscanf(""%d"", &r), -- r;\n\t\t\t\trep(j, m) tmp[j] = id[r][j];\n\t\t\t\trotate(tmp.begin(), tmp.begin() + 1, tmp.begin() + m);\n\t\t\t\trep(j, m) id[r][j] = tmp[j];\n\t\t\t} else if(ty == 2) {\n\t\t\t\tint c;\n\t\t\t\tscanf(""%d"", &c), -- c;\n\t\t\t\trep(i, n) tmp[i] = id[i][c];\n\t\t\t\trotate(tmp.begin(), tmp.begin() + 1, tmp.begin() + n);\n\t\t\t\trep(i, n) id[i][c] = tmp[i];\n\t\t\t} else if(ty == 3) {\n\t\t\t\tint r; int c; int x;\n\t\t\t\tscanf(""%d%d%d"", &r, &c, &x), -- r, -- c;\n\t\t\t\tval[id[r][c]] = x;\n\t\t\t} else abort();\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, m) {\n\t\t\t\tif(j != 0) putchar(\' \');\n\t\t\t\tprintf(""%d"", val[i * m + j]);\n\t\t\t}\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}\n']",,,['implementation'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Little Artem and Matrix.json,https://codeforces.com//blog/entry/44538,Let s have 2 matrices a idx In a we will have NULL for cell if we don t know the value or the value idx will be initialized with idx i j i j Then we need to emulate the process on matrix idx If we have 3rd query we can set up the value in matrix a because we know the original position of that cell keeping idx 
https://codeforces.com//contest/377/problem/A,4961,A,377A,377,A. Maze,Pavel loves grid mazes A grid maze is an rectangle maze where each cell is either empty or is a wall You can go from one cell to another only if both cells are empty and have a common side Pavel drew a grid maze with all empty cells forming a connected area That is you can go from any empty cell to any other one Pavel doesn t like it when his maze has too little walls He wants to turn exactly empty cells into walls so that all the remaining cells still formed a connected area Help him ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nconst int N = 1234;\n\nchar a[N][N];\nbool was[N][N];\nint x[N * N], y[N * N];\n\nint main() {\n  int n, m, s;\n  scanf(""%d %d %d"", &n, &m, &s);\n  for (int i = 0; i < n; i++) scanf(""%s"", a[i]);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++) was[i][j] = false;\n  bool found = false;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (!found && a[i][j] == \'.\') {\n        int b = 1, e = 1;\n        x[1] = i;\n        y[1] = j;\n        was[i][j] = true;\n        while (b <= e) {\n          for (int q = 0; q < 4; q++) {\n            int xk = x[b] + dx[q];\n            int yk = y[b] + dy[q];\n            if (xk >= 0 && yk >= 0 && xk < n && yk < m)\n              if (a[xk][yk] == \'.\' && !was[xk][yk]) {\n                e++;\n                x[e] = xk;\n                y[e] = yk;\n                was[xk][yk] = true;\n              }\n          }\n          b++;\n        }\n        for (int id = e - s + 1; id <= e; id++) a[x[id]][y[id]] = \'X\';\n        found = true;\n      }\n  for (int i = 0; i < n; i++) printf(""%s\\n"", a[i]);\n  return 0;\n}\n']",,,['dfs and similar'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Maze.json,https://codeforces.com//blog/entry/10157,Start BFS or DFS from any free cell As the maze is connected this search will visit all free cells But we can stop the search when it visits free cells It s obvious that these cells are connected to each other Remaining cells can be transformed into the walls Solutions which every move transform the cell which has the minimal number of neighbours passed pretests However it s wrong Here is the counter test Top left cell has no more neighbours than any other cell but we cannot transform it into the wall 
https://codeforces.com//contest/835/problem/A,116346,A,835A,835,A. Key races,Two boys decided to compete in text typing on the site Key races During the competition they have to type a text consisting of characters The first participant types one character in milliseconds and has ping milliseconds The second participant types one character in milliseconds and has ping milliseconds If connection ping delay is milliseconds the competition passes for a participant as follows Exactly after milliseconds after the start of the competition the participant receives the text to be entered Right after that he starts to type it Exactly milliseconds after he ends typing all the text the site receives information about it The winner is the participant whose information on the success comes earlier If the information comes from both participants at the same time it is considered that there is a draw Given the length of the text and the information about participants determine the result of the game ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint main()\n{\n\tint s,v1,v2,t1,t2;\n\tint s1,s2;\n\tscanf(""%d%d%d%d%d"",&s,&v1,&v2,&t1,&t2);\n\ts1=2*t1+s*v1;\n\ts2=2*t2+s*v2;\n\tif(s1<s2)\n\t\tprintf(""First\\n"");\n\telse if(s2<s1)\n\t\tprintf(""Second\\n"");\n\telse\n\t\tprintf(""Friendship\\n"");\n\treturn 0;\n}']",,,['math'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Key races.json,https://codeforces.com//blog/entry/53588,Information on the success of the first participant will come in milliseconds of the second participant in milliseconds We need to compare these numbers and print the answer depending on the comparison result 
https://codeforces.com//contest/1174/problem/D,353393,D,1174D,1174,D. Ehab and the Expected XOR Problem,Given two integers n and x construct an array that satisfies the following conditions for any element a i in the array 1 le a i 2 n there is no subsegment with bitwise XOR equal to 0 or x its length l should be maximized A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, x;\nint vis[(1 << 18) + 5];\nint main()\n{\n\tcin >> n >> x;\n\tfor (int i = 0; i < 1 << n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t\tvis[i ^ x] = 1;\n\t}\n\tint lst = 0;\n\tvector<int> vec;\n\tfor (int i = 1; i < 1 << n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tvec.push_back(i ^ lst);\n\t\t\tlst = i;\n\t\t}\n\t}\n\tprintf(""%d\\n"", (int)vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++)\n\t\tprintf(""%d "", vec[i]);\n\tputs("""");\n}']",,,"['bitmasks', 'constructive algorithms']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Ehab and the Expected XOR Problem.json,https://codeforces.com//blog/entry/67388,The main idea is to build the prefix xor of the array not the array itself then build the array from it Let the prefix xor array be called Now Thus the problem becomes construct an array such that no pair of numbers has bitwise xor sum equal to 0 or and its length should be maximal Notice that no pair of numbers has bitwise xor sum equal to 0 simply means you can t use the same number twice If no pair of numbers less than will have bitwise xor sum equal to so you can just use all the numbers from 1 to in any order Otherwise you can think of the numbers forming pairs where each pair consists of 2 numbers with bitwise xor sum equal to From any pair if you add one number to the array you can t add the other However the pairs are independent from each other your choice in one pair doesn t affect any other pair Thus you can just choose either number in any pair and add them in any order you want After you construct you can construct using the formula Code link https pastebin com 0gCLC0BP Time complexity 
https://codeforces.com//contest/1827/problem/F,1922415,F,1827F,1827,F. Copium Permutation,You are given a permutation a 1 a 2 ldots a n of the first n positive integers A subarray l r is called if we can rearrange it so that it becomes a sequence of consecutive integers or more formally if max a l a l 1 ldots a r min a l a l 1 ldots a r r l For each k in the range 0 n print out the number of copium subarrays of a over all ways of rearranging the last n k elements of a ,"['#include <bits/stdc++.h>\n\nint main() {\n\tusing std::cin;\n\tusing std::cout;\n\tusing std::cerr;\n\tstd::ios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tstd::vector<int> A(N);\n\t\tfor (auto& a : A) { cin >> a; a--; }\n\n\t\tstd::vector<int> nxt_earlier(N);\n\t\tstd::vector<int> prv_earlier(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnxt_earlier[i] = i+1;\n\t\t\tprv_earlier[i] = i-1;\n\t\t}\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tint a = A[i];\n\t\t\tint p = prv_earlier[a];\n\t\t\tint n = nxt_earlier[a];\n\t\t\tif (p != -1) nxt_earlier[p] = n;\n\t\t\tif (n != N) prv_earlier[n] = p;\n\t\t}\n\n\t\tauto c2 = [](int a) -> int64_t {\n\t\t\tassert(a >= 0);\n\t\t\treturn int64_t(a) * int64_t(a-1) / 2;\n\t\t};\n\n\t\t// lo_ans is strictly before i, hi_ans is strictly after i\n\t\tint64_t lo_ans = 0;\n\t\tint64_t hi_ans = c2(N+1);\n\t\t// We store mid_ans (things using i) in the persistent stack\n\n\t\tenum class NodeType {\n\t\t\tLEAF,\n\t\t\tINCR,\n\t\t\tDECR,\n\t\t\tFULL,\n\t\t\tPARTIAL,\n\t\t};\n\t\tstruct cnd_t {\n\t\t\tint left;\n\t\t\tint lo;\n\t\t\tint lo_gap;\n\t\t\tint hi;\n\t\t\tint hi_gap;\n\t\t\tNodeType node_type;\n\t\t\tint node_sz;\n\n\t\t\tint64_t mid_ans = 0;\n\n\t\t\tint lo_best = 0;\n\t\t\tint64_t lo_cur = 0;\n\t\t\tint hi_best = 0;\n\t\t\tint64_t hi_cur = 0;\n\t\t};\n\n\t\tstd::vector<cnd_t> stk; stk.reserve(N);\n\n\t\tstd::vector<int64_t> res; res.reserve(N+1);\n\t\tres.push_back(lo_ans + 0 + hi_ans);\n\n\t\tauto update_back = [&]() -> void {\n\t\t\tint z = int(stk.size()) - 1;\n\t\t\tassert(z >= 0);\n\t\t\tstk[z].mid_ans = z == 0 ? 0 : stk[z-1].mid_ans;\n\t\t\tstk[z].mid_ans += std::max(stk[z].node_sz, 1);\n\t\t\t{\n\t\t\t\tint lo_gap_sz = stk[z].lo - stk[z].lo_gap;\n\t\t\t\tassert(lo_gap_sz >= 0);\n\t\t\t\tif (z > 0 && stk[z].lo_gap == stk[z-1].lo_gap) {\n\t\t\t\t\tstk[z].lo_best = std::max(stk[z-1].lo_best, stk[z-1].node_sz);\n\t\t\t\t\tstk[z].mid_ans -= stk[z-1].lo_cur;\n\t\t\t\t} else {\n\t\t\t\t\tstk[z].lo_best = 0;\n\t\t\t\t}\n\t\t\t\tstk[z].lo_cur = int64_t(lo_gap_sz) * int64_t(stk[z].lo_best + 1);\n\t\t\t\tstk[z].mid_ans += stk[z].lo_cur;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint hi_gap_sz = stk[z].hi_gap - stk[z].hi;\n\t\t\t\tassert(hi_gap_sz >= 0);\n\t\t\t\tif (z > 0 && stk[z].hi_gap == stk[z-1].hi_gap) {\n\t\t\t\t\tstk[z].hi_best = std::max(stk[z-1].hi_best, stk[z-1].node_sz);\n\t\t\t\t\tstk[z].mid_ans -= stk[z-1].hi_cur;\n\t\t\t\t} else {\n\t\t\t\t\tstk[z].hi_best = 0;\n\t\t\t\t}\n\t\t\t\tstk[z].hi_cur = int64_t(hi_gap_sz) * int64_t(stk[z].hi_best + 1);\n\t\t\t\tstk[z].mid_ans += stk[z].hi_cur;\n\t\t\t}\n\t\t};\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a = A[i];\n\n\t\t\twhile (!stk.empty() && (a < stk.back().lo_gap || a > stk.back().hi_gap)) {\n\t\t\t\tassert(stk.size() >= 2);\n\t\t\t\tif (stk.end()[-2].lo_gap == stk.end()[-1].lo_gap) {\n\t\t\t\t\tstk.end()[-2].lo = stk.end()[-1].lo;\n\t\t\t\t} else if (stk.end()[-2].hi_gap == stk.end()[-1].hi_gap) {\n\t\t\t\t\tstk.end()[-2].hi = stk.end()[-1].hi;\n\t\t\t\t}\n\n\t\t\t\tstk.pop_back();\n\n\t\t\t\tstk.back().node_type = NodeType::PARTIAL;\n\t\t\t\tstk.back().node_sz = 0;\n\t\t\t}\n\n\t\t\tif (!stk.empty()) {\n\t\t\t\tif (stk.back().node_type == NodeType::DECR) {\n\t\t\t\t\tassert(a < stk.back().lo || a > stk.back().hi);\n\t\t\t\t\tif (a > stk.back().hi) {\n\t\t\t\t\t\tstk.back().node_type = NodeType::FULL;\n\t\t\t\t\t\tstk.back().node_sz = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (stk.back().node_type == NodeType::INCR) {\n\t\t\t\t\tassert(a < stk.back().lo || a > stk.back().hi);\n\t\t\t\t\tif (a < stk.back().lo) {\n\t\t\t\t\t\tstk.back().node_type = NodeType::FULL;\n\t\t\t\t\t\tstk.back().node_sz = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thi_ans -= int64_t(nxt_earlier[a] - a) * int64_t(a - prv_earlier[a]);\n\n\t\t\tif (!stk.empty()) {\n\t\t\t\t// Until this point, we were just merging/joining the single back node, so we don\'t need to call update in any other places\n\t\t\t\tupdate_back();\n\t\t\t}\n\t\t\tstk.push_back({i, a, prv_earlier[a]+1, a, nxt_earlier[a]-1, NodeType::PARTIAL, 0});\n\t\t\tupdate_back();\n\t\t\t//cerr << ""Run "" << i << \' \' << a << \' \' << lo_ans << \' \' << hi_ans << \'\\n\';\n\t\t\t//for (auto it : stk) { cerr << it.left << \' \' << it.lo_gap << \'-\' << it.lo << \'-\' << it.hi << \'-\' << it.hi_gap << \' \' << int(it.node_type) << \' \' << it.node_sz << \'\\n\'; }\n\n\t\t\tres.push_back(lo_ans + stk.back().mid_ans + hi_ans);\n\t\t\t//cerr << ""mid_ans "" << mid_ans << \'\\n\';\n\n\t\t\tstk.back().node_type = NodeType::LEAF;\n\t\t\tstk.back().node_sz = 1;\n\t\t\tlo_ans ++;\n\n\t\t\twhile (stk.size() >= 2 && std::max(stk.back().hi, stk.end()[-2].hi) - std::min(stk.back().lo, stk.end()[-2].lo) == i - stk.end()[-2].left) {\n\t\t\t\t// merge these two nodes into one\n\t\t\t\tNodeType node_type;\n\t\t\t\tint node_sz;\n\t\t\t\tif (stk.end()[-2].lo_gap == stk.end()[-1].lo_gap) {\n\t\t\t\t\tstk.end()[-2].lo = stk.end()[-1].lo;\n\t\t\t\t\tnode_type = NodeType::DECR;\n\t\t\t\t\tnode_sz = (stk.end()[-2].node_type == node_type ? stk.end()[-2].node_sz : 1) + 1;\n\t\t\t\t\tlo_ans += node_sz - 1;\n\t\t\t\t} else if (stk.end()[-2].hi_gap == stk.end()[-1].hi_gap) {\n\t\t\t\t\tstk.end()[-2].hi = stk.end()[-1].hi;\n\t\t\t\t\tnode_type = NodeType::INCR;\n\t\t\t\t\tnode_sz = (stk.end()[-2].node_type == node_type ? stk.end()[-2].node_sz : 1) + 1;\n\t\t\t\t\tlo_ans += node_sz - 1;\n\t\t\t\t} else {\n\t\t\t\t\tnode_type = NodeType::FULL;\n\t\t\t\t\tnode_sz = 1;\n\t\t\t\t\tlo_ans ++;\n\t\t\t\t}\n\n\t\t\t\tstk.pop_back();\n\t\t\t\tstk.back().node_type = node_type;\n\t\t\t\tstk.back().node_sz = node_sz;\n\t\t\t}\n\t\t}\n\t\tassert(int(res.size()) == N+1);\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tcout << res[i] << "" \\n""[i==N];\n\t\t}\n\t}\n\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Copium Permutation.json,https://codeforces.com//blog/entry/116109,SolutionSolve the problem for fixed Call the last elements as special numbers Observation In optimal rearrangement every maximal segment of special numbers will be placed on consecutive positions in either ascending order or descending order For simplicity from now on we will call maximal segment of special number as maximal segment For example take a permutation and the maximal segments are and We divide the set of copium subarrays into three parts one for those lie entirely on prefix one for those lie entirely on suffix and one for the rest The number of subarrays in the first part can be calculated with the algorithm used in 526F Pudding Monsters The number of subarrays in the second part can be easily deduced from above observation Define an array such that for each and subarray contains consecutive nonspecial numbers For example take a permutation and then We will process array from right to left while adding special numbers from left to right Let us consider first add all special numbers which are missing from subarray at the end of current permutation If is not already copium we increase our answer by one Denote and as the minimum and maximum number in subarray Loot at two maximal segments one contains and one contains We can place them here to increase the answer For example let and the current permutation The two maximal segments are and We can place them like to increase the answer by 4 Furthermore we can see that three good positions and benefit from maximal segment In general consider consecutive good positions satisfying all of them can benefit from the same maximal segment if for all subarray is copium There is a similar condition when we consider consecutive good positions having the same So the algorithm goes like this For each value of and find the longest segment of good positions satisfying condition then multiply with the length of corresponding maximal segment and add to the answer Solve for each We will calculate the answer for each from to in this order We will store the longest segment for each prefix of equivalent and equivalent positions Note that when going from to only a suffix of will no longer be good so we can manually delete them one by one from right to left then add There will be at most good positions we need to consider The first one of course is If or let be the last position satisfying or the second one is the first good position after and it satisfies a property It must be the last position in the equivalent or equivalent positions The proof is left as an exercise Therefore updating this position will not affect the positions behind it The overall complexity is 
https://codeforces.com//contest/260/problem/B,2466,B,260B,260,B. Ancient Prophesy,A recently found Ancient Prophesy is believed to contain the exact Apocalypse date The prophesy is a string that only consists of digits and characters We ll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date s record in the format We ll say that the number of the date s occurrences is the number of such substrings in the Prophesy For example the Prophesy mentions date twice first time as second time as The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date A date is correct if the year lies in the range from to the month is from to and the number of the day is strictly more than a zero and doesn t exceed the number of days in the current month Note that a date is written in the format that means that leading zeroes may be added to the numbers of the months or days if needed In other words date isn t recorded in the format and date is recorded in it Notice that any year between 2013 and 2015 is not a leap year ,"['//program 260-B\n\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint Days(int Month)\n{\n  if(Month==2)\n    return 28;\n  if(Month==4||Month==6||Month==9||Month==11)\n    return 30;\n  return 31;\n}\n\nint Calc(string S)\n{\n  if(S[2]!=\'-\'||S[5]!=\'-\')\n    return -1;\n  for(int i=0;i<10;i++)\n    {\n      if(i==2||i==5)\n        continue;\n      if(S[i]<\'0\'||S[i]>\'9\')\n        return -1;\n    }\n  int Day=(S[0]-48)*10+(S[1]-48);\n  int Month=(S[3]-48)*10+(S[4]-48);\n  int Year=(S[6]-48)*1000+(S[7]-48)*100+(S[8]-48)*10+(S[9]-48);\n  if(Year<2013||Year>2015)\n    return -1;\n  if(Month<1||Month>12)\n    return -1;\n  if(Day<1||Day>Days(Month))\n    return -1;\n  return (Year-2013)*10000+Month*100+Day;\n}\n\nvoid Output(int X)\n{\n  putchar(X/10+48);\n  putchar(X%10+48);\n}\n\nint main()\n{\n  string S;\n  cin>>S;\n  static int Count[30000];\n  memset(Count,0,sizeof(Count));\n  for(int i=0;i+10<=S.size();i++)\n    {\n      string T="""";\n      for(int j=0;j<10;j++)\n        T+=S[i+j];\n      int Temp=Calc(T);\n      if(Temp!=-1)\n        Count[Temp]++;\n    }\n  int Ans=0;\n  for(int i=1;i<30000;i++)\n    if(Count[i]>Count[Ans])\n      Ans=i;\n  Output(Ans%100);\n  putchar(\'-\');\n  Output(Ans/100%100);\n  putchar(\'-\');\n  printf(""%d\\n"",Ans/10000+2013);\n  return 0;\n}\n']",,,"['brute force', 'implementation', 'strings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Ancient Prophesy.json,https://codeforces.com//blog/entry/6263,In this problem you have to consider every date from to year there is no leap years in this interval count occurrences of this date and find maximum In one year there is days so the complexity of the solution 
https://codeforces.com//contest/519/problem/D,23226,D,519D,519,D. A and B and Interesting Substrings,After several years of doing sports programming and solving many problems that require calculating all sorts of abstract objects A and B also developed rather peculiar tastes A likes lowercase letters of the Latin alphabet He has assigned to each letter a number that shows how much he likes that letter he has assigned negative numbers to the letters he dislikes B likes substrings He especially likes the ones that start and end with the same letter their length must exceed one Also A and B have a string Now they are trying to find out how many substrings of a string are interesting to B that is starts and ends with the same letter and its length is larger than one and also the sum of values of all letters assigned by A is equal to zero Naturally A and B have quickly found the number of substrings that are interesting to them Can you do it ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint val[27];\nchar a[N];\nint n;\nmap<long long, int> h[26];\n\nint main() {\n    int i;\n   // freopen(""ttt"", ""r"", stdin);\n\n    for(i = 0; i < 26; ++i) {\n        cin >> val[i];\n    }\n    cin >> (a + 1);\n        n = strlen(a + 1);\n\n    long long sc = 0, rez = 0;\n\n    for(i = 1; i <= n; ++i) {\n        a[i] -= \'a\';\n        sc += val[a[i]];\n\n        rez += h[a[i]][sc - val[a[i]]];\n        h[a[i]][sc]++;\n    }\n\n    cout << rez;\n\n    return 0;\n}\n']",,,"['data structures', 'dp', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. A and B and Interesting Substrings.json,https://codeforces.com/blog/entry/16687,In this problem you were asked to find number of substrings of given string such that each substring starts and finishes with one and the same letter and sum of weight of letters of that substring without first and last letter is zero Solution Let s denote sum i as sum of weights of first i letters Create 26 map longlong int s 1 for each letter Suppose we are on position number i and current character s map is m Then add m sum i 1 to the answer and add sum i to the m 
https://codeforces.com//contest/1348/problem/D,609091,D,1348D,1348,D. Phoenix and Science,Phoenix has decided to become a scientist He is currently investigating the growth of bacteria Initially on day 1 there is one bacterium with mass 1 Every day some number of bacteria will split possibly zero or all When a bacterium of mass m splits it becomes two bacteria of mass frac m 2 each For example a bacterium of mass 3 can split into two bacteria of mass 1 5 Also every night the mass of every bacteria will increase by one Phoenix is wondering if it is possible for the total mass of all the bacteria to be exactly n If it is possible he is interested in the way to obtain that mass using the minimum possible number of nights Help him become the best scientist ,"['#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint t,n,cur;\nll qpow (ll a,ll b) {\n\tll res=1;\n\twhile (b) {\n\t\tif (b) {res*=a;}\n\t\ta*=a,b>>=1;\n\t}\n\treturn res;\n}\nll divc (ll a,ll b) {\n\tif (a%b==0) {return a/b;}\n\telse {return a/b+1;}\n}\nll calc (int x) {return (1<<x)-1;}\nint main () {\n\tscanf(""%d"",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(""%d"",&n);\n\t\tint ans=0;\n\t\twhile (calc(ans)<n) {ans++;}\n\t\tprintf(""%d\\n"",ans-1);\n\t\tcur=1,n--;\n\t\tfor (int i=2;i<=ans;i++) {\n\t\t\tint tmp=cur;\n\t\t\tcur=divc(n,calc(ans-i+1));\n\t\t\tn-=cur;\n\t\t\tprintf(""%d "",cur-tmp);\n\t\t}\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Phoenix and Science.json,https://codeforces.com//blog/entry/76555,There exists many constructive solutions here is one I think is very elegant We will try to approach the problem by considering how much the total mass increases every night If there are bacteria some day before the splitting that night can have a mass increase between and inclusive depending on how many bacteria split that day Therefore we can reword the problem as follows construct a sequence of minimal length such that and the sum of is To minimize the length of sequence we will start building our sequence with such that the total sum is less than or equal to If the total sum is we are done Otherwise we insert into our sequence and sort This gives a valid sequence of minimal length To transform our sequence into the answer we can just print the differences because the number of bacteria that split during the day is equal to how much the mass increase changes Time complexity for each test case if you sort by insertion 
https://codeforces.com//contest/369/problem/A,4123,A,369A,369,A. Valera and Plates,Valera is a lazy student He has clean bowls and clean plates Valera has made an eating plan for the next days As Valera is lazy he will eat exactly one dish per day At that in order to eat a dish he needs exactly one plate or bowl We know that Valera can cook only two types of dishes He can eat dishes of the first type from bowls and dishes of the second type from either bowls or plates When Valera finishes eating he leaves a dirty plate bowl behind His life philosophy doesn t let him eat from dirty kitchenware So sometimes he needs to wash his plate bowl Find the minimum number of times Valera will need to wash a plate bowl if he acts optimally ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define lowbit(x) ((x) & (-(x)))\nusing namespace std;\ntypedef long long LL;\nconst int N = 1005;\nint n , m , k , a[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n    #endif\n    int ans = 0;\n    cin >> n >> m >> k;\n    for (int i = 0 ; i < n ; i ++) {\n        cin >> a[i];\n        if (a[i] == 2) {\n            if (k) k --;\n            else if (m) m --;\n            else ans ++;\n        }\n        else if (a[i] == 1) {\n            if (m) m --;\n            else ans ++;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;  \n}']",,,"['greedy', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Valera and Plates.json,https://codeforces.com//blog/entry/9760,We will use greedy algorithm Let s now th day and current dish is a dish of first type Then if we have the bowl let s use it Otherwise we will increase the answer If the current dish is a dish of the second type we first try to get the plate and then the bowl If there are no plates bowls at all then we will increase the answer Author s solution 5306397 
https://codeforces.com//contest/477/problem/A,15278,A,477A,477,A. Dreamoon and Sums,Dreamoon loves summing up something for no reason One day he obtains two integers and occasionally He wants to calculate the sum of all integers Positive integer is called if and where is some number in range By we denote the of integer division of and By we denote the of integer division of and You can read more about these operations here The answer may be large so please print its remainder modulo Can you compute it faster than Dreamoon ,"['#include <cstdio>\n\n#define MOD 1000000007\n\nint main() {\n//  freopen(""in.txt"", ""r"", stdin);\n//  freopen(""out.txt"", ""w"", stdout);\n    \n    long long a, b, rlt;\n    \n    scanf(""%I64d%I64d"", &a, &b);\n    rlt = (b * (b - 1) / 2) % MOD;\n    rlt = rlt * a % MOD * ((a * b + b + 2) % MOD) % MOD;\n    if (rlt & 1) rlt += MOD;\n    rlt /= 2;\n    printf(""%I64d\\n"", rlt % MOD);\n    return 0;\n}']",,,['math'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Dreamoon and Sums.json,https://codeforces.com/blog/entry/14256,If we fix the value of k and let d div x b m mod x b we have d mk x db m So we have x mkb m kb 1 m And we know m would be in range 1 b 1 because it s a remainder and x is positive so the sum of x of that fixed k would be Next we should notice that if an integer x is nice it can only be nice for a single particular k because a given x uniquely defines div x b and mod x b Thus the final answer would be sum up for all individual k which can be calculated in O a and will pass the time limit of 1 5 seconds Also the formula above can be expanded to Dreamoon says he s too lazy to do this part so if you use O 1 solution you just computed the answer faster than Dreamoon Note that no matter which approach one should be very careful of overflowing of the integer data type of the used language For example one should do a module after every multiplication if using 64 bit integer type And pay attention to precedence of operations take c for example a b c would be executed as a b c instead of a b c another c example a b c m would be executed as a b c m instead of a b c m Thanks saurabhsuniljain for pointing out the preceding problem and examples in the comment time complexity O 1 
https://codeforces.com//contest/1901/problem/C,2344505,C,1901C,1901,"C. Add, Divide and Floor",You are given an integer array a 1 a 2 dots a n 0 le a i le 10 9 In one operation you can choose an integer x 0 le x le 10 18 and replace a i with lfloor frac a i x 2 rfloor lfloor y rfloor denotes rounding y down to the nearest integer for all i from 1 to n Pay attention to the fact that all elements of the array are affected on each operation Print the smallest number of operations required to make all elements of the array equal If the number of operations is less than or equal to n then print the chosen x for each operation If there are multiple answers print any of them ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int mn = 1e9, mx = 0;\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin >> a;\n        mn = min(mn, a);\n        mx = max(mx, a);\n    }\n    vector<int> ans;\n    while (mn != mx) {\n        if (mn % 2 == mx % 2) {\n            ans.push_back(0);\n        } else if (mx % 2 == 0) {\n            ans.push_back(1);\n            ++mn;\n            ++mx;\n        } else {\n            ans.push_back(0);\n        }\n        mn /= 2;\n        mx /= 2;\n    }\n    cout << ans.size() << ""\\n"";\n    if ((int)ans.size() <= n) {\n        for (int x : ans) {\n            cout << x << "" "";\n        }\n        cout << ""\\n"";\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'math']",1400,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Add, Divide and Floor.json",https://codeforces.com//blog/entry/122645,Sort the array Notice how applying the operation doesn t change the order of the elements regardless of It means that it s enough to make the initial minimum and maximum equal to make all elements equal Consider the difference between the minimum and the maximum values What happens to it after an operation Let the minimum be and the maximum be Then it s The roundings are difficult to deal with so let s pretend the parities always align to even So it s Apparently the difference is just getting divided by Let s bring the parities back Notice that the rounding of the difference depends only on the parities of and You can consider all cases of parities of and to discover that it s always possible to divide the difference by rounding down and it s never possible to make it less than that One easy algorithm to achieve that is the following if the minimum is even choose otherwise choose Repeat until the minimum is equal to the maximum Overall complexity per testcase 
https://codeforces.com//contest/1802/problem/A,1817554,A,1802A,1802,A. Likes,Nikita recently held a very controversial round after which his contribution changed very quickly The announcement hung on the main page for n seconds In the ith second a i th person either liked or removed the like Nikita was lucky in this task and there are no dislikes If a i 0 then the a ith person put a like If a i 0 then the person a i removed the like Since Nikita s contribution became very bad after the round he wanted to analyze how his contribution changed while the announcement was on the main page He turned to the creator of the platform with a request to give him the sequence a 1 a 2 ldots a n But due to the imperfection of the platform the sequence a was shuffled You are given a shuffled sequence of a that describes user activity You need to tell for each moment from 1 to n what the maximum and minimum number of likes could be on the post at that moment ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tint sum=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch==\'-\')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){sum=sum*10+ch-48;ch=getchar();}\n\treturn sum*f;\n}\nint main()\n{\n\tint T;\n\tT=read();\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tn=read();\n\t\tint tot1=0,tot2=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=read();\n\t\t\tif(x>0) tot1++;\n\t\t\telse tot2++;\n\t\t}\n\t\tint x=0;\n\t\tint a=tot1,b=tot2;\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a>0)x++,a--;\n\t\t\telse x--;\n\t\t\tcout<<x<<"" "";\n\t\t} \n\t\tcout<<endl;\n\t\ta=tot1,b=tot2;\n\t\tx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(x==0) a--,x++;\n\t\t\telse\n\t\t\t\tif(b) b--,x--;\n\t\t\t\telse a--,x++;\n\t\t\tcout<<x<<"" "";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Likes.json,https://codeforces.com//blog/entry/113857,SolutionLet s show a construction that maximizes the number of likes We need to first leave all the likes that we can put and only then delete them To minimize the number of likes we need to delete the like if we can immediately after we post it The code below implements these constructs 
https://codeforces.com//contest/1926/problem/A,2485151,A,1926A,1926,A. Vlad and the Best of Five,Vladislav has a string of length 5 whose characters are each either texttt A or texttt B Which letter appears most frequently texttt A or texttt B ,"['#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tsort(s.begin(),s.end());\n\t\tcout<<s[2]<<""\\n"";\n\t}\n\t\n\treturn 0;\n}']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\A. Vlad and the Best of Five.json,https://codeforces.com//blog/entry/126132,Since the string is of an odd length we know that the number of s can t be equal to the number of s So there is always only one possible answer Denote variables a counter and b counter the count of s and s in the string respectively Let s just iterate through all 5 characters of the string and increase the a counter every time we see an and the b counter every time we see a If the a counter is greater than the b counter we output and otherwise 
https://codeforces.com//contest/843/problem/D,119864,D,843D,843,D. Dynamic Shortest Path,You are given a weighted directed graph consisting of vertices and edges You should answer queries of two types find the length of shortest path from vertex to vertex add to weights of edges with indices ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nstruct rng {\n    struct A {\n        int n;\n        const bool operator!=(A r) { return n != r.n; }\n        A& operator++() { n++; return *this; }\n        int operator*() { return n; }\n    };\n    int l, r;\n    rng(int r) : l(0), r(r) {}\n    rng(int l, int r) : l(l), r(r) {}\n    A begin() { return A{l}; }\n    A end() { return A{r}; }\n};\n\ntemplate<class D, D INF>\nstruct Dijkstra {\n    V<D> res; //res[i] = si\n    \n    template<class E>\n    Dijkstra(const VV<E> &g, int s) {\n        int n = (int)g.size();\n        res = V<D>(n, INF);\n        \n        using P = pair<D, int>;\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (E e: g[p.second]) {\n                if (p.first+e.dist < res[e.to]) {\n                    res[e.to] = p.first+e.dist;\n                    q.push(P(res[e.to], e.to));\n                }\n            }\n        }\n    }\n};\n\nstruct E {\n    int to;\n    int dist;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n, m, q;\n    cin >> n >> m >> q;\n    VV<E> g(n);\n    using P = pair<int, int>;\n    V<P> ed(m);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c; a--; b--;\n        ed[i] = P(a, int(g[a].size()));\n        g[a].push_back(E{b, c});\n    }\n    \n    V<ll> sm = Dijkstra<ll, TEN(18)>(g, 0).res;\n    V<int> pos(n);\n    V<bool> cant(n);\n    for (int i = 0; i < n; i++) cant[i] = (sm[i] == TEN(18));\n\n    for (int i = 0; i < n; i++) {\n        if (cant[i]) continue;\n        for (auto &e: g[i]) {\n            int j = e.to;\n            e.dist -= sm[j] - sm[i];\n        }\n    }\n\n    auto ref = [&]() {\n        for (int i = 0; i < n; i++) {\n            if (cant[i]) continue;\n            for (auto &e: g[i]) {\n                int j = e.to;\n                e.dist -= pos[j] - pos[i];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (cant[i]) continue;\n            sm[i] += pos[i];\n            pos[i] = 0;\n        }\n    };\n\n    int c = 0;\n    V<bool> vis(n);\n    for (int ph = 0; ph < q; ph++) {\n        int ty;\n        cin >> ty;\n        if (ty == 1) {\n            if (c) {\n                fill(begin(pos), end(pos), TEN(9));\n                fill(begin(vis), end(vis), false);\n    \n                VV<int> que(c+1);\n                que[0].push_back(0);\n                pos[0] = 0;\n                for (int di = 0; di <= c; di++) {\n                    while (que[di].size()) {\n                        int p = que[di].back(); que[di].pop_back();\n                        if (vis[p]) continue;\n                        vis[p] = true;\n                        for (auto e: g[p]) {\n                            if (c < di + e.dist) continue;\n                            if (pos[e.to] <= di + e.dist) continue;\n                            pos[e.to] = di + e.dist;\n                            que[di + e.dist].push_back(e.to);\n                        }\n                    }\n                }\n                ref();\n                c = 0;                    \n            }\n            int v;\n            cin >> v; v--;\n            cout << (cant[v] ? -1 : sm[v]) << endl;\n        } else {\n            int x;\n            cin >> x;\n            for (int i = 0; i < x; i++) {\n                int l;\n                cin >> l; l--;\n                g[ed[l].first][ed[l].second].dist++;\n            }\n            c += x;            \n        }\n    }\n    return 0;\n}\n']",,,"['graphs', 'shortest paths']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Dynamic Shortest Path.json,https://codeforces.com//blog/entry/54029,Firstly let s run an usual Dijkstra from find distances and make them a potentials of vertices Then for each request let s recalculate all distances and make the potentials equal to these distances To quickly recalculate the distance between requests we can use the fact that in a graph with potentials all distances are 0 When we increased the weight of some edges by 1 in the graph with potentials all distances do not exceed the number of changed edges so we can run a Dijkstra on a vector per 
https://codeforces.com//contest/1772/problem/G,1699974,G,1772G,1772,G. Gaining Rating,Monocarp is playing chess on one popular website He has n opponents he can play with The i th opponent has rating equal to a i Monocarp s initial rating is x Monocarp wants to raise his rating to the value y y x When Monocarp is playing against one of the opponents he will win if his rating is bigger or equal to the opponent s rating If Monocarp wins his rating is increased by 1 otherwise it is decreased by 1 The rating of his opponent does not change Monocarp wants to gain rating y playing as few games as possible But he can t just grind it playing against weak opponents The website has a rule that you should play against all opponents as evenly as possible Speaking formally if Monocarp wants to play against an opponent i there should be no other opponent j such that Monocarp has played more games against i than against j Calculate the minimum possible number of games Monocarp needs to gain rating y or say it s impossible Note that ratings of Monocarp s opponents change while Monocarp s rating does change ,"['/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=3e5+5,mod=1e9+7;\nll n,m,k,a[N];\nvoid elixprep(){\n    \n}\nll climb (ll f, ll s, ll a, ll d){\n    return (s-f+a-d-1)/(a-d);\n}\nvoid elix()\n{\n    cin>>n>>m>>k;\n    rep(i,1,n) cin>>a[i];\n    sort(a+1,a+n+1);\n    ll tmp=m;\n    ll cnt=0,id=0;\n    rep(i,1,n) if (a[i]<=tmp){\n        cnt++;\n        tmp++;\n        id=i;\n        if (tmp==k){\n            cout<<cnt;\n            return;\n        }\n    }\n    else  tmp--;\n    if (tmp<=m){\n        cout<<-1;\n        return;\n    }\n    n++;\n    a[n]=k;\n    sort(a+1,a+n+1);\n    ll height=m+id-1;\n    ll res=id-1;\n    while (height<=k){\n        if (height>=a[id]){\n            id++;\n            height++;\n            res++;\n        }\n        else{\n            ll add=id-1,rem=n-id;\n            if (add==rem){\n                cout<<-1;\n                return;\n            }\n            tmp=climb(height,a[id],add,rem);\n            height+=tmp*(add-rem);\n            res+=tmp*(n-1);\n            res++;\n            id++;\n            height++;\n        }\n    }\n    cout<<res-height+k;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}\n//listen to trap music. it won\'t help']",,,"['binary search', 'greedy', 'implementation', 'math', 'sortings', 'two pointers']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Gaining Rating.json,https://codeforces.com//blog/entry/110313,After parsing the statement you can understand that Monocarp plays cyclically in one cycle he chooses some order of opponents and play with them in that order Then repeats again and again until he gains desired rating at some moment So firstly let s prove that in one cycle it s optimal to play against opponents in Suppose you play with opponents in some order and there is a position where if you swap and you won t lose anything and may even gain extra wins It means that the total gain after playing one cycle in increasing order in greater or equal than playing in any other order In other words we can sort array and play against them cyclically in that order Monocarp s list of games will look like several full cycles and some prefix The problem is that there can be many cycles and we need to skip them in a fast way How one cycle looks Monocarp starts with some wins first games and then loses all other games games where The maximum rating he gains is and the resulting rating after all games is We can already find several conditions of leaving a cycle if then Monocarp gets what he wants and stops otherwise if or he will never gain the desired rating since in the next cycle the number of wins since his starting rating Otherwise if and he will start one more cycle with rating and will gain the desired rating eventually So how to find the number of games he will win for a starting rating Let s calculate two values for a given sorted skill array for each let s calculate the minimum rating Monocarp need to win opponent and all opponent before and the rating he ll get after winning the th opponent We can calculate these values in one iteration we ll use indexation then for each if then and otherwise and Now knowing values it s easy to find the number of wins for a starting rating is equal to minimum such that don t forget indexation Or the first position in array with value strictly greater than We can search it with standard function since array is sorted Okay we found the number of wins for the current Let s just calculate how many cycles Monocarp will make with exactly wins There are only two conditions that should be met in order to break this cycle either Monocarp reaches rating it can be written as inequality or the number of wins increases starting rating becomes greater or equal than i e From the first inequality we get minimum and from the second one As a result we can claim that Monocarp will repeat the current cycle exactly times and either finish in the next turn or the number of wins will change So we can skip these equal cycles we can increase answer by and current rating by Since we skip equal cycles then at each step we either finish with success or or the number of wins increases Since is bounded by we will make no more than skips and total complexity is because of initial sorting and calls of 
https://codeforces.com//contest/1999/problem/D,2800022,D,1999D,1999,D. Slavic s Exam,Slavic has a very tough exam and needs your help in order to pass it Here is the question he is struggling with There exists a string s which consists of lowercase English letters and possibly zero or more Slavic is asked to change each to a lowercase English letter such that string t becomes a subsequence not necessarily continuous of the string s Output any such string or say that it is impossible in case no string that respects the conditions exists ,"['#include<bits/stdc++.h>using namespace std;int T;int main(){\tcin>>T;\twhile(T--){\t\tstring s,t;cin>>s>>t;\t\tint pos=0;\t\tfor(int i=0;i<s.size();i++){\t\t\tif(s[i]==t[pos]||s[i]==\'?\'){\t\t\ts[i]=t[pos];pos++;}\t\t\tif(pos==t.size())break;\t\t}\t\tputs(pos==t.size()?""Yes"":""No"");\t\tfor(char &c:s)if(c==\'?\')c=\'a\';\t\tif(pos==t.size())cout<<s<<endl;\t}\treturn 0;}']",,,"['greedy', 'implementation', 'strings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Slavic s Exam.json,https://codeforces.com//blog/entry/132373,Let s use a greedy strategy with two pointers one at the start of s called i and one at the start of t called j At each step advance i by 1 If si then we set it to tj and increment j If si tj then we also increment j because there is a match It works because if there is ever a question mark it never makes it worse to match the current character in t earlier than later The complexity is O n 
https://codeforces.com//contest/1558/problem/F,1088954,F,1558F,1558,F. Strange Sort,You have a permutation an array a a 1 a 2 ldots a n of distinct integers from 1 to n The length of the permutation n is odd Consider the following algorithm of sorting the permutation in increasing order A helper procedure of the algorithm f i takes a single argument i 1 le i le n 1 and does the following If a i a i 1 the values of a i and a i 1 are exchanged Otherwise the permutation doesn t change The algorithm consists of iterations numbered with consecutive integers starting with 1 On the i th iteration the algorithm does the following if i is odd call f 1 f 3 ldots f n 2 if i is even call f 2 f 4 ldots f n 1 It can be proven that after a finite number of iterations the permutation will be sorted in increasing order After how many iterations will this happen for the first time ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nint solve(vector<int> a){\n\tint n = (int)a.size();\n\tbool sorted = true;\n\tfor(int i = 0; i < n; i++) if(a[i] != i) sorted = false;\n\tif(sorted){\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i+1 < n; i += 2){\n\t\tif(a[i] > a[i+1]) swap(a[i], a[i+1]);\n\t}\n\tvector<int> loc(n);\n\tfor(int i = 0; i < n; i++) loc[a[i]] = i;\n\tvector<int> r(n+1, 0);\n\tfor(int i = 0; i <= n; i++) r[i] = n-i;\n\tNode segtree(r, 0, n+2);\n\tint ans = 0;\n\tint min1 = n;\n\tint max0 = n-1;\n\tfor(int i = n-1; i > 0; i--){\n\t\tsegtree.add(loc[i]+1, n+2, 1);\n\t\tsegtree.add(0, loc[i]+1, -1);\n\t\tmin1 = min(min1, loc[i]);\n\t\twhile(a[max0] >= i) max0--;\n\t\tans = max(ans, segtree.query(min1, max0+1));\n\t}\n\treturn 1 + max(ans - 1, 0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor(int& x : a){\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\t\tint ans = solve(a);\n\t\tcout << ans << '\\n';\n\t}\n}""]",,,"['data structures', 'sortings']",3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Strange Sort.json,https://codeforces.com//blog/entry/94216,Let s draw a wall of towers of cubes with the th tower having height For example for the picture will look as follows stands for a cube When two elements get swapped their corresponding towers get swapped as well Note that applying to the permutation swapping and if is equivalent to applying to each row of the above matrix independently swapping cells and if the th cell is and the th cell is Also note that in the final state when the permutation is each row of the matrix is sorted in non descending order too s go before s and vice versa if each row is sorted the permutation is sorted as well Thus it s enough to find the number of iterations required to sort each row of the matrix and the maximum of these numbers is the answer for the given permutation The rows of the matrix are for How to solve the problem for a sequence of s and s We can assume that the instances of s don t change their relative order and the same for s Let the positions of zeros in the initial sequence be The th zero from the left is moving towards position in the sorted sequence Let be the number of steps it takes the th zero from the left to get to its final position If the th zero is already in position then Otherwise if note that because the th zero can only get to position after the th zero gets to position Moreover let there be ones to the left of the th zero in the initial sequence Then because the has to swap with every to the left of it and also the first iteration is useless if is odd It turns out that the th zero either gets stuck into the th zero and then or consistently swaps with s on each iteration except for maybe the first in which case We are interested in Let the number of s at the start of the initial sequence be It can be seen that and this is exactly the number of iterations required Recall that we need to find the number of iterations for different binary sequences However these binary sequences are very similar to each other Let s maintain the values of for all zeros in a segment tree and say for positions containing ones Start with the sequence for that is a sequence of all ones As we increase by one a single in gets replaced with We can handle these changes using a segment tree with range add and range max The time complexity of the solution is Another equivalent formula is Here is the number of s in is the smallest position such that and is the largest position such that This formula can also be proven using induction In short consider this formula applied to the number of iterations the difference is that instead of we sometimes have depending on the parity of the current iteration number Consider all positions where the value is maximized Then it can be shown that after one iteration the value for all such positions decreases by if the parity is incorrect after one iteration the parity becomes correct otherwise observe that and which get swapped in the next iteration Moreover the value for all other positions has the same parity increases by at most and thus doesn t become too big either 
https://codeforces.com//contest/1205/problem/E,390601,E,1205E,1205,E. Expected Value Again,You are given integers n k Let s consider the alphabet consisting of k different elements Let f s of the string s be the number of indexes i 1 le i s for which prefix of s of length i equals to suffix of s of length i For example beauty of the string abacaba equals 2 as for i 1 3 prefix and suffix of length i are equal Consider all words of length n in the given alphabet Find the expected value of f s 2 of a uniformly chosen at random word We can show that it can be expressed as frac P Q where P and Q are coprime and Q isn t divided by 10 9 7 Output P cdot Q 1 bmod 10 9 7 ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nconst int MOD=1e9+7;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\tb%=(MOD-1);\n\twhile(b<0) b+=MOD-1;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint mu[SZ];\nbool ip[SZ];\nll ps(ll k,ll n)\n{\n\tif(k==1) return n+1;\n\t//k^0+k^1+...+k^n\n\treturn (qp(k,n+1)-1)*qp(k-1,MOD-2)%MOD;\n}\nll ps(ll k,ll l,ll r)\n{\n\treturn qp(k,l)*ps(k,r-l)%MOD;\n}\nll pp(ll k,ll n)\n{\n\t//S=k+2k^2+3k^3+nk^n\n\t//kS=k^2+2k^3+3k^4+...+nk^(n+1)\n\t//kS-S=nk^(n+1)-k^n-k^(n-1)-...-k^2-k\n\treturn (n*qp(k,n+1)-ps(k,1,n))%MOD*qp(k-1,MOD-2)%MOD;\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tans+=i*qp(k,i),ans%=MOD;\n\treturn ans;\n}\nll su(ll l,ll r)\n{\n\tl%=MOD; r%=MOD;\n\treturn (l+r)*(r-l+1)/2%MOD;\n}\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tif(n==1)\n\t{\n\t\tputs(""0"");\n\t\treturn 0;\n\t}\n\tif(k==1)\n\t{\n\t\tll w=n-1;\n\t\tw=w*w%MOD;\n\t\tcout<<w<<""\\n"";\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i) mu[i]=1;\n\tfor(int i=2;i<=n;++i) if(!ip[i])\n\t{\n\t\tfor(int j=i;j<=n;j+=i)\n\t\t{\n\t\t\tip[j]=1;\n\t\t\tif((j/i)%i==0) mu[j]=0;\n\t\t\telse mu[j]=-mu[j];\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;++i)\n//\t\tcout<<mu[i]<<"","";\n//\tcout<<""\\n"";\n\tll ans=0;\n\tfor(int s=1;s<=n;++s)\n\t{\n\t\t//i+j<=n+s, i,j<n, gcd(i,j)=s\n\t\tint u=(n+s)/s,r=(n-1)/s;\n\t\tll cd=0,ap=0;\n\t\t//-k^(i+j-n)\n\t\tfor(int x=1;x<=r;++x)\n\t\t{\n\t\t\tll ux=u/x,rx=r/x;\n\t\t\tll K=qp(k,x*s);\n\t\t\tll R=min(ux,rx+1);\n\t\t\tcd+=mu[x]*su(1,R-1);\n\t\t\tap+=mu[x]*K*pp(K,R-1);\n//\t\t\tfor(int p=2;p<=R;++p)\n//\t\t\t{\n//\t\t\t\tint rr=p-1;\n//\t\t\t\tcd+=mu[x]*rr;\n//\t\t\t\tap+=mu[x]*rr*qp(K,p);\n//\t\t\t\tcd%=MOD; ap%=MOD;\n//\t\t\t}\n\t\t\tcd+=mu[x]*rx*(ux-R);\n\t\t\tap+=mu[x]*rx*ps(K,R+1,ux); \n\t\t\tcd%=MOD; ap%=MOD;\n//\t\t\tfor(int p=R+1;p<=ux;++p)\n//\t\t\t{\n//\t\t\t\tint rr=rx;\n//\t\t\t\tcd+=mu[x]*rr;\n//\t\t\t\tap+=mu[x]*rr*qp(K,p);\n//\t\t\t\tcd%=MOD; ap%=MOD;\n//\t\t\t}\n//\t\t\tfor(int p=1;p<=r/x;++p)\n//\t\t\t\tfor(int q=1;q<=r/x;++q) if(p+q<=ux)\n//\t\t\t\t\tcd+=mu[x],\n//\t\t\t\t\tap+=mu[x]*qp(K,p+q);\n\t\t\t\t\t//ans-=mu[x]*qp(k,p*x*s+q*x*s-n);\n\t\t}\n\t\tcd%=MOD,ap%=MOD;\n\t\tans+=qp(k,s)*cd;\n\t\tans-=ap*qp(k,-n);\n\t\tans%=MOD;\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tans+=ps(k,i+1-n,i+n-1-n);\n\tans=ans%MOD*qp(k,n*(ll)(MOD-2))%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<""\\n"";\n}\n']",,,"['combinatorics', 'strings']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Expected Value Again.json,https://codeforces.com/blog/entry/69158,Let be a function of the string equal to if the prefix and suffix of length are equal and equal to otherwise We need to calculate using linearity of expectation We will call the number the period of the string if for all Moreover the length of is not required to be divided by Statement 1 is the period of the string is Proof that is equivalent to which is equivalent to the fact that for from to Statement 2 Proof The probability that is since each of the last characters is uniquely determined from the previous ones Statement 3 Let Then Proof Assume that We know that the string is and periodic Consider a graph of string positions and draw edges between positions at distances Then the number of different strings satisfying is where is the number of connected components of our graph Then Thus we need to show that The case of is obvious in this case by subtracting and adding we can show that the string has period in this case We now consider the case when Without loss of generality We write out in a circle numbers from to They denote the components of connectivity when we draw only the edges connecting the positions at a distance of Now we need to add edges of the form for here Moreover we know that We will add these edges one at a time and observe how the connected components change If we connected two positions that were not connected yet then we reduced the number of connected components by Otherwise we connected two already connected vertices and formed a cycle When does a cycle form at all If we consider all the edges of the form then our graph is divided into cycles components each of which contains all positions giving the same residues when divided by Thus it is necessary to calculate how many of these cycles we form If cycles are formed then the number of components will be How many cycles will we create Let s see if the cycle consisting of positions giving the remainder when divided by closes It closes only if all its vertices are in This is equivalent to the fact that among the positions in not a single number gives the remainder of when dividing by If then this cannot happen for any and Otherwise there will be exactly where Thus the statement is proved Further reasoning is standard We have shown that depends only on and It remains for to count the number of pairs such that We will do it as follows if then we rewrite it as Now we just need to find the number of numbers coprime to on the segment This can be done for where is the number of prime divisors of It can be shown that this gives the asymptotics of If you have a better one please share in the comments 
https://codeforces.com//contest/455/problem/B,12118,B,455B,455,B. A Lot of Games,Andrew Fedor and Alex are inventive guys Now they invent the game with strings for two players Given a group of non empty strings During the game two players build the word together initially the word is empty The players move in turns On his step player must add a single letter in the end of the word the resulting word must be prefix of at least one string from the group A player loses if he cannot move Andrew and Alex decided to play this game times The player who is the loser of the th game makes the first move in the th game Guys decided that the winner of all games is the player who wins the last th game Andrew and Alex already started the game Fedor wants to know who wins the game if both players will play optimally Help him ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 200010;\n\nint a[N][26];\n\nchar foo[N];\n\nbool can_win[N], can_lose[N];\n\nint main() {\n  int nnn, k;\n  scanf(""%d %d"", &nnn, &k);\n  memset(a, 0, sizeof(a));\n  int n = 1;\n  for (int i = 0; i < nnn; i++) {\n    scanf(""%s"", foo);\n    int t = 1;\n    for (int j = 0; foo[j]; j++) {\n      int p = foo[j] - \'a\';\n      if (a[t][p] == 0) {\n        n++;\n        a[t][p] = n;\n      }\n      t = a[t][p];\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    bool mv = false;\n    for (int j = 0; j < 26; j++) {\n      if (a[i][j] != 0) {\n        mv = true;\n        break;\n      }\n    }\n    if (!mv) {\n      can_win[i] = false;\n      can_lose[i] = true;\n      continue;\n    }\n    can_win[i] = false;\n    can_lose[i] = false;\n    for (int j = 0; j < 26; j++) {\n      if (a[i][j] != 0) {\n        if (!can_win[a[i][j]]) {\n          can_win[i] = true;\n        }\n        if (!can_lose[a[i][j]]) {\n          can_lose[i] = true;\n        }\n      }\n    }\n  }\n  if (!can_win[1]) {\n    puts(""Second"");\n    return 0;\n  }\n  if (can_lose[1]) {\n    puts(""First"");\n    return 0;\n  }\n  // can_win && !can_lose\n  puts((k % 2 == 1) ? ""First"" : ""Second"");\n  return 0;\n}\n']",,,"['dfs and similar', 'dp', 'games', 'implementation', 'strings', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. A Lot of Games.json,https://codeforces.com//blog/entry/13336,To solve this problem we need the prefix tree trie which will have all the strings from the group Next we will calculate the two DP win v Can player win if he makes a move now players have word equal to prefix in the prefix tree trie lose v Can player lose if he makes a move now players have word equal to prefix in the prefix tree trie if is leaf of trie then win v false lose v true Else such children of vertex Let s look at a few cases If then second player win first player lose all games If then first player win he can change the state of the game in his favor If and then if then first player win else second player win Asymptotics 
https://codeforces.com//contest/689/problem/E,64401,E,689E,689,E. Mike and Geometry Problem,Mike wants to prepare for IMO but he doesn t know geometry so his teacher gave him an interesting geometry problem Let s define to be the number of integer points in the segment with say that You are given two integers and and closed intervals on axis and you have to find In other words you should find the sum of the number of integer points in the intersection of any of the segments As the answer may be very large output it modulo Mike can t solve this problem so he needs your help You will help him won t you ,"['#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 400100;\n\nmap<int, int> nor;\nvector<int> vals, val;\nint sol, n, k, l[N], r[N], A[N];\nll P[N], I[N];\nll comb(int x, int y) {\n    return 1LL * P[x] * I[y] % mod * I[x - y] % mod;\n}\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""a.in"", ""r"", stdin);\n    freopen(""a.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n >> k;\n    FOR(i,1,n) {\n        cin >> l[i] >> r[i];\n        r[i]++;\n        vals.pb(l[i]);\n        vals.pb(r[i]);\n    }\n    P[0] = 1;\n    FOR(i,1,n) {\n        P[i] = 1LL * P[i - 1] * i % mod;\n    }\n    I[n] = powmod(P[n], mod - 2);\n    ROF(i,n-1,0) {\n        I[i] = I[i + 1] * (i + 1) % mod;\n    }\n    sort(vals.begin(), vals.end());\n    FIT(it,vals) {\n        if(!val.size()) {\n            val.pb(it);\n        } else if (val.back() != it) {\n            val.pb(it);\n        }\n    }\n    int t = 0;\n    FIT(it,val) {\n        nor[it] = ++t;\n    }\n    FOR(i,1,n) {\n        A[nor[l[i]]]++;\n        A[nor[r[i]]]--;\n    }\n    FOR(i,1,t) {\n        A[i] += A[i - 1];\n        if (A[i] >= k) {\n            sol += 1LL * comb(A[i],k) * (val[i] - val[i - 1]) % mod;\n            if (sol >= mod) {\n                sol -= mod;\n            }\n        }\n    }\n    cout << sol;\n    return 0;\n}']",,,"['combinatorics', 'data structures', 'dp', 'geometry', 'implementation']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Mike and Geometry Problem.json,https://codeforces.com//blog/entry/45912,Let define the following propriety if the point i is intersected by p segments then in our sum it will be counted times so our task reduce to calculate how many points is intersected by i intervals 1 i n Let dp i be the number of points intersected by i intervals Then our answer will be We can easily calculate array dp using a map and partial sum trick here you can find about it 
https://codeforces.com//contest/2060/problem/B,3147467,B,2060B,2060,B. Farmer John s Card Game,Farmer John s n cows are playing a card game Farmer John has a deck of n cdot m cards numbered from 0 to n cdot m 1 He distributes m cards to each of his n cows Farmer John wants the game to be fair so each cow should only be able to play 1 card per round He decides to determine a determined by a permutation text p of length n such that the p i th cow will be the i th cow to place a card on top of the center pile in a round In other words the following events happen in order in each round The p 1 th cow places any card from their deck on top of the center pile The p 2 th cow places any card from their deck on top of the center pile The p n th cow places any card from their deck on top of the center pile There is a catch Initially the center pile contains a card numbered 1 In order to place a card the number of the card must be greater than the number of the card on top of the center pile Then the newly placed card becomes the top card of the center pile If a cow cannot place any card in their deck the game is considered to be lost Farmer John wonders does there exist p such that it is possible for all of his cows to empty their deck after playing all m rounds of the game If so output any valid p Otherwise output 1 text A permutation of length n contains each integer from 1 to n exactly once ,"['#include <bits/stdc++.h>using namespace std;\xa0int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr);\xa0\tint t; \tcin >> t;  // number of test cases\xa0\twhile(t--){\t\tint n, m;\t\tcin >> n >> m;\t\tvector<vector<int>> cowCards(n, vector<int>(m));\t\tvector<int> allCards;\t\tallCards.reserve(n*m);\xa0\t\tfor(int i=0; i<n; i++){\t\t\tfor(int j=0; j<m; j++){\t\t\t\tcin >> cowCards[i][j];\t\t\t\tallCards.push_back(cowCards[i][j]);\t\t\t}\t\t}\xa0\t\tfor(int i=0; i<n; i++){\t\t\tsort(cowCards[i].begin(), cowCards[i].end());\t\t}\t\tmap<vector<int>, int> deckToCow;\t\tfor(int i=0; i<n; i++){\t\t\tdeckToCow[cowCards[i]] = i;\t\t}\t\tsort(allCards.begin(), allCards.end());\t\tbool possible = true;\t\tvector<int> p(n, -1);\t\tvector<bool> usedCow(n, false);\xa0\t\tfor(int j=0; j<n; j++){\t\t\tvector<int> colSet(m);\t\t\tfor(int row=0; row<m; row++){\t\t\t\tcolSet[row] = allCards[row*n + j];\t\t\t}\t\t\tauto it = deckToCow.find(colSet);\t\t\tif(it == deckToCow.end()){\t\t\t\tpossible = false;\t\t\t\tbreak;\t\t\t}\t\t\tint cowIndex = it->second;\t\t\tif(usedCow[cowIndex]){\t\t\t\tpossible = false;\t\t\t\tbreak;\t\t\t}\t\t\tusedCow[cowIndex] = true;\t\t\tp[j] = cowIndex;\t\t}\xa0\t\tif(!possible){\t\t\tcout << -1 << ""\\n"";\t\t\tcontinue;\t\t}\t\tfor(int j=0; j<n; j++){\t\t\tcout << p[j] + 1 << (j+1 < n ? \' \' : \'\\n\');\t\t}\t}\xa0\treturn 0;}']",,,"['greedy', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Farmer John s Card Game.json,https://codeforces.com/blog/entry/138342,Assume the cows are initially ordered correctly A solution exists if the first cow can place 0 the second cow can place 1 and so on continuing with the first cow placing n the second cow placing n 1 and so forth Observing the pattern the first cow must be able to place 0 n 2n the second 1 n 1 2n 1 and in general the i th cow where i 0 n 1 must be able to place i n i 2n i For each cow sorting their cards reveals whether they satisfy this condition the difference between adjacent cards in the sorted sequence must be n If any cow s cards do not meet this criterion the solution does not exist and we output 1 If the cows are not ordered correctly we need to rearrange them To construct the solution find the index of the cow holding card i for each i 0 n 1 Since the cards of each cow are sorted denote min card as the smallest card a cow holds Using an array p iterate over each cow c from 0 to n 1 and set pmin card c Finally iterate i from 0 to n 1 and output pi Time Complexity O nmlog m Note that sorting is not necessary and a solution with complexity up to O nm 2 will still pass 
https://codeforces.com//contest/1462/problem/E2,833574,E2,1462E2,1462,E2. Close Tuples  hard version ,You are given a sequence a of length n consisting of integers from 1 to n Find the number of tuples of m elements such that the maximum number in the tuple differs from the minimum by no more than k Formally you need to find the number of tuples of m indices i 1 i 2 ldots i m such that max a i 1 a i 2 ldots a i m min a i 1 a i 2 ldots a i m le k For example if n 4 m 3 k 2 a 1 2 4 3 then there are two such triples i 1 j 2 z 4 and i 2 j 3 z 4 If n 4 m 2 k 1 a 1 1 1 1 then all six possible pairs are suitable ,"[""#include <bits/stdc++.h>\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define si short int\n#define speed ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define pill pair<ll,ll>\n#define f first\n#define s second\n#define pilc pair<ll,char>\n#define all(a) (a).begin(),(a).end()\n#define rep(s,e,step) for(int i = (s); i < (e) ; i += step)\n#define vrep(s,e,step) for(int j = (s); j < (e) ; j += step)\n#define ex exit(0) \n#define sz(a) (a).size()\n#define triple pair<pill, ll>\n#define pinode pair<node*, node*>\n#define quadra pair<pill, pill>\n#define ld long double\nusing namespace std;\n \nconst ll N = 2e5 + 10;\nconst ll M = 2e5 + 1;\nconst ll big = 1e18;\nconst ll hsh2 = 1964325029 ;\nconst long long mod = 1e9 + 7;\nconst long double EPS = 1e-14;\nconst ll block = 1e7;\nconst ll shift = 2e3;\nmt19937_64 rofl(chrono::steady_clock::now().time_since_epoch().count());\n\nll t;\nll a[N];\nll F[N];\nll bp(ll b, ll c) {\n\tll d = 1;\n\twhile(c) {\n\t\tif(c&1)\n\t\t\td = b * d % mod;\n\t\tc >>= 1;\n\t\tb = b * b % mod;\t\n\t}\n\treturn d;\n}\n\nll inv(ll a) {\n\treturn bp(a, mod - 2);\n}\nll C(ll n, ll k) {\n\tif(n < k)\n\t\treturn 0;\n\treturn F[n] * inv(F[n - k] * F[k] % mod) % mod;\n}\n\nvoid solve() {\n    ll n, m, k;\n    cin >> n >> m >> k;\n    F[0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i], F[i] = F[i - 1] * i % mod;\n\tsort(a + 1, a + n + 1);\n\tll ans = 0;\n\tfor(ll i = 1, l = 1; i <= n; i++) {\n\t\twhile(a[i] - a[l] > k)\n\t\t\tl++;\n\t\tans = (ans + C(i - l, m - 1)) % mod;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tspeed;\n\tcin >> t;\n\twhile(t--)solve(); \t\n}              \n/*\nqiwwqdesw\n1\nd\n \n*/""]",,,"['binary search', 'combinatorics', 'implementation', 'math', 'sortings', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E2. Close Tuples  hard version .json,https://codeforces.com//blog/entry/85594,The key idea that allows us to move from the previous version to this one is that the values of the numbers themselves are not important to us The main idea is to consider all numbers in the interval Let s also as in the previous version iterate over the minimum element in the tuple Now let s find the count of numbers that lie in the interval this can be done with a binary search two pointers or prefix sums using an array of occurrences Then it remains to add to the answer the number of ways to choose numbers from we fixed one of the numbers as the minimum You have to sum these values over all possible values of even the same because now you are not fixing the value of the minimum element as in the previous problem but its index in the sorted array To calculate binomial coefficients quickly you can pre compute all factorial values and all values by modulo If you do not know how to calculate the inverse element by modulo then you could pre compute the part of Pascal s triangle in 
https://codeforces.com//contest/948/problem/A,164143,A,948A,948,A. Protect Sheep,Bob is a farmer He has a large pasture with many sheep Recently he has lost some of them due to wolf attacks He thus decided to place some shepherd dogs in such a way that all his sheep are protected The pasture is a rectangle consisting of cells Each cell is either empty contains a sheep a wolf or a dog Sheep and dogs always stay in place but wolves can roam freely around the pasture by repeatedly moving to the left right up or down to a neighboring cell When a wolf enters a cell with a sheep it consumes it However no wolf can enter a cell with a dog Initially there are no dogs Place dogs onto the pasture in such a way that no wolf can reach any sheep or determine that it is impossible Note that since you have many dogs you do need to minimize their number ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint R, C;\nchar a[510][510];\n\nint main() {\n    scanf(""%d%d"",&R,&C);\n    for(int i = 0 ; i < R ; i++)\n        scanf("" %s"",a[i]);\n    for(int i = 0 ; i < R ; i++) {\n        for(int j = 0 ; j < C ; j++) {\n            if(a[i][j] == \'S\') {\n                if(i != 0) {\n                    if(a[i-1][j] == \'W\') {\n                        printf(""No"");\n                        return 0;\n                    }\n                    if(a[i-1][j] != \'S\')\n                        a[i-1][j] = \'D\';\n                }\n                if(j != 0) {\n                    if(a[i][j-1] == \'W\') {\n                        printf(""No"");\n                        return 0;\n                    }\n                    if(a[i][j-1] != \'S\')\n                        a[i][j-1] = \'D\';\n                }\n                if(i != R) {\n                    if(a[i+1][j] == \'W\') {\n                        printf(""No"");\n                        return 0;\n                    }\n                    if(a[i+1][j] != \'S\')\n                        a[i+1][j] = \'D\';\n                }\n                if(j != C) {\n                    if(a[i][j+1] == \'W\') {\n                        printf(""No"");\n                        return 0;\n                    }\n                    if(a[i][j+1] != \'S\')\n                        a[i][j+1] = \'D\';\n                }\n            }\n        }\n    }\n    puts(""Yes"");\n    for(int i = 0 ; i < R; i++) {\n        for(int j = 0 ; j < C ; j++) {\n            printf(""%c"",a[i][j]);\n        }\n        puts("""");\n    }\n    return 0;\n}\n']",,,"['brute force', 'dfs and similar', 'graphs', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Protect Sheep.json,https://codeforces.com//blog/entry/58286,Suppose that there is a wolf and a sheep in adjacent cells It is obvious that in this case the answer this particular wolf can always attack this sheep Otherwise the answer is always The simplest way of protecting all sheep is to place a dog in every empty cell Then no wolf can move and all sheep are safe and happy 
https://codeforces.com//contest/1735/problem/D,1564418,D,1735D,1735,D. Meta-set,You like the card board game Set Each card contains k features each of which is equal to a value from the set 0 1 2 The deck contains all possible variants of cards that is there are 3 k different cards in total A feature for three cards is called if it is the same for these cards or pairwise distinct Three cards are called a if all k features are good for them For example the cards 0 0 0 0 2 1 and 0 1 2 form a set but the cards 0 2 2 2 1 2 and 1 2 0 do not as for example the last feature is not good A group of cards is called a if there is strictly more than one set among them How many meta sets there are among given n distinct cards ,"[""// LUOGU_RID: 91547278\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+'0');\n}\n#define writesp(x) write(x),putchar(' ')\n#define writeln(x) write(x),putchar('\\n')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=1010;\n\nint n,k;\n\nstruct Node {\n\tint c[24];\n\tvoid init() {\n\t\trep(i,1,k) c[i]=read();\n\t}\n} a[N];\nNode operator + (const Node& a,const Node& b) {\n\tNode ret;\n\trep(i,1,k) ret.c[i]=(3-(a.c[i]+b.c[i])%3)%3;\n\treturn ret;\n}\n\null cal(Node x) {\n\tull ret=0;\n\trep(i,1,k) {\n\t\tret=ret*3ll+x.c[i];\n\t}\n\treturn ret;\n}\n\nmap<ull,int> M;\n\nint main() {\n\tn=read(),k=read();\n\trep(i,1,n) a[i].init();\n\tM.clear();\n\trep(i,1,n) rep(j,i+1,n) {\n\t\tNode res=a[i]+a[j];\n\t\tM[cal(res)]++;\n\t}\n\tll ans=0;\n\trep(i,1,n) {\n\t\tll cnt=M[cal(a[i])];\n\t\tans+=1ll*cnt*(cnt-1)/2;\n\t}\n\twriteln(ans);\n\treturn 0;\n}\n""]",,,"['brute force', 'combinatorics', 'data structures', 'hashing', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Meta-set.json,https://codeforces.com//blog/entry/107533,SolutionFor every two cards there is always a single card that forms a set with them 1 That means that two sets can share at most one card Let s prove that there are no more than sets in a meta set Let s define cards as Let s guess that is a set All other sets can have at most one card among according to 1 so they must include and So we have at most one other set otherwise they would have two same cards which is prohibited according to 1 So every meta set looks like sets with one common card Let s call this card a central card Now there is just a simple combinatorics For each card we want to know the number of sets that include it If this number is then we should add to the answer it is the number of meta sets with this card as a central card To get the number of sets for each card we can iterate over all pairs of cards generate the complement to the set and add to that card in a map hashmap Complexity is or 
https://codeforces.com//contest/1360/problem/G,629827,G,1360G,1360,G. A B Matrix,You are given four positive integers n m a b 1 le b le n le 50 1 le a le m le 50 Find any such rectangular matrix of size n times m that satisfies all of the following conditions each row of the matrix contains exactly a ones each column of the matrix contains exactly b ones all other elements are zeros If the desired matrix does not exist indicate this For example for n 3 m 6 a 2 b 1 there exists a matrix satisfying the conditions above begin vmatrix 0 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 end vmatrix ,"['#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < \'0\' || cc > \'9\' ) {  if( cc == \'-\' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= \'0\' && cc <= \'9\' )  cn = cn * 10 + cc - \'0\', cc = getchar() ;\n\treturn cn * flus ;\n}\n#define maxn 205\nint n , m , a, b ; \nsigned main() {\n\tint T = gi() ;\n\twhile( T -- ) {\n\t\tn = gi(), m = gi(), a = gi(), b = gi() ;\n\t\tif( n * a != m * b ) {\n\t\t\tputs(""NO"") ;\n\t\t\tcontinue ;\n\t\t}\n\t\tputs(""YES"") ;\n\t\tint last = 0 ;\n\t\trep( i, 1, n ) {\n\t\t\tint l = last + 1, r = ( last + a ) % m;\n\t\t\tif( l == 0) {\n\t\t\t\trep( j, 1, r ) printf(""1"") ;\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\tprintf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse if(r == 0 ) {\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\trep( j, l, m ) printf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse if( l <= r ) {\n\t\t\t\trep( j, 1, last ) printf(""0"") ;\n\t\t\t\trep( j, last + 1, last + a ) printf(""1"");\n\t\t\t\trep( j, last + a + 1, m ) printf(""0"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep( j, 1, r ) printf(""1"") ;\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\trep( j, l, m ) printf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0 ;\n} ']",,,"['constructive algorithms', 'greedy', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. A B Matrix.json,https://codeforces.com//blog/entry/77846,Let s see how the desired matrix looks like Since each row should have exactly ones and each column should have exactly ones the number of ones in all rows should be equal to the number of ones in all columns Thus the desired matrix exists iff or Let s show how to construct the desired matrix if it exists Let s find any number such that where is the remainder of dividing by In the first row of the desired matrix we put the ones at the positions and in the th row we put the ones as in the row but cyclically shifted by to the right 
https://codeforces.com//contest/1095/problem/F,275106,F,1095F,1095,F. Make It Connected,You are given an undirected graph consisting of n vertices A number is written on each vertex the number on vertex i is a i Initially there are no edges in the graph You may add some edges to this graph but you have to pay for them The cost of adding an edge between vertices x and y is a x a y coins There are also m special offers each of them is denoted by three numbers x y and w and means that you can add an edge connecting vertices x and y and pay w coins for it You don t have to use special offers if there is a pair of vertices x and y that has a special offer associated with it you still may connect these two vertices paying a x a y coins for it What is the minimum number of coins you have to spend to make the graph connected Recall that a graph is connected if it s possible to get from any vertex to any other vertex using only the edges belonging to this graph ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint par[200010];\nint root(int v){return par[v] < 0 ? v : (par[v] = root(par[v]));}\n\nint merge(int x,int y){\n    if((x = root(x)) == (y = root(y))) return 0 ;\n\tif(par[y] < par[x])\tswap(x, y);\n\tpar[x] += par[y];\n\tpar[y] = x;\n\treturn 1;\n}\n\n\nint main(){\n\tfast_io;\n\tfor (int i = 0; i < 200010; ++i)\n\t{\n\t\tpar[i]=-1;\n\t}\n\tint n,m;\n\tcin>>n>>m;\n\tvector<pair<ll,pair<int,int> > >edge;\n\tpair<ll,int> a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i].first;\n\t\ta[i].second=i+1;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tll x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tedge.push_back({z,{x,y}});\n\t}\n\tsort(a,a+n);\n\tfo(i,1,n-1){\n\t\tedge.push_back({a[i].first+a[0].first,{a[i].second,a[0].second}});\n\t}\n\tsort(edge.begin(), edge.end());\n\tll ans=0;\n\tfor(auto i:edge){\n\t\tint x=i.second.first;\n\t\tint y=i.second.second;\n\t\tll w=i.first;\n\t\tif(merge(x,y)){\n\t\t\tans+=w;\n\t\t}\n\t}\n\tshow(ans);\n\treturn 0;\n}']",,,"['dsu', 'graphs', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Make It Connected.json,https://codeforces.com//blog/entry/64130,Suppose we have found all the edges of the graph explicitly sorted them and start running Kruskal on the sorted list of edges Each time we add some edge to MST it is either a special edge given in the input or an edge which was generated with cost whichever costs less Let s try to analyze how can we find the cheapest edge of each type that connects two components For special edges we may just maintain the number of special edges we already added or skipped and when choosing a new edge we skip some more possibly zero special edges that don t connect anything until we find an edge that connects something And for the other type of edges we may find two components having minimum numbers on the vertices in those components as small as possible and just connect the minimum vertex in the first component with the minimum vertex in the second component We may simulate this by maintaining a data structure for example a multiset where for each component we will store the vertex having minimum in this component and pick two minimums from this set We also have to be able to check if two vertices are connected this can be done with DSU and merge two components But this solution can be made easier Every time we add a non special edge one of the ends of this edge is the vertex with minimum So we may just find this vertex generate all edges connecting this vertex to all other vertices merge this set of edges with the set of special edges and run any MST algorithm on the resulting set of edges If there are multiple minimums in the array then we may pick any of them because in Kruskal algorithm it doesn t matter which of the edges with equal costs we try to add first 
https://codeforces.com//contest/1818/problem/B,1897384,B,1818B,1818,B. Indivisible,You re given a positive integer n Find a permutation a 1 a 2 dots a n such that for any 1 leq l r leq n the sum a l a l 1 dots a r is not divisible by r l 1 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nusing PI = pair<int, int>;\nusing LL = long long;\n\nconst int N = 105;\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(""in.txt"", ""r"", stdin);\n#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint T; cin >> T;\n\twhile (T --) {\n\t\tint n; cin >> n;\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (n & 1) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 2; i <= n; i += 2) {\n\t\t\tcout << i << \' \' << i - 1 << \' \';\n\t\t}cout << endl;\n\t}\n\treturn 0;\n}\n']",,,['constructive algorithms'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Indivisible.json,https://codeforces.com//blog/entry/115586,If is odd there is no solution as the sum of the whole array is always divisible by Otherwise the solution is as follows Start with the identity permutation Swap the adjacent pairs to get Indeed consider the sum of a sub array There are cases and have different parity the sum is and its greatest common divisor with is as is not divisible by and have the same parity the sum is or depending on the parity The first summand is divisible by as is even So the whole sum has the remainder or modulo thus it can t be divisible by it 
https://codeforces.com//contest/731/problem/E,75976,E,731E,731,E. Funny Game,Once upon a time Petya and Gena gathered after another programming competition and decided to play some game As they consider most modern games to be boring they always try to invent their own games They have only stickers and markers but that won t stop them The game they came up with has the following rules Initially there are stickers on the wall arranged in a row Each sticker has some number written on it Now they alternate turn Petya moves first One move happens as follows Lets say there are stickers on the wall The player who makes the current move picks some integer from to and takes leftmost stickers removes them from the wall After that he makes the new sticker puts it to the left end of the row and writes on it the new integer equal to the sum of all stickers he took on this move Game ends when there is only one sticker left on the wall The score of the player is equal to the sum of integers written on all stickers he took during all his moves The goal of each player is to maximize the difference between his score and the score of his opponent Given the integer and the initial sequence of stickers on the wall define the result of the game i e the difference between the Petya s and Gena s score if both players play optimally ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)2e5+5;\nint n,a[N],m,s[N],ans[N];\n\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t\tcin >> a[i];\n\ts[0]=a[0];\n\tfor(int i=1;i<n;i++)\n\t\ts[i]=s[i-1]+a[i];\n\tans[n-2]=s[n-1];\n\tm=s[n-2]-ans[n-2];\n\tfor(int i=n-3;i>=0;i--)\n\t{\n\t\tif(i==0)ans[i]=max(m,s[n-1]); else ans[i]=max(m,s[n-1]-s[i-1]);\n\t\tm=max(m,s[i]-ans[i]);\n\t}\n\tcout << ans[0];\n\treturn 0;\n}\n']",,,"['dp', 'games']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Funny Game.json,https://codeforces.com//blog/entry/47840,First of all comment on such type of games In CS the game where two players are willing to maximize the difference between their own score and the score of their opponent is called a zero sum game A useful knowledge is that problems for such a kind of games are usually solved using dynamic programming Note that at any moment the first sticker contains the sum of numbers on some prefix of an original sequence This means that the state of a game is defined by a single number the length of an original sequence prefix that were summed into a single number Let s make two observations First of all for any state the turn that current player will perform doesn t depend on scores of both players Indeed at any moment we may forget about the scores of both players since they add the constant factor to the resulting score difference so we may virtually discard both players current scores So all we need to know about state is what difference there will be between the current player score and his opponent score if the game would have started from the state with zero scores Second observation is that the turn chosen by a player from the state and the final difference of scores at the end does not depend from which player is currently making a turn Petr or Gennady i e the game is symmetric Denote as the difference between the first player score and the second player score if the game would have started from the state with zero scores It is a convenient way to think about this game as if there were no separate scores of two players but only a single balance value difference between them and the first player is adding some numbers to the balance at his turn nd second player subtracts some numbers from the balance In such formulation is a balance change at the end of the game if the current player is willing to maximize it and he is currently in the state The answer for a problem will be as one can see Note that if the current player would be willing to minimize balance then the final balance change from the state would be because the game is symmetric Let s calculate all using dynamic programming At the end of the game i e in the state the value is equal to zero because the players won t be making any turns and so the balance won t change Consider some state Suppose current player will take all the stickers up to the th here th means the index in the original sequence In such case he will change balance by where is the sum of first numbers in an original sequence and game will move to the state After that his opponent will change the balance by note that the balance change value is added with an opposite sign since the opponent will be playing from this state So the final balance change when making such a turn will be In the DP definition we play for a player that is willing to maximize the balance so Such a formula produces a solution in but one may find that that it s enough to keep the maximum value of on suffix recalculating it in when moving from to So we have the solution that works in Question Which data type should be used for and for the answer in particular 
https://codeforces.com//contest/273/problem/B,2628,B,273B,273,B. Dima and Two Sequences,Little Dima has two sequences of points with integer coordinates sequence and sequence Now Dima wants to count the number of distinct sequences of points of length that can be assembled from these sequences such that the coordinates of points in the assembled sequence will Help him with that Note that each element of the initial sequences should be used exactly once in the assembled sequence Dima considers two assembled sequences and distinct if there is such that As the answer can be rather large print the remainder from dividing the answer by number ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\nvector<pair<int, int> > a;\nint main(void) {\n    int n;\n    scanf(""%d"", &n);\n    for(int i=0;i<n;i++) {\n        int x; scanf(""%d"", &x);\n        a.push_back(make_pair(x, i+1));\n    }\n    for(int i=0;i<n;i++) {\n        int x; scanf(""%d"", &x);\n        a.push_back(make_pair(x, i+1));\n    }\n    int MOD;\n    scanf(""%d"", &MOD);\n    sort(a.begin(), a.end());\n    int ans=1;\n    for(int i=0,j=0;i<n*2;i=j) {\n        while(j<n*2 && a[j].first == a[i].first) j++;\n        int v=0, m=j-i, q=1;\n        for(int k=i+1;k<j;k++) if(a[k].second == a[k-1].second) ++v;\n        for(int k=1;k<=m;k++) {\n            int s=k; while(v>0 && s%2==0) s/=2,v--;\n            q=q*1LL*s%MOD;\n        }\n        ans=ans*1LL*q%MOD;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']",,,['combinatorics'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Dima and Two Sequences.json,https://codeforces.com/blog/entry/6625,Not hard to understand that answer will be number of numbers with first coordinate 1 number of numbers with first coordinate 2 number of numbers with first coordinate 10 9 2 number of such i 1 n that Ai Bi The only problem was to divide number with non prime modulo it can be easely done if we will count number of prime mulpiplies 2 in all factorials Then we can simply substract number that we need and multiply answer for some power of 2 
https://codeforces.com//contest/1010/problem/E,201806,E,1010E,1010,E. Store,Natasha was already going to fly back to Earth when she remembered that she needs to go to the Martian store to buy Martian souvenirs for her friends It is known that the Martian year lasts x max months month lasts y max days day lasts z max seconds Natasha also knows that this store works according to the following schedule 2 months in a year were selected x l and x r 1 le x l le x r le x max 2 days in a month y l and y r 1 le y l le y r le y max and 2 seconds in a day z l and z r 1 le z l le z r le z max The store works at all such moments month x day y second z when simultaneously x l le x le x r y l le y le y r and z l le z le z r Unfortunately Natasha does not know the numbers x l x r y l y r z l z r One Martian told Natasha I went to this store n m times n times of them it was opened and m times closed He also described his every trip to the store the month day second of the trip and whether the store was open or closed at that moment Natasha can go to the store k times For each of them determine whether the store at the time of the trip is open closed or this information is unknown ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin  t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nstruct SegTree {\n  int shift;\n  vector<int> tree;\n  vector<int> xs;\n  void build() {\n    make_unique(xs);\n    shift = 1;\n    while (shift < xs.size()) {\n      shift *= 2;\n    }\n    tree.assign(2 * shift, 0);\n  }\n  int get_lower_bound(int coord) {\n    return lower_bound(all(xs), coord) - xs.begin();\n  }\n  int get_sum(int l, int r) {\n    l = get_lower_bound(l);\n    r = get_lower_bound(r);\n    l += shift;\n    r += shift;\n    int res = 0;\n    while (l < r) {\n      if (l & 1) {\n        res += tree[l++];\n        continue;\n      }\n      if (r & 1) {\n        res += tree[--r];\n        continue;\n      }\n      l /= 2;\n      r /= 2;\n    }\n    return res;\n  }\n  void update(int x, int val) {\n    int v = get_lower_bound(x);\n    assert(xs[v] == x);\n    v += shift;\n    while (v) {\n      tree[v] += val;\n      v /= 2;\n    }\n  }\n};\n\nstruct LargeTree {\n  int shift;\n  vector<SegTree> trees;\n  LargeTree(int n) {\n    shift = 1;\n    while (shift < n) {\n      shift *= 2;\n    }\n    trees.resize(2 * shift);\n  }\n  void build() {\n    for (int i = 0; i < trees.size(); ++i) {\n      trees[i].build();\n    }\n  }\n  void raw_insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].xs.push_back(y);\n      x /= 2;\n    }\n  }\n  void insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].update(y, 1);\n      x /= 2;\n    }\n  }\n  int count(int lx, int rx, int ly, int ry) {\n    lx += shift;\n    rx += shift;\n    int res = 0;\n    while (lx < rx) {\n      if (lx & 1) {\n        res += trees[lx++].get_sum(ly, ry);\n        continue;\n      }\n      if (rx & 1) {\n        res += trees[--rx].get_sum(ly, ry);\n        continue;\n      }\n      lx /= 2;\n      rx /= 2;\n    }\n    return res;\n  }\n};\n\nconst int C = 100500;\n\nstruct Query {\n  int z;\n  int lx, rx;\n  int ly, ry;\n  int sign;\n  int id;\n};\n\nint pidorand() {\n  return (rand() << 16) | rand();\n}\n\n#ifndef AIM\n#define rand pidorand\n#endif\n\nvoid solve(bool read) {\n  //read = false;\n  LargeTree tree(C);\n  vector<int> borders(3);\n  for (int i = 0; i < 3; ++i) {\n    if (read) {\n      cin >> borders[i];\n    } else {\n      borders[i] = 100000;\n    }\n  }\n  int n, m, k;\n  if (read) {\n    cin >> n >> m >> k;\n  } else {\n    n = 1;\n    m = 100000;\n    k = 100000;\n  }\n  vector<int> mins(3, C), maxes(3, 0);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      int cur;\n      if (read) {\n        cin >> cur;\n      } else {\n        cur = rand() % borders[j] + 1;\n      }\n      relax_min(mins[j], cur);\n      relax_max(maxes[j], cur);\n    }\n  }\n  auto is_into = [&] (const vector<int>& cur) {\n    for (int i = 0; i < 3; ++i) {\n      if (cur[i] < mins[i] || cur[i] > maxes[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  vector<vector<vector<int>>> not_visited(C);\n  for (int i = 0; i < m; ++i) {\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n    }\n    if (is_into(cur)) {\n      cout << ""INCORRECT\\n"";\n      return;\n    }\n    not_visited[cur[2]].push_back({cur[0], cur[1]});\n    tree.raw_insert(cur[0], cur[1]);\n  }\n  tree.build();\n\n  cout << ""CORRECT\\n"";\n\n  vector<int> res(k, 0);\n  vector<bool> is_inside(k, false);\n  vector<vector<Query>> queries(C);\n  for (int i = 0; i < k; ++i) {\n    auto cur_mins = mins;\n    auto cur_maxes = maxes;\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n      relax_min(cur_mins[j], cur[j]);\n      relax_max(cur_maxes[j], cur[j]);\n    }\n    if (is_into(cur)) {\n      is_inside[i] = true;\n      continue;\n    }\n    Query cur_q = {cur_maxes[2], cur_mins[0], cur_maxes[0] + 1, cur_mins[1], cur_maxes[1] + 1, 1, i};\n    queries[cur_q.z].push_back(cur_q);\n    cur_q.z = cur_mins[2] - 1;\n    cur_q.sign = -1;\n    if (cur_q.z >= 0) {\n      queries[cur_q.z].push_back(cur_q);\n    }\n  }\n\n  for (int z = 0; z < C; ++z) {\n    for (auto& vec : not_visited[z]) {\n      tree.insert(vec[0], vec[1]);\n    }\n    for (auto& q : queries[z]) {\n      res[q.id] += q.sign * tree.count(q.lx, q.rx, q.ly, q.ry);\n    }\n  }\n\n  for (int i = 0; i < k; ++i) {\n    if (is_inside[i]) {\n      cout << ""OPEN\\n"";\n      continue;\n    }\n    if (res[i] > 0) {\n      cout << ""CLOSED\\n"";\n      continue;\n    }\n    cout << ""UNKNOWN\\n"";\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",,,['data structures'],2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Store.json,https://codeforces.com/blog/entry/60851,Consider options This means that Natasha does not know about any moment when the store was closed Let s find the numbers where are moments when store is open For each query answer if and Answer otherwise Let s find the numbers where are moments when store is open If there is at least one moment when the store is closed and and then the answer is Otherwise let s create a compressed two dimensional segment tree The first coordinate is number of the month in the year the second coordinate is number of the day in a month At each vertex of the tree of segments we store a pair of numbers the greatest such number of a second when the store was closed in this day of this month that and the smallest such number of a second when the store was closed in this day of this month that Now every query we will handle like this If and answer Otherwise consider the parallelepiped given by the coordinates of opposite vertices and and consider each vertex in turn the parallelepiped under consideration Let s make the query in the segment tree Let the received answer is If the number or number is between numbers and this means that there is such a time point when the store is closed that is between and the month of the year when the store is closed is between the month in the year when the store is open and the month in the year in the query is between and the day in the month when the store is closed is between the day in the month when the store is open and the day in the month in the query is between and second in a day when the store is closed is between a second in a day when the store is open and a second in a day in the query hence the answer to the query is If the condition is not satisfied for any vertex of the parallelepiped the answer is Complexity 
https://codeforces.com//contest/1844/problem/E,2009575,E,1844E,1844,E. Great Grids,An n times m grid of characters is called if it satisfies these three conditions Each character is either or Every 2 times 2 contiguous subgrid contains all three different letters Any two cells that share a common edge contain different letters Let x y denote the cell in the x th row from the top and y th column from the left You want to construct a great grid that satisfies k constraints Each constraint consists of two cells x i 1 y i 1 and x i 2 y i 2 that share exactly one corner You want your great grid to have the same letter in cells x i 1 y i 1 and x i 2 y i 2 Determine whether there exists a great grid satisfying all the constraints ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,k,i,j,fa[8005];\nint fnd(int x){if(fa[x]==x)return x;return fa[x]=fnd(fa[x]);}\nvoid merge(int x,int y){fa[fnd(x)]=fnd(y);}\nvoid solve()\n{\n\tread(n);read(m);read(k);fz1(i,n+m+n+m)fa[i]=i;\n\tfz1(i,k){\n\t\tint x1,y1,x2,y2;read(x1);read(y1);read(x2);read(y2);\n\t\tint x=min(x1,x2),y=min(y1,y2);\n\t\tif((x1==x)==(y1==y)){\n\t\t\tmerge(x,y+n);\n\t\t\tmerge(x+n+m,y+n+n+m);\n\t\t}\n\t\telse{\n\t\t\tmerge(x,y+n+n+m);\n\t\t\tmerge(x+n+m,y+n);\n\t\t}\n\t}\n\tfz1(i,n+m)if(fnd(i)==fnd(i+n+m)){\n\t\tputs(""NO"");return;\n\t}\n\tputs(""YES"");\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']",,,"['2-sat', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Great Grids.json,https://codeforces.com//blog/entry/118128,We present two approaches Let the letters and correspond to the numbers and modulo respectively Consider drawing an arrow between any two adjacent cells in a great grid pointing to the right or down and label this arrow with the difference of the two cells modulo The conditions imply that all labels are or and in each contiguous subgrid the top arrow has the same label as the bottom arrow and the left arrow has the same label as the right arrow Hence we can associate a type to each of rows and columns which is its label A constraint for cells and means that row and column must have different labels and a constraint for cells and means that row and must have the same label These relations form a graph and the problem reduces to a variant of colourability which can be checked using DFS or a DSU In a great grid draw a or for each subgrid connecting the equal letters We can observe that these grids have a simple pattern every two rows are either the same or opposite Furthermore any such pattern corresponds to a great grid this can be proven with the idea in approach 1 We can associate a type to each row and column a boolean variable or such that an entry is or depending on whether the labels are the same or different The constraints correspond to entries needing to be or forming a graph of pairs of labels that must be the same or different Thus the problem reduces to a variant of colourability which can be checked using DFS or a DSU The intended time complexity is although slower implementations with complexities like or can also pass 
https://codeforces.com//contest/246/problem/E,2239,E,246E,246,E. Blood Cousins Return,Polycarpus got hold of a family tree The found tree describes the family relations of people numbered from 1 to Every person in this tree has at most one direct ancestor Also each person in the tree has a name the names are not necessarily unique We call the man with a number a 1 ancestor of the man with a number if the man with a number is a direct ancestor of the man with a number We call the man with a number a ancestor of the man with a number if the man with a number has a 1 ancestor and the man with a number is a ancestor of the 1 ancestor of the man with a number In the tree the family ties do not form cycles In other words there isn t a person who is his own direct or indirect ancestor that is who is an ancestor of himself for some We call a man with a number the son of the man with a number if the man with a number is a ancestor of the man with a number Polycarpus is very much interested in how many sons and which sons each person has He took a piece of paper and wrote pairs of numbers Help him to learn for each pair the number of distinct names among all names of the sons of the man with number ,"['#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\nconst int maxn=1000*100*2;\nvi g[maxn], q[maxn], qi[maxn], rt;\nchar S[100000];\nstring s[maxn], ts[maxn];\nint n, m, nm[maxn], ans[maxn], l[maxn], zz;\nvector<set<int> > T[maxn];\nvoid mer(set<int> &l, set<int> &r)\n{\n    if (l.size()<r.size()) l.swap(r);\n    for (set<int>::iterator it=r.begin(); it!=r.end(); it++)\n        l.insert(*it);\n}\nint nh;\nvoid dfs(int v, int h=0)\n{\n    nh++;\n    for (int i=0;i<q[v].size();i++)\n    {\n        int th=h+q[v][i];\n        l[qi[v][i]]=T[th].size();\n    }\n    set<int> tst;\n    tst.insert(lower_bound(ts, ts+zz, s[v])-ts);\n    T[h].push_back(tst);\n    for (int i=0; i<g[v].size(); i++)\n        dfs(g[v][i], h+1);\n    for (int i=0;i<q[v].size();i++)\n    {\n        int th=h+q[v][i], tl=l[qi[v][i]], tr=T[th].size();\n        if (tl==tr) continue;\n        for (int j=tr-1; j-1>=tl; j--)\n        {\n            mer(T[th][j-1], T[th][j]);\n            T[th].pop_back();\n        }\n        ans[qi[v][i]]=T[th][tl].size();\n    }\n}\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i=0; i<n;i++)\n    {\n        int p; scanf(""%s %d"", S, &p);\n        s[i]=ts[i]=string(S, S+strlen(S));\n        p--;\n        if (p!=-1) g[p].push_back(i); else rt.push_back(i);\n    }\n    scanf(""%d"", &m);\n    for (int i=0; i<m; i++)\n    {\n        int v, k;\n        scanf(""%d %d"", &v, &k);\n        v--;\n        q[v].push_back(k);\n        qi[v].push_back(i);\n    }\n    sort(ts, ts+n); zz=unique(ts, ts+n)-ts;\n    for (int i=0; i<rt.size(); i++) dfs(rt[i], nh);\n    for (int i=0; i<m; i++) printf(""%d\\n"", ans[i]);\n    return 0;\n}\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dp', 'sortings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Blood Cousins Return.json,https://codeforces.com//blog/entry/5934,This problem had little in common with problem 208E Blood Cousins In comments to this problem there was given a solution using structure deque array in which you can add or delete elements from both endings Let s describe solution using this structure Firstly all different names change with different integers and for every vertex v save all queries with this vertex Then for every vertex which is root of some tree make dfs the parameters of dfs are vertex v and deque set z This deque for every depth i of the subtree of v save set all different names integers on depth i This deque could be calculated simply Consider all sons of v and calculate such deque for them Obviously the size of our deque z will be maximum of sizes of descendants deques Then consider every descendants deques and merge appropriate sets of integers Of course we will merge smaller set to a larger set After that you should insert to the beginning of deque z the set of size 1 color of vertex v After this you can at once answer all queries of vertex v Answer is 0 if v has no descendants on the depth k or the size of z k It is known that such method has good asymptotic the author s solution works about one second The asymptotic is O N log2 N The solution should be realized carefully You must not copy every element of your set or deque You should do swap of smaller and greater set or deque without copying elements ant than merge smaller to greater 
https://codeforces.com//contest/1182/problem/D,356989,D,1182D,1182,D. Complete Mirror,You have given tree consist of n vertices Select a vertex as root vertex that satisfies the condition below For all vertices v 1 and v 2 if distance root v 1 distance root v 2 then degree v 1 degree v 2 where degree means the number of vertices connected to that vertex and distance means the number of edges between two vertices Determine and find if there is such root vertex in the tree If there are multiple answers find any of them ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nint n;\nstruct R{int v,z;}e[222222];\nint K[111111],ce;\nint q[111111],du,my;\nint d[111111],pa[111111];\nint qaq[111111],deg[111111],dep[111111],siz[111111];\n#define push(x) (q[++my]=x)\n#define pop() q[du++]\n#define front() q[du]\n#define clear() (du=1,my=0)\nvoid ins(int a,int b)\n{\n\te[++ce]=(R){b,K[a]};\n\tK[a]=ce;\n\t++deg[a];\n}\nint measure(int u)\n{\n\tclear();\n\tdep[u]=0;\n\tpa[u]=0;\n\tint tot=0;\n\tfor(push(u);du<=my;++tot)\n\t{\n\t\tint u=pop();\n\t\tsiz[u]=1;\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].v!=pa[u])\n\t\t{\n\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\tpa[e[i].v]=u;\n\t\t\tpush(e[i].v);\n\t\t}\n\t}\n\tfor(int i=my;i;--i)\n\t{\n\t\tint u=q[i];\n\t\tif(siz[u]>=(tot+1)>>1)return u;\n\t\tsiz[pa[u]]+=siz[u];\n\t}\n\tassert(0);\n}\nint is_link(int u,int pa)\n{\n\tint cnt=0,z=u;\n\tfor(int i=K[u];i;i=e[i].z)if(e[i].v!=pa)\n\t{\n\t\tz=is_link(e[i].v,u);\n\t\tif(z==-1)return -1;\n\t\t++cnt;\n\t}\n\tif(cnt>1)return -1;\n\treturn z;\n}\nvpii vec;\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v;\n\t\tscanf(""%d%d"",&u,&v);\n\t\tins(u,v);\n\t\tins(v,u);\n\t}\n\tint rt=measure(1);\n\tmeasure(rt);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(!qaq[dep[i]])qaq[dep[i]]=deg[i];\n\t\telse if(qaq[dep[i]]!=deg[i])goto hell;\n\t}\n\tprintf(""%d\\n"",rt);\n\treturn 0;\n\thell:;\n\tbool nlink=0;\n\tint clink=0;\n\tfor(int i=K[rt];i;i=e[i].z)\n\t{\n\t\tint qwq=is_link(e[i].v,rt);\n\t\tif(qwq!=-1)vec.push_back(pii(dep[qwq],e[i].v)),++clink;\n\t}\n\tif(clink==0)\n\t{\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\tmap<int,int>mp;\n\tfor(vpii::itr it=vec.begin();it!=vec.end();++it)++mp[it->first];\n\tfor(map<int,int>::itr it=mp.begin();it!=mp.end();++it)\n\t{\n\t\tif(it->second==1)\n\t\t{\n\t\t\tfor(int i=K[rt];i;i=e[i].z)\n\t\t\t{\n\t\t\t\tint qwq=is_link(e[i].v,rt);\n\t\t\t\tif(qwq!=-1)\n\t\t\t\t{\n\t\t\t\t\tif(dep[qwq]==it->first)\n\t\t\t\t\t{\n\t\t\t\t\t\tmeasure(qwq);\n\t\t\t\t\t\tmemset(qaq,0,sizeof(qaq));\n\t\t\t\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!qaq[dep[i]])qaq[dep[i]]=deg[i];\n\t\t\t\t\t\t\telse if(qaq[dep[i]]!=deg[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tputs(""-1"");\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(""%d\\n"",qwq);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(""-1"");\n\treturn 0;\n}']",,,"['constructive algorithms', 'dfs and similar', 'dp', 'hashing', 'implementation', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Complete Mirror.json,https://codeforces.com//blog/entry/67614,First the valid tree should form like the picture below unless the whole tree is completely linear This node is the top of the tree This node has always degree This node is always one of the possible answers of valid tree There might be no top node in the tree This node is the closest children from the top node that satisfies In other words this node is the end of the leaf branch which includes top node as leaf This node can be one of the possible answers of valid tree If there is no semitop in the tree the whole tree is invalid This is the area of nodes between semitop node and semibottom nodes These nodes are the closest ancestors from each leaf nodes which satisfies In other words these nodes are the end of each leaf branches These nodes are the leaves except top node And also let s define and are if there are only nodes with between and exclusive There are two ways to find the top node and the semitop node Lawali s solution Find the diameter path and validate for two leaves of the diameter path If no valid vertex found i e top is not in the diameter path then the semitop should be the middle of the diameter path Now validate for the semitop and the closest directly reachable leaf from semitop If any valid vertex found print it Otherwise print The first case of diameter path in valid tree Semitop node is the middle of diameter path The second case of diameter path in valid tree Top node is the end of diameter path McDic s solution Clone the whole tree and cut the leaf branches include top from the cloned tree Let s call this tree as Inner tree consists of only semitop mid level nodes and semibottom nodes Then you can find the semitop by collapsing each level from leaf nodes of inner tree Now validate for semitop the furthest directly reachable leaf node from semitop and the closest directly reachable leaf node from semitop It is guaranteed that the top node is one of those two leaves If any valid vertex found print it Otherwise print This is the inner tree of original tree You can find the semitop easier than before since top is removed in inner tree Time complexity is 
https://codeforces.com//contest/1608/problem/B,1223924,B,1608B,1608,B. Build the Permutation,You are given three integers n a b Determine if there exists a permutation p 1 p 2 ldots p n of integers from 1 to n such that There are exactly a integers i with 2 le i le n 1 such that p i 1 p i p i 1 in other words there are exactly a local maximums There are exactly b integers i with 2 le i le n 1 such that p i 1 p i p i 1 in other words there are exactly b local minimums If such permutations exist find any such permutation ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//AOJGRL4B\ntemplate<class t>\nvi toposort(vvc<t> g){\n\tint n=g.size();\n\tvi a(n);\n\trep(i,n)for(auto e:g[i])\n\t\ta[e]++;\n\tqueue<int> q;\n\trep(i,n)if(a[i]==0)\n\t\tq.push(i);\n\tvi res;\n\trep(i,n){\n\t\tif(q.empty())return {};\n\t\tint v=q.front();q.pop();\n\t\tres.pb(v);\n\t\tfor(auto e:g[v])\n\t\t\tif(--a[e]==0)\n\t\t\t\tq.push(e);\n\t}\n\treturn res;\n}\n\nvoid muri(){\n\tprint(-1);\n}\n\nvoid slv(){\n\tint n,a,b;cin>>n>>a>>b;\n\tif(a+b>n-2){\n\t\treturn muri();\n\t}\n\tvi z;\n\tif(a==b+1||a==b){\n\t\trep(i,a){\n\t\t\tz.pb(0);\n\t\t\tz.pb(1);\n\t\t}\n\t\tif(a==b)z.pb(0);\n\t}else if(a==b-1){\n\t\trep(i,b){\n\t\t\tz.pb(1);\n\t\t\tz.pb(0);\n\t\t}\n\t}else return muri();\n\tif(z.empty())z.pb(0);\n\tz.resize(n-1,z.back());\n\tvvc<int> g(n);\n\trep(i,n-1)if(z[i]==0)g[i].pb(i+1);\n\telse g[i+1].pb(i);\n\tvi idx=toposort(g);\n\tvi p(n);\n\trep(i,n)p[idx[i]]=i;\n\tprint_offset(p,1);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['constructive algorithms', 'greedy']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Build the Permutation.json,https://codeforces.com//blog/entry/97782,First answer does not exists if Second answer exists if and only if It happens because between every two consecutive local maximums must be exactly one local minimum And vice versa between two consecutive minimums must be exactly one maximum First case gives second both in total gives Lets build answer considering Otherwise we can build inverse answer swap and and perform replace Lets take biggest numbers i e from downto and put them consequentially such numbers on first position and on each second position from first are less then other numbers It gives that every number except first and last are local maximum or local minimum Rest of the numbers needed to be placed before this sequence in increasing order 
https://codeforces.com//contest/1665/problem/E,1360544,E,1665E,1665,E. MinimizOR,You are given an array a of n non negative integers numbered from 1 to n Let s define the of the array a as displaystyle min i neq j a i a j where denotes the bitwise OR operation There are q queries For each query you are given two integers l and r l r For each query you should find the cost of the subarray a l a l 1 ldots a r ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nconst int inf=(1<<30)-1;\nint a[100005],cntid,rt[100005];\nstruct stree\n{\n\tint ls,rs,cnt;\n}t[7000005];\ninline void build()\n{\n\tt[cntid=1]={0,0,0},rt[0]=1;\n}\ninline void pd(int now)\n{\n\tif(!t[now].ls) t[t[now].ls=++cntid]={0,0,0};\n\tif(!t[now].rs) t[t[now].rs=++cntid]={0,0,0};\n}\ninline void ins(int lst,int now,int l,int r,int p)\n{\n\tif(l==r)\n\t{\n\t\tt[now].cnt=t[lst].cnt+1;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(p<=mid)\n\t{\n\t\tpd(lst);\n\t\tt[now].rs=t[lst].rs;\n\t\tpd(now);\n\t\tins(t[lst].ls,t[now].ls,l,mid,p);\n\t}\n\telse\n\t{\n\t\tpd(lst);\n\t\tt[now].ls=t[lst].ls;\n\t\tpd(now);\n\t\tins(t[lst].rs,t[now].rs,mid+1,r,p);\n\t}\n\tt[now].cnt=t[t[now].ls].cnt+t[t[now].rs].cnt;\n}\ninline int ask(int now,int l,int r,int L,int R)\n{\n\tif(!now) return 0;\n\tif(l==L&&r==R) return t[now].cnt;\n\tint mid=(l+r)>>1;\n\tif(mid>=R) return ask(t[now].ls,l,mid,L,R);\n\tif(mid+1<=L) return ask(t[now].rs,mid+1,r,L,R);\n\treturn ask(t[now].ls,l,mid,L,mid)+ask(t[now].rs,mid+1,r,mid+1,R);\n}\n/*inline int ask(int l,int r,int x)\n{\n\tint ans=0;\n\tfor(int i=l;i<=r;i++)\n\t\tans+=a[i]<=x;\n\treturn ans;\n}*/\ninline int query(int lst,int now,int l,int r,int cnt)\n{\n\tif(l==r) return l;\n\tint mid=(l+r)>>1;\n\tif(t[t[now].ls].cnt-t[t[lst].ls].cnt>=cnt) return query(t[lst].ls,t[now].ls,l,mid,cnt);\n\treturn query(t[lst].rs,t[now].rs,mid+1,r,cnt-t[t[now].ls].cnt+t[t[lst].ls].cnt);\n}\n/*inline int query(int l,int r,int x)\n{\n\tint ans=0;\n\tfor(int i=l;i<=r;i++)\n\t\tif(a[i]<=x) ans=max(ans,a[i]);\n\treturn ans;\n}*/\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tbuild();\n\t\tfor(int i=1;i<=n;i++) \n\t\t{\n\t\t\tcin >> a[i];\n\t\t\trt[i]=++cntid;\n\t\t\tt[rt[i]]={0,0,0};\n\t\t\tins(rt[i-1],rt[i],0,inf,a[i]);\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\twhile(q--)\n\t\t{\n\t\t\tint l,r;\n\t\t\tcin >> l >> r;\n\t\t\tvector <int> v;\n\t\t\tint ans=0;\n\t\t\tfor(int i=29;i>=0;i--)\n\t\t\t{\n\t\t\t\tint x=ask(rt[r],0,inf,ans,ans+(1<<i)-1)-ask(rt[l-1],0,inf,ans,ans+(1<<i)-1);\n\t\t\t\tint X=x;\n\t\t\t\tint qwq=(1<<30)-ans-1;\n\t\t\t\tqwq>>=i,qwq<<=i;\n\t\t\t\tfor(auto t:v) if(!(t&qwq)) ++x;\n\t\t\t\tif(x>=2) continue;\n\t\t\t\tans+=(1<<i);\n\t\t\t\tif(!X) continue; \n\t\t\t\tint nw=query(rt[l-1],rt[r],0,inf,ask(rt[r],0,inf,0,ans-1)-ask(rt[l-1],0,inf,0,ans-1)),flag=0;\n\t\t//\t\tcout << ask(rt[r],0,inf,0,ans-1)-ask(rt[l-1],0,inf,0,ans-1) << ""    "";\n\t\t//\t\tcout << l << "" "" << r << "" "" << ans-1 << "" "" << nw << ""\\n"";\n\t\t\t\tfor(auto t:v)\n\t\t\t\t\tif(t==nw) flag=1;\n\t\t\t\tif(!flag) v.push_back(nw);\n\t\t\t}\n\t\t\tcout << ans << ""\\n"";\n\t\t}\n\t}\n\t\n\treturn 0;\n}']",,,"['bitmasks', 'brute force', 'data structures', 'divide and conquer', 'greedy', 'implementation', 'two pointers']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. MinimizOR.json,https://codeforces.com//blog/entry/101663,EditorialThe key idea for the solution is that the answer always lies among no more than 31 minimal numbers According to this idea it is possible to build a segment tree for minimum on a segment After that we only need to find no more than 31 minimums on the segment each time we find one we change it to and finally we can find all ORs pairwise among these 31 numbers It is also possible to use the Merge Sort Tree and the same idea Now let s prove the key idea let s prove by induction that if all numbers are less than then it s enough to consider minimal numbers Base case all numbers are from to and the proof is obvious Inductive step Let s show that for any if for the statement is true then it s true for If all numbers have 1 in th bit then the th bit of the answer is also 1 that s why we only have to minimize the remaining bits For these bits we can apply the induction hypothesis that minimal numbers are enough If at least two numbers have 0 in their th bit then the th bit in the answer is also 0 That s why we only consider only numbers with 0 in th bit and we have to minimize the remaining bits Again applying the induction hypothesis minimal numbers are enough If there is exactly one number with 0 in th bit then the th bit in the answer is 1 and we have to find minimal numbers over bits They are among minimal numbers over bits so minimal numbers are enough 
https://codeforces.com//contest/1680/problem/B,1398256,B,1680B,1680,B. Robots,There is a field divided into n rows and m columns Some cells are empty denoted as other cells contain robots denoted as You can send a command to at the same time The command can be of one of the four types move up move right move down move left When you send a command attempt to take one step in the direction you picked If a robot tries to move outside the field it explodes otherwise moves to an adjacent cell in the chosen direction You can send as many commands as you want possibly zero in any order Your goal is to make at least one robot reach the upper left corner of the field Can you do this without forcing any of the robots to explode ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(string& x : s) cin >> x;\n\tint rx = -1, ry = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'E\') continue;\n\t\t\tif(rx == -1){\n\t\t\t\trx = i;\n\t\t\t\try = j;\n\t\t\t}\n\t\t\tif(i < rx || j < ry){\n\t\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ""YES"" << \'\\n\';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Robots.json,https://codeforces.com//blog/entry/102852,Let s assume that the rows are numbered from to from top to bottom and columns are numbered from to from left to right If there is no robot in the cell initially we have to perform several moves up and or left If the first row with at least one robot is the th row then we can make at most steps up and we should do at least steps up since otherwise there will me no robot in the upper row Similarly if the first column with at least one robot is the th column then we can make at most steps to the left and we should do at least steps to the left since otherwise there will me no robot in the leftmost column Now there are two possible solutions both starting with finding and we afterwards either simulate moves up and moves to the left and check that everything is fine or just check that there is a robot in the cell since only this robot can end up in 
https://codeforces.com//contest/365/problem/B,4037,B,365B,365,B. The Fibonacci Segment,You have array Segment is good if for all Let s define is the length of the segment Segment is longer than segment if Your task is to find a good segment of the maximum length in array Note that a segment of length or is always good ,"['#include <stdio.h>\n#include <string.h>\n\nint main(){\n\n    int test;\n    int ans=0,now=0;\n    long long prev1,prev2,temp;\n\n    for( scanf(""%d"",&test) ; test-- ; ){\n        if( now==0 ){\n            scanf(""%I64d"",&prev2);\n            now=1;\n        }\n        else if( now==1 ){\n            scanf(""%I64d"",&prev1);\n            now=2;\n        }\n        else{\n            scanf(""%I64d"",&temp);\n            if( prev1+prev2!=temp ){\n                now=2;  \n            }\n            else{\n                now++;\n            }\n            prev2=prev1;\n            prev1=temp; \n        }\n        \n        if( now>ans ) ans=now;\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n']",,,['implementation'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. The Fibonacci Segment.json,https://codeforces.com//blog/entry/9657,Good sequence may contain only zeroes or contain some positive number In the second case such a sequence is not longer than sequence 0 1 1 2 3 5 8 x y where y 109 and x 109 That s possible to find it using dummy algorithm In the first case you may use binary search of two pointers 
https://codeforces.com//contest/2005/problem/E2,2874766,E2,2005E2,2005,E2. Subtangle Game  Hard Version ,Tsovak and Narek are playing a game They have an array a and a matrix b of integers with n rows and m columns numbered from 1 The cell in the i th row and the j th column is i j They are looking for the elements of a in turns Tsovak starts first Each time a player looks for a cell in the matrix containing the current element of a Tsovak looks for the first then Narek looks for the second etc Let s say a player has chosen the cell r c The next player has to choose his cell in the submatrix starting at r 1 c 1 and ending in n m the submatrix can be empty if r n or c m If a player cannot find such a cell or the remaining submatrix is empty or the array ends the previous player has chosen the last element then he loses Your task is to determine the winner if the players play optimally For example in C it is enough to use the following lines at the start of the function int main ios base sync with stdio false cin tie NULL cout tie NULL ,"['#include <bits/stdc++.h>using namespace std;\xa0vector < vector < pair <int , int> > > aparitii;vector < vector <int> > matrice;vector <int> sir , maxim;\xa0inline void Solve (){    int lungime , linii , coloane;    cin >> lungime >> linii >> coloane;\xa0    aparitii.resize(linii * coloane + 1);    matrice.resize(linii + 1);    sir.resize(lungime + 1);\xa0    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[indice]; }\xa0    for (int linie = 1 ; linie <= linii ; linie++)     {        matrice[linie].resize(coloane + 1);        for (int coloana = 1 ; coloana <= coloane ; coloana++)            { cin >> matrice[linie][coloana]; }    }            for (int coloana = 1 ; coloana <= coloane ; coloana++) {        for (int linie = 1 ; linie <= linii ; linie++) {            if (!aparitii[matrice[linie][coloana]].empty() && aparitii[matrice[linie][coloana]].back().second == coloana)                { aparitii[matrice[linie][coloana]].back().first = linie; }            else                { aparitii[matrice[linie][coloana]].push_back({linie , coloana}); }        }    }    \xa0    matrice.clear();    maxim.resize(coloane + 2);    for (int indice = lungime ; indice ; indice--)    {        int ramas = 0;        for (auto locatie : aparitii[sir[indice]])         {            while (ramas < locatie.second)                { maxim[++ramas] = 0; }\xa0            if (maxim[locatie.second + 1] <= locatie.first)                { maxim[ramas] = locatie.first; }        }\xa0        while (ramas < coloane)            { maxim[++ramas] = 0; }\xa0        for ( ; ramas ; ramas--)            { maxim[ramas] = max(maxim[ramas] , maxim[ramas + 1]); }    }\xa0    cout << (maxim[1] ? ""T\\n"" : ""N\\n"");\xa0    aparitii.clear();    maxim.clear();    sir.clear();}\xa0int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);\xa0    int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }\xa0    return 0;}']",,,"['data structures', 'dp', 'games', 'greedy', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E2. Subtangle Game  Hard Version .json,https://codeforces.com/blog/entry/133869,Let s define dp0i j as the minimal even index k 1 k l such that dpk i j wins Define dp1i j similarly for odds First fill all of them with Then compute them from the bottom right cell of the matrix to the top left cell of the matrix dp0i j will be the minimal of the following three values dp0i 1 j if i n there will be no submatrix left so dp0i 1 j will be dp0i j 1 Let s define by ind the index of bi j in a there are no duplicates in a and if there is no bi j there assign to ind If dp1i 1 j 1 ind 1 which means that dpind 1 i 1 j 1 loses and ensues the current player s win then the value of this part will be ind Otherwise This is because in other cases the opponent either had a winning position starting from ind 1 or even earlier in the game so we can t win from that index We count dp1 similarly but we count dp0 and dp1 simultaneously for every i j Lastly if dp11 1 1 then Tsovak wins otherwise Narek wins 
https://codeforces.com//contest/1422/problem/D,748726,D,1422D,1422,D. Returning Home,Yura has been walking for some time already and is planning to return home He needs to get home as fast as possible To do this Yura can use the instant movement locations around the city Let s represent the city as an area of n times n square blocks Yura needs to move from the block with coordinates s x s y to the block with coordinates f x f y In one minute Yura can move to any neighboring by side block in other words he can move in four directions Also there are m instant movement locations in the city Their coordinates are known to you and Yura Yura can move to an instant movement location in no time if he is located in a block with the same coordinate x or with the same coordinate y as the location Help Yura to find the smallest time needed to get home ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\n//I S(int x){return 1ll*x*(x+1)/2%mod;}\nint n,m,ans;\nint Sx,Sy,Fx,Fy;\nint X[N],Y[N],tag[N];\nint idx[N],idy[N],posx[N],posy[N];\nI dis(int x,int y,int p){\n\treturn min(abs(X[p]-x),abs(Y[p]-y));\n}\n#define P pair<int,int>\npriority_queue<P>q;\nV input(){\n\tn=getint(),m=getint();\n\tSx=getint(),Sy=getint(),Fx=getint(),Fy=getint();\n\tFOR(i,1,m)X[i]=getint(),Y[i]=getint();\n\tans=abs(Fx-Sx)+abs(Fy-Sy);\n\tFOR(i,1,m)q.push(P(-dis(Sx,Sy,i),i));\n}\nI cmpx(int x,int y){return X[x]<X[y];}\nI cmpy(int x,int y){return Y[x]<Y[y];}\nV init(){\n\tFOR(i,1,m)idx[i]=i;\n\tsort(idx+1,idx+1+m,cmpx);\n\tFOR(i,1,m)posx[idx[i]]=i;\n\tFOR(i,1,m)idy[i]=i;\n\tsort(idy+1,idy+1+m,cmpy);\n\tFOR(i,1,m)posy[idy[i]]=i;\n}\nV work(){\n\tfor(int u,w,v;!q.empty();){\n\t\tw=-q.top().first,u=q.top().second,q.pop();\n\t\tif(tag[u])continue;\n\t\ttag[u]=1,ans=min(0ll+ans,0ll+w+abs(X[u]-Fx)+abs(Y[u]-Fy));\n\t\tif((v=idx[posx[u]-1])&&!tag[v])\n\t\t\tq.push(P(-w-X[u]+X[v],v));\n\t\tif((v=idx[posx[u]+1])&&!tag[v])\n\t\t\tq.push(P(-w-X[v]+X[u],v));\n\t\tif((v=idy[posy[u]-1])&&!tag[v])\n\t\t\tq.push(P(-w-Y[u]+Y[v],v));\n\t\tif((v=idy[posy[u]+1])&&!tag[v])\n\t\t\tq.push(P(-w-Y[v]+Y[u],v));\n\t}\n\tcout<<ans<<\'\\n\';\n}\nint main(){\n//\tfreopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n//\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n//\t}\n\treturn 0;\n}\n']",,,"['graphs', 'shortest paths', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Returning Home.json,https://codeforces.com//blog/entry/83452,You can build a graph with vertices at the start point and all fast travel points The distance between the vertices and is calculated as To avoid drawing all edges in the graph note that for a pair of points and such that if there is a point with coordinate such that it is between and then the distance between the first and second point will be equal to the sum of the distances between the first and third and between the third and second In this case the edge between the first and second points does not need to be drawn it will be unnecessary It turns out that for each point of the graph it will be enough to draw the edges to the points nearest along the axis in both directions Similarly for Next in the constructed graph we find the minimum distance from the starting point to each point of the graph and sum it up with the distance to the end point which is equal to Among all the distances we choose the minimum one 
https://codeforces.com//contest/877/problem/D,130131,D,877D,877,D. Olya and Energy Drinks,Olya loves energy drinks She loves them so much that her room is full of empty cans from energy drinks Formally her room can be represented as a field of cells each cell of which is empty or littered with cans Olya drank a lot of energy drink so now she can run meters per second Each second she chooses one of the four directions up down left or right and runs from to meters in this direction Of course she can only run through empty cells Now Olya needs to get from cell to cell How many seconds will it take her if she moves optimally It s guaranteed that cells and are empty These cells can coincide ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long  LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define F first\n#define S second\ninline int read(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == \'-\')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - \'0\';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar(\'0\'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar(\'-\');\n\t}\n\twrite(a); puts("""");\n}\n#include<string>\nconst int N=1005;\nint n,m,k,sx,sy,tx,ty,l,r,bs[N*N*4],s1[4]={0,0,1,-1},s2[4]={1,-1,0,0};\nbool vis[N][N][4];\npair<int,int> zz,zs,que[N*N*4];\nchar ch[N][N];\nint main(){\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++)scanf(""\\n%c"",&ch[i][j]);\n\t}\n\tcin>>sx>>sy>>tx>>ty;\n\tque[r=1]=mp(sx,sy); for(int i=0;i<4;i++)vis[sx][sy][i]=1;\n\twhile(l<r){\n\t\tzs=que[++l];\n\t\tif(zs==mp(tx,ty)){\n\t\t\twriteln(bs[l]); return 0;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tzz=zs;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tzz.F+=s1[i]; zz.S+=s2[i];\n\t\t\t\tif(zz.F&&zz.S&&zz.F<=n&&zz.S<=m&&!vis[zz.F][zz.S][i]&&ch[zz.F][zz.S]==\'.\'){\n\t\t\t\t\tvis[zz.F][zz.S][i]=1;\n\t\t\t\t\tque[++r]=zz;\n\t\t\t\t\tbs[r]=bs[l]+1;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t}\n\t}\n\tputs(""-1"");\n}']",,,"['data structures', 'dfs and similar', 'graphs', 'shortest paths']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Olya and Energy Drinks.json,https://codeforces.com//blog/entry/55362,Note that can find right answer but works in It s too slow We ll store all not visited cells in For each row and column we ll make own Now it s easy to find all not visited cell which is reachable from vertex in where is number of this cells Then summary it works in 
https://codeforces.com//contest/746/problem/D,85372,D,746D,746,D. Green and Black Tea,Innokentiy likes tea very much and today he wants to drink exactly cups of tea He would be happy to drink more but he had exactly tea bags of them are green and are black Innokentiy doesn t like to drink the same tea green or black more than times in a row Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink cups of tea without drinking the same tea more than times in a row or to inform that it is impossible Each tea bag has to be used exactly once ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)301*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n,k,a,b;\nchar A=\'G\',B=\'B\';\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>k>>a>>b;\n    if(a<b)swap(a,b),swap(A,B);\n    ll num=(a+k-1)/k-1;\n    if(num>b)return cout<<""NO"",0;\n    b-=num;\n    for(int i=0;i<num;i++)\n    {\n    \tfor(int j=0;j<k;j++)cout<<A;\n    \tcout<<B;\n    \tfor(int j=0;j<k-1 && b;j++,b--)cout<<B;\n\t}\n\tll p=a%k;\n\tif(p==0)p=k;\n\tfor(int j=0;j<p;j++)cout<<A;\n\tfor(int j=0;j<k && b;j++,b--)cout<<B;\n    return 0;\n}']",,,"['constructive algorithms', 'greedy', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Green and Black Tea.json,https://codeforces.com//blog/entry/49160,Let s use greedy to solve this problem On the current step we choose tea which left more but if the last cups were equal we need to use the other tea If we can t use the other tea there is no answer and we need to print So we need to store the number of last cups which were equals and how many of green and black tea left we greedily build the answer If we use all tea with this algorithm we found the answer and it is guaranteed that it is correct answer 
https://codeforces.com//contest/1477/problem/C,879397,C,1477C,1477,C. Nezzar and Nice Beatmap,Nezzar loves the game osu osu is played on beatmaps which can be seen as an array consisting of points on a plane A beatmap is called nice if for any three consecutive points A B C listed in order the angle between these three points centered at B is 90 degrees Now Nezzar has a beatmap of n points A 1 A 2 ldots A n Nezzar would like to reorder these n points so that the resulting beatmap is nice Formally you are required to find a permutation p 1 p 2 ldots p n of integers from 1 to n such that beatmap A p 1 A p 2 ldots A p n is nice If it is impossible you should determine it ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nint dist(pi a,pi b){\n\treturn sq(a.a-b.a)+sq(a.b-b.b);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> xy(n);\n\trep(i,n)xy[i]=readpi();\n\tvi used(n);\n\tused[0]=1;\n\tvi ans{0};\n\trep(i,n-1){\n\t\tint cur=ans[i];\n\t\tint f=-1;\n\t\trep(nx,n)if(!used[nx]){\n\t\t\tif(f==-1||dist(xy[cur],xy[f])<dist(xy[cur],xy[nx]))\n\t\t\t\tf=nx;\n\t\t}\n\t\tused[f]=1;\n\t\tans.pb(f);\n\t}\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['constructive algorithms', 'geometry', 'greedy', 'math', 'sortings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Nezzar and Nice Beatmap.json,https://codeforces.com//blog/entry/87294,There are two different approaches to solve this task Pick an arbitrary point and in each iteration select the furthest point from previously chosen point among all available points Indeed we can prove the correctness by contradiction Notice that in any triangle possibly degenerate there exists at most one obtuse angle or right angle in this triangle Therefore we may build our permutation using modified version of insertion sort it suffices to substitute comparing operator We believe that time complexity for the latter approach is better than However we fail to find a proof or counterexample for it It would be grateful if someone could figure it out and inform us about it 
https://codeforces.com//contest/89/problem/C,471,C,89C,89,C. Chip Play,Let s consider the following game We have a rectangular field in size Some squares of the field contain chips Each chip has an arrow painted on it Thus each chip on the field points in one of the following directions up down left or right The player may choose a chip and make a move with it The move is the following sequence of actions The chosen chip is marked as the current one After that the player checks whether there are more chips in the same row or in the same column with the current one that are pointed by the arrow on the current chip If there is at least one chip then the closest of them is marked as the new current chip and the former current chip is removed from the field After that the check is repeated This process can be repeated several times If a new chip is not found then the current chip is removed from the field and the player s move ends By the end of a move the player receives several points equal to the number of the deleted chips By the given initial chip arrangement determine the maximum number of points that a player can receive during one move Also determine the number of such moves ,"['#include<stdio.h>\nchar in[5010][5010];\nshort xp[5010][5010],xn[5010][5010];\nshort yp[5010][5010],yn[5010][5010];\ninline void del(int x,int y){\n    xn[xp[x][y]][y]=xn[x][y];\n    xp[xn[x][y]][y]=xp[x][y];\n    yn[x][yp[x][y]]=yn[x][y];\n    yp[x][yn[x][y]]=yp[x][y];\n}\ninline void add(int x,int y){\n    xn[xp[x][y]][y]=x;\n    xp[xn[x][y]][y]=x;\n    yn[x][yp[x][y]]=y;\n    yp[x][yn[x][y]]=y;\n}\nint n,m;\ninline int go(int x,int y){\n    if(x==0||y==0||x==n+1||y==m+1)return 0;\n    del(x,y);\n    int d;\n    if(in[x][y]==\'D\')d=go(xn[x][y],y);\n    else if(in[x][y]==\'U\')d=go(xp[x][y],y);\n    else if(in[x][y]==\'R\')d=go(x,yn[x][y]);\n    else if(in[x][y]==\'L\')d=go(x,yp[x][y]);\n    add(x,y);\n    return d+1;\n}\nint main(){\n    int i,j;\n    scanf(""%d%d"",&n,&m);\n    for(i=1;i<=n;i++)scanf(""%s"",in[i]+1);\n    for(i=1;i<=n;i++){\n\tint p=0;\n\tfor(j=1;j<=m+1;j++){\n\t    if(in[i][j]!=\'.\'){\n\t\tyn[i][p]=j;\n\t\typ[i][j]=p;\n\t\tp=j;\n\t    }\n\t}\n    }\n    for(j=1;j<=m;j++){\n\tint p=0;\n\tfor(i=1;i<=n+1;i++){\n\t    if(in[i][j]!=\'.\'){\n\t\txn[p][j]=i;\n\t\txp[i][j]=p;\n\t\tp=i;\n\t    }\n\t}\n    }\n    int ans=0,ac=0;\n    for(i=1;i<=n;i++){\n\tfor(j=1;j<=m;j++){\n\t    if(in[i][j]!=\'.\'){\n\t\tint d=go(i,j);\n\t\tif(d>ans){\n\t\t    ans=d;ac=1;\n\t\t}else if(d==ans)ac++;\n\t    }\n\t}\n    }\n    printf(""%d %d\\n"",ans,ac);\n}\n']",,,"['brute force', 'data structures', 'implementation']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Chip Play.json,https://codeforces.com//blog/entry/2162,This problem can be solved by simulation You can just iterate over all chips and for every of them calculate number of points But srupid simulate can give O k3 time solution where k is total number of chips It doesn t fit into time limits For example try test like 1 5000 RRRR 2500 times LLLL 2500 times You can simulate process in time by using some data structures like std set but it doesn t fit into limits too Similating in O k2 time is given by following data structure For every chip you can save links to chips that is placed up doun left and right from the considered chip Net of links can be built in O nm Now when you simulate process you can remove chips this way Chip L R Chip R Chip R L Chip L Chip U D Chip D Chip D U Chip U So jump from some chip to the next chip in a move can be done in O 1 Now you can simulate every move in O k Remove operation is reversible because every removed chip stores links to all of its neighbours Therefore you can save links to all removed chips in current move and after restore net of links using following operetions for all removed chips in reversed order Chip L R Chip Chip R L Chip Chip U D Chip Chip D U Chip Also you can just build net of links anew for every move 
https://codeforces.com//contest/667/problem/A,57418,A,667A,667,A. Pouring Rain,A lot of people in Berland hates rain but you do not Rain pacifies puts your thoughts in order By these years you have developed a good tradition when it rains you go on the street and stay silent for a moment contemplate all around you enjoy freshness think about big deeds you have to do Today everything had changed quietly You went on the street with a cup contained water your favorite drink In a moment when you were drinking a water you noticed that the process became quite long the cup still contained water because of rain You decided to make a formal model of what was happening and to find if it was possible to drink all water in that situation Thus your cup is a cylinder with diameter equals centimeters Initial level of water in cup equals centimeters from the bottom You drink a water with a speed equals milliliters per second But rain goes with such speed that if you do not drink a water from the cup the level of water increases on centimeters per second The process of drinking water from the cup and the addition of rain to the cup goes evenly and continuously Find the time needed to make the cup empty or find that it will never happen It is guaranteed that if it is possible to drink all water it will happen not later than after seconds Note one milliliter equals to one cubic centimeter ,"['#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, ""/STACK:256000000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define TASK """"\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define for1(i, n) for (int i = 1; i <= (int)n; i++)\n#define forq(i, s, t) for (int i = s; i <= (int)t; i++)\n#define ford(i, s, t) for (int i = s; i >= (int)t; i--)\n#define mk make_pair\n#define pk\tpush_back\n#define all(v) v.begin(), v.end()\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n\nconst double EPS = 1e-15;\nconst double PI = acos(-1.0);\nconst int MAXN = (int)1e5 + 7;\nconst int INF = (int)1e9 + 7;\nconst ll LINF = (ll)2e18 + 7;\nconst int MOD = (int)1e9 + 7;\nconst ull P = 239017;\nconst ull MM = (ull)2147482661;\n\t\nint solve();\n\nint main()\n{\n#ifdef _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tfreopen(""test.txt"", ""w"", stderr);\n\tdouble tstart = TIME;\n#else\n\t//freopen(TASK"".in"", ""r"", stdin), freopen(TASK"".out"", ""w"", stdout);\n#endif\n\treturn solve();\n}\n\nint solve()\n{\n\tdouble d, h, v, e;\n\tcin >> d >> h >> v >> e;\n\tdouble s = PI * (d * d) / 4;\n\tdouble u = e * s;\n\tif (u >= v) {\n\t\tprintf(""NO\\n"");\n\t}\n\telse {\n\t\tdouble ans = h * s / (v - u);\n\t\tprintf(""YES\\n%.10f"", ans);\n\t}\n\treturn 0;\n}']",,,"['geometry', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Pouring Rain.json,https://codeforces.com//blog/entry/44622,To know how much water you consume per second you should divide consumed volume by the area of the cup Then you should compare thisit with If your speed of drinking is greater then you ll drink all the water in seconds Otherwise you would never do it 
https://codeforces.com//contest/877/problem/B,130129,B,877B,877,B. Nikita and string,One day Nikita found the string containing letters and only Nikita thinks that string is beautiful if it can be cut into strings possibly empty without changing the order of the letters where the st and the rd one contain only letters and the nd contains only letters Nikita wants to make the string beautiful by removing some possibly none of its characters but without changing their order What is the maximum length of the string he can get ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long  LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define F first\n#define S second\ninline int read(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == \'-\')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - \'0\';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar(\'0\'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar(\'-\');\n\t}\n\twrite(a); puts("""");\n}\n#include<string>\nconst int N=5005;\nchar s[N];\nint dp[N][3];\nint main(){\n\tcin>>(s+1);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<3;j++)dp[i][j]=dp[i-1][j];\n\t\tif(s[i]==\'a\'){\n\t\t\tdp[i][0]++;\n\t\t\tdp[i][1]=max(dp[i][1],dp[i][0]);\n\t\t\tdp[i][2]=max(max(dp[i][1],dp[i][2]+1),dp[i-1][1]+1);\n\t\t}else{\n\t\t\tdp[i][1]=max(dp[i][1]+1,max(dp[i-1][0]+1,dp[i][0]));\n\t\t\tdp[i][2]=max(dp[i][2],dp[i][1]);\n\t\t}\n\t}\n\tcout<<dp[n][2]<<endl;\n}']",,,"['brute force', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Nikita and string.json,https://codeforces.com//blog/entry/55362,Let be the count of letter in prefix of length and be the count of letter in prefix of length Let s fix two positions and so we remove all from prefix which ends in and suffix which starts in and all between positions and Then length of string is Using two for loops we find optimal and and calculate answer 
https://codeforces.com//contest/1209/problem/C,411979,C,1209C,1209,C. Paint the Digits,You are given a sequence of n digits d 1d 2 dots d n You need to paint all the digits in two colors so that each digit is painted either in the color 1 or in the color 2 if you write in a row from left to right all the digits painted in the color 1 and then after them all the digits painted in the color 2 then the resulting sequence of n digits will be non decreasing that is each next digit will be greater than or equal to the previous digit For example for the sequence d 914 the only valid coloring is 211 paint in the color 1 two last digits paint in the color 2 the first digit But 122 is not a valid coloring 9 concatenated with 14 is not a non decreasing sequence It is allowed that either of the two colors is not used at all Digits painted in the same color are not required to have consecutive positions Find any of the valid ways to paint the given sequence of digits or determine that it is impossible to do ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint _,n,a[N],bit[N];\nchar s[N];\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d"",&n);\n\t\tscanf(""%s"",s);\n\t\trep(i,0,n) a[i]=s[i]-\'0\';\n\t\tauto solve=[&]() {\n\t\t\trep(md,0,10) {\n\t\t\t\trep(i,0,n) {\n\t\t\t\t\tif (a[i]==md) bit[i]=3;\n\t\t\t\t\telse if (a[i]<md) bit[i]=1;\n\t\t\t\t\telse bit[i]=2;\n\t\t\t\t}\n\t\t\t\tbool v2=0;\n\t\t\t\trep(i,0,n) {\n\t\t\t\t\tif (bit[i]==2) v2=1;\n\t\t\t\t\tif (bit[i]==3) { if (!v2) bit[i]=2; else bit[i]=1; }\n\t\t\t\t}\n\t\t\t\tVI v;\n\t\t\t\trep(i,0,n) if (bit[i]==1) v.pb(a[i]);\n\t\t\t\trep(i,0,n) if (bit[i]==2) v.pb(a[i]);\n\t\t\t\tbool f=1;\n\t\t\t\trep(i,1,n) if (v[i]<v[i-1]) f=0;\n\t\t\t\tif (f) {\n\t\t\t\t\trep(i,0,n) printf(""%d"",bit[i]);\n\t\t\t\t\tputs("""");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tif (!solve()) puts(""-"");\n\t}\n}\n']",,,"['constructive algorithms', 'greedy', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Paint the Digits.json,https://codeforces.com/blog/entry/69791,The sequence must split into two non decreasing where the end of the first start of the second Let s bruteforce the value x so that all elements x go to the color 1 all elements x go to the color 2 and for x we are not sure Actually we can say that all elements equal to x which go before the first element x an safely go to the color 2 while the rest can only go to the color 1 So we colored our sequence and we now only need to check whether this coloring is fine Complexity is 10 n 
https://codeforces.com//contest/71/problem/A,380,A,71A,71,A. Way Too Long Words,Sometimes some words like or are so long that writing them many times in one text is quite tiresome Let s consider a word if its length is than characters All too long words should be replaced with a special abbreviation This abbreviation is made like this we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters That number is in decimal system and doesn t contain any leading zeroes Thus will be spelt as and will be spelt as You are suggested to automatize the process of changing the words with abbreviations At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes ,"['#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nchar readin[110];\n\nmain(){\n\tint t;\n\t\n\tscanf ( ""%d"", &t );\n\twhile( t -- ){\n\t\tscanf ( ""%s"", readin );\n\t\tif ( strlen( readin ) > 10 )\n\t\t\tprintf( ""%c%d%c\\n"", readin[0], strlen( readin ) - 2, readin[ strlen( readin ) - 1 ] );\n\t\telse\n\t\t\tprintf( ""%s\\n"", readin );\n\t}\n\t\n\treturn 0;\n}\n']",,,['strings'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Way Too Long Words.json,https://codeforces.com//blog/entry/1624,In this problem you can just do what is written in the statement Let read all words For each of them compute its length L its the first and the last letter If L 10 output word without any changes otherwise output the first letter next L 2 and finally the last letter 
https://codeforces.com//contest/1844/problem/C,2009573,C,1844C,1844,C. Particles,You have discovered n mysterious particles on a line with integer charges of c 1 dots c n You have a device that allows you to perform the following operation Choose a particle and remove it from the line The remaining particles will shift to fill in the gap that is created If there were particles with charges x and y directly to the left and right of the removed particle they combine into a single particle of charge x y For example if the line of particles had charges of 3 1 4 1 5 9 performing the operation on the 4th particle will transform the line into 3 1 9 9 If we then use the device on the 1st particle in this new line the line will turn into 1 9 9 You will perform operations until there is only one particle left What is the maximum charge of this remaining particle that you can obtain ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,a[200005];\ni64 ans;\nvoid solve()\n{\n\tread(n);fz1(i,n)read(a[i]);\n\tans=-0x3f3f3f3f3f3f3f3fll;fz1(i,n)ans=max(ans,1ll*a[i]);\n\ti64 sum=0;bool flg=0;\n\tfor(i=1;i<=n;i+=2)if(a[i]>=0){\n\t\tflg=1;sum+=a[i];\n\t}\n\tif(flg) ans=max(ans,sum);\n\tsum=flg=0;\n\tfor(i=2;i<=n;i+=2)if(a[i]>=0){\n\t\tflg=1;sum+=a[i];\n\t}\n\tif(flg) ans=max(ans,sum);\n\tprintf(""%lld\\n"",ans);\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']",,,"['dp', 'greedy', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Particles.json,https://codeforces.com//blog/entry/118128,Consider the set of even indexed particles and the set of odd indexed particles Observe that particles can only ever combine with other particles from the same set It follows that the answer is at most On the other hand this bound is almost always obtainable We can first perform the operation on all negatively charged particles in the same set as the desired final particle then perform the operation on all the particles from the opposite set There is a corner case where all particles are negative where the answer is just The time complexity is 
https://codeforces.com//contest/1759/problem/C,1648491,C,1759C,1759,C. Thermostat,Vlad came home and found out that someone had reconfigured the old thermostat to the temperature of a The thermostat can only be set to a temperature from l to r inclusive the temperature cannot change by less than x Formally in one operation you can reconfigure the thermostat from temperature a to temperature b if a b ge x and l le b le r You are given l r x a and b Find the minimum number of operations required to get temperature b from temperature a or say that it is impossible ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nvoid solve(){\n    int l, r, x, a, b;\n    cin >> l >> r >> x >> a >> b;\n\n    if(a == b) {\n        cout << 0 << endl;\n        return;\n    }\n    if(a > b) swap(a, b);\n    if(b - a >= x) {\n        cout << 1 << endl;\n    } else if(a - l >= x and l + x <= b) {\n        cout << 2 << endl;\n    } else if(a + x <= r and r - x >= b) {\n        cout << 2 << endl;\n    } else if( (a + x <= r and r - l >= x and l + x <= b)) {\n        cout << 3 << endl;\n    } else if( (a - x >= l and l + x <= r and r - x >= b)) {\n        cout << 3 << endl;\n    } else cout << -1 << endl;\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']",,,"['greedy', 'math', 'shortest paths']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Thermostat.json,https://codeforces.com//blog/entry/109254,First let s consider the cases when the answer exists If then the thermostat is already set up and the answer is else if then it is enough to reconfigure the thermostat in operation else if exist such temperature that and then you can configure the thermostat in operations If such exists between and we can chose one of bounds or we need to make operations if times if we cannot reconfigure through one of the boundaries as above but we can through both or If we can t get the temperature in one of these ways the answer is 
https://codeforces.com//contest/1458/problem/C,837944,C,1458C,1458,C. Latin Square,You are given a square matrix of size n Every row and every column of this matrix is a permutation of 1 2 ldots n Let a i j be the element at the intersection of i th row and j th column for every 1 leq i j leq n Rows are numbered 1 ldots n top to bottom and columns are numbered 1 ldots n left to right There are six types of operations cyclically shift all columns to the right formally set the value of each a i j to a i j 2 bmod n 1 cyclically shift all columns to the left formally set the value of each a i j to a i j bmod n 1 cyclically shift all rows down formally set the value of each a i j to a i 2 bmod n 1 j cyclically shift all rows up formally set the value of each a i j to a i bmod n 1 j replace the permutation read left to right in each row with its inverse replace the permutation read top to bottom in each column with its inverse Inverse of a permutation p 1 p 2 ldots p n is a permutation q 1 q 2 ldots q n such that p q i i for every 1 leq i leq n One can see that after any sequence of operations every row and every column of the matrix will still be a permutation of 1 2 ldots n Given the initial matrix description you should process m operations and output the final matrix ,"['/**\n *    author:  tourist\n *    created: 19.12.2020 13:42:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> p(n * n, vector<int>(3));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        int v;\n        cin >> v;\n        --v;\n        p[i * n + j][0] = i;\n        p[i * n + j][1] = j;\n        p[i * n + j][2] = v;\n      }\n    }\n    string s;\n    cin >> s;\n    vector<int> order(3);\n    iota(order.begin(), order.end(), 0);\n    vector<int> shift(3, 0);\n    for (char c : s) {\n      if (c == \'R\') {\n        shift[1] = (shift[1] + 1) % n;\n      }\n      if (c == \'L\') {\n        shift[1] = (shift[1] + n - 1) % n;\n      }\n      if (c == \'D\') {\n        shift[0] = (shift[0] + 1) % n;\n      }\n      if (c == \'U\') {\n        shift[0] = (shift[0] + n - 1) % n;\n      }\n      if (c == \'I\') {\n        swap(order[1], order[2]);\n        swap(shift[1], shift[2]);\n      }\n      if (c == \'C\') {\n        swap(order[0], order[2]);\n        swap(shift[0], shift[2]);\n      }\n    }\n    vector<vector<int>> a(n, vector<int>(n, -1));\n    vector<int> z(3);\n    for (int i = 0; i < n * n; i++) {\n      for (int j = 0; j < 3; j++) {\n        z[j] = (p[i][order[j]] + shift[j]) % n;\n      }\n      a[z[0]][z[1]] = z[2];\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (j > 0) {\n          cout << "" "";\n        }\n        assert(a[i][j] != -1);\n        cout << a[i][j] + 1;\n      }\n      cout << \'\\n\';\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['math', 'matrices']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Latin Square.json,https://codeforces.com//blog/entry/85750,For convenience let s assume that all row and column indices as well as matrix values are from 0 n 1 instead for 1 n If only shift operations were present we could solve the problem in linear time just maintain where the top left corner ends up after all the shifts and then the matrix can be easily reconstructed if this is not immediately clear to you take a moment and think how this should be done For the inverse operations the approach is going to be similar but we ll need a different way to look at the matrix Instead of the matrix let s think about the set of all triples i j a i j Imagining a set of n2 points in 3D where i j are x and y coordinates in the horizontal plance and a i j is the height z is a good mental picture Shift operations apply x x 1 modn and y y 1 modn to all points We can think of this as a translation of the entire 3D space with some looping at the borders Instead of the given points let s keep track of where the point 0 0 0 is located after the operations are done it s just as easy as in two dimensional version from before Now let s introduce the inverses Consider say a row inverse operation and all the points i j k where k a i j that have the same row index i As an example suppose that the top 0 th row of the matrix contains numbers 2 1 3 0 The entries in the row correspond to points 0 0 2 0 1 1 0 2 3 0 3 0 The inverse permutation to this row is 3 1 0 2 thus the new set of points should be 0 0 3 0 1 1 0 2 0 0 3 2 In general if there is currently a point i j k in the set then after the inverse there must be a point i k j Thus the entire operation may be summarized as swap the second and third coordinates Similarly the column inverse is swap the first and third coordinates Again we think of this transformation applied to the entire 3D space this can be seen as a mirror reflection with respect to y z or x z plane How does this affect our keep track of 0 0 0 approach It is easy to update its position just swap respective coordinates However we now need to care about how the answer is reconstructed since say the point 1 0 0 not necessarily ends up one step to the right of 0 0 0 Thus in addition let s keep track of how the direction vectors vx 1 0 0 vy 0 1 0 vz 0 0 1 are permuted after all operations Shifts do not affect them but inverses swap two of them depending on which coordinates where swapped We are almost done we just need to reconstruct the answer at the end If we had an initially given point p i j k where will it end up If the origin ends up at a position represented as a vector v0 x y z then p ends up at p v0 ivx jvy kvz where vx vy vz are permuted accordingly Once we have the result p i j k all we need is to put k into b i j where b is the answer matrix This results once again in a linear time solution This explanation could have been much shorter with some linear algebraic machinery basically each transformation multiplication by a certain matrix but I chose to leave it as elementary simple as possible 
https://codeforces.com//contest/903/problem/B,138451,B,903B,903,B. The Modcrab,Vova is again playing some computer game now an RPG In the game Vova s character received a quest to slay the fearsome monster called Modcrab After two hours of playing the game Vova has tracked the monster and analyzed its tactics The Modcrab has health points and an attack power of Knowing that Vova has decided to buy a lot of strong healing potions and to prepare for battle Vova s character has health points and an attack power of Also he has a large supply of healing potions each of which increases his current amount of health points by when Vova drinks a potion All potions are identical to each other It is guaranteed that The battle consists of multiple phases In the beginning of each phase Vova can either attack the monster thus reducing its health by or drink a healing potion it increases Vova s health by Then the Modcrab attacks Vova reducing his health by The battle ends when Vova s or Modcrab s health drops to or lower It is possible that the battle ends in a middle of a phase after Vova s attack Of course Vova wants to win the fight But also he wants to do it as fast as possible So he wants to make up a strategy that will allow him to win the fight after the minimum possible number of phases Help Vova to make up a strategy You may assume that Vova never runs out of healing potions and that he can always win ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint main() {\n\tint H1, A1, C1, H2, A2, i;\n\tscanf(""%d %d %d %d %d"", &H1, &A1, &C1, &H2, &A2);\n\n\tint ans = INF;\n\tfor (i = 0; i <= 10000; i++) {\n\t\tint h = H1 + i*(C1 - A2);\n\t\tll tur = (h + A2 - 1) / A2;\n\t\tif (tur * A1 >= H2) {\n\t\t\tans = min(ans, (H2 + A1 - 1) / A1 + i);\n\t\t\tprintf(""%d\\n"", ans);\n\t\t\tfor (int j = 1; j <= i; j++) printf(""HEAL\\n"");\n\t\t\tfor (int j = 1; j <= (H2 + A1 - 1) / A1; j++) printf(""STRIKE\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn !printf(""%d\\n"", ans);\n}']",,,"['greedy', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. The Modcrab.json,https://codeforces.com//blog/entry/56330,A simple greedy solution works simulate the process until the Modcrab is dead and make Vova drink a potion if his current health is less than and monster s current health is greater than because in this case Vova can t finish the Modcrab in one strike but the Modcrab can win if Vova doesn t heal In any other situation Vova must attack Since all parameters are up to the number of phases won t exceed 
https://codeforces.com//contest/1768/problem/E,1720622,E,1768E,1768,E. Partial Sorting,Consider a permutation dagger p of length 3n Each time you can do one of the following operations Sort the first 2n elements in increasing order Sort the last 2n elements in increasing order We can show that every permutation can be made sorted in increasing order using only these operations Let s call f p the minimum number of these operations needed to make the permutation p sorted in increasing order Given n find the sum of f p over all 3n permutations p of size 3n Since the answer could be very large output it modulo a prime M dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=3e6+10;\nint mod,n,t_case;\nstruct modint{\n\tint val;\n\tinline modint(int val_=0):val(val_){}\n\tinline modint &operator=(int val_){return val=val_,*this;}\n\tinline modint &operator+=(const modint &k){return val=val+k.val>=mod?val+k.val-mod:val+k.val,*this;}\n\tinline modint &operator-=(const modint &k){return val=val-k.val<0?val-k.val+mod:val-k.val,*this;}\n\tinline modint &operator*=(const modint &k){return val=1ll*val*k.val%mod,*this;}\n\tinline modint &operator^=(int k){\n\t    modint ret=1,tmp=*this;\n\t    for(;k;k>>=1,tmp*=tmp)if(k&1)ret*=tmp;\n\t    return val=ret.val,*this;\n\t}\n\tinline modint &operator/=(modint k){return *this*=(k^=mod-2);}\n\tinline modint &operator+=(int k){return val=val+k>=mod?val+k-mod:val+k,*this;}\n\tinline modint &operator-=(int k){return val=val<k?val-k+mod:val-k,*this;}\n\tinline modint &operator*=(int k){return val=1ll*val*k%mod,*this;}\n\tinline modint &operator/=(int k){return *this*=((modint(k))^=mod-2);}\n\ttemplate<class T>friend modint operator+(modint a,T b){return a+=b;}\n\ttemplate<class T>friend modint operator-(modint a,T b){return a-=b;}\n\ttemplate<class T>friend modint operator*(modint a,T b){return a*=b;}\n\ttemplate<class T>friend modint operator^(modint a,T b){return a/=b;}\n\ttemplate<class T>friend modint operator/(modint a,T b){return a/=b;}\n\tfriend modint operator^(modint a,int b){return a^=b;}\n\tfriend bool operator==(modint a,int b){return a.val==b;}\n\tfriend bool operator!=(modint a,int b){return a.val!=b;}\n\tinline bool operator!(){return !val;}\n\tinline modint operator-(){return val?mod-val:0;}\n\tinline modint &operator++(){return *this+=1;}\n};\nusing mi=modint;\nmi fac[maxn],ifac[maxn];\ninline void init(int sz){\n\tfac[0]=1;\n\tfor(ri i=1;i<=sz;++i)fac[i]=fac[i-1]*i;\n\tifac[sz]=1/fac[sz];\n\tfor(ri i=sz;i;--i)ifac[i-1]=ifac[i]*i;\n}\ninline mi A(int x,int y){\n\tif(x<y||y<0)return 0;\n\treturn fac[x]*ifac[x-y];\n}\ninline mi C(int x,int y){\n\tif(x<y||y<0)return 0;\n\treturn A(x,y)*ifac[y];\n}\nint main(){\n\tscanf(""%d%d"",&n,&mod);\n\tinit(n*3);\n\tmi w=1,x=2*fac[n*2]-fac[n],y=2*A(n*2,n)*fac[n*2],z=fac[n*3];\n\tfor(ri i=0;i<=n;++i)y-=C(n,i)*A(n,i)*A(n,n-i)*A(n*2-i,n)*fac[n];\n\tz-=y,y-=x,x-=w;\n\tprintf(""%d"",0*w+1*x+2*y+3*z);\n\treturn 0;\n}']",,,"['combinatorics', 'math', 'number theory']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Partial Sorting.json,https://codeforces.com//blog/entry/110901,There is a very easy dp solution we will show one possible way to optimize it to where is the maximum possible value of Let be the minimum number of eris required to reach index Suppose we want to calculate and we already know Let s look at our cost function more closely We can notice that it is definitely not optimal to use the transition if That is it will be more optimal to perform jumps of length 1 Transforming this inequality we get So if is quite large we only need to look at a couple of close to and then do something else for the small values of 1 To handle this case we can just iterate over all from to since the transition could be optimal only if Time complexity 2 Another useful fact is that if there exists an index such that and the transition also cannot be optimal since followed by will cost less Proof This leaves us two subcases two handle 2 1 Just maintain the rightmost occurrences of all values from to Time complexity 2 2 Initially set to and decrease it until becomes true Time complexity amortized Total time complexity 
https://codeforces.com//contest/1870/problem/E,2216418,E,1870E,1870,E. Another MEX Problem,You are given an array of integers a of size n You can choose a set of non overlapping subarrays of the given array note that some elements may be not included in any subarray this is allowed For each selected subarray calculate the MEX of its elements and then calculate the bitwise XOR of all the obtained MEX values What is the maximum bitwise XOR that can be obtained The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 5007, S = 8300, M = 8192;\nint n, k;\nbitset < S > dp[N];\nint mex[N][N];\nint cnt[N]; \nint a[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tL(l, 1, n) {\n\t\tL(i, 0, n) cnt[i] = 0;\n\t\tint ans = 0;\n\t\tL(r, l, n) {\n\t\t\tcnt[a[r]] += 1;\n\t\t\twhile(cnt[ans]) ++ans;\n\t\t\tmex[l][r] = ans;\n\t\t}\n\t}\n\t\n\tdp[0].set(0);\n\tL(i, 1, n) {\n\t\tdp[i] = dp[i - 1];\n\t\tL(j, 1, i) {\n\t\t\tif(i == j || (mex[j][i] != mex[j + 1][i] && mex[j][i] != mex[j][i - 1])) {\n\t\t\t\tL(k, 0, M - 1) \n\t\t\t\t\tif(dp[j - 1][k]) \n\t\t\t\t\t\tdp[i].set(k ^ mex[j][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tL(i, 0, M - 1) {\n\t\tif(dp[n][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\t\n\tL(i, 0, n) {\n\t\tdp[i].reset();\n\t}\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]",,,"['bitmasks', 'brute force', 'dp', 'shortest paths']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Another MEX Problem.json,https://codeforces.com//blog/entry/120524,TutorialLet s solve the problem using dynamic programming let s store such that if it is possible to obtain an of values from the prefix up to excluding equal to and otherwise Notice that the answer cannot be greater than Therefore the size of this two dimensional array is Let s learn how to solve this in We iterate over from to and inside that we iterate over from to maintaining the value Then for all from to we update if This way we update based on the case when the resulting set includes the set We also need to update if we assign This accounts for the case when we do not include in the answer Let s define this will make the following text clearer Let s consider the segment Notice that if there exist and such that or and then we can take the segment instead of the segment in the set of values and the answer will remain the same If however there is no such segment for the segment then we call this segment irreplaceable Now let s prove that there are no more than irreplaceable segments For each irreplaceable segment let s look at the larger element of the pair let s assume is larger the other case is symmetric Now let s prove that there is at most one segment where is the left element and by contradiction Suppose there are at least 2 such segments let s call their right boundaries Notice that otherwise the segment would not be irreplaceable we could remove Since then It is obvious that appears among the elements and therefore which means that the segment is not irreplaceable contradiction For each there is at most one irreplaceable segment where it is the smaller of the two extremes and at most one where it is the larger Therefore the total number of irreplaceable segments is no more than Let s update the DP only through the irreplaceable segments then the solution works in time where is the number of irreplaceable segments However we have already proven that so the overall time complexity is 
https://codeforces.com//contest/2060/problem/D,3147473,D,2060D,2060,D. Subtract Min Sort,You are given a sequence a consisting of n positive integers You can perform the following operation any number of times Select an index i 1 le i n and subtract min a i a i 1 from both a i and a i 1 Determine if it is possible to make the sequence by using the operation any number of times ,"['#include <bits/stdc++.h>using namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\xa0    int t;    cin >> t;    while(t--){        int n;         cin >> n;        vector<long long> a(n);        for(int i=0; i<n; i++){            cin >> a[i];        }\xa0        bool possible = true;        for(int i=n-1; i>=1; i--){            if(a[i-1] > a[i]){                long long x = a[i-1] - a[i];                int leftIdx = i-2; // 0-based index for a[i-2]                if(leftIdx < 0){                    possible = false;                    break;                }                a[leftIdx] -= x;   // reduce the left neighbor                a[i-1] = a[i];     // fix a[i-1] down to a[i]                if(a[leftIdx] < 0){                    possible = false;                    break;                }            }        }        if(possible){            for(int i=0; i+1<n; i++){                if(a[i] > a[i+1]){                    possible = false;                    break;                }            }        }\xa0        cout << (possible ? ""YES\\n"" : ""NO\\n"");    }\xa0    return 0;}']",,,['greedy'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Subtract Min Sort.json,https://codeforces.com/blog/entry/138342,For clarity let s denote opi as an operation performed on ai and ai 1 Claim if it is possible then the sequence of operations op1 op2 opn 1 will sort the array Proof Let b be any sequence of operations that will sort the array Let s transform the sequence b such that it becomes op1 op2 opn 1 First let s note that an opi does nothing if ai 0 or ai 1 0 Additionally after opi at least one of ai ai 1 will become zero Thus we can remove all duplicates in b without altering the result Now let x be the largest number such that opx is in b Since at least one of ax ax 1 will be zero operations must be performed such that each of a1 a2 ax 1 are zero Let S be the set of indices with i x such that opi is not in b Note that we can simply append each operation in S at the end of b without altering the result since all elements before ax are already zero Our sequence of operations now contain a permutation of op1 op2 opx and we have ensured that all of a1 a2 ax 0 Since the sequence is now sorted we can in fact continue performing opx 1 opx 2 opn 1 in this order Notice that this sequence of operations will keep our array sorted as opy will make ay 0 since ay ay 1 Let s show that we can rearrange our operations such that 1 comes first There are two cases either op1 comes before op2 or op2 comes before op1 In the first case notice that no operation done before op1 will impact either the value of a1 or a2 so rearranging such that op1 comes first does not impact the final results In the second case notice that after op2 is done we must have a1 a2 as otherwise op1 will not simultaneously make a1 a2 0 This implies that right before op2 is performed we must have a1 a3 a2 Then rearranging the operations such that op1 comes first will not impact the final result Using the same line of reasoning we can make op2 the second operation then op3 and so on To solve the problem we can simply simulate the operations in this order and then check if the array is sorted at the end 
https://codeforces.com//contest/1592/problem/F1,1129224,F1,1592F1,1592,F1. Alice and Recoloring 1,Alice has a grid of size n times m The cell on the intersection of i th row and j th column is denoted as i j Alice can do the following operations with this grid Choose any subrectangle containing cell 1 1 and flip the colors of all its cells Flipping means changing its color from white to black or from black to white Choose any subrectangle containing cell n 1 and flip the colors of all its cells Choose any subrectangle containing cell 1 m and flip the colors of all its cells Choose any subrectangle containing cell n m and flip the colors of all its cells Alice wants to obtain her favorite coloring with these operations What s the smallest number of coins that she would have to spend It can be shown that it s always possible to transform the initial grid into any other ,"[""#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,m;\nint sum,ans;\nint a[505][505],b[505][505];\nvoid solve()\n{\n\tcin>>n>>m;rep(i,n)rep(j,m){char c;cin>>c;a[i][j]=(c=='B');}\n\trep(i,n+1)rep(j,m+1)b[i][j]=a[i-1][j-1]^a[i-1][j]^a[i][j-1]^a[i][j];\n\tfor(int i=2;i<=n+1;i++)for(int j=2;j<=m+1;j++) sum+=b[i][j];\n\tans=sum;\n\tif(b[n+1][m+1])\n\t{\n\t\tfor(int i=2;i<=n;i++)for(int j=2;j<=m;j++)\n\t\t{\n\t\t\tint tmp=sum-b[i][j]-b[i][m+1]-b[n+1][j]-b[n+1][m+1];\n\t\t\ttmp+=4-b[i][j]-b[i][m+1]-b[n+1][j]-b[n+1][m+1];\n\t\t\tans=min(ans,tmp+3); \n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}""]",,,"['constructive algorithms', 'greedy']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F1. Alice and Recoloring 1.json,https://codeforces.com//blog/entry/95583,We will transform favorite coloring to the all white coloring instead Let s denote by and by First observation is that it doesn t make sense to do operations of type and at all Indeed each of them can be replaced with operations of type Instead of flipping subrectangle we can flip subrectangles and and similarly for So from now on we only consider first and last operations Let s create a grid of rows and columns where denotes the parity of the sum of numbers in those of cells of favorite coloring which are present on the grid Clearly all numbers in are if and only if current coloring is all so we will want to just make the grid all Let s look at how first and last operations affect the grid If we flip the subrectangle with the operation of the first type in grid the only value that changes is If we flip the subrectangle clearly otherwise we could have instead used operations of the first type Then it s easy to see that the only cells that will change are So now we have the following problem we have a binary grid In one operation we can change some to with cost of coin or to select some and flip the numbers in cells with cost of coins What s the smallest cost to make all numbers Now it s easy to see that it doesn t make sense to apply second operation more than once as instead of doing it twice we can apply the operation of the first type at most times as cell will be flipped twice Moreover it only makes sense to apply the second operation if there exist such for which all cells are So the algorithm would be to calculate the grid to calculate the total number of ones in it and substract from if there exists such for which all cells are Complexity 
https://codeforces.com//contest/1772/problem/A,1699968,A,1772A,1772,A. A+B ,You are given an expression of the form a b where a and b are integers from 0 to 9 You have to evaluate it and print the result ,"['/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,a[N],k,res;\nvoid elixprep(){\n    \n}\nstring s;\nvoid elix()\n{\n    cin>>s;\n    cout<<s[0]+s[2]-96;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}\n//listen to trap music. it won\'t help']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. A+B .json,https://codeforces.com//blog/entry/110313,There are multiple ways to solve this problem Most interpreted languages have some function that takes the string evaluates it as code and then returns the result One of the examples is the function in Python If the language you use supports something like that you can read the input as a string and use it as the argument of such a function Suppose you use a language where this is impossible There are still many approaches to this problem The most straightforward one is to take the first and the last characters of the input string calculate their ASCII codes and then subtract the ASCII code of the character from them to get these digits as integers not as characters Then you can just add them up and print the result 
https://codeforces.com//contest/217/problem/D,1610,D,217D,217,D. Bitonix  Patrol,Byteland is trying to send a space mission onto the Bit X planet Their task is complicated by the fact that the orbit of the planet is regularly patrolled by Captain Bitonix the leader of the space forces of Bit X There are stations around Bit X numbered clockwise from 1 to The stations are evenly placed on a circular orbit so the stations number and and the stations number 1 and are neighboring The distance between every pair of adjacent stations is equal to space miles To go on a patrol Captain Bitonix jumps in his rocket at one of the stations and flies in a circle covering a distance of at least one space mile before finishing in some perhaps the starting station Bitonix rocket moves by burning fuel tanks After Bitonix attaches an liter fuel tank and chooses the direction clockwise or counter clockwise the rocket flies exactly space miles along a circular orbit in the chosen direction Note that the rocket has no brakes it is not possible for the rocket to stop before depleting a fuel tank For example assume that and and Bitonix has fuel tanks with volumes of 10 60 90 and 100 liters If Bitonix starts from station 1 uses the 100 liter fuel tank to go clockwise then uses the 90 liter fuel tank to go clockwise and then uses the 10 liter fuel tank to go counterclockwise he will finish back at station 1 This constitutes a valid patrol Note that Bitonix does not have to use all available fuel tanks Another valid option for Bitonix in this example would be to simply use the 60 liter fuel tank to fly to either station 2 or 3 However if was equal to 3 was equal to 60 and the only fuel tanks available to Bitonix were one 10 liter tank and one 100 liter tank he would have no way of completing a valid patrol he wouldn t be able to finish any patrol exactly at the station The Byteland space agency wants to destroy some of Captain Bitonix fuel tanks so that he cannot to complete any valid patrol Find how many different subsets of the tanks the agency can destroy to prevent Captain Bitonix from completing a patrol and output the answer modulo ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007\n\nint M;\nint cnt[130];\n// int CNT;\n\nint x[10];\nbool can[10][130];\nint mod[10000];\n\nint prod(int pos){ // cout << pos << endl;\n    ll ans = 1;\n    int i;\n    REP(i,pos) ans = ans * cnt[x[i]] % MOD;\n    return (int)ans;\n}\n\nint dfs(int pos, int last){ // cout << pos << endl;\n    int i,j;\n    \n//  CNT++;\n//  REP(i,pos) cout << x[i] << \' \';\n//  cout << endl;\n\n    int ans = prod(pos);\n    \n    if(pos < 6) for(i=last+1;i<=M/2;i++) if(!can[pos][i]){\n        x[pos] = i;\n        if(pos < 5){\n            REP(j,M) can[pos+1][j] = false;\n            REP(j,M) if(can[pos][j]) can[pos+1][j] = can[pos+1][mod[j+i]] = can[pos+1][mod[j-i+M]] = true;\n        }\n        int tmp = dfs(pos+1, i);\n        ans += tmp;\n        if(ans >= MOD) ans -= MOD;\n    }\n    \n    return ans;\n}\n\nint main(void){\n    int N,T,x,i;\n    \n    scanf(""%d%d%d"",&N,&M,&T);\n    REP(i,T){\n        scanf(""%d"",&x);\n        x %= M;\n        if(x != 0) cnt[min(x,M-x)]++;\n    }\n    \n    REP(i,10000) mod[i] = i % M;\n    can[0][0] = true;\n    int ans = dfs(0, 0);\n    printf(""%d\\n"", ans);\n//  cout << CNT << endl;\n    \n    return 0;\n}\n']",,,"['bitmasks', 'brute force', 'combinatorics', 'dfs and similar', 'math']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Bitonix  Patrol.json,https://codeforces.com//blog/entry/5285,Observation 1 Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix s purposes Moreover fuel tanks for which the capacities remainders sum to D are also equivalent Out of every group of equivalent tanks the agency can only leave at most one Observation 2 If more than six tanks remain Bitonix can certainly complete his patrol Indeed let us assume that 7 tanks were left undestroyed by the agency Out of the 128 possible subsets of those tanks at least two distinct ones say A and B sum up to the same remainders modulo D Thus if Bitonix moves forward with tanks from A B and backwards with tanks from B A he will finish at some station after an actual journey Because of observations 1 and 2 it turns out that a simple recursive search suffices to solve the problem However because of the large constraints it may prove necessary to use some optimizations such as using bitmasks for keeping track of what distances Bitonix can cover 
https://codeforces.com//contest/273/problem/D,2630,D,273D,273,D. Dima and Figure,Dima loves making pictures on a piece of squared paper And yet more than that Dima loves the pictures that depict one of his favorite figures A piece of squared paper of size is represented by a table consisting of rows and columns All squares are white on blank squared paper Dima defines a as an image on a blank piece of paper obtained by painting some squares black The picture portrays one of Dima s favorite figures if the following conditions hold The picture contains at least one painted cell All painted cells form a connected set that is you can get from any painted cell to any other one you can move from one cell to a side adjacent one The minimum number of moves needed to go from the painted cell at coordinates to the painted cell at coordinates moving only through the colored cells equals Now Dima is wondering how many paintings are on an piece of paper that depict one of his favorite figures Count this number modulo ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\ntypedef long long LL;\nLL sum[2][2][2][155][155];\nLL dp[2][2][2][155][155];\nconst int MOD = 1e9+7;\nvoid add(LL &x, long long v) {\n    x = (x+v)%MOD;\n}\n\nLL require_sum(int u, int f1, int f2, int xL, int xR, int yL, int yR) {\n    return\n        sum[u][f1][f2][xR][yR] - sum[u][f1][f2][xL-1][yR]\n        -sum[u][f1][f2][xR][yL-1] + sum[u][f1][f2][xL-1][yL-1];\n}\nint main(void) {\n    int m, n;\n    LL sol=0;\n    scanf(""%d%d"", &m, &n);\n    int u=0;\n    for(int i=1;i<=m;i++)\n        for(int j=i;j<=m;j++) {\n            dp[0][0][0][i][j] = 1;\n            add(sol, (n+1-1)*dp[0][0][0][i][j]);\n        }\n    for(int i=1;i<=m;i++)\n        for(int j=1;j<=m;j++) {\n            sum[0][0][0][i][j] = (dp[0][0][0][i][j] + sum[0][0][0][i-1][j] + sum[0][0][0][i][j-1] - sum[0][0][0][i-1][j-1])%MOD;\n        }\n    for(int row=2;row<=n;row++) {\n        memset(dp[1-u],0,sizeof(dp[1-u]));\n        memset(sum[1-u],0,sizeof(sum[1-u]));\n        for(int i=1;i<=m;i++)\n            for(int j=i;j<=m;j++) {\n                dp[1-u][0][0][i][j] = require_sum(u, 0, 0, i, j, i, j);\n                dp[1-u][0][1][i][j] = require_sum(u, 0, 1, i, j, j, m);\n                if(j<m) add(dp[1-u][0][1][i][j], require_sum(u, 0, 0, i, j, j+1, m));\n                \n                dp[1-u][1][0][i][j] = require_sum(u, 1, 0, 1, i, i, j);\n                if(i>1) add(dp[1-u][1][0][i][j], require_sum(u, 0, 0, 1, i-1, i, j));\n\n                dp[1-u][1][1][i][j] = require_sum(u, 1, 1, 1, i, j, m);\n                if(i>1) add(dp[1-u][1][1][i][j], require_sum(u, 0, 1, 1, i-1, j, m));\n                if(j<m) add(dp[1-u][1][1][i][j], require_sum(u, 1, 0, 1, i, j+1, m));\n                if(i>1&&j<m) add(dp[1-u][1][1][i][j], require_sum(u, 0, 0, 1, i-1, j+1, m));\n            }\n        u=1-u;\n                for(int f1=0;f1<2;f1++)\n                    for(int f2=0;f2<2;f2++) {\n        for(int i=1;i<=m;i++)\n            for(int j=1;j<=m;j++)\n                sum[u][f1][f2][i][j] = (dp[u][f1][f2][i][j] + sum[u][f1][f2][i-1][j]+sum[u][f1][f2][i][j-1] - sum[u][f1][f2][i-1][j-1])%MOD;\n        add(sol, (n+1-row)*1LL*sum[u][f1][f2][m][m]);\n                    }\n    }\n    sol = (sol%MOD+MOD)%MOD;\n    printf(""%I64d\\n"", sol);\n    return 0;\n}\n']",,,['dp'],2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Dima and Figure.json,https://codeforces.com/blog/entry/6625,Good picture is connected figure that saticfy next condition most left coordinates in every row of figure vere we have some cells will be almost ternary we have the same situation with right side but here we have another sign So it is not hard to write dp i j1 j2 m1 m2 numbr of figures printed of field size i m where last row contain all cells from j1 to j2 the most left coordinate will be m1 the most right coordinate will be m2 But it is not enough We have to rewrite it in way that m1 will mean was there some rows j and j 1 that most left coordinate if row j is bigger then most left coordinate in j 1 So now it is not hard to write solution with coplexity O n m m m m But we should optimize transfer to O 1 is can be done using precalculations of sums on some rectangels 
https://codeforces.com//contest/1447/problem/E,797266,E,1447E,1447,E. Xor Tree,For a given sequence of non negative integers b 1 b 2 dots b k we determine if it is in the following way Consider a graph on k nodes with numbers from b 1 to b k written on them For every i from 1 to k find such j 1 le j le k j neq i for which b i oplus b j among all such j where oplus denotes the operation of bitwise XOR https en wikipedia org wiki Bitwise operationXOR Next draw an edge between vertices with numbers b i and b j in this graph We say that the sequence is if and only if the resulting graph forms a is connected and doesn t have any simple cycles It is possible that for some numbers b i and b j you will try to add the edge between them twice Nevertheless you will add this edge only once You can find an example below the picture corresponding to the first test case Sequence 0 1 5 2 6 good as we reach 1 from 5 However sequence 0 1 5 2 good You are given a sequence a 1 a 2 dots a n of non negative integers You would like to remove some of the elements possibly none to make the sequence good What is the minimum possible number of removals required to achieve this goal It can be shown that for any sequence we can remove some number of elements leaving at least 2 so that the remaining sequence is good ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, a[200010];\nconst int W = 31;\nconst int MAXNODE = (W + 1) * 200010;\nint ch[MAXNODE][2], cnt[MAXNODE];\nint M = 1;\n\nvoid ins(int v) {\n    //printf(""ins %d\\n"",v);\n    int now = 1;\n    cnt[1]++;\n    for (int i=W;i>=0;i--) {\n        int dir = ((v >> i) & 1);\n        int &nxt = ch[now][dir];\n        if (!nxt) nxt = ++M;\n        cnt[nxt]++;\n        now = nxt;\n        //printf(""now = %d\\n"",now);\n    }\n}\n\nint dfs(int x) {\n    if (x == 0) return 0;\n    if (!ch[x][0] && !ch[x][1]) return 1;\n    return max(dfs(ch[x][0]) + (!!ch[x][1]), dfs(ch[x][1]) + (!!ch[x][0]));\n}\n\nint main() {\n    scanf(""%d"",&N);\n    for (int i=1;i<=N;i++) {\n        scanf(""%d"",&a[i]);\n    }\n    for (int i=1;i<=N;i++) {\n        ins(a[i]);\n    }\n    printf(""%d\\n"",N - dfs(1));\n}']",,,"['bitmasks', 'divide and conquer', 'dp', 'graphs', 'string suffix structures', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Xor Tree.json,https://codeforces.com//blog/entry/82067,Small hintsIs it possible that the graph formed has a cycle How to evaluate whether a sequence is good 
https://codeforces.com//contest/1428/problem/D,762866,D,1428D,1428,D. Bouncing Boomerangs,To improve the boomerang throwing skills of the animals Zookeeper has set up an n times n grid with some targets The rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to n from left to right For each column Zookeeper will throw a boomerang from the bottom of the column below the grid upwards When the boomerang hits any target it will bounce off make a 90 degree turn to the right and fly off in a straight line in its new direction The boomerang can hit multiple targets and does not stop until it leaves the grid In the above example n 6 and the black crosses are the targets The boomerang in column 1 blue arrows bounces 2 times while the boomerang in column 3 red arrows bounces 3 times The boomerang in column i hits exactly a i targets before flying out of the grid However Zookeeper has lost the original positions of the targets Thus he asks you to construct a valid configuration of targets that matches the number of hits for each column or tell him that no such configuration exists If multiple valid configurations exist you may print any of them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nvi wek[nax];\nvector<pii> wyn;\n\nvoid buduj(int kol, int wys)\n{\n\twyn.push_back({n+1-wys, kol});\n\twek[kol].push_back(wys);\n}\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n\texit(0);\n}\n\nvi jedy[4];\n\nint daj(int v)\n{\n\tif (v==2)\n\t{\n\t\tif (jedy[1].empty())\n\t\t\tnope();\n\t\tint x=jedy[1].back();\n\t\tjedy[1].pop_back();\n\t\treturn x;\n\t}\n\tfor (int i=3; i; i--)\n\t{\n\t\tif (!jedy[i].empty())\n\t\t{\n\t\t\tint x=jedy[i].back();\n\t\t\tjedy[i].pop_back();\n\t\t\treturn x;\n\t\t}\n\t}\n\tnope();\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (!tab[i])\n\t\t\tcontinue;\n\t\tif (tab[i]==1)\n\t\t{\n\t\t\tbuduj(i, n+1-i);\n\t\t\tjedy[1].push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t\tint x=daj(tab[i]);\n\t\tif (tab[i]==2)\n\t\t{\n\t\t\tbuduj(i, n+1-x);\n\t\t\tjedy[2].push_back(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuduj(i, n+1-i);\n\t\t\tbuduj(x, n+1-i);\n\t\t\tjedy[3].push_back(i);\n\t\t}\n\t}\n\t\n\tprintf(""%d\\n"", (int)wyn.size());\n\tfor (pii i : wyn)\n\t\tprintf(""%d %d\\n"", i.first, i.second);\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'implementation']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Bouncing Boomerangs.json,https://codeforces.com//blog/entry/83771,Clearly columns with are completely empty and we can ignore them Let s first consider just columns with s and s When a boomerang strikes its first target it will change directions from upwards to rightwards If the boomerang in column exits the grid on the right This means that if the target that it hits in on row there is no other target to its right on row For columns with the boomerang in column has to hit second target in some column before moving downwards The targets that this boomerang hits must be in the same row and since no row contains more than targets these are the only targets in the row Additionally there isn t any target below the second target This means This tells us that columns with must be matched with columns with to its right with If we only had and we can simply greedily match s to s that are available s initially seem difficult to handle The key observation is that s can link to s to its right The way to do this for the have the first target for one boomerang be the third target for another boomerang This allows us to chain the s together in one long chain Thus we only care about the first which has to use either a or a if it uses a that cannot be matched with a We should always use a if possible since it will never be used by anything else and the exact that we use also doesn t matter Thus the solution is as follows Process from right to left If the current value is a add it to a list of available ones If the current value is a match it with an available and remove the from the list If the current value is a match it with or in that order of preference Once we have found the chains and matches we can go from left to right and give each chain match some number of rows to use so that they do not overlap The final time complexity is Bonus Show that the directly simulating the path of each boomerang is overall Bonus unsolved Solve for 
https://codeforces.com//contest/519/problem/C,23225,C,519C,519,C. A and B and Team Training,An important part of preparing for a competition is sharing programming knowledge from the experienced members to those who are just beginning to deal with the contests Therefore during the next team training A decided to make teams so that newbies are solving problems together with experienced participants A believes that the optimal team of three people should consist of one experienced participant and two newbies Thus each experienced participant can share the experience with a large number of people However B believes that the optimal team should have two experienced members plus one newbie Thus each newbie can gain more knowledge and experience As a result A and B have decided that all the teams during the training session should belong to one of the two types described above Furthermore they agree that the total number of teams should be as much as possible There are experienced members and newbies on the training session Can you calculate what maximum number of teams can be formed ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\nint n, m;\n\nint main() {\n    //freopen(""ttt"", ""r"", stdin);\n\n    cin >> n >> m;\n\n    int rez = 0;\n\n    while(n > 0 && m > 0 && n + m >= 3) {\n        ++rez;\n        if(n < m) {\n              --n;\n            m -= 2;\n        }\n        else {\n            --m;\n        n-= 2;\n        }\n    }\n\n    cout << rez;\n\n    return 0;\n}\n']",,,"['greedy', 'implementation', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. A and B and Team Training.json,https://codeforces.com/blog/entry/16687,In this problem we should split n experienced participants and m newbies into teams Solution Let s denote number teams with 2 experienced partisipants and 1 new participant as type1 and teams with 1 experienced participant and 2 new participants as type2 Let s fix number of teams of type1 and denote it as i Their amount is not grater than m Then number of teams of type2 is min m 2 i n i Check all possible i and update answer 
https://codeforces.com//contest/1428/problem/C,763216,C,1428C,1428,C. ABBB,Zookeeper is playing a game In this game Zookeeper must use bombs to bomb a string that consists of letters and He can use bombs to bomb a substring which is either or When he bombs such a substring the substring gets deleted from the string and the remaining parts of the string get concatenated For example Zookeeper can use two such operations to to Zookeeper wonders what the shortest string he can make is Can you help him find the length of the shortest string ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nchar wcz[nax];\n\nint ile;\n\nvoid test()\n{\n\tscanf(""%s"", wcz+1);\n\tile=0;\n\tfor (int i=1; wcz[i]; i++)\n\t{\n\t\tif (wcz[i]==\'B\' && ile>0)\n\t\t{\n\t\t\tile--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tile++;\n\t\t}\n\t}\n\tprintf(""%d\\n"", ile);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['brute force', 'data structures', 'greedy', 'strings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. ABBB.json,https://codeforces.com//blog/entry/83771,This game is equivalent to processing left to right and maintaining a stack If the current processed character is A we add it to the stack if the current processed character is B we can either add it to the stack or pop the top of the stack In the optimal solution we will always pop from the stack whenever possible To prove this we will use the stay ahead argument Firstly we notice that the contents of the stack do not actually matter We actually only need to maintain the length of this stack Decrementing the size of the stack whenever possible is optimal as it is the best we can do And in the case where we must push B to the stack this is optimal as the parity of the length of the stack must be the same as the parity of the processed string so obtaining a stack of length 0 is impossble Bonus what is the length of the longest string that Zookeeper can make such that there are no moves left 
https://codeforces.com//contest/1651/problem/F,1324101,F,1651F,1651,F. Tower Defense,Monocarp is playing a tower defense game A level in the game can be represented as an OX axis where each lattice point from 1 to n contains a tower in it The tower in the i th point has c i mana capacity and r i mana regeneration rate In the beginning before the 0 th second each tower has full mana If at the end of some second the i th tower has x mana then it becomes mathit min x r i c i mana for the next second There are q monsters spawning on a level The j th monster spawns at point 1 at the beginning of t j th second and it has h j health Every monster is moving 1 point per second in the direction of increasing coordinate When a monster passes the tower the tower deals mathit min H M damage to it where H is the current health of the monster and M is the current mana amount of the tower This amount gets subtracted from both monster s health and tower s mana Unfortunately sometimes some monsters can pass all n towers and remain alive Monocarp wants to know what will be the total health of the monsters after they pass all towers ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 200001; \nconst int K = 100;\nconst int SZ = 262144;\n\nll sum[2*SZ][K];\n\nll qsum(int l, int r, int T) {\n    ll resL = 0, resR = 0; r++;\n    for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {\n        if (l&1) resL = resL+sum[l++][T];\n        if (r&1) resR = sum[--r][T]+resR;\n    }\n    return resL + resR;\n}\n\n\nint flar(int l, int r, int T, ll H, int L = 0, int R = SZ-1, int ind = 1) {\n    //dbg(l, r, T, H, L, R, ind, sum[ind][T]);\n    if (L > r || l > R) return -1;\n    if (L == R) {\n        return H <= sum[ind][T] ? L : -1;\n    }\n    int M = (L+R)/2;\n    if (sum[ind*2][T] >= H) {\n        int val = flar(l, r, T, H, L, M, ind*2);\n        if (val != -1) return val;\n    } \n    return flar(l, r, T, H - sum[ind*2][T], M+1, R, ind*2+1);\n}\n\nvoid solve() {\n    int N; cin >> N;\n    ll C[N], R[N];\n    F0R(i, N) cin >> C[i] >> R[i];\n    F0R(i, N) {\n        F0R(j, K) {\n            sum[i+SZ][j] = min(C[i], R[i] * j);\n        }\n    }\n    FORd(i, 1, SZ) {\n        F0R(j, K) {\n            sum[i][j] = sum[2*i][j] + sum[2*i+1][j];\n        }\n    }\n\n    set<pair<int, pl>> ev;\n    F0R(i, N) {\n        ev.ins({i, {-MX, C[i]}});\n    }\n\n    ll H[MX];\n    F0R(i, MX) H[i] = 0;\n    int Q; cin >> Q;\n    while(Q--) {\n        int T; cin >> T;\n        cin >> H[T];\n    }\n\n    ll ans = 0;\n    F0R(t, MX) {\n        int p = 0;\n        while (!ev.empty()) {\n            pair<int, pl> cur = *ev.begin();\n            if (t - cur.s.f >= K) {\n                ll gap = t - cur.s.f;\n                FOR(i, p, cur.f) {\n                    ll V = min(R[i] * gap, C[i]);\n                    if (V >= H[t]) {\n                        ev.ins({i, {t, V - H[t]}});\n                        goto done;\n                    }\n                    H[t] -= V;\n                }\n            } else if (p < cur.f) {\n                ll S = qsum(p, cur.f - 1, t - cur.s.f);\n                if (S < H[t]) {\n                    H[t] -= S;\n                } else {\n                    int pos = flar(p, cur.f - 1, t - cur.s.f, H[t] + qsum(0, p-1, t - cur.s.f));\n                    if (p < pos) H[t] -= qsum(p, pos - 1, t - cur.s.f);\n                    ll V = min(R[pos] * (t - cur.s.f), C[pos]);\n                    ev.ins({pos, {t, V - H[t]}});\n                    goto done;\n                }\n\n            }\n            ll V = min(cur.s.s + R[cur.f] * (t - cur.s.f), C[cur.f]);\n            if (V >= H[t]) {\n                ev.erase(ev.begin());\n                cur.s.s = V - H[t];\n                cur.s.f = t;\n                ev.ins(cur);\n                goto done;\n            }\n            H[t] -= V;\n            p = cur.f + 1;\n            ev.erase(ev.begin());\n\n        }\n        ans += H[t];\n        //dbg(t, H[t]);\n        ev.ins({N-1, {t, 0}});\n        done:\n        ;\n        /*if (t < 11) {\n            dbg(t, ev);\n        }*/\n    }\n\n    cout << ans << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']",,,"['binary search', 'brute force', 'data structures']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Tower Defense.json,https://codeforces.com//blog/entry/100796,Let s start thinking about the problem from the easy cases How to solve the problem fast if all towers have full mana We can store prefix sums of their capacities and find the first tower that doesn t get drained completely with a binary search Let s try the opposite How to solve the problem fast if all towers were drained completely in the previous second It s the same but the prefix sums are calculated over regeneration rates What if all towers were drained at the same second earlier than the previous second and no tower is fully restored yet It s also the same but the regeneration rates are multiplied by the time passed since the drain What if we drop the condition about the towers not being fully restored How would a data structure that can answer prefix sum queries work It should store the total mana capacity of all towers that are full Then mana regeneration rates for all towers that aren t If these are kept separately then it s easy to obtain the prefix sum by providing the time passed This will be total capacity plus total regeneration rate multiplied by the time passed How to determine if the tower is fully restored since the drain or not That s easy For each tower we can calculate the number of seconds it takes it to get restored from zero That is Thus all towers that have this value smaller than the time passed won t get restored All the rest will Unfortunately in the actual problem not all towers were last drained at the same time However it s possible to reduce the problem to that Store the segments of towers that were drained at same time There are also towers that weren t drained completely but they can be stored as segments of length too When a monster comes it drains some prefix of the towers completely and possibly one more tower partially In terms of segments it removes some prefix of the them and possibly cuts one Then it creates a segment that covers the prefix and possibly a segment of length with a partially drained tower So each monster creates segments and removes no more segments than were created Thus if we were to process each creation and removal in some then the complexity will be All towers on each segment have the same time passed since the drain We want to query the sum on the entire segment If it is greater than the remaining health of the monster we want to find the largest prefix of this segment that has a smaller or equal sum than the monster health Given time passed let s learn to query the range sum If we knew the queries beforehand it would be easy Initialize a segment tree as if all towers are completely restored Then make events of two kinds a tower with restore time and a query with time Sort them in the decreasing order and start processing one by one When a tower event happens update a single position in the segment tree from capacity to regeneration rate When a query event happens find the sum Since the queries are not known beforehand make that segment tree persistent and ask specific versions of it If a segment of towers was last drained at time and the query is at time then you should query the segment tree in version Obviously you can store not all versions but only ones that have some tower change Moreover it s more convenient to make one version responsible for one tower update Then you can lower bound the array of sorted to find the version you want to ask at To determine the largest prefix of this segment that has a smaller or equal sum than the monster health you can either binary search for or traverse the segment tree for The time limit might be a little tight for the first approach but it can still pass Overall complexity 
https://codeforces.com//contest/415/problem/B,7962,B,415B,415,B. Mashmokh and Tokens,Bimokh is Mashmokh s boss For the following days he decided to pay to his workers in a new way At the beginning of each day he will give each worker a certain amount of tokens Then at the end of each day each worker can give some of his tokens back to get a certain amount of money The worker can save the rest of tokens but he can t use it in any other day to get more money If a worker gives back tokens then he ll get dollars Mashmokh likes the tokens however he likes money more That s why he wants to save as many tokens as possible so that the amount of money he gets is maximal possible each day He has numbers Number is the number of tokens given to each worker on the th day Help him calculate for each of days the number of tokens he can save ,"['#include <stdio.h>\nint n, a, b, x[100000];\nint main()\n{\n\tscanf(""%d%d%d"", &n, &a, &b);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(""%d"", &x[i]);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tlong long tmp = (long long)x[i] * a / b;\n\t\tprintf(""%d "", x[i] - (tmp * b % a ? tmp * b / a + 1 : tmp * b / a));\n\t}\n\tgetchar(); getchar();\n\treturn 0;\n}\n']",,,"['binary search', 'greedy', 'implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Mashmokh and Tokens.json,https://codeforces.com//blog/entry/11470,For this problem you can find the number of tokens you can save if you initally have tokens in Then you can calculate the answer for all of numbers in Suppose by then then Suppose initially we have tokens Let then we need to find such maximum that So will be equal to so we can calculate in 
https://codeforces.com//contest/1118/problem/D1,300358,D1,1118D1,1118,D1. Coffee and Coursework  Easy version , Polycarp has to write a coursework The coursework consists of m pages Polycarp also has n cups of coffee The coffee in the i th cup has a i caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not usually being written in a single day in a perfect world of Berland at least Some of them require multiple days of hard work Let s consider some day of Polycarp s work Consider Polycarp drinks k cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are a i 1 a i 2 dots a i k Then the first cup he drinks gives him energy to write a i 1 pages of coursework the second cup gives him energy to write max 0 a i 2 1 pages the third cup gives him energy to write max 0 a i 3 2 pages the k th cup gives him energy to write max 0 a i k k 1 pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n#define ll long long int\n#define ld double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst ll M=2e5+5;\nll a[M];\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tll n,m;\n\tcin>>n>>m;\n\tll s=0;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t\ts=s+a[i];\n\t}\n\tsort(a+1,a+1+n);\n\tif(s<m)\n\t{\n\t\tcout<<""-1\\n"";\n\t\treturn 0;\n\t}\n\tll l=1,r=n,p=-1;\n\twhile(l<r)\n\t{\n\t\tll mid=(l+r)/2;\n\t\tif(mid==p)\n\t\t\tmid++;\n\t\tp=mid;\n\t\tll s=0;\n\t\tll curr=0;\n\t\tll x=0;\n\t\tfor(ll i=n;i>=1;i--)\n\t\t{\n\t\t\tif(curr==mid)\n\t\t\t{\n\t\t\t\tcurr=0;\n\t\t\t\tx++;\n\t\t\t}\n\t\t\ts=s+max(a[i]-x,(ll)0);\n\t\t\tcurr++;\n\t\t}\n\t\tif(s>=m)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcout<<r<<""\\n"";\n\treturn 0;\n}']",,,"['brute force', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D1. Coffee and Coursework  Easy version .json,https://codeforces.com/blog/entry/65396,Since the number of days doesn t exceed let s iterate over this value from to So now we have to check somehow if the current number of days is enough to write a coursework Let the current number of days be The best way to distribute first cups of coffee for each day is to take maximums in the array Then we have to distribute second cups for each day Let s also take the next maximums in the remaining array and so on How do we can calculate such a thing easily Let s sort the array in the reversed order before iterating over all numbers of days then the following formula will work fine for the current number of days So if the value of the formula above is greater than or equal to then the current number of days is enough If there is no any suitable number of days the answer is 
https://codeforces.com//contest/1775/problem/F,1730878,F,1775F,1775,F. Laboratory on Pluto,As you know Martian scientists are actively engaged in space research One of the highest priorities is Pluto In order to study this planet in more detail it was decided to build a laboratory on Pluto It is known that the lab will be built of n square blocks of equal size For convenience we will assume that Pluto s surface is a plane divided by vertical and horizontal lines into unit squares Each square is either occupied by a lab block or not and only n squares are occupied Since each block is square it has four walls If a wall is adjacent to another block it is considered otherwise Pluto is famous for its extremely cold temperatures so the outside walls of the lab must be insulated One unit of insulation per exterior wall would be required Thus the greater the total length of the outside walls of the lab i e its perimeter the more insulation will be needed Consider the lab layout in the figure below It shows that the lab consists of n 33 blocks and all the blocks have a total of 24 outside walls i e 24 units of insulation will be needed You should build the lab optimally i e minimize the amount of insulation On the other hand there may be many optimal options so scientists may be interested in the number of ways to build the lab using the minimum amount of insulation modulo a prime number m Two ways are considered the same if they are the same when overlapping without turning Thus if a lab plan is rotated by 90 circ such a new plan can be considered a separate way To help scientists explore Pluto you need to write a program that solves these difficult problems ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n,MOD;\nvector<int> area;\n\nint memo[1005]; //excess is at most this much???\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\trep(x,0,2000) area.pub((x/2)*((x+1)/2));\n\t\n\tint TC,TYP;\n\tcin>>TC>>TYP;\n\tif (TYP==2){\n\t\tcin>>MOD;\n\t\t\n\t\tmemo[0]=1;\n\t\trep(x,1,1005) rep(z,0,4){\n\t\t\trep(y,0,1005-x){\n\t\t\t\tmemo[x+y]=(memo[x+y]+memo[y])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (TC--){\n\t\tcin>>n;\n\t\t\n\t\tint lo=0,hi=sz(area),mi;\n\t\twhile (hi-lo>1){\n\t\t\tmi=hi+lo>>1;\n\t\t\tif (area[mi]<n) lo=mi;\n\t\t\telse hi=mi;\n\t\t}\n\t\t\n\t\tint h=hi/2,w=(hi+1)/2;\n\t\t\t\n\t\tif (TYP==1){\n\t\t\tcout<<h<<"" ""<<w<<endl;\n\t\t\t\n\t\t\trep(x,0,h){\n\t\t\t\trep(y,0,w){\n\t\t\t\t\tif (n){\n\t\t\t\t\t\tcout<<""#"";\n\t\t\t\t\t\tn--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcout<<""."";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\t\n\t\t}\n\t\telse{\n\t\t\tint p=h+w;\n\t\t\t\n\t\t\tint ans=0;\n\t\t\trep(x,h-105,h+105){\n\t\t\t\tint w=p-x;\n\t\t\t\tif (w>0 && x>0 && n<=x*w) ans=(ans+memo[x*w-n])%MOD;\n\t\t\t}\n\t\t\t\n\t\t\tcout<<2*p<<"" ""<<ans<<endl;\n\t\t}\n\t}\n}\n']",,,"['constructive algorithms', 'dp', 'greedy', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Laboratory on Pluto.json,https://codeforces.com//blog/entry/111286,Let us find out the minimal perimeter for a fixed in Let If and then the minimum perimeter will be If and then the minimum perimeter will be If 1 and 2 are not satisfied then the minimum perimeter is For convenience we denote the semiperimeter by Let s check one of the rectangle s side from to We will immediately get Then if the area of the rectangle is at least then for tests with we can derive a rectangle with sides and by removing some number of cells from the 1st row or column of this matrix Consider a matrix with sides and with minimal perimeter and area at least It is easy to see that if we gradually remove one corner cell of a given figure the perimeter will not change Suppose we have some good figure Let s look at all four figures that form empty cells in the matrix These figures form a kind of staircase that is the number of cells in the past row is not less than the number of cells Why is this so Suppose that in some line we delete a cell so that the figure ceases to form a staircase In that case the perimeter of the piece will increase by which will be the bad piece Now the problem is reduced to the following For each matrix with dimensions by with minimal perimeter and area not less than calculate the number of ways to arrange the staircases in 4 corners such that the sum of cells occupied by the staircases equals How to do this Assume DP the number of ways to arrange staircases in not more than 4 so that the sum of all cells occupied by staircases equals and the length of the last line of staircase equals Then how to count the given DP Go through and the length of the line we will add to the current staircase then go from to Or go to the next corner This DP works for To answer we go through all good rectangles as specified above and add to the answer To solve the problem for a full score you must optimize the above DP to The final difficulty is 
https://codeforces.com//contest/1137/problem/B,309118,B,1137B,1137,B. Camp Schedule,The new camp by widely known over the country Spring Programming Camp is going to start soon Hence all the team of friendly curators and teachers started composing the camp s schedule After some continuous discussion they came up with a schedule s which can be represented as a binary string in which the i th symbol is if students will write the contest in the i th day and if they will have a day off At the last moment Gleb said that the camp will be the most productive if it runs with the schedule t which can be described in the same format as schedule s Since the number of days in the current may be different from number of days in schedule t Gleb required that the camp s schedule must be altered so that the number of occurrences of t in it as a substring is maximum possible At the same time only their order may change Could you rearrange the schedule in the best possible way ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nvector<int> kmp(const T &a) {\n  int n = a.size();\n  vector<int> fail(n);\n  fail[0] = -1;\n  for (int i = 1; i < n; ++i) {\n    fail[i] = fail[i - 1];\n    while (~fail[i] && a[fail[i] + 1] != a[i]) {\n      fail[i] = fail[fail[i]];\n    }\n    if (a[fail[i] + 1] == a[i]) {\n      ++fail[i];\n    }\n  }\n  return fail;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  string s, t;\n  cin >> s >> t;\n  int zero = 0, one = 0;\n  for (auto c : s) {\n    if (c == \'0\') {\n      ++zero;\n    } else {\n      ++one;\n    }\n  }\n  vector<int> fail = kmp(t);\n  int cur = 0;\n  while (zero || one) {\n    if (!zero) {\n      cout << 1;\n      --one;\n    } else if (!one) {\n      cout << 0;\n      --zero;\n    } else {\n      cout << t[cur];\n      if (t[cur] == \'0\') {\n        --zero;\n      } else {\n        --one;\n      }\n      ++cur;\n      if (cur == (int) t.size()) {\n        cur = fail.back() + 1;\n      }\n    }\n  }\n  cout << ""\\n"";\n  return 0;\n}\n']",,,"['greedy', 'hashing', 'strings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Camp Schedule.json,https://codeforces.com/blog/entry/65825,If we can t make any occurrences of string in string just output any permutation of Otherwise we can show that there is an optimal answer such that it starts with a string Suppose the opposite then remove all characters of the string before the first occurrence of the string and insert them to the end The number of occurrences clearly didn t decreased Obviously we want to make the next occurrence of string in string as left as possible If we decide to make it somewhere else we can move out the extra characters and try to improve the answer To achieve this we need to find the largest suffix of the string that matches the prefix of string of the same length It can be found by using the prefix function z function or hashes 
https://codeforces.com//contest/533/problem/F,26207,F,533F,533,F. Encoding,Polycarp invented a new way to encode strings Let s assume that we have string consisting of lowercase English letters Let s choose several pairs of letters of the English alphabet in such a way that each letter occurs in at most one pair Then let s replace each letter in with its pair letter if there is a pair letter for it For example if you chose pairs and then word according to the given encoding principle transforms to word Polycarpus already has two strings and He suspects that string was obtained after applying the given encoding method from some substring of string Find all positions in such that can be obtained fro substring by applying the described encoding operation by using some set of pairs of English alphabet letters ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 210010\nconst int alp = \'z\'-\'a\'+1;\nchar s[MAX],t[MAX];\nvector<int> wz[30],sl[30];\nint ost[30];\nint kmp[MAX*2];\nint ile[MAX];\nint q[MAX][alp];\nvector<int> gd[alp];\nvoid add(int nr,int i,int j){\n  if(nr < 0 || nr >= MAX)return;\n  if(q[nr][i]==0)q[nr][i] = j+1;\n  if(q[nr][j]==0)q[nr][j] = i+1;\n  if(q[nr][i] == j+1 && q[nr][j] == i+1)\n    ile[nr]++;\n}\nvoid licz(vector<int> &z,int il,int zy,int d){\n  int n = z.size();\n  int t = 0;\n  F(i,1,n){\n    while(t && z[i] != z[t])t = kmp[t-1];\n    if(z[i] == z[t])\n      t++;\n    kmp[i] = t;\n    if(t == il){\n      int poz = gd[d][i-il];\n      add(poz-ost[zy],zy,d);\n    }\n  }\n}\nint n,m;\nmain(){\n  make2(n,m);\n  scanf(""%s%s"",s,t);\n  R(i,n)s[i] -= \'a\';\n  R(i,m)t[i] -= \'a\';\n  R(i,alp)ost[i] = -1;\n  R(i,n){\n    if(ost[s[i]]!=-1)\n      wz[s[i]].PB(i-ost[s[i]]);\n    ost[s[i]] = i;\n    gd[s[i]].PB(i);\n  }\n  R(i,alp)ost[i] = -1;\n  R(i,m){\n    if(ost[t[i]]!=-1)\n      sl[t[i]].PB(i-ost[t[i]]);\n    ost[t[i]] = i;\n  }\n  R(i,alp)sl[i].PB(-1);\n  R(i,alp)R(j,alp){\n    int pom = sl[i].size();\n    if(ost[i] == -1 || gd[j].size() == 0)continue;\n    if(pom == 1){\n      R(k,gd[j].size())\n        add(gd[j][k]-ost[i],i,j);\n      continue;\n    }\n    R(k,wz[j].size())\n      sl[i].PB(wz[j][k]);\n    licz(sl[i],pom-1,i,j);\n    sl[i].resize(pom);\n  }\n  int roz = 0;\n  R(i,alp)if(ost[i]!=-1)roz++;\n  vector<int> wyn;\n  R(i,n)if(ile[i] == roz)wyn.PB(i+1);\n  printf(""%d\\n"",(int)wyn.size());\n  R(i,wyn.size())\n    printf(""%d "",wyn[i]);\n  puts("""");\n}']",,,"['hashing', 'string suffix structures', 'strings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Encoding.json,https://codeforces.com//blog/entry/17458,There are two possible ideas for solving this task Fix pair of letters x and y Replace all letters x in S with 1s and all remaining letters with 0s Do the same for y with string T By using KMP algorithm or Z function determine all positions where string T can be attached to string S so there is a match If such condition is fullfilled for pair x y and for pair y x then this position is a possible match position if we use pair x y and possibly some other pairs Now for each suitable position we need to check if letters can be distributed in pairs according to the information we know This can be done in O sigma where sigma 26 the size of the alphabet So this solution works in O n sigma2 n sigma O n sigma2 It fits in time limit if implementation is efficient enough Another way is to perform such transformation with both strings that allows us to compare them up to letters renaming Let s replace each letter with distance from it to the closes letter to the left from it that is the same or with inf if there is no such letter Now for strings to be equal we just need to check that string T matches the substring of S in all positions except possibly first occurence of each letter in T This can be done by modified prefix function or by hashing Now suppose we know that in some position string T is the same as string S up to renaming letters It s not hard to determine the letter permutation for this renaming by just checking what matches in S with first occurence of each letter in string T Let s check that this permutation is a set of transpositions in O sigma So we have a solution in O n sigma 
https://codeforces.com//contest/1428/problem/B,762864,B,1428B,1428,B. Belted Rooms,In the snake exhibition there are n rooms numbered 0 to n 1 arranged in a circle with a snake in each room The rooms are connected by n conveyor belts and the i th conveyor belt connects the rooms i and i 1 bmod n In the other words rooms 0 and 1 1 and 2 ldots n 2 and n 1 n 1 and 0 are connected with conveyor belts The i th conveyor belt is in one of three states If it is clockwise snakes can only go from room i to i 1 bmod n If it is anticlockwise snakes can only go from room i 1 bmod n to i If it is off snakes can travel in either direction Above is an example with 4 rooms where belts 0 and 3 are off 1 is clockwise and 2 is anticlockwise Each snake wants to leave its room and come back to it later A room is if the snake there can leave the room and later come back to it using the conveyor belts How many such rooms are there ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nint ile;\n\nint lew, pra;\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz);\n\tile=0;\n\tfor (int i=0; i<n; i++)\n\t\tif (wcz[i]==\'-\' || wcz[(i+1)%n]==\'-\')\n\t\t\tile++;\n\tlew=pra=0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (wcz[i]==\'<\')\n\t\t\tlew=1;\n\t\tif (wcz[i]==\'>\')\n\t\t\tpra=1;\n\t}\n\tif (!lew || !pra)\n\t\tile=n;\n\tprintf(""%d\\n"", ile);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['graphs', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Belted Rooms.json,https://codeforces.com//blog/entry/83771,Let s consider two ways to return to the start point The first is to go one big round around the circle The second is to move 1 step to the side and return back immediately Going one big round is only possible if and only if There are no clockwise belts OR There are no anticlockwise belts If we can go one big round all rooms are returnable If there are both clockwise and anticlockwise belts then we can t go one big round For any room to be returnable it must have an off belt to the left or to the right In summary check if clockwise belts are absent or if anticlockwise belts are absent If either is absent the answer is Otherwise we have to count the number of rooms with an off belt to the left or to the right 
https://codeforces.com//contest/1915/problem/E,2402116,E,1915E,1915,E. Romantic Glasses,Iulia has n glasses arranged in a line The i th glass has a i units of juice in it Iulia drinks only from odd numbered glasses while her date drinks only from even numbered glasses To impress her date Iulia wants to find a contiguous subarray of these glasses such that both Iulia and her date will have the same amount of juice in total if only the glasses in this subarray are considered Please help her to do that More formally find out if there exists two indices l r such that 1 leq l leq r leq n and a l a l 2 a l 4 dots a r a l 1 a l 3 dots a r 1 if l and r have the same parity and a l a l 2 a l 4 dots a r 1 a l 1 a l 3 dots a r otherwise ,"['#include ""bits/stdc++.h""\nusing namespace std;       \n\n// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\nusing ll = long long;\nusing ld = long double;\n#define pb push_back\n#define ff first\n#define ss second\n#define sz(x) (ll)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nvoid freopen(string s) { freopen((s+"".in"").c_str(), ""r"", stdin); freopen((s+"".out"").c_str(), ""w"", stdout); }\nvoid IOIGold2024_InshAllah() { ios_base::sync_with_stdio(false); cin.tie(NULL); }\nll binmul(ll a, ll b, ll c) { ll res = 0; while(b) { if(b&1) (res += a) %= c; (a += a) %= c; b >>= 1; } return res; }\nll binpow(ll a, ll b, ll c) { ll res = 1; while(b) { if(b&1) (res *= a) %= c; (a *= a) %= c; b >>= 1; } return res; }\ntemplate<typename T> T gcd(T a, T b) { if(b==0) return a; return gcd(b, a%b); }\ntemplate<typename T> T lcm(T a, T b) { return a/gcd(a, b)*b; }\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nld rnd() { return rng()%INT_MAX*1.0/INT_MAX; }\n\nconst ll inf = 1e18+7, MX = LLONG_MAX, MN = LLONG_MIN;\nconst ll mod = 1e9+7, N = 3e5+5;\nll a[N], even[N], odd[N];\n\nvoid kigash() {\n    ll n;\n    cin>>n;\n    // odd[i] - odd[j] = even[i] - even[j]\n    // odd[i] - even[i] = odd[j] - even[j]\n    map<ll, ll> have;\n    have[0] = 1;\n    ll f = 0;\n    for(ll i=1; i<=n; i++) {\n        cin>>a[i];\n        even[i] = even[i-1], odd[i] = odd[i-1];\n        if(i&1) odd[i] += a[i];\n        else even[i] += a[i];\n        if(have.count(odd[i]-even[i])) f = 1;\n        have[odd[i]-even[i]] = 1;\n    }\n    if(f) cout<<""YES\\n"";\n    else cout<<""NO\\n"";\n    return;\n}\n\nsigned main(/*Kigash Amir*/) {\n    // freopen("""");\n    IOIGold2024_InshAllah();\n    ll tt = 1;\n    cin>>tt;\n    for(ll i=1; i<=tt; i++) {\n        kigash();\n    }\n}']",,,"['data structures', 'greedy', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\E. Romantic Glasses.json,https://codeforces.com//blog/entry/123952,Let s rewrite the given equation as From here it s clear that we need to find if there is a subarray with equal to How to check this Let s flip all elements on even indices Then alternating sums of are the same as subarray sums on So we just need to check if there is a subarray with sum This is a standard problem with prefix sums if two prefix sums are equal then the subarray between them has sum otherwise no subarray has sum The complexity is or depending on how you check if two elements of an array are equal Be careful about using hash tables as they can be hacked 
https://codeforces.com//contest/828/problem/A,113851,A,828A,828,A. Restaurant Tables,In a small restaurant there are tables for one person and tables for two persons It it known that groups of people come today each consisting of one or two people If a group consist of one person it is seated at a vacant one seater table If there are none of them it is seated at a vacant two seater table If there are none of them it is seated at a two seater table occupied by single person If there are still none of them the restaurant denies service to this group If a group consist of two people it is seated at a vacant two seater table If there are none of them the restaurant denies service to this group You are given a chronological order of groups coming You are to determine the total number of people the restaurant denies service to ,"['#include<bits/stdc++.h>\nint n,a,b,c=0,ans=0;\nint main(){\n\tscanf(""%d%d%d"",&n,&a,&b);\n\tfor(int i=0,x;i<n;++i){\n\t\tscanf(""%d"",&x);\n\t\tif(x==1){\n\t\t\tif(a)--a;\n\t\t\telse if(b)--b,++c;\n\t\t\telse if(c)--c;\n\t\t\telse ++ans;\n\t\t}else{\n\t\t\tif(b)--b;\n\t\t\telse ans+=2;\n\t\t}\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']",,,['implementation'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Restaurant Tables.json,https://codeforces.com//blog/entry/53268,We need to store three values the number of free tables for one person the number of free tables for two persons and the number of tables for two persons occupied by single person If the next group consisting of persons and there are no free tables for two persons i e the restaurant denies service to this group and we need to add to the answer In the other case we need subtract one from and move to the next group If the next group consisting of person and there is free table for one person i e we need to subtract one from and move to the next group In the other case if there is free table for two persons you need to put person for this table subtract one from and add one to If there are no free tables but we need to subtract one form If no one from the described conditions did not met the restaurant denies service to this group consisting of one person and we need to add one to the answer and move to the next group 
https://codeforces.com//contest/1609/problem/C,1205811,C,1609C,1609,C. Complex Market Analysis,While performing complex market analysis William encountered the following problem For a given array a of size n and a natural number e calculate the number of pairs of natural numbers i k which satisfy the following conditions 1 le i k i e cdot k le n Product a i cdot a i e cdot a i 2 cdot e cdot ldots cdot a i k cdot e is a prime number A prime number or a prime is a natural number greater than 1 that is not a product of two smaller natural numbers ,"[""/**\n *    author:  tourist\n *    created: 28.11.2021 17:38:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int M = (int) 1e6 + 10;\n  vector<bool> pr(M, true);\n  pr[0] = pr[1] = false;\n  for (int i = 2; i < M; i++) {\n    if (pr[i]) {\n      for (int j = i + i; j < M; j += i) {\n        pr[j] = false;\n      }\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, e;\n    cin >> n >> e;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> L(n);\n    vector<int> R(n);\n    for (int z = 0; z < e; z++) {\n      int i = z;\n      int cc = 0;\n      while (i < n) {\n        if (a[i] > 1) {\n          L[i] = cc + 1;\n          cc = 0;\n        } else {\n          cc += 1;\n        }\n        i += e;\n      }\n      cc = 0;\n      i -= e;\n      while (i >= 0) {\n        if (a[i] > 1) {\n          R[i] = cc + 1;\n          cc = 0;\n        } else {\n          cc += 1;\n        }\n        i -= e;\n      }\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n      if (pr[a[i]]) {\n        ans += L[i] * 1LL * R[i] - 1;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]",,,"['binary search', 'dp', 'implementation', 'number theory', 'schedules', 'two pointers']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Complex Market Analysis.json,https://codeforces.com//blog/entry/97350,Note that the product of natural numbers is a prime number if and only if of these numbers equal to one and one number is prime Next let s group all of our numbers into groups which are ones It s important that these groups are separated by a prime numbers If the current number is neither a one nor a prime it means we stop building a group for the current index Let s say we now have of these groups then for each we must add product where is the number of ones in group Also a group of ones doesn t necessarily have to be connected to the subsequent group of ones so to get the answer we must take into the account their product with the next prime if there is one and the previous prime if there is one for this group 
https://codeforces.com//contest/296/problem/A,2829,A,296A,296,A. Yaroslav and Permutations,Yaroslav has an array that consists of integers In one second Yaroslav can swap two neighboring array elements Now Yaroslav is wondering if he can obtain an array where any two neighboring elements would be distinct in a finite time Help Yaroslav ,"['#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#pragma comment(linker, ""/STACK:256000000"")\n\nusing namespace std;\n\nconst int maxN = 200;\nint a[maxN];\n\nint main() {\n  //freopen(""input.txt"", ""r"", stdin);\n  //freopen(""output.txt"", ""w"", stdout);\n\n  int n;\n  scanf(""%d"", &n);\n\n  map<int, int> res;\n\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    ++res[x];\n  }\n\n  for (map<int, int>::iterator it = res.begin(); it != res.end(); ++it) {\n    if (it->second > (n + 1) / 2) {\n      cout << ""NO"" << endl;\n      return 0;\n    }\n  }\n\n  cout << ""YES"" << endl;\n\n  return 0;\n}\n']",,,"['greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Yaroslav and Permutations.json,https://codeforces.com//blog/entry/7329,Note that after applying the operations of the exchange we can get any permutation of numbers Not difficult to understand that the answer is YES if you can place a single number that it would not stand in the neighboring cells Thus if a some number is meeted C times it must fulfill the condition C n 1 2 
https://codeforces.com//contest/1558/problem/A,1088949,A,1558A,1558,A. Charmed by the Game,Alice and Borys are playing tennis A tennis match consists of In each game one of the players is and the other one is Players serve in turns after a game where Alice is serving follows a game where Borys is serving and vice versa Each game ends with a victory of one of the players If a game is won by the serving player it s said that this player If a game is won by the receiving player it s said that this player It is known that Alice won a games and Borys won b games during the match It is unknown who served first and who won which games Find all values of k such that exactly k breaks could happen during the match between Alice and Borys in total ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint a, b;\n\tcin >> a >> b;\n\tint n = (a + b);\n\tint x = n / 2;\n\tint y = (n+1) / 2;\n\tset<int> val;\n\tfor(int _ = 0; _ < 2; _++){\n\t\tfor(int z = min(a, x) + min(b, y); z >= max(a + x, b + y) - n; z -= 2) val.insert(n - z);\n\t\tswap(a, b);\n\t}\n\tcout << val.size() << '\\n';\n\tfor(int z : val){\n\t\tcout << z << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]",,,"['brute force', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Charmed by the Game.json,https://codeforces.com//blog/entry/94216,First of all we don t know who served first but there are only two options so let s just try both and unite the sets of s we get Assume that Alice served first Exactly games were played If is even both players served exactly times and if is odd Alice served one more time than Borys The simplest way to consider both cases is to say that Alice served times and Borys served times denotes rounding up and denotes rounding down Let be the number of times Borys broke Alice s serve and let be the number of times Alice broke Borys serve In this case the number of games Alice won is and the number of games Borys won is We know neither nor but let s loop over From we can calculate If the values of and represent a valid scenario of the match with exactly breaks in total The case when Borys served first is handled similarly Analyzing the formulas further we can find a closed form solution Let If is even all possible values of are If is odd all possible values of are 
https://codeforces.com//contest/384/problem/C,5719,C,384C,384,C. Milking cows,Iahub helps his grandfather at the farm Today he must milk the cows There are cows sitting in a row numbered from to from left to right Each cow is either facing to the left or facing to the right When Iahub milks a cow all the cows that see the current cow get scared and lose one unit of the quantity of milk that they can give A cow facing left sees all the cows with lower indices than her index and a cow facing right sees all the cows with higher indices than her index A cow that got scared once can get scared again and lose one more unit of milk A cow that has been milked once cannot get scared and lose any more milk You can assume that a cow never loses all the milk she can give a cow gives an infinitely amount of milk Iahub can decide the order in which he milks the cows But he must milk each cow exactly once Iahub wants to lose as little milk as possible Print the minimum amount of milk that is lost ,"['//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname """"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(""%d"" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(""%d"" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint a[sz], s1, s2, p1, p2, t[2][sz], c1, c2, c, n, L[sz], R[sz];\nlong long ans;\n\nvoid upd(int g, int v, int l, int r, int p, int x)\n{\n\tif (l == r)\n\t\tt[g][v] = x;\n\telse\n\t{\n\t\tint m = (l + r) >> 1;\n\t\tif (p <= m)\n\t\t\tupd(g, v + v, l, m, p, x);\n\t\telse\n\t\t\tupd(g, v + v + 1, m + 1, r, p, x);\n\t\tt[g][v] = t[g][v + v] + t[g][v + v + 1];\n\t}\n}\n\n\nint get(int g, int v, int tl, int tr, int l, int r)\n{\n\tif (l > r)\n\t\treturn 0;\n\tif (l == tl && r == tr)\n\t\treturn t[g][v];\n\tint m = (tl + tr) >> 1;\n\treturn get(g, v + v, tl, m, l, min(r, m)) + get(g, v + v + 1, m + 1, tr, max(m + 1, l), r);\n}\n\nint main(){\n\t//freopen(fname""in"", ""r"", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\tcin >> n;\n\tfor (1, n, i)\n\t{\n\t\tcin >> a[i];\n\t\tif (a[i])\n\t\t\tL[++c1] = i;\n\t\telse\n\t\t\tR[++c2] = i;\n\t\tupd(a[i], 1, 1, n, i, 1);\t\n\t}\n\tc = 1;\n\tfor (1, n, i)\n\t{\n\t\tif (c <= c1 && c2)\n\t\t{\n\t\t\tp1 = L[c];\n\t\t\tp2 = R[c2];\n\t\t\ts1 = get(1, 1, 1, n, 1, p1 - 1) + get(0, 1, 1, n, p1 + 1, n);\n\t\t\ts2 = get(1, 1, 1, n, 1, p2 - 1) + get(0, 1, 1, n, p2 + 1, n);\n\t\t\tans += min(s1, s2);\n\t\t\tif (s1 < s2)\n\t\t   \t{\n\t\t   \t\tupd(1, 1, 1, n, p1, 0);\n\t\t   \t\tc++;\n\t\t   \t}\n\t\t   \telse\n\t\t   \t{\n\t\t   \t\tupd(0, 1, 1, n, p2, 0);\n\t\t   \t\tc2--;\n\t\t   \t}\n\t\t}\n\t\telse\n\t\tbreak;\n\t}\n\tcout << ans;\n    \treturn 0;\n}\n']",,,['greedy'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Milking cows.json,https://codeforces.com//blog/entry/10476,A good strategy to approach this problem is to think how optimal ordering should look like For this let s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j As we ll show having this information will be enough to build optimal ordering It is enough to consider only cases when i j case when i j is exactly the opposite of case i j For formality I ll call the optimal ordering permutation and lost milk the cost of permutation So for an optimal permutation P let s take 2 numbers i j and see in which cases i should appear before j in permutation i is before j if P pos1 i P pos2 j and pos1 pos2 otherwise we ll call i is after j We have 4 possible cases 1 A i 0 and A j 0 If we put i before j no additional cost will be added Since j is in right of i and i only adds cost when it finds elements in left of i j won t be affected when processing i When processing j i will be already deleted so it won t affect the cost either Hence we can put i before j and no cost will be added 2 A i 0 and A j 1 Here i and j can appear in arbitrary order in permutation i can be before or after j No matter how we choose them they won t affect each other and cost will remain the same 3 A i 1 and A j 0 As well here i and j can appear in arbitrary order If we choose i first j will be in right of it so cost of permutation will increase by one If we choose j first i will be in left of it so cost of permutation will increase as well No matter what we do in this case cost of permutation increases by 1 4 A i 1 and A j 1 Here i needs to be after j This adds 0 cost Taking i before j will add 1 cost to permutation since j is in right of i Those 4 cases show us how a minimal cost permutation should look In a permutation like this only case 3 contributes to final cost so we need to count number of indices i j such as i j and A i 1 and A j 0 If we show a permutation following all rules exists task reduces to By cases 2 and 3 it follows that in an optimal permutation it only matters order of elements having same value in A We can put firstly all elements having value 0 in A then all elements having value 1 in A We can order elements having value 0 by case 1 and elements having value 1 by case 4 More exactly suppose i1 i2 im and A i1 A i2 A im 0 and j1 j2 jn A j1 A j2 A jn 1 Then a permutation following all rules is i1 i2 im j1 j2 jn This permutation can always be built Hence task reduces to count number of indices i j such as i j and A i 1 and A j 0 We can achieve easily an O N algorithm to do this Let s build an array cnt j number of 0s in range j j 1 N from array A We can easily implement it by going backwards from N to 1 The result is sum of cnt i when A i 1 Code http pastie org 8651813 Our first observation is that if there is a path from 1 1 to N N then the length of path is 2 N 2 Since all paths have length 2 N 2 it follows that if there is at least one path the answer is 2 N 2 and if there isn t the answer is 1 How to prove it Every path from 1 1 to N N has exactly N 1 down directions and exactly N 1 right directions So total length for each path is N 1 N 1 2 N 2 So we reduced our problem to determine if there is at least one path from 1 1 to N N This is the challenging part of this task considering that N 10 9 How would you do it for a decently small N let s say N 10 3 One possible approach would be for each row keep a set of reachable columns We could easily solve this one by doing this if i j denotes element from ith row and jth column then i j is is not reachable if if i j contains a volcano then i j is not reachable Otherwise if at least one of i 1 j and i j 1 is reachable then i j is reachable Otherwise i j is not reachable What s the main problem of this approach It needs to keep track of 10 9 lines and in worst case each of those lines can have 10 9 reachable elements So worst case we need 10 9 10 9 10 18 operations and memory Can we optimize it We can note for beginning that we don t need to keep track of 10 9 lines only m lines are really necessarily We need only lines containing at least one obstacle in worst case when each line contains only one obstacle we need m lines How to solve it this way Suppose line number x contains some obstacles and lines x 1 x 2 x 3 do not contain any obstacle Suppose we calculated set S y cell x y is reachable How would look S1 S2 S3 corresponding to lines x 1 x 2 x 3 For S1 we can reach cell x 1 ymin where ymin is minimal value from set S Then we can also reach ymin 1 ymin 2 N by moving right from x 1 ymin So S1 ymin ymin 1 N How do S2 and S3 look It s easy to see that they ll be as well ymin ymin 1 N So we get following optimization suppose set of lines containing at least one obstacle is L1 L2 Lk We need to run algorithm only for lines L1 L1 1 L2 L2 1 L3 L3 1 Lk Lk 1 It looks like we didn t make anything with this optimization Even if we calculate for m lines each line can still have 10 9 reachable positions So worst case we perform 10 14 operations We need something better for managing information from a line You can note that for a given line y there are a lot of positions having consecutive values There are a lot of positions x y and x y 1 both reachable This should give us following idea what if instead of keeping reachable positions we keep reachable ranges That is for each line x we keep a set of ranges S a b all cells x k with a k b are reachable How many ranges can it be for a line If the line contains m obstacles there are m 1 ranges Suppose for line x all cells are reachable but for line x 1 cells x 1 3 x 1 5 x 1 N 1 are blocked Then the ranges of reachable cells are 1 2 4 4 6 N 2 and N N By now we get worst case m lines and worst case each line having m elements so in worst case we d have to handle m m 10 10 events This may still look too much but happily this bound is over estimated If a line has o obstacles there can be at most o 1 ranges If lines L1 L2 Lk have o1 o2 ok obstacles there ll be at most o1 o2 ok k ranges But o1 o2 ok m and also k is at most m proved above why we re interested in at most m lines so in worst case we get m m 2 m ranges Yaay finally a decent number of states for this problem So we iterate each line we re interested in Let s find set of ranges for this line thinking that all cells from line above are reachable This is easy to do After we get our ranges like all cells from above can be visited let s think how having obstacles above can influence current ranges After adding ranges from above current ranges can t increase obviously they can only decrease remain the same or some of them can become empty So let s take each range a b from current line and see how it will transform after adding ranges from previous line Given range a b it can transform only in a b with a a If a b then obviously range is empty Why second number of range keeps constant Let a smallest reachable column from current line which is in range a b It s enough to check a a as if a b range will be empty It s obviously why we need to keep a smallest value possible a we re interested to keep range as big as possible and as less as we cut from left as big it is Once we ve found a in range a b or a b if range is empty all cells a 1 a 2 b are reachable as well by going right from a so if interval is not empty then second number defining it remains b Next question is how to find a fast enough In order a point a to be reachable on current range it also needs to exist a range on previous line containing it If the range from previous line is pa pb then a needs to follow 3 conditions a minimal such as pa a pb a a What if instead of finding a we find pa pb Then a is max pa a In order a to be as small as possible since a is constant pa needs to be as small as possible So we reduced it to pa minimal pb a a pb a Intervals from previous line are disjoint no 2 intervals cross each other It means that if pb is minimal than pa is minimal too if we increase pb then pa will increase too so it won t be minimal Hence you need to find an interval pa pb such as pb is minimal and pb a Then a is max a pa This is easy to do if we sort all intervals from previous line increasing by second value pb then we binary search for value a Finally after running algorithm for all lines last range from last line has second number N assuming ranges are sorted increasing by second value then there exist a path otherwise there does not exist This algorithm should run O m logm worst case good enough to pass Code http pastie org 8651817 This is kind of task that needs to be break into smaller subproblems that you can solve independently then put them together and get solution Let s define level of a node the number of edges in the path from root to the node Root node 1 is at level 0 sons of root are at level 1 sons of sons of root are at level 2 and so on Now suppose you want to do an operation of type 1 to a node x What nodes from subtree of x will be added val a positive value Obviously x will be first being located at level L Sons of x located at level L 1 will be added val Sons of sons located at level L 2 will be added value val again So nodes from subtree of x located at levels L L 2 L 4 will be added a val and nodes located at levels L 1 L 3 L 5 will be added a val Let s take those values of L modulo 2 All nodes having remainder L modulo 2 will be added a val and nodes having reminder L 1 modulo 2 will be added val In other words for a fixed x at a level L let y a node from subtree of x at level L2 If L and L2 have same parity val will be added to y Otherwise val will be added to y From here we have the idea to split nodes of tree in 2 sets those being located at even level and those being located at odd level What still makes the problem hard to solve The fact that we have a tree If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree problem would be simpler the problem would reduce to add subtract values to all elements of a subarray and query about a current value of an element of array So how can we transform tree to an array such as for a node x all nodes from subtree of x to be a subarray of array The answer is yes We can do this by properties of DFS search Before reading on make sure that you know what is discovery time and finish time in a DFS search Let s build 3 arrays now discover representing nodes in order of their discover times a node is as before in discover as it has a small discover time begin for a node in which time it was discovered and end what s last time of a discovered node before this node finishes For a subtree of x all nodes in the subtree are nodes in discover from position begin x to end x Example suppose you have tree 1 5 1 6 6 7 6 4 4 2 4 3 Discover is 1 5 6 7 4 2 3 begin is 1 6 7 5 2 3 4 end is 7 6 7 7 2 7 4 What s subtree of node 6 elements of discover from position begin 6 to end 6 In this case from 3 to 7 so elements 6 7 4 2 3 You can see it s correct and take more examples if you want Now we reduced problem to you re given an array A you can perform 2 operations 1 increase all elements from a range x y to a value val val can be negative to treat subtractions 2 what s current value of an element from position pos Those who solved Iahub and Xors from my last round CF 198 should probably say they saw something similar before If you didn t solve problem before I encourage you to do it after you solve this one it uses a similar idea to what will follow now Also if you don t know Fenwick trees please read them before moving on An alternative would be for this task using segment trees with lazy update but I see this one more complicated than needed I ll use now a not so common approach when dealing with data structures Instead of keeping in a node the result like you usually do I ll keep just an auxiliary information So what algorithm proposed does Let A an array initially with all elements 0 When you need to update range x y with value val you simply do A x val and A y 1 val When you need to answer a query about position pos you output A 1 A 2 A pos Implemented brute force you get O 1 per update and O N per query However these both are operations supported by a Fenwick tree so you can get O logN per operation It may not be very clear why this algorithm works Let s take a closer look an update needs to add value val only to range x y When you query a position pos let s see if algorithm handles it correctly 1 pos x In this case result must not be affected by my update Since pos x and I only updated 2 values with indices x when doing A 1 A 2 A pos it won t matter at all I did that update at least not for this query 2 x pos y Here for a pos I need to add value val only once We add it only at A x in this way it will be counted once and it will be considered for each elements from range x y since an element at position p from range x y has p x in A 1 A 2 A p I ll have to consider A x 3 pos y Here I don t have to consider the query But it would be considered when processing A x But if I add to A y 1 value val I ll just cancel the value previously added Code actually we use just one Fenwick tree instead of 2 can you think why it works http pastie org 8651824 
https://codeforces.com//contest/1996/problem/F,2778593,F,1996F,1996,F. Bomb,Sparkle gives you two arrays a and b of length n Initially your score is 0 In one operation you can choose an integer i and add a i to your score Then you must set a i max 0 a i b i You only have time to perform k operations before Sparkle sets off a nuclear bomb What is the maximum score you can acquire after k operations ,"['/**   - dwuy -\xa0\u3000\u3000\u3000\u3000\u3000 \u3000   \u3000\u3000\u3000\u3000\u3000 | \u3000_\u3000 _|\u3000 \u3000\u3000\u3000 ` _x \u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\u3000\u3000\u3000 /\u3000  \u3000\u3000 ?\u3000|\u3000\u3000 |\u3000|\u3000|\u3000| (__)_)\u3000\xa0**/#include <bits/stdc++.h>\xa0#define fastIO ios_base::sync_with_stdio(false); cin.tie(NULL)#define file(a) freopen(a"".inp"",""r"",stdin); freopen(a"".out"", ""w"",stdout)#define fi first#define se second#define endl ""\\n""#define len(s) (int)((s).size())#define MASK(k)(1LL<<(k))#define TASK ""test""#define int long long\xa0using namespace std;\xa0typedef tuple<int, int, int> tpiii;typedef pair<double, double> pdd;typedef pair<int, int> pii;typedef long long ll;\xa0const long long OO = 1e18;const int MOD = 1e9 + 7;const int INF = 1e9;const int MX = 300005;\xa0int n, m, k, q;string s, t;int a[MX];int b[MX];\xa0int calc(int l, int r, int k){    return (l + r)*((r - l)/k + 1)/2;}\xa0void solve(){    cin >> n >> k;    for(int i=1; i<=n; i++) cin >> a[i];    for(int i=1; i<=n; i++) cin >> b[i];\xa0    int res = 0;    for(int lo=0, hi=1e9; lo<=hi;){        int mid = (lo + hi)>>1;        int cnt = 0;        for(int i=1; i<=n; i++) if(a[i] >= mid){            cnt += (a[i] - mid)/b[i] + 1;        }        if(cnt >= k) res = mid, lo = mid + 1;        else hi = mid - 1;    }    int ans = 0;    vector<int> tmp;    for(int i=1; i<=n; i++) if(a[i] >= res){        if((a[i] - res)/b[i]) ans += calc(a[i] - b[i]*((a[i] - res)/b[i] - 1), a[i], b[i]);        tmp.push_back(a[i] - b[i]*((a[i] - res)/b[i]));        k -= (a[i] - res)/b[i];    }        sort(tmp.begin(), tmp.end(), greater<int>());    for(int x: tmp){        if(k == 0) break;        ans += x;        k--;    }    cout << ans << endl;}\xa0int32_t main(){    fastIO;    //file(TASK);\xa0    int q;    cin >> q;    while(q--){        solve();    }\xa0    // cout << calc(5, 17, 4);\xa0    return 0;}\xa0\xa0\xa0']",,,"['binary search', 'greedy', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Bomb.json,https://codeforces.com//blog/entry/131528,Let s first solve the problem in O k One possible solution is to loop through each operation and take the largest ai each time and set ai max 0 ai bi This can be done with a set or a priority queue With that in mind let s binary search for the largest x such that every value we add to our score has been greater or equal to x for all k operations Define f x as the number of operations required for every ai to be less than x Specifically f x ni 1 ai xbi We are searching for the smallest x such that f x k Once we ve found x we can subtract f x from k Note that now k must be less than to n otherwise we can another operation on all ai So it suffices to run the slow solution for these remaining operations as long as ai 0 Alternatively we can notice that the remaining operations will all add x 1 to our answer assuming x 0 To obtain the sum of all ai we collected when calculating f x we can use the arithmetic sequence sum formula For each i the number of terms in the sequence is t ai xbi The first term of the sequence is f ai bi t 1 The last term is ai Using the formula we can add t2 f ai to the answer 
https://codeforces.com//contest/2037/problem/E,3030273,E,2037E,2037,E. Kachina s Favorite Binary String,Kachina challenges you to guess her favorite binary string text s of length n She defines f l r as the number of subsequences text of texttt 01 in s l s l 1 ldots s r To determine s you can ask her some questions In each question you can choose two indices l and r 1 leq l r leq n and ask her for the value of f l r Determine and output s after asking Kachina no more than n questions However it may be the case that s is In this case you would need to report texttt IMPOSSIBLE instead Formally s is if after asking n questions there are always multiple possible strings for s regardless of what questions are asked texttt IMPOSSIBLE text A binary string only contains characters texttt 0 and texttt 1 text A sequence a is a subsequence of a sequence b if a can be obtained from b by the deletion of several possibly zero or all elements For example subsequences of mathtt 1011101 are mathtt 0 mathtt 1 mathtt 11111 mathtt 0111 but not mathtt 000 nor mathtt 11100 ,"['#include <bits/stdc++.h>\xa0#define int long long#define fi first#define se second\xa0const int N = 2e5 + 5;const int K = 1e2 + 5;const int mod = 998244353;\xa0#define all(v) (v).begin(), (v).end()#define pii pair<int, int>\xa0using namespace std;\xa0mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());\xa0int t, n, a[N];\xa0signed main() {    ios_base::sync_with_stdio(0);    cin.tie(0);\xa0    if(ifstream(""file.inp"")){    \tfreopen(""file.inp"", ""r"", stdin);    \tfreopen(""file.out"", ""w"", stdout);    }\xa0    cin >> t;    while(t--) {    \tcin >> n;    \tbool imp = 1;    \ta[1] = 0;    \tfor(int i = 2; i <= n; i++) {    \t\tcout << ""? "" << 1 << \' \' << i << endl;    \t\tcin >> a[i];    \t\tif(a[i] > 0) imp = 0;    \t}    \tif(imp) {    \t\tcout << ""! IMPOSSIBLE"" << endl;    \t}    \telse {    \t\tstring s(n, \'1\');    \t\tint cnt = 0;    \t\tfor(int i = 2; i <= n; i++) {    \t\t\tif(a[i] > a[i - 1]) {    \t\t\t\tfor(int j = i - 2; j >= i - 1 - a[i] + 2 * a[i - 1]; j--) {                        s[j] = \'0\';                        cnt++;    \t\t\t\t}    \t\t\t}    \t\t\telse if(a[i] == a[i - 1] && cnt) s[i - 1] = \'0\';    \t\t}    \t\tcout << ""! "" << s << endl;    \t}    }\xa0    return 0;}\xa0// tuntun']",,,"['dp', 'greedy', 'interactive', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Kachina s Favorite Binary String.json,https://codeforces.com//blog/entry/135533,Notice that for if for some r we have f 1 r f 1 r 1 then we can conclude that sr 1 1 if it is 0 then f 1 r f 1 r 1 will be true and if f 1 r is non zero and f 1 r f 1 r 1 then sr 1 is 0 Unfortunately this is only useful if there is a 0 in s1 s2 sr so the next thing can try is to find is the value of the longest prefix such that f 1 r is 0 after this point there will be a zero in all prefixes See that if f 1 r 0 and f 1 r 1 k then sr 1 1 the last k characters of s1 s2 sr must be 0 and the first r k characters must be 1 To prove this we can argue by contradiction suppose it is not true and then it will become apparent that some shorter prefix will be non zero when we query it The one case that this does not cover is when all prefixes are zero from similar contradiction argument as above we can see that the string must look like 111 1100 000 in this case in this case it is not hard to see that all queries will give a value of zero and thus we can report that it is impossible So we should query all prefixes the first one which is non zero if this does not exist we can report impossible we can deduce its value as discussed above then there will be a 0 in the prefix so we can deduce all subsequent characters as discussed at the start 
https://codeforces.com//contest/1913/problem/A,2387087,A,1913A,1913,A. Rating Increase,Monocarp is a great solver of adhoc problems Recently he participated in an Educational Codeforces Round and gained rating Monocarp knew that before the round his rating was a After the round it increased to b b a He wrote both values one after another to not forget them However he wrote them so close to each other that he can t tell now where the first value ends and the second value starts Please help him find some values a and b such that neither of them has a leading zero both of them are strictly greater than 0 b a they produce the given value ab when written one after another If there are multiple answers you can print any of them ,"['/**\n *    author:  tourist\n *    created: 18.12.2023 09:34:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string s;\n    cin >> s;\n    bool found = false;\n    for (int i = 1; i <= (int) s.size() - 1; i++) {\n      string a = s.substr(0, i);\n      string b = s.substr(i);\n      if (a[0] == \'0\' || b[0] == \'0\') {\n        continue;\n      }\n      if (a.size() < b.size() || (a.size() == b.size() && a < b)) {\n        cout << a << "" "" << b << \'\\n\';\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      cout << -1 << \'\\n\';\n    }\n  }\n  return 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Rating Increase.json,https://codeforces.com//blog/entry/123493,Since the length of the string is pretty small it s possible to iterate over all possible cuts of into and First you have to check if has a leading zero If it doesn t compare integer representations of and In order to get an integer from a string you can use for C or for Python 
https://codeforces.com//contest/1551/problem/F,1055226,F,1551F,1551,F. Equidistant Vertices,A tree is an undirected connected graph without cycles You are given a tree of n vertices Find the number of ways to choose exactly k vertices in this tree i e a k element subset of vertices so that all pairwise distances between the selected vertices are equal in other words there exists an integer c such that for all u v u ne v u v are in selected vertices d u v c where d u v is the distance from u to v Since the answer may be very large you need to output it modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n    \nconst int MOD=1000000007;\nstruct Mint {\n    int val;\n \n    Mint(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n        if (v >= MOD)\n            v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        int g = m, r = a, x = 0, y = 1;\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        } \n        return x < 0 ? x + m : x;\n    } \n    explicit operator int() const {\n        return val;\n    }\n    Mint& operator+=(const Mint &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    Mint& operator-=(const Mint &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n           #if !defined(_WIN32) || defined(_WIN64)\n                return x % m;\n           #endif\n           unsigned x_high = x >> 32, x_low = (unsigned) x;\n           unsigned quot, rem;\n           asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n           return rem;\n    }\n    Mint& operator*=(const Mint &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n    Mint& operator/=(const Mint &other) {\n        return *this *= other.inv();\n    }\n    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }\n    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }\n    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }\n    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }\n    Mint& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n    Mint& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }\n    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }\n    Mint operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n    bool operator==(const Mint &other) const { return val == other.val; }\n    bool operator!=(const Mint &other) const { return val != other.val; }\n    Mint inv() const {\n        return mod_inv(val);\n    }\n    Mint power(long long p) const {\n        assert(p >= 0);\n        Mint a = *this, result = 1;\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n        return result;\n    }\n    friend ostream& operator << (ostream &stream, const Mint &m) {\n        return stream << m.val;\n    }\n    friend istream& operator >> (istream &stream, Mint &m) {\n        return stream>>m.val;   \n    }\n};\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    vector<vector<int>> g(n+1);\n    for(int i=1;i<=n-1;++i)\n    {\n        int x,y;\n        cin >> x >> y;\n        g[x].push_back(y),g[y].push_back(x);\n    }\n    vector<int> dep(n+1);\n    Mint ans = 0;\n    vector<vector<int>> cnt(n+1,vector<int>(n+1,0));\n    int have = 0;\n    function<void(int,int,int)> dfs = [&](int s,int p,int tt)\n    {\n        int cur = 0;\n        ++cnt[dep[s]][tt];\n        for(auto &j:g[s])\n        {\n            if(j != p)\n            {\n                dep[j] = dep[s] + 1;\n                if(p == 0)\n                    dfs(j,s,++cur);\n                else\n                    dfs(j,s,tt);\n            }\n        }\n        if(p == 0)\n            have = cur;\n    };\n    if(k == 2)\n    {\n        cout << Mint(n) * Mint(n-1)/2 << ""\\n"";\n        return 0;\n    }\n    int K = k;\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=0;j<=n;++j)\n        {\n            for(int k=0;k<=n;++k)\n                cnt[j][k] = 0;\n            dep[j] = 0;\n        }\n        dfs(i,0,0);\n        vector<vector<Mint>> dp(have+1,vector<Mint>(k+1,0));\n        debug(have);\n        // continue;\n        for(int j=1;j<=n;++j)\n        {\n            int t = 0;\n            vector<int> want;\n            for(int k=1;k<=have;++k)\n            {\n                if(cnt[j][k] > 0)\n                    want.push_back(cnt[j][k]);\n            }\n            t = sz(want);\n            debug(i,j,want);\n            if(t < K)\n                break;\n            for(int k=1;k<=t;++k)\n                for(int l=0;l<=K;++l)\n                    dp[k][l] = 0;\n            dp[0][0] = 1;\n            for(int x=1;x<=t;++x)\n            {\n                for(int l=0;l<=K;++l)\n                {\n                    if(l == 0)\n                        dp[x][l] = dp[x-1][l];\n                    else\n                        dp[x][l] = dp[x-1][l] + dp[x-1][l-1] * want[x-1];\n                }\n            }\n            ans += dp[t][K];\n        }\n        // debug(i,int(ans));\n    }\n    cout << ans << ""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']",,,"['brute force', 'combinatorics', 'dfs and similar', 'dp', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Equidistant Vertices.json,https://codeforces.com//blog/entry/93149,If any set of two vertices may be taken so the answer is modulo Suppose Consider three vertices such that If this equality is true there s a vertex that belongs to all three paths otherwise either one of the vertices belongs to the path between two others or there is more than one simple path i e path having distinct edges between any of the vertices so the graph isn t a tree Hence the following equalities are true Then hence Suppose Let s select vertices that is a correct desired set of four vertices for the triple of paths let s select a common vertex and for the triple Because is the same vertex as The same procedure we can do for all other pairs of triples of vertices The situation will not be another if we add a new vertex in the set if the set will still meet the problem s conditions So if a vertex exists such that all vertices of the set are equidistant from it Note that for each set only one such exists Let s iterate over all vertices taking them as and hang the tree by The set of vertices equidistant from meets the problem s condition if and only if the vertices of the set are placed in different subtrees of vertices adjacent to in other words the paths from them to must intersect only in Let s calculate the number of desired sets for a given and a layer of equidistant vertices Let be the number of vertices adjacent to and it s the number of subtrees too Let s create an array indexed of size so that the th element will contain the number of the vertices of the layer in the th subtree For the layer of vertices adjacent to this array will be filled with For the other layers we can update the array as follows let s mark and vertices adjacent to as used then for every vertex of the current layer let s decrease by if is the index of the subtree of the vertex then let s increase by the number of the vertices adjacent to the current one but not used Then let s mark the vertices as used After the iteration the array will correspond to the new layer Using the array let s calculate the number of the desired sets of vertices using the concept of dynamic programming Let s create an array indexed of size will contain a number of found sets of vertices if only subtrees have been considered Let s fill the array with except Let s start a loop with parameter from to and the internal one with parameter from to In every step we can either take a vertex from th subtree or take nothing If we take a vertex from the subtree it s possible only if then we have ways to select vertices considering subtrees so that the last vertex belongs to the th subtree This value we must add to that must contain all ways to select vertices from subtrees If we ignore the subtree the number of ways to select vertices from subtrees ignoring the th subtree is It must be added to the number of ways to select vertices from subtrees The answer for the current and the current layer of equidistant vertices is The answer for the whole tree is the sum of the answers for all and for all layers of equidistant vertices Remember that all arithmetical operations must be done modulo The number of possible central vertices is For every central vertex and every layer we perform two actions recalculate the array and calculate the number of the corresponding sets using the concept of dynamic programming The recalculation of works in it s just BFS starting from so for every central vertex it works in O n The dynamic programming for the current and the current layer works in for the current and all layers in The summary time corresponding to the current is The total algorithm work time is The sum of all is a total number of the adjacent vertices to all vertices it s just a double number of edges So the total work time is 
https://codeforces.com//contest/1633/problem/A,1280033,A,1633A,1633,A. Div. 7,You are given an integer n You have to change the minimum number of digits in it in such a way that the resulting number and If there are multiple ways to do it print any of them If the given number is already divisible by 7 leave it unchanged ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    if (n % 7 == 0) {\n        std::cout << n << ""\\n"";\n    } else {\n        n -= n % 10;\n        n += 9;\n        n -= n % 7;\n        std::cout << n << ""\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,['brute force'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Div. 7.json,https://codeforces.com//blog/entry/99539,A lot of different solutions can be written in this problem The model solution relies on the fact that every th integer is divisible by and it means that there is always a way to change the last digit of or leave it unchanged so that the result is divisible by So if is already divisible by we just print it otherwise we change its last digit using some formulas or iteration on its value from to 
https://codeforces.com//contest/404/problem/C,7290,C,404C,404,C. Restore Graph,Valera had an undirected connected graph without self loops and multiple edges consisting of vertices The graph had an interesting property there were at most edges adjacent to each of its vertices For convenience we will assume that the graph vertices were indexed by integers from 1 to One day Valera counted the shortest distances from one of the graph vertices to all other ones and wrote them out in array Thus element of the array shows the shortest distance from the vertex Valera chose to vertex number Then something irreparable terrible happened Valera lost the initial graph However he still has the array Help him restore the lost graph ,"['#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define lx x + x\n#define rx lx + 1\n#define ly y + y\n#define ry ly + 1\ntypedef long long LL;\n\nconst int N = 100005;\nconst int M = 1005;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\ntypedef double DB;\nint n, k, x;\nvector <int> v[N], ans, res;\n\nvoid add(int x, int y){\n    ans.PB(x), res.PB(y);\n}\n\nint main(){\n    scanf(""%d%d"", &n, &k);\n    for (int i = 1; i <= n; i++){\n        scanf(""%d"", &x);\n        v[x].PB(i);\n    }\n    if (v[0].size() != 1){\n        puts(""-1"");\n        return 0;\n    }\n    int cnt = 1;\n    for (int i = 1; i < n; i++){\n        int x = v[i - 1].size();\n        int y = v[i].size();\n        if (!y){\n            puts(""-1"");\n            return 0;\n        }\n        if (i == 1 && y > k){\n            puts(""-1"");\n            return 0;\n        }\n        if (i != 1){\n            if (k == 1 || ((LL)x * (k - 1) < y)){\n                puts(""-1"");\n                return 0;\n            }\n        }\n        for (int j = 0; j < y; j++){\n            if (i == 1) add(v[0][0], v[i][j]); else\n            add(v[i - 1][j / (k - 1)], v[i][j]);\n        }\n        cnt += y;\n        if (cnt == n) break;\n    }\n    cout << ans.size() << endl;\n    for (int i = 0; i < ans.size(); i++)\n        printf(""%d %d\\n"", ans[i], res[i]);\n}\n']",,,"['dfs and similar', 'graphs', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Restore Graph.json,https://codeforces.com/blog/entry/11095,First of all let us notice that it must be only one in Also means that is the vertex from which Valera calculated the distance to the other vertices Let s notice that every vertex with must be adjacent only to the vertices such that Besides there is always must be such neighboor of that Let s build sought graph by adding one vertex to the existing graph We will add vertex in order of increasing their distance to Initially we have one vertex with number in our graph When we add vertex with let s consider such vertices that Let s choose the vertex with minimal degree among them If this value is equal to then there is no solution In other case let s add to our graph and add the edge to the answer If there are no vertices with distance to then the answer is also If everything fine we will get the answer which is tree so the number of edges in it equals 
https://codeforces.com//contest/339/problem/C,3414,C,339C,339,C. Xenia and Weights,Xenia has a set of weights and pan scales Each weight has an integer weight from 1 to 10 kilos Xenia is going to play with scales and weights a little For this she puts weights on the scalepans one by one The first weight goes on the left scalepan the second weight goes on the right scalepan the third one goes on the left scalepan the fourth one goes on the right scalepan and so on Xenia wants to put the total of weights on the scalepans Simply putting weights on the scales is not interesting so Xenia has set some rules First she does not put on the scales two consecutive weights of the same weight That is the weight that goes th should be different from the th weight for any Second every time Xenia puts a weight on some scalepan she wants this scalepan to outweigh the other one That is the sum of the weights on the corresponding scalepan must be strictly greater than the sum on the other pan You are given all types of weights available for Xenia You can assume that the girl has an infinite number of weights of each specified type Your task is to help Xenia lay weights on the scales or to say that it can t be done ,"['#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=2006;\n\nbool f[N][11][11];\nchar buff[111];\nint n;\n\nvoid PRINT(int dep, int cho, int mor) {\n\tint pre=-1;\n\tfor(int i=1; i<=10 && pre==-1; i++)\n\t\tif(f[dep-1][i][cho-mor] && i!=cho) pre=i;\n\tif(dep==1) printf(""%d"", pre);\n\telse PRINT(dep-1, pre, cho-mor);\n\tprintf("" %d"", cho);\n}\n\nint main() {\n\tscanf(""%s%d"", buff, &n);\n\tmemset(f, 0, sizeof f);\n\tfor(int i=1; i<=10; i++) if(buff[i-1]==\'1\') f[0][i][i]=1;\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=1; j<=10; j++) {\n\t\t\tfor(int k=1; k<=10; k++) {\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tfor(int nxt=1; nxt<=10; nxt++) {\n\t\t\t\t\tif(buff[nxt-1]!=\'1\') continue;\n\t\t\t\t\tif(nxt-k<=0) continue;\n\t\t\t\t\tif(nxt==j) continue;\n\t\t\t\t\tf[i+1][nxt][nxt-k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint id1=-1, id2=-1;\n\tfor(int i=1; i<=10 && id1==-1; i++)\n\t\tfor(int j=1; j<=10 && id1==-1; j++) {\n\t\t\tif(f[n-1][i][j]) {\n\t\t\t\tid1=i, id2=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif(id1==-1) {\n\t\tprintf(""NO\\n"");\n\t\treturn 0;\n\t}\n\tprintf(""YES\\n"");\n\tif(n==1) printf(""%d\\n"", id1);\n\telse PRINT(n-1, id1, id2), printf(""\\n"");\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'shortest paths']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Xenia and Weights.json,https://codeforces.com//blog/entry/8725,Tutorial by Fefer Ivan Let s consider the definition of balance Balance is the difference between sum of all weights on the left pan and sum of all weights on the right pan At the beginning balance is equal to 0 Att each step Xenia puts one weight on the pan It means she adds to or substracts from balance integer from 1 to 10 In each odd step the integer is added and in each even step the integer is subtracted From the statement we know that after each step balance must change it sign and must not be equal to 0 So if after some step the absolute value of balance is greater than 10 Xenia can not continue Also it is said in the statement that we can not use two equal weigths in a row To solve the problem let s consider a graph where vertices are tuples of three numbers where is a current balance is a weight used in the previous step and is the number of the current step Arcs of the graph must correspond to Xenias actions described in the statement The solution of the problme is a path from vertex to some vertex where x y are any numbers and is the requared number of steps 
https://codeforces.com//contest/1168/problem/A,349588,A,1168A,1168,A. Increasing by Modulo,Toad Zitz has an array of integers each integer is between 0 and m 1 inclusive The integers are a 1 a 2 ldots a n In one operation Zitz can choose an integer k and k indices i 1 i 2 ldots i k such that 1 leq i 1 i 2 ldots i k leq n He should then change a i j to a i j 1 bmod m for each chosen integer i j The integer m is fixed for all operations and indices Here x bmod y denotes the remainder of the division of x by y Zitz wants to make his array non decreasing with the minimum number of such operations Find this minimum number of operations ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\n#define maxN 323456\nint n, m;\nint a[maxN];\n\nbool check(int c) {\n\tint premin = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] + c < m) {\n\t\t\tif (a[i] + c < premin) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpremin = max(premin, a[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[i] + c - m < premin)\n\t\t\t\tpremin = max(premin, a[i]);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t}\n\tint l = -1, r = m;\n\twhile (l + 1 < r) {\n\t\tint c = (l + r) / 2;\n\t\tif (check(c))\n\t\t\tr = c;\n\t\telse\n\t\t\tl = c;\n\t}\n\tprintf(""%d\\n"", r);\n}']",,,"['binary search', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Increasing by Modulo.json,https://codeforces.com//blog/entry/67241,Let s check that the answer to the problem is x Then for each element you have some interval interval on the circle of remainders modulo m of values that it can be equal to So you need to check that you can pick in each interval some point to make all these values non decrease You can do it with greedy Each time let s take the smallest element from the interval that is at least the previously chosen value And after this let s make the binary search on x So we have the solution in O nlogm 
https://codeforces.com//contest/1327/problem/B,571325,B,1327B,1327,B. Princesses and Princes,The King of Berland Polycarp LXXXIV has n daughters To establish his power to the neighbouring kingdoms he wants to marry his daughters to the princes of these kingdoms As a lucky coincidence there are n other kingdoms as well So Polycarp LXXXIV has enumerated his daughters from 1 to n and the kingdoms from 1 to n For each daughter he has compiled a list of kingdoms princes of which she wanted to marry Polycarp LXXXIV is very busy so he finds a couple for his daughters greedily one after another For the first daughter he takes and marries the daughter to their prince For the second daughter he takes If there are no free princes in the list then the daughter marries nobody and Polycarp LXXXIV proceeds to the next daughter The process ends after the n th daughter For example let there be 4 daughters and kingdoms the lists daughters have are 2 3 1 2 3 4 3 respectively In that case daughter 1 marries the prince of kingdom 2 daughter 2 marries the prince of kingdom 1 daughter 3 marries the prince of kingdom 3 leaving daughter 4 nobody to marry to Actually before starting the marriage process Polycarp LXXXIV has the time to convince one of his daughters that some prince is also worth marrying to Effectively that means that he can add exactly one kingdom to exactly one of his daughter s list Polycarp LXXXIV wants to increase the number of married couples Unfortunately what he doesn t have the time for is determining what entry to add If there is no way to increase the total number of married couples then output that the marriages are already optimal Otherwise find such an entry that the total number of married couples increases if Polycarp LXXXIV adds it If there are multiple ways to add an entry so that the total number of married couples increases then print any of them For your and our convenience you are asked to answer t independent test cases ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint _,n,matl[N],matr[N];\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d"",&n);\n\t\tint cnt=0;\n\t\trep(i,1,n+1) matr[i]=0,matl[i]=0;\n\t\trep(i,1,n+1) {\n\t\t\tint k,x;\n\t\t\tscanf(""%d"",&k);\n\t\t\trep(j,0,k) {\n\t\t\t\tscanf(""%d"",&x);\n\t\t\t\tif (matl[i]||matr[x]) continue;\n\t\t\t\tmatr[x]=1; matl[i]=1; cnt++;\n\t\t\t}\n\t\t}\n\t\tif (cnt==n) {\n\t\t\tputs(""OPTIMAL"");\n\t\t} else {\n\t\t\tint pl=0,pr=0;\n\t\t\trep(i,1,n+1) if (matl[i]==0) pl=i;\n\t\t\trep(i,1,n+1) if (matr[i]==0) pr=i;\n\t\t\tputs(""IMPROVE"");\n\t\t\tprintf(""%d %d\\n"",pl,pr);\n\t\t}\n\t}\n}\n']",,,"['brute force', 'graphs', 'greedy']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Princesses and Princes.json,https://codeforces.com//blog/entry/75147,Simulate the process without adding the new entry For this you can just maintain an array taken i th value of which is true if the i th prince is married and false otherwise Now observe that there are two possible outcomes Every daughter is married the answer is optimal There is a daughter who isn t married That means that there is a free prince as well Marry them to each other because doing that won t affect any other marriages and add a new one to the answer Overall complexity O n m 
https://codeforces.com//contest/1543/problem/E,1038890,E,1543E,1543,E. The Final Pursuit,Finally you have defeated Razor and now you are the Most Wanted street racer Sergeant Cross has sent the full police force after you in a deadly pursuit Fortunately you have found a hiding spot but you fear that Cross and his force will eventually find you To increase your chances of survival you want to tune and repaint your BMW M3 GTR The car can be imagined as a n dimensional hypercube A simple n dimensional hypercube is an undirected unweighted graph built recursively as follows Take two simple n 1 dimensional hypercubes one having vertices numbered from 0 to 2 n 1 1 and the other having vertices numbered from 2 n 1 to 2 n 1 A simple 0 dimensional Hypercube is just a single vertex Add an edge between the vertices i and i 2 n 1 for each 0 leq i 2 n 1 A permuted n dimensional hypercube is formed by permuting the vertex numbers of a simple n dimensional hypercube in any arbitrary manner Examples of a simple and permuted 3 dimensional hypercubes are given below Note that a permuted n dimensional hypercube has the following properties There are exactly 2 n vertices There are exactly n cdot 2 n 1 edges Each vertex is connected to exactly n other vertices There are no self loops or duplicate edges Let s denote the permutation used to generate the permuted n dimensional hypercube representing your car from a simple n dimensional hypercube by P Before messing up the functionalities of the car you want to find this permutation so that you can restore the car if anything goes wrong But the job isn t done yet You have n different colours numbered from 0 to n 1 You want to colour the vertices of this permuted n dimensional hypercube in such a way that for each and every vertex u satisfying 0 leq u 2 n and for each and every colour c satisfying 0 leq c n there is at least one vertex v adjacent to u having a colour c In other words from each and every vertex it must be possible to reach a vertex of any colour by just moving to an adjacent vertex Given the permuted n dimensional hypercube find any valid permutation P and colouring ,"['// Problem: E. The Final Pursuit\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nvector<int> e[65536];\nint vis[65536];\nint id[65536],inv[65536];\nint col[65536];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tint m=n*(1<<(n-1));\n\t\tint N=1<<n;\n\t\tfor(int i=0; i<N; ++i) e[i].clear(),vis[i]=0,id[i]=0;\n\t\tfor(int i=1; i<=m; ++i) \n\t\t{\n\t\t\tint u=read(),v=read();\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tint visc=1;\n\t\tvector<int> cur,nxt;\n#define pb push_back\n\t\tvis[0]=2;\n\t\tint powpowpow2=1;\n\t\tfor(int i:e[0])\n\t\t{\n\t\t\tvis[i]=1,cur.pb(i),id[i]=powpowpow2,++visc;\n\t\t\tpowpowpow2<<=1;\n\t\t}\n\t\twhile(visc!=N)\n\t\t{\n\t\t\tnxt.clear();\n\t\t\tfor(int i:cur) vis[i]=2;\n\t\t\tfor(int i:cur) for(int j:e[i]) if(vis[j]!=2)\n\t\t\t{\n\t\t\t\tid[j]|=id[i];\n\t\t\t\tif(!vis[j]) vis[j]=1,++visc,nxt.pb(j);\n\t\t\t}\n\t\t\tcur=nxt;\n\t\t}\n\t\tfor(int i=0; i<N; ++i) inv[id[i]]=i;\n\t\tfor(int i=0; i<N; ++i) printf(""%d "",inv[i]);\n\t\tputs(""""); \n\t\tint o=n;\n\t\twhile(!(o&1)) o>>=1;\n\t\tif(o!=1) puts(""-1"");\n\t\telse\n\t\t{\n\t\t\tfor(int i=0; i<N; ++i)\n\t\t\t{\n\t\t\t\tint s=0;\n\t\t\t\tfor(int j=0; j<n; ++j) if(i&(1<<j)) s^=j;\n\t\t\t\tcol[inv[i]]=s;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; ++i)\n\t\t\t{\n\t\t\t\tset<int> s;\n\t\t\t\tfor(int j:e[i]) s.insert(col[j]);\n\t\t\t\tassert((int)s.size()==n);\n\t\t\t}\n\t\t\tfor(int i=0; i<N; ++i) printf(""%d "",col[i]);\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['bitmasks', 'constructive algorithms', 'divide and conquer', 'graphs', 'greedy', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The Final Pursuit.json,https://codeforces.com//blog/entry/92582,Tutorial Part 1 Finding the PermutationBefore moving to the solution notice a very important property of simple Dimensional Hypercubes Two vertices and are connected if and only if and differ by exactly one bit in their binary representations The permutation can be found using the following greedy algorithm First assign any arbitrary vertex as This is obvious since all vertices are equivalent Then in the simple Dimensional Hypercube all powers of must be connected to the vertex Moreover these vertices are added only when we are adding another dimension to the cube Since all directions are also equivalent it does not matter in which direction we add a new dimension So we can assign all the vertices connected to in the permuted Dimensional Hypercube as in any arbitrary order Now we will find for the remaining vertices in increasing order of In order to find first find a set of vertices such that and is connected to in the simple Dimensional Hypercube Then find any vertex connected to all the vertices such that in the permuted Dimensional Hypercube and assign I claim that we can never make a wrong choice because we will never have a choice There will only be one such vertex for any Let s prove it ProofConsider two vertices and in the set These vertices will differ by exactly bits in their binary representation Let the bits in which they differ be and Then they will have the form and where represent the same bits Now only two vertices and can be connected to both and Since a permuted Dimensional Hypercube is isomorphic to a simple Dimensional Hypercube there will only be two vertices connected to both and in the permuted Dimensional Hypercube also If we iterate over in increasing order then otherwise one of or will be greater than which is a contradiction So the only vertices connected to both and will have the forms and Now since and has already been calculated and so one of the vertex connected to both and in the permuted Dimensional Hypercube has already been used So we are left with only one choice for such a vertex Alternate method of finding the permutation by mshiladityam Let s call the vertex connected to a given vertex and which is in the opposite constituent smaller hypercube the image of the given vertex Lemma if there is an edge in the Dimensional hypercube where vertices and lie in different constituent Dimensional Hypercubes in other words and are images of each other then for all vertices adjacent to the image of is adjacent to This lemma can be proved by using the fact that two vertex are connected if and only if they differ by exactly bit Select any two vertices and They form a starting point we treat them as two vertices in opposite constituents by symmetry we can prove that any pairs can be treated as such Now let us perform multisource BFS with and as source nodes Due to the lemma the nodes which are discovered from first lie in the component of and those which are discovered from first lie in the component of it is easy again to prove it using induction on depth of already discovered vertices So we have separated these two constituent smaller dimension hypercubes Lets call a recursive function on any one of them this recursive function returns a permutation which transforms the permutated hypercube to the simple hypercube Now we find for each vertex in the constituent hypercube whose permutation we just found its image Then we can find the permutation for the other constituent by just adding to the corresponding image Hence we perform the merging process of recursion The time complexity of this approach is 
https://codeforces.com//contest/1841/problem/C,1962592,C,1841C,1841,C. Ranom Numbers,Ranom digits are denoted by uppercase Latin letters from to Moreover the value of the letter is 1 is 10 is 100 is 1000 is 10000 A Ranom number is a sequence of Ranom digits The value of the Ranom number is calculated as follows the values of all digits are summed up but some digits are taken with negative signs a digit is taken with negative sign if there is a digit with a value to the right of it not necessarily immediately after it otherwise that digit is taken with a positive sign For example the value of the Ranom number is 1000 1 1 1 10 1000 100 1 2088 You are given a Ranom number You can change no more than one digit in it Calculate the maximum possible value of the resulting number ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << "" ""; cout << v[i];\n    }\n    cout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\n\nvector<int> v = { 1,10,100,1000,10000 };\n\nll dp[1 << 18][5][2];\nvoid solve() {\n    string s; cin >> s;\n    reverse(all(s));\n    rep(i, s.size() + 1) {\n        rep(j, 5)rep(k, 2)dp[i][j][k] = -INF;\n    }\n    dp[0][0][0] = 0;\n    rep(i, s.size()) {\n        int c = s[i] - \'A\';\n        rep(j, 5)rep(k, 2) {\n            if (dp[i][j][k]==-INF)continue;\n            rep(ad, 5) {\n                int nj = max(j, ad);\n                int nk = k; if (ad != c)nk++;\n                if (nk > 1)continue;\n                ll val = dp[i][j][k];\n                if (j > ad)val -= v[ad];\n                else val += v[ad];\n                chmax(dp[i + 1][nj][nk], val);\n            }\n        }\n    }\n    ll ans = -INF;\n    rep(j, 5)rep(k, 2)chmax(ans, dp[s.size()][j][k]);\n    cout << ans << ""\\n"";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}']",,,"['brute force', 'dp', 'greedy', 'math', 'strings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Ranom Numbers.json,https://codeforces.com//blog/entry/117262,There are two main solutions to this problem dynamic programming and greedy Reverse the string we were given so that the sign of each digit depends on the maximum digit to the left of it not to the right Then run the following dynamic programming is the maximum value of the number if we considered first characters applied changes to them is either or and the maximum character we encountered so far was can have possible values The transitions are fairly simple when we consider the state we can either leave the current character as it is or if iterate on the replacement for the current character and use the replacement instead then we go to the state with Note that this solution can also work if we can make more than one operation This dynamic programming has states where is the number of different characters and is the maximum number of changes we can make and each state has no more than outgoing transitions In this problem and so this solution easily passes Of course we can try to iterate on every character and check all possible replacements for it but quickly calculating the answer after replacement can be a bit difficult Instead we claim the following it is optimal to consider at most positions to replace the first and the last position of the first and the last position of and so on That way we have only different candidates for the answer and we can check each of them in How to prove that this is enough When we replace a character we either increase or decrease it If we increase a character it s easy to see why it s optimal to try only the first occurrence of each character increasing a character may affect some characters to the left of it turn them from positive to negative and by picking the first occurrence of a character we make sure that the number of characters transformed from positive to negative is as small as possible Note that if the string has at least one character different from we can replace the first such character with and increase the answer by at least this will be useful in the second part of the proof Now suppose it s optimal to decrease a character let s show that it s always optimal to choose the last occurrence of a character to decrease Suppose we decreased a character and it was not the last occurrence This means that this character will be negative after replacement so it should be negative before the replacement The maximum value we can add to the answer by replacing a negative character with another negative character is changing negative to negative and we have already shown that we can add at least by replacing the first non character in the string with So if we decrease a character and it was not the last occurrence of that character it s suboptimal 
https://codeforces.com//contest/1272/problem/D,494356,D,1272D,1272,D. Remove One Element,You are given an array a consisting of n integers You can remove element from this array Thus the final length of the array is n 1 or n Your task is to calculate the maximum possible length of the contiguous subarray of the remaining array Recall that the contiguous subarray a with indices from l to r is a l dots r a l a l 1 dots a r The subarray a l dots r is called strictly increasing if a l a l 1 dots a r ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n;\nint a[N], l[N], r[N];\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    for (int i = 1; i <= n; i++)\n        l[i] = (a[i] > a[i - 1] ? l[i - 1] + 1 : 1);\n    for (int i = n; i >= 1; i--)\n        r[i] = (a[i] < a[i + 1] ? r[i + 1] + 1 : 1);\n    int res = 0;\n    for (int i = 1; i <= n; i++)\n        res = max(res, max(l[i], r[i]));\n    for (int i = 2; i < n; i++)\n        if (a[i - 1] < a[i + 1])\n            res = max(res, l[i - 1] + r[i + 1]);\n    cout << res;\n}\n']",,,"['brute force', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Remove One Element.json,https://codeforces.com//blog/entry/72132,Firstly let s calculate for each from to two following values and means the maximum length of the increasing sequence starting in the position and means the maximum length of the increasing sequence ending in the position Initially all values are the element itself The array can be calculated in order from right to left with the following condition if then otherwise it still remain The same with the array but we have to calculate its values in order from left to right and if then otherwise it still remain Having these arrays we can calculate the answer The initial answer if we don t remove any element is the maximum value of the array And if we remove the th element where then we can update the answer with the value if Time complexity 
https://codeforces.com//contest/803/problem/F,104511,F,803F,803,F. Coprime Subsequences,Let s call a non empty sequence of positive integers if the greatest common divisor of all elements of this sequence is equal to Given an array consisting of positive integers find the number of its subsequences Since the answer may be very large print it modulo Note that two subsequences are considered different if chosen indices are different For example in the array there are different subsequences and ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y)\n{\n    x += y;\n    if (x >= MOD) return x - MOD;\n    return x;\n}\nll sub(ll x, ll y)\n{\n    x -= y;\n    if (x < 0) return x + MOD;\n    return x;\n}\nll mult(ll x, ll y)\n{\n    return (x * y) % MOD;\n}\n\nconst int N = 100100;\nll a[N];\nll mu[N];\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    for (int i = 1; i < N; i++)\n        a[i] = 1;\n\n    int n;\n    scanf(""%d"", &n);\n    while(n--)\n    {\n        int x;\n        scanf(""%d"", &x);\n        a[x] = add(a[x], a[x]);\n    }\n    for (int x = 1; x < N; x++)\n        for (int y = 2 * x; y < N; y += x)\n            a[x] = mult(a[x], a[y]);\n\n    mu[1] = 1;\n    for (int x = 1; x < N; x++)\n        for (int y = 2 * x; y < N; y += x)\n            mu[y] = sub(mu[y], mu[x]);\n\n    ll ans = 0;\n    for (int i = 1; i < N; i++)\n        ans = add(ans, mult(mu[i], sub(a[i], 1)));\n    printf(""%lld\\n"", ans);\n\n    return 0;\n}\n']",,,"['bitmasks', 'combinatorics', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Coprime Subsequences.json,https://codeforces.com//blog/entry/51768,This problem can be solved using inclusion exclusion Let be the number of subsequences such that all elements of the subsequence are divisible by We can calculate which is the number of elements divisible by by factorizing all elements of the sequence and generating their divisors and Then we can apply the inclusion exclusion principle and get the resulting formula where is the M bius function 
