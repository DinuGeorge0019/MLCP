problem_link,problem_name,problem_statement,problem_solution,tags,dificulty
https://codeforces.com//contest/1041/problem/D,D. Glider,A plane is flying at a constant height of h meters above the ground surface Let s consider that it is flying from the point 10 9 h to the point 10 9 h parallel with Ox axis A glider is inside the plane ready to start his flight at any moment for the sake of simplicity let s consider that he may start only when the plane s coordinates are integers After jumping from the plane he will fly in the same direction as the plane parallel to Ox axis covering a unit of distance every second Naturally he will also descend thus his second coordinate will decrease by one unit every second There are ascending air flows on certain segments each such segment is characterized by two numbers x 1 and x 2 x 1 x 2 representing its endpoints No two segments share any common points When the glider is inside one of such segments he doesn t descend so his second coordinate stays the same each second The glider still flies along Ox axis covering one unit of distance every second Determine the maximum distance along Ox axis from the point where the glider s flight starts to the point where his flight ends if the glider can choose any integer coordinate to jump from the plane and start his flight After touching the ground the glider stops altogether so he cannot glide through an ascending airflow segment if his second coordinate is 0 ,"['#include<bits/stdc++.h>\nusing namespace std;\nint s[200009];\nint l[200009];\nint r[200009];\nmain(){\n    int n, h;\n    cin >> n >> h;\n    vector<pair<int,int> > v;\n    for(int i = 0; i < n; i++){\n        int a, b;\n        cin >>a >> b;\n        v.push_back({a, b});\n    }\n    sort(v.begin(),v .end());\n\n    for(int i = 1; i <= n; i++){\n        l[i] =  v[i - 1].first;\n        r[i] =  v[i - 1].second;\n    }\n    for(int i = 1; i <= n; i++){\n        s[i] = s[i - 1] +r[i] - l[i];\n    }\n    int ans = 0;\n    for(int i = 1; i <= n; i++){\n        int lo = i, hi = n;\n        while(lo < hi){\n            int mid = (lo + hi + 1)/2;\n            if(r[mid] - l[i] < s[mid] - s[i - 1] + h)\n                lo = mid;\n            else hi = mid - 1;\n        }\n        ans = max(ans, h + s[lo] - s[i - 1]);\n\n    }\n    cout << ans <<endl;\n\n\n}\n']","['binary search', 'data structures', 'two pointers']",1700
https://codeforces.com//contest/533/problem/D,D. Landmarks,We have an old building with columns in a row These columns support the ceiling These columns are located in points with coordinates The leftmost and the rightmost columns are special we will call them the other columns are For each column we know its durability Let s consider an ordinary column with coordinate Let s assume that the coordinate of the closest to it column to the left bearing or ordinary is and the coordinate of the closest to it column to the right also bearing or ordinary is In this task let s assume that this column supports the segment of the ceiling from point to point here both fractions are considered as real division If the length of the segment of the ceiling supported by the column exceeds then the column cannot support it and it crashes after a while and after that the load is being redistributeed between the neighbouring columns according to the same principle Thus ordinary columns will be crashing for some time until the process stops at some state One can prove that the set of the remaining columns doesn t depend on the order in which columns crash If there are only two bearing columns left in the end then we assume that the whole construction crashes under the weight of the roof But if at least one ordinary column stays in addition to the bearing ones then the building doesn t crash To make the building stronger we can add one extra ordinary column of arbitrary durability at any not necessarily integer point If point is already occupied by an ordinary column it is replaced by a new one Your task is to find out what minimal durability can the added column have so that the building doesn t crash ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N; // 0 and N are strong\nll X;\nll x[100010],r[100010],l[100010];\nll d[100010];\nbool broken[100010];\n\nint sz;\nint id[100010];\n\nll func(void){\n    int i,j;\n    \n    r[0] = l[N] = X;\n//  for(i=0;i<=N;i++) cout << x[i] << \' \' << l[i] << \' \' << r[i] << endl;\n    \n    for(i=1;i<N;i++){\n        if(x[i] + r[i] >= X) return 0;\n        if(x[i] - l[i] <= 0) return 0;\n    }\n    \n    ll ans = INF;\n//  REP(i,N+1) REP(j,N+1) if(i < j && x[i] + r[i] >= x[j] - l[j]) ans = min(ans, x[j] - x[i]);\n\n    sz = 0;\n\n    for(j=1;j<=N;j++){\n        i = j - 1;\n        if(r[i] != 0){\n            while(1){\n                if(sz == 0) break;\n                int p = id[sz-1];\n                if(x[p] + r[p] > x[i] + r[i]) break;\n                sz--;\n            }\n            id[sz] = i;\n            sz++;\n        }\n        \n        if(l[j] != 0){\n            int low = 0, high = sz;\n            while(high - low > 1){\n                int mid = (low + high) / 2;\n                int p = id[mid];\n                if(x[p] + r[p] >= x[j] - l[j]) low = mid; else high = mid;\n            }\n            int q = id[low];\n            ans = min(ans, x[j] - x[q]);\n        }\n    }\n    \n    return ans;\n}\n\nint st[100010];\n\nvoid calc_r(void){\n    int i;\n    \n    sz = 1;\n    st[0] = 0;\n    \n    for(i=1;i<N;i++){\n        while(1){\n            if(sz < 2) break;\n            int p = st[sz-2], q = st[sz-1];\n            if(2 * d[q] >= x[i] - x[p]) break;\n            sz--;\n        }\n        r[i] = 2 * d[i] - (x[i] - x[st[sz-1]]);\n        if(r[i] <= 0) r[i] = 0;\n        st[sz] = i;\n        sz++;\n    }\n}\n\nvoid calc_l(void){\n    int i;\n    \n    sz = 1;\n    st[0] = N;\n    \n    for(i=N-1;i>=1;i--){\n        while(1){\n            if(sz < 2) break;\n            int p = st[sz-2], q = st[sz-1];\n            if(2 * d[q] >= x[p] - x[i]) break;\n            sz--;\n        }\n        l[i] = 2 * d[i] - (x[st[sz-1]] - x[i]);\n        if(l[i] <= 0) l[i] = 0;\n        st[sz] = i;\n        sz++;\n    }\n}\n\nint main(void){\n    int i;\n    \n    cin >> N;\n    REP(i,N+2){\n        int tmp;\n        scanf(""%d"", &tmp);\n        x[i] = tmp;\n    }\n    for(i=1;i<=N;i++){\n        int tmp;\n        scanf(""%d"", &tmp);\n        d[i] = tmp;\n    }\n    N++;\n    X = x[N];\n    \n    calc_r();\n    calc_l();\n    \n    ll ans = func();\n    printf(""%.9f\\n"", ans / 2.0);\n    \n    return 0;\n}\n']","['data structures', 'dp']",3000
https://codeforces.com//contest/61/problem/A,A. Ultra-Fast Mathematician,Shapur was an extremely gifted student He was great at everything including Combinatorics Algebra Number Theory Geometry Calculus etc He was not only smart but extraordinarily fast He could manage to sum numbers in a single second One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him As a result he made a very great contest and asked every one to come and take part In his contest he gave the contestants many different pairs of numbers Each number is made from digits or The contestants should write a new number corresponding to the given pair of numbers The rule is simple The th digit of the answer is if and only if the th digit of the two given numbers differ In the other case the th digit of the answer is Shapur made many numbers and first tried his own speed He saw that he can perform these operations on numbers of length length of a number is number of digits in it in a glance He always gives correct answers so he expects the contestants to give correct answers too He is a good fellow so he won t give anyone very big numbers and he always gives one person numbers of same length Now you are going to take part in Shapur s contest See if you are faster and more accurate ,"['# include <cstdio>\n\nchar inp1[101],inp2[101];\n\nint main()\n{\n\tscanf(""%s%s"",inp1,inp2);\n\tfor(int i=0;inp1[i];i++)\n\t\tif(inp1[i]==inp2[i])\n\t\t\tprintf(""0"");\n\t\telse\n\t\t\tprintf(""1"");\n\tprintf(""\\n"");\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/479/problem/B,B. Towers,As you know all the kids in Berland love playing with cubes Little Petya has towers consisting of cubes of the same size Tower with number consists of cubes stacked one on top of the other Petya defines the of a set of towers as a value equal to the difference between the heights of the highest and the lowest of the towers For example if Petya built five cube towers with heights 8 3 2 6 3 the instability of this set is equal to 6 the highest tower has height 8 the lowest one has height 2 The boy wants the instability of his set of towers to be as low as possible All he can do is to perform the following operation several times take the top cube from some tower and put it on top of some other tower of his set Please note that Petya would never put the cube on the same tower from which it was removed because he thinks it s a waste of time Before going to school the boy will have time to perform no more than such operations Petya does not want to be late for class so you have to help him accomplish this task ,"['#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<cstring>\n#define rep(i,a,b) for (int i=a;i<=b;++i)\n#define dep(i,a,b) for (int i=a;i>=b;--i)\n#define For(i,u) for (int i=H[u];i;i=nxt[i])\n#define re(i,x) for (i=x.begin();i!=x.end();++i)\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 100005\nusing namespace std;\ntemplate<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c==\'-\')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-\'0\';if(fu)x=-x;};\ntemplate<class T> inline void read(T&x,T&y){read(x);read(y);}\ntemplate<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct S{int x,id;} a[N];\n//head\nint n,k;\nbool cmp(S a,S b) {return a.x<b.x;}\nstruct ass{int x,y;} q[N];int ans[N];\nint main() {\n\tread(n,k);rep(i,1,n)read(a[i].x),a[i].id=i;\n\tsort(a+1,a+n+1,cmp);ans[0]=a[n].x-a[1].x;\n\trep(i,1,k) {\n\t\tsort(a+1,a+n+1,cmp);\n\t\ta[1].x++;a[n].x--;q[i].y=a[1].id;q[i].x=a[n].id;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tans[i]=a[n].x-a[1].x;\n\t}\n\tint pos=0,mx=ans[0];\n\trep(i,1,k) if (ans[i]<mx) mx=ans[i],pos=i;\n\tprintf(""%d %d\\n"",mx,pos);\n\trep(i,1,pos) printf(""%d %d\\n"",q[i].x,q[i].y);\n\treturn 0;\n}']","['brute force', 'constructive algorithms', 'greedy', 'implementation', 'sortings']",1400
https://codeforces.com//contest/1689/problem/D,D. Lena and Matrix,As a gift for her birthday Lena got a matrix puzzle The matrix consists of n rows and m columns and each cell is either black or white The coordinates i j denote the cell which belongs to the i th row and j th column for every 1 leq i leq n and 1 leq j leq m To solve the puzzle Lena has to choose a cell that minimizes the Manhattan distance to the farthest black cell from the chosen cell More formally let there be k ge 1 black cells in the matrix with coordinates x i y i for every 1 leq i leq k Lena should choose a cell a b that minimizes max i 1 k a x i b y i As Lena has no skill she asked you for help Will you tell her the optimal cell to choose ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        vector<vector<char>> a(n, vector<char>(m));\n        int ans = INF, x = -1, y = -1;\n        int mx[4] = {-INF, -INF, -INF, -INF};\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> a[i][j];\n                if (a[i][j] == \'B\') {\n                    mx[0] = max(mx[0], -i - j);\n                    mx[1] = max(mx[1], -i + j);\n                    mx[2] = max(mx[2], i - j);\n                    mx[3] = max(mx[3], i + j);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int val = -INF;\n                val = max(val, mx[0] + i + j);\n                val = max(val, mx[1] + i - j);\n                val = max(val, mx[2] - i + j);\n                val = max(val, mx[3] - i - j);\n                if (val < ans) {\n                    ans = val;\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n        cout << x + 1 << "" "" << y + 1 << endl;\n    }\n    return 0;\n}']","['data structures', 'dp', 'geometry', 'shortest paths']",1900
https://codeforces.com//contest/546/problem/A,A. Soldier and Bananas,A soldier wants to buy bananas in the shop He has to pay dollars for the first banana dollars for the second one and so on in other words he has to pay dollars for the th banana He has dollars How many dollars does he have to borrow from his friend soldier to buy bananas ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\nint main(){\n    long long k,n,w;\n    cin >> k >> n >> w;\n    cout << max(0LL,w*(w+1)/2*k-n) << endl;\n}']","['brute force', 'implementation', 'math']",800
https://codeforces.com//contest/1293/problem/A,A. ConneR and the A.R.C. Markland-N,A R C Markland N is a tall building with n floors numbered from 1 to n Between each two adjacent floors in the building there is a staircase connecting them It s lunchtime for our sensei Colin ConneR Neumann Jr and he s planning for a location to enjoy his meal ConneR s office is at floor s of the building On each floor including floor s of course there is a restaurant offering meals However due to renovations being in progress k of the restaurants are currently closed and as a result ConneR can t enjoy his lunch there CooneR wants to reach a restaurant as quickly as possible to save time What is the minimum number of staircases he needs to walk to reach a closest currently open restaurant Please answer him quickly and you might earn his praise and even enjoy the lunch with him in the elegant Neumanns way ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    int ntest;\n    cin >> ntest;\n    while (ntest--) {\n        int n, s, k, x;\n        cin >> n >> s >> k;\n        set <int> ss;\n        for (int i = 1; i <= k; ++i) cin >> x, ss.insert(x);\n        int ans = 0;\n        while (true) {\n            if (s + ans <= n && ss.find(s + ans) == ss.end()) break;\n            if (s - ans >= 1 && ss.find(s - ans) == ss.end()) break;\n            ++ans;\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n""]","['binary search', 'brute force', 'implementation']",1100
https://codeforces.com//contest/1389/problem/B,B. Array Walk,You are given an array a 1 a 2 dots a n consisting of n integers Initially you are standing at index 1 and have a score equal to a 1 You can perform two kinds of moves move right go from your current index x to x 1 and add a x 1 to your score This move can only be performed if x n move left go from your current index x to x 1 and add a x 1 to your score This move can only be performed if x 1 You want to perform k moves Also there should be no more than z moves to the left among them What is the maximum score you can achieve ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int INF = (int)1e9 + (int)1e8;\nconst int N = 100100;\nconst int K = 7;\nint n, m, k;\nint a[N];\nint dp[N][K][2];\n\nvoid solve() {\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tfor (int i = 0; i <= m; i++)\n\t\tfor (int j = 0; j <= k; j++)\n\t\t\tfor (int h = 0; h < 2; h++)\n\t\t\t\tdp[i][j][h] = -INF;\n\tdp[0][0][0] = a[0];\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int x = 0; x <= k; x++)\n\t\t\tfor (int f = 0; f < 2; f++) {\n\t\t\t\tif (dp[i][x][f] == -INF) continue;\n\t\t\t\tfor (int g = 0; g < 2; g++) {\n\t\t\t\t\tif (f & g) continue;\n\t\t\t\t\tif (x + g > k) continue;\n\t\t\t\t\tint pos = i + 1 - 2 * (x + g);\n\t\t\t\t\tif (pos < 0 || pos >= n) continue;\n\t\t\t\t\tdp[i + 1][x + g][g] = max(dp[i + 1][x + g][g], dp[i][x][f] + a[pos]);\n\t\t\t\t}\n\t\t\t}\n\tint ans = -INF;\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tans = max(ans, dp[m][i][j]);\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['brute force', 'dp', 'greedy']",1600
https://codeforces.com//contest/1359/problem/D,D. Yet Another Yet Another Task,Alice and Bob are playing yet another card game This time the rules are the following There are n cards lying in a row in front of them The i th card has value a i First Alice chooses a non empty consecutive segment of cards l r l le r After that Bob removes a single card j from that segment l le j le r The score of the game is the total value of the remaining cards on the segment a l a l 1 dots a j 1 a j 1 dots a r 1 a r In particular if Alice chooses a segment with just one element then the score after Bob removes the only card is 0 Alice wants to make the score as big as possible Bob takes such a card that the score is as small as possible What segment should Alice choose so that the score is maximum possible Output the maximum score ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 1e5 + 10;\nint a[maxN];\nint n;\nint pref[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    int best = 0;\n    vector < pair < int, int > > all;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        pref[i] = pref[i - 1] + a[i];\n        for (auto& it : all) {\n            it.first = max(it.first, a[i]);\n        }\n        all.emplace_back(a[i], pref[i - 1]);\n        sort(all.begin(), all.end());\n        map < int, int > mp;\n        for (auto& it : all) {\n            if (!mp.count(it.first)) mp[it.first] = it.second;\n            else mp[it.first] = min(mp[it.first], it.second);\n        }\n        all.clear();\n        for (auto& it : mp) {\n            all.emplace_back(it);\n            best = max(best, pref[i] - it.second - it.first);\n        }\n    }\n    cout << best;\n    return 0;\n}']","['data structures', 'dp', 'implementation', 'two pointers']",2000
https://codeforces.com//contest/1676/problem/G,G. White-Black Balanced Subtrees,You are given a rooted tree consisting of n vertices numbered from 1 to n The root is vertex 1 There is also a string s denoting the color of each vertex if s i texttt B then vertex i is black and if s i texttt W then vertex i is white A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices Count the number of balanced subtrees A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the In this problem all trees have root 1 The tree is specified by an array of parents a 2 dots a n containing n 1 numbers a i is the parent of the vertex with the number i for all i 2 dots n The parent of a vertex u is a vertex that is the next vertex on a simple path from u to the root The of a vertex u is the set of all vertices that pass through u on a simple path to the root For example in the picture below 7 is in the subtree of 3 because the simple path 7 to 5 to 3 to 1 passes through 3 Note that a vertex is included in its subtree and the subtree of the root is the entire tree The picture shows the tree for n 7 a 1 1 2 3 3 5 and s texttt WBBWWBW The subtree at the vertex 3 is balanced ,"[""#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 4040;\n\nint a[N];\nvector<int> edges[N];\nstring s;\nint ans;\nint f[N];\n\nvoid dfs(int x)\n{\n\tf[x] = 0;\n\tif(s[x - 1] == 'B')\n\t\tf[x] ++;\n\telse\n\t\tf[x] --;\n\tfor(auto &y : edges[x])\n\t{\n\t\tdfs(y);\n\t\tf[x] += f[y];\n\t}\n\t\n\tans += !f[x];\n}\n\nint main()\n{\n\tint t;\n\tint n;\n\tint i;\n\t\n\tcin >> t;\n\twhile(t --)\n\t{\n\t\tcin >> n;\n\t\tfor(i = 1; i <= n; i ++)\n\t\t\tedges[i].clear();\n\t\tfor(i = 2; i <= n; i ++)\n\t\t\tcin >> a[i];\n\t\tfor(i = 2; i <= n; i ++)\n\t\t\tedges[a[i]].push_back(i);\n\t\tcin >> s;\n\t\t\n\t\tans = 0;\n\t\tdfs(1);\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n""]","['dfs and similar', 'dp', 'graphs', 'trees']",1300
https://codeforces.com//contest/1322/problem/C,C. Instant Noodles,Wu got hungry after an intense training session and came to a nearby store to buy his favourite instant noodles After Wu paid for his purchase the cashier gave him an interesting task You are given a bipartite graph with positive integers in all vertices of the half For a subset S of vertices of the half we define N S as the set of all vertices of the right half adjacent to at least one vertex in S and f S as the sum of all numbers in vertices of N S Find the greatest common divisor of f S for all possible non empty subsets S assume that GCD of empty set is 0 Wu is too tired after his training to solve this problem Help him ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=500005;\nint n,m;\nll val[N],hsh[N];\npll a[N];\nll rnd(){\n\tll x=0;\n\tFor(i,1,18)\n\t\tx=x*10+rand()%10;\n\treturn x;\n}\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid solve(){\n\tscanf(""%d%d"",&n,&m);\n\tFor(i,1,n) scanf(""%lld"",&a[i].se);\n\tFor(i,1,n) val[i]=rnd(),hsh[i]=0;\n\tFor(i,1,m){\n\t\tint x,y;\n\t\tscanf(""%d%d"",&x,&y);\n\t\thsh[y]^=val[x];\n\t}\n\tFor(i,1,n) a[i].fi=hsh[i];\n\tsort(a+1,a+n+1);\n\tll ans=0,s=a[1].se;\n\tFor(i,2,n+1){\n\t\tif (i==n+1||a[i].fi!=a[i-1].fi){\n\t\t\tif (a[i-1].fi)\n\t\t\t\tans=gcd(ans,s);\n\t\t\ts=0;\n\t\t}\n\t\ts+=a[i].se;\n\t}\n\tprintf(""%lld\\n"",ans);\n}\nint main(){\n\tsrand(time(NULL));\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n} ']","['graphs', 'hashing', 'math', 'number theory']",2300
https://codeforces.com//contest/518/problem/B,B. Tanya and Postcard,Little Tanya decided to present her dad a postcard on his Birthday She has already created a message string of length consisting of uppercase and lowercase English letters Tanya can t write yet so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string The newspaper contains string consisting of uppercase and lowercase English letters We know that the length of string greater or equal to the length of the string The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters That s why Tanya wants to cut some letters out of the newspaper and make a message of length exactly so that it looked as much as possible like If the letter in some position has correct value and correct letter case in the string and in the string that Tanya will make then she shouts joyfully and if the letter in the given position has only the correct value but it is in the wrong case then the girl says Tanya wants to make such message that lets her shout as much as possible If there are multiple ways to do this then her second priority is to maximize the number of times she says Your task is to help Tanya make the message ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nchar op(char c)\n{\n    if (islower(c))return toupper(c);\n    return tolower(c);\n}\nint c[211]={0},o[555555]={0};\nint main()\n{\n    int i,j,k;\n    string s,t;\n    cin>>s>>t;\n    for (i=0;i<sz(t);i++)\n    {\n        c[t[i]]++;\n    }\n    int a=0,b=0;\n    for (i=0;i<sz(s);i++)\n    {\n        if (c[s[i]])\n        {\n            o[i]=1;\n            --c[s[i]];\n            ++a;\n        }\n    }\n    for (i=0;i<sz(s);i++)if (o[i]==0)\n    {\n        if (c[op(s[i])])\n        {\n            --c[op(s[i])];\n            ++b;\n        }\n    }\n    printf(""%d %d\\n"",a,b);\n    return 0;\n}\n            ']","['greedy', 'implementation', 'strings']",1400
https://codeforces.com//contest/497/problem/E,E. Subsequences Return,Assume that equals the sum of digits of number in the based notation For example The sequence of integers is defined as Your task is to calculate the number of distinct of sequence Calculate the answer modulo Sequence is called to be a of sequence if there is a sequence of indices such that In particular an empty sequence i e the sequence consisting of zero elements is a subsequence of any sequence ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst ll mod = 1000000007;\n\nstruct Input {\n\tll n;\n\tint k;\n\t\n\tbool read () {\n\t\treturn cin >> n >> k;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tll ans;\n\t\n\tvoid write () {\n\t\tcout << ans << endl;\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tint s;\n\t\n\tve<ve<ll> > mul (const ve<ve<ll> > &a, const ve<ve<ll> > &b) {\n\t\tve<ve<ll> > ans(s, ve<ll>(s, 0));\n\t\tforn (i, s) {\n\t\t\tforn (j, s) {\n\t\t\t\tforn (k, s) {\n\t\t\t\t\t(ans[i][j] += a[i][k] * b[k][j]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tve<ve<ll> > shift (const ve<ve<ll> > &a, int t) {\n\t\tve<ve<ll> > ans(s, ve<ll>(s));\n\t\tforn (i, k) {\n\t\t\tforn (j, k) {\n\t\t\t\tans[(i + t) % k][(j + t) % k] = a[i][j];\n\t\t\t}\n\t\t}\n\t\tforn (i, k) {\n\t\t\tans[k][(i + t) % k] = a[k][i];\n\t\t\tans[(i + t) % k][k] = a[i][k];\n\t\t}\n\t\tans[k][k] = a[k][k];\n\t\treturn ans;\n\t}\n\t\n\tint f (ll n) {\n\t\tint res = 0;\n\t\twhile (n) {\n\t\t\t(res += n % k) %= k;\n\t\t\tn /= k;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid solve () {\n\t\ts = k + 1;\n\t\tve<ve<ll> > a(s, ve<ll>(s, 0));\n\t\tforn (i, s) {\n\t\t\ta[i][i] = 1;\n\t\t}\n\t\ta[0][k] = 1;\n\t\ta[0][0] = 0;\n\t\ta[k][0] = mod - 1;\n\t\ta[k][k] = 2;\n\t\t\n\t\tve<ve<ll> > res(s, ve<ll>(s, 0));\n\t\tforn (i, s) {\n\t\t\tres[i][i] = 1;\n\t\t}\n\t\twhile (n) {\n\t\t\twhile (n % k) {\n\t\t\t\tres = mul(shift(a, f(n - 1)), res);\n\t\t\t\t--n;\n\t\t\t}\n\t\t\tve<ve<ll> > b = a;\n\t\t\tfor (int t = 1; t < k; ++t) {\n\t\t\t\ta = mul(a, shift(b, t));\n\t\t\t}\n\t\t\tn /= k;\n\t\t}\n\t\tdebug(res[k]);\n\t\tans = res[k][k];\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n']","['dp', 'matrices']",2900
https://codeforces.com//contest/1783/problem/G,G. Weighed Tree Radius,You are given a tree of n vertices and n 1 edges The i th vertex has an initial weight a i Let the d v u from vertex v to vertex u be the number of edges on the path from v to u Note that d v u d u v and d v v 0 Let the distance w v u from v to u be w v u d v u a u Note that w v v a v and w v u neq w u v if a u neq a v Analogically to usual distance let s define the e v of vertex v as the greatest weighted distance from v to any other vertex including v itself or e v max limits 1 le u le n w v u Finally let s define the r of the tree as the minimum eccentricity of any vertex or r min limits 1 le v le n e v You need to perform m queries of the following form v j x j assign a v j x j After performing each query print the radius r of the current tree ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class Info,\n    class Merge = std::plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}\n    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n};\n\nconstexpr int inf = 1E9;\n\nstruct Info {\n    std::array<int, 2> sid;\n    int mid;\n    std::array<int, 2> l;\n    std::array<int, 2> r;\n    std::array<int, 3> ans;\n    \n    Info() : sid{-inf, -1}, mid{-inf}, l{-inf, -1}, r{-inf, -1}, ans{-inf, -1, -1} {}\n    Info(int x, int a, int id) : sid{x + a, id}, mid{-2 * x}, l{-x + a, id}, r{-x + a, id}, ans{0, id, id} {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.sid = std::max(a.sid, b.sid);\n    c.mid = std::max(a.mid, b.mid);\n    c.l = std::max({a.l, b.l, std::array{a.sid[0] + b.mid, a.sid[1]}});\n    c.r = std::max({a.r, b.r, std::array{b.sid[0] + a.mid, b.sid[1]}});\n    c.ans = std::max({a.ans, b.ans, std::array{a.l[0] + b.sid[0], a.l[1], b.sid[1]}, std::array{a.sid[0] + b.r[0], a.sid[1], b.r[1]}});\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<int> euler, teul(n), dep(n), parent(n, -1);\n    int tm = 0;\n    \n    auto dfs = [&](auto dfs, int x) -> void {\n        euler.push_back(x);\n        teul[x] = tm++;\n        for (auto y : adj[x]) {\n            if (y == parent[x]) continue;\n            parent[y] = x;\n            dep[y] = dep[x] + 1;\n            dfs(dfs, y);\n            euler.push_back(x);\n            tm++;\n        }\n    };\n    dfs(dfs, 0);\n    \n    std::vector<Info> ini(2 * n - 1);\n    for (int i = 0; i < 2 * n - 1; i++) {\n        int x = euler[i];\n        if (i == teul[x]) {\n            ini[i] = Info(dep[x], a[x], x);\n        } else {\n            ini[i] = Info(dep[x], 0, x);\n        }\n    }\n    SegmentTree<Info> seg(ini);\n    \n    int m;\n    std::cin >> m;\n    \n    while (m--) {\n        int x, y;\n        std::cin >> x >> y;\n        x--;\n        a[x] = y;\n        seg.modify(teul[x], Info(dep[x], a[x], x));\n        \n        auto [d, u, v] = seg.info[1].ans;\n        \n        if (dep[u] + a[u] < dep[v] + a[v]) std::swap(u, v);\n        \n        int ans = std::max({a[u], a[v], (d + 1) / 2});\n        std::cout << ans << ""\\n"";\n    }\n    \n    return 0;\n}']","['data structures', 'divide and conquer', 'implementation', 'trees']",2800
https://codeforces.com//contest/374/problem/B,B. Inna and Nine,Inna loves digit very much That s why she asked Dima to write a small number consisting of nines But Dima must have misunderstood her and he wrote a very large number consisting of digits from to Inna wants to slightly alter the number Dima wrote so that in the end the number contained as many digits nine as possible In one move Inna can choose two adjacent digits in a number which sum equals and replace them by a single digit For instance Inna can alter number like this Also she can use this method to transform number into number Inna will not transform it into as she can get numbers and which contain more digits nine Dima is a programmer so he wants to find out how many distinct numbers containing as many digits nine as possible Inna can get from the written number Help him with this challenging task ,"['/** Micro Mezzo Macro Flation -- Overheated Economy ., Last Update: Feb. 12th 2013 **/ //{\n\n/** Header .. **/ //{\n#define LOCAL\n\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (int n____=(i=0,int(n));i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,int(b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,int(a));i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,int(n));i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=1,int(b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,int(a));i>=a____;--i)\n\n#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, nxt) for (int i=hd;i;i=nxt[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define fi first\n#define se second\n\n#define Rush for(int ____T=RD(); ____T--;)\n\n#define Display(A, n, m) {                      \\\n\tREP(i, n){\t\t                            \\\n        REP(j, m) cout << A[i][j] << "" "";       \\\n        cout << endl;\t\t\t\t            \\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#define Display_1(A, n, m) {\t\t\t\t    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m) cout << A[i][j] << "" "";     \\\n\t\tcout << endl;\t\t            \t\t\\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#pragma comment(linker, ""/STACK:36777216"")\n//#pragma GCC optimize (""O2"")\n#define Ruby system(""ruby main.rb"")\n#define Haskell system(""runghc main.hs"")\n#define Python system(""python main.py"")\n#define Pascal system(""fpc main.pas"")\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf("" %c"", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &x){\n    char c; for (c = getchar(); c < \'-\'; c = getchar());\n    if (c == \'-\'){x = \'0\' - getchar(); for (c = getchar(); \'0\' <= c && c <= \'9\'; c = getchar()) x = x * 10 + \'0\' - c;}\n    else {x = c - \'0\'; for (c = getchar(); \'0\' <= c && c <= \'9\'; c = getchar()) x = x * 10 + c - \'0\';}\n    return x;\n}\n\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline void RDD(const T0&a, const T1&b){RDD(a),RDD(b);}\ntemplate<class T0,class T1,class T2>inline void RDD(const T0&a, const T1&b, const T2&c){RDD(a),RDD(b),RDD(c);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& UNQ(T &A){A.resize(unique(ALL(SRT(A)))-A.begin());return A;}\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\n\nconst int dx8[] = {-1, 0, 1, 0 , -1 , -1 , 1 , 1};\nconst int dy8[] = {0, 1, 0, -1 , -1 , 1 , -1 , 1};\n\nconst int dxhorse[] = {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\nconst int dyhorse[] = {1 ,  -1 , 2  , -2 , 2 ,-2 , 1 ,-1};\n\nconst int MOD = 1000000007;\n//int MOD = 99990001;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 1LL << 60;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = acos(-1.0); //M_PI;\n\n//}\n\n/** Add On .. **/ //{\n// <<= \'0. Nichi Joo ., //{\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (a<b) a=b;}\ntemplate<class T> inline void checkMin(T &a, T &b, const T x){checkMin(a, x), checkMin(b, x);}\ntemplate<class T> inline void checkMax(T &a, T &b, const T x){checkMax(a, x), checkMax(b, x);}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ninline int ceil(int x, int y){return (x - 1) / y + 1;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n// <<= \'1. Bitwise Operation ., //{\nnamespace BO{\n\ninline bool _1(int x, int i){return bool(x&1<<i);}\ninline bool _1(LL x, int i){return bool(x&1LL<<i);}\ninline LL _1(int i){return 1LL<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n\ninline int reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\ninline LL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\ntemplate<class T> inline bool odd(T x){return x&1;}\ntemplate<class T> inline bool even(T x){return !odd(x);}\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\ntemplate<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\ntemplate<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n\ninline int low_idx(int x){return __builtin_ffs(x);}\ninline int low_idx(LL x){return __builtin_ffsll(x);}\ninline int high_idx(int x){return low_idx(reverse_bits(x));}\ninline int high_idx(LL x){return low_idx(reverse_bits(x));}\ninline int clz(int x){return __builtin_clz(x);}\ninline int clz(LL x){return __builtin_clzll(x);}\ninline int ctz(int x){return __builtin_ctz(x);}\ninline int ctz(LL x){return __builtin_ctzll(x);}\ninline int parity(int x){return __builtin_parity(x);}\ninline int parity(LL x){return __builtin_parityll(x);}\ninline int lg2(int a){return 31 - clz(a);}\ninline int lg2(LL a){return 63 - clz(a);}\ninline int count_bits(int x){return __builtin_popcount(x);}\ninline int count_bits(LL x){return __builtin_popcountll(x);}\n\n} using namespace BO;//}\n// <<= \'2. Number Theory .,//{\nnamespace NT{\ninline LL __lcm(LL a, LL b){return a*b/__gcd(a,b);}\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\n\ninline int pow(int a, int b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int pow(int a, LL b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T> inline T pow(T a, LL b){\n    T c(1); while (b){\n        if (b&1) c *= a;\n        a *= a, b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIV(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int phi(int n){\n    int res = n; for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n} using namespace NT;//}\n//}\n\n/** Miscellaneous .. **/ //{\n// <<= \'Random Event .. . //{\nnamespace RNG{\n//srand((unsigned)time(NULL));\ninline unsigned int rand16(){return ((rand()) << 15) ^ rand();}\ninline unsigned int rand32(){return (rand16() << 16) | rand16();}\ninline ULL rand64(){return ((LL)rand32() << 32) | rand32();}\ninline ULL random(LL l, LL r){return l == r ? l : rand64() % (r - l) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return bool(rand() % 2);}\n} using namespace RNG;\n//}\n// <<= \'Clock .. . //{\nnamespace CLOCK{\nDB s0, s1, rd, k, T;\ninline DB getTime(){\n#ifdef LOCAL\n    return 1.0 * clock() / CLOCKS_PER_SEC;\n#else\n    timeval tv;\n    gettimeofday(&tv, 0);\n    return tv.tv_sec + tv.tv_usec * 1e-6;\n#endif\n}\n\ninline void st0(DB _T = 0.98){T = _T, s0 = getTime();}\ninline void st1(DB _k = 1.618){k = _k, s1 = getTime();}\ninline void ed1(){rd = getTime() - s1;}\ninline DB elapsed(){return getTime() - s0;}\ninline bool safe(){return elapsed() + rd * k < T;}\n} //using namespace CLOCK;\n//}\n// <<= \'Temp .. . //{\nnamespace TMP{\ntemplate<class T> PTT operator+(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi + p2.fi, p1.se + p2.se);\n}\n\ntemplate<class T> PTT operator-(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi - p2.fi, p1.se - p2.se);\n}\n\ntemplate<class T> PTT operator*(const PTT &lhs, T k){\n    return PTT(lhs.fi * k, lhs.se * k);\n}\n} using namespace TMP;\n//}\n//}\n\n/** Algorithm    .. */ //{\n// <<= \'-. Math .,//{\nnamespace Math{\n\ttypedef long long typec;\n\t///Lib functions\n\ttypec GCD(typec a, typec b)\n\t{\n\t\treturn b ? GCD(b, a % b) : a;\n\t}\n\ttypec extendGCD(typec a, typec b, typec& x, typec& y)\n\t{\n\t\tif(!b) return x = 1, y = 0, a;\n\t\ttypec res = extendGCD(b, a % b, x, y), tmp = x;\n\t\tx = y, y = tmp - (a / b) * y;\n\t\treturn res;\n\t}\n\t///for x^k\n\ttypec power(typec x, typec k)\n\t{\n\t\ttypec res = 1;\n\t\twhile(k)\n\t\t{\n\t\t\tif(k&1) res *= x;\n\t\t\tx *= x, k >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t///for x^k mod m\n\ttypec powerMod(typec x, typec k, typec m)\n\t{\n\t\ttypec res = 1;\n\t\twhile(x %= m, k)\n\t\t{\n\t\t\tif(k&1) res *= x, res %= m;\n\t\t\tx *= x, k >>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t/***************************************\n\tInverse in mod p^t system\n\t***************************************/\n\ttypec inverse(typec a, typec p, typec t = 1)\n\t{\n\t\ttypec pt = power(p, t);\n\t\ttypec x, y;\n\t    y = extendGCD(a, pt, x, y);\n\t\treturn x < 0 ? x += pt : x;\n\t}\n\t/***************************************\n\tLinear congruence theorem\n\tx = a (mod p)\n\tx = b (mod q)\n\tfor gcd(p, q) = 1, 0 <= x < pq\n\t***************************************/\n\ttypec linearCongruence(typec a, typec b, typec p, typec q)\n\t{\n\t\ttypec x, y;\n\t\ty = extendGCD(p, q, x, y);\n\t\twhile(b < a) b += q / y;\n\t\tx *= b - a, x = p * x + a, x %= p * q;\n\t\tif(x < 0) x += p * q;\n\t\treturn x;\n\t}\n\t/***************************************\n\tprime table\n\tO(n)\n\t***************************************/\n\tconst int PRIMERANGE = 1000000;\n\tint prime[PRIMERANGE + 1];\n\tint mobius[PRIMERANGE + 1];\n\tint getPrime()\n\t{\n\t\tmemset (prime, 0, sizeof (int) * (PRIMERANGE + 1));\n\t\tmemset(mobius , 0 , sizeof(mobius));\n\t\tmobius[1] = 1;\n\t\tfor (int i = 2; i <= PRIMERANGE; i++)\n\t\t{\n\t\t\tif (!prime[i]) prime[++prime[0]] = i , mobius[i] = -1;\n\t\t\tfor (int j = 1; j <= prime[0] && prime[j] <= PRIMERANGE / i; j++)\n\t\t\t{\n\t\t\t\tprime[prime[j]*i] = 1;\n\t\t\t\tif (i % prime[j] == 0) break;\n\t\t\t\telse mobius[i * prime[j]] = -mobius[i];\n\t\t\t}\n\t\t}\n\t\treturn prime[0];\n\t}\n\t/***************************************\n\tget factor of n\n\tO(sqrt(n))\n\tfactor[][0] is prime factor\n\tfactor[][1] is factor generated by this prime\n\tfactor[][2] is factor counter\n\n\tneed: Prime Table\n\t***************************************/\n\t///you should init the prime table before\n\tint factor[100][3], facCnt;\n\tint getFactors(int x)\n\t{\n\t\tfacCnt = 0;\n\t\tint tmp = x;\n\t\tfor(int i = 1; prime[i] <= tmp / prime[i]; i++)\n\t\t{\n\t\t\tfactor[facCnt][1] = 1, factor[facCnt][2] = 0;\n\t\t\tif(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][0] = prime[i];\n\t\t\twhile(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][2]++, factor[facCnt][1] *= prime[i], tmp /= prime[i];\n\t\t\tif(factor[facCnt][1] > 1) facCnt++;\n\t\t}\n\t\tif(tmp != 1)\n\t\t\tfactor[facCnt][0] = tmp, factor[facCnt][1] = tmp, factor[facCnt++][2] = 1;\n\t\treturn facCnt;\n\t}\n\ttypec combinationModP(typec n, typec k, typec p)\n\t{\n\t\tif(k > n) return 0;\n\t\tif(n - k < k) k = n - k;\n\t\ttypec a = 1, b = 1, x, y;\n\t\tint pcnt = 0;\n\t\tfor(int i = 1; i <= k; i++)\n\t\t{\n\t\t\tx = n - i + 1, y = i;\n\t\t\twhile(x % p == 0) x /= p, pcnt++;\n\t\t\twhile(y % p == 0) y /= p, pcnt--;\n\t\t\tx %= p, y %= p, a *= x, b *= y;\n\t\t\tb %= p, a %= p;\n\t\t}\n\t\tif(pcnt) return 0;\n\t\textendGCD(b, p, x, y);\n\t\tif(x < 0) x += p;\n\t\ta *= x, a %= p;\n\t\treturn a;\n\t}\n};//using namespace Math;\n//}\n// <<= \'-. Geo ,.//{\nnamespace Geo{\n\t#define typec double\n    const typec eps=1e-9;\n    int dblcmp(double d){\n        if (fabs(d)<eps)return 0;\n        return d>eps?1:-1;\n    }\n    int sgn(double a) {return a<-eps?-1:a>eps;}\n    inline double sqr(double x){return x*x;}\n    struct Point2D{\n\t\ttypec x,y;\n\t\tPoint2D(){}\n\t\tPoint2D(typec _x,typec _y):x(_x),y(_y){};\n\t\tvoid input(){\n\t\t\tscanf(""%lf%lf"",&x,&y);\n\t\t}\n\t\tvoid output(){\n\t\t\tprintf(""%.2f %.2f\\n"",x,y);\n\t\t}\n\t\tbool operator==(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0&&dblcmp(a.y-y)==0;\n\t\t}\n\t\tbool operator<(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0?dblcmp(y-a.y)<0:x<a.x;\n\t\t}\n\t\ttypec len(){\n\t\t\treturn hypot(x,y);\n\t\t}\n\t\ttypec len2(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tPoint2D operator + (const Point2D &A) const{\n\t\t\treturn Point2D(x + A.x , y + A.y);\n\t\t}\n\t\tPoint2D operator - (const Point2D &A) const{\n\t\t\treturn Point2D(x - A.x , y - A.y);\n\t\t}\n\t\tPoint2D operator * (const typec _x) const{\n\t\t\treturn Point2D(x * _x , y * _x);\n\t\t}\n\t\ttypec operator * (const Point2D &A) const{\n\t\t\treturn x * A.x + y * A.y;\n\t\t}\n\t\ttypec operator ^ (const Point2D &A) const{\n\t\t\treturn x * A.y - y * A.x;\n\t\t}\n\t\tPoint2D operator / (const typec _p) const{\n\t\t\treturn Point2D(x / _p , y / _p);\n\t\t}\n\t\ttypec distance(Point2D p){\n\t\t\treturn hypot(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D add(Point2D p){\n\t\t\treturn Point2D(x+p.x,y+p.y);\n\t\t}\n\t\tPoint2D sub(Point2D p){\n\t\t\treturn Point2D(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D mul(typec b){\n\t\t\treturn Point2D(x*b,y*b);\n\t\t}\n\t\tPoint2D div(typec b){\n\t\t\treturn Point2D(x/b,y/b);\n\t\t}\n\t\ttypec dot(Point2D p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\ttypec det(Point2D p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\ttypec rad(Point2D a,Point2D b){\n\t\t\tPoint2D p=*this;\n\t\t\treturn fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n\t\t}\n\t\tPoint2D trunc(typec r){\n\t\t\ttypec l=len();\n\t\t\tif (!dblcmp(l))return *this;\n\t\t\tr/=l;\n\t\t\treturn Point2D(x*r,y*r);\n\t\t}\n\t\tPoint2D rotleft(){\n\t\t\treturn Point2D(-y,x);\n\t\t}\n\t\tPoint2D rotright(){\n\t\t\treturn Point2D(y,-x);\n\t\t}\n\t\tPoint2D rotate(Point2D p,typec angle)//ÈÆµãpÄæÊ±ÕëÐý×ªangle½Ç¶È\n\t\t{\n\t\t\tPoint2D v=this->sub(p);\n\t\t\ttypec c=cos(angle),s=sin(angle);\n\t\t\treturn Point2D(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n\t\t}\n\t};\n\n\ttypec cross(Point2D a,Point2D b,Point2D c){\n\t\treturn (b.sub(a)).det(c.sub(a));\n\t}\n}using namespace Geo;\n//}\n//}\n\n/** I/O Accelerator Interface .. **/ //{\ntemplate<class T> inline T& RD(T &x){\n    //cin >> x;\n    //scanf(""%d"", &x);\n    char c; for (c = getchar(); c < \'0\'; c = getchar()); x = c - \'0\'; for (c = getchar(); \'0\' <= c && c <= \'9\'; c = getchar()) x = x * 10 + c - \'0\';\n    //char c; c = getchar(); x = c - \'0\'; for (c = getchar(); c >= \'0\'; c = getchar()) x = x * 10 + c - \'0\';\n    return x;\n}\n\ninline DB& RF(DB &x){\n    //cin >> x;\n    scanf(""%lf"", &x);\n    /*char t; while ((t=getchar())==\' \'||t==\'\\n\'); x = t - \'0\';\n    while ((t=getchar())!=\' \'&&t!=\'\\n\'&&t!=\'.\')x*=10,x+=t-\'0\';\n    if (t==\'.\'){DB l=1; while ((t=getchar())!=\' \'&&t!=\'\\n\')l*=0.1,x += (t-\'0\')*l;}*/\n    return x;\n}\n\ninline char* RS(char *s){\n    //gets(s);\n    scanf(""%s"", s);\n    return s;\n}\n\nint Case; template<class T> inline void OT(const T &x){\n    //printf(""Case %d: %d\\n"", ++Case, x);\n    //printf(""%.2lf\\n"", x);\n    //printf(""%d\\n"", x);\n    cout << x << endl;\n}\n//}\n/* .................................................................................................................................. */\n//const int N = 1e6;\n//char a[N];\n//LL f(int x){\n//    if (x % 2 == 0)\n//        return x / 2 + 1;\n//    else return 1;\n//}\n//void solve(){\n//    int n = strlen(a);\n//    LL ans = 1;\n//    int cnt = 1;\n//    for(int i = 1 ; i < n ; ++i){\n//        if (a[i] + a[i - 1] - \'0\' - \'0\' == 9) ++cnt;\n//        else{\n////                LL res = f()\n//            ans *= f(cnt);\n//            cnt = 1;\n//        }\n//    }\n//    ans *= f(cnt);\n//    OT(ans);\n//}\n//int main(){\n////    init();\n//    while(~scanf(""%s"" , a)) solve();\n//}\nconst int N = 100005;\nconst int inf = 1000000005;\nstring s;\nint a[N] , tot = 0;\nint main () {\n//    #ifndef ONLINE_JUDGE\n//        freopen (""input.txt"" , ""r"" , stdin);\n//    #endif\n    cin >> s;\n    if (s.size() == 1) {\n        puts (""1"");\n        return 0;\n    }\n    for (int i = 1 ; i < s.size() ; i ++) {\n        if ((s[i] + s[i - 1] - \'0\' - \'0\') == 9)\n            a[tot ++] = 1;\n        else a[tot ++] = 0;\n    }\n    a[tot ++] = 0;\n    int b = a[0];\n    LL ans = 1LL;\n    for (int i = 1 ; i < tot ; i ++) {\n        if (a[i] == 0) {\n            if (b && b % 2 == 0)\n                ans = ans * 1LL * (b / 2 + 1);\n            b = 0;\n        }\n        else b ++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n\n\n']","['combinatorics', 'greedy']",1500
https://codeforces.com//contest/1151/problem/D,D. Stas and the Queue at the Buffet,During a break in the buffet of the scientific lyceum of the Kingdom of Kremland there was formed a queue of n high school students numbered from 1 to n Initially each student i is on position i Each student i is characterized by two numbers a i and b i of the person i equals the product of a i by the number of people standing to the left of his position add the product b i by the number of people standing to the right of his position Formally the of the student i which is on the position j equals a i cdot j 1 b i cdot n j The director entrusted Stas with the task rearrange the people in the queue so that Although Stas is able to solve such problems this was not given to him He turned for help to you ,"['#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<long long> A(N), B(N);\n\tvector<int> perm(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i] >> B[i];\n\t\tperm[i] = i;\n\t}\n\tsort(perm.begin(), perm.end(), [&](int i, int j) { return A[i] - B[i] > A[j] - B[j]; });\n\tlong long ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tans += A[perm[i]] * i + B[perm[i]] * (N - i - 1);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']","['greedy', 'math', 'sortings']",1600
https://codeforces.com//contest/205/problem/A,A. Little Elephant and Rozdil,The Little Elephant loves Ukraine very much Most of all he loves town Rozdol ukr Rozdil However Rozdil is dangerous to settle so the Little Elephant wants to go to some other town The Little Elephant doesn t like to spend much time on travelling so for his journey he will choose a town that needs minimum time to travel to If there are multiple such cities then the Little Elephant won t go anywhere For each town except for Rozdil you know the time needed to travel to this town Find the town the Little Elephant will go to or print if he stays in Rozdil ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 100009;\nint a[maxn];\nint main()\n{\n    int n, i, mi, cnt, id;\n    while(scanf(""%d"", &n) != EOF)\n    {\n        for(i=0; i<n; ++i) scanf(""%d"", a+i);\n        mi=*min_element(a,a+n);\n        cnt=0;\n        for(i=0; i<n; ++i)\n        {\n            if(a[i]==mi)\n            {\n                id=i;\n                ++cnt;\n            }\n        }\n        if(cnt>1) puts(""Still Rozdil"");\n        else printf(""%d\\n"", id+1);\n    }\n    return 0;\n}\n']","['brute force', 'implementation']",900
https://codeforces.com//contest/1180/problem/A,A. Alex and a Rhombus,While playing with geometric figures Alex has accidentally invented a concept of a in a cell grid is just a square 1 times 1 i e just a cell for all n geq 2 one obtains from a adding all cells which have a common side with it to it look at the picture to understand it better Alex asks you to compute the number of cells in a ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC optimize(3)\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC target(""sse3"",""sse2"",""sse"")\n//#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n//#pragma GCC target(""f16c"")\n//#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n//#pragma GCC diagnostic error ""-fwhole-program""\n//#pragma GCC diagnostic error ""-fcse-skip-blocks""\n//#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n//#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return \'""\' + s + \'""\';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? ""true"" : ""false"");}template <typename A, typename B>string to_string(pair<A, B> p) {return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";}template <typename A>string to_string(A v) {bool first = true;string res = ""{"";for (const auto &x : v) {if (!first) {res += "", "";}first = false;res += to_string(x);}res += ""}"";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << "" "" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == \'-\') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - \'0\';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\n\nnamespace SOLVE {\n    ll f(ll n){\n        if(n == 1){\n            return 1;\n        }else{\n            return 4*(n-1)+f(n-1);\n        }\n    }\n    void main(){\n        ll n;cin>>n;\n        cout<<f(n);\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']","['dp', 'implementation', 'math']",800
https://codeforces.com//contest/1905/problem/E,E. One-X,In this sad world full of imperfections ugly segment trees exist A segment tree is a tree where each node represents a segment and has its number A segment tree for an array of n elements can be built in a recursive manner Let s say function operatorname build v l r builds the segment tree rooted in the node with number v and it corresponds to the segment l r Now let s define operatorname build v l r If l r this node v is a leaf so we stop adding more edges Else we add the edges v 2v and v 2v 1 Let m lfloor frac l r 2 rfloor Then we call operatorname build 2v l m and operatorname build 2v 1 m 1 r So the whole tree is built by calling operatorname build 1 1 n Now Ibti will construct a segment tree for an array with n elements He wants to find the sum of operatorname lca dagger S where S is a non empty subset of Notice that there are exactly 2 n 1 possible subsets Since this sum can be very large output it modulo 998 244 353 dagger operatorname lca S is the number of the least common ancestor for the nodes that are in S ,"['// Problem: E. One-X\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/E\n// Memory Limit: 512 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#pragma GCC optimize(""Ofast,inline,unroll-loops"")\n// #define _GLIBCXX_DEBUG //交题前记得注释掉不然容易T。\n#include<bits/stdc++.h>\n#define File(s) freopen(#s"".in"",""r"",stdin),freopen(#s"".out"",""w"",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<""@""<<__LINE__<<""=""<<(x)<<\'\\n\')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=-2023,M=998244353;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\nauto pow2(ll b){\n\t//todo:光速\n\treturn qpow(2,b%(M-1));\n}\nll calc(ll n){\n\tif(n==0)return 0;\n\tif(n==1)return 1;\n\tll ln=(n+1)/2,rn=n/2;\n\treturn (pow2(ln)+M-1)*ll(pow2(rn)+M-1)%M;\n}\nsigned main(){\n\t//std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tll n=g90;\n\t\tll ans=0,sum=1,sum1=0,cnt=1,cnt1=0;\n\t\tfor(int l=0;;++l){\n\t\t\tans=(ans+sum*calc(n)+sum1*calc(n+1))%M;\n\t\t\tif(n==1){\n\t\t\t\tsum1=sum1*4+cnt1;\n\t\t\t\tans=(ans+sum1*calc(1))%M;\n\t\t\t\tbreak;\n\t\t\t}else if(n&1){\n\t\t\t\tstd::tie(sum,sum1)=std::make_pair(sum*2+cnt,sum*2+sum1*4+cnt1);//(2j)+(2j+1)\n\t\t\t\tstd::tie(cnt,cnt1)=std::make_pair(cnt,cnt+cnt1*2);\n\t\t\t}else{\n\t\t\t\tstd::tie(sum,sum1)=std::make_pair(sum1*2+cnt1+sum*4+cnt,sum1*2);\n\t\t\t\tstd::tie(cnt,cnt1)=std::make_pair(cnt*2+cnt1,cnt1);\n\t\t\t}\n\t\t\t\n\t\t\tsum%=M,sum1%=M;\n\t\t\tn/=2;\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t}();\n}//main()']","['combinatorics', 'dfs and similar', 'dp', 'math', 'trees']",2400
https://codeforces.com//contest/1004/problem/E,E. Sonya and Ice Cream,Sonya likes ice cream very much She eats it even during programming competitions That is why the girl decided that she wants to open her own ice cream shops Sonya lives in a city with n junctions and n 1 streets between them All streets are two way and connect two junctions It is possible to travel from any junction to any other using one or more streets City Hall allows opening shops only on junctions The girl cannot open shops in the middle of streets Sonya has exactly k friends whom she can trust If she opens a shop one of her friends has to work there and not to allow anybody to eat an ice cream not paying for it Since Sonya does not want to skip an important competition she will not work in shops personally Sonya wants all her ice cream shops to form a simple path of the length r 1 le r le k i e to be located in different junctions f 1 f 2 dots f r and there is street between f i and f i 1 for each i from 1 to r 1 The girl takes care of potential buyers so she also wants to minimize the maximum distance between the junctions to the nearest ice cream shop The distance between two junctions a and b is equal to the sum of all the street lengths that you need to pass to get from the junction a to the junction b So Sonya wants to max a min 1 le i le r d a f i where a takes a value of all possible n junctions f i the junction where the i th Sonya s shop is located and d x y the distance between the junctions x and y Sonya is not sure that she can find the optimal shops locations that is why she is asking you to help her to open not more than k shops that will form a simple path and the maximum distance between any junction and the nearest shop would be minimal ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Edge;\n\n#define MAXN 100001\n#define MAXD 17\n#define INF 0x3f3f3f3f\n\nint n, s, p[MAXN], f[MAXN], tot, que[MAXN], dis[MAXN], pre[MAXN], suf[MAXN], Log[MAXN], st[MAXD][MAXN];\nvector<Edge> e[MAXN];\nbool inq[MAXN];\n\nint rmq(int l, int r) {\n\tif(l > r)\n\t\treturn 0;\n\tint d = Log[r - l + 1];\n\treturn max(st[d][l], st[d][r - (1 << d) + 1]);\n}\n\nvoid dfs(int u, int fa) {\n\tf[u] = 0;\n\tfor(auto it : e[u]) {\n\t\tint v = it.first, w = it.second;\n\t\tif(v == fa || inq[v])\n\t\t\tcontinue;\n\t\tdfs(v, u);\n\t\tif(f[u] < f[v] + w) {\n\t\t\tf[u] = f[v] + w;\n\t\t\tp[u] = v;\n\t\t}\n\t}\n}\n\nint main() {\n\tLog[1] = 0;\n\tfor(int i = 2; i < MAXN; ++i)\n\t\tLog[i] = Log[i >> 1] + 1;\n\tscanf(""%d%d"", &n, &s);\n\tfor(int i = 1; i < n; ++i) {\n\t\tint u, v, w;\n\t\tscanf(""%d%d%d"", &u, &v, &w);\n\t\te[u].push_back(make_pair(v, w));\n\t\te[v].push_back(make_pair(u, w));\n\t}\n\tdfs(1, -1);\n\tfor(que[tot++] = 1; f[que[0]]; que[0] = p[que[0]]);\n\tdfs(que[0], -1);\n\tinq[que[0]] = 1;\n\tdis[0] = f[que[0]];\n\tfor(int u = que[0]; f[u]; u = p[u]) {\n\t\tinq[p[u]] = 1;\n\t\tdis[tot] = f[p[u]];\n\t\tque[tot++] = p[u];\n\t}\n\tfor(int i = 0; i < tot; ++i) {\n\t\tdfs(que[i], -1);\n\t\tpre[i] = suf[i] = st[0][i] = f[que[i]];\n\t}\n\tfor(int i = 1; i < tot; ++i)\n\t\tif(pre[i] < pre[i - 1] + dis[i - 1] - dis[i])\n\t\t\tpre[i] = pre[i - 1] + dis[i - 1] - dis[i];\n\tfor(int i = tot - 2; i >= 0; --i)\n\t\tif(suf[i] < suf[i + 1] + dis[i] - dis[i + 1])\n\t\t\tsuf[i] = suf[i + 1] + dis[i] - dis[i + 1];\n\tfor(int d = 1; d < MAXD; ++d)\n\t\tfor(int i = 0; i < tot && i + (1 << d - 1) < tot; ++i)\n\t\t\tst[d][i] = max(st[d - 1][i], st[d - 1][i + (1 << d - 1)]);\n\tint ans = INF;\n\tfor(int i = 0, j = 0; i < tot; ++i)\n\t\tfor(j = j < i ? i : j; j < tot && j - i + 1 <= s; ++j) {\n\t\t\tint tmp = max(max(pre[i], suf[j]), rmq(i + 1, j - 1));\n\t\t\tif(ans > tmp)\n\t\t\t\tans = tmp;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']","['binary search', 'data structures', 'dp', 'greedy', 'shortest paths', 'trees']",2400
https://codeforces.com//contest/1762/problem/C,C. Binary Strings are Fun,A binary string dagger b of odd length m is if b i is the median ddagger of b 1 i S for all indices i 1 leq i leq m For a binary string a of length k a binary string b of length 2k 1 is an of a if b 2i 1 a i for all i such that 1 leq i leq k For example and are of the string String x is not an of string y because x 3 neq y 2 Note that there are 2 k 1 different of a You are given a binary string s of length n Find the sum of the number of over all prefixes of s In other words find sum i 1 n f s 1 i where f x gives number of of string x Since the answer can be quite large you only need to find it modulo 998 244 353 dagger A binary string is a string whose elements are either mathtt 0 or mathtt 1 ddagger For a binary string a of length 2m 1 the median of a is the unique element that occurs at least m times in a S a l r denotes the string of length r l 1 which is formed by the concatenation of a l a l 1 ldots a r in that order ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint fpow(int a,int b)\n{\n    int ans=1;\n    while(b){\n        if(b & 1) ans =1LL*ans*a%mod;\n        a = 1LL*a*a%mod ; b >>= 1;\n    }\n    return ans;\n}\nint t[400005] , rt[400005];\nint C(int a,int b)\n{\n    return 1LL*t[a]*rt[a - b] % mod * rt[b] %mod;\n}\nint c[200005];\nchar s[200005];\nint n;\nvoid solve()\n{\n    scanf(""%d"",&n);t[0] = rt[0] = 1;\n   // for(int i = 1;i <= n*2;i++) t[i] = 1LL*t[i - 1]*i % mod , rt[i] = fpow(t[i],mod-2);\n  //  for(int i = 0;i <= n;i++) c[i] = 1LL*C(i*2 , i) * fpow(i  + 1 , mod - 2) % mod ;\n    scanf(""%s"",s+1);\n    int lst = 1 ,d = 1;\n    int ans = 0;\n    for(int i = 2;i <= n +1;i++) {\n        if(i == n + 1 || s[i] != s[i - 1]){\n            int L = i - lst;\n            ans = (ans + 1LL*(fpow(2 , L) - 1) * d) % mod;\n          //  d = 1LL*d*c[L] % mod;\n         //   printf(""After %d , %d\\n"",i - 1 , ans);\n            lst = i;\n        }\n    }\n    printf(""%d\\n"",ans);\n    return;\n}\nint main() {\n   // freopen(""in.txt"",""r"",stdin);\n    int t;scanf(""%d"",&t);\n    while(t--) solve();\n    return 0;\n}\n']","['combinatorics', 'math']",1400
https://codeforces.com//contest/53/problem/E,E. Dead Ends,Life in Bertown has become hard The city has too many roads and the government spends too much to maintain them There are junctions and two way roads at which one can get from each junction to any other one The mayor wants to close some roads so that the number of roads left totaled to roads and it were still possible to get from each junction to any other one Besides the mayor is concerned with the number of dead ends which are the junctions from which only one road goes There shouldn t be too many or too few junctions Having discussed the problem the mayor and his assistants decided that after the roads are closed the road map should contain exactly dead ends Your task is to count the number of different ways of closing the roads at which the following conditions are met There are exactly roads left It is possible to get from each junction to any other one There are exactly dead ends on the resulting map Two ways are considered different if there is a road that is closed in the first way and is open in the second one ,"['/* \n * File:   E.cpp\n * Author: J_M\n *\n * Created on 2011年1月29日, 上午11:56\n */\n\n#include <cstdlib>\n#include <iostream>\n#include <stdio.h>\nusing namespace std;\n#define two(x) (1<<x)\nint dp[two(10)+5][two(10)+5];\nint n,m,k;\nint e[105][2];\nint main(int argc, char** argv) {\n    cin>>n>>m>>k;\n    for (int i=0;i<m;i++){\n        cin>>e[i][0]>>e[i][1];\n        e[i][0]--; e[i][1]--;\n        int u=two(e[i][0]),v=two(e[i][1]);\n        dp[u|v][u|v]=1;\n    }\n    int res=0;\n    for (int i=0;i<two(n);i++) for (int j=0;j<two(n);j++) if (dp[i][j]){\n        int cnt=0;\n        for (int t=0;t<n;t++) if (two(t) & j)\n            cnt++;\n        if (dp[i][j]>1 && cnt>1)\n            dp[i][j]/=cnt;\n        if (cnt==k && i==two(n)-1)\n            res+=dp[i][j];\n        for (int t=0;t<m;t++){\n            int u=e[t][0],v=e[t][1];\n            int x=i,y=j;\n            if ((i & two(u))!=0 && (i & two(v))==0){\n                x|=two(v);\n                if (y & two(u))\n                    y^=two(u);\n                y|=two(v);\n            }else\n            if ((i & two(u))==0 && (i & two(v))!=0){\n                x|=two(u);\n                if (y & two(v))\n                    y^=two(v);\n                y|=two(u);\n            }else\n                continue;\n            dp[x][y]+=dp[i][j];\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n\n']","['bitmasks', 'dp']",2500
https://codeforces.com//contest/384/problem/B,B. Multitasking,Iahub wants to enhance his multitasking abilities In order to do this he wants to sort arrays simultaneously each array consisting of integers Iahub can choose a pair of distinct indices and Then in each array the values at positions and are swapped only if the value at position is strictly greater than the value at position Iahub wants to find an array of pairs of distinct indices that chosen in order sort all of the arrays in ascending or descending order the particular order is given in input The size of the array can be at most at most pairs Help Iahub find any suitable array ,"['//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname """"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(""%d"" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(""%d"" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint n, m, k;\n\nint main(){\n\t//freopen(fname""in"", ""r"", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << ""\\n"";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << "" "" << j << ""\\n"";\n    \t\telse\t\n    \t\t\tcout << j << "" "" << i << ""\\n"";\n    \t\t\n    \treturn 0;\n}\n']","['greedy', 'implementation', 'sortings', 'two pointers']",1500
https://codeforces.com//contest/632/problem/D,D. Longest Subsequence,You are given array with elements and the number Consider some subsequence of and the value of least common multiple LCM of its elements Denote LCM as Find any longest subsequence of with the value A subsequence of is an array we can get by erasing some elements of It is allowed to erase zero or all elements The LCM of an empty array equals ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MAXN = 1200000;\n\nint n, m;\nint cc[MAXN];\nint a[MAXN];\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(""%d"", a + i);\n\t\tif (a[i] <= m)\n\t\t\t++cc[a[i]];\n\t}\n\tfor (int i = m; i >= 1; --i) {\n\t\tfor (int j = i + i; j <= m; j += i)\n\t\t\tcc[j] += cc[i];\n\t}\n\tpair<int, int> mx = make_pair(0, 1);\n\tfor (int i = 1; i <= m; ++i)\n\t\tmx = max(mx, make_pair(cc[i], i));\n\tint aa = mx.second;\n\tvector<int> ans;\n\tll go = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (aa % a[i] == 0)\n\t\t\tans.push_back(i + 1), go = go * a[i] / __gcd(go, (ll)a[i]);\n\tprintf(""%lld %d\\n"", go, (int)ans.size());\n\tfor (int i = 0; i < (int)ans.size(); ++i)\n\t\tprintf(""%d "", ans[i]);\n\tprintf(""\\n"");\n\treturn 0;\n}\n\n\n']","['brute force', 'math', 'number theory']",2100
https://codeforces.com//contest/229/problem/B,B. Planets,Goa uld Apophis captured Jack O Neill s team again Jack himself was able to escape but by that time Apophis s ship had already jumped to hyperspace But Jack knows on what planet will Apophis land In order to save his friends Jack must repeatedly go through stargates to get to this planet Overall the galaxy has planets indexed with numbers from 1 to Jack is on the planet with index 1 and Apophis will land on the planet with index Jack can move between some pairs of planets through stargates he can move in both directions the transfer takes a positive and perhaps for different pairs of planets unequal number of seconds Jack begins his journey at time 0 It can be that other travellers are arriving to the planet where Jack is currently located In this case Jack has to wait for exactly 1 second before he can use the stargate That is if at time another traveller arrives to the planet Jack can only pass through the stargate at time unless there are more travellers arriving at time to the same planet Knowing the information about travel times between the planets and the times when Jack would not be able to use the stargate on particular planets determine the minimum time in which he can get to the planet with index ,"['/*\n * b.cpp\n *\n *  Created on: 2012-10-1\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <queue>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\nint n, m;\nstruct Edge {\n\tint t, c;\n\tEdge(int _t, int _c) :\n\t\t\tt(_t), c(_c) {\n\t}\n};\nvector<Edge> E[MAX_N];\nint d[MAX_N];\nbool used[MAX_N];\nvector<int> bad[MAX_N];\nconst int INF = ~0U >> 1;\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c);\n\t\t--a, --b;\n\t\tE[a].push_back(Edge(b, c));\n\t\tE[b].push_back(Edge(a, c));\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint k;\n\t\tscanf(""%d"", &k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint t;\n\t\t\tscanf(""%d"", &t);\n\t\t\tbad[i].push_back(t);\n\t\t}\n\t}\n\tfill(d, d + n, INF);\n\td[0] = 0;\n\tpriority_queue<pair<int, int> > que;\n\tque.push(make_pair(-d[0], 0));\n\twhile (!que.empty()) {\n\t\tint u = que.top().second; //arrive time\n\t\tque.pop();\n\t\tif (used[u])\n\t\t\tcontinue;\n\t\tused[u] = true;\n\t\tvector<int>&my = bad[u];\n\t\tint go = d[u];\n\t\tif (!my.empty()) {\n\t\t\twhile (binary_search(my.begin(), my.end(), go)) {\n\t\t\t\t++go;\n\t\t\t}\n\t\t}\n\t\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\t\tif (go + e->c < d[e->t]) {\n\t\t\t\td[e->t] = go + e->c;\n\t\t\t\tque.push(make_pair(-d[e->t], e->t));\n\t\t\t}\n\t\t}\n\t}\n\tif (d[n - 1] == INF)\n\t\tputs(""-1"");\n\telse\n\t\tcout << d[n - 1] << endl;\n\treturn 0;\n}\n']","['binary search', 'data structures', 'graphs', 'shortest paths']",1700
https://codeforces.com//contest/1899/problem/A,A. Game with Integers,Vanya and Vova are playing a game Players are given an integer n On their turn the player can add 1 to the current integer or subtract 1 The players take turns Vanya starts If Vanya s move the integer is divisible by 3 then he wins If 10 moves have passed and Vanya has not won then Vova wins Write a program that based on the integer n determines who will win if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int t;\n        cin >> t;\n        while (t--) {\n                int n;\n                cin >> n;\n                cout << (n % 3 ? ""First\\n"" : ""Second\\n"");\n        }\n}']","['games', 'math', 'number theory']",800
https://codeforces.com//contest/1229/problem/B,B. Kamil and Making a Stream,Kamil likes streaming the competitive programming videos His MeTube channel has recently reached 100 million subscribers In order to celebrate this he posted a video with an interesting problem he couldn t solve yet Can you help him You re given a tree a connected undirected graph consisting of n vertices connected by n 1 edges The tree is rooted at vertex 1 A vertex u is called an of v if it lies on the shortest path between the root and v In particular a vertex is an ancestor of itself Each vertex v is assigned its x v a non negative integer not larger than 10 12 This allows us to define the beauty of a path Let u be an ancestor of v Then we define the beauty f u v as the greatest common divisor of the beauties of all vertices on the shortest path between u and v Formally if u t 1 t 2 t 3 dots t k v are the vertices on the shortest path between u and v then f u v gcd x t 1 x t 2 dots x t k Here gcd denotes the greatest common divisor of a set of numbers In particular f u u gcd x u x u Your task is to find the sum sum u text is an ancestor of v f u v As the result might be too large please output it modulo 10 9 7 Note that for each y gcd 0 y gcd y 0 y In particular gcd 0 0 0 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nconst int N = 100100;\nvector<int> g[N];\nvector<pli> a[N];\nint n;\nll x[N];\n\nvoid dfs(int v, int par) {\n\tif (par != -1) {\n\t\tfor (pli t : a[par]) {\n\t\t\tll y = gcd(t.first, x[v]);\n\t\t\tif (a[v].empty() || a[v].back().first != y) {\n\t\t\t\ta[v].push_back(mp(y, t.second));\n\t\t\t} else {\n\t\t\t\ta[v].back().second += t.second;\n\t\t\t}\n\t\t}\n\t}\n\tif (a[v].empty() || a[v].back().first != x[v]) {\n\t\ta[v].push_back(mp(x[v], 1));\n\t} else {\n\t\ta[v].back().second++;\n\t}\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tdfs(u, v);\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &x[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tll ans = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (pli t : a[v]) {\n\t\t\tans = (ans + t.first * t.second) % MOD;\n\t\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['binary search', 'data structures', 'dfs and similar', 'dp', 'graphs', 'math', 'number theory', 'trees']",2000
https://codeforces.com//contest/1582/problem/G,G. Kuzya and Homework,Kuzya started going to school He was given math homework in which he was given an array a of length n and an array of symbols b of length n consisting of symbols and Let s denote a for a segment l r 1 le l le r le n in the following way Let x 1 initially For every i from l to r we will consequently do the following if b i x x a i and if b i then x frac x a i Let s call for the segment l r a list of all x that we got during the calculations the number of them is exactly r l 1 For example let a 7 12 3 5 4 10 9 b l 2 r 6 then the path of calculations for that segment is 12 4 0 8 0 2 2 Let s call a segment l r if the path of calculations for it contains Kuzya needs to find the number of simple segments l r 1 le l le r le n Since he obviously has no time and no interest to do the calculations for each option he asked you to write a program to get to find that number ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = (1 << 20);\n\nvector<int> p;\n\nvoid solve(int n) {\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tstring b;\n\tcin >> b;\n\tvector<vector<pair<int, int>>> f(M);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint val = a[i];\n\t\tint op = (b[i] == \'*\' ? +1 : -1); \n\t\twhile (val > 1) {\n\t\t\tint p0 = p[val];\n\t\t\tint e0 = 0;\n\t\t\twhile (val % p0 == 0) {\n\t\t\t\tval /= p0;\n\t\t\t\te0 += op;\n\t\t\t}\n\t\t\tf[p0].push_back({i, e0});\n\t\t}\n\t}\n\tvector<int> g(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tg[i] = i;\n\t}\n\tfor (const auto& f0 : f) {\n\t\tif (!f0.empty()) {\n\t\t\tvector<pair<int, int>> sk;\n\t\t\tauto add = [&](int val, int pos) {\n\t\t\t\twhile (sk.size() > 0 && sk.back().first >= val) {\n\t\t\t\t\tsk.pop_back();\n\t\t\t\t}\n\t\t\t\tsk.push_back({ val, pos });\n\t\t\t};\n\t\t\tadd(0, 0);\n\t\t\tint cur = 0;\n\t\t\tfor (const auto& w : f0) {\n\t\t\t\tadd(cur, w.first);\n\t\t\t\tcur += w.second;\n\t\t\t\tint target =  -1;\n\t\t\t\tif (sk[0].first <= cur) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = sk.size();\n\t\t\t\t\twhile (hi - lo > 1) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (sk[mi].first <= cur) {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget = sk[lo].second;\n\t\t\t\t}\n\t\t\t\tg[w.first] = min(g[w.first], target);\n\t\t\t\tadd(cur, w.first + 1);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> h(n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\th[g[i] + 1].push_back(i);\n\t}\n\tset<int> w;\n\tw.insert(n);\n\tlong long r = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j : h[i]) {\n\t\t\tw.insert(j);\n\t\t}\n\t\twhile (*w.begin() < i) {\n\t\t\tw.erase(w.begin());\n\t\t}\n\t\tr += *w.begin() - i;\n\t}\n\tcout << r << endl;\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""g.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tp = vector<int>(M);\n\tfor (int i = 2; i < M; ++i) {\n\t\tif (p[i] == 0) {\n\t\t\tfor (int j = i; j < M; j += i) {\n\t\t\t\tp[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tsolve(n);\n\t}\n\treturn 0;\n}\n']","['data structures', 'number theory']",2600
https://codeforces.com//contest/618/problem/C,C. Constellation,Cat Noku has obtained a map of the night sky On this map he found a constellation with stars numbered from to For each the th star is located at coordinates No two stars are located at the same position In the evening Noku is going to take a look at the night sky He would like to find three distinct stars and form a triangle The triangle must have positive area In addition all other stars must lie strictly outside of this triangle He is having trouble finding the answer and would like your help Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions It is guaranteed that there is no line such that all stars lie on that line It can be proven that if the previous condition is satisfied there exists a solution to this problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n\tll x, y;\n\n\tPoint() : x(), y() {}\n\tPoint (ll _x, ll _y) : x(_x), y(_y) {}\n\n\tPoint operator + (const Point &a) const\n\t{\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\tPoint operator - (const Point &a) const\n\t{\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\tll operator % (const Point &a) const\n\t{\n\t\treturn x * a.x + y * a.y;\n\t}\n\tll operator * (const Point &a) const\n\t{\n\t\treturn x * a.y - y * a.x;\n\t}\n\tll sqrLen() const\n\t{\n\t\treturn *this % *this;\n\t}\n\n\tvoid scan()\n\t{\n\t\tscanf(""%lld%lld"", &x, &y);\n\t}\n};\n\nconst int N = 100100;\nPoint a[N];\nint n;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i].scan();\n\tll L = (a[1] - a[0]).sqrLen();\n\tint v = 1;\n\tfor (int i = 2; i < n; i++)\n\t{\n\t\tll d = (a[i] - a[0]).sqrLen();\n\t\tif (d < L)\n\t\t{\n\t\t\tL = d;\n\t\t\tv = i;\n\t\t}\n\t}\n\tll S = -1;\n\tint u = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tll s = (a[i] - a[0]) * (a[i] - a[v]);\n\t\ts = abs(s);\n\t\tif (s == 0) continue;\n\t\tif (S == -1 || s < S)\n\t\t{\n\t\t\tS = s;\n\t\t\tu = i;\n\t\t}\n\t}\n\tprintf(""%d %d %d\\n"", 1, min(v, u) + 1, max(v, u) + 1);\n\t\n\treturn 0;\n}']","['geometry', 'implementation']",1600
https://codeforces.com//contest/1777/problem/C,C. Quiz Master,A school has to decide on its team for an international quiz There are n students in the school We can describe the students using an array a where a i is the smartness of the i th 1 le i le n student There are m topics 1 2 3 ldots m from which the quiz questions will be formed The i th student is considered proficient in a topic T if a i bmod T 0 Otherwise he is a rookie in that topic We say that a team of students is collectively proficient in all the topics if for every topic there is a member of the team proficient in this topic Find a team that is collectively proficient in all the topics such that the maximum difference between the smartness of any two students in that team is Output this difference ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint m;\nnamespace pr\n{\n\ttypedef int ll;\n\ttypedef long long lll;\n\ttypedef pair<ll,int> pa;\n\tll ksm(ll x,ll y,const ll p)\n\t{\n\t\tll r=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) r=(lll)r*x%p;\n\t\t\tx=(lll)x*x%p; y>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tnamespace miller\n\t{\n\t\tconst int p[7]={2,3,5,7,11,61,24251};\n\t\tll s,t;\n\t\tbool test(ll n,int p)\n\t\t{\n\t\t\tif (p>=n) return 1;\n\t\t\tll r=ksm(p,t,n),w;\n\t\t\tfor (int j=0; j<s&&r!=1; j++)\n\t\t\t{\n\t\t\t\tw=(lll)r*r%n;\n\t\t\t\tif (w==1&&r!=n-1) return 0;\n\t\t\t\tr=w;\n\t\t\t}\n\t\t\treturn r==1;\n\t\t}\n\t\tbool prime(ll n)\n\t\t{\n\t\t\tif (n<2) return 0;\n\t\t\tfor (int i=0; i<7; ++i) if (n%p[i]==0) return n==p[i];\n\t\t\ts=__builtin_ctz(n-1); t=n-1>>s;\n\t\t\tfor (int i=0; i<7; ++i) if (!test(n,p[i])) return 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tusing miller::prime;\n\tmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\tnamespace rho\n\t{\n\t\tvoid nxt(ll &x,ll &y,ll &p) { x=((lll)x*x+y)%p; }\n\t\tll find(ll n,ll C)\n\t\t{\n\t\t\tll l,r,d,p=1;\n\t\t\tl=rnd()%(n-2)+2,r=l;\n\t\t\tnxt(r,C,n);\n\t\t\tint cnt=0;\n\t\t\twhile (l^r)\n\t\t\t{\n\t\t\t\tp=(lll)p*llabs(l-r)%n;\n\t\t\t\tif (!p) return gcd(n,llabs(l-r));\n\t\t\t\t++cnt;\n\t\t\t\tif (cnt==127)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\td=gcd(llabs(l-r),n);\n\t\t\t\t\tif (d>1) return d;\n\t\t\t\t}\n\t\t\t\tnxt(l,C,n); nxt(r,C,n); nxt(r,C,n);\n\t\t\t}\n\t\t\treturn gcd(n,p);\n\t\t}\n\t\tvector<pa> w;\n\t\tvector<ll> d;\n\t\tvoid dfs(ll n,int cnt)\n\t\t{\n\t\t\tif (n==1) return;\n\t\t\tif (prime(n)) return w.emplace_back(n,cnt),void();\n\t\t\tll p=n,C=rnd()%(n-1)+1;\n\t\t\twhile (p==1||p==n) p=find(n,C++);\n\t\t\tint r=1; n/=p;\n\t\t\twhile (n%p==0) n/=p,++r;\n\t\t\tdfs(p,r*cnt); dfs(n,cnt);\n\t\t}\n\t\tvector<pa> getw(ll n)\n\t\t{\n\t\t\tw=vector<pa>(0); dfs(n,1);\n\t\t\tif (n==1) return w;\n\t\t\tsort(w.begin(),w.end());\n\t\t\tint i,j;\n\t\t\tfor (i=1,j=0; i<w.size(); i++) if (w[i].first==w[j].first) w[j].second+=w[i].second; else w[++j]=w[i];\n\t\t\tw.resize(j+1);\n\t\t\treturn w;\n\t\t}\n\t\tvoid dfss(int x,ll n)\n\t\t{\n\t\t\tif (n>m) return;\n\t\t\tif (x==w.size()) return d.push_back(n),void();\n\t\t\tdfss(x+1,n);\n\t\t\tfor (int i=1; i<=w[x].second; i++) dfss(x+1,n*=w[x].first);\n\t\t}\n\t\tvector<ll> getd(ll n)\n\t\t{\n\t\t\tgetw(n); d=vector<ll>(0); dfss(0,1);\n\t\t\tsort(d.begin(),d.end());\n\t\t\treturn d;\n\t\t}\n\t}\n\tusing rho::getw,rho::getd;\n\tusing miller::prime;\n}\nusing pr::getw,pr::getd;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j;\n\t\tcin>>n>>m;\n\t\tvector<int> a(n);\n\t\tcin>>a;\n\t\tsort(all(a));\n\t\ta.resize(n=unique(all(a))-a.begin());\n\t\tint cur=0;\n\t\tvector<vector<int>> d;\n\t\td.reserve(n);\n\t\tfor (int x:a) d.push_back(getd(x));\n\t\tint ans=1e6;\n\t\tvector<int> cnt(m+1);\n\t\tfor (i=0,j=0; i<n; i++)\n\t\t{\n\t\t\twhile (j<n&&cur<m)\n\t\t\t{\n\t\t\t\tfor (int x:d[j]) cur+=!cnt[x]++;\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif (cur<m) break;\n\t\t\tcmin(ans,a[j-1]-a[i]);\n\t\t\tfor (int x:d[i]) cur-=!--cnt[x];\n\t\t}\n\t\tif (ans==1e6) ans=-1;\n\t\tcout<<ans<<\'\\n\';\n\t}\n}\n']","['binary search', 'math', 'number theory', 'sortings', 'two pointers']",1700
https://codeforces.com//contest/439/problem/C,C. Devu and Partitioning of the Array,Devu being a small kid likes to play a lot but he only likes to play with arrays While playing he came up with an interesting question which he could not solve can you please solve it for him Given an array consisting of distinct integers Is it possible to partition the whole array into disjoint non empty parts such that of the parts have even sum each of them must have even sum and remaining have odd sum note that parts need not to be continuous If it is possible to partition the array also give any possible way of valid partitioning ,"['#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<""OK"";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 100100\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(""a.in"");\nofstream g(""a.out"");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nvector<int> v[N];\nint par[N],imp[N],ti,x,tp,po,p,k,n;\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(""a.in"",""r"",stdin);\n    freopen(""a.out"",""w"",stdout);\n    #endif\n    \n    f>>n>>k>>p;\n    p=k-p;\n    FOR(i,1,n)\n    {\n        f>>x;\n        if(x&1)\n            imp[++ti]=x;\n        else\n            par[++tp]=x;\n    }\n    while(ti>p)\n    {\n        ++po;\n        if(po==k+1)\n            po=1;\n        v[po].pb(imp[ti]);\n        v[po].pb(imp[ti-1]);\n        ti-=2;\n    }\n    if(ti!=p)\n    {\n        g<<""NO"";\n        return 0;\n    }\n    while(tp)\n    {\n        ++po;\n        if(po==k+1)\n            po=1;\n        v[po].pb(par[tp]);\n        tp--;\n    }\n    while(ti)\n    {\n        po++;\n        if(po==k+1)\n            po=1;\n        v[po].pb(imp[ti]);\n        ti--;\n    }\n    FOR(i,1,k)\n    if(v[i].size()==0)\n    {\n        g<<""NO"";\n        return 0;\n    }\n    g<<""YES\\n"";\n    FOR(i,1,k)\n    {\n        g<<v[i].size()<<"" "";\n        for(int j=0;j<v[i].size();++j)\n            g<<v[i][j]<<"" "";\n        g<<""\\n"";\n    }\n    \n    return 0;\n}']","['brute force', 'constructive algorithms', 'implementation', 'number theory']",1700
https://codeforces.com//contest/1633/problem/F,F. Perfect Matching,You are given a tree consisting of n vertices numbered from 1 to n and n 1 edges numbered from 1 to n 1 Initially all vertices except vertex 1 are inactive You have to process queries of three types 1 v activate the vertex v It is guaranteed that the vertex v is inactive before this query and one of its neighbors is active After activating the vertex you have to choose a subset of edges of the tree such that each vertex is incident to chosen edge and each vertex is not incident to any of the chosen edges in other words this subset should represent a perfect matching on the active part of the tree If any such subset of edges exists print the sum of indices of edges in it otherwise print 0 2 queries of this type will be asked only right after a query of type 1 and there will be such queries If your answer to the previous query was 0 simply print 0 otherwise print the subset of edges for the previous query as follows first print the number of edges in the subset then print the indices of the chosen edges The sum of indices should be equal to your answer to the previous query 3 terminate the program Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Info {\n    int c[2];\n    i64 s[2];\n    Info() : c{}, s{} {}\n    Info(int x, int v) : Info() {\n        c[x] = 1;\n        s[x] = v;\n    }\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.c[0] = a.c[0] + b.c[0];\n    c.c[1] = a.c[1] + b.c[1];\n    c.s[0] = a.s[0] + b.s[0];\n    c.s[1] = a.s[1] + b.s[1];\n    return c;\n}\n\nvoid apply(Info &a, int b) {\n    if (b) {\n        std::swap(a.c[0], a.c[1]);\n        std::swap(a.s[0], a.s[1]);\n    }\n}\n\nvoid apply(int &a, int b) {\n    a ^= b;\n}\n\ntemplate<class Info, class Tag,\n    class Merge = std::plus<Info>>\nstruct LazySegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void apply(int p, const Tag &v) {\n        ::apply(info[p], v);\n        ::apply(tag[p], v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    bool rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return true;\n        }\n        if (l >= x && r <= y && info[p].c[0] + info[p].c[1] == r - l) {\n            apply(p, v);\n            return true;\n        }\n        if (l >= x && r <= y && info[p].c[0] + info[p].c[1] == 0) {\n            return false;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        bool res;\n        if (rangeApply(2 * p + 1, m, r, x, y, v)) {\n            res = rangeApply(2 * p, l, m, x, y, v);\n        } else {\n            res = false;\n        }\n        pull(p);\n        return res;\n    }\n    bool rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--;\n        v--;\n        \n        adj[u].emplace_back(v, i + 1);\n        adj[v].emplace_back(u, i + 1);\n    }\n    \n    std::vector<int> id(n), parent(n, -1), dep(n), top(n), in(n), out(n), siz(n);\n    int clk = 0;\n    \n    std::function<void(int)> dfs1 = [&](int u) {\n        if (u > 0) {\n            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), std::pair(parent[u], id[u])));\n        }\n        siz[u] = 1;\n        for (auto &e : adj[u]) {\n            auto [v, i] = e;\n            id[v] = i;\n            parent[v] = u;\n            dep[v] = dep[u] + 1;\n            dfs1(v);\n            siz[u] += siz[v];\n            if (siz[v] > siz[adj[u][0].first]) {\n                std::swap(adj[u][0], e);\n            }\n        }\n    };\n    dfs1(0);\n    \n    std::function<void(int)> dfs2 = [&](int u) {\n        in[u] = clk++;\n        for (auto [v, i] : adj[u]) {\n            top[v] = v == adj[u][0].first ? top[u] : v;\n            dfs2(v);\n        }\n        out[u] = clk;\n    };\n    dfs2(0);\n    \n    LazySegmentTree<Info, int> seg(n);\n    seg.modify(0, Info(1, 0));\n    \n    while (true) {\n        int op;\n        std::cin >> op;\n        \n        if (op == 3) {\n            break;\n        }\n        \n        if (op == 1) {\n            int x;\n            std::cin >> x;\n            x--;\n            int s = 1;\n            for (auto [v, i] : adj[x]) {\n                s ^= seg.rangeQuery(in[v], in[v] + 1).c[1];\n            }\n            \n            seg.modify(in[x], Info(s, id[x]));\n            if (s == 1) {\n                x = parent[x];\n                while (x != -1) {\n                    if (!seg.rangeApply(in[top[x]], in[x] + 1, 1)) {\n                        break;\n                    }\n                    x = parent[top[x]];\n                }\n            }\n        }\n        \n        auto info = seg.info[1];\n        if (info.c[0] != info.c[1]) {\n            std::cout << 0 << std::endl;\n        } else if (op == 1) {\n            std::cout << info.s[1] << std::endl;\n        } else {\n            std::vector<int> ans;\n            for (int i = 0; i < n; i++) {\n                if (seg.rangeQuery(in[i], in[i] + 1).c[1] == 1) {\n                    ans.push_back(id[i]);\n                }\n            }\n            std::sort(ans.begin(), ans.end());\n            \n            std::cout << ans.size();\n            for (auto x : ans) {\n                std::cout << "" "" << x;\n            }\n            std::cout << std::endl;\n        }\n    }\n    \n    return 0;\n}']","['data structures', 'divide and conquer', 'interactive', 'trees']",2800
https://codeforces.com//contest/1807/problem/D,D. Odd Queries,You have an array a 1 a 2 dots a n Answer q queries of the following form If we change all elements in the range a l a l 1 dots a r of the array to k will the sum of the entire array be odd Note that queries are and do not affect future queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ld double\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define line cout << \'\\n\'\n\n#define sz(v) ((int)(v).size())\nconst double pi = 3.1415926535897932384626433832795;\n\nconst long long mod = 998244353;\nconst long long inf = 9099999999999999999;\nconst long long nmax = 4e5 + 100;\nconst long double eps = 1e-9;\n\nrandom_device rd;\nmt19937 rnd(rd());\n//rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n//int MAGIC = rnd();\n\nvoid runtimeerror() {\n  int n, q;\n  cin >> n >> q;\n  vector <int> arr(n);\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n  vector <int> pref(n + 1);\n  for (int i = 0; i < n; i++)\n    pref[i + 1] = pref[i] + arr[i];\n  while (q--) {\n    int l, r, k;\n    cin >> l >> r >> k;\n    if ((pref[n] - (pref[r] - pref[l - 1]) + k * (r - l + 1)) & 1) cout << ""YES"";\n    else cout << ""NO"";\n    line;\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n\n  //  freopen(""input.txt"", ""r"", stdin);\n  //  freopen(""output.txt"", ""w"", stdout);\n\n  ll t = 1;\n    cin >> t;\n  while (t--)\n    runtimeerror();\n\n  //  cout << ""WINNER"";\n  // i\'m stupid man\n}']","['data structures', 'implementation']",900
https://codeforces.com//contest/1735/problem/F,F. Pebbles and Beads,There are two currencies pebbles and beads Initially you have a pebbles b beads There are n days each day you can exchange one currency for another at some exchange rate On day i you can exchange p i leq x leq p i pebbles for q i leq y leq q i beads or vice versa It s allowed not to perform an exchange at all Meanwhile if you perform an exchange the proportion x cdot q i y cdot p i must be fulfilled Fractional exchanges are allowed You can perform no more than one such exchange in one day The numbers of pebbles and beads you have must always remain non negative Please solve the following n problems independently for each day i output the maximum number of pebbles that you can have at the end of day i if you perform exchanges optimally ,"['// LUOGU_RID: 91546812\n//author: HugeWide\n/*rating:\nCodeforces: 2307,International Master\nAtcoder: 1990,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\') {\n\t\tif(ch==\'-\') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\') {\n\t\tx=(x<<3)+(x<<1)+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar(\'-\'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+\'0\');\n}\n#define writesp(x) write(x),putchar(\' \')\n#define writeln(x) write(x),putchar(\'\\n\')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=300300;\n\nint n;\ndb a,b;\ndb p[N],q[N];\n\nstruct Vector {\n\tdb x,y;\n\tVector(db _x,db _y) {\n\t\tx=_x,y=_y;\n\t}\n\tbool operator < (const Vector& a) const {\n\t\treturn y*a.x>x*a.y;\n\t}\n};\nmultiset<Vector> s;\ntypedef multiset<Vector>::iterator si;\n\ndb lx,ly,rx,ry;\nvoid solve() {\n\tn=read(),a=read(),b=read();\n\trep(i,1,n) p[i]=read();\n\trep(i,1,n) q[i]=read();\n\ts.clear(); lx=rx=a,ly=ry=b;\n\trep(i,1,n) {\n\t\ts.insert(Vector(p[i]*2,q[i]*2));\n\t\tlx-=p[i],ly+=q[i],rx+=p[i],ry-=q[i];\n\t\twhile(ry<0) {\n\t\t\tsi it=s.begin();\n\t\t\tdb x=it->x,y=it->y;\n\t\t\ts.erase(it);\n\t\t\tif(ry+y<=0) {\n\t\t\t\trx-=x,ry+=y;\n\t\t\t} else {\n\t\t\t\trx-=x,ry+=y;\n\t\t\t\tdb t=ry/y;\n\t\t\t\tx*=t,y*=t;\n\t\t\t\trx+=x,ry-=y;\n\t\t\t\ts.insert(Vector(x,y));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(lx<0) {\n\t\t\tsi it=s.end(); it--;\n\t\t\tdb x=it->x,y=it->y;\n\t\t\ts.erase(it);\n\t\t\tif(lx+x<=0) {\n\t\t\t\tlx+=x,ly-=y;\n\t\t\t} else {\n\t\t\t\tlx+=x,ly-=y;\n\t\t\t\tdb t=lx/x;\n\t\t\t\tx*=t,y*=t;\n\t\t\t\tlx-=x,ly+=y;\n\t\t\t\ts.insert(Vector(x,y));\n\t\t\t}\n\t\t}\n//\t\tdb x=rx,y=ry;\n//\t\tprintf(""(%.0lf,%.0lf) "",x,y);\n//\t\tfor(si it=s.begin();it!=s.end();it++) {\n//\t\t\tx-=it->x,y+=it->y;\n//\t\t\tprintf(""(%.0lf,%.0lf) "",x,y);\n//\t\t}\n//\t\tprintf(""\\n"");\n\t\tdouble ans=rx;\n\t\tprintf(""%.12lf\\n"",ans);\n\t}\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n']","['data structures', 'geometry']",2900
https://codeforces.com//contest/1740/problem/D,D. Knowledge Cards,Pak Chanek a renowned scholar invented a card puzzle using his knowledge In the puzzle you are given a board with n rows and m columns Let r c represent the cell in the r th row and the c th column Initially there are k cards stacked in cell 1 1 Each card has an integer from 1 to k written on it More specifically the i th card of the stack in cell 1 1 has the number a i written on it It is known that no two cards have the same number written on them In other words the numbers written on the cards are a permutation of integers from 1 to k All other cells are empty You need to move the k cards to cell n m to create another stack of cards Let b i be the number written on the i th card of the stack in cell n m You should create the stack in cell n m in such a way so that b i i for all 1 leq i leq k In one move you can remove the from a cell and place it onto an adjacent cell a cell that shares a common side If the target cell already contains one or more cards you place your card You must do each operation while satisfying the following restrictions Each cell other than 1 1 and n m must not have more than one card on it You cannot move a card onto cell 1 1 You cannot move a card from cell n m Given the values of n m k and the array a determine if the puzzle is solvable ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m, k;\n    std::cin >> n >> m >> k;\n    \n    std::vector<int> a(k);\n    for (int i = 0; i < k; i++) {\n        std::cin >> a[i];\n        a[i] = k - a[i];\n    }\n    \n    std::vector<bool> f(k);\n    int siz = 0;\n    for (int i = 0, j = 0; i < k; i++) {\n        while (!f[i]) {\n            f[a[j++]] = true;\n            siz++;\n        }\n        if (siz > n * m - 3) {\n            std::cout << ""TIDAK\\n"";\n            return;\n        }\n        f[i] = false;\n        siz--;\n    }\n    std::cout << ""YA\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['constructive algorithms', 'data structures']",1500
https://codeforces.com//contest/1393/problem/D,D. Rarity and New Dress,Carousel Boutique is busy again Rarity has decided to visit the pony ball and she surely needs a new dress because going out in the same dress several times is a sign of bad manners First of all she needs a dress pattern which she is going to cut out from the rectangular piece of the multicolored fabric The piece of the multicolored fabric consists of n times m separate square scraps Since Rarity likes dresses in style a dress pattern must only include scraps sharing the same color A dress pattern must be the square and since Rarity is fond of rhombuses the sides of a pattern must form a 45 circ angle with sides of a piece of fabric that way it will be resembling the traditional picture of a rhombus Examples of proper dress patterns Examples of improper dress patterns The first one consists of multi colored scraps the second one goes beyond the bounds of the piece of fabric the third one is not a square with sides forming a 45 circ angle with sides of the piece of fabric Rarity wonders how many ways to cut out a dress pattern that satisfies all the conditions that do exist Please help her and satisfy her curiosity so she can continue working on her new masterpiece ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nconst ll NN = 2e5 + 5;\nll n, m, has;\nchar a[2020][2020];\nll d[2020][2020];\nll dx[] = {-1, 1, 0, 0};\nll dy[] = {0, 0, -1, 1};\nll cek(ll X, ll Y)\n{\n    ll H = 0;\n    for(ll i = 0; i < 4; i++)\n    {\n        ll nx = X + dx[i];\n        ll ny = Y + dy[i];\n        // cout << X << "" "" << Y << "" "" << nx << "" "" << ny << ""  "" << a[nx][ny] << "" "" << a[X][Y] << ""\\n"";\n        if(1 <= nx && nx <= n && 1 <= ny && ny <= m && (a[nx][ny] == a[X][Y]))\n            H++;\n    }\n    // cout << X << "" "" << Y << "" "" << H << ""\\n"";\n    return (H < 4);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> n >> m;\n    for(ll i = 1; i <= n; i++)\n        for(ll j = 1; j <= m; j++)\n            cin >> a[i][j];\n    queue<pair<ll, ll> >  q;\n    for(ll i = 1; i <= n; i++)\n        for(ll j = 1; j <= m; j++)\n            if(cek(i, j))\n            {\n                d[i][j] = 1;\n                q.push(mp(i, j));\n            }\n    while(!q.empty())\n    {\n        ll X = q.front().fi;\n        ll Y = q.front().se;\n        q.pop();\n        for(ll i = 0; i < 4; i++)\n        {\n            ll nx = X + dx[i];\n            ll ny = Y + dy[i];\n            if(1 <= nx && nx <= n && 1 <= ny && ny <= m && d[nx][ny] == 0)\n            {\n                d[nx][ny] = d[X][Y] + 1;\n                q.push(mp(nx, ny));\n            }\n        }\n    }\n    // for(ll i = 1; i <= n; i++)\n    // {\n    //     for(ll j = 1; j <= m; j++)\n    //         cout << d[i][j] << "" "";\n    //     cout << ""\\n"";\n    // }\n    for(ll i = 1; i <= n; i++)\n        for(ll j = 1; j <= m; j++)\n            has += d[i][j];\n    cout << has << ""\\n"";\n}   ']","['dfs and similar', 'dp', 'implementation', 'shortest paths']",2100
https://codeforces.com//contest/1389/problem/D,D. Segment Intersections,You are given two lists of segments al 1 ar 1 al 2 ar 2 dots al n ar n and bl 1 br 1 bl 2 br 2 dots bl n br n Initially all segments al i ar i are equal to l 1 r 1 and all segments bl i br i are equal to l 2 r 2 In one step you can choose one segment either from the first or from the second list and extend it by 1 In other words suppose you ve chosen segment x y then you can transform it either into x 1 y or into x y 1 Let s define a total intersection I as the sum of lengths of intersections of the corresponding pairs of segments i e sum limits i 1 n text intersection length al i ar i bl i br i Empty intersection has length 0 and length of a segment x y is equal to y x What is the minimum number of steps you need to make I greater or equal to k ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll INF = (ll)1e18;\n\nll getCost(int l1, int r1, int l2, int r2, int d) {\n\tif (l1 > l2) {\n\t\tswap(l1, l2);\n\t\tswap(r1, r2);\n\t}\n\tll ans = 0;\n\tint w = 0;\n\tif (r1 < l2) {\n\t\tans += l2 - r1;\n\t\tw = r2 - l1;\n\t} else {\n\t\td = max(0, d - (min(r1, r2) - max(l1, l2)));\n\t\tw = max(r1, r2) - min(r1, r2) + max(l1, l2) - min(l1, l2);\n\t}\n\tif (d <= w) return ans + d;\n\treturn ans + w + 2 * (d - w);\n}\n\nvoid solve() {\n\tint n, k, l1, l2, r1, r2;\n\tscanf(""%d%d%d%d%d%d"", &n, &k, &l1, &r1, &l2, &r2);\n\tll ans = INF;\n\tfor (int m = 1; m <= n; m++) {\n\t\tint d = k / m;\n\t\tll w1 = getCost(l1, r1, l2, r2, d);\n\t\tll w2 = getCost(l1, r1, l2, r2, d + 1);\n//\t\teprintf(""%d %lld %lld\\n"", m, w1, w2);\n\t\td = k % m;\n\t\tans = min(ans, d * w2 + (m - d) * w1);\n\t}\n\tprintf(""%lld\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation', 'math']",2100
https://codeforces.com//contest/698/problem/C,C. LRU,While creating high loaded systems one should pay a special attention to caching This problem will be about one of the most popular caching algorithms called LRU Least Recently Used Suppose the cache may store no more than objects At the beginning of the workflow the cache is empty When some object is queried we check if it is present in the cache and move it here if it s not If there are more than objects in the cache after this the least recently used one should be removed In other words we remove the object that has the smallest time of the last query Consider there are videos being stored on the server all of the same size Cache can store no more than videos and caching algorithm described above is applied We know that any time a user enters the server he pick the video with probability The choice of the video is independent to any events before The goal of this problem is to count for each of the videos the probability it will be present in the cache after queries ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\ndouble p[100],ff[100];\ndouble dp[(1<<20)+10];\nvoid gao(double pr,int i) {\n\tif (fabs(pr)<=1e-9) {\n\t\tputs(""0"");\n\t\treturn;\n\t}\n\tdp[0]=pr;\n\trep(i,0,n) ff[i]=0; ff[0]=pr;\n\trep(S,1,(1<<n)) if ((S&(1<<i))==0){\n\t\tdp[S]=0;\n\t\tdouble prob=1;\n\t\trep(j,0,n) if ((S&(1<<j))!=0){\n\t\t\tprob-=p[j];\n\t\t\tdp[S]+=dp[S^(1<<j)]*p[j];\n\t\t}\n\t\tdp[S]/=prob;\n\t\tff[__builtin_popcount(S)]+=dp[S];\n\t}\n\tdouble v=0;\n\trep(i,0,k) v+=ff[i];\n\tprintf(""%.10f\\n"",v);\n}\nint main() {\n\tscanf(""%d%d"",&n,&k);\n\trep(i,0,n) scanf(""%lf"",p+i);\n\trep(i,0,n) {\n\t\tgao(p[i],i);\n\t}\n}\n']","['bitmasks', 'dp', 'math', 'probabilities']",2400
https://codeforces.com//contest/1543/problem/D1,D1. RPD and Rap Sheet  Easy Version ,Every decimal number has a base k equivalent The individual digits of a base k number are called k its Let s define the k itwise XOR of two k its a and b as a b bmod k The k itwise XOR of two base k numbers is equal to the new number formed by taking the k itwise XOR of their corresponding k its The k itwise XOR of two decimal numbers a and b is denoted by a oplus k b and is equal to the decimal representation of the k itwise XOR of the base k representations of a and b All further numbers used in the statement below are in decimal unless specified When k 2 it is always true in this version the k itwise XOR is the same as the bitwise XOR You have hacked the criminal database of Rockport Police Department RPD also known as the Rap Sheet But in order to access it you require a password You don t know it but you are quite sure that it lies between 0 and n 1 inclusive So you have decided to guess it Luckily you can try at most n times without being blocked by the system But the system is adaptive Each time you make an incorrect guess it changes the password Specifically if the password before the guess was x and you guess a different number y then the system changes the password to a number z such that x oplus k z y Guess the password and break into the system ,"['// Problem: D1. RPD and Rap Sheet (Easy Version)\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/D1\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),k=read();\n\t\tint s=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t{\n\t\t\tprintf(""%lld\\n"",i^s);\n\t\t\tfflush(stdout);\n\t\t\ts=i;\n\t\t\tif(read()==1) break;\n\t\t\t//如果i是0，会变成ixor s\n\t\t}\n\t}\n\treturn 0;\n}']","['bitmasks', 'constructive algorithms', 'interactive', 'math']",1700
https://codeforces.com//contest/986/problem/B,B. Petr and Permutations,Petr likes to come up with problems about randomly generated data This time problem is about random permutation He decided to generate a random permutation this way he takes identity permutation of numbers from 1 to n and then 3n times takes a random pair of different elements and swaps them Alex envies Petr and tries to imitate him in all kind of things Alex has also come up with a problem about random permutation He generates a random permutation just like Petr but swaps elements 7n 1 times instead of 3n times Because it is more random OK You somehow get a test from one of these problems and now you want to know from which one ,"['/**\n *    author:  tourist\n *    created: 29.05.2018 18:40:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  vector<int> was(n, 0);\n  int cyc = 0;\n  for (int i = 0; i < n; i++) {\n    if (was[i]) {\n      continue;\n    }\n    cyc++;\n    int p = i;\n    while (!was[p]) {\n      was[p] = 1;\n      p = a[p];\n    }\n  }\n  cout << ((n - cyc) % 2 == (3 * n) % 2 ? ""Petr"" : ""Um_nik"") << \'\\n\';\n  return 0;\n}\n']","['combinatorics', 'math']",1800
https://codeforces.com//contest/1455/problem/A,A. Strange Functions,Let s define a function f x x is a positive integer as follows write all digits of the decimal representation of x backwards then get rid of the leading zeroes For example f 321 123 f 120 21 f 1000000 1 f 111 111 Let s define another function g x dfrac x f f x x is a positive integer as well Your task is the following for the given positive integer n calculate the number of different values of g x among all numbers x such that 1 le x le n ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    string S;\n    cin >> S;\n    cout << S.size() << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","['math', 'number theory']",800
https://codeforces.com//contest/1870/problem/A,A. MEXanized Array,You are given three non negative integers n k and x Find the maximum possible sum of elements in an array consisting of non negative integers which has n elements its MEX is equal to k and all its elements do not exceed x If such an array does not exist output 1 The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nll n, k, x;\nvoid Main() {\n\tcin >> n >> k >> x;\n\tif(k > n) {\n\t\tcout << -1 << '\\n';\n\t} else if(k > x + 1) {\n\t\tcout << -1 << '\\n';\n\t} else {\n\t\tll sum = (ll) k * (k - 1) / 2;\n\t\tn -= k;\n\t\tsum += (k == x ? x - 1 : x) * n;\n\t\tcout << sum << '\\n';\n\t}\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]","['constructive algorithms', 'greedy', 'math']",800
https://codeforces.com//contest/670/problem/E,E. Correct Bracket Sequence Editor,Recently Polycarp started to develop a text editor that works only with correct bracket sequences abbreviated as CBS Note that a bracket sequence is correct if it is possible to get a correct mathematical expression by adding s and s to it For example sequences and are correct while and are not Each bracket in CBS has a pair For example in 1st bracket is paired with 8th 2d bracket is paired with 3d 3d bracket is paired with 2d 4th bracket is paired with 7th 5th bracket is paired with 6th 6th bracket is paired with 5th 7th bracket is paired with 4th 8th bracket is paired with 1st Polycarp s editor currently supports only three operations during the use of CBS The cursor in the editor takes the whole position of one of the brackets not the position between the brackets There are three operations being supported move the cursor one position to the left move the cursor one position to the right delete the bracket in which the cursor is located delete the bracket it s paired to and all brackets between them that is delete a substring between the bracket in which the cursor is located and the one it s paired to After the operation the cursor moves to the nearest bracket to the right of course among the non deleted If there is no such bracket that is the suffix of the CBS was deleted then the cursor moves to the nearest bracket to the left of course among the non deleted There are pictures illustrated several usages of operation below All incorrect operations shift cursor over the end of CBS delete the whole CBS etc are not supported by Polycarp s editor Polycarp is very proud of his development can you implement the functionality of his editor ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)5e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nchar s[maxN];\nint rev[maxN];\nint n, m, q;\n\nset <int> available;\nset<int> ::iterator it;\n\nvoid makeDel() {\n    int l = *it;\n    int r = rev[l];\n    auto iter2 = available.lower_bound(rev[*it]);\n    if (l < r) {\n        iter2++;\n        available.erase(it, iter2);\n    } else {\n        it++;\n        available.erase(iter2, it);\n    }\n    it = available.upper_bound(l);\n    if (it == available.end()) it = prev(it);\n}\n\nint main() {\n\n   // freopen(""input.txt"", ""r"", stdin);\n   // freopen(""output.txt"", ""w"", stdout);\n\n    n = nextInt<int>();\n    m = nextInt<int>();\n    int p = nextInt<int>() - 1;\n    gets(s);\n    stack <int> st;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == \'(\') {\n            st.push(i);\n        } else {\n            rev[i] = st.top();\n            rev[st.top()] = i;\n            st.pop();\n        }\n        available.insert(i);\n    }\n    it = available.lower_bound(p);\n\n    for (int i =0; i < m; ++i) {\n        char ch = getchar();\n        if (ch == \'L\') {\n            it--;\n        } else if (ch == \'R\') {\n            it++;\n        } else {\n            makeDel();\n        }\n    }\n    for (auto x: available) putchar(s[x]);\n    return 0;\n}\n']","['data structures', 'dsu', 'strings']",1700
https://codeforces.com//contest/1280/problem/C,C. Jeremy Bearimy,Welcome Everything is fine You have arrived in The Medium Place the place between The Good Place and The Bad Place You are assigned a task that will either make people happier or torture them for eternity You have a list of k pairs of people who have arrived in a new inhabited neighborhood You need to assign each of the 2k people into one of the 2k houses Each person will be the resident of exactly one house and each house will have exactly one resident Of course in the neighborhood it is possible to visit friends There are 2k 1 roads each of which connects two houses It takes some time to traverse a road We will specify the amount of time it takes in the input The neighborhood is designed in such a way that from anyone s house there is exactly one sequence of distinct roads you can take to any other house In other words the graph with the houses as vertices and the roads as edges is a tree The truth is these k pairs of people are actually soulmates We index them from 1 to k We denote by f i the amount of time it takes for the i th pair of soulmates to go to each other s houses As we have said before you will need to assign each of the 2k people into one of the 2k houses You have two missions one from the entities in The Good Place and one from the entities of The Bad Place Here they are The first mission from The Good Place is to assign the people into the houses such that the sum of f i over all pairs i is minimized Let s define this minimized sum as G This makes sure that soulmates can easily and efficiently visit each other The second mission from The Bad Place is to assign the people into the houses such that the sum of f i over all pairs i is maximized Let s define this maximized sum as B This makes sure that soulmates will have a difficult time to visit each other What are the values of G and B ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<vector<pair<int,ll> > > edges;\n\nll a1, a2;\nint n;\n\nint dfs(int v, int p){\n\tint sz = 1;\n\tfor(pair<int,ll> e : edges[v]){\n\t\tif(e.first == p) continue;\n\t\tint csz = dfs(e.first, v);\n\t\tsz += csz;\n\t\tif(csz & 1){\n\t\t\ta1 += e.second;\n\t\t}\n\t\ta2 += e.second * min(n - csz, csz);\n\t}\n\treturn sz;\n}\nvoid solve(){\n\ta1 = a2 = 0;\n\tcin >> n;\n\tn *= 2;\n\tedges.assign(n, {});\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tll t;\n\t\tcin >> a >> b >> t;\n\t\ta--; b--;\n\t\tedges[a].push_back({b, t});\n\t\tedges[b].push_back({a, t});\n\t}\n\tdfs(0, -1);\n\tcout << a1 << ' ' << a2 << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['dfs and similar', 'graphs', 'greedy', 'trees']",2000
https://codeforces.com//contest/681/problem/A,A. A Good Contest,Codeforces user handle color depends on his rating it is red if his rating is greater or equal to it is orange if his rating is less than but greater or equal to etc Each time participant takes part in a rated contest his rating is changed depending on his performance Anton wants the color of his handle to become red He considers his performance in the rated contest to be if he outscored some participant whose handle was colored red before the contest and his rating has increased after it Anton has written a program that analyses contest results and determines whether he performed good or not Are you able to do the same ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring name;\n\n\t\tint a, b;\n\t\tcin >> name >> a >> b;\n\t\tif (a >= 2400 && b > a) {\n\t\t\tcout << ""YES\\n"";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << ""NO\\n"";\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/893/problem/B,B. Beautiful Divisors,Recently Luba learned about a special kind of numbers that she calls numbers The number is called iff its binary representation consists of consecutive ones and then consecutive zeroes Some examples of beautiful numbers More formally the number is beautiful iff there exists some positive integer such that the number is equal to Luba has got an integer number and she wants to find its greatest beautiful divisor Help her to find it ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nbool isWonderful(int d) {\n\tint l = __builtin_ctz(d);\n\treturn d == ((2 << l) - 1) << l;\n}\n\nint main() {\n\tint n = nxt();\n\tint d = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (n % i || !isWonderful(i)) {\n\t\t\tcontinue;\n\t\t}\n\t\td = i;\n\t}\n\tprintf(""%d\\n"", d);\n\n\treturn 0;\n}\n']","['brute force', 'implementation']",1000
https://codeforces.com//contest/703/problem/D,D. Mishka and Interesting sum,Little Mishka enjoys programming Since her birthday has just passed her friends decided to present her with array of non negative integers of elements Mishka loved the array and she instantly decided to determine its beauty value but she is too little and can t process large arrays Right because of that she invited you to visit her and asked you to process queries Each query is processed in the following way Two integers and are specified bounds of query segment Integers presented in array segment in sequence of integers are written down XOR sum of written down integers is calculated and this value is the answer for a query Formally if integers written down in point 2 are then Mishka wants to know the value where operator of exclusive bitwise OR Since only the little bears know the definition of array beauty all you are to do is to answer each of queries presented ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name"".in"", ""r"", stdin); \\\n        freopen(name"".out"", ""w"", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << "" = "" << head << "" <<"" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=\',\' || c!=0) {\n        if (*s==\'(\' || *s==\'[\' || *s==\'{\' || *s==\'<\') c++;\n        if (*s==\')\' || *s==\']\' || *s==\'}\' || *s==\'>\') c--;\n        cerr << *s++;\n    }\n    cerr << "" = "" << head << "", "";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << ""\\033[32m>> "" << __LINE__ << "": "" << __PRETTY_FUNCTION__ << endl; \\\n    cout << ""   ""; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << ""\\033[0m""; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss="""", const string se="""") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? """" : "", "") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << ""("" << pair.F << "", "" << pair.S << "")"";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), ""["", ""]"");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), ""{"", ""}"");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), ""|"", ""|"");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << ""{"";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?"""":"", "") << it->F << "":"" << it->S;\n    }\n    o << ""}"";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << ""Not lucky"" << endl;\n        exit(0);\n    }\n}\n\nconst int MX = 1123456;\n\ninline int lb(int a) {\n    return a&(-a);\n}\nstruct BIT {\n    int v[MX];\n    void chg(int a, int x) {\n        a+=2;\n        for (int i=a; i; i-=lb(i)) {\n            v[i] ^= x;\n        }\n    }\n\n    int qry(int a) {\n        a+=2;\n        int t = 0;\n        for (int i=a; i<MX; i+=lb(i)) {\n            t ^= v[i];\n        }\n        return t;\n    }\n}bit;\n\n\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    static int ip[MX];\n    int N;\n    cin >> N;\n    for (int i=0; i<N; i++) {\n        cin >> ip[i];\n    }\n\n    int Q;\n    cin>>Q;\n    using pii = pair<int, int>;\n    static vector<pii> q[MX];\n    for (int i=0; i<Q; i++) {\n        int l, r;\n        cin>>l>>r;\n        l--;\n        r--;\n        q[r].PB({l, i});\n    }\n\n    static int ans[MX];\n    map<int, int> mp;\n\n    for (int i=0; i<N; i++) {\n        int v = ip[i];\n        if (mp.count(v)) {\n            bit.chg(mp[v], v);\n            //cout << i << endl;\n            //cout << ""chg = "" << mp[v] << \' \' << v << endl;\n        }\n        mp[v] = i;\n\n        for (auto qr: q[i]) {\n            int l = qr.F, id = qr.S;\n            ans[id] = bit.qry(l);\n        }\n    }\n\n    for (int i=0; i<Q; i++) {\n        cout << ans[i] << \'\\n\';\n    }\n\n    return 0;\n}\n\n']",['data structures'],2100
https://codeforces.com//contest/1348/problem/C,C. Phoenix and Distribution,Phoenix has a string s consisting of lowercase Latin letters He wants to distribute all the letters of his string into k strings a 1 a 2 dots a k such that every letter of s goes to exactly one of the strings a i The strings a i need to be substrings of s Phoenix can distribute letters of s and rearrange the letters within each string a i however he wants For example if s and k 2 Phoenix may distribute the letters of his string in many ways such as and and and and But these ways are invalid and and and empty string a i should be non empty Phoenix wants to distribute the letters of his string s into k strings a 1 a 2 dots a k to the lexicographically maximum string among them i e minimize max a 1 a 2 dots a k Help him find the optimal distribution and print the minimal possible value of max a 1 a 2 dots a k String x is lexicographically less than string y if either x is a prefix of y and x ne y or there exists an index i 1 le i le min x y such that x i y i and for every j 1 le j i x j y j Here x denotes the length of the string x ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=100010;\nint t,k,n,a[MAXN];\nchar c[MAXN];\nint divc (int a,int b) {\n\tif (a%b==0) {return a/b;}\n\telse {return a/b+1;}\n}\nint main () {\n\tscanf(""%d"",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(""%d%d"",&n,&k);\n\t\tscanf(""%s"",c+1);\n\t\tfor (int i=1;i<=n;i++) {a[i]=c[i]-\'a\'+1;}\n\t\tsort(a+1,a+n+1);\n\t\tif (a[1]==a[k]) {\n\t\t\tint flg=0;\n\t\t\tfor (int j=k+1;j<=n;j++) {if (a[j]!=a[k+1]) {flg=1;break;}}\n\t\t\tif (!flg) {\n\t\t\t\tprintf(""%c"",a[k]+\'a\'-1);\n\t\t\t\tfor (int j=1;j<=divc((n-k),k);j++) {printf(""%c"",a[k+1]+\'a\'-1);}\n\t\t\t\tprintf(""\\n"");\n\t\t\t} else {\n\t\t\t\tfor (int j=k;j<=n;j++) {printf(""%c"",a[j]+\'a\'-1);}\n\t\t\t\tprintf(""\\n"");\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(""%c\\n"",a[k]+\'a\'-1);\n\t\t}\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'sortings', 'strings']",1600
https://codeforces.com//contest/115/problem/E,E. Linear Kingdom Races,You are a car race organizer and would like to arrange some races in Linear Kingdom Linear Kingdom has consecutive roads spanning from left to right The roads are numbered from to from left to right thus the roads follow in the order of their numbers increasing There will be several races that may be held on these roads Each race will use a subset of these roads Also each race will pay some amount of money to you if this race is held No races overlap in time so some roads can be used in several races Unfortunately some of the roads are in a bad condition and they need repair Each road has repair costs associated with it you are required to pay this cost to repair the road A race can only take place if all the roads used in the race are renovated Your task is to repair such roads possibly all or none that will maximize your profit Your profit is defined as the total money you get from the races that are held minus the total money you spent to repair the roads Note that you may decide not to repair any road and gain zero profit Print the maximum profit you can gain ,"['#include <vector>\n#include <cstring>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <stdlib.h>\n#include <ctime>\n#include <string>\n#include <complex>\n#ifdef __ASD__\n#include <windows.h>\n#endif\nusing namespace std;\n#define all(a) a.begin(),a.end()\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define fornn(i,n) for(i=0;i<(n);++i)\n#define lng long long\n#define SQ(a) ((a)*(a))\n#define forv(i,v) for(int i=0;i<(int)v.size();++i)\n#define mp make_pair\n#define pb push_back\n#define ABS(a) ((a)<0?-(a):(a))\n#define iinf 1000000000\n#define linf 1000000000000000000LL\n#define dinf 1e200\n#define left asdleft\n#define prev asdprev\n#define eps 1e-12\n#define y1 asdy1\n#define y2 asdy2\n#define EQ(a,b) abs((a)-(b))<eps\n#define PI 3.1415926535897932384626433832795\n#define DEG2RAD PI/180\n#define ulng unsigned lng\n#define next asdnext\n#define prev asdprev\nvoid mytimer(string task){\n#ifdef __ASD__\n        static LARGE_INTEGER prev;      LARGE_INTEGER cur,freq; QueryPerformanceCounter(&cur);  QueryPerformanceFrequency(&freq);       if(task!="""")            cout<<task<<"" took ""<<(cur.QuadPart-prev.QuadPart)*1.0/freq.QuadPart<<endl;     prev=cur;\n#endif\n}\nvoid ext(int c){\n#ifdef __ASD__\n        exit(c);\n#endif\n}\n\nconst int lim=1000000;\nlng tree[lim];\nlng delta[lim];\n\nvoid add(int l,int r,lng v,int a,int b,int k){\n    if(l==a&&r==b){\n        delta[k]+=v;\n        tree[k]+=v;\n        return;\n    }\n    int c=(a+b)/2;\n    if(r<=c)\n        add(l,r,v,a,c,k*2+1);\n    else if(l>=c)\n        add(l,r,v,c,b,k*2+2);\n    else{\n        add(l,c,v,a,c,k*2+1);\n        add(c,r,v,c,b,k*2+2);\n    }\n    tree[k]=max(tree[k*2+1],tree[k*2+2])+delta[k];\n}\n\nvector<pair<int,int> > *starts = new vector<pair<int,int> >[210000];\nint cost[210000];\nint n;\n\n#define taska ""burai""\nint main(){\n#ifdef __ASD__\n    freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#else\n    //freopen(taska"".in"",""r"",stdin);freopen(taska"".out"",""w"",stdout);\n#endif\n\n    ios_base::sync_with_stdio(false);\n\n    int m;\n    cin>>n>>m;\n    forn(i,n)\n        cin>>cost[i];\n    forn(i,m){\n        int a,b,c;\n        cin>>a>>b>>c;\n        --a;--b;\n        starts[b].pb(mp(a,c));\n    }\n\n    forn(k,n){\n        add(k+1,k+2,tree[0],0,n+1,0);\n        add(0,k+1,-cost[k],0,n+1,0);\n        forv(i,starts[k])\n            add(0,starts[k][i].first+1,starts[k][i].second,0,n+1,0);\n    }\n\n    cout<<tree[0];\n\n    return 0;\n}\n']","['data structures', 'dp']",2400
https://codeforces.com//contest/1785/problem/E,E. Infinite Game,Alice and Bob are playing an infinite game consisting of Each set consists of In each round one of the players wins The first player to win two rounds in a set wins this set Thus a set always ends with the score of 2 0 or 2 1 in favor of one of the players Let s call a a finite string s consisting of characters and Consider an infinite string formed with repetitions of string s sss ldots Suppose that Alice and Bob play rounds according to this infinite string left to right If a character of the string sss ldots is then Alice wins the round if it s Bob wins the round As soon as one of the players wins two rounds the set ends in their favor and a new set starts from the next round Let s define a i as the number of sets won by Alice among the first i sets while playing according to the given scenario Let s also define r as the limit of ratio frac a i i as i rightarrow infty If r frac 1 2 we ll say that scenario s is If r frac 1 2 we ll say that scenario s is If r frac 1 2 we ll say that scenario s is You are given a string s consisting of characters and Consider all possible ways of replacing every with or to obtain a string consisting only of characters and Count how many of them result in a scenario winning for Alice how many result in a tied scenario and how many result in a scenario winning for Bob Print these three numbers modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> add(vector<num> a, vector<num> b){\n\tfor(int i = 0; i < a.size(); i++) a[i] += b[i];\n\treturn a;\n}\n\nvector<num> solve(string s){\n\tif(s.size() == 1){\n\t\tif(s == ""a"") return {1, 0, 0};\n\t\tif(s == ""b"") return {0, 0, 1};\n\t\tif(s == ""?"") return {1, 0, 1};\n\t}\n\tif(s[0] == \'?\'){\n\t\tstring sa = s;\n\t\tstring sb = s;\n\t\tsa[0] = \'a\'; sb[0] = \'b\';\n\t\treturn add(solve(sa), solve(sb));\n\t}\n\tif(s[1] == \'?\'){\n\t\tstring sa = s;\n\t\tstring sb = s;\n\t\tsa[1] = \'a\'; sb[1] = \'b\';\n\t\treturn add(solve(sa), solve(sb));\n\t}\n\tvector<num> ans(3, 0);\n\tauto pack = [&](tuple<int, array<int, 3>, array<int, 2>> state) -> int {\n\t\tauto [score, f, pc] = state;\n\t\tint a = score + 300;\n\t\tfor(int x : f) a = 3 * a + x;\n\t\tfor(int c : pc) a = 2 * a + c;\n\t\treturn a;\n\t};\n\tauto unpack = [&](int a) -> tuple<int, array<int, 3>, array<int, 2>> {\n\t\tint score;\n\t\tarray<int, 3> f;\n\t\tarray<int, 2> pc;\n\t\tfor(int i = 1; i >= 0; i--){\n\t\t\tpc[i] = a % 2;\n\t\t\ta /= 2;\n\t\t}\n\t\tfor(int i = 2; i >= 0; i--){\n\t\t\tf[i] = a % 3;\n\t\t\ta /= 3;\n\t\t}\n\t\tscore = a - 300;\n\t\treturn {score, f, pc};\n\t};\n\tint C = 90000;\n\tfor(int mask = 0; mask < 8; mask++){\n\t\tif(mask == 0) continue;\n\t\tvector<num> dp(C, 0);\n\t\t// [score] [f from 0, 1, 2] s[i-2] s[i-1]\n\t\t{\n\t\t\tint score = 0;\n\t\t\tint f0 = 0;\n\t\t\tif(s[0] == s[1]){\n\t\t\t\tf0 = 2;\n\t\t\t\tscore += (s[0] == \'a\' ? 1 : -1) * (((mask >> 0) & 1) ? 1 : 0);\n\t\t\t}\n\t\t\tdp[pack({score, {f0, 1, 2}, {s[0] - \'a\', s[1] - \'a\'}})] += 1;\n\t\t}\n\t\tfor(int c = 2; c < (int)s.size(); c++){\n\t\t\tvector<num> ndp(C, 0);\n\t\t\tfor(char x : {\'a\', \'b\'}){\n\t\t\t\tint xi = x - \'a\';\n\t\t\t\tif(s[c] != \'?\' && s[c] != x) continue;\n\t\t\t\tfor(int state = 0; state < dp.size(); state++){\n\t\t\t\t\tnum cnt = dp[state];\n\t\t\t\t\tif(cnt == 0) continue;\n\t\t\t\t\tauto [score, f, opc] = unpack(state);\n\t\t\t\t\t// array<int, 3> pc {opc[0], opc[1], x - \'a\'};\n\t\t\t\t\tfor(int b = 0; b < 3; b++){\n\t\t\t\t\t\tif(f[b] == 0){\n\t\t\t\t\t\t\tif(opc[0] == opc[1]){\n\t\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscore += (xi == 0 ? 1 : -1) * (((mask >> b) & 1) ? 1 : 0);\n\t\t\t\t\t\t\t\tf[b] = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(f[b] == 1){\n\t\t\t\t\t\t\tif(opc[1] == xi){\n\t\t\t\t\t\t\t\tscore += (xi == 0 ? 1 : -1) * (((mask >> b) & 1) ? 1 : 0);\n\t\t\t\t\t\t\t\tf[b] = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf[b]--;\n\t\t\t\t\t}\n\t\t\t\t\tndp[pack({score, f, {opc[1], xi}})] += cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tfor(int state = 0; state < dp.size(); state++){\n\t\t\tnum cnt = dp[state];\n\t\t\tif(cnt == 0) continue;\n\t\t\tauto [score, f, pc] = unpack(state);\n\t\t\tvector<int> go(3);\n\t\t\tfor(int b = 0; b < 3; b++){\n\t\t\t\tif(f[b] == 2){\n\t\t\t\t\tgo[b] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tvector<int> cur;\n\t\t\t\t\tfor(int x = f[b]; x < 2; x++){\n\t\t\t\t\t\tcur.push_back(pc[x]);\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcur.push_back(s[i] - \'a\');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(cur.size() >= 3 || cur[0] == cur[1]){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tscore += (cur.back() == 0 ? 1 : -1) * (((mask >> b) & 1) ? 1 : 0);\n\t\t\t\t\tif(s.size() == 2 && i == 2) i = 0;\n\t\t\t\t\tgo[b] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = go[go[go[go[0]]]];\n\t\t\tif(!((mask >> r) & 1)) continue;\n\t\t\tint c = r;\n\t\t\tint real_mask = 0;\n\t\t\twhile(true){\n\t\t\t\treal_mask ^= (1 << c);\n\t\t\t\tc = go[c];\n\t\t\t\tif(c == r) break;\n\t\t\t}\n\t\t\tif(real_mask != mask) continue;\n\t\t\tint which;\n\t\t\tif(score > 0){\n\t\t\t\twhich = 0;\n\t\t\t} else if(score == 0){\n\t\t\t\twhich = 1;\n\t\t\t} else if(score < 0){\n\t\t\t\twhich = 2;\n\t\t\t} else assert(false);\n\t\t\tans[which] += cnt;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tstring s;\n\tcin >> s;\n\tvector<num> ans = solve(s);\n\tfor(num x : ans) cout << x << \'\\n\';\n}']","['bitmasks', 'brute force', 'dp', 'games']",3100
https://codeforces.com//contest/1547/problem/G,G. How Many Paths ,You are given a directed graph G which can contain loops edges from a vertex to itself Multi edges are absent in G which means that for all ordered pairs u v exists at most one edge from u to v Vertices are numbered from 1 to n A path from u to v is a sequence of edges such that vertex u is the start of the first edge in the path vertex v is the end of the last edge in the path for all pairs of adjacent edges next edge starts at the vertex that the previous edge ends on We will assume that the empty sequence of edges is a path from u to u For each vertex v output one of four values 0 if there are no paths from 1 to v 1 if there is only one path from 1 to v 2 if there is more than one path from 1 to v and the number of paths is finite 1 if the number of paths from 1 to v is infinite Let s look at the example shown in the figure Then the answer for vertex 1 is 1 there is only one path from 1 to 1 path with length 0 the answer for vertex 2 is 0 there are no paths from 1 to 2 the answer for vertex 3 is 1 there is only one path from 1 to 3 it is the edge 1 3 the answer for vertex 4 is 2 there are more than one paths from 1 to 4 and the number of paths are finite two paths 1 3 3 4 and 1 4 the answer for vertex 5 is 1 the number of paths from 1 to 5 is infinite the loop can be used in a path many times the answer for vertex 6 is 1 the number of paths from 1 to 6 is infinite the loop can be used in a path many times ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n, m;\n        cin >> n >> m;\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            g[x].push_back(y);\n        }\n\n        vector<int> used(n);\n        vector<int> dd(n);\n        vector<int> onc(n);\n\n        function<void(int)> dfs = [&](int v) {\n            used[v] = 1;\n            for (int i : g[v]) {\n                if (used[i] == 1) {\n                    onc[i] = 1;\n                } else if (used[i] == 2) {\n                    dd[i] = 1;\n                } else {\n                    dfs(i);\n                }\n            }\n            used[v] = 2;\n        };\n\n        dfs(0);\n\n        function<void(int)> dfs2 = [&](int v) {\n            for (int i : g[v]) {\n                if (!onc[i]) {\n                    onc[i] = 1;\n                    dfs2(i);\n                }\n            }\n        };\n\n        function<void(int)> dfs3 = [&](int v) {\n            for (int i : g[v]) {\n                if (!dd[i]) {\n                    dd[i] = 1;\n                    dfs3(i);\n                }\n            }\n        };\n\n        for (int i = 0; i < n; i++) {\n            if (onc[i]) {\n                dfs2(i);\n            }\n            if (dd[i]) {\n                dfs3(i);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                cout << ""0 "";\n            } else if (onc[i]) {\n                cout << ""-1 "";\n            } else if (dd[i]) {\n                cout << ""2 "";\n            } else {\n                cout << ""1 "";\n            }\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']","['dfs and similar', 'dp', 'graphs', 'trees']",2100
https://codeforces.com//contest/1215/problem/B,B. The Number of Products,You are given a sequence a 1 a 2 dots a n consisting of n non zero integers i e a i ne 0 You have to calculate two following values the number of pairs of indices l r l le r such that a l cdot a l 1 dots a r 1 cdot a r is negative the number of pairs of indices l r l le r such that a l cdot a l 1 dots a r 1 cdot a r is positive ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,S[1000005];\nint main(){\n\t/*scanf(""%d%d%d%d%d"",&a1,&a2,&k1,&k2,&n);\n\tint low=a1*(k1-1)+a2*(k2-1);\n\tprintf(""%d "",max(n-low,0));\n\tif (k1>k2) swap(k1,k2),swap(a1,a2);\n\tint T1=min(n/k1,a1); a1-=k1; n-=T1*k1;\n\tprintf(""%d"",T1+n/k2);*/\n\tscanf(""%d"",&n);\n\tS[0]=1;\n\tFor(i,1,n){\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tif (x<0) S[i]=S[i-1]^1;\n\t\telse S[i]=S[i-1];\n\t}\n\tint s0=0,s1=0;\n\tFor(i,0,n)\n\t\tif (S[i]==0) ++s0;\n\t\telse ++s1;\n\tprintf(""%lld %lld\\n"",1ll*s0*s1,1ll*n*(n+1)/2-1ll*s0*s1);\n}']","['combinatorics', 'dp', 'implementation']",1400
https://codeforces.com//contest/673/problem/A,A. Bear and Game,Bear Limak likes watching sports on TV He is going to watch a game today The game lasts minutes and there are no breaks Each minute can be either interesting or boring If consecutive minutes are boring then Limak immediately turns TV off You know that there will be interesting minutes Your task is to calculate for how many minutes Limak will watch the game ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <limits.h>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\nbool C[100];\n\nint main() {\n\tscanf(""%d"", &N);\n\twhile(N--) {\n\t\tint t; scanf(""%d"", &t);\n\t\tC[t] = 1;\n\t}\n\n\tint con = 0;\n\tfor(int i = 1; i <= 90; i++) {\n\t\tif(!C[i]) ++con; else con = 0;\n\t\tif(con == 15) {\n\t\t\treturn 0 & printf(""%d\\n"", i);\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", 90);\n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1430/problem/F,F. Realistic Gameplay,Recently you ve discovered a new shooter They say it has realistic game mechanics Your character has a gun with magazine size equal to k and should exterminate n waves of monsters The i th wave consists of a i monsters and happens from the l i th moment of time up to the r i th moments of time All a i monsters spawn at moment l i and you have to exterminate all of them before the moment r i ends you can kill monsters right at moment r i For every two consecutive waves the second wave starts not earlier than the first wave ends though the second wave can start at the same moment when the first wave ends formally the condition r i le l i 1 holds Take a look at the notes for the examples to understand the process better You are confident in yours and your character s skills so you can assume that aiming and shooting are instant and you need exactly one bullet to kill one monster But reloading takes exactly 1 unit of time One of the realistic mechanics is a mechanic of reloading when you reload you throw away the old magazine with all remaining bullets in it That s why constant reloads may cost you excessive amounts of spent bullets You ve taken a liking to this mechanic so now you are wondering what is the minimum possible number of bullets you need to spend both used and thrown to exterminate all waves Note that you don t throw the remaining bullets away after eradicating all monsters and you start with a full magazine ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=2005;\nint n,k;\nint l[N],r[N],a[N];\nll f[N];\nint main(){\n\tscanf(""%d%d"",&n,&k);\n\tFor(i,1,n) scanf(""%d%d%d"",&l[i],&r[i],&a[i]);\n\tmemset(f,33,sizeof(f));\n\tf[0]=0;\n\tll ans=1ll<<60;\n\tFor(i,1,n){\n\t\tint nT=l[i];\n\t\tll cost=k,Bul=k;\n\t\tFor(j,i,n){\n\t\t\tif (!Bul&&l[j]!=r[j-1])\tBul=k,cost+=k;\n\t\t\t//cout<<i<<\' \'<<j<<\' \'<<Bul<<\' \'<<cost<<endl; \n\t\t\tif (Bul+1ll*(r[j]-l[j])*k<a[j]) break;\n\t\t\tint v=min(Bul,1ll*a[j]),rem=a[j];\n\t\t\tBul-=v; rem-=v;\n\t\t\tint round=(rem+k-1)/k;\n\t\t\tcost+=1ll*round*k;\n\t\t\tBul+=1ll*round*k;\n\t\t\tBul-=rem;\n\t\t\t//cout<<i<<\' \'<<j<<\' \'<<Bul<<\' \'<<cost<<\' \'<<round<<endl;\n\t\t\tif (r[j]!=l[j+1]||round!=r[j]-l[j]){\n\t\t\t\tif (j==n) ans=min(ans,f[i-1]+cost-Bul);\n\t\t\t\tf[j]=min(f[j],f[i-1]+cost);\n\t\t\t}\n\t\t\tif (round!=r[j]-l[j]&&!Bul)\n\t\t\t\tBul+=k,cost+=k;\n\t\t}\n\t}\n\tif (ans>1ll<<58)\n\t\tans=-1;\n\tcout<<ans<<endl;\n}']","['dp', 'greedy']",2600
https://codeforces.com//contest/996/problem/A,A. Hit the Lottery,Allen has a LOT of money He has n dollars in the bank For security reasons he wants to withdraw it in cash we will not disclose the reasons here The denominations for dollar bills are 1 5 10 20 100 What is the minimum number of bills Allen could receive after withdrawing his entire balance ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <stdlib.h>\n#include <set>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <regex>\n#include <math.h>\n#include <map>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <array>\n#include <valarray>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\ntypedef int integer;\ntypedef array<int, 2> hv;\n#define double long double\n#define int long long\n#define make(type, x) type x; cin>>x\n#define make2(type, x, y) type x, y; cin>>x>>y\n#define make3(type, x, y, z) type x, y, z; cin>>x>>y>>z\n#define make4(type, x, y, z, q) type x, y, z, q; cin>>x>>y>>z>>q\n#define ALL(x) (x).begin(), (x).end()\n#define FORIT(p) for(auto it = p.begin(); it != p.end(); it++)\n#define FOR(b) for(int i = 0; i <(b); ++i)\n#define VI vector<int>\n#define VVI vector<vector<int>>\n#define PII pair<int, int>\n#define PPII pair<PII, int>\n#define M7 1000000007\n#define M9 1000000009\n\n\n\n\nvoid Solve() {\n\tmake(int, n);\n\tint ans = n / 100;\n\tn %= 100;\n\tans += n / 20;\n\tn %= 20;\n\tans += n / 10;\n\tn %= 10;\n\tans += n / 5;\n\tn %= 5;\n\tcout << ans + n;\n\n}\n\n\n\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie();\n#if  _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tSolve();\n\twhile (!cin.eof()) {\n\t\tstring s = ""_"";\n\t\tdo getline(cin, s);\n\t\twhile (!cin.eof() && !s.empty());\n\t\tif (cin.eof()) return 0;\n\t\tFOR(3) cout << endl;\n\t\tSolve();\n\t}\n#else\n\tSolve();\n#endif\n\treturn 0;\n\t}']","['dp', 'greedy']",800
https://codeforces.com//contest/1239/problem/F,"F. Swiper, no swiping ",I m the Map I m the Map I m the MAP MapIn anticipation of new adventures Boots wanted to do a good deed After discussion with the Map and Backpack they decided to gift Dora a connected graph After a long search Boots chose t graph s variants which Dora might like However fox Swiper wants to spoil his plan The Swiper knows that Dora now is only able to count up to 3 so he has came up with a following idea He wants to steal some non empty set of vertices so that the Dora won t notice the loss He has decided to steal some non empty set of vertices so that after deletion of the stolen vertices and edges adjacent to them every vertex wouldn t change it s degree modulo 3 The degree of a vertex is the number of edges it is adjacent to It would ve been suspicious to steal all the vertices so Swiper needs another plan Boots are sure that the crime can not be allowed However they are afraid that they won t be able to handle this alone So Boots decided to ask for your help Please determine for every graph s variant whether the Swiper can perform the theft or not ,"['#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n#include <complex>\n \n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> pii;\n \nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n \nconst int N = 1000001;\nint n,m,x,y;\nvector<int> v[N];\n \nqueue<int> q;\nint dis[N];\nint prv[N];\nbool vst[N];\nbool ans[N]; \nint idx;\n \npii Z={0,0};\npii dfs(int cur, int prv, int h) {\n\tif(cur==h) return Z;\n\tif(vst[cur]) return {cur, prv};\n\tvst[cur]=true;\n\tfor(int nxt : v[cur]) {\n\t\tif(nxt==prv) continue;\n\t\tpii temp=dfs(nxt, cur, h);\n\t\tif(temp!=Z) return temp;\n\t}\n\treturn Z;\n}\nvoid print();\nbool findCycle(int h) {\n\tfor(int i=1; i<=n; i++) vst[i]=false;\n\tfor(int i=1; i<=n; i++) {\n\t\tif(vst[i]) continue;\n\t\tpii c=dfs(i,0,h);\n\t\tif(c!=Z){\n\t\t\t//i->c min path\n\t\t\tint s=c.first, e=c.second;\n\t\t\tfor(int j=1; j<=n; j++) dis[j]=INF;\n\t\t\tdis[s]=0;\n\t\t\tq.push(s);\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint cur=q.front(); q.pop();\n\t\t\t\tfor(int nxt : v[cur]) {\n\t\t\t\t\tif(cur==s && nxt==e) continue;\n\t\t\t\t\tif(cur==h) continue;\n\t\t\t\t\tif(dis[nxt]==INF) dis[nxt]=dis[cur]+1, prv[nxt]=cur, q.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=e; j!=s; j=prv[j]) ans[j]=true;\n\t\t\tans[s]=true;\n\t\t\tprint();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid print() {\n\tprintf(""Yes\\n"");\n\tint cnt=0;\n\tfor(int i=1; i<=n; i++) if(!ans[i]) cnt++;\n\tprintf(""%d\\n"", cnt);\n\tfor(int i=1; i<=n; i++) if(!ans[i]) printf(""%d "", i);\n\tprintf(""\\n"");\n}\nvoid mark(int cur) {\n\tif(ans[cur]) return;\n\tans[cur]=true;\n\tfor(int nxt : v[cur]) mark(nxt);\n}\nvoid unmark(int cur, int x, int y) {\n\tif(cur==x || cur==y) return;\n\tif(!ans[cur]) return;\n\tans[cur]=false;\n\tfor(int nxt : v[cur]) unmark(nxt,x,y);\n}\nvoid case1() {\n\tfor(int i=1; i<=n; i++) {\n\t\tif(sz(v[i])%3==1) {\n\t\t\tfor(int i=1; i<=n; i++) dis[i]=INF;\n\t\t\tdis[i]=0;\n\t\t\tq.push(i);\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint cur=q.front(); q.pop();\n\t\t\t\tfor(int nxt : v[cur]) if(dis[nxt]==INF) dis[nxt]=dis[cur]+1, prv[nxt]=cur, q.push(nxt);\n\t\t\t}\n\t\t\t\n\t\t\tint tt=INF;\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t    if(i!=j && sz(v[j])%3==1) tt=min(tt, dis[j]);\n\t\t\t}\n\t\t\tif(tt==n-1) {printf(""No\\n""); return;}\n\t\t\t\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\tif(i!=j && sz(v[j])%3==1 && dis[j]==tt) {\n\t\t\t\t\t\n\t\t\t\t\tfor(int c=j; c!=i; c=prv[c]) {\n\t\t\t\t\t\tans[c]=true;\n\t\t\t\t\t}\n\t\t\t\t\tans[i]=true;\n\t\t\t\t\tprint();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(""No\\n"");\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid case2() {\n\tfor(int i=1; i<=n; i++) if(sz(v[i])%3==1) {idx=i; break;}\n\n\tif(findCycle(idx)) return;\n\n\tfor(int i=1; i<=n; i++) {\n\t\tif(i==idx) continue;\n\t\tif(sz(v[i])>3) {\n\t\t\tfor(int i=1; i<=n; i++) ans[i]=true;\n\t\t\tint c=0;\n\t\t\tfor(int j=0; c<3; j++) {\n\t\t\t\tif(v[i][j]==idx) continue;\n\t\t\t\tunmark(v[i][j], i, idx);\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tprint();\n\t\t\treturn;\n\t\t}\n\t}\n\tif(sz(v[idx])==4) {printf(""No\\n""); return;} //clear\n\tans[idx]=true;\n\tint t=0;\n\tfor(int i=0; t<2; i++) {\n\t\tif(ans[v[idx][i]]) continue;\n\t\tmark(v[idx][i]);\n\t\tt++;\n\t}\n\tprint();\n}\nvoid case3() {\n\tbool flag=true;\n\tfor(int i=1; i<=n; i++) if(sz(v[i])!=2) {flag=false; break;}\n\tif(flag) {printf(""No\\n""); return;}\n\tfindCycle(0);\n}\nvoid proc() {\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i=1; i<=n; i++) v[i].clear(), ans[i]=false;\n\tfor(int i=0; i<m; i++) {\n\t\tscanf(""%d%d"", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\n\tif(n==1) {printf(""No\\n""); return;}\n\tfor(int i=1; i<=n; i++) {\n\t\tif(sz(v[i])%3==0) {\n\t\t\tans[i]=true;\n\t\t\tprint();\n\t\t\treturn;\n\t\t}\n\t}\n \n\tint cnt=0;\n\tfor(int i=1; i<=n; i++) if(sz(v[i])%3==1) cnt++;\n\tif(cnt>1) case1();\n\telse if(cnt==1) case2();\n\telse case3();\n\t\n}\nint main(void){\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) proc();\n}\n']","['graphs', 'implementation']",3400
https://codeforces.com//contest/1474/problem/A,A. Puzzle From the Future,In the year Mike found two binary integers a and b of length n both of them are written only by digits 0 and 1 that can have leading zeroes In order not to forget them he wanted to construct integer d in the following way he creates an integer c as a result of bitwise summing of a and b so c may have one or more 2 s For example the result of bitwise summing of 0110 and 1101 is 1211 or the sum of 011000 and 011000 is 022000 after that Mike replaces equal consecutive digits in c by one digit thus getting d In the cases above after this operation 1211 becomes 121 and 022000 becomes 020 so d won t have equal consecutive digits Unfortunately Mike lost integer a before he could calculate d himself Now to cheer him up you want to find integer a of length n such that d will be Maximum possible as integer means that 102 21 012 101 021 21 and so on ,"[""#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n\tlong long n,i;\n\tstring str;\n\tcin>>n>>str;\n\tlong long b[n],cur=1+str[0]-'0';\n\tb[0]=1;\n\tfor(i=1;i<n;i++){\n\t\tif(cur==0){\n\t\t\tb[i]=1;\n\t\t}\n\t\telse if(cur==1){\n\t\t\tif(str[i]=='1'){\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i]=0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(str[i]=='0'){\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i]=0;\n\t\t\t}\n\t\t}\n\t\tcur=(str[i]-'0')+b[i];\n\t}\n\tfor(i=0;i<n;i++)\n\t\tcout<<b[i];\n\tcout<<endl;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlong long t=1;\n\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}""]",['greedy'],800
https://codeforces.com//contest/1884/problem/E,E. Hard Design,Consider an array of integers b 0 b 1 ldots b n 1 Your goal is to make all its elements equal To do so you can perform the following operation several possibly zero times Pick a pair of indices 0 le l le r le n 1 then for each l le i le r increase b i by 1 i e replace b i with b i 1 After performing this operation you receive r l 1 2 coins The value f b is defined as a pair of integers cnt cost where cnt is the number of operations required to make all elements of the array equal and cost is the total number of coins you can receive among all possible ways to make all elements equal within cnt operations In other words first you need to minimize the number of operations second you need to maximize the total number of coins you receive You are given an array of integers a 0 a 1 ldots a n 1 Please find the value of f for all cyclic shifts of a Formally for each 0 le i le n 1 you need to do the following Let c j a j i pmod n for each 0 le j le n 1 Find f c Since cost can be very large output it modulo 10 9 7 Please note that under a fixed cnt you need to maximize the total number of coins cost not its remainder modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 65536, stdin), p1 == p2) ? EOF : *p1 ++)\n#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++\n#define putchar(x) (p3 - obuf < 1000000) ? (*p3++ = x) : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x)\nusing namespace std;\nstatic char buf[29999999], *p1 = buf, *p2 = buf, obuf[29999999], *p3 = obuf;\ntemplate <typename item>\ninline void read (register item &x) {\n    x = 0;\n\tregister char c = getchar();\n    while (c < \'0\' || c > \'9\') c = getchar();\n    while (c >= \'0\' && c <= \'9\') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n}\nstatic char cc[15];\ntemplate <typename item>\ninline void print (register item x) {\n\tregister int len = 0;\n\tdo cc[len++] = x % 10 + \'0\', x /= 10; while (x);\n\twhile (len--) putchar(cc[len]);\n}\nint N;ll A[2000006];\nconst ll inf=1e16,mod=1e9+7;\nstruct node{int x,y;ll cnt;}B[4000006];\nint tot;ll d[2000006];\nint stk[2000005],tail;\nvoid add(ll &x,const ll y){\n\tif((x+=y)>=mod)x-=mod;\n}\nbool cmp(node a,node b){\n\treturn a.x<b.x;\n}\nbool cmp1(node a,node b){\n\treturn a.y>b.y;\n}\nstruct BIT{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tv%=mod;\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))add(val[i],v);\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))add(res,val[i]);\n\t\treturn res;\n\t}\n}b0,b2,b3;\nstruct BIT1{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))val[i]+=v;\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))res+=val[i];\n\t\treturn res;\n\t}\n}B1;\nll res1[1000005],res2[1000005],sum[2000005];\nvoid solve(){\n\tread(N);ll mx=0ll;tot=0;\n\tfor(int i=1;i<=N;++i)read(A[i]),mx=max(mx,A[i]),res1[i]=res2[i]=0ll;\n\tif(N==1){print(0);putchar(\' \');print(0);putchar(\'\\n\');return ;}\n\tA[0]=inf;for(int i=N+1;i<=2*N;++i)A[i]=A[i-N];\n\tfor(int i=1;i<2*N;++i){\n\t\tsum[i]=sum[i-1];\n\t\tif(A[i+1]<A[i])sum[i]+=A[i]-A[i+1];\n\t}\n    for(int i=0;i<2*N;++i)d[i]=A[i]-A[i+1];tail=0;\n    for(int i=0;i<2*N;++i){\n    \tif(d[i]<0ll){\n    \t\twhile(d[i]<0ll){\n    \t\t\tif(d[stk[tail]]<-d[i]){\n    \t\t\t\tB[++tot]=node{stk[tail],i,d[stk[tail]]};\n    \t\t\t\td[i]+=d[stk[tail]];d[stk[tail--]]=0ll;\n\t\t\t\t}else {\n\t\t\t\t\tB[++tot]=node{stk[tail],i,-d[i]};\n\t\t\t\t\td[stk[tail]]+=d[i];d[i]=0ll;\n\t\t\t\t\tif(!d[stk[tail]])--tail;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d[i]>0ll)stk[++tail]=i; \n\t}\n\twhile(tail){\n\t\tB[++tot]=node{stk[tail],2*N,d[stk[tail]]};\n\t\td[stk[tail--]]=0ll;\n\t}\n    for(int i=1;i<=N;++i)res1[i]=sum[i+N-2]-sum[i-1]+mx-A[i];\n    b0.init();b2.init();b3.init();B1.init();\n\tsort(B+1,B+tot+1,cmp);int nd=1;\n    for(int i=0;i<=2*N;++i){\n    \twhile(nd<=tot&&B[nd].x<=i){\n    \t\tb0.modify(B[nd].y,1ll*(B[nd].y-B[nd].x)*(B[nd].y-B[nd].x)%mod*(B[nd].cnt%mod)%mod);\n    \t\tB1.modify(B[nd].y,B[nd].cnt);b2.modify(B[nd].y,1ll*B[nd].y*B[nd].cnt%mod);\n    \t\tb3.modify(B[nd].y,1ll*B[nd].y*B[nd].y%mod*B[nd].cnt%mod); ++nd;\n\t\t}\n    \tif(i+1<=N){\n    \t\tres2[i+1]=(res2[i+1]+mod-(b0.query(i+N-1)+mod-b0.query(i))%mod)%mod;\n    \t\tll allcnt=B1.query(i+N-1)-B1.query(i);res2[i+1]=(res2[i+1]+1ll*N*N%mod*((mx-A[i+1]-allcnt)%mod)%mod)%mod;\n\t\t\tallcnt%=mod;res2[i+1]=(res2[i+1]+1ll*i*i%mod*allcnt)%mod;\n\t\t\tll c3=b3.query(i+N-1)-b3.query(i)+mod,c2=b2.query(i+N-1)-b2.query(i)+mod;c3%=mod;c2%=mod;\n\t\t\tres2[i+1]=(res2[i+1]+mod-2ll*i*c2%mod)%mod;\n\t\t\tres2[i+1]=(res2[i+1]+c3)%mod;   \n\t\t} \n\t\tif(i-(N-2)<=N&&i-(N-2)>=1)res2[i-(N-2)]=(res2[i-(N-2)]+b0.query(i)-b0.query(i-(N-2)-1)+mod)%mod;\n\t} nd=1;B1.init();b2.init();b3.init();sort(B+1,B+tot+1,cmp1);\n\tfor(int i=2*N;i>=1;--i){\n\t\twhile(nd<=tot&&B[nd].y>=i){\n\t\t\tif(B[nd].x){\n\t\t\t\tB1.modify(B[nd].x,B[nd].cnt); b2.modify(B[nd].x,1ll*B[nd].x*B[nd].cnt%mod);\n\t\t\t    b3.modify(B[nd].x,1ll*B[nd].x*B[nd].x%mod*B[nd].cnt%mod);\n\t\t\t}\n\t\t\t++nd; \n\t\t}\n\t\tif(i-(N-1)<=N&&i-(N-1)>=1){\n\t\t\tint l=i-(N-1);\n\t\t\tll c1=B1.query(i-1)-B1.query(l-1),c2=b2.query(i-1)-b2.query(l-1)+mod,c3=b3.query(i-1)-b3.query(l-1)+mod;\n\t\t//\tcout<<l<<"" ""<<c1<<endl;\n\t\t\tc2%=mod;c3%=mod;c1%=mod;\n\t\t    res2[l]=(res2[l]+1ll*i*i%mod*c1%mod)%mod;\n\t\t    res2[l]=(res2[l]-2ll*i*c2%mod+mod)%mod;\n\t\t    res2[l]=(res2[l]+c3)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tprint(res1[i]);putchar(\' \');\n\t\tprint(res2[i]);putchar(\'\\n\');\n\t}\n}\nint main(){\n\tint t;read(t);\n\twhile(t--)solve(); \n\tfwrite(obuf, p3 - obuf, 1, stdout);\n    return 0;\n}']","['greedy', 'implementation', 'math']",2800
https://codeforces.com//contest/568/problem/D,D. Sign Posts,One Khanate had a lot of roads and very little wood Riding along the roads was inconvenient because the roads did not have road signs indicating the direction to important cities The Han decided that it s time to fix the issue and ordered to put signs on every road The Minister of Transport has to do that but he has only signs Help the minister to solve his problem otherwise the poor guy can lose not only his position but also his head More formally every road in the Khanate is a line on the plane given by an equation of the form and are not equal to 0 at the same time You are required to determine whether you can put signs in at most points so that each road had at least one sign installed ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#ifdef WIN32\n\t#define LLD ""%I64d""\n#else\n\t#define LLD ""%lld""\n#endif\n\n#define pb push_back\n#define all(x) begin(x), end(x)\n\nconst int MAXIT[6] = {0, 1, 6, 13, 20, 25};\n\nstruct line\n{\n    int a, b, c;\n    int id;\n};\n\nvector<line> l;\nint n, k;\nvector<pair<int, int>> answer;\n\nvoid solve(vector<line> &l, int k)\n{\n    int n = l.size();\n    if (k >= (int)n)\n    {\n        for (int i = 0; i < (int)n; i++) answer.pb({l[i].id, -2});\n        printf(""YES\\n"");\n        printf(""%d\\n"", answer.size());\n        for (auto t : answer) printf(""%d %d\\n"", t.first + 1, t.second + 1);\n        exit(0);\n    }\n    if (k == 0) return;\n    for (int IT = 0; IT < MAXIT[k]; IT++)\n    {\n        int wh1 = rand() % n;\n        int wh2 = rand() % (n - 1);\n        if (wh2 >= wh1) wh2++;\n        auto &l1 = l[wh1];\n        auto &l2 = l[wh2];\n        if ((ll)l1.a * l2.b == (ll)l2.a * l1.b) continue;\n        vector<line> next;\n        for (auto &t : l) if ((ll)l1.a * l2.b * t.c + (ll)l1.b * l2.c * t.a + (ll)l1.c * l2.a * t.b !=\n                             (ll)l1.c * l2.b * t.a + (ll)l1.b * l2.a * t.c + (ll)l1.a * l2.c * t.b) next.pb(t);\n        if ((int)next.size() > max((double)k - 1, n * (1.0 - 1.0 / (2 * k)))) continue;\n        answer.pb({l1.id, l2.id});\n        solve(next, k - 1);\n        answer.pop_back();\n    }\n}\n\nint main()\n{\n    scanf(""%d%d"", &n, &k);\n    l.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(""%d%d%d"", &l[i].a, &l[i].b, &l[i].c);\n        l[i].id = i;\n    }\n    solve(l, k);\n    printf(""NO\\n"");\n    return 0;\n}\n']","['brute force', 'geometry', 'math']",2800
https://codeforces.com//contest/1316/problem/A,A. Grade Allocation,n students are taking an exam The highest possible score at this exam is m Let a i be the score of the i th student You have access to the school database which stores the results of all students You can change each student s score as long as the following conditions are satisfied All scores are integers 0 leq a i leq m The average score of the class doesn t change You are student 1 and you would like to maximize your own score Find the highest possible score you can assign to yourself such that all conditions are satisfied ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nint t;\nint n, m, x;\nint main( ) {\n\tscanf(""%d"", &t);\n\twhile (t --) {\n\t\tscanf(""%d %d"", &n, &m);\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(""%d"", &x);\n\t\t\tsum += x;\n\t\t}\n\t\tprintf(""%d\\n"", min(sum, m));\n\t}\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/370/problem/D,D. Broken Monitor,Innocentius has a problem his computer monitor has broken Now some of the pixels are dead that is they are always black As consequence Innocentius can t play the usual computer games He is recently playing the following game with his younger brother Polycarpus Innocentius is touch typing a program that paints a white square one pixel wide frame on the black screen As the monitor is broken some pixels that should be white remain black Polycarpus should look at what the program displayed on the screen and guess the position and size of the frame Innocentius has painted Polycarpus doesn t like the game but Innocentius persuaded brother to play as the game is good for the imagination and attention Help Polycarpus automatize his part in the gaming process Write the code that finds such possible frame that the frame s width is 1 pixel the frame doesn t go beyond the borders of the screen all white pixels of the monitor are located on the frame of all frames that satisfy the previous three conditions the required frame must have the smallest size Formally a square frame is represented by such pixels of the solid square that are on the square s border that is are not fully surrounded by the other pixels of the square For example if the frame s size is then it consists of 8 pixels if its size is then it contains 4 pixels and if then the frame is reduced to a single pixel ,"['#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file """"\n#define N 100500\n\nchar a[2300][2300];\n       \nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        scanf(""%s"", a[i]);\n    int l = inf, r = -inf, u = inf, d = -inf;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            if (a[i][j] == \'w\')\n            {\n                l = min(l, j);\n                r = max(r, j);\n                u = min(u, i);\n                d = max(d, i);\n            }\n    if (l == inf)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    bool L = 0, R = 0, U = 0, D = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (i == u && j > l && j < r && a[i][j] == \'w\') U = 1;\n            if (i == d && j > l && j < r && a[i][j] == \'w\') D = 1;\n            if (j == l && i > u && i < d && a[i][j] == \'w\') L = 1;\n            if (j == r && i > u && i < d && a[i][j] == \'w\') R = 1;\n        }\n    int s = max(r - l, d - u);\n    if (l == r || u == d)\n    {\n        if (l == r)\n        {\n            if (r - s >= 0) l = r - s;\n            else if (l + s < m) r = l + s;\n            else if (L || R)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                l = max(0, r - s);\n                r = min(m - 1, l + s);\n                if (r - l != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n        else\n        {\n            if (d - s >= 0) u = d - s;\n            else if (u + s < n) d = u + s;  \n            else if (U || D)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                u = max(0, d - s);\n                d = min(n - 1, u + s);\n                if (d - u != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    else\n    {                         \n    if (U && D && d - u != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (L && R && r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (U && d - u != s) d = s + u;\n    if (D && d - u != s) u = d - s;\n    if (L && r - l != s) r = l + s;\n    if (R && r - l != s) l = r - s;\n    if (!U && !D && d - u != s)\n    {\n        u = max(0, d - s);\n        d = min(n - 1, u + s);\n    }\n    if (!L && !R && r - l != s)\n    {\n        l = max(0, r - s);\n        r = min(m - 1, l + s);\n    }\n    if (u < 0 || l < 0 || d >= n || r >= m)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (d - u != s || r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if ((i == u || i == d) && j >= l && j <= r)\n            {\n                if (a[i][j] != \'w\') a[i][j] = \'+\';\n            }\n            else if (i >= u && i <= d && (j == l || j == r))\n            {\n                if (a[i][j] != \'w\') a[i][j] = \'+\';\n            }\n            else if (a[i][j] == \'w\')\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    for (int i = 0; i < n; i++)\n        printf(""%s\\n"", a[i]);\n\n\n\n    return 0;\n}']","['brute force', 'constructive algorithms', 'greedy', 'implementation']",2100
https://codeforces.com//contest/574/problem/A,A. Bear and Elections,Limak is a grizzly bear who desires power and adoration He wants to win in upcoming elections and rule over the Bearland There are candidates including Limak We know how many citizens are going to vote for each candidate Now th candidate would get votes Limak is candidate number To win in elections he must get strictly more votes than any other candidate Victory is more important than everything else so Limak decided to cheat He will steal votes from his opponents by bribing some citizens To bribe a citizen Limak must give him or her one candy citizens are bears and bears like candies Limak doesn t have many candies and wonders how many citizens does he have to bribe ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vpi> vvpi;\n\nint main(){\n  int n;\n  cin>>n;\n  int a[n];\n  for(int i = 0;i < n;++i) cin>>a[i];\n  int r = 0;\n  while(true){\n    int  maxi = 0; \n    for(int i = 1;i < n;++i){\n      if(a[i] >= a[maxi]) maxi = i;\n    }\n    if(maxi == 0) break;\n    ++r;\n    ++a[0];\n    --a[maxi];\n  }\n  cout<<r<<endl;\n}']","['greedy', 'implementation']",1200
https://codeforces.com//contest/1843/problem/F1,F1. Omsk Metro  simple version ,As is known Omsk is the capital of Berland Like any capital Omsk has a well developed metro system The Omsk metro consists of a certain number of stations connected by tunnels and between any two stations there is exactly one path that passes through each of the tunnels no more than once In other words the metro is a tree To develop the metro and attract residents the following system is used in Omsk Each station has its own weight x in 1 1 If the station has a weight of 1 then when the station is visited by an Omsk resident a fee of 1 burle is charged If the weight of the station is 1 then the Omsk resident is rewarded with 1 burle Omsk Metro currently has only one station with number 1 and weight x 1 Every day one of the following events occurs You are a friend of Alex so your task is to answer Alex s questions daggerSubsegment continuous sequence of elements ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m,q;\nint dmx[N],dmn[N];\nint emx[N],emn[N];\nint val[N];\nvoid solve()\n{\n\tn=read();\tint cnt=1;\n\temn[1]=0;\temx[1]=1;\n\tdmn[1]=0;\tdmx[1]=1;\n\tval[1]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tchar opt;\n\t\tcin>>opt;\n\t\tif(opt==\'+\')\n\t\t{\n\t\t\tint x=read();\tint y=++cnt;\tint z=read();\n\t\t\tval[y]=val[x]+z;\n\t\t\tdmn[y]=min(dmn[x],val[y]);\n\t\t\tdmx[y]=max(dmx[x],val[y]);\n\t\t\t\n\t\t\temn[y]=min(emn[x],val[y]-dmx[y]);\n\t\t\temx[y]=max(emx[x],val[y]-dmn[y]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=read();\tint y=read();\tint z=read();\n\t\t\tif(emn[y]<=z&&z<=emx[y])\tputs(""YES"");\n\t\t\telse\tputs(""NO""); \n\t\t}\n\t}\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}\n']","['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'math', 'trees']",1800
https://codeforces.com//contest/551/problem/A,A. GukiZ and Contest,Professor GukiZ likes programming contests He especially likes to rate his students on the contests he prepares Now he has decided to prepare a new contest In total students will attend and before the start every one of them has some positive integer rating Students are indexed from to Let s denote the rating of th student as After the contest ends every student will end up with some positive integer position GukiZ expects that his students will take places according to their ratings He thinks that each student will take place equal to In particular if student has rating strictly lower then student will get the strictly better position than and if two students have equal ratings they will share the same position GukiZ would like you to reconstruct the results by following his expectations Help him and determine the position after the end of the contest for each of his students if everything goes as expected ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n\n#define pb push_back\n#define mp make_pair\n#define LL long long\n#define LD long double\n#define maxlongint 2147483647\n\nusing namespace std;\n\nconst int inf = 999999999;\nconst int mod = 1000000007;\n\ninline int Getint()\n{\n\tchar ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') ch = getchar();\n\tint ret = 0;\n\twhile (ch >= \'0\' && ch <= \'9\') ret = ret * 10 + ch - \'0\', ch = getchar();\n\treturn ret;\n}\n\nint a[2010];\nint n;\n\nint main()\n{\n\tn = Getint();\n\tfor (int i = 1; i <= n; i++) a[i] = Getint();\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint ans = 0;\n\t\tfor (int j = 1; j <= n; j++) if (a[j] > a[i]) ans++;\n\t\tprintf(""%d "", ans + 1);\n\t}\n\tprintf(""\\n"");\n\treturn 0;\n}']","['brute force', 'implementation', 'sortings']",800
https://codeforces.com//contest/1019/problem/A,A. Elections,As you know majority of students and teachers of Summer Informatics School live in Berland for the most part of the year Since corruption there is quite widespread the following story is not uncommon Elections are coming You know the number of voters and the number of parties n and m respectively For each voter you know the party he is going to vote for However he can easily change his vote given a certain amount of money In particular if you give i th voter c i bytecoins you can ask him to vote for any other party you choose The United Party of Berland has decided to perform a statistical study you need to calculate the minimum number of bytecoins the Party needs to spend to ensure its victory In order for a party to win the elections it needs to receive strictly more votes than any other party ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 3001;\nint n,m;\nvector<int> d[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m;\n  int mam = 0;\n  R(i,n){\n    int a,b;\n    cin >> a >> b;\n    if(a == 1){\n      mam ++;\n    }else{\n      d[a-2].PB(b);\n    }\n  }\n  R(i,m){\n    sort(ALL(d[i]),greater<int>());\n  }\n  int res = 1e18;\n  R(i,n+1)if(i){\n    vector<int> rest;\n    int ak_mam = mam;\n    int wyn = 0;\n    R(j,m){\n      R(k,min(SZ(d[j]),i - 1)){\n        rest.PB(d[j][k]);\n      }\n      for(int k = i - 1; k < SZ(d[j]); k ++){\n        wyn += d[j][k];\n        ak_mam ++;\n      }\n    }\n    if(ak_mam < i){\n      sort(ALL(rest));\n      R(j,i - ak_mam){\n        wyn += rest[j];\n      }\n    }\n    debug(i,wyn);\n    mini(res,wyn);\n  }\n  cout << res << ""\\n"";\n}\n']","['brute force', 'greedy']",1700
https://codeforces.com//contest/1625/problem/B,B. Elementary Particles,Martians are actively engaged in interplanetary trade Olymp City the Martian city known for its spaceport has become a place where goods from all the corners of our Galaxy come To deliver even more freight from faraway planets Martians need fast spaceships A group of scientists conducts experiments to build a fast engine for the new spaceship In the current experiment there are n elementary particles the i th of them has type a i Denote a subsegment of the particle sequence a 1 a 2 dots a n as a sequence a l a l 1 dots a r for some left bound l and right bound r 1 le l le r le n For instance the sequence 1 4 2 8 5 7 for l 2 and r 4 has the sequence 4 2 8 as a subsegment Two subsegments are considered different if at least one bound of those subsegments differs Note that the subsegments can be equal as sequences but still considered different For example consider the sequence 1 1 1 1 1 and two of its subsegments one with l 1 and r 3 and another with l 2 and r 4 Both subsegments are equal to 1 1 1 but still considered different as their left and right bounds differ The scientists want to conduct a reaction to get two different subsegments of the same length Denote this length k The resulting pair of subsegments must be i e for i 1 le i le k it must be true that the types of particles on the i th position are the same for these two subsegments For example the pair 1 7 3 and 4 7 8 is harmonious as both subsegments have 7 on the second position The pair 1 2 3 and 3 1 2 is not harmonious The longer are harmonious subsegments the more chances for the scientists to design a fast engine So they asked you to calculate the maximal possible length of harmonious pair made of different subsegments ,"['#include <bits/stdc++.h>\n#define rep(i,n) for (i=1;i<=(n);i++)\nusing namespace std;\nint pre[155555],n,i,t;\nint main(){\n\tcin>>t;\n\twhile(t--){\n\t\tint ans=-1;\n\t\tmemset(pre,0,sizeof(pre));\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tint x;cin>>x;\n\t\t\tif(pre[x]){\n\t\t\t\tans=max(ans,pre[x]+(n-i));\n\t\t\t}\n\t\t\tpre[x]=i;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n']","['brute force', 'greedy', 'sortings']",1100
https://codeforces.com//contest/187/problem/B,B. AlgoRace,PMP is getting a warrior He is practicing a lot but the results are not acceptable yet This time instead of programming contests he decided to compete in a car racing to increase the spirit of victory He decides to choose a competition that also exhibits algorithmic features AlgoRace is a special league of car racing where different teams compete in a country of cities Cities are numbered through Every two distinct cities in the country are connected with one bidirectional road Each competing team should introduce one driver and a set of cars The competition is held in rounds In th round drivers will start at city and finish at city Drivers are allowed to change their cars at most times Changing cars can take place in any city in no time One car can be used multiple times in one round but total number of changes should not exceed Drivers can freely choose their path to destination PMP has prepared type of purpose built cars Beside for PMP s driving skills depending on properties of the car and the road a car traverses each road in each direction in different times PMP Warriors wants to devise best strategies of choosing car and roads in each round to maximize the chance of winning the cup For each round they want to find the minimum time required to finish it ,"['#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <set>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\n\n#define pb push_back\n#define mp make_pair\n#define sz(A) int((A).size())\n#define y1 Y1\n#define y2 Y2\n\nconst int INF = int(1e9), N = 65;\n\nint timer[N][N][N], dp[N][N][N];\n\nint main() {\n    int n, m, r;\n    scanf(""%d%d%d"", &n, &m, &r);\n    for (int i = 0; i < m; i++) {\n        for (int j = 1; j <= n; j++)\n            for (int k = 1; k <= n; k++)\n                scanf(""%d"", &timer[i][j][k]);\n                for (int f = 1; f <= n; f++)\n        for (int j = 1; j <= n; j++)\n            for (int k = 1; k <= n; k++)\n                    timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);      \n    }\n\n    for (int iter = 0; iter < n; iter++)\n        for (int j = 1; j <= n; j++)\n            for (int k = 1; k <= n; k++)\n                dp[iter][j][k] = INF;       \n\n    for (int i = 0; i < m; i++) \n        for (int j = 1; j <= n; j++)\n            for (int k = 1; k <= n; k++)\n                dp[0][j][k] = min(dp[0][j][k], timer[i][j][k]);\n\n    for (int iter = 1; iter < n; iter++) {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++) \n                dp[iter][i][j] = dp[iter - 1][i][j];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++) {\n                if (i != j) {\n                    for (int k = 1; k <= n; k++) {\n                        if (k != i && k != j)   \n                            dp[iter][i][j] = min(dp[iter][i][j], dp[iter - 1][i][k] + dp[0][k][j]);\n                    }\n                }\n            }\n    }\n\n    for (int i = 0; i < r; i++) {\n        int s, t, k;\n        scanf(""%d%d%d"", &s, &t, &k);        \n        k = min(n - 1, k);\n        printf(""%d\\n"", dp[k][s][t]);\n    }\n                                                                                                                \n    return 0;\n}']","['dp', 'shortest paths']",1800
https://codeforces.com//contest/1253/problem/A,A. Single Push,You re given two arrays a 1 dots n and b 1 dots n both of the same length n In order to perform a you have to choose three integers l r k satisfying 1 le l le r le n and k 0 Then you will add k to elements a l a l 1 ldots a r For example if a 3 7 1 4 1 2 and you choose l 3 r 5 k 2 the array a will become 3 7 underline 3 6 3 2 You can do this operation Can you make array a equal to array b We consider that a b if and only if for every 1 le i le n a i b i ,"['#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint n,tc;\nint A[100005], B[100005];\n\nint main(){\n\n\tscanf(""%d"",&tc);\n\twhile ( tc-- ){\n\t\tint l = -1, r = -1;\n\t\tbool cannot = false;\n\t\tscanf(""%d"",&n);\n\t\tfor ( int i = 0; i < n; i++ ){\n\t\t\tscanf(""%d"",&A[i]);\n\t\t}\n\t\tfor ( int i = 0; i < n; i++ ){\n\t\t\tscanf(""%d"",&B[i]);\n\t\t\tif ( B[i] == A[i] ) continue;\n\t\t\tif ( B[i] < A[i] ) cannot = true;\n\t\t\telse  {\n\t\t\t\tif ( l == -1 ) l = i;\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\n\t\tif ( cannot ){\n\t\t\tprintf(""NO\\n"");\n\t\t} else {\n\t\t\tif ( l == -1 || r == -1 ){\n\t\t\t\tprintf(""YES\\n"");\n\t\t\t} else {\n\t\t\t\tint diff = B[l] - A[l];\n\t\t\t\tfor ( int i = l + 1; i <= r; i++ ){\n\t\t\t\t\tif ( B[i] - A[i] != diff ){\n\t\t\t\t\t\tcannot = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( cannot ) printf(""NO\\n"");\n\t\t\t\telse printf(""YES\\n"");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",['implementation'],1000
https://codeforces.com//contest/1881/problem/D,D. Divide and Equalize,You are given an array a consisting of n positive integers You can perform the following operation on it Choose a pair of elements a i and a j 1 le i j le n and i neq j Choose one of the divisors of the integer a i i e an integer x such that a i bmod x 0 Replace a i with frac a i x and a j with a j cdot x Determine whether it is possible to make all elements in the array the same by applying the operation a certain number of times possibly zero For example let s consider the array a 100 2 50 10 1 with 5 elements Perform two operations on it Choose a 3 50 and a 2 2 x 5 Replace a 3 with frac a 3 x frac 50 5 10 and a 2 with a 2 cdot x 2 cdot 5 10 The resulting array is a 100 10 10 10 1 Choose a 1 100 and a 5 1 x 10 Replace a 1 with frac a 1 x frac 100 10 10 and a 5 with a 5 cdot x 1 cdot 10 10 The resulting array is a 10 10 10 10 10 After performing these operations all elements in the array a become equal to 10 ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,a[N];\nll d[N];\nll cnt;\nvoid sep(ll x){\n    rep(i,2,sqrt(x)) if (x%i==0){\n        while (x%i==0){\n            if (d[i]==0) cnt++;\n            d[i]++;\n            x/=i;\n            if (d[i]==n) d[i]=0,cnt--;\n        }\n    }\n    if (x>1){\n        if (d[x]==0) cnt++;\n        d[x]++;\n        if (d[x]==n) d[x]=0,cnt--;\n    }\n}\nvoid rest(ll x){\n    rep(i,2,sqrt(x)) if (x%i==0){\n        d[i]=0;\n        while (x%i==0) x/=i;\n    }\n    if (x>1){\n        d[x]=0;\n    }\n}\nvoid prep(){\n\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) cin>>a[i],sep(a[i]);\n    if (!cnt) cout<<""YES"";\n    else cout<<""NO"";\n    cnt=0;\n    rep(i,1,n) rest(a[i]);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']","['math', 'number theory']",1300
https://codeforces.com//contest/1012/problem/E,E. Cycle sort,You are given an array of n positive integers a 1 a 2 dots a n You can perform the following operation any number of times select several distinct indices i 1 i 2 dots i k 1 le i j le n and move the number standing at the position i 1 to the position i 2 the number at the position i 2 to the position i 3 the number at the position i k to the position i 1 In other words the operation cyclically shifts elements i 1 to i 2 to ldots i k to i 1 For example if you have n 4 an array a 1 10 a 2 20 a 3 30 a 4 40 and you choose three indices i 1 2 i 2 1 i 3 4 then the resulting array would become a 1 20 a 2 40 a 3 30 a 4 10 Your goal is to make the array sorted in non decreasing order with the minimum number of operations The additional constraint is that the sum of cycle lengths over all operations should be less than or equal to a number s If it s impossible to sort the array while satisfying that constraint your solution should report that as well ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 200600;\nint n, S;\nint a[N];\nint b[N];\nint xs[N];\nint k;\nvector<int> g[N];\nint m;\nvector<int> cycles[N];\nint p[N];\nbool used[N];\n\nvoid dfs(int v) {\n\twhile(!g[v].empty()) {\n\t\tint id = g[v].back();\n\t\tg[v].pop_back();\n\t\tdfs(a[id]);\n\t\tcycles[m].push_back(id);\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &S);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\tsort(b, b + n);\n\tfor (int i = 0; i < n; i++)\n\t\txs[k++] = b[i];\n\tk = unique(xs, xs + k) - xs;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] = lower_bound(xs, xs + k, a[i]) - xs;\n\t\tb[i] = lower_bound(xs, xs + k, b[i]) - xs;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b[i]) continue;\n\t\tg[b[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tdfs(i);\n\t\tif (!cycles[m].empty()) m++;\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tS -= (int)cycles[i].size();\n\tif (S < 0) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tp[i] = i;\n\tfor (int id = 0; id < m; id++) {\n\t\tfor (int i = 0; i < (int)cycles[id].size(); i++) {\n\t\t\tint v = cycles[id][i], u = cycles[id][(i + 1) % (int)cycles[id].size()];\n\t\t\tp[u] = v;\n\t\t}\n\t}\n\tS = min(S, m);\n\tif (S > 1) {\n\t\tprintf(""%d\\n"", 2 + m - S);\n\t\tprintf(""%d\\n"", S);\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tprintf(""%d "", cycles[i][0] + 1);\n\t\tprintf(""\\n"");\n\t\tfor (int i = S - 1; i > 0; i--)\n\t\t\tswap(p[cycles[i][0]], p[cycles[i - 1][0]]);\n\t} else {\n\t\tprintf(""%d\\n"", m);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tif (p[i] == i) {\n\t\t\tused[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> cur;\n\t\tint x = i;\n\t\twhile(!used[x]) {\n\t\t\tcur.push_back(x);\n\t\t\tused[x] = 1;\n\t\t\tx = p[x];\n\t\t}\n\t\tprintf(""%d\\n"", (int)cur.size());\n\t\tfor (int z : cur)\n\t\t\tprintf(""%d "", z + 1);\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}\n']","['dsu', 'math']",3100
https://codeforces.com//contest/992/problem/E,E. Nastya and King-Shamans,Nastya likes reading and even spends whole days in a library sometimes Today she found a chronicle of Byteland in the library and it stated that there lived shamans long time ago It is known that at every moment there was exactly one shaman in Byteland and there were shamans in total enumerated with integers from to in the order they lived Also each shaman had a magic power which can now be expressed as an integer The chronicle includes a list of powers of the shamans Also some shamans can be king shamans if they gathered all the power of their predecessors i e their power is exactly the sum of powers of all previous shamans Nastya is interested in whether there was at least one king shaman in Byteland Unfortunately many of the powers are unreadable in the list so Nastya is doing the following Initially she supposes some power for each shaman After that she changes the power of some shaman times the shamans can differ and after that wants to check if there is at least one king shaman in the list If yes she wants to know the index of any king shaman Unfortunately the list is too large and Nastya wants you to help her ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 262144;\ntypedef long long ll;\n\nint n, q;\nll z[200005], a[200005];\n\nconst ll INF = 2123123123123123123ll;\n\nstruct stb {\n\tstruct node {\n\t\tll b, lo, hi;\n\t\tint z;\n\n\t\tnode& operator+= (const node& o) {\n\t\t\tlo = min(lo, o.lo);\n\t\t\thi = max(hi, o.hi);\n\t\t\tz = max(z, o.z);\n\t\t\treturn *this;\n\t\t}\n\n\t\tnode operator+ (const node& o) const {\n\t\t\tnode tmp = *this;\n\t\t\ttmp += o;\n\t\t\treturn tmp;\n\t\t}\n\t};\n\n\tnode d[2*MAXN];\n\n\tvoid push(int i) {\n\t\tif (d[i].b == 0)\n\t\t\treturn;\n\n\t\tif (i >= MAXN) {\n\t\t\td[i].lo += d[i].b;\n\t\t\td[i].hi += d[i].b;\n\t\t\td[i].z = d[i].lo == 0 ? i - MAXN + 1 : -1;\n\t\t\td[i].b = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(d[i].lo + d[i].b <= 0 && 0 <= d[i].hi + d[i].b)) {\n\t\t\td[i].lo += d[i].b;\n\t\t\td[i].hi += d[i].b;\n\t\t\td[2*i].b += d[i].b;\n\t\t\td[2*i+1].b += d[i].b;\n\t\t\td[i].b = 0;\n\t\t\td[i].z = -1;\n\t\t\treturn;\n\t\t}\n\n\t\td[2*i].b += d[i].b;\n\t\td[2*i+1].b += d[i].b;\n\t\tpush(2*i);\n\t\tpush(2*i+1);\n\t\td[i] = d[2*i] + d[2*i+1];\n\t}\n\n\tvoid init() {\n\t\tfor (int i=1; i<=n; i++)\n\t\t\td[i + MAXN - 1] = {0, z[i], z[i], z[i] == 0 ? i : -1};\n\t\tfor (int i=n+1; i<=MAXN; i++)\n\t\t\td[i + MAXN - 1] = {0, INF, INF, -1};\n\n\t\tfor (int i=MAXN-1; i>=1; i--)\n\t\t\td[i] = d[2*i] + d[2*i+1];\n\t}\n\n\tvoid add(int l, int r, ll val, int x = 1, int xl = 1, int xr = MAXN) {\n\t\tpush(x);\n\t\tif (r < xl || xr < l)\n\t\t\treturn;\n\t\tif (l <= xl && xr <= r) {\n\t\t\td[x].b += val;\n\t\t\tpush(x);\n\t\t\treturn;\n\t\t}\n\n\t\tint xm = (xl + xr) >> 1;\n\t\tadd(l, r, val, 2*x, xl, xm);\n\t\tadd(l, r, val, 2*x+1, xm+1, xr);\n\n\t\td[x] = d[2*x] + d[2*x+1];\n\t}\n\n\tint nula() {\n\t\tpush(1);\n\t\treturn d[1].z;\n\t}\n\n} drvo;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n >> q;\n\n\tll ps = 0;\n\tfor (int i=1; i<=n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta[i] = x;\n\t\tz[i] = x - ps;\n\t\tps += x;\n\t}\n\n\tdrvo.init();\n\n\tfor (int i=1; i<=q; i++) {\n\t\tint p;\n\t\tll v;\n\t\tcin >> p >> v;\n\t\tv -= a[p];\n\t\ta[p] += v;\n\n\t\tdrvo.add(p, p, v);\n\t\tif (p != n)\n\t\t\tdrvo.add(p+1, n, -v);\n\t\tcout << drvo.nula() << '\\n';\n\t}\n}""]","['binary search', 'data structures']",2500
https://codeforces.com//contest/911/problem/G,G. Mass Change Queries,You are given an array consisting of integers You have to process queries to this array each query is given as four numbers and denoting that for every such that and you have to set equal to Print the array after all queries are processed ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic void adjust(list<int> &X, list<int> &Y, int l, int r)\n{\n    auto it = X.begin();\n    while (it != X.end())\n    {\n        auto nxt = next(it);\n        if (*it >= l && *it < r)\n            Y.splice(Y.begin(), X, it);\n        it = nxt;\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    int S = min(500, N);\n    int M = (N + S - 1) / S;\n    int H = 101;\n    vector<vector<list<int>>> pos(H, vector<list<int>>(M));\n    for (int i = 0; i < N; i++)\n    {\n        int s = i / S;\n        int a;\n        cin >> a;\n        pos[a][s].push_back(i);\n    }\n    int Q;\n    cin >> Q;\n    for (int i = 0; i < Q; i++)\n    {\n        int l, r, x, y;\n        cin >> l >> r >> x >> y;\n        l--;\n        if (x == y)\n            continue;\n        int sl = l / S;\n        int sr = (r - 1) / S;\n        adjust(pos[x][sl], pos[y][sl], l, r);\n        if (sl != sr)\n            adjust(pos[x][sr], pos[y][sr], l, r);\n        for (int i = sl + 1; i < sr; i++)\n            pos[y][i].splice(pos[y][i].begin(), std::move(pos[x][i]));\n    }\n\n    vi a(N);\n    for (int i = 0; i < M; i++)\n        for (int j = 0; j < H; j++)\n            for (int p : pos[j][i])\n                a[p] = j;\n\n    for (int i = 0; i < N; i++)\n        cout << a[i] << \' \';\n    cout << \'\\n\';\n\n    return 0;\n}\n']",['data structures'],2500
https://codeforces.com//contest/1641/problem/B,B. Repetitions Decoding,Olya has an array of integers a 1 a 2 ldots a n She wants to split it into tandem repeats Since it s rarely possible before that she wants to perform the following operation several possibly zero number of times insert a pair of equal numbers into an arbitrary position Help her More formally A tandem repeat is a sequence x of even length 2k such that for each 1 le i le k the condition x i x i k is satisfied An array a could be split into tandem repeats if you can split it into several parts each being a subsegment of the array such that each part is a tandem repeat In one operation you can choose an arbitrary letter c and insert c c to any position in the array at the beginning between any two integers or at the end You are to perform several operations and split the array into tandem repeats or determine that it is impossible Please note that you do have to minimize the number of operations ,"['/**\n *    author:  tourist\n *    created: 23.02.2022 13:49:47       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<pair<int, int>> ops;\n    vector<int> lens;\n    bool fail = false;\n    while (!a.empty()) {\n      int n = (int) a.size();\n      int i = n - 1;\n      int j = i - 1;\n      while (j >= 0 && a[j] != a[i]) {\n        j -= 1;\n      }\n      if (j == -1) {\n        fail = true;\n        break;\n      }\n      int ptr = j;\n      for (int k = i - 1; k >= j + 1; k--) {\n        ops.emplace_back(ptr, a[k]);\n        ptr += 1;\n      }\n      lens.push_back(2 * (i - j));\n      a.erase(a.begin() + i);\n      a.erase(a.begin() + j);\n      reverse(a.begin() + j, a.end());\n    }\n    if (fail) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    cout << ops.size() << \'\\n\';\n    for (auto& op : ops) {\n      cout << op.first << "" "" << op.second << \'\\n\';\n    }\n    reverse(lens.begin(), lens.end());\n    cout << lens.size() << \'\\n\';\n    for (int i = 0; i < (int) lens.size(); i++) {\n      cout << lens[i] << "" \\n""[i == (int) lens.size() - 1];\n    }\n  }\n  return 0;\n}\n']","['constructive algorithms', 'implementation', 'sortings']",2000
https://codeforces.com//contest/1454/problem/B,B. Unique Bid Auction,There is a game called Unique Bid Auction You can read more about it here https en wikipedia org wiki Unique bid auction though you don t have to do it to solve this problem Let s simplify this game a bit Formally there are n participants the i th participant chose the number a i The winner of the game is such a participant that the number he chose is i e nobody else chose this number except him and is i e among all unique values of a the minimum one is the winning one Your task is to find the of the participant who won the game or if there is no winner Indexing is 1 based i e the participants are numbered from 1 to n You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        map<int, vi> use;\n        f0r(i, n) use[a[i]].eb(i);\n        bool ok = false;\n        for (auto x : use) {\n            if (sz(x.s) == 1) {\n                ok = true;\n                ps(x.s[0] + 1);\n                break;\n            }\n        }\n        if (ok) continue;\n        ps(-1);\n    }\n    return 0;\n}']",['implementation'],800
https://codeforces.com//contest/1913/problem/C,C. Game with Multiset,In this problem you are initially given an empty multiset You have to process two types of queries x add an element equal to 2 x to the multiset w say whether it is possible to take the sum of some subset of the current multiset and get a value equal to w ,"['/**\n *    author:  tourist\n *    created: 18.12.2023 09:38:49       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> cnt(30);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string op;\n    cin >> op;\n    if (op == ""1"") {\n      int x;\n      cin >> x;\n      cnt[x] += 1;\n    } else {\n      int w;\n      cin >> w;\n      for (int i = 29; i >= 0; i--) {\n        int take = min(w >> i, cnt[i]);\n        w -= take << i;\n      }\n      cout << (w == 0 ? ""YES"" : ""NO"") << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","['binary search', 'bitmasks', 'brute force', 'greedy']",1300
https://codeforces.com//contest/1037/problem/A,A. Packets,You have n coins each of the same value of 1 Distribute them into packets such that any amount x 1 leq x leq n can be formed using some possibly one or all number of these packets Each packet may only be used entirely or not used at all No packet may be used more than once in the formation of the single x however it may be reused for the formation of other x s Find the minimum number of packets in such a distribution ,"[""/**\n *    author:  tourist\n *    created: 02.09.2018 17:35:42       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  int x = 1;\n  int ans = 0;\n  while (n > 0) {\n    ans++;\n    if (n <= x) {\n      break;\n    }\n    n -= x;\n    x <<= 1;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","['constructive algorithms', 'greedy', 'math']",1300
https://codeforces.com//contest/1512/problem/B,B. Almost Rectangle,There is a square field of size n times n in which two cells are marked These cells can be in the same row or column You are to mark two more cells so that they are the corners of a rectangle with sides parallel to the coordinate axes For example if n 4 and a rectangular field looks like this there are asterisks in the marked cells begin matrix end matrix Then you can mark two more cells as follows begin matrix end matrix If there are several possible solutions then print any of them ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=100010;\nconst int mod=1000000007;\nusing namespace std;\n\nbool x[def],y[def];\nint n;\n\nvoid deal(bool *x)\n{\tint num=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(x[i])num++;\n\tif(num==1){\n\t\tif(!x[1])x[1]=true;\n\t\telse x[2]=true;\n\t}\n}\n\nint main()\n{\tint _=1,__=1;\n\tchar c;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)x[i]=y[i]=false;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tscanf("" %c"",&c);\n\t\t\t\tif(c==\'*\')\n\t\t\t\t\tx[i]=y[j]=true;\n\t\t\t}\n\t\tdeal(x);deal(y);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tprintf(""%c"",x[i]&&y[j]?\'*\':\'.\');\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}']",['implementation'],800
https://codeforces.com//contest/1628/problem/A,A. Meximum Array,Mihai has just learned about the MEX concept and since he liked it so much he decided to use it right away Given an array a of n non negative integers Mihai wants to create that is formed in the following way While a is not empty Choose an integer k 1 leq k leq a Append the MEX of the first k numbers of the array a to the end of array b and erase them from the array a shifting the positions of the remaining numbers in a But since Mihai loves big arrays as much as the MEX concept he wants the new array b to be the So Mihai asks you to tell him what the maximum array b that can be created by constructing the array optimally is An array x is lexicographically greater than an array y if in the first position where x and y differ x i y i or if x y and y is a prefix of x where x denotes the size of the array x The of a set of non negative integers is the minimal non negative integer such that it is not in the set For example 1 2 3 0 and 0 1 2 4 5 3 ,"['/**\n *    author:  tourist\n *    created: 22.01.2022 17:34:53       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> res;\n    vector<int> cnt(n + 1);\n    for (int i = 0; i < n; i++) {\n      cnt[a[i]] += 1;\n    }\n    int i = 0;\n    while (i < n) {\n      int mex = 0;\n      while (cnt[mex] > 0) {\n        mex += 1;\n      }\n      vector<bool> seen(mex);\n      int cc = 0;\n      while (i < n) {\n        if (a[i] < mex && !seen[a[i]]) {\n          seen[a[i]] = true;\n          cc += 1;\n        }\n        cnt[a[i]] -= 1;\n        i += 1;\n        if (cc == mex) {\n          break;\n        }\n      }\n      res.push_back(mex);\n    }\n    cout << res.size() << \'\\n\';\n    for (int i = 0; i < (int) res.size(); i++) {\n      cout << res[i] << "" \\n""[i == (int) res.size() - 1];\n    }\n  }\n  return 0;\n}\n']","['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math', 'two pointers']",1400
https://codeforces.com//contest/132/problem/A,A. Turing Tape,INTERCAL is the oldest of esoteric programming languages One of its many weird features is the method of character based output known as Turing Tape method It converts an array of unsigned 8 bit integers into a sequence of characters to print using the following method The integers of the array are processed one by one starting from the first Processing th element of the array is done in three steps 1 The 8 bit binary notation of the ASCII code of the previous printed character is reversed When the first element of the array is processed the result of this step is considered to be 0 2 The th element of the array is subtracted from the result of the previous step modulo 256 3 The binary notation of the result of the previous step is reversed again to produce ASCII code of the th character to be printed You are given the text printed using this method Restore the array used to produce this text ,"['#pragma comment(linker, ""/STACK:65777216"")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint getcode(char c){\n\tint q = int(c);\n\tif(q<0) q += 256;\n\treturn q;\n}\n\nint mirror(int code){\n\tint res = 0;\n\tREP(i,8)if(code&(1<<i))\n\t\tres ^= (1<<(7-i));\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n//  freopen(""output.txt"",""w"",stdout);\n#endif\n\t\n\tstring s;\n\tgetline(cin,s);\n\n\tint prev = 0;\n\tREP(i,s.size()){\n\t\tprev = getcode(s[i]);\n\t\tprev = mirror(prev);\n\n\t\tint x = mirror(i?getcode(s[i-1]):0) - prev;\n\t\tx%=256;\n\t\tif(x<0) x+=256;\n\t\tcout<<x<<endl;\n\t}\n\n \n#ifdef LocalHost\n    cout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']",['implementation'],1300
https://codeforces.com//contest/1550/problem/F,F. Jumping Around,There is an infinite pond that can be represented with a number line There are n rocks in the pond numbered from 1 to n The i th rock is located at an integer coordinate a i The coordinates of the rocks are pairwise distinct The rocks are numbered in the increasing order of the coordinate so a 1 a 2 dots a n A robot frog sits on the rock number s The frog is programmable It has a base jumping distance parameter d There also is a setting for the jumping distance range If the jumping distance range is set to some integer k then the frog can jump from some rock to any rock at a distance from d k to d k inclusive in any direction The distance between two rocks is an absolute difference between their coordinates You are assigned a task to implement a feature for the frog Given two integers i and k determine if the frog can reach a rock number i from a rock number s performing a sequence of jumps with the jumping distance range set to k The sequence can be arbitrarily long or empty You will be given q testcases for that feature the j th testcase consists of two integers i and k Print if the i th rock is reachable and otherwise You can output and in any case for example strings and will be recognized as a positive answer ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q, s, d;\n    std::cin >> n >> q >> s >> d;\n    s--;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> f(n, -1);\n    std::priority_queue<std::pair<int, int>> h;\n    \n    std::set<int> jump, stones;\n    for (int i = 0; i < n; i++) {\n        stones.insert(i);\n    }\n    \n    auto getK = [&](int u) {\n        int x = a[u];\n        auto it = jump.lower_bound(x);\n        \n        int ans = 1e9;\n        if (it != jump.end()) {\n            ans = std::min(ans, *it - x);\n        }\n        if (it != jump.begin()) {\n            ans = std::min(ans, x - *std::prev(it));\n        }\n        \n        return ans;\n    };\n    \n    h.emplace(0, s);\n    \n    while (!h.empty()) {\n        auto [x, u] = h.top();\n        h.pop();\n        \n        if (f[u] >= 0) {\n            continue;\n        }\n        \n        f[u] = -x;\n        \n        for (auto v : {a[u] - d, a[u] + d}) {\n            jump.insert(v);\n            \n            int j = std::partition_point(a.begin(), a.end(), [&](int x) { return x < v; }) - a.begin();\n            \n            auto it = stones.lower_bound(j);\n            if (it != stones.end()) {\n                h.emplace(-std::max(f[u], a[*it] - v), *it);\n            }\n            \n            if (it != stones.begin()) {\n                it--;\n                h.emplace(-std::max(f[u], v - a[*it]), *it);\n            }\n        }\n        \n        stones.erase(u);\n        auto it = stones.lower_bound(u);\n        \n        if (it != stones.end()) {\n            h.emplace(-std::max(f[u], getK(*it)), *it);\n        }\n        if (it != stones.begin()) {\n            it--;\n            h.emplace(-std::max(f[u], getK(*it)), *it);\n        }\n    }\n    \n    while (q--) {\n        int i, k;\n        std::cin >> i >> k;\n        i--;\n        \n        if (k >= f[i]) {\n            std::cout << ""Yes\\n"";\n        } else {\n            std::cout << ""No\\n"";\n        }\n    }\n    \n    return 0;\n}\n']","['binary search', 'data structures', 'divide and conquer', 'dp', 'dsu', 'graphs', 'shortest paths']",2700
https://codeforces.com//contest/765/problem/F,F. Souvenirs,Artsem is on vacation and wants to buy souvenirs for his two teammates There are souvenir shops along the street In th shop Artsem can buy one souvenir for dollars and he cannot buy more than one souvenir in one shop He doesn t want to introduce envy in his team so he wants to buy two souvenirs with least possible difference in price Artsem has visited the shopping street times For some strange reason on the th day only shops with numbers from to were operating weird yes it is but have you ever tried to come up with a reasonable legend for a range query problem For each visit Artsem wants to know the minimum possible difference in prices of two different souvenirs he can buy in the opened shops In other words for each Artsem s visit you should find the minimum possible value of where ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 3e5 + 100;\nint as[N];\nint a[N];\n\nconst int LOG = 18;\nconst int LEVEL = (1 << LOG);\nconst int SZ = (LEVEL << 1);\n\nstruct tree\n{\n\tint mx[SZ];\n\ttree() : mx() \n\t{\n\t\tmemset(mx, -1, sizeof mx);\n\t}\n\tvoid set(int pos, int val)\n\t{\n\t\tpos += LEVEL;\n\t\tmx[pos] = max(mx[pos], val);\n\t\tpos /= 2;\n\t\twhile (pos >= 1)\n\t\t{\n\t\t\tmx[pos] = max(mx[2 * pos], mx[2 * pos + 1] );\n\t\t\tpos /= 2;\n\t\t}\n\t}\n\tint getMax(int v, int l, int r, int tl, int tr)\n\t{\n\t\tif (tr < l || r < tl) return -1;\n\t\tif (l <= tl && tr <= r) return mx[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn max(\n\t\t\t\tgetMax(2 * v, l, r, tl, tm),\n\t\t\t\tgetMax(2 * v + 1, l, r, tm + 1, tr)\n\t\t\t\t);\n\t}\n\tint getMax(int l, int r)\n\t{\n\t\tif (l > r) return -1;\n\t\treturn getMax(1, l, r, 0, LEVEL - 1);\n\t}\n\tint getMaxVal(int vl, int vr, int k)\n\t{\n\t\tint l = lower_bound(as, as + k, vl) - as;\n\t\tint r = upper_bound(as, as + k, vr) - as;\n\t\tr--;\n\t\treturn getMax(l, r);\n\t}\n\n} tree;\n\nvector <int> listD[N], listU[N];\n\nvoid init(int n, int k)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n//\t\tint cnt = 0;\n//\t\teprintf(""init i = %d\\n"", i);\n\t\tint deltaUp = as[k - 1] - as[a[i] ];\n\t\twhile (true)\n\t\t{\n//\t\t\tcnt++;\n//\t\t\tif (cnt > LOG * 2) throw;\n\t\t\tint mxPos = tree.getMaxVal(as[a[i] ], as[a[i] ] + deltaUp, k);\n//\t\t\teprintf(""deltaUp = %d, mxPos = %d\\n"", deltaUp, mxPos);\n\t\t\tif (mxPos == -1) break;\n\t\t\tlistU[i].push_back(mxPos);\n\t\t\tdeltaUp = as[a[mxPos] ] - as[a[i] ];\n//\t\t\teprintf(""deltaUp = %d\\n"", deltaUp);\n\t\t\tif (deltaUp == 0) break;\n\t\t\tdeltaUp /= 2;\n\t\t}\n\t\tint deltaDown = as[a[i] ] - as[0];\n//\t\tcnt = 0;\n\t\twhile (true)\n\t\t{\n//\t\t\tcnt++;\n//\t\t\tif (cnt > LOG * 2) throw;\n//\t\t\teprintf(""i = %d: %d ... %d\\n"", i, as[a[i] ] - deltaDown, as[a[i] ] );\n\t\t\tint mxPos = tree.getMaxVal(as[a[i] ] - deltaDown, as[a[i] ], k);\n//\t\t\teprintf(""deltaDown = %d, mxPos = %d\\n"", deltaDown, mxPos);\n\t\t\tif (mxPos == -1) break;\n\t\t\tlistD[i].push_back(mxPos);\n\t\t\tdeltaDown = as[a[i] ] - as[a[mxPos] ];\n\t\t\tif (deltaDown == 0) break;\n\t\t\tdeltaDown /= 2;\n\t\t}\n\t\ttree.set(a[i], i);\n\t}\n\n//\tfor (int x : listD[15] )\n//\t\teprintf(""%d "", x);\n//\teprintf(""\\n"");\n}\n\n\nvector <int> qsmall[N];\nvector <int> qu[N];\nint ans[N];\nconst int BL = 320; // TODO\n//const int BL = 5;\n\n/*\nint solveSlow(int l, int r)\n{\n\tint answ = abs(as[a[r] ] - as[a[l] ] );\n\tfor (int i = l; i <= r; i++)\n\t\tfor (int j = i + 1; j <= r; j++)\n\t\t\tansw = min(answ, abs(as[a[i] ] - as[a[j] ] ) );\n\treturn answ;\n}\n*/\n\nint l[N], r[N];\nbool cmpR(int i, int j)\n{\n\treturn r[i] < r[j];\n}\n\nint val[N], slow[N];\n\nvoid solve(int n, int k)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tslow[i] = as[k - 1] - as[0];\n\t\tval[i] = as[k - 1] - as[0];\n\t}\n\n\tfor (int bs = 0; bs < n; bs += BL)\n\t{\n\t\tint be = min(bs + BL - 1, n - 1);\n//\t\teprintf(""bs = %d, be = %d\\n"", bs, be);\n\t\tvector <int> qs;\n\t\tfor (int i = bs; i <= be; i++)\n\t\t\tfor (int x : qu[i] )\n\t\t\t\tqs.push_back(x);\n\t\tsort(qs.begin(), qs.end(), cmpR);\n\t\n\n\t\tfor (int cr = bs; cr <= be; cr++)\n\t\t{\n\t\t\tfor (int cl = bs; cl < cr; cl++)\n\t\t\t\tslow[cl] = min(slow[cl], abs(as[a[cr] ] - as[a[cl] ] ));\n\t\t\tfor (int cl = cr - 1; cl >= bs; cl--)\n\t\t\t\tslow[cl] = min(slow[cl], slow[cl + 1] );\n\t\t\twhile (!qsmall[cr].empty() )\n\t\t\t{\n\t\t\t\tint id = qsmall[cr].back();\n\t\t\t\tqsmall[cr].pop_back();\n\t\t\t\tans[id] = slow[l[id] ];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = be - 1; i >= bs; i--)\n\t\t{\n\t\t\tslow[i] = slow[i + 1];\n\t\t\tfor (int j = i + 1; j <= be; j++)\n\t\t\t\tslow[i] = min(slow[i], abs(as[a[i] ] - as[a[j] ] ) );\n\t\t}\n\n\t\tint ptr = 0;\n\t\tint mnR = as[k - 1] - as[0] + 1;\n\t\tfor (int i = be + 1; i <= n; i++)\n\t\t{\n\t\t\twhile (!listD[i].empty() && listD[i].back() <= be)\n\t\t\t{\n\t\t\t\tint x = listD[i].back();\n\t\t\t\tval[x] = min(val[x], as[a[i] ] - as[a[x] ] );\n\t\t\t\tlistD[i].pop_back();\n\t\t\t}\n\t\t\twhile (!listU[i].empty() && listU[i].back() <= be)\n\t\t\t{\n\t\t\t\tint x = listU[i].back();\n\t\t\t\tval[x] = min(val[x], as[a[x] ] - as[a[i] ] );\n\t\t\t\tlistU[i].pop_back();\n\t\t\t}\n\t\t\tif (!listD[i].empty() )\n\t\t\t{\n\t\t\t\tint x = listD[i].back();\n\t\t\t\tmnR = min(mnR, as[a[i] ] - as[a[x] ] );\n\t\t\t}\n\t\t\tif (!listU[i].empty() )\n\t\t\t{\n\t\t\t\tint x = listU[i].back();\n\t\t\t\tmnR = min(mnR, as[a[x] ] - as[a[i] ] );\n\t\t\t}\n\n\t\t\twhile (ptr != (int) qs.size() && r[qs[ptr] ] == i)\n\t\t\t{\n\t\t\t\tint id = qs[ptr++];\n\n\t\t\t\tint answ = min(mnR, slow[l[id] ] );\n\t\t\t\tfor (int j = l[id]; j <= be; j++)\n\t\t\t\t\tansw = min(answ, val[j] );\n\t\t\t\tans[id] = answ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(""%d"", &a[i] );\n\t\tas[i] = a[i];\n\t}\n\tsort(as, as + n);\n\tint k = unique(as, as + n) - as;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = lower_bound(as, as + k, a[i] ) - as;\n\n//\tfor (int i = 0; i < k; i++)\n//\t\teprintf(""%d "", as[i] );\n//\teprintf(""\\n"");\n\n\tint m;\n\tscanf(""%d"", &m);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(""%d%d"", &l[i], &r[i] );\n\t\tl[i]--;\n\t\tr[i]--;\n\t\tif (r[i] / BL == l[i] / BL)\n\t\t\tqsmall[r[i] ].push_back(i);//ans[i] = solveSlow(l[i], r[i]);\n\t\telse\n\t\t\tqu[l[i] ].push_back(i);\n\t}\n\tinit(n, k);\n\tsolve(n, k);\n\tfor (int i = 0; i < m; i++)\n\t\tprintf(""%d\\n"", ans[i] );\n\n\treturn 0;\n}\n\n\n']",['data structures'],3100
https://codeforces.com//contest/746/problem/F,F. Music in Car,Sasha reaches the work by car It takes exactly minutes On his way he listens to music All songs in his playlist go one by one after listening to the th song Sasha gets a pleasure which equals The th song lasts for minutes Before the beginning of his way Sasha turns on some song and then he listens to the songs one by one at first the song then the song then the song number and so on He listens to songs until he reaches the work or until he listens to the last song in his playlist Sasha can listen to each song to the end or In the second case he listens to the song for integer number of minutes at least half of the song s length Formally if the length of the song equals minutes Sasha listens to it for no less than minutes then he immediately switches it to the next song if there is such For example if the length of the song which Sasha wants to listen to equals minutes then he should listen to it for at least minutes if the length of the song equals minutes then he should listen to it for at least minutes It takes no time to switch a song Sasha wants to listen no more than songs If the last listened song plays for less than half of its length then Sasha doesn t get pleasure from it and that song is not included to the list of listened songs It is not allowed to skip songs A pleasure from a song does not depend on the listening mode for the th song this value equals Help Sasha to choose such and no more than songs for listening to get the maximum pleasure Write a program to find the maximum pleasure Sasha can get from the listening to the songs on his way to the work ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)501*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n,w,k,a[N],t[N],ans;\nmultiset <ll> s,p;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>w>>k;\n    for(int i=0;i<n;i++)cin>>a[i];\n    for(int i=0;i<n;i++)cin>>t[i];\n    for(ll i=0,j=0,time=0,res=0;i<n;i++)\n    {\n    \twhile(j<n)\n    \t{\n    \t\tll now=time;\n    \t\tif((ll)s.size()<w)now+=(t[j]+1)/2;\n    \t\telse if(t[j]>(*s.begin()))now+=(t[j]+1)/2+((*s.begin())-((*s.begin())+1)/2);\n    \t\telse now+=t[j];\n    \t\t\n\t\t\tif(now>k)break;\n    \t\t\n    \t\tif((ll)s.size()<w)s.insert(t[j]);\n    \t\telse if(t[j]>(*s.begin()))p.insert(*s.begin()),s.erase(s.begin()),s.insert(t[j]);\n    \t\telse p.insert(t[j]);\n    \t\t\n\t\t\ttime=now;res+=a[j];j++;\n\t\t}\n\t\tans=max(ans,res);\n\t\t\n\t\tif(j<=i){j=i+1;continue;}\n\t\tres-=a[i];\n\t\tif(t[i]<*s.begin())p.erase(p.find(t[i])),time-=t[i];\n\t\telse \n\t\t{\n\t\t\ts.erase(s.find(t[i]));\n\t\t\ttime-=(t[i]+1)/2;\n\t\t\tif(p.size())\n\t\t\t{\n\t\t\t\tauto it=p.end();it--;\n\t\t\t\ts.insert(*it);\n\t\t\t\ttime-=(*it-(*it+1)/2);\n\t\t\t\tp.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n    return 0;\n}']","['data structures', 'greedy', 'two pointers']",2200
https://codeforces.com//contest/615/problem/B,B. Longtail Hedgehog,This Christmas Santa gave Masha a magic picture and a pencil The picture consists of points connected by segments they might cross in any way that doesn t matter No two segments connect the same pair of points and no segment connects the point to itself Masha wants to color some segments in order paint a hedgehog In Mashas mind every hedgehog consists of a tail and some spines She wants to paint the tail that satisfies the following conditions Only segments already presented on the picture can be painted The tail should be continuous i e consists of some sequence of points such that every two neighbouring points are connected by a colored segment The numbers of points from the beginning of the tail to the end should strictly increase Masha defines the length of the tail as the number of points in it Also she wants to paint some spines To do so Masha will paint all the segments such that one of their ends is the of the tail Masha defines the beauty of a hedgehog as the length of the tail multiplied by the number of spines Masha wants to color the most beautiful hedgehog Help her calculate what result she may hope to get Note that according to Masha s definition of a hedgehog one segment may simultaneously serve as a spine and a part of the tail she is a little girl after all Take a look at the picture for further clarifications ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, ro[4000005][2] = {{0}}, p[100005], u, v;\nint cnt[100005] = {0};\nlong long ans = 0, f[100005] = {0};\nint main()\n{\n\tcin >> n >> m;\n\tmemset(p, -1, sizeof(p));\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tscanf(""%d%d"", &u, &v);\n\t\tro[i * 2 - 1][0] = v;\n\t\tro[i * 2 - 1][1] = p[u];\n\t\tp[u] = i * 2 - 1;\n\t\tro[i * 2][0] = u;\n\t\tro[i * 2][1] = p[v];\n\t\tp[v] = i * 2;\n\t\tcnt[u]++;\n\t\tcnt[v]++;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = p[i]; j != -1; j = ro[j][1])\n\t\t\tif (ro[j][0] < i)\n\t\t\t\tf[i] = max(f[i], f[ro[j][0]]);\n\t\tf[i]++;\n\t\tans = max(ans, f[i] * cnt[i]);\n\t}\n\tcout << ans << endl;\n}']","['dp', 'graphs']",1600
https://codeforces.com//contest/1841/problem/C,C. Ranom Numbers,Ranom digits are denoted by uppercase Latin letters from to Moreover the value of the letter is 1 is 10 is 100 is 1000 is 10000 A Ranom number is a sequence of Ranom digits The value of the Ranom number is calculated as follows the values of all digits are summed up but some digits are taken with negative signs a digit is taken with negative sign if there is a digit with a value to the right of it not necessarily immediately after it otherwise that digit is taken with a positive sign For example the value of the Ranom number is 1000 1 1 1 10 1000 100 1 2088 You are given a Ranom number You can change no more than one digit in it Calculate the maximum possible value of the resulting number ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << "" ""; cout << v[i];\n    }\n    cout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\n\nvector<int> v = { 1,10,100,1000,10000 };\n\nll dp[1 << 18][5][2];\nvoid solve() {\n    string s; cin >> s;\n    reverse(all(s));\n    rep(i, s.size() + 1) {\n        rep(j, 5)rep(k, 2)dp[i][j][k] = -INF;\n    }\n    dp[0][0][0] = 0;\n    rep(i, s.size()) {\n        int c = s[i] - \'A\';\n        rep(j, 5)rep(k, 2) {\n            if (dp[i][j][k]==-INF)continue;\n            rep(ad, 5) {\n                int nj = max(j, ad);\n                int nk = k; if (ad != c)nk++;\n                if (nk > 1)continue;\n                ll val = dp[i][j][k];\n                if (j > ad)val -= v[ad];\n                else val += v[ad];\n                chmax(dp[i + 1][nj][nk], val);\n            }\n        }\n    }\n    ll ans = -INF;\n    rep(j, 5)rep(k, 2)chmax(ans, dp[s.size()][j][k]);\n    cout << ans << ""\\n"";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}']","['brute force', 'dp', 'greedy', 'math', 'strings']",1800
https://codeforces.com//contest/1316/problem/B,B. String Modification,Vasya has a string s of length n He decides to make the following modification to the string Pick an integer k 1 leq k leq n For i from 1 to n k 1 reverse the substring s i i k 1 of s For example if string s is and k 2 below is the series of transformations the string goes through original string after reversing the first substring of length 2 after reversing the second substring of length 2 after reversing the last substring of length 2 Hence the resulting string after modifying s with k 2 is Vasya wants to choose a k such that the string obtained after the above mentioned modification is lexicographically smallest possible among all choices of k Among all such k he wants to choose the smallest one Since he is busy attending Felicity 2020 he asks for your help A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar str[10001];\nint t;\nint n;\nint b[6001][6001];\nint p[6001];\nbool cmp(const int& x, const int& y) {\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (str[b[x][i]] != str[b[y][i]]) return str[b[x][i]] < str[b[y][i]];\n\t}\n\treturn x < y;\n}\n\nint main( ) {\n\tscanf(""%d"", &t);\n\twhile (t --) {\n\t\tscanf(""%d"", &n);\n\t\tscanf(""%s"", str + 1);\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tfor (int j = i; j <= n; j ++)\n\t\t\t\tb[i][j - i + 1] = j;\n\t\t\tint cur = n - i + 1;\n\t\t\tfor (int j = 1; j < i; j ++) {\n\t\t\t\tif ((n - i + 1) % 2 == 1) {\n\t\t\t\t\tb[i][++ cur] = i - j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb[i][++ cur] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i ++) p[i] = i;\n\t\tsort(p + 1, p + 1 + n, cmp);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tprintf(""%c"", str[b[p[1]][i]]);\n\t\tputs("""");\n\t\tprintf(""%d\\n"", p[1]);\n\t}\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms', 'implementation', 'sortings', 'strings']",1400
https://codeforces.com//contest/1404/problem/B,B. Tree Tag,Alice and Bob are playing a fun game of tree tag The game is played on a tree of n vertices numbered from 1 to n Recall that a tree on n vertices is an undirected connected graph with n 1 edges Initially Alice is located at vertex a and Bob at vertex b They take turns alternately and Alice makes the first move In a move Alice can jump to a vertex with distance da from the current vertex And in a move Bob can jump to a vertex with distance db from the current vertex The distance between two vertices is defined as the number of edges on the unique simple path between them In particular either player is allowed to stay at the same vertex in a move Note that when performing a move a player only occupies the starting and ending vertices of their move not the vertices between them If after at most 10 100 moves Alice and Bob occupy the same vertex then Alice is declared the winner Otherwise Bob wins Determine the winner if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//AGC33 C\ntemplate<class E>\nstruct treediameter{\n\tconst vvc<E>&g;\n\tint r1,r2;\n\tvi d1,d2;\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vi&d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vvc<E>&gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(all(d1))-d1.bg;\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(all(d1))-d1.bg;\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tint a,b,c,d;cin>>a>>b>>c>>d;\n\ta--;b--;\n\tauto t=readTree(n);\n\t\n\tint dia=treediameter<int>(t).dia;\n\tchmin(c,dia);\n\tchmin(d,dia);\n\t\n\tconst string Alice=""Alice\\n"";\n\tconst string Bob=""Bob\\n"";\n\t\n\tauto dfs=[&](auto self,int v,int p,int dist)->int{\n\t\tif(v==b)return dist;\n\t\tfor(auto to:t[v])if(to!=p){\n\t\t\tint w=self(self,to,v,dist+1);\n\t\t\tif(w!=-1)return w;\n\t\t}\n\t\treturn int(-1);\n\t};\n\tint ini=dfs(dfs,a,-1,0);\n\tif(ini<=c){\n\t\tdmp(ini);\n\t\tcout<<Alice;\n\t\treturn;\n\t}\n\t\n\tif(c*2>=d){\n\t\tdmp2(c,d);\n\t\tcout<<Alice;\n\t\treturn;\n\t}\n\t\n\tcout<<Bob;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;\n\trep(_,t)slv();\n}\n']","['dfs and similar', 'dp', 'games', 'trees']",1900
https://codeforces.com//contest/817/problem/D,D. Imbalanced Array,You are given an array consisting of elements The of some subsegment of this array is the difference between the maximum and minimum element from this segment The of the array is the sum of of all subsegments of this array For example the of array is because there are different subsegments of this array from index to index is from index to index is from index to index is from index to index is from index to index is from index to index is You have to determine the of the array ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nconst int maxn = 1e6 + 5;\nint n;\nint a[maxn];\nint l[maxn];\nint r[maxn];\nlong long ans;\n\nvoid work() {\n    FOR(i, 0, n) l[i] = r[i] = i;\n    FOR(i, 1, n) {\n        int st = i;\n        while (st && a[i] >= a[st - 1]) st = l[st - 1];\n        l[i] = st;\n    }\n    FORd(i, n - 1, 0) {\n        int st = i;\n        while (st < n - 1 && a[i] > a[st + 1]) st = r[st + 1];\n        r[i] = st;\n    }\n    FOR(i, 0, n) {\n        ans += (long long) a[i] * (i - l[i] + 1) * (r[i] - i + 1);\n    }\n}\n\nvoid solve() {\n   scanf(""%d"", &n);\n   FOR(i, 0, n) scanf(""%d"", a + i);\n   work();\n   FOR(i, 0, n) a[i] *= -1;\n   work();\n   cout << ans << ""\\n"";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        //ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","['data structures', 'divide and conquer', 'dsu', 'sortings']",1900
https://codeforces.com//contest/41/problem/E,E. 3-cycles,During a recent research Berland scientists found out that there were cities in Ancient Berland joined by two way paths Any two cities are joined by no more than one path No path joins a city with itself According to a well known tradition the road network was built so that it would be impossible to choose three cities from each of which one can get to any other one directly That is there was no cycle exactly as long as 3 Unfortunately the road map has not been preserved till nowadays Now the scientists are interested how much developed a country Ancient Berland was Help them find what maximal number of roads could be in the country You also have to restore any of the possible road maps ,"['#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<list>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<sstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I=(A);I<=(B);I++)\n#define REP(I,N) for(int I=0;I<(N);I++)\n#define ALL(X) (X).begin(),(X).end()\n#define VAR(A,B) __typeof(B) A=B\n#define FORE(I,X) for(VAR(I,(X).begin());I!=(X).end();I++)\n#define F first\n#define S second\n#define INF 1000000007\n#define PB push_back\n#define MP make_pair\ntypedef pair<int,int> PII;\ntypedef long long LL;\nint n,wyn;\n\nint main(){\n\tscanf(""%d"",&n);\n\tif (n<3){\n\t\tif (n==1) printf(""0\\n"");\n\t\telse printf(""1\\n1 2\\n"");\n\t\treturn 0;\n\t}\n\tREP(i,n){\n\t\twyn+=(n-i)/2;\n\t}\n\tprintf(""%d\\n"",wyn);\n\tREP(i,n){\n\t\tREP(j,(n-i)/2){\n\t\t\tprintf(""%d %d\\n"",i+1,i+2*j+2);\n\t\t}\n\t}\n}\n']","['constructive algorithms', 'graphs', 'greedy']",1900
https://codeforces.com//contest/18/problem/C,C. Stripe,Once Bob took a paper stripe of squares the height of the stripe is 1 square In each square he wrote an integer number possibly negative He became interested in how many ways exist to cut this stripe into two pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece and each piece contains positive integer amount of squares Would you help Bob solve this problem ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""g""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\n\nint const N=100005;\n\nint a[N], s[N];\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n\n\n    int n;\n    cin >> n;\n    s[0]=0;\n    for (int i=1; i<=n; i++) {\n        cin >> a[i];\n        s[i]=s[i-1]+a[i];\n    }\n    int res=0;\n    for (int i=1; i<n; i++)\n        if (s[i]+s[i]==s[n])\n            res++;\n    cout << res << endl;\n    return 0;\n}']","['data structures', 'implementation']",1200
https://codeforces.com//contest/1469/problem/C,C. Building a Fence,You want to build a fence that will consist of n equal sections All sections have a width equal to 1 and height equal to k You will place all sections in one line side by side Unfortunately the ground beneath the fence is not flat For simplicity you can think that the ground level under the i th section is equal to h i You should follow several rules to build the fence the consecutive sections should have a common side of length at least 1 the first and the last sections should stand on the corresponding ground levels the sections between may be either on the ground level or higher but not higher than k 1 from the ground level h i the height should be an integer Is it possible to build a fence that meets all rules ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, k;\n        std::cin >> n >> k;\n        int l = 0, r = 0;\n        bool ok = true;\n        for (int i = 0; i < n; ++i) {\n            int h;\n            std::cin >> h;\n            if (i == 0) {\n                l = r = h;\n            } else {\n                l = std::max(l - k + 1, h);\n                r = std::min(r + k - 1, h + k - 1);\n            }\n            if (l > r) {\n                ok = false;\n            }\n            if (i == n - 1 && l != h) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            std::cout << ""YES\\n"";\n        } else {\n            std::cout << ""NO\\n"";\n        }\n    }\n    return 0;\n}']","['dp', 'greedy', 'implementation', 'two pointers']",1600
https://codeforces.com//contest/714/problem/A,A. Meeting of Old Friends,Today an outstanding event is going to happen in the forest hedgehog Filya will come to his old fried Sonya Sonya is an owl and she sleeps during the day and stay awake from minute to minute inclusive Also during the minute she prinks and is unavailable for Filya Filya works a lot and he plans to visit Sonya from minute to minute inclusive Calculate the number of minutes they will be able to spend together ,"['#include <cstdio>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nlong long Intersect(long long a, long long b, long long c, long long d) {\n    long long answer = min(b, d) - max(a, c) + 1;\n    if (answer < 0)\n        answer = 0;\n    return answer;\n}\n\nint main() {\n    //freopen(""tema.in"", ""r"", stdin);\n    //freopen(""tema.out"", ""w"", stdout);\n    long long l1, r1, l2, r2, k;\n    scanf(""%I64d%I64d%I64d%I64d%I64d"", &l1, &r1, &l2, &r2, &k);\n    long long answer = Intersect(l1, r1, l2, r2);\n    if (k >= l1 && k <= r1 && k >= l2 && k <= r2)\n        answer--;\n    printf(""%I64d\\n"", answer);\n    return 0;\n}\n']","['implementation', 'math']",1100
https://codeforces.com//contest/1246/problem/B,B. Power Products,You are given n positive integers a 1 ldots a n and an integer k geq 2 Count the number of pairs i j such that 1 leq i j leq n and there exists an integer x such that a i cdot a j x k ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n,k;\n\ntemplate<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine\n\tvector<pair<T,int>> pri;\n\n\tfor (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n\t\tint t = 0;\n\t\twhile (x % i == 0) x /= i, t ++;\n\t\tpri.pb({i,t});\n\t}\n\n\tif (x > 1) pri.pb({x,1});\n\treturn pri;\n}\n\nmap<ll,ll> m;\n\npl cool(ll X) {\n\tauto z = factor(X);\n\tll x = 1, y = 1;\n\ttrav(t,z) {\n\t\tt.s %= k;\n\t\tif (t.s > 0) {\n\t\t\tF0R(i,t.s) x *= t.f;\n\t\t\tF0R(i,k-t.s) {\n\t\t\t\ty *= t.f;\n\t\t\t\tif (y > 1e5) return {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn {x,y};\n}\n\nint main() {\n\tsetIO(); re(n,k);\n\tll ans = 0;\n\tF0R(i,n) {\n\t\tll x; re(x);\n\t\tpl t = cool(x);\n\t\t// ps(""HA"",x,t);\n\t\tif (t.s != -1) {\n\t\t\tif (m.count(t.s)) ans += m[t.s];\n\t\t\tm[t.f] ++;\n\t\t}\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']","['hashing', 'implementation', 'math']",1800
https://codeforces.com//contest/435/problem/A,A. Queue on Bus Stop,It s that time of the year when the Russians flood their countryside summer cottages dachas and the bus stop has a lot of people People rarely go to the dacha on their own it s usually a group so the people stand in queue by groups The bus stop queue has groups of people The th group from the beginning has people Every minutes an empty bus arrives at the bus stop it can carry at most people Naturally the people from the first group enter the bus first Then go the people from the second group and so on Note that the order of groups in the queue never changes Moreover if some group cannot fit all of its members into the current bus it waits for the next bus together with other groups standing after it in the queue Your task is to determine how many buses is needed to transport all groups to the dacha countryside ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint a[110];\n\nint main() {\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n; i++) {\n        scanf(""%d"", &a[i]);\n    }\n    int tot = 0;\n    for (int i = 0; i < n; i++) {\n        int j = i, sum = 0;\n        for (j = i; j < n; j++) {\n            sum += a[j];\n            if (sum > m) break;\n        }\n        if (sum > m) j--;\n        tot++;\n        i = j;\n    }\n    printf(""%d\\n"", tot);\n    return 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/825/problem/F,F. String Compression,Ivan wants to write a letter to his friend The letter is a string consisting of lowercase Latin letters Unfortunately when Ivan started writing the letter he realised that it is very long and writing the whole letter may take extremely long time So he wants to write the of string instead of the string itself The of string is a sequence of strings where is the decimal representation of number without any leading zeroes and is some string consisting of lowercase Latin letters If Ivan writes string exactly times then string exactly times and so on the result will be string The length of a is Among all Ivan wants to choose a version such that its length is minimum possible Help Ivan to determine minimum possible length ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nstd::vector<int> getSelfPi(const std::string& s, int pos) {\n    size_t n = s.length() - pos;\n    std::vector<int> res(n);\n    size_t cur = 0;\n    for (size_t i = 1; i < n; i++) {\n        while (s[i + pos] != s[cur + pos] && cur > 0) {\n            cur = res[cur - 1];\n        }\n        if (s[i + pos] == s[cur + pos]) cur++;\n        res[i] = cur;\n    }\n    return res;\n}\n\nstruct Solution {\n  std::string s;\n  std::vector<std::vector<int>> pis;\n  void buildPi() {\n      pis.resize(s.length());\n      for (int i = 0; i < s.length(); i++) {\n          pis[i] = getSelfPi(s, i);\n      }\n  }\n  int log10(int diff) {\n      int res = 0;\n      while (diff > 0) {\n          res++;\n          diff /= 10;\n      }\n      return res;\n  }\n\n  void run(std::istream& in, std::ostream& out) {\n      in >> s;\n      buildPi();\n      std::vector<int> dyn(s.length() + 1, 1000000);\n      dyn[0] = 0;\n      for (int i = 0; i < s.length(); i++) {\n          int init = dyn[i];\n          for (int j = i + 1; j <= s.length(); j++) {\n              dyn[j] = std::min(dyn[j], init + j - i + 1);\n              int len = pis[i][j - i - 1];\n              int diff = j - i - len;\n              if ((j - i) % diff == 0) {\n                  dyn[j] = std::min(dyn[j], init + diff + log10((j - i) / diff));\n              }\n\n          }\n      }\n      out << dyn[s.length()] << std::endl;\n  }\n};\n\nint main() {\n    std::cin.sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    Solution().run(std::cin, std::cout);\n    return 0;\n}']","['dp', 'hashing', 'string suffix structures', 'strings']",2400
https://codeforces.com//contest/1593/problem/C,C. Save More Mice,There are one cat k mice and one hole on a coordinate line The cat is located at the point 0 the hole is located at the point n All mice are located between the cat and the hole the i th mouse is located at the point x i 0 x i n At each point many mice can be located In one second the following happens First mouse moves to the right by 1 If the mouse reaches the hole it hides i e the mouse will not any more move to any point and will not be eaten by the cat Then the mouse has finished its move the cat moves to the right by 1 If at the new cat s position some mice are located the cat eats them they will not be able to move after that The actions are performed until any mouse hasn t been hidden or isn t eaten In other words the first move is made by a mouse If the mouse has reached the hole it s saved Then the cat makes a move The cat eats the mice located at the pointed the cat has reached if the cat has reached the hole it eats nobody Each second you can select a mouse that will make a move What is the maximum number of mice that can reach the hole without being eaten ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=400005;\nint x[N],n,k,t;\nint main() {\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>n>>k;\n        for (int i=1;i<=k;i++) cin>>x[i];\n        sort(x+1,x+k+1);\n        int res=0,pos=0;\n        for (int i=k;i>=1;i--) {\n            if (pos<x[i]) res++,pos+=n-x[i];\n            else break;\n        }\n        cout<<res<<""\\n"";\n    }\n}\n']","['binary search', 'greedy', 'greedy']",1000
https://codeforces.com//contest/1650/problem/A,A. Deletions of Two Adjacent Letters,The string s is given the string length is number The string consists of lowercase letters of the Latin alphabet As long as the string length is greater than 1 the following operation can be performed on it select any two adjacent letters in the string s and delete them from the string For example from the string in one operation you can get any of the four strings or In particular in one operation the length of the string reduces by 2 Formally let the string s have the form s s 1s 2 dots s n n 1 During one operation you choose an arbitrary index i 1 le i n and replace s s 1s 2 dots s i 1 s i 2 dots s n For the given string s and the letter c determine whether it is possible to make such a sequence of operations that in the end the equality s c will be true In other words is there such a sequence of operations that the process will end with a string of length 1 which consists of the letter c ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\nvoid solve(){\n\tstring s; cin>>s;\n\tchar ch; cin>>ch;\n\tint sz = s.length();\n\tfor(int i=0; i<sz; i+=2){\n\t\tif(s[i]==ch){\n\t\t\tcout<<""YES""<<\'\\n\';\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<""NO""<<\'\\n\';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/1876/problem/E,E. Ball-Stackable,With a problem title like that there is no way this is going to be a graph problem Chaneka has a graph with n vertices and n 1 edges Some of the edges are directed and some of the edges are undirected Edge i connects vertex u i to vertex v i If t i 0 edge i is undirected If t i 1 edge i is directed in the direction from u i to v i It is known that if you make all edges undirected the graph becomes a tree dagger Chaneka wants to direct all undirected edges and colour each edge different edges can have the same colour After doing that suppose Chaneka starts a walk from an arbitrary vertex x to an arbitrary vertex y it is possible that x y going through one or more edges She is allowed to go through each edge either following the direction or opposite to the direction of the edge She is also allowed to visit a vertex or an edge more than once During the walk Chaneka maintains a stack of balls that is initially empty before the walk Each time Chaneka goes through an edge she does the following If Chaneka goes through it in the right direction she puts a new ball with a colour that is the same as the edge s colour to the top of the stack If Chaneka goes through it in the opposite direction she removes the ball that is on the top of the stack A walk is if and only if the stack is not empty before each time Chaneka goes through an edge in the opposite direction A walk is if and only if it is stackable and each time Chaneka goes through an edge in the opposite direction the colour of the ball removed from the stack is the same as the colour of the edge traversed Is it possible to direct all undirected edges and colour each edge such that all stackable walks are also ball stackable If it is possible find a construction example that uses the among all valid ways of directing and colouring If there are multiple such solutions output any of them dagger A tree is a connected graph with no cycles ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvector<pii> graf[nax];\n\nint ojf[nax];\n\nint fin(int v)\n{\n\tif (v!=ojf[v])\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nint blok[nax];\nint dpdol[nax];\nint dpgor[nax];\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n\texit(0);\n}\n\nvoid dfs1(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tblok[v]=max(blok[v], blok[i.first]-1+2*(i.second==2));\n\t\tblok[i.first]=max(blok[i.first], blok[v]-1+2*(i.second==1));\n\t}\n\tfor (pii i : graf[v])\n\t\tif (i.first!=oj)\n\t\t\tdfs1(i.first, v);\n\tfor (pii i : graf[v])\n\t{\n\t\tblok[v]=max(blok[v], blok[i.first]-1+2*(i.second==2));\n\t\tblok[i.first]=max(blok[i.first], blok[v]-1+2*(i.second==1));\n\t}\n}\n\nvoid dfs2(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\tdfs2(i.first, v);\n\t\t\tdpdol[v]+=dpdol[i.first]+(i.second==2);\n\t\t}\n\t}\n}\n\nvoid dfs3(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t\tif (i.first==oj && i.second==2)\n\t\t\tdpgor[v]++;\n\tint s=dpgor[v];\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\ts+=dpdol[i.first]+(i.second==2);\n\t\t}\n\t}\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\tdpgor[i.first]=s-(dpdol[i.first]+(i.second==2));\n\t\t\tdfs3(i.first, v);\n\t\t}\n\t}\n}\n\nvi stos[nax];\n\nint k=0;\n\nvoid dfs4(int v, int oj, int gle)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tif (i.second==2)\n\t\t{\n\t\t\tprintf(""%d %d %d\\n"", i.first, v, stos[gle-1].back());\n\t\t\tdfs4(i.first, v, gle-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk++;\n\t\t\tprintf(""%d %d %d\\n"", v, i.first, k);\n\t\t\tstos[gle].push_back(k);\n\t\t\tdfs4(i.first, v, gle+1);\n\t\t\tstos[gle].pop_back();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c);\n\t\tif (!c)\n\t\t{\n\t\t\tgraf[a].push_back({b, 0});\n\t\t\tgraf[b].push_back({a, 0});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgraf[a].push_back({b, 1});\n\t\t\tgraf[b].push_back({a, 2});\n\t\t}\n\t}\n\tdfs1(1, 0);\n\tdfs1(1, 0);\n\tdebug() << range(blok+1, blok+1+n);\n\tdfs2(1, 0);\n\tdfs3(1, 0);\n\tdebug() << range(dpdol+1, dpdol+1+n);\n\tdebug() << range(dpgor+1, dpgor+1+n);\n\tint g=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!blok[i] && (g==0 || dpdol[i]+dpgor[i]<dpdol[g]+dpgor[g]))\n\t\t\tg=i;\n\tprintf(""%d\\n"", n-1-(dpdol[g]+dpgor[g]));\n\tdfs4(g, 0, 0);\n\treturn 0;\n}\n']","['constructive algorithms', 'data structures', 'dp', 'trees']",3300
https://codeforces.com//contest/1481/problem/C,C. Fence Painting,You finally woke up after this crazy dream and decided to walk around to clear your head Outside you saw your house s fence so plain and boring that you d like to repaint it You have a fence consisting of n planks where the i th plank has the color a i You want to repaint the fence in such a way that the i th plank has the color b i You ve invited m painters for this purpose The j th painter will arrive at the moment j and will recolor plank to color c j For each painter you can choose which plank to recolor but you can t turn them down i e each painter has to color exactly one plank Can you get the coloring b you want If it s possible print for each painter which plank he must paint ,"['#include<bits/stdc++.h>\nusing namespace std;\nint a[100009],b[100009],c[100009];\nvector<int> v[100009];\nmain(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        for(int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n        for(int i = 1; i <= n; i++){\n            cin >> b[i];\n        }\n        for(int i = 1; i <= m; i++){\n            cin >> c[i];\n        }\n        int ok = 0;\n        for(int i = 1; i <= n; i++){\n            if(b[i] == c[m]) ok = i; \n        }\n        if(!ok) {\n            cout <<""NO""<<endl;\n            continue;\n        }\n        int bad = 0;\n        for(int i = 1; i <= n; i++){\n            if(b[i] != a[i]) v[b[i]].push_back(i), bad++;\n        }\n        vector<int> ans;\n        for(int i = m; i >= 1; i--){\n            if(!v[c[i]].size()) \n            {        if(i == m) ans.push_back(ok); \n                     else ans.push_back(ans[0]);\n                     continue;}\n            ans.push_back(v[c[i]].back());\n            v[c[i]].pop_back();\n            bad--;\n        }\n        if(bad) cout<<""NO""<<endl;\n        else{\n            \n            cout<<""YES""<<endl;\n            reverse(ans.begin(),ans.end());\n            for(int x : ans)\n                cout<<x<<"" "";\n                cout<<endl;\n        }\n        for(int i = 1; i <= n; i++)\n            v[i].clear();\n    }\n}']","['brute force', 'constructive algorithms', 'greedy']",1600
https://codeforces.com//contest/1891/problem/D,D. Suspicious logarithms,Let f x be the floor of the binary logarithm of x In other words f x is largest non negative integer y such that 2 y does not exceed x Let g x be the floor of the logarithm of x with base f x In other words g x is the largest non negative integer z such that f x z does not exceed x You are given q queries The i th query consists of two integers l i and r i The answer to the query is the sum of g k across all integers k such that l i leq k leq r i Since the answers might be large print them modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define int __int128\nusing namespace std;\nint read(){\n\tint w=0,h=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')h=-h;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){w=w*10+ch-\'0\';ch=getchar();}\n\treturn w*h;\n}\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar(x%10+\'0\');\n}\nvoid writeln(int x){write(x);puts("""");}\nvoid writech(int x){write(x);putchar(\' \');}\nconst int mod=1e9+7;\nint calc(int x){\n\tif(x<4)return 0;\n\tint ans=0;\n\tfor(int i=2;i<=60;i++){\n\t\tint l=(1ll<<i),r=min(x,(int)(1ll<<(i+1))-1);\n\t\t//writech(l);writeln(r);\n\t\tif(l>x)break;\n\t\tfor(int p=1,bs=i;p<=60;p++,bs=bs*i){\n\t\t\tif(bs*i<l)continue;\n\t\t    if(bs>r)break;\n\t\t\tint L=max(l,bs),R=min(r,bs*i-1);\n\t\t\tif(L<=R)(ans+=(R-L+1)%mod*p)%=mod;\n\t\t\t//writech(i);writech(p);writech(bs);writech(L);writeln(R);\n\t\t\tif(bs*p>1000000000000000000)break;\n\t\t}\n\t}\n\treturn ans;\n}\nvoid solve(){int l=read(),r=read();writeln((calc(r)-calc(l-1)+mod)%mod);}\nsigned main(){\n\tint T=read();while(T--)solve();\n\treturn 0;\n}\n\n']","['binary search', 'brute force', 'math']",1900
https://codeforces.com//contest/1059/problem/E,E. Split the Tree,You are given a rooted tree on n vertices its root is the vertex number 1 The i th vertex contains a number w i Split it into the minimum possible number of vertical paths in such a way that each path contains no more than L vertices and the sum of integers w i on each path does not exceed S Each vertex should belong to exactly one path A vertical path is a sequence of vertices v 1 v 2 ldots v k where v i i ge 2 is the parent of v i 1 ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\ntemplate<int maxn,typename NUM>\nstruct BIT {\n    NUM s[maxn];\n    \n    void init() {\n        mst(s, 0);\n    }\n    BIT() {\n        init();\n    }\n    \n    void update(int a,NUM value) {\n        a++;\n        while(a<maxn) {\n            s[a]+=value;\n            a+=lowbit(a);\n        }\n    }\n    \n    NUM query(int a) {\n        NUM ans = 0;\n        a++;\n        while(a) {\n            ans+=s[a];\n            a-=lowbit(a);\n        }\n        return ans;\n    }\n    NUM query(int a,int b) {\n        if(b<a)return 0;\n        return query(b)-query(a-1);\n    }\n};\nll n,l,s;\nll weight[100010];\nll par[100010];\n\nBIT<200010, ll>tree;\nnamespace HLD {\n    //0不能被使用\n    struct edge {\n        int to;\n        edge(int x):to(x){}\n    };\n    \n    const int root = 1;\n    const int maxn = 200010;\n    vector<edge>adj[maxn];\n    int dfnToID[maxn],dfn[maxn],head[maxn],fa[maxn],dep[maxn],size[maxn],heavy[maxn],r[maxn],cnt = 1;\n    ll sum[maxn];\n    void firstDfs(int cur,int _fa) {\n        sum[cur] = weight[cur] + sum[_fa];\n        dep[cur] = dep[_fa]+1;\n        size[cur]=1;\n        fa[cur] = _fa;\n        for(auto e:adj[cur]) {\n            if(e.to!=_fa) {\n                firstDfs(e.to,cur);\n                size[cur]+=size[e.to];\n            }\n        }\n        int heavyChild = 0;\n        for(auto e:adj[cur]) {\n            if(e.to!=_fa) {\n                if(size[e.to]>size[heavyChild]) {\n                    heavyChild = e.to;\n                }\n            }\n        }\n        heavy[cur] = heavyChild;\n    }\n    \n    \n    void secondDfs(int cur,int _fa) {\n        if(cur!=heavy[_fa]) {\n            head[cur] = cur;\n        } else {\n            head[cur] = head[_fa];\n        }\n        dfn[cur] = cnt++;\n        r[cur] = dfn[cur];\n        dfnToID[dfn[cur]] = cur;\n        if(!heavy[cur])return;\n        secondDfs(heavy[cur],cur);\n        r[cur] = r[heavy[cur]];\n        for(auto e:adj[cur]) {\n            if(e.to==_fa||e.to==heavy[cur])continue;\n            secondDfs(e.to,cur);\n            r[cur] = r[e.to];\n        }\n    }\n    void init() {\n        firstDfs(root,0);\n        secondDfs(root,0);\n    }\n    \n    int kthFather(int k,int cur) {\n        while(k) {\n            if(head[cur] == cur) {\n                k--;\n                cur = fa[head[cur]];\n            } else {\n                if(dep[cur]-dep[head[cur]]<=k) {\n                    k-=dep[cur]-dep[head[cur]];\n                    cur = head[cur];\n                } else {\n                    return dfnToID[dfn[cur]-k];\n                }\n            }\n        }\n        return cur;\n    }\n    int LCA(int u,int v) {\n        while(head[u]!=head[v]) {\n            if(dep[head[u]]>dep[head[v]])swap(u,v);\n            v = fa[head[v]];\n        }\n        if(dep[u]<dep[v])return u;\n        return v;\n    }\n    \n    int dis(int u,int v){\n        return dep[u]+dep[v]-2*dep[LCA(u, v)];\n    }\n    void add(int low,int high){\n        while(head[low]!=head[high]){\n            tree.update(dfn[head[low]], 1);\n            tree.update(dfn[low]+1, -1);\n            low = fa[head[low]];\n        }\n        tree.update(dfn[high], 1);\n        tree.update(dfn[low]+1, -1);\n    }\n    \n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    in(n,l,s);\n    REP(i,1,n+1){in(weight[i]);if(weight[i]>s){\n        \n        cout<<-1;return 0;\n    }}\n    REP(i,2,n+1)in(par[i]);\n    REP(i,2,n+1){\n        HLD::adj[par[i]].push_back(HLD::edge(i));\n    }\n    HLD::init();\n    ll ans = 0;\n    RREP(i,n,1){\n        if(tree.query(HLD::dfn[i]) > 0)continue;\n        ans++;\n        int ll = 0,rr = l-1;\n        upmin(rr, HLD::dep[i]-1);\n//        dbg(rr);\n        while(ll<rr){\n            int mid = (ll+rr)/2+1;\n            int father = HLD::kthFather(mid, i);\n            if(HLD::sum[i]-HLD::sum[father]+weight[father] <= s){\n                ll = mid;\n            }else{\n                rr = mid-1;\n            }\n        }\n        int father = HLD::kthFather(ll, i);\n//        dbg(father);\n        HLD::add(i, father);\n    }\n    \n    \n    \n    \n    \n    \n    cout<<ans;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']","['binary search', 'data structures', 'dp', 'greedy', 'trees']",2400
https://codeforces.com//contest/665/problem/C,C. Simple Strings,loves simple strings A string is called simple if every pair of adjacent characters are distinct For example are simple whereas are not simple is given a string He wants to change a minimum number of characters so that the string becomes simple Help him with this task ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nchar wcz[1000007];\n\nint tak[1000007];\n\nint main()\n{\n    scanf(""%s"", wcz);\n    for (int i=0; 1; i++)\n    {\n        if (!wcz[i])\n        break;\n        if (wcz[i]==wcz[i+1])\n        {\n            wcz[i+1]=1;\n            tak[i+1]=1;\n        }\n    }\n    for (int i=0; 1; i++)\n    {\n        if (!wcz[i])\n        break;\n        if (tak[i])\n        {\n            if (wcz[i-1]!=\'a\' && wcz[i+1]!=\'a\')\n            {\n                wcz[i]=\'a\';\n            }\n            else\n            {\n                if (wcz[i-1]!=\'b\' && wcz[i+1]!=\'b\')\n                {\n                    wcz[i]=\'b\';\n                }\n                else\n                {\n                    wcz[i]=\'c\';\n                }\n            }\n        }\n        printf(""%c"", wcz[i]);\n    }\n    printf(""\\n"");\n    return 0;\n}\n']","['dp', 'greedy', 'strings']",1300
https://codeforces.com//contest/1151/problem/B,B. Dima and a Bad XOR,Student Dima from Kremland has a matrix a of size n times m filled with non negative integers He wants to select exactly one integer from each row of the matrix so that the of the selected integers is strictly greater than zero Help him Formally he wants to choose an integers sequence c 1 c 2 ldots c n 1 leq c j leq m so that the inequality a 1 c 1 oplus a 2 c 2 oplus ldots oplus a n c n 0 holds where a i j is the matrix element from the i th row and the j th column Here x oplus y denotes the bitwise XOR operation of integers x and y ,"['#include <vector>\n#include <iostream>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int> > A(H, vector<int>(W));\n\tint cur = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t\tcur ^= A[i][0];\n\t}\n\tint px = -1, py = -1;\n\tfor (int i = 0; i < H && px == -1; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tint nxt = cur ^ A[i][0] ^ A[i][j];\n\t\t\tif (nxt > 0) {\n\t\t\t\tpx = i, py = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (px >= 0 && py >= 0) {\n\t\tcout << ""TAK"" << endl;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (i) cout << \' \';\n\t\t\tcout << (i == px ? py + 1 : 1);\n\t\t}\n\t\tcout << endl;\n\t}\n\telse {\n\t\tcout << ""NIE"" << endl;\n\t}\n\treturn 0;\n}']","['bitmasks', 'brute force', 'constructive algorithms', 'dp']",1600
https://codeforces.com//contest/1928/problem/E,E. Modular Sequence,You are given two integers x and y A sequence a of length n is called if a 1 x and for all 1 i le n the value of a i is either a i 1 y or a i 1 bmod y Here x bmod y denotes the remainder from dividing x by y Determine if there exists a modular sequence of length n with the sum of its elements equal to S and if it exists find any such sequence ,"['#include<bits/stdc++.h>\n\nint main() {\n        std::cin.tie(nullptr)->sync_with_stdio(false);\n\n        int t;\n        std::cin >> t;\n        while (t--) {\n                int n, x, y, s;\n                std::cin >> n >> x >> y >> s;\n                long long st = x / y;\n                if (s < 1ll * (x % y) * n) {\n                        std::cout << ""NO\\n"";\n                        continue;\n                }\n                s -= (x % y) * n;\n                std::vector<int> dp(s + 1, 1e9);\n                std::vector<int> par(s + 1, -1);\n                dp[0] = 0;\n                for (int i = 0; i <= s; ++i) {\n                        for (int j = 1; i + j * (j - 1) / 2 * y <= s; ++j) {\n                                int k = i + j * (j - 1) / 2 * y;\n                                if (dp[k] > dp[i] + j) {\n                                        dp[k] = dp[i] + j;\n                                        par[k] = j;\n                                }\n                        }\n                }\n                bool ok = false;\n                for (int d = 1; (2 * st + d - 1) * d / 2 * y <= s; ++d) {\n                        if (d + dp[s - (2 * st + d - 1) * d / 2 * y] <= n) {\n                                std::cout << ""YES\\n"";\n                                std::vector<int> ans(n, x % y);\n                                int ptr = 0;\n                                for (int i = 0; i < d; ++i, ++ptr) ans[ptr] += (st + i) * y;\n                                int u = s - (2 * st + d - 1) * d / 2 * y;\n                                while (u != 0) {\n                                        int k = par[u];\n                                        u -= k * (k - 1) / 2 * y;\n                                        for (int i = 0; i < k; ++i, ++ptr) ans[ptr] += i * y;\n                                }\n                                for (auto i : ans) std::cout << i << \' \';\n                                std::cout << \'\\n\';\n                                ok = true;\n                                break;\n                        }\n                }\n                if (!ok) std::cout << ""NO\\n"";\n        }\n}']","['brute force', 'constructive algorithms', 'dp', 'graphs', 'greedy', 'math', 'number theory']",2300
https://codeforces.com//contest/222/problem/D,D. Olympiad,A boy named Vasya has taken part in an Olympiad His teacher knows that in total Vasya got at least points for both tours of the Olympiad The teacher has the results of the first and the second tour of the Olympiad but the problem is the results have only points no names The teacher has to know Vasya s chances Help Vasya s teacher find two numbers the best and the worst place Vasya could have won Note that the total results table sorts the participants by the sum of points for both tours the first place has the participant who has got the most points If two or more participants have got the same number of points it s up to the jury to assign places to them according to their choice It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nmultiset<int> s;\nint a[ 100001 ], b[ 100001 ];\n\nint main( )\n{\n\tint n, p, i, t1, t2, q = 1000000000, ans = 1;\n\tmultiset<int>::iterator ii;\n\tscanf(""%d%d"", &n, &p);\n\tfor ( i = 0; i < n; i++ ) scanf(""%d"", &a[ i ]);\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tscanf(""%d"", &b[ i ]);\n\t\ts.insert( b[ i ] );\n\t}\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tii = s.lower_bound( p - a[ i ] );\n\t\tif ( ii != s.end( ) )\n\t\t\tif ( q > *ii + a[ i ] )\n\t\t\t{\n\t\t\t\tq = *ii + a[ i ];\n\t\t\t\tt1 = *ii;\n\t\t\t\tt2 = i;\n\t\t\t}\n\t}\n\tii = s.find( t1 );\n\ts.erase( ii );\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tif ( i == t2 ) continue;\n\t\tii = s.lower_bound( q - a[ i ] );\n\t\tif ( ii != s.end( ) )\n\t\t{\n\t\t\tans++;\n\t\t\ts.erase( ii );\n\t\t}\n\t}\n\tprintf(""1 %d\\n"", ans);\n\treturn 0;\n}\n']","['binary search', 'greedy', 'sortings', 'two pointers']",1900
https://codeforces.com//contest/1451/problem/A,A. Subtract or Divide,Ridbit starts with an integer n In one move he can perform one of the following operations divide n by one of its divisors or subtract 1 from n if n is greater than 1 A proper divisor is a divisor of a number excluding itself For example 1 2 4 5 and 10 are proper divisors of 20 but 20 itself is not What is the minimum number of moves Ridbit is required to make to reduce n to 1 ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tll x; cin>>x;\n\t\tif(x==1)\n\t\t{\n\t\t\tcout<<0<<'\\n';\n\t\t}\n\t\telse if(x==2)\n\t\t{\n\t\t\tcout<<1<<'\\n';\n\t\t}\n\t\telse if(x%2==0||x==3)\n\t\t{\n\t\t\tcout<<2<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<3<<'\\n';\n\t\t}\n\t}\n}\n""]","['greedy', 'math']",800
https://codeforces.com//contest/367/problem/B,B. Sereja ans Anagrams,Sereja has two sequences and and number Sequence consists of integers Similarly sequence consists of integers As usual Sereja studies the sequences he has Today he wants to find the number of positions such that sequence can be obtained from sequence by rearranging elements Sereja needs to rush to the gym so he asked to find all the described positions of ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nmap <int, int> mp;\n\nint bad;\nint a[200010],b[200010],c[200010];\nbool ans[200010];\n\nvoid add(int x){\n    mp[x]++;\n    int tmp = mp[x];\n    if(tmp == 1) bad++;\n    if(tmp == 0) bad--;\n}\n\nvoid erase(int x){\n    mp[x]--;\n    int tmp = mp[x];\n    if(tmp == -1) bad++;\n    if(tmp == 0) bad--;\n}\n\nvoid func(int n, int m, int offset, int step){ // b: m, c: n, find b from c\n    int i;\n    \n    if(n < m) return;\n    \n    REP(i,m) add(c[i]);\n    if(bad == 0) ans[offset] = true;\n    // cout << offset << \' \' << bad << endl;\n    \n    for(i=m;i<n;i++){\n        add(c[i]);\n        erase(c[i-m]);\n        if(bad == 0) ans[offset + step * (i-m+1)] = true;\n        // cout << offset + step * (i-m+1) << \' \' << bad << endl;\n    }\n    \n    for(i=n-m;i<n;i++) erase(c[i]);\n}\n\nint main(void){\n    int n,m,p,i,j;\n    \n    cin >> n >> m >> p;\n    REP(i,n) scanf(""%d"", &a[i]);\n    REP(i,m) scanf(""%d"", &b[i]);\n    \n    REP(i,m) erase(b[i]);\n    \n    REP(i,p){\n        int n2 = 0;\n        for(j=i;j<n;j+=p){\n            c[n2] = a[j];\n            n2++;\n        }\n        func(n2, m, i, p);\n    }\n    \n    int cnt = 0;\n    REP(i,n) if(ans[i]) cnt++;\n    cout << cnt << endl;\n    bool first = true;\n    REP(i,n) if(ans[i]){\n        if(!first) printf("" "");\n        first = false;\n        printf(""%d"", i+1);\n    }\n    \n    cout << endl;\n    \n    return 0;\n}\n']","['binary search', 'data structures']",1900
https://codeforces.com//contest/1626/problem/C,C. Monsters And Spells,Monocarp is playing a computer game once again He is a wizard apprentice who only knows a single spell Luckily this spell can damage the monsters The level he s currently on contains n monsters The i th of them appears k i seconds after the start of the level and has h i health points As an additional constraint h i le k i for all 1 le i le n All k i are different Monocarp can cast the spell at moments which are positive integer amounts of second after the start of the level 1 2 3 dots The damage of the spell is calculated as follows If he didn t cast the spell at the previous second the damage is 1 Otherwise let the damage at the previous second be x Then he can choose the damage to be either x 1 or 1 A spell uses mana casting a spell with damage x uses x mana Mana doesn t regenerate To kill the i th monster Monocarp has to cast a spell with damage at least h i at the exact moment the monster appears which is k i Note that Monocarp can cast the spell even when there is no monster at the current second The mana amount required to cast the spells is the sum of mana usages for all cast spells Calculate the least amount of mana required for Monocarp to kill all monsters It can be shown that it s always possible to kill all monsters under the constraints of the problem ,"['#pragma region Macros\n//#pragma GCC target(""avx2"")\n// #pragma GCC optimize(""O3"")\n// #pragma comment(linker, ""/stack:200000000"")\n#ifdef ONLINE_JUDGE\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2"")\n// #pragma GCC target(""avx2"")\n#endif\n#pragma GCC optimize(""Ofast"")\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl \'\\n\'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= b; i -= c)\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define rng(v, l, r) v.begin() + l, v.begin() + r\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {""NO"", ""YES""};\nconst string YesNo[2] = {""No"", ""Yes""};\nconst string yesno[2] = {""no"", ""yes""};\nconst string firstsecond[2] = {""second"", ""first""};\nconst string FirstSecond[2] = {""Second"", ""First""};\nconst string possiblestr[2] = {""impossible"", ""possible""};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\n\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\n// bit 演算系\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - \'0\'; }\n    }\n    if(s[0] == \'-\') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << ""0""); }\n    i128 num = v;\n    if(v < 0) {\n        os << \'-\';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + \'0\'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? "", "" : "" "");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << \'(\'; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << \')\'; }\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << ""("" << p.first << "", "" << p.second << "")""; }\n    return os << p.first << "" "" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << ""["";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? """" : "", "") << y;\n        else\n            os << (f ? """" : "" "") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << ""]"";\n    return os;\n}\n\n#ifdef noimi\n#undef endl\nvoid debug() { cerr << endl; }\nvoid debug(bool) { cerr << endl; }\ntemplate <class Head, class... Tail> void debug(bool is_front, Head head, Tail... tail) {\n    if(!is_front) cerr << "", "";\n    cerr << head;\n    debug(false, tail...);\n}\n\n#define dump(args...)                                                                                                                                          \\\n    {                                                                                                                                                          \\\n        vector<string> _debug = _split(#args, \',\');                                                                                                            \\\n        err(true, begin(_debug), args);                                                                                                                        \\\n    }\n\nvector<string> _split(const string &s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while(getline(ss, x, c)) {\n        if(empty(v))\n            v.eb(x);\n        else {\n            bool flag = false;\n            for(auto [c, d] : {pair(\'(\', \')\'), pair(\'[\', \']\'), pair(\'{\', \'}\')}) {\n                if(count(all(v.back()), c) != count(all(v.back()), d)) flag = true;\n            }\n            if(flag)\n                v.back() += "","" + x;\n            else\n                v.eb(x);\n        }\n    }\n    return move(v);\n}\n\nvoid err(bool, vector<string>::iterator) { cerr << endl; }\ntemplate <typename T, typename... Args> void err(bool is_front, vector<string>::iterator it, T a, Args... args) {\n    if(!is_front) cerr << "", "";\n    cerr << it->substr((*it)[0] == \' \', (*it).size()) << "" = "" << a, err(false, ++it, args...);\n}\n\n// #define dump(...) cerr << #__VA_ARGS__ << "" : "", debug(true, __VA_ARGS__)\n#else\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n#endif\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << \' \';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(std::forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, std::forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nint toint(const char &c, const char start = \'a\') { return c - start; }\nint toint(const char &c, const string &chars) { return find(all(chars), c) - begin(chars); }\nint alphabets_to_int(const char &c) { return (islower(c) ? c - \'a\' : c - \'A\' + 26); }\ntemplate <typename T> auto toint(const T &v, const char &start = \'a\') {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\ntemplate <typename T> auto toint(const T &v, const string &start) {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\n// a -> 0, A -> 26\ntemplate <typename T> auto alphabets_to_int(const T &s) {\n    vector<decltype(alphabets_to_int(s[0]))> res;\n    res.reserve(s.size());\n    for(auto &&e : s) { res.emplace_back(alphabets_to_int(e)); }\n    return res;\n}\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        T mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#pragma endregion\n\nint main() {\n    TEST {\n        INT(n);\n        VEC(int, t, n);\n        VEC(int, a, n);\n        vi b(n);\n        rep(i, n) b[i] = t[i] - a[i] + 1;\n        auto tri = [&](ll l, ll r) { return (l + r) * (r - l + 1) / 2; };\n\n        auto id = iota(b);\n        int M = -1;\n        ll ans = 0;\n        ll now = 0;\n        fore(i, id) {\n            dump(b[i]);\n            if(b[i] > M) {\n                ans += tri(1, a[i]);\n                M = t[i];\n                now = a[i];\n            } else {\n                if(t[i] > M) {\n                    ans += tri(now + 1, now + (t[i] - M));\n                    now += t[i] - M;\n                    M = t[i];\n                }\n            }\n            dump(ans, M, now);\n        }\n        OUT(ans);\n    }\n}']","['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'math', 'two pointers']",1700
https://codeforces.com//contest/213/problem/C,C. Relay Race,Furik and Rubik take part in a relay race The race will be set up on a large square with the side of meters The given square is split into cells represented as unit squares each cell has some number At the beginning of the race Furik stands in a cell with coordinates and Rubik stands in a cell with coordinates Right after the start Furik runs towards Rubik besides if Furik stands at a cell with coordinates then he can move to cell or After Furik reaches Rubik Rubik starts running from cell with coordinates to cell with coordinates If Rubik stands in cell then he can move to cell or Neither Furik nor Rubik are allowed to go beyond the boundaries of the field if a player goes beyond the boundaries he will be disqualified To win the race Furik and Rubik must earn as many points as possible The number of points is the sum of numbers from the cells Furik and Rubik visited Print the maximum number of points Furik and Rubik can earn on the relay race ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\nconst int maxn = 300;\nconst int inf = 1000000000;\n\nint n;\nint a[maxn][maxn];\n\nint opt[2][maxn][maxn];\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(""%d"", &a[i][j]);\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                opt[i][j][k] = -inf;\n            }\n        }\n    }\n    opt[1][0][0] = 0;\n    for (int row = 0; row < n; row ++) {\n        int *b = a[row];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                opt[0][i][j] = opt[1][i][j];\n                if (opt[0][i][j] != -inf) {\n                    opt[0][i][j] += b[i];\n                }\n                opt[1][i][j] = -inf;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (opt[0][i][j] == -inf) {\n                    continue;\n                }\n                opt[1][i][j] = max(opt[1][i][j], opt[0][i][j] + (i < j ? b[j] : 0));\n                if (i + 1 < n) {\n                    int ni = i + 1, nj = max(i + 1, j);\n                    opt[0][ni][nj] = max(opt[0][ni][nj], opt[0][i][j] + b[ni]);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (opt[1][i][j] == -inf) {\n                    continue;\n                }\n                if (j + 1 < n) {\n                    opt[1][i][j + 1] = max(opt[1][i][j + 1], opt[1][i][j] + b[j + 1]);\n                }\n            }\n        }\n    }\n    cout << opt[1][n - 1][n - 1] << endl;\n}\n']",['dp'],2000
https://codeforces.com//contest/1580/problem/F,F. Problems for Codeforces,XYMXYM and CQXYM will prepare n problems for Codeforces The difficulty of the problem i will be an integer a i where a i geq 0 The difficulty of the problems must satisfy a i a i 1 m 1 leq i n and a 1 a n m where m is a fixed integer XYMXYM wants to know how many plans of the difficulty of the problems there are modulo 998 244 353 Two plans of difficulty a and b are different only if there is an integer i 1 leq i leq n satisfying a i neq b i ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int RT = 3;\n\nconst int MAXT = 19;\nconst int MAXL = 550000;\n\nint fac[MAXL + 5], ifac[MAXL + 5], inv[MAXL + 5];\nint rg[MAXT + 5];\n\nint ub2(int n)\n{\n\tint ret = 0;\n\twhile((1 << ret) < n) ret ++;\n\treturn ret;\n}\n\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1LL * ret * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint cr[MAXL + 5];\nvoid dft(int arr[], int siz, int dir)\n{\n\tif(dir == -1) reverse(arr + 1, arr + (1 << siz));\n\tint cur = 0;\n\tfor(int i = 0; i < (1 << siz); i ++) {\n\t\tif(cur < i) swap(arr[cur], arr[i]);\n\t\tfor(int j = siz - 1; j >= 0; j --) {\n\t\t\tcur ^= 1 << j;\n\t\t\tif(cur >> j & 1) break;\n\t\t}\n\t}\n\trep1(d, siz) {\n\t\tint pr = rg[d];\n\t\tcr[0] = 1;\n\t\tfor(int i = 1; i < (1 << (d - 1)); i ++) cr[i] = 1LL * cr[i - 1] * pr % MOD;\n\t\tfor(int i = 0; i < (1 << siz); i += 1 << d) rep(j, 1 << (d - 1)) {\n\t\t\tint ev = arr[i + j], od = 1LL * arr[i + j + (1 << (d - 1))] * cr[j] % MOD;\n\t\t\tarr[i + j] = ev + od - (ev + od >= MOD ? MOD : 0);\n\t\t\tarr[i + j + (1 << (d - 1))] = ev - od + (ev - od < 0 ? MOD : 0);\n\t\t}\n\t}\n\tif(dir == -1) {\n\t\tint invn = inv[1 << siz];\n\t\trep(i, 1 << siz) arr[i] = 1LL * arr[i] * invn % MOD;\n\t}\n}\n\nint tmp0[MAXL + 5], tmp1[MAXL + 5];\nvoid poly_mul(int A[], int B[], int ret[], int siz)\n{\n\trep(i, 1 << (siz + 1)) tmp0[i] = i >> siz ? 0 : A[i];\n\trep(i, 1 << (siz + 1)) tmp1[i] = i >> siz ? 0 : B[i];\n\tdft(tmp0, siz + 1, 1);\n\tdft(tmp1, siz + 1, 1);\n\trep(i, 1 << (siz + 1)) ret[i] = 1LL * tmp0[i] * tmp1[i] % MOD;\n\tdft(ret, siz + 1, -1);\n}\n\nvoid poly_inv(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) tmp1[i] = i == 0 ? power(A[0], MOD - 2) : 0;\n\trep1(i, siz) {\n\t\trep(j, 1 << (i + 1)) tmp0[j] = j >> i ? 0 : A[j];\n\t\trep(j, 1 << (i + 1)) tmp1[j] = j >> (i - 1) ? 0 : tmp1[j];\n\t\tdft(tmp0, i + 1, 1);\n\t\tdft(tmp1, i + 1, 1);\n\t\trep(j, 1 << (i + 1)) tmp1[j] = (2 + 1LL * (MOD - tmp0[j]) * tmp1[j] % MOD) * tmp1[j] % MOD;\n\t\tdft(tmp1, i + 1, -1);\n\t}\n\trep(i, 1 << siz) ret[i] = tmp1[i];\n}\n\nint tmp2[MAXL + 5];\nvoid poly_ln(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) if(i > 0) tmp2[i - 1] = 1LL * A[i] * i % MOD;\n\tpoly_inv(A, ret, siz);\n\tpoly_mul(ret, tmp2, ret, siz);\n\tfor(int i = (1 << siz) - 1; i >= 0; i --) ret[i] = i == 0 ? 0 : 1LL * inv[i] * ret[i - 1] % MOD;\n}\n\nint tmp3[MAXL + 5], tmp4[MAXL + 5];\nvoid poly_exp(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) tmp3[i] = i == 0;\n\trep1(i, siz) {\n\t\tpoly_ln(tmp3, tmp4, i);\n\t\trep(j, 1 << i) tmp4[j] = ((j == 0) + A[j] - tmp4[j] + MOD) % MOD;\n\t\tpoly_mul(tmp3, tmp4, tmp3, i);\n\t}\n\trep(i, 1 << siz) ret[i] = tmp3[i];\n}\n\nvoid init()\n{\n\trg[0] = 1;\n\trep1(i, MAXT) rg[i] = power(RT, (MOD - 1) >> i);\n\tfac[0] = 1;\n\trep1(i, MAXL) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\tifac[MAXL] = power(fac[MAXL], MOD - 2);\n\tfor(int i = MAXL; i >= 1; i --) ifac[i - 1] = 1LL * ifac[i] * i % MOD;\n\trep1(i, MAXL) inv[i] = 1LL * ifac[i] * fac[i - 1] % MOD;\n}\n\nint n, m, dat[300005], A[300005], B[300005], C[300005], D[300005], E[300005], F[300005], G[300005];\n\nint main()\n{\n\tinit();\n\tscanf(""%d%d"", &n, &m);\n\tint cur = 1;\n\trep1(i, n) {\n\t\tint maxt = (m + i) / 2;\n\t\tif(maxt == (m + i - 1) / 2) cur = 1LL * cur * (maxt - i + 1) % MOD;\n\t\telse cur = 1LL * cur * maxt % MOD;\n\t\tcur = 1LL * cur * inv[i] % MOD;\n\t\tdat[i] = (cur + MOD) % MOD;\n\t}\n\t\n\trep1(i, n) if(i % 4 == 0) A[i] = (MOD - dat[i]) % MOD;\n\telse if(i % 4 == 1) B[i] = dat[i];\n\telse if(i % 4 == 2) A[i] = dat[i];\n\telse B[i] = (MOD - dat[i]) % MOD;\n\t\n\tA[0] = 1;\n\trep1(i, n) A[i] = (MOD - A[i]) % MOD;\n\tpoly_inv(A, C, 16);\n\tpoly_mul(B, C, D, 16);\n\tD[0] = 1;\n\trep1(i, n) D[i] = (MOD - D[i]) % MOD;\n\tpoly_inv(D, E, 16);\n\tpoly_ln(C, F, 16);\n\tpoly_ln(E, G, 16);\n\tint ans = 1LL * n * (F[n] + G[n]) % MOD;\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']","['combinatorics', 'fft', 'math']",3300
https://codeforces.com//contest/1534/problem/E,E. Lost Array,Note the XOR sum of an array a 1 a 2 ldots a n 1 le a i le 10 9 is defined as a 1 oplus a 2 oplus ldots oplus a n where oplus denotes the bitwise XOR operation Little Dormi received an array of n integers a 1 a 2 ldots a n for Christmas However while playing with it over the winter break he accidentally dropped it into his XOR machine and the array got lost The XOR machine is currently configured with a query size of k which you cannot change and allows you to perform the following type of query by giving the machine k indices x 1 x 2 ldots x k it will output a x 1 oplus a x 2 oplus ldots oplus a x k As Little Dormi s older brother you would like to help him recover the of his array a 1 a 2 ldots a n by querying the XOR machine Little Dormi isn t very patient so to be as fast as possible you must query the XOR machine the number of times to find the XOR sum of his array Formally let d be the minimum number of queries needed to find the XOR sum of any array of length n with a query size of k Your program will be accepted if you find the correct XOR sum in at most d queries Lastly you also noticed that with certain configurations of the machine k and values of n it may not be possible to recover the XOR sum of Little Dormi s lost array If that is the case you should report it as well The array a 1 a 2 ldots a n is fixed before you start querying the XOR machine and does not change with the queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << endl; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint N,K;\nvb cur_state;\n\nint query(vi b) {\n\tassert(sz(b) == K);\n\tpr(""?"");\n\teach(t,b) {\n\t\tcur_state[t] = cur_state[t]^1;\n\t\tpr(\' \',t);\n\t}\n\tps();\n\tints(x); \n\trtn x;\n}\n\nvoid finish(int ans) {\n\tps(""!"",ans);\n\texit(0);\n}\n\nint main() {\n\tre(N,K);\n\tvi dp(N+1,MOD);\n\tvpi pre(N+1,{-2,-2});\n\tqueue<int> q;\n\tauto ad = [&](int x, int d, pi p) {\n\t\tif (dp[x] != MOD) return;\n\t\tdp[x] = d; pre[x] = p; q.push(x);\n\t};\n\tad(0,0,{-1,-1});\n\twhile (sz(q)) {\n\t\tint x = q.ft; q.pop();\n\t\tint rem = N-x;\n\t\tF0R(common,min(K,x)+1) if (K-common <= rem) {\n\t\t\tad(x-common+K-common,dp[x]+1,{x,common});\n\t\t}\n\t}\n\tif (dp[N] == MOD) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\tvi movs;\n\tint cur = N;\n\twhile (cur != 0) {\n\t\tmovs.pb(pre[cur].s);\n\t\tcur = pre[cur].f;\n\t}\n\treverse(all(movs));\n\tdbg(movs);\n\tint ans = 0;\n\tcur_state.rsz(N+1);\n\teach(m,movs) {\n\t\tvi yes, no;\n\t\tFOR(i,1,N+1) {\n\t\t\tif (cur_state[i]) yes.pb(i);\n\t\t\telse no.pb(i);\n\t\t}\n\t\tvi b;\n\t\trep(m) {\n\t\t\tassert(sz(yes));\n\t\t\tb.pb(yes.bk); yes.pop_back();\n\t\t}\n\t\trep(K-m) {\n\t\t\tassert(sz(no));\n\t\t\tb.pb(no.bk); no.pop_back();\n\t\t}\n\t\tans ^= query(b);\n\t}\n\tFOR(i,1,N+1) assert(cur_state[i]);\n\tfinish(ans);\n\n\n\t// N=K: ez\n\t// K even and N odd: bad\n\t// K=1: ez\n\t// K odd and K=N-1: N\n\t// K=3:\n\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['graphs', 'greedy', 'interactive', 'shortest paths']",2300
https://codeforces.com//contest/1841/problem/E,E. Fill the Matrix,There is a square matrix consisting of n rows and n columns of cells both numbered from 1 to n The cells are colored white or black Cells from 1 to a i are black and cells from a i 1 to n are white in the i th column You want to place m integers in the matrix from 1 to m There are two rules each cell should contain at most one integer black cells should not contain integers The of the matrix is the number of such j that j 1 is written in the same row in the next column as j in the neighbouring cell to the right What s the maximum possible beauty of the matrix ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << "" ""; cout << v[i];\n    }\n    cout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\ntemplate<typename T>\nstruct SegT {\nprivate:\n    int sz; vector<T> node;\n    T init_c;\n    function<T(T, T)> f;\npublic:\n    SegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        int n = v.size();\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n        rep(i, n) {\n            node[i + sz - 1] = v[i];\n        }\n        per(i, sz - 1) {\n            node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n    SegT(int n, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n    }\n    void update(int k, T a) {\n        k += sz - 1;\n        node[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            node[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0)r = sz;\n        if (r <= a || b <= l)return init_c;\n        else if (a <= l && r <= b)return node[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(vl, vr);\n        }\n    }\n    //k以上でf(x,node[y+sz-1])をtrueにするような最小のy\n    int searchloc(int le, T x, function<bool(T, T)> comp) {\n        int  k = le + sz - 1;\n        if (comp(x, node[k]))return le;\n        x = f(x, node[k]);\n        while (k > 0) {\n            int mem = k;\n            k = (k - 1) / 2;\n            if (2 * k + 1 == mem) {\n                if (comp(x, node[2 * k + 2])) {\n                    k = 2 * k + 2; break;\n                }\n                x = f(x, node[2 * k + 2]);\n            }\n        }\n        if (k == 0)return sz;\n        while (k < sz - 1) {\n            if (comp(x, node[2 * k + 1])) {\n                k = 2 * k + 1;\n            }\n            else {\n                x = f(x, node[2 * k + 1]);\n                k = 2 * k + 2;\n            }\n        }\n        return k - (sz - 1);\n    }\n\n};\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    rep(i, n)cin >> a[i];\n    auto f = [&](P a, P b) {\n        return max(a, b);\n    };\n    vector<P> ori(n);\n    rep(i, n)ori[i] = { a[i],i };\n    SegT<P> st(ori, { -1,-1 }, f);\n    vector<P> ps;\n    function<void(int, int, int)> dfs = [&](int l, int r, int d) {\n        if (l >= r)return;\n        P p = st.query(l, r);\n        int m = p.second;\n        if (a[m] < d) {\n            ps.push_back({ r - l,d - a[m] });\n        }\n        dfs(l, m, a[m]);\n        dfs(m + 1, r, a[m]);\n    };\n    dfs(0, n, n);\n    sort(all(ps), greater<P>());\n    ll ans = 0;\n    ll k; cin >> k;\n    rep(i, ps.size()) {\n        ll c = ps[i].second;\n        ll len = ps[i].first;\n        if (k <= c*len) {\n            ll d = k / len;\n            ans += (len - 1) * d;\n            ll r = k % len;\n            if (r > 0)ans += r - 1;\n            break;\n        }\n        else {\n            ans += (len - 1) * c;\n            k -= c * len;\n        }\n    }\n    //cout << ""ans is "";\n    cout << ans << ""\\n"";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}']","['data structures', 'greedy', 'math']",2200
https://codeforces.com//contest/741/problem/E,E. Arpa’s abnormal DNA and Mehrdad’s deep interest,Anyone knows that Arpa isn t a normal man he is well sorry I can t explain it more Mehrdad is interested about the reason so he asked Sipa one of the best biology scientists in Arpa s land for help Sipa has a DNA editor Sipa put Arpa under the DNA editor DNA editor showed Arpa s DNA as a string consisting of lowercase English letters Also Sipa has another DNA consisting of lowercase English letters that belongs to a normal man Now there are options to change Arpa s DNA numbered from to th of them is to put between th and th characters of If will be put before and if it will be put after Mehrdad wants to choose the most option for Arpa s DNA among these options DNA is more than if is lexicographically smaller than Mehrdad asked Sipa questions Given integers what is the most interesting option if we only consider such options that and If there are several most interesting options Mehrdad wants to know one with the smallest number Since Sipa is a biology scientist but not a programmer you should help him ,"['#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << "" = "" << x << endl\n#define _ << "" _ "" <<\n\ntypedef long long llint;\n\nconst int MAX = 201000;\nconst int B = 300;\n\nstruct STrmq {\n  vector<vector<int>> table;\n  vector<int> logs, array;\n\n  STrmq(const vector<int>& a) {\n    if (a.size() == 0) return;\n\n    array = a;\n    int lg = 0;\n    while ((1<<lg) <= (int)a.size()) lg++;\n    table = vector<vector<int>>(a.size(), vector<int>(lg));\n\n    REP(i, (int)a.size()) table[i][0] = i;\n    FOR(j, 1, lg) REP(i, (int)a.size()) {\n      if (i + (1<<(j-1)) < (int)a.size() && a[ table[i+(1<<(j-1))][j-1] ] < a[ table[i][j-1] ]) {\n        table[i][j] = table[i+(1<<(j-1))][j-1];\n      } else {\n        table[i][j] = table[i][j-1];\n      }\n    }\n\n    logs.resize(a.size() + 1);\n    logs[0] = 0;\n    FOR(i, 1, (int)a.size() + 1)\n      logs[i] = logs[i - 1] + (i == (1 << (logs[i-1]+1)));\n  }\n\n  int query(int a, int b) {\n    int k = logs[b - a + 1];\n    if (array[table[a][k]] <= array[table[b-(1<<k)+1][k]]) {\n      return table[a][k];\n    } else {\n      return table[b-(1<<k)+1][k];\n    }\n  }\n};\n\nvector<int> RMQ(const vector<int>& array, const vector<pair<int, int>>& queries) {\n  int n = array.size();\n  vector<int> dad(n);\n  function<int (int)> findset = [&] (int x) {\n    return x == dad[x] ? x : dad[x] = findset(dad[x]);\n  };\n \n  vector<vector<int>> qs(n);\n  REP(i, (int)queries.size()) qs[queries[i].second].push_back(i);\n\n  vector<int> ans(queries.size());\n  vector<int> stack;\n  REP(i, n) {\n    dad[i] = i;\n    while (stack.size() && array[stack.back()] > array[i]) {\n      dad[stack.back()] = i;\n      stack.pop_back();\n    }\n    stack.push_back(i);\n    for (int qi: qs[i]) ans[qi] = findset(queries[qi].first);\n  }\n  \n  return ans;\n}\n\nnamespace SuffixArray {\n  const int MAXN = 200020;\n\n  int lcp[MAXN], A[MAXN];\n  \n  void build(char *s, int n) {\n    static int tmp[MAXN], bc[MAXN];\n    REP(i, n) A[i] = i, bc[i] = s[i];\n\n    for (int T = 1; ; T *= 2) {\n      auto cmp = [&s, &T, &n] (const int &a, const int &b) {\n\tif (bc[a] != bc[b]) return bc[a] < bc[b];\n\tif (a+T >= n || b+T >= n) return a > b;\n\treturn bc[a+T] < bc[b+T];\n      };\n      sort(A, A + n, cmp);\n      tmp[A[0]] = 0;\n      FOR(i, 1, n) tmp[A[i]] = tmp[A[i-1]] + cmp(A[i-1], A[i]);\n      REP(i, n) bc[i] = tmp[i];\n      if (bc[A[n-1]] == n-1) break;\n    }\n\n    lcp[0] = 0;\n    int h = 0;\n    REP(i, n)\n      if (bc[i] > 0) {\n\tint j = A[ bc[i]-1 ];\n\twhile (i+h < n && j+h < n && s[i+h] == s[j+h]) h++;\n\tlcp[bc[i]] = h;\n\tif (h > 0) --h;\n      }\n  }\n};\n\nchar s[MAX];\nchar t[MAX];\nchar a[MAX];\n\nint slen, tlen;\n\nint main(void) {\n  int q;\n  scanf(""%s %s %d"", s, t, &q);\n  slen = strlen(s);\n  tlen = strlen(t);\n\n  REP(i, slen) a[i] = s[i];\n  REP(i, tlen) a[slen + i] = t[i];\n\n  SuffixArray::build(a, slen + tlen);\n  int* A = SuffixArray::A;\n  int* lcp = SuffixArray::lcp;\n  vector<int> invA(slen + tlen);\n  REP(i, slen + tlen) invA[A[i]] = i;\n  \n  STrmq lcp_rmq(vector<int>(lcp, lcp + slen + tlen));\n  auto get_lcp = [&] (int i, int j) {\n    assert(i < slen + tlen && j < slen + tlen);\n    if (i == j) return slen + tlen - i;\n    i = invA[i], j = invA[j];\n    if (i > j) swap(i, j);\n    return lcp[lcp_rmq.query(i + 1, j)];\n  };\n\n  vector<int> v;\n  REP(i, slen + 1) v.push_back(i);\n\n  sort(v.begin(), v.end(), [&] (int x, int y) {\n      int l;\n      bool flip = false;\n      if (x < y) swap(x, y), flip = true;\n      if (x-y >= tlen) {\n        if ((l = get_lcp(y, slen)) < tlen) return (a[y+l] < a[slen+l]) ^ flip;\n        if ((l = get_lcp(y+tlen, y)) < x-y-tlen) return (a[y+tlen+l] < a[y+l]) ^ flip;\n        if ((l = get_lcp(slen, x-tlen)) < tlen) return (a[slen+l] < a[x-tlen+l]) ^ flip;\n      } else {\n        if ((l = get_lcp(y, slen)) < x-y) return (a[y+l] < a[slen+l]) ^ flip;\n        if ((l = get_lcp(slen, slen+x-y)) < tlen-(x-y)) return (a[slen+l] < a[slen+x-y+l]) ^ flip;\n        if ((l = get_lcp(slen+tlen-(x-y), y)) < (x-y)) return (a[slen+tlen-(x-y)+l] < a[y+l]) ^ flip;\n      }\n      return (x < y) ^ flip;\n    }\n  );\n\n  int n = slen + 1;\n  vector<int> a(n);\n  REP(i, n) a[v[i]] = i;\n  \n  STrmq rmq(a);\n\n  vector<pair<int, int>> ans(q);\n  vector<int> ql(q), qr(q), qk(q), qx(q), qy(q);\n  vector<vector<int>> qs(B);\n\n  REP(i, q) {\n    scanf(""%d %d %d %d %d"", &ql[i], &qr[i], &qk[i], &qx[i], &qy[i]);\n    \n    ans[i] = {n, -1};\n    \n    if (qk[i] < B) {\n      qs[qk[i]].push_back(i);\n    } else {\n      int x = qx[i], y = qy[i];\n      while (x < n) {\n        int l = max(ql[i], x);\n        int r = min(qr[i], y);\n        if (l <= r) {\n          int best = rmq.query(l, r);\n          ans[i] = min(ans[i], {a[best], best});\n        }\n        x += qk[i], y += qk[i];\n      }\n    }\n  }\n    \n  FOR(k, 1, B) {\n    REP(i, k) {\n      vector<int> v;\n      for (int j = i; j < n; j += k)\n        v.push_back(a[j]);\n\n      vector<pair<int, int>> queries;\n      vector<int> queries_id;\n      \n      for (int qi: qs[k]) {\n        if (qx[qi] <= i && i <= qy[qi] && qr[qi] >= i) {\n          int l = (ql[qi]-i+k-1) / k;\n          int r = (qr[qi]-i) / k;\n          if (l <= r) {\n            queries.push_back({l, r});\n            queries_id.push_back(qi);\n          }\n        }\n      }\n\n      if (v.size() && queries.size()) {\n        vector<int> mins = RMQ(v, queries);\n        REP(j, (int)mins.size()) {\n          int qi = queries_id[j];\n          int best = mins[j]*k + i;\n          ans[qi] = min(ans[qi], {a[best], best});\n        }\n      }\n    }\n  }\n  \n  REP(i, q) printf(""%d "", ans[i].second);\n  printf(""\\n"");\n\n  return 0;\n}\n']","['data structures', 'string suffix structures']",3400
https://codeforces.com//contest/1236/problem/B,B. Alice and the List of Presents,Alice got many presents these days So she decided to pack them into boxes and send them to her friends There are n kinds of presents Presents of one kind are identical i e there is no way to distinguish two gifts of the same kind Presents of different kinds are different i e that is two gifts of different kinds are distinguishable The number of presents of each kind that Alice has is very big so we can consider Alice has an infinite number of gifts of each kind Also there are m boxes All of them are for different people so they are pairwise distinct consider that the names of m friends are written on the boxes For example putting the first kind of present into the first box but not into the second box is different from putting the first kind of present into the second box but not into the first box Alice wants to pack presents with the following rules She won t pack more than one present of each kind into the same box so each box should contain presents of different kinds i e each box contains a subset of n kinds empty boxes are allowed For each kind at least one present should be packed into some box Now Alice wants to know how many different ways to pack the presents exists Please help her and calculate this number Since the answer can be huge output it by modulo 10 9 7 See examples and their notes for clarification ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\ntypedef long long ll;\n\n\n//returns a^pw % mod\nll fastPow(ll a, ll pw, ll mod) {\n    ll res = 1;\n    a %= mod;\n    while(pw > 0) {\n        if(pw & 1) res = (res*a)%mod;\n        a = (a*a)%mod;\n        pw >>= 1;\n    }\n    return res;\n}\n\nconst int mod = 1e9+7;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin >> n >> m;\n    cout << fastPow((fastPow(2,m,mod)-1+mod),n,mod);\n\n\n}\n""]","['combinatorics', 'math']",1500
https://codeforces.com//contest/1891/problem/F,F. A Growing Tree,You are given a rooted tree with the root at vertex 1 initially consisting of a single vertex Each vertex has a numerical value initially set to 0 There are also q queries of two types The first type add a child vertex with the number sz 1 to vertex v where sz is the current size of the tree The numerical value of the new vertex will be 0 The second type add x to the numerical values of all vertices in the subtree of vertex v After all queries output the numerical value of all of the vertices in the final tree ,"['#include <cstdio>\n#include <vector>\nusing namespace std;\nint read(){\n\tchar c=getchar();int x=0;bool f=0;\n\twhile(c<48||c>57) f|=(c==\'-\'),c=getchar();\n\tdo x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\twhile(c>=48&&c<=57);\n\tif(f) return -x;\n\treturn x;\n}\nconst int N=1000003;\ntypedef long long ll;\nvector<int> vec[N];\nint ft[N],sn[N],sz[N],tp[N],dfn[N],num;\nvoid dfs(int u){\n\tsz[u]=1;sn[u]=0;\n\tfor(int v:vec[u]){\n\t\tft[v]=u;\n\t\tdfs(v);\n\t\tsz[u]+=sz[v];\n\t\tif(sz[v]>sz[sn[u]]) sn[u]=v;\n\t}\n}\nvoid split(int u,int tops){\n\ttp[u]=tops;dfn[u]=++num;\n\tif(sn[u]) split(sn[u],tops);\n\tfor(int v:vec[u]){\n\t\tif(v==sn[u]) continue;\n\t\tsplit(v,v);\n\t}\n}\ntypedef long long ll;\nint op[N],val[N],vv[N];\nll tr[N];\nvoid upd(int x,ll v){for(int i=x;i<=num;i+=(i&-i)) tr[i]+=v;}\nll qry(int x){\n\tll res=0;\n\tfor(int i=x;i;i^=(i&-i)) res+=tr[i];\n\treturn res;\n}\nll query(int x){\n\tll res=0;\n\twhile(x){\n\t\tres+=qry(dfn[x])-qry(dfn[tp[x]]-1);\n\t\tx=ft[tp[x]];\n\t}\n\treturn res;\n}\nll res[N];\nvoid calc(int u,ll cur){\n\tcur+=qry(dfn[u])-qry(dfn[u]-1);\n\tres[u]=cur;\n\tfor(int v:vec[u]) calc(v,cur);\n}\nint main(){\n\tint tc=read();\n\twhile(tc--){\n\t\tint q=read();\n\t\tint sz=1;\n\t\tnum=0;\n\t\tfor(int i=1;i<=q;++i){\n\t\t\top[i]=read();\n\t\t\tval[i]=read();\n\t\t\tif(op[i]==1) vec[val[i]].emplace_back(++sz);\n\t\t\telse vv[i]=read();\n\t\t}\n\t\tdfs(1);\n\t\tsplit(1,1);\n\t\tsz=1;\n\t\tfor(int i=1;i<=q;++i)\n\t\t\tif(op[i]==1){\n\t\t\t\t++sz;\n\t\t\t\tupd(dfn[sz],-query(val[i]));\n\t\t\t}\n\t\t\telse upd(dfn[val[i]],vv[i]);\n\t\tcalc(1,0);\n\t\tfor(int i=1;i<=sz;++i) printf(""%lld "",res[i]);\n\t\tputchar(\'\\n\');\n\t\tfor(int i=1;i<=sz;++i) vec[i].clear(),tr[i]=0;\n\t}\n\treturn 0;\n}\n']","['data structures', 'dfs and similar', 'trees']",2000
https://codeforces.com//contest/557/problem/E,E. Ann and Half-Palindrome,Tomorrow Ann takes the hardest exam of programming where she should get an excellent mark On the last theoretical class the teacher introduced the notion of a String is a if for all the odd positions the following condition is held where is the length of string if positions are indexed from For example strings are half palindromes and strings and are not Ann knows that on the exam she will get string consisting only of letters and and number To get an excellent mark she has to find the th in the lexicographical order string among all substrings of that are half palyndromes Note that each substring in this order is considered as many times as many times it occurs in The teachers guarantees that the given number doesn t exceed the number of substrings of the given string that are half palindromes Can you cope with this problem ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9+9; \nlong long hasht [5005][5005]; \nint ishalf [5005][5005]; \nint pref [5005][5005]; \nchar ans [5005]; \nlong long pow29 [5005]; \nstring a; \nlong long counter = 0; \nint main()\n{\n    ios_base::sync_with_stdio(0);\n    pow29[0]=1; \n    for (long long g=1; g<=5000; g++)\n    {\n        pow29[g]=(1LL*29*pow29[g-1])%mod; \n    }\n    cin >> a; \n    long long k; cin >> k; \n    for (long long g=0; g<a.length(); g++)\n    {\n        ishalf[g][g]=1; \n    }\n    for (long long g=2; g<=a.length(); g++)\n    {\n        for (long long y=0; y<=a.length()-g; y++)\n        {\n            long long start = y, end = y+g-1; \n            if (a[start]==a[end])\n            {\n                if (ishalf[start+2][end-2] || start+2>=end-2)\n                {\n                    ishalf[start][end]=1; \n                }\n            }\n        }\n    }\n    for (long long g=0; g<a.length(); g++)\n    {\n        for (long long y=a.length()-1; y>=g; y--)\n        {\n            pref[g][y]=ishalf[g][y]+pref[g][y+1];\n        }\n    }\n    for (long long g=0; g<a.length(); g++)\n    {\n        for (long long y=g; y<a.length(); y++)\n        {\n            hasht[g][y]=hasht[g][y-1]+(pow29[y-g]*(a[y]-'a'+1)); \n            if (hasht[g][y]>=mod) hasht[g][y]-=mod; \n            if (hasht[g][y]>=mod) hasht[g][y]-=mod; \n        }\n    }\n    long long curhash = 0; \n    while (k)\n    {\n        long long storehash1 = curhash + pow29[counter];\n        if (storehash1>=mod) storehash1-=mod; \n        long long storehash2 = storehash1 + pow29[counter]; \n        if (storehash2>=mod) storehash2-=mod; \n        long long checker = 0, exactsame1=0, exactsame2=0;      \n        for (long long g=0; g+counter<a.length(); g++)\n        {\n            if (hasht[g][g+counter]==storehash1)\n            {\n                checker+=pref[g][g+counter]; \n                if (ishalf[g][g+counter])\n                exactsame1++; \n            }\n            if (ishalf[g][g+counter]==1 && hasht[g][g+counter]==storehash2) exactsame2++;\n        }\n        /*\n        if (counter==1)\n        {\n            cout << exactsame1 << ' ' << checker << '\\n';break;\n        }\n        */\n        if (checker>=k)\n        {\n            if (exactsame1>=k)\n            {\n                ans[counter]='a'; counter++; break; \n            }\n            checker-=exactsame1; \n            k-=exactsame1; \n            ans[counter]='a'; \n            curhash=storehash1; \n        }\n        else\n        {\n            k-=checker; \n            if (exactsame2>=k)\n            {\n                ans[counter]='b'; counter++; break; \n            }\n            k-=exactsame2; \n            ans[counter]='b'; \n            curhash=storehash2;\n        }\n        counter++; \n    }\n    for (long long g=0; g<counter; g++) cout << ans[g]; \n    return 0;\n}""]","['data structures', 'dp', 'graphs', 'string suffix structures', 'strings', 'trees']",2300
https://codeforces.com//contest/418/problem/A,A. Football,One day at the Russian Code Cup event it was decided to play football as an out of competition event All participants was divided into teams and played several matches two teams could not play against each other more than once The appointed Judge was the most experienced member Pavel But since he was the wisest of all he soon got bored of the game and fell asleep Waking up he discovered that the tournament is over and the teams want to know the results of all the matches Pavel didn t want anyone to discover about him sleeping and not keeping an eye on the results so he decided to recover the results of all games To do this he asked all the teams and learned that the real winner was friendship that is each team beat the other teams exactly times Help Pavel come up with chronology of the tournir that meets all the conditions or otherwise report that there is no such table ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  scanf(""%d %d"", &n, &k);\n  if (k > (n - 1) / 2) {\n    printf(""%d\\n"", -1);\n  } else {\n    printf(""%d\\n"", n * k);\n    for (int i = 1; i <= n; i++)\n      for (int j = 0; j < k; j++) printf(""%d %d\\n"", i, (i + j) % n + 1);\n  }\n  return 0;\n}\n']","['constructive algorithms', 'graphs', 'implementation']",1400
https://codeforces.com//contest/1538/problem/A,A. Stone Game,Polycarp is playing a new computer game This game has n stones in a row The stone on the position i has integer power a i Each turn Polycarp can destroy either stone on the first position or stone on the last position in other words either the leftmost or the rightmost stone When Polycarp destroys the stone it does not exist any more Now Polycarp wants two achievements He gets them if he destroys the stone with the power and the stone with the power Help Polycarp find out what is the minimum number of moves he should make in order to achieve his goal For example if n 5 and a 1 5 4 3 2 then Polycarp could make the following moves Destroy the leftmost stone After this move a 5 4 3 2 Destroy the rightmost stone After this move a 5 4 3 Destroy the leftmost stone After this move a 4 3 Polycarp destroyed the stones with the greatest and least power so he can end the game Please note that in the example above you can complete the game in two steps For example Destroy the leftmost stone After this move a 5 4 3 2 Destroy the leftmost stone After this move a 4 3 2 Polycarp destroyed the stones with the greatest and least power so he can end the game ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nint n,m,i,j,k,t,t1,u,v,a,b;\nint pos[100001];\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n;\n        for (i=1;i<=n;i++)\n        {\n            cin>>u;\n            pos[u]=i;\n        }\n        cout<<min(n-(abs(pos[n]-pos[1])-1),min(max(pos[1],pos[n]),n-min(pos[1],pos[n])+1))<<endl;\n    }\n}\n']","['brute force', 'dp', 'greedy']",800
https://codeforces.com//contest/216/problem/C,C. Hiring Staff,A new Berland businessman Vitaly is going to open a household appliances store All he s got to do now is to hire the staff The store will work seven days a week but not around the clock Every day at least people must work in the store Berland has a law that determines the order of working days and non working days Namely each employee must work for exactly consecutive days then rest for exactly days then work for more days and rest for more and so on Vitaly doesn t want to break the law Fortunately there is a loophole the law comes into force on the day when the employee is hired For example if an employee is hired on day then he should work on days and so on Day can be chosen arbitrarily by Vitaly There is one more thing the key to the store Berland law prohibits making copies of keys so there is only one key Vitaly is planning to entrust the key to the store employees At the same time on each day the key must be with an employee who works that day otherwise on this day no one can get inside the store During the day the key holder can give the key to another employee if he also works that day The key will handed to the first hired employee at his first working day Each employee has to be paid salary Therefore Vitaly wants to hire as few employees as possible provided that the store can operate normally on each day from to infinity In other words on each day with index from to infinity the store must have at least working employees and one of the working employees should have the key to the store Help Vitaly and determine the minimum required number of employees as well as days on which they should be hired ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\nint main()\n{\n  int i,m,n,k,st;\n  vector<int> a;\n  scanf(""%d%d%d"",&n,&m,&k);\n  a.clear();\n  st=0;\n  for (i=0;i<n+m;i++)\n  {\n    while (a.size()-st<k)\n      a.push_back(i+1);\n    while ((st<a.size())&&(i+2-a[st]>=n)) st++;\n    if (st==a.size()) a.push_back(i+1);\n  }\n  printf(""%d\\n"",a.size());\n  for (i=0;i<a.size();i++)\n  {\n    if (i!=0) printf("" "");\n    printf(""%d"",a[i]);\n  }\n  printf(""\\n"");\n}\n']",['greedy'],1800
https://codeforces.com//contest/1483/problem/A,A. Basic Diplomacy,Aleksey has n friends He is also on a vacation right now so he has m days to play this new viral cooperative game But since it s cooperative Aleksey will need one teammate in each of these m days On each of these days some friends will be available for playing and all others will not On each day Aleksey must choose one of his available friends to offer him playing the game and they of course always agree However if any of them happens to be chosen strictly more than left lceil dfrac m 2 right rceil times then all other friends are offended Of course Aleksey doesn t want to offend anyone Help him to choose teammates so that nobody is chosen strictly more than left lceil dfrac m 2 right rceil times ,"['#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, M; cin >> N >> M;\n\n\t\tvector<vector<int>> F(M);\n\t\tfor (auto& v : F) {\n\t\t\tint k; cin >> k;\n\t\t\tv.resize(k);\n\t\t\tfor (auto& a : v) cin >> a;\n\t\t}\n\n\t\tvector<int> cnt(N+1);\n\t\tvector<int> C(M);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tC[i] = F[i][0];\n\t\t\tcnt[C[i]]++;\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (cnt[v] > (M+1)/2) {\n\t\t\t\tfor (int i = 0; cnt[v] > (M+1)/2 && i < M; i++) {\n\t\t\t\t\tif (C[i] == v && int(F[i].size()) > 1) {\n\t\t\t\t\t\tcnt[C[i]]--;\n\t\t\t\t\t\tC[i] = F[i][1];\n\t\t\t\t\t\tcnt[C[i]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt[v] > (M+1)/2) {\n\t\t\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\t\t\tgoto finished;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ""YES"" << \'\\n\';\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcout << C[i] << "" \\n""[i+1==M];\n\t\t}\n\nfinished:;\n\t}\n\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'implementation']",1600
https://codeforces.com//contest/718/problem/A,A. Efim and Strange Grade,Efim just received his grade for the last test He studies in a special school and his grade can be equal to any positive decimal fraction First he got disappointed as he expected a way more pleasant result Then he developed a tricky plan Each second he can ask his teacher to round the grade at any place after the decimal point also he can ask to round to the nearest integer There are seconds left till the end of the break so Efim has to act fast Help him find what is the maximum grade he can get in no more than seconds Note that he can choose to not use all seconds Moreover he can even choose to not round the grade at all In this problem classic rounding rules are used while rounding number to the th digit one has to take a look at the digit If it is less than than the th digit remain unchanged while all subsequent digits are replaced with Otherwise if the digit is greater or equal to the digit at the position is increased by this might also change some other digits if this one was equal to and all subsequent digits are replaced with At the end all trailing zeroes are thrown away For example if the number is rounded to the first decimal place the result is while if we round to the nearest integer the result is Rounding number in the fifth decimal place will result in number ,"['#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint n, t;\nstring s;\n\nvoid incByOne(string &s)\n{\n\tint pnt = int(s.length()) - 1;\n\twhile (pnt >= 0 && s[pnt] == \'9\')\n\t\ts[pnt--] = \'0\';\n\tif (pnt >= 0) s[pnt]++;\n\telse s = ""1"" + s;\n}\n\nint main()\n{\n\tcin >> n >> t;\n\tcin >> s;\n\tint pos = s.find(\'.\');\n\tint ind = pos + 1;\n\twhile (ind < s.length() && s[ind] < \'5\') ind++;\n\tif (ind >= s.length()) printf(""%s\\n"", s.c_str());\n\telse {\n\t\tint lst = s.length();\n\t\twhile (ind > pos && s[ind] >= \'5\' && t) {\n\t\t\tif (ind - 1 == pos) {\n\t\t\t\ts = s.substr(0, pos);\n\t\t\t\tincByOne(s);\n\t\t\t\tprintf(""%s\\n"", s.substr().c_str());\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts[ind - 1]++;\n\t\t\tfor (int j = ind; j < lst; j++)\n\t\t\t\ts[j] = \'0\';\n\t\t\tlst = ind; ind--; t--;\n\t\t}\n\t\tlst = int(s.length()) - 1;\n\t\twhile (s[lst] == \'0\') lst--;\n\t\tprintf(""%s\\n"", s.substr(0, lst + 1).c_str());\n\t}\n\treturn 0;\n}']","['dp', 'implementation', 'math']",1700
https://codeforces.com//contest/1777/problem/F,F. Comfortably Numb,You are given an array a consisting of n non negative integers The of a subarray a l a l 1 ldots a r for arbitrary l leq r is defined as max a l a l 1 ldots a r oplus a l oplus a l 1 oplus ldots oplus a r where oplus denotes the bitwise XOR operation Find the maximum numbness over all subarrays ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nvector<int> lg(2);\ntemplate <typename T> struct maxtable\n{\n\tvector<T> a;\n\tvector<vector<T>> st;\n\tmaxtable(const vector<T> &b) :a(all(b))\n\t{\n\t\tint n=a.size(),i,j,k,r;\n\t\twhile (lg.size()<=n) lg.push_back(lg[lg.size()>>1]+1);\n\t\tst.assign(lg[n]+1,vector<T>(n));\n\t\tiota(all(st[0]),0);\n\t\tfor (j=1; j<=lg[n]; j++)\n\t\t{\n\t\t\tr=n-(1<<j);\n\t\t\tk=1<<j-1;\n\t\t\tfor (i=0; i<=r; i++) st[j][i]=a[st[j-1][i]]<a[st[j-1][i+k]]?st[j-1][i+k]:st[j-1][i];\n\t\t}\n\t}\n\tT rmq(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn max(a[st[z][l]],a[st[z][r-(1<<z)+1]]);\n\t}\n\tint rmp(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn a[st[z][l]]<a[st[z][r-(1<<z)+1]]?st[z][r-(1<<z)+1]:st[z][l];\n\t}\n};\nconst int N=7e6+5;\nint c[N][2],s[N];\nint id;\nvoid insert(int &x,int y,int w,int dep)\n{\n\tx=++id; s[x]=s[y]+1;\n\tif (dep==-1) return;\n\tint o=w>>dep&1;\n\tc[x][o^1]=c[y][o^1];\n\tinsert(c[x][o],c[y][o],w,dep-1);\n}\nint ask(int x,int y,int w)\n{\n\tint r=0,o;\n\tfor (int i=29; i>=0; i--)\n\t{\n\t\to=1^w>>i&1;\n\t\tif (s[c[x][o]]==s[c[y][o]]) o^=1;\n\t\telse r|=1<<i;\n\t\tx=c[x][o]; y=c[y][o];\n\t}\n\treturn r;\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tfor (i=1; i<=id; i++) c[i][0]=c[i][1]=s[i]=0;\n\t\tcin>>n;\n\t\tvector<int> a(n+1),sum(n+1);\n\t\tfor (i=1; i<=n; i++) cin>>a[i];\n\t\t// for (i=1; i<=n; i++) a[i]=i;\n\t\tfor (i=1; i<=n; i++) sum[i]=sum[i-1]^a[i];\n\t\tvector<int> rt(n+1);\n\t\tid=0;\n\t\tfor (i=0; i<=n; i++) insert(rt[i],i==0?0:rt[i-1],sum[i],29);\n\t\tmaxtable t(a);\n\t\tint ans=0;\n\t\tfunction<void(int,int)> dfs=[&](int l,int r)\n\t\t{\n\t\t\tif (l>r) return;\n\t\t\tint m=t.rmp(l,r);\n\t\t\t//[l-1,m-1],[m,r]\n\t\t\tif (m-l<r-m)\n\t\t\t{\n\t\t\t\tfor (int i=l-1; i<=m-1; i++) cmax(ans,ask(rt[m-1],rt[r],sum[i]^a[m]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i=m; i<=r; i++) cmax(ans,ask(l==1?0:rt[l-2],rt[m-1],sum[i]^a[m]));\n\t\t\t}\n\t\t\tdfs(l,m-1); dfs(m+1,r);\n\t\t};\n\t\tdfs(1,n);\n\t\tcout<<ans<<\'\\n\';\n\t}\n}\n']","['bitmasks', 'data structures', 'divide and conquer', 'strings', 'trees']",2400
https://codeforces.com//contest/1760/problem/D,D. Challenging Valleys,You are given an array a 0 dots n 1 of n integers This array is called a if there exists subarray a l dots r such that 0 le l le r le n 1 a l a l 1 a l 2 dots a r l 0 or a l 1 a l r n 1 or a r a r 1 Here are three examples The first image shows the array 3 2 2 1 2 2 3 it because only subarray with indices l r 3 satisfies the condition The second image shows the array 1 1 1 2 3 3 4 5 6 6 6 it because only subarray with indices l 0 r 2 satisfies the codition The third image shows the array 1 2 3 4 3 2 1 it because two subarrays l r 0 and l r 6 that satisfy the condition You are asked whether the given array is a valley or not ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define int long long\n#define pb push_back\n#define pf push_front\n#define ppf pop_front\n#define ppb pop_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n\nvoid freo(string x) {\n  freopen((x + "".in"").c_str(), ""r"", stdin);\n  freopen((x + "".out"").c_str(), ""w"", stdout);\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector <pair <int, int>> comp;\n  int l = 0;\n  for (int i = 1; i < n; i++) {\n    if (a[i] != a[l]) {\n      comp.pb({l, i - 1});\n      l = i;\n    } \n  }\n  comp.pb({l, n - 1});\n  int cnt = 0;\n  for (auto i : comp) {\n    if ((i.F == 0 || a[i.F - 1] > a[i.F]) && (i.S == n - 1 || a[i.S + 1] > a[i.S])) cnt++;\n  }\n  if (cnt == 1) cout << ""YES\\n"";\n  else cout << ""NO\\n"";\n}\n\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  //freo(""timeline"");\n  int tt = 1;\n  cin >> tt;\n  while (tt--) solve();\n}']","['implementation', 'two pointers']",1000
https://codeforces.com//contest/595/problem/B,B. Pasha and Phone,Pasha has recently bought a new phone and started adding his friends phone numbers there Each phone number consists of exactly digits Also Pasha has a number and two sequences of length is divisible by and Let s split the phone number into blocks of length The first block will be formed by digits from the phone number that are on positions the second block will be formed by digits from the phone number that are on positions and so on Pasha considers a phone number if the th block doesn t start from the digit and is divisible by if represented as an integer To represent the block of length as an integer let s write it out as a sequence Then the integer is calculated as the result of the expression Pasha asks you to calculate the number of phone numbers of length for the given and As this number can be too big print it modulo ,"['#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, const char * argv[]) {\n    std::ios::sync_with_stdio(false);\n\n    int n, k;\n    cin >> n >> k;\n    long long res = 1;\n    \n    long long a, b;\n    long long max_number = 9;\n    long long ten = 1;\n    for (int i = 0; i + 1< k; ++i) {\n        max_number = max_number * 10 + 9;\n        ten *= 10;\n    }\n    \n    vector<int> aa(n/k);\n    vector<int> bb(n/k);\n    for (int i = 0; i < n/k; ++i) {\n        cin >> aa[i];\n    }\n    for (int i = 0; i < n/k; ++i) {\n        cin >> bb[i];\n    }\n    \n    for (int i = 0; i < n/k; ++i) {\n        vector<long long> kol(10, 0);\n        \n        a = aa[i];\n        b = bb[i];\n        long long sum = 0;\n\n        for (int j = 0; j < 10; ++j) {\n            kol[j] = (ten * (j + 1) - 1) / a + 1;\n            if (j != b) {\n                sum += kol[j] - (j > 0 ? kol[j - 1] : 0);\n            }\n        }\n        res *= sum;\n        res %= 1000000007;\n    }\n    \n    cout << res;\n    \n    return 0;\n}\n']","['binary search', 'math']",1600
https://codeforces.com//contest/66/problem/B,B. Petya and Countryside,Little Petya often travels to his grandmother in the countryside The grandmother has a large garden which can be represented as a rectangle in size when viewed from above This rectangle is divided into equal square sections The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section Creating artificial rain is an expensive operation That s why we limit ourselves to creating the artificial rain only above one section At that the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section That is for example the garden can be represented by a rectangle where the section heights are equal to 4 2 3 3 2 Then if we create an artificial rain over any of the sections with the height of 3 the water will flow over all the sections except the ones with the height of 4 See the illustration of this example at the picture As Petya is keen on programming he decided to find such a section that if we create artificial rain above it the number of watered sections will be maximal Help him ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""b""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nint N, a[1005];\n\nvoid Load ()\n{\n    cin >> N;\n\n    for (int i = 0;i < N;i++)\n        cin >> a[i];\n}\n\nvoid Solve ()\n{\n    int ans = 0;\n\n    for (int i = 0;i < N;i++)\n    {\n        int cur = 1;\n        for (int j = i - 1;j >= 0 && a[j] <= a[j + 1];j--) cur++;\n        for (int j = i + 1;j < N && a[j] <= a[j - 1];j++) cur++;\n        ans = max (ans, cur);\n    }\n    cout << ans;\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","['brute force', 'implementation']",1100
https://codeforces.com//contest/1493/problem/B,B. Planet Lapituletti,The time on the planet Lapituletti goes the same way it goes on Earth but a day lasts h hours and each hour lasts m minutes The inhabitants of that planet use digital clocks similar to earth ones Clocks display time in a format the number of hours in decimal is displayed first then after the colon follows the number of minutes in decimal the number of minutes and hours is written with leading zeros if needed to form a two digit number Hours are numbered from 0 to h 1 and minutes are numbered from 0 to m 1 That s how the digits are displayed on the clock Please note that digit 1 is placed in the of its position A standard mirror is in use on the planet Lapituletti Inhabitants often look at the reflection of the digital clocks in the mirror and feel happy when what you see on the reflected clocks is a valid time that means that you see valid digits in the reflection and this time can be seen on the normal clocks at some moment of a day The image of the clocks in the mirror is reflected against a vertical axis The reflection is not a valid time The reflection is a valid time with h 24 m 60 However for example if h 10 m 60 then the reflection is not a valid time An inhabitant of the planet Lapituletti begins to look at a mirrored image of the clocks at some time moment s and wants to know the nearest future time moment which can possibly happen on the next day when the reflected clock time is valid It can be shown that with any h m s such a moment exists If the reflected time is correct at the moment the inhabitant began to look at the clock that moment is considered the nearest You are asked to solve the problem for several test cases ,"['#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,""r"",stdin)\n#define Fout(s) freopen(s,""w"",stdout)\n#define file(s) Fin(s"".in""),Fout(s"".out"")\n//#define int long long\nconst int P=998244353; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline void fprint(const vector<int> &f) {for(int i=0;i<(int)f.size();i++) fprintf(stderr,""%d "",f[i]); fprintf(stderr,""\\n"");}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]=\'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\nint rev[10]={0,1,5,-1,-1,2,-1,-1,8,-1};\nbool chk(int h,int m,int A,int B) {\n\tif(rev[A/10]==-1) return 0;\n\tif(rev[A%10]==-1) return 0;\n\tif(rev[B/10]==-1) return 0;\n\tif(rev[B%10]==-1) return 0;\n\tint C=rev[B%10]*10+rev[B/10];\n\tint D=rev[A%10]*10+rev[A/10];\n\treturn 0<=C&&C<h&&0<=D&&D<m;\n}\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""pro.in"",""r"",stdin);\n\t\tfreopen(""pro.out"",""w"",stdout);\n\t#endif\n\tint T; scanf(""%d"",&T);\n\twhile(T--) {\n\t\tint h,m; scanf(""%d%d"",&h,&m);\n\t\tint A,B; scanf(""%d:%d"",&A,&B);\n\t\twhile(!chk(h,m,A,B)) {\n\t\t\tB++;\n\t\t\tif(B==m) A++,B=0;\n\t\t\tif(A==h) A=0;\n\t\t}\n\t\tprintf(""%d%d:%d%d\\n"",A/10,A%10,B/10,B%10);\n\t}\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/']","['brute force', 'implementation']",1300
https://codeforces.com//contest/298/problem/B,B. Sail,The polar bears are going fishing They plan to sail from to However the boat can only sail by wind At each second the wind blows in one of these directions east south west or north Assume the boat is currently at If the wind blows to the east the boat will move to If the wind blows to the south the boat will move to If the wind blows to the west the boat will move to If the wind blows to the north the boat will move to Alternatively they can hold the boat by the anchor In this case the boat stays at Given the wind direction for seconds what is the earliest time they sail to ,"[""//In the Name of GOD\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#define MOD 1000000007ll\n\nusing namespace std;\n\n\n\n\nint main()\n{\n\tlong long n,x,y,a,b;\n\tcin>>n>>x>>y>>a>>b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tchar ch;\n\t\tcin>>ch;\n\t\tif(ch=='S')\n\t\t{\n\t\t\tif(y>b)\n\t\t\t\ty--;\n\t\t}\n\t\tif(ch=='N')\n\t\t{\n\t\t\tif(y<b)\n\t\t\t\ty++;\n\t\t}\n\t\tif(ch=='E')\n\t\t\tif(x<a)\n\t\t\t\tx++;\n\t\tif(ch=='W')\n\t\t\tif(x>a)\n\t\t\t\tx--;\n\t\tif(x==a and y==b)\n\t\t{\n\t\t\tcout<<i+1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<-1;\n\treturn 0;\n}\n""]","['brute force', 'greedy', 'implementation']",1200
https://codeforces.com//contest/1191/problem/B,B. Tokitsukaze and Mahjong,Tokitsukaze is playing a game derivated from Japanese mahjong In this game she has three tiles in her hand Each tile she owns is a suited tile which means it has a suit or and a number a digit ranged from 1 to 9 In this problem we use one digit and one lowercase letter which is the first character of the suit to represent a suited tile All possible suited tiles are represented as ldots ldots ldots In order to win the game she must have at least one described below in her hand so sometimes she should draw extra suited tiles After drawing a tile the number of her tiles increases by one She can draw any tiles she wants including those already in her hand Do you know the minimum number of extra suited tiles she needs to draw so that she can win Here are some useful definitions in this game A also known as meld is formed by a or a A also known as triplet is made of three identical tiles such as however or is NOT a A also known as sequence is made of three sequential numbered tiles in the same suit such as and however or is NOT a Some examples it contains no or so it includes no it contains a but no so it includes a it contains no but a or so it includes a Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite ,"['#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>=\'0\'&&ch<=\'9\')) {if (ch==\'-\')f=-1;ch=getchar();}\n    while (ch>=\'0\'&&ch<=\'9\') {x=x*10+(ch-\'0\'); ch=getchar();}\n    return x*f;\n}\n\nchar a[5],b[5],c[5];\n\nint main() {\n\n\tscanf(""%s"",a); scanf(""%s"",b); scanf(""%s"",c);\n\tif (a[1]==b[1]&&a[1]==c[1]) {\n\t\tint x=a[0]-\'0\',y=b[0]-\'0\',z=c[0]-\'0\';\n\t\tif (x>y) swap(x,y); if (x>z) swap(x,z);\n\t\tif (y>z) swap(y,z);\n\t\tif (x==y&&y==z) puts(""0"");\n\t\telse if (y-x==1&&z-y==1) puts(""0"");\n\t\telse if (abs(x-y)<=2||abs(y-z)<=2) puts(""1"");\n\t\telse puts(""2"");\n\t} else {\n\t\tif (a[1]==b[1]) {\n\t\t\tint x=a[0]-\'0\',y=b[0]-\'0\';\n\t\t\tif (abs(x-y)<=2) puts(""1"");\n\t\t\telse puts(""2"");\n\t\t} else if (a[1]==c[1]) {\n\t\t\tint x=a[0]-\'0\',y=c[0]-\'0\';\n\t\t\tif (abs(x-y)<=2) puts(""1"");\n\t\t\telse puts(""2"");\n\t\t} else if (b[1]==c[1]) {\n\t\t\tint x=c[0]-\'0\',y=b[0]-\'0\';\n\t\t\tif (abs(x-y)<=2) puts(""1"");\n\t\t\telse puts(""2"");\n\t\t} else puts(""2"");\n\t}\n\n\treturn 0;\n\t\n}\n']","['brute force', 'implementation']",1200
https://codeforces.com//contest/1360/problem/G,G. A B Matrix,You are given four positive integers n m a b 1 le b le n le 50 1 le a le m le 50 Find any such rectangular matrix of size n times m that satisfies all of the following conditions each row of the matrix contains exactly a ones each column of the matrix contains exactly b ones all other elements are zeros If the desired matrix does not exist indicate this For example for n 3 m 6 a 2 b 1 there exists a matrix satisfying the conditions above begin vmatrix 0 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 end vmatrix ,"['#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < \'0\' || cc > \'9\' ) {  if( cc == \'-\' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= \'0\' && cc <= \'9\' )  cn = cn * 10 + cc - \'0\', cc = getchar() ;\n\treturn cn * flus ;\n}\n#define maxn 205\nint n , m , a, b ; \nsigned main() {\n\tint T = gi() ;\n\twhile( T -- ) {\n\t\tn = gi(), m = gi(), a = gi(), b = gi() ;\n\t\tif( n * a != m * b ) {\n\t\t\tputs(""NO"") ;\n\t\t\tcontinue ;\n\t\t}\n\t\tputs(""YES"") ;\n\t\tint last = 0 ;\n\t\trep( i, 1, n ) {\n\t\t\tint l = last + 1, r = ( last + a ) % m;\n\t\t\tif( l == 0) {\n\t\t\t\trep( j, 1, r ) printf(""1"") ;\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\tprintf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse if(r == 0 ) {\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\trep( j, l, m ) printf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse if( l <= r ) {\n\t\t\t\trep( j, 1, last ) printf(""0"") ;\n\t\t\t\trep( j, last + 1, last + a ) printf(""1"");\n\t\t\t\trep( j, last + a + 1, m ) printf(""0"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep( j, 1, r ) printf(""1"") ;\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\trep( j, l, m ) printf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0 ;\n} ']","['constructive algorithms', 'greedy', 'math']",1900
https://codeforces.com//contest/1329/problem/C,C. Drazil Likes Heap,Drazil likes heap very much So he created a problem with heap There is a max heap with a height h implemented on the array The details of this heap are the following This heap contains exactly 2 h 1 positive non zero integers All integers are distinct These numbers are stored in the array a indexed from 1 to 2 h 1 For any 1 i 2 h a i a left lfloor frac i 2 right rfloor Now we want to reduce the height of this heap such that the height becomes g with exactly 2 g 1 numbers in heap To reduce the height we should perform the following action 2 h 2 g times Choose an index i which contains an element and call the following function f in index i Note that we suppose that if a i 0 then index i don t contain an element After all operations the remaining 2 g 1 element must be located in indices from 1 to 2 g 1 Now Drazil wonders what s the minimum possible sum of the remaining 2 g 1 elements Please find this sum and find a sequence of the function calls to achieve this value ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 20) + 7;\nint ord[N];\nint myPos[N];\nint bal[N];\nint a[2 * N];\nint ans[N];\nint ansSz;\nint n, m;\n\nvoid solve() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tmyPos[a[i]] = i;\n\t\tord[i - 1] = a[i];\n\t\tint v = i;\n\t\tint k = 0;\n\t\twhile(v > 1) {\n\t\t\tv /= 2;\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (int i = (1 << n); i < (1 << (n + 1)); i++)\n\t\ta[i] = 0;\n\tsort(ord, ord + (1 << n) - 1);\n\treverse(ord, ord + (1 << n) - 1);\n\tll sum = 0;\n\tansSz = 0;\n\tfor (int i = 0; i < (1 << n) - 1; i++) {\n\t\tint x = ord[i];\n\t\tint v = myPos[x];\n\t\twhile(a[v] > 0) {\n\t\t\tv *= 2;\n\t\t\tif (a[v] < a[v + 1]) v++;\n\t\t}\n\t\tv /= 2;\n\t\tif (v < (1 << m)) {\n\t\t\tsum += x;\n\t\t\tcontinue;\n\t\t}\n\t\tv = myPos[x];\n\t\tans[ansSz++] = v;\n\t\twhile(a[v] > 0) {\n\t\t\tv *= 2;\n\t\t\tif (a[v] < a[v + 1]) v++;\n\t\t\tif (a[v] > 0) myPos[a[v]] = v / 2;\n\t\t\ta[v / 2] = a[v];\n\t\t}\n\t}\n\tprintf(""%lld\\n"", sum);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(""%d "", ans[i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\n\treturn 0;\n}\n']","['constructive algorithms', 'data structures', 'greedy', 'implementation']",2400
https://codeforces.com//contest/875/problem/E,E. Delivery Club,Petya and Vasya got employed as couriers During the working day they are to deliver packages to different points on the line According to the company s internal rules the delivery of packages must be carried out strictly in a certain order Initially Petya is at the point with the coordinate Vasya is at the point with the coordinate and the clients are at the points in the order of the required visit The guys agree in advance who of them will deliver the package to which of the customers and then they act as follows When the package for the th client is delivered the one who delivers the package to the st client is sent to the path it can be the same person who went to the point or the other The friend who is not busy in delivering the current package is standing still To communicate with each other the guys have got walkie talkies The walkie talkies work rather poorly at great distances so Petya and Vasya want to distribute the orders so that the maximum distance between them during the day is as low as possible Help Petya and Vasya to minimize the maximum distance between them observing all delivery rules ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,x[100010],w[100010],f[100010][25],g[100010][25],u[100010],l,r;\ninline int minn(int l,int r)\n{\n\tint k=u[r-l+1];\n\treturn min(f[l][k],f[r-(1<<k)+1][k]);\n}\ninline int maxx(int l,int r)\n{\n\tint k=u[r-l+1];\n\treturn max(g[l][k],g[r-(1<<k)+1][k]);\n}\ninline bool check(int p)\n{\n\tint i,k,l,r,m,a,b;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   for(l=i,r=n;l<r;)\n\t     {\n\t\t  m=(l+r+1>>1);\n\t\t  a=minn(i,m);\n\t\t  b=maxx(i,m);\n\t\t  if(a>=x[i]-p && b<=x[i]+p)\n\t\t    l=m;\n\t\t  else\n\t\t    r=m-1;\n\t\t }\n\t   w[i]=l;\n\t  }\n\tfor(i=3,k=max(w[1],w[2]);i<=k;i++)\n\t  k=max(k,w[i]);\n\treturn i>n;\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j;\n\tscanf(""%d"",&n);\n\tn+=2;\n\tfor(i=1;i<=n;i++)\n\t  scanf(""%d"",&x[i]);\n\tfor(i=n;i>0;i--)\n\t  {\n\t   f[i][0]=g[i][0]=x[i];\n\t   for(j=1;j<=20;j++)\n\t     {\n\t\t  f[i][j]=min(f[i][j-1],f[min(i+(1<<j-1),n)][j-1]);\n\t\t  g[i][j]=max(g[i][j-1],g[min(i+(1<<j-1),n)][j-1]);\n\t\t }\n\t  }\n\tfor(i=2;i<=n;i++)\n\t  u[i]=u[i>>1]+1;\n\tfor(l=abs(x[1]-x[2]),r=1000000000;l<r;)\n\t  if(check(l+r>>1))\n\t    r=(l+r>>1);\n\t  else\n\t    l=(l+r>>1)+1;\n\tprintf(""%d\\n"",l);\n\treturn 0;\n}\n']","['binary search', 'data structures', 'dp']",2600
https://codeforces.com//contest/1513/problem/E,E. Cost Equilibrium,An array is called beautiful if all the elements in the array are equal You can transform an array using the following steps any number of times Choose two indices i and j 1 leq i j leq n and an integer x 1 leq x leq a i Let i be the source index and j be the sink index Decrease the i th element by x and increase the j th element by x The resulting values at i th and j th index are a i x and a j x respectively The cost of this operation is x cdot j i Now the i th index can no longer be the sink and the j th index can no longer be the source The total cost of a transformation is the sum of all the costs in step 3 For example array 0 2 3 3 can be transformed into a beautiful array 2 2 2 2 with total cost 1 cdot 1 3 1 cdot 1 4 5 An array is called balanced if it can be transformed into a beautiful array and the cost of such transformation is defined In other words the minimum cost of transformation into a beautiful array equals the maximum cost You are given an array a 1 a 2 ldots a n of length n consisting of non negative integers Your task is to find the number of balanced arrays which are permutations of the given array Two arrays are considered different if elements at some position differ Since the answer can be large output it modulo 10 9 7 ,"['#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int N = 200010;\nconst int M = 200010;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint f[N], invf[N];\nmap<int, int> mp;\nint c(int n, int k) {\n    return f[n] * 1ll * invf[k] % mod * invf[n - k] % mod;\n}\n\nvoid solve() {\n    int n;\n    scanf(""%d"", &n);\n    long long sum = 0;\n    f[0] = 1;\n    for (int i = 1; i <= n; ++i) f[i] = f[i - 1] * 1ll * i % mod;\n    invf[0] = invf[1] = 1;\n    for (int i = 2; i <= n; ++i) invf[i] = (mod - invf[mod % i] * 1ll * (mod / i) % mod) % mod;\n    for (int i = 2; i <= n; ++i) invf[i] = invf[i - 1] * 1ll * invf[i] % mod;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", &a[i]);\n        sum += a[i];\n    }\n    if (sum % n != 0) {\n        puts(""0"");\n        return;\n    }\n    sum /= n;\n    sort(a, a + n);\n    if (a[0] == sum) {\n        puts(""1"");\n        return;\n    }\n    int cnt = 0, cnt2 = 0;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < sum) cnt++;\n        if (a[i] > sum) cnt2++;\n    }\n    if (cnt == 1 || cnt2 == 1) {\n        for (int i = 0; i < n; ++i) mp[a[i]]++;\n        int ans = 1;\n        for (auto it : mp) {\n            ans = ans * 1ll * c(n, it.second) % mod;\n            n -= it.second;\n        }\n        printf(""%d\\n"", ans);\n        return;\n    }\n    int ans = c(n, n - cnt - cnt2);\n    for (int i = 0; i < n; ++i) mp[a[i]]++;\n    int ans2 = 1;\n    for (auto it : mp) {\n        if (it.first < sum) {\n            ans2 = ans2 * 1ll * c(cnt, it.second) % mod;\n            cnt -= it.second;\n        } else if (it.first > sum) {\n            ans2 = ans2 * 1ll * c(cnt2, it.second) % mod;\n            cnt2 -= it.second;\n        }\n    }\n    printf(""%d\\n"", ans * 2ll * ans2 % mod);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    solve();\n    return 0;\n}\n']","['combinatorics', 'constructive algorithms', 'math', 'sortings']",2300
https://codeforces.com//contest/369/problem/D,D. Valera and Fools,One fine morning fools lined up in a row After that they numbered each other with numbers from to inclusive Each fool got a unique number The fools decided not to change their numbers before the end of the fun Every fool has exactly bullets and a pistol In addition the fool number has probability of in percent that he kills the fool he shoots at The fools decided to have several rounds of the fun Each round of the fun looks like this each currently living fool shoots at another living fool with the smallest number a fool is not stupid enough to shoot at himself All shots of the round are perfomed at one time simultaneously If there is exactly one living fool he does not shoot Let s define a as the set of numbers of all the living fools at the some time We say that a situation is if for some integer number there is a nonzero probability that after rounds of the fun this situation will occur Valera knows numbers and Help Valera determine the number of distinct ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define lowbit(x) ((x) & (-(x)))\nusing namespace std;\ntypedef long long LL;\nconst int N = 3005;\nint dp[N][N] = {0} , n , k , p[N] , a[N] , b[N];\nqueue <pair <int , int> > q[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n    #endif\n    scanf (""%d %d"" , &n , &k);\n    if (n == 1) {\n        puts (""1"");\n        return 0;\n    }\n    a[n + 1] = b[n + 1] = 0;\n    for (int i = 1 ; i <= n ; i ++) {\n        scanf (""%d"" , &p[i]);\n        a[i] = a[i + 1] + (p[i] != 0);\n        b[i] = b[i + 1] + (p[i] == 100);\n    }\n    for (int i = n ; i >= 1 ; i --) {\n\n        a[i] = a[i + 1] + (p[i] != 0);\n        b[i] = b[i + 1] + (p[i] == 100);\n    }\n    int ans = 1;\n    q[0].push (make_pair (1 , 2));\n    for (int i = 0 ; i < k ; i ++) {\n        while (!q[i].empty ()) {\n            pair <int , int> u = q[i].front ();\n            // cout << u.first << "" "" << u.second << endl;\n            q[i].pop ();\n            if (u.second > n) continue;\n            if (p[u.first] == 100) {\n                if (b[u.second]) {\n                    int x = u.second + 1 , y = min (u.second + 2 , n + 1);\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else if (a[u.second] == 0) {\n                    int x = u.first , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else {\n                    int x = u.second + 1 , y = min (u.second + 2 , n + 1);\n                    // cout << x << "" "" << y << endl;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.first;y = u.second + 1;\n                    // cout << x << "" "" << y << endl;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n            }\n            else if (p[u.first] == 0) {\n                if (b[u.second]) {\n                    int x = u.second , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else if (a[u.second] == 0) {\n                    ;\n                }\n                else {\n                    int x = u.second , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n            }\n            else {\n                if (b[u.second]) {\n                    int x = u.second , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.second + 1 ; y = min (u.second + 2 , n + 1);\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else if (a[u.second] == 0) {\n                    int x = u.first , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else {\n                    int x = u.first , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.second + 1 ; y = min (u.second + 2 , n + 1);\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.second ; y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n            }\n        }\n    }\n    printf (""%d\\n"" , ans);\n    return 0;  \n}']","['dfs and similar', 'dp', 'graphs', 'shortest paths']",2200
https://codeforces.com//contest/1844/problem/C,C. Particles,You have discovered n mysterious particles on a line with integer charges of c 1 dots c n You have a device that allows you to perform the following operation Choose a particle and remove it from the line The remaining particles will shift to fill in the gap that is created If there were particles with charges x and y directly to the left and right of the removed particle they combine into a single particle of charge x y For example if the line of particles had charges of 3 1 4 1 5 9 performing the operation on the 4th particle will transform the line into 3 1 9 9 If we then use the device on the 1st particle in this new line the line will turn into 1 9 9 You will perform operations until there is only one particle left What is the maximum charge of this remaining particle that you can obtain ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,a[200005];\ni64 ans;\nvoid solve()\n{\n\tread(n);fz1(i,n)read(a[i]);\n\tans=-0x3f3f3f3f3f3f3f3fll;fz1(i,n)ans=max(ans,1ll*a[i]);\n\ti64 sum=0;bool flg=0;\n\tfor(i=1;i<=n;i+=2)if(a[i]>=0){\n\t\tflg=1;sum+=a[i];\n\t}\n\tif(flg) ans=max(ans,sum);\n\tsum=flg=0;\n\tfor(i=2;i<=n;i+=2)if(a[i]>=0){\n\t\tflg=1;sum+=a[i];\n\t}\n\tif(flg) ans=max(ans,sum);\n\tprintf(""%lld\\n"",ans);\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']","['dp', 'greedy', 'implementation', 'math']",1300
https://codeforces.com//contest/1736/problem/D,D. Equal Binary Subsequences,Everool has a binary string s of length 2n Note that a binary string is a string consisting of only characters 0 and 1 He wants to partition s into two subsequences He needs your help to do it You are allowed to do the following operation once You can choose any subsequence of s and rotate it right by one position In other words you can select a sequence of indices b 1 b 2 ldots b m where 1 le b 1 b 2 ldots b m le 2n After that you set s b 1 s b m s b 2 s b 1 ldots s b m s b m 1 Can you partition s into two subsequences after performing the allowed operation once A partition of s into two disjoint equal subsequences s p and s q is two arrays of indices p 1 p 2 ldots p n and q 1 q 2 ldots q n such that each integer from 1 to 2n is encountered in either p or q exactly once s p s p 1 s p 2 ldots s p n s q s q 1 s q 2 ldots s q n and s p s q If it is not possible to partition after performing any kind of operation report 1 If it is possible to do the operation and partition s into two disjoint subsequences s p and s q such that s p s q print elements of b and indices of s p i e the values p 1 p 2 ldots p n ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n; n<<=1;\n\t\tvector<int> a(n);\n\t\tvector cnt(2,0);\n\t\t{\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor (i=0; i<n; i++) ++cnt[a[i]=s[i]-\'0\'];\n\t\t}\n\t\tif (cnt[0]&1) { cout<<""-1\\n""; continue; }\n\t\tvector<int> pos;\n\t\tint cur=0;\n\t\tfor (i=0; i<n; i+=2) if (a[i]!=a[i+1]) pos.push_back((a[i+1]==cur)+i+1),cur^=1;\n\t\tcout<<pos.size()<<\' \'<<pos<<\'\\n\';\n\t\tfor (i=0; i<n; i+=2) cout<<i+1<<"" \\n""[i==n-2];\n\t}\n}\n']","['constructive algorithms', 'geometry', 'greedy', 'implementation', 'strings']",2200
https://codeforces.com//contest/1689/problem/A,A. Lex String,Recently Kuznecov has found two strings a and b of lengths n and m respectively They consist of lowercase English letters and Let another string c be initially empty Kuznecov can do the following two types of operations Choose any character from the string a remove it from a and add it to the end of c Choose any character from the string b remove it from b and add it to the end of c But he can not do more than k operations of the same type in a row He must perform operations until either a or b becomes empty What is the lexicographically smallest possible value of c after he finishes A string x is lexicographically smaller than a string y if and only if one of the following holds x is a prefix of y but x neq y in the first position where x and y differ the string x has a letter that appears earlier in the alphabet than the corresponding letter in y ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint T, n, m, k;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> T;\n    while (T--) {\n        string a, b, ans;\n        cin >> n >> m >> k >> a >> b;\n        auto solve = [&](string &a) {\n            for (int i = 0; i < a.length(); i++) {\n                for (int j = 0; j + 1 < a.length(); j++) {\n                    if (a[j] > a[j + 1]) swap(a[j], a[j + 1]);\n                }\n            }\n        };\n        solve(a); solve(b);\n        int i = 0, j = 0, cnt = 0, d = -1;\n        while (i < a.length() && j < b.length()) {\n            int o = 1;\n            if ((d == 1 && cnt == k) || ((d != 0 || cnt != k) && (a[i] < b[j]))) o = 0;\n            if (o == d) ++cnt;\n            else d = o, cnt = 1;\n            if (o == 0) ans = ans + a[i], ++i;\n            else ans = ans + b[j], ++j;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}']","['brute force', 'greedy', 'implementation', 'sortings', 'two pointers']",800
https://codeforces.com//contest/1822/problem/C,C. Bun Lover,Tema loves cinnabon rolls buns with cinnabon and chocolate in the shape of a snail Cinnabon rolls come in different sizes and are square when viewed from above The most delicious part of a roll is the chocolate which is poured in a thin layer over the cinnabon roll in the form of a spiral and around the bun as in the following picture For a cinnabon roll of size n the length of the outer side of the square is n and the length of the shortest vertical chocolate segment in the central part is one Formally the bun consists of two dough spirals separated by chocolate A cinnabon roll of size n 1 is obtained from a cinnabon roll of size n by wrapping each of the dough spirals around the cinnabon roll for another layer Tema is interested in how much chocolate is in his cinnabon roll of size n Since Tema has long stopped buying small cinnabon rolls it is guaranteed that n ge 4 Answer this non obvious question by calculating the total length of the chocolate layer ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define lli long long int\n#define fr(i, k, n) for (lli i = k; i < n; i++)\n#define rf(i, n, k) for (lli i = n; i > k; i--)\n#define pb push_back\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n\n// #define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n\nlli power(lli a, lli n)\n{\n    lli res = 1;\n    while (n)\n    {\n        if (n % 2)\n        {\n            res *= a;\n            // res %= mod;\n        }\n        a *= a;\n        // a %= mod;\n        n /= 2;\n    }\n    return res;\n}\n\nlli gcd(lli a, lli b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\nlli lcm(lli v, lli b)\n{\n    return (v * b) / gcd(v, b);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    // freopen(""error.txt"", ""w"", stderr);\n#endif\n    lli t = 1;\n    cin >> t;\n    while (t--)\n    {\n        lli n;\n        cin >> n;\n        cout << n * n + (2 * (n + 1)) << \'\\n\';\n    }\n}']",['math'],800
https://codeforces.com//contest/712/problem/C,C. Memory and De-Evolution,Memory is now interested in the de evolution of objects specifically triangles He starts with an equilateral triangle of side length and he wishes to perform operations to obtain an equilateral triangle of side length In a single second he can modify the length of a single side of the current triangle such that it remains a non degenerate triangle triangle of positive area At any moment of time the length of each side should be integer What is the minimum number of seconds required for Memory to obtain the equilateral triangle of side length ,"['#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint a[3];\n\nint main()\n{\n\tint x,y;\n\tcin>>x>>y;\n\ta[0]=a[1]=a[2]=y;\n\tint ans=0,pos=0;\n\twhile (true)\n\t{\n\t\tif (a[0]==x && a[1]==x && a[2]==x) break;\n\t\tint s=a[0]+a[1]+a[2]-a[pos];\n\t\ta[pos]=min(x,s-1);\n\t\tpos++;pos%=3;\n\t\tans++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\t']","['greedy', 'math']",1600
https://codeforces.com//contest/109/problem/E,E. Lucky Interval,One day Petya came across an interval of numbers Let be the number of lucky digits of number Find the minimum such that ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<40)\n\nint lucky(ll x){\n    int ans = 0;\n    while(x > 0){\n        if(x%10 == 4 || x%10 == 7) ans++;\n        x /= 10;\n    }\n    return ans;\n}\n\nmap <pair <ll, int>, int> mp1;\n\nll func1(ll low, int x){\n    int i;\n    ll ans = INF;\n    \n    if(x < 0) return INF;\n    \n    pair <ll, int> st = make_pair(low,x);\n    if(mp1.find(st) != mp1.end()) return mp1[st];\n    \n    if(low <= 3){\n        if(x == 0) return low;\n        ans = 0;\n        REP(i,x) ans = ans * 10 + 4;\n        return mp1[st] = ans;\n    }\n    \n    REP(i,10){\n        if(i < low%10){\n            ll tmp = func1(low/10+1,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        } else {\n            ll tmp = func1(low/10,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        }\n    }\n    \n    return mp1[st] = ans;\n}\n\nll func2(ll low, int x, int y){\n    int i;\n    ll ans = INF;\n    \n    if(x < 0 || y < 0) return INF;\n    \n    REP(i,9) if(y - x == lucky(i+1) - lucky(i)){\n        if(i < low%10){\n            ll tmp = func1(low/10+1,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        } else {\n            ll tmp = func1(low/10,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        }\n    }\n    \n    return ans;\n}\n\nll func3(ll low, int x, int y){\n    ll ans = INF;\n    \n    int i;\n    for(i=0;;i++){\n        ll tmp = func2(low,x,y);\n        int j;\n        REP(j,i) tmp = min(tmp * 10 + 9, INF);\n        ans = min(ans,tmp);\n        \n        if(low == 0) return ans;\n        low /= 10;\n    }\n}\n\nll func(ll low, ll high){\n    if(high/10 - low/10 >= 2){\n        ll tmp = func(low/10,high/10);\n        return tmp * 10 + low % 10;\n    }\n    \n    ll ans = INF;\n    \n    int i,j,k;\n    \n    REP(i,10){\n        j = i + (int)(high - low);\n        if(j >= 20) continue;\n        \n        int x = lucky(low) - lucky(i);\n        int y = 0;\n        if(j >= 10) y = lucky(high) - lucky(j-10);\n        \n        bool failed = false;\n        for(k=i;k<=j;k++){\n            int tmp1 = lucky(low+k-i);\n            int tmp2 = ((k >= 10) ? (y + lucky(k-10)) : (x + lucky(k)));\n            if(tmp1 != tmp2){\n                failed = true;\n                break;\n            }\n        }\n        if(failed) continue;\n        \n        ll small = (low - i + 10) / 10;\n        if(j >= 10){\n            ll tmp = func3(small,x,y);\n            ans = min(ans,tmp*10+i);\n        } else {\n            ll tmp = func1(small,x);\n            ans = min(ans,tmp*10+i);\n        }\n    }\n    \n    return ans;\n}\n\nint main(void){\n    ll a,d;\n    cin >> a >> d;\n    ll ans = func(a,a+d-1);\n    cout << ans << endl;\n    return 0;\n}\n']","['brute force', 'math']",2700
https://codeforces.com//contest/270/problem/B,B. Multithreading,Emuskald is addicted to Codeforces and keeps refreshing the main page not to miss any changes in the recent actions list He likes to read thread conversations where each thread consists of multiple messages Recent actions shows a list of different threads ordered by the time of the latest message in the thread When a new message is posted in a thread that thread jumps on the top of the list No two messages of different threads are ever posted at the same time Emuskald has just finished reading all his opened threads and refreshes the main page for some more messages to feed his addiction He notices that no new threads have appeared in the list and at the th place in the list there is a thread that was at the th place before the refresh He doesn t want to waste any time reading old messages so he wants to open only threads with new messages Help Emuskald find out the number of threads that have new messages A thread surely has a new message if there is no such sequence of thread updates posting messages that both conditions hold thread is not updated it has no new messages the list order 1 2 changes to ,"['#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fo(i,n) for(int i=1;i<=n;i++)\n#define fe(i,n) for(__typeof(n.begin()) i=n.begin();i!=n.end();i++)\nint n,z;\nint a[100020];\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tint t=n;\n\tfor(int i=n;i--;)\n\t{\n\t\tif(a[i]>t)\n\t\t{\n\t\t\tprintf(""%d"",i+1);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t\tt=a[i];\n\t}\n\tputs(""0"");\n\treturn 0;\n}']","['data structures', 'greedy', 'implementation']",1400
https://codeforces.com//contest/1900/problem/A,A. Cover in Water,Filip has a row of cells some of which are blocked and some are empty He wants all empty cells to have water in them He has two actions at his disposal 1 place water in an empty cell 2 remove water from a cell and place it in any other empty cell If at some moment cell i 2 le i le n 1 is empty and both cells i 1 and i 1 contains water then it becomes filled with water Find the minimum number of times he needs to perform action 1 in order to fill all empty cells with water Note that you don t need to minimize the use of action 2 Note that blocked cells neither contain water nor can Filip place water in them ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint ans, n, a[105], cnt = 0;\nchar s[105];\nvoid solve(){\n\tscanf(""%d%s"", &n, s + 1);\n\tcnt = 0; ans = 0;\n\tfor(int i = 1, j; i <= n; i = j + 1){\n\t\tj = i; if(s[j] == \'#\') continue;\n\t\twhile(j < n && s[j + 1] == \'.\') ++j;\n\t\ta[++cnt] = j - i + 1; \n\t}\n\tint yes = 0;\n\tfor(int i = 1; i <= cnt; ++i) if(a[i] >= 3) yes = 1;\n\tif(yes) printf(""2\\n"");\n\telse {\n\t\tfor(int i = 1; i <= cnt; ++i) ans += a[i];\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']","['constructive algorithms', 'greedy', 'implementation', 'strings']",800
https://codeforces.com//contest/1546/problem/B,B. AquaMoon and Stolen String,AquaMoon had n strings of length m each n is an number When AquaMoon was gone Cirno tried to pair these n strings together After making frac n 1 2 pairs she found out that there was exactly one string without the pair In her rage she disrupted each pair of strings For each pair she selected some positions at least 1 and at most m and swapped the letters in the two strings of this pair at the selected positions For example if m 6 and two strings and are in one pair and Cirno selected positions 2 3 and 6 she will swap with with and with The resulting strings will be and Cirno then stole away the string without pair and shuffled all remaining strings in arbitrary order AquaMoon found the remaining n 1 strings in complete disarray Also she remembers the initial n strings She wants to know which string was stolen but she is not good at programming Can you help her ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"") \n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n,m;\nstring a[200005];\nint cnt[100005][26];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n >> m;\n        for(int i = 0;i < m;i++) {\n            for(int j = 0;j < 26;j++) cnt[i][j] = 0;\n        }\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            for(int j = 0;j < m;j++) {\n                cnt[j][a[i][j]-\'a\']++;\n            }\n        }\n        for(int i = n+1;i < 2*n;i++) {\n            cin >> a[i];\n            for(int j = 0;j < m;j++) {\n                cnt[j][a[i][j]-\'a\']--;\n            }\n        }\n        for(int i = 0;i < m;i++) {\n            for(int j = 0;j < 26;j++) {\n                if(cnt[i][j]) cout << (char)(j+\'a\');\n            }\n        }\n        cout << \'\\n\';\n    }\n}']","['interactive', 'math']",1200
https://codeforces.com//contest/1840/problem/G1,G1. In Search of Truth  Easy Version ,You are playing a game The circle is divided into n sectors sectors are numbered from 1 to n in some order You are in the adjacent room and do not know either the number of sectors or their numbers There is also an arrow that initially points to some sector Initially the host tells you the number of the sector to which the arrow points After that you can ask the host to move the arrow k sectors counterclockwise or clockwise at most 2023 times And each time you are told the number of the sector to which the arrow points Your task is to determine the integer n the number of sectors in at most 2023 queries It is guaranteed that 1 le n le 10 6 ,"['#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n;\nint tot=1;\nint rnd()\n{\n\ttot++;\n\tif(tot<=1000)\treturn 1;\n\treturn 1000;\n}\nint now=1;\nint query(int x)\n{\n\t//now=(now+x-1)%5+1;\n\t//return now;\n\tcout<<""+ ""<<x<<endl;\n\tint p=read();\n\treturn p;\n}\nmap<int ,ll >tag;\nint main()\n{\n\tn=read();\ttag[n]=1;\n\tint tot=1;\n\tint ans;\n\tint pp;\n\twhile(true)\n\t{\n\t\tint len=rnd();\ttot+=len;\tint x=query(len);\n\t\tif(tag[x])\n\t\t{\n\t\t\tans=tot-tag[x];\n\t\t\tpp=x;\n\t\t\tbreak;\n\t\t}\n\t\telse\ttag[x]=tot;\n\t}\n\tprintf(""! %d"",ans);\n    return 0;\n}']","['constructive algorithms', 'interactive', 'math', 'meet-in-the-middle', 'probabilities']",2200
https://codeforces.com//contest/590/problem/D,D. Top Secret Task,A top secret military base under the command of Colonel Zuev is expecting an inspection from the Ministry of Defence According to the charter each top secret military base must include a top secret troop that should well we cannot tell you exactly what it should do it is a top secret troop at the end The problem is that Zuev s base is missing this top secret troop for some reasons The colonel decided to deal with the problem immediately and ordered to line up in a single line all soldiers of the base entrusted to him Zuev knows that the of the th soldier from the left is equal to Zuev wants to form the top secret troop using leftmost soldiers in the line thus he wants their total loquacity to be as small as possible as the troop should remain top secret To achieve this he is going to choose a pair of soldiers and swap them He intends to do so no more than times Note that any soldier can be a participant of such swaps for any number of times The problem turned out to be unusual and colonel Zuev asked you to help Determine what is the minimum total loquacity of the first soldiers in the line that can be achieved by performing no more than swaps of two consecutive soldiers ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint dp[2][76][25000];\nint a[200];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N, K, S;\n    cin >> N >> K >> S;\n    forn(i, N) cin >> a[i];\n    bool sw = false;\n    if (K > N / 2) {\n        K = N - K;\n        reverse(a, a + N);\n        forn(i, N) a[i] = -a[i];\n        sw = true;\n    }\n    dp[0][0][0] = 0;\n    forn(i, N) {\n        forn(j, min(i + 1, K) + 1) forn(l, (i + 1) * N + 1) dp[1][j][l] = 1e9;\n        forn(j, min(i, K) + 1) forn(l, i * N + 1) {\n            if (j < K) uin(dp[1][j + 1][l + abs(i - j)], dp[0][j][l] + a[i]);\n            uin(dp[1][j][l + abs(i - (K + i - j))], dp[0][j][l]);\n        }\n        forn(j, min(i + 1, K) + 1) forn(l, (i + 1) * N + 1) dp[0][j][l] = dp[1][j][l];\n    }\n    int ans = 1e9;\n    forn(d, min(N * N, 2 * S) + 1) uin(ans, dp[0][K][d]);\n    if (sw) forn(i, N) ans -= a[i];\n    cout << ans << \'\\n\';\n\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",['dp'],2300
https://codeforces.com//contest/133/problem/B,B. Unary,Unary is a minimalistic Brainfuck dialect in which programs are written using only one token Brainfuck programs use 8 commands and their meaning is not important for the purposes of this problem Unary programs are created from Brainfuck programs using the following algorithm First replace each command with a corresponding binary code using the following conversion table 1000 1001 1010 1011 1100 1101 1110 1111 Next concatenate the resulting binary codes into one binary number in the same order as in the program Finally write this number using unary numeral system this is the Unary program equivalent to the original Brainfuck one You are given a Brainfuck program Your task is to calculate the size of the equivalent Unary program and print it modulo ,"['#include <cstdio>\n#include <string>\n#include <map>\n#include <cstring>\n#include <bitset>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <memory.h>\n#include <list>\n#include <vector>\n#include <set>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define sqr(n)  (n)*(n)\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define INF 2000000000\n\ntypedef long long ll;\n\nint MOD = 1000003;\n\nint main()\n{\n    string s;\n    cin >> s;\n    int res = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        res *= 16;\n        if(s[i]==\'>\')\n            res+=8;\n        else if(s[i]==\'<\')\n            res+=9;\n        else if(s[i]==\'+\')\n            res+=10;\n        else if(s[i]==\'-\')\n            res+=11;\n        else if(s[i]==\'.\')\n            res+=12;\n        else if(s[i]==\',\')\n            res+=13;\n        else if(s[i]==\'[\')\n            res+=14;\n        else if(s[i]==\']\')\n            res+=15;\n        res %= MOD;\n    }\n    printf(""%d"",res);\n    return 0;\n}\n']",['implementation'],1200
https://codeforces.com//contest/570/problem/A,A. Elections,The country of Byalechinsk is running elections involving candidates The country consists of cities We know how many people in each city voted for each candidate The electoral system in the country is pretty unusual At the first stage of elections the votes are counted for each city it is assumed that in each city won the candidate who got the highest number of votes in this city and if several candidates got the maximum number of votes then the winner is the one with a smaller index At the second stage of elections the winner is determined by the same principle over the cities the winner of the elections is the candidate who won in the maximum number of cities and among those who got the maximum number of cities the winner is the one with a smaller index Determine who will win the elections ,"['#include <cstdio>\n#include <cstring>\n\nint a[105][105];\nint win_cnt[105];\n\nint main() {\n    int n,m;\n    scanf(""%d%d"",&m,&n);\n    int i,j;\n    for (i=1;i<=n;i++) {\n        for (j=1;j<=m;j++) {\n            scanf(""%d"",a[i]+j);\n        }\n    }\n    for (i=1;i<=n;i++) {\n        int x=1;\n        for (j=2;j<=m;j++) {\n            if (a[i][j]>a[i][x]) x=j;\n        }\n        ++win_cnt[x];\n    }\n    int ans=1;\n    for (i=2;i<=m;i++) {\n        if (win_cnt[i]>win_cnt[ans]) ans=i;\n    }\n    printf(""%d\\n"",ans);\n}']",['implementation'],1100
https://codeforces.com//contest/1819/problem/C,C. The Fox and the Complete Tree Traversal,The fox Yae climbed the of the Sacred Sakura A tree is a connected undirected graph that does not contain cycles The fox uses her magical powers to move around the tree Yae can jump from vertex v to another vertex u if and only if the distance between these vertices does not exceed 2 In other words in one jump Yae can jump from vertex v to vertex u if vertices v and u are connected by an edge or if there exists such vertex w that vertices v and w are connected by an edge and also vertices u and w are connected by an edge After Yae was able to get the sakura petal she wondered if there was a route in the tree v 1 v 2 ldots v n such that the fox can jump from vertex v i to vertex v i 1 the fox can jump from vertex v n to vertex v 1 all v i are pairwise distinct Help the fox determine if the required traversal exists ,"['#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(""Ofast,unroll-loops"")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << \' \'\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << ""\\n"";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\nconst int maxn=200005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n//#define wiwihorz  \nvoid balbitorz(){}\nint n,dis[2][maxn],a[maxn];\nvector<int> adj[maxn],vec[maxn];\n\nvoid dfs(int u, int par, int t){\n    dis[t][u]=par==-1?0:dis[t][par]+1;\n    for(auto v: adj[u]) if(v!=par) dfs(v,u,t);\n}\n\nvoid orzck(){\n    cin >> n;\n    rep(n-1){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    dfs(0,-1,0);\n    int p=max_element(dis[0],dis[0]+n)-dis[0];\n    dfs(p,-1,0);\n    int q=max_element(dis[0],dis[0]+n)-dis[0];\n    dfs(q,-1,1);\n    int d=dis[0][q];\n    rep(n){\n        assert(dis[0][i]+dis[1][i]-d>=0&&(dis[0][i]+dis[1][i]-d)%2==0);\n        if(dis[0][i]+dis[1][i]-d>2){\n            print(""No"");\n            return;\n        }\n        if(dis[0][i]+dis[1][i]-d==0){\n            a[dis[0][i]]=i;\n            for(auto j: adj[i]) if(dis[0][j]+dis[1][j]-d==2) vec[i].pb(j);\n        }\n    }\n    vector<int> res;\n    for(int i=0; i<d; i+=2){\n        res.pb(a[i]);\n        for(auto j: vec[a[i+1]]) res.pb(j);\n    }\n    int dd=d;\n    if(d%2==0){\n        dd--;\n        res.pb(a[d]);\n    }\n    for(int i=dd; i>=1; i-=2){\n        res.pb(a[i]);\n        for(auto j: vec[a[i-1]]) res.pb(j);\n    }\n    assert(sz(res)==n);\n    print(""Yes"");\n    for(auto i: res) print0(i+1);\n    cout << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(""input1.txt"",""r"",stdin);\n    // freopen(""output1.txt"",""w"",stdout);\n    // freopen(""output2.txt"",""w"",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}']","['constructive algorithms', 'dp', 'implementation', 'math', 'trees']",2400
https://codeforces.com//contest/889/problem/C,C. Maximum Element,One day Petya was solving a very interesting problem But although he used many optimization techniques his solution still got Time limit exceeded verdict Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of positive integers was too slow Desperate Petya decided to use a somewhat unexpected optimization using parameter so now his function contains the following code int fast max int n int a int ans 0 int offset 0 for int i 0 i n i if ans a i ans a i offset 0 else offset offset 1 if offset k return ans return ans That way the function iteratively checks array elements storing the intermediate maximum and if after consecutive iterations that maximum has not changed it is returned as the answer Now Petya is interested in fault rate of his function He asked you to find the number of permutations of integers from to such that the return value of his function on those permutations is not equal to Since this number could be very big output the answer modulo ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\n\nll rev(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = rev(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll f[MAXN];\nll fct[MAXN];\nll rfct[MAXN];\n\nll cnk(int x, int y) {\n    return fct[x + y] * rfct[x] % MOD * rfct[y] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    rfct[n] = rev(fct[n]);\n    for (int i = n; i > 0; --i) {\n        rfct[i - 1] = (rfct[i] * i) % MOD;\n    }\n    \n    ll mulall = 1;\n    ll ans = fct[n - 1];\n\n\n    ll sum = 0;\n    f[0] = 1;\n    sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        sum = (sum + f[i - 1]) % MOD;\n        ll cf = sum * mulall % MOD;\n        ans += cf * fct[n - 1] % MOD * rfct[i] % MOD;\n        ans %= MOD;\n        mulall = (mulall * i) % MOD;\n        f[i] = (rev(mulall) * cf) % MOD;\n        if (i >= k) {\n            sum = (sum - f[i - k] + MOD) % MOD;\n        }\n    }\n\n    cout << (fct[n] - ans + MOD) % MOD;\n}']","['dp', 'math']",2400
https://codeforces.com//contest/734/problem/A,A. Anton and Danik,Anton likes to play chess and so does his friend Danik Once they have played games in a row For each game it s known who was the winner Anton or Danik None of the games ended with a tie Now Anton wonders who won more games he or Danik Help him determine this ,"['#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 100500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\nchar t[maxn];\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( ""input.txt"", ""r"", stdin );\n    // freopen( ""output.txt"", ""w"", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n;\n    scanf ( ""%d\\n"", &n );\n    gets( t );\n    int bal = 0;\n    for ( int j = 0; j < n; j++ )\n    \tbal += t[j] == \'A\' ? 1 : -1;\n    if ( bal > 0 ) {\n    \tputs( ""Anton"" );\n    \treturn 0;\n    }\n    if ( bal < 0 ) {\n    \tputs( ""Danik"" );\n    \treturn 0;\n    }\n    puts( ""Friendship"" );\n    return 0;\n}\n']","['implementation', 'strings']",800
https://codeforces.com//contest/1109/problem/D,D. Sasha and Interesting Fact from Graph Theory,Once during a lesson Sasha got bored and decided to talk with his friends Suddenly he saw Kefa Since we can talk endlessly about Kefa we won t even start doing that The conversation turned to graphs Kefa promised Sasha to tell him about one interesting fact from graph theory if Sasha helps Kefa to count the number of In this task a is a weighted connected graph consisting of n vertices and n 1 edges and weights of edges are integers from 1 to m Kefa determines the beauty of a tree as follows he finds in the tree his two favorite vertices vertices with numbers a and b and counts the distance between them The distance between two vertices x and y is the sum of weights of edges on the simple path from x to y If the distance between two vertices a and b is to m then the tree is Sasha likes graph theory and even more Sasha likes interesting facts that s why he agreed to help Kefa Luckily Sasha is familiar with you Help Sasha to count the number of trees for Kefa Two trees are considered to be distinct if there is an edge that occurs in one of them and doesn t occur in the other one Edge s Kefa warned Sasha that there can be too many beautiful trees so it will be enough to count the number modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = (int)1e6 + 7;\nll f[N], rf[N];\nll pw1[N], pw2[N];\nint n, m;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\trf[0] = rf[1] = 1;\n\tfor (ll x = 2; x < N; x++)\n\t\trf[x] = sub(0, mult(MOD / x, rf[MOD % x]));\n\tfor (int i = 2; i < N; i++)\n\t\trf[i] = mult(rf[i - 1], rf[i]);\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\n\tscanf(""%d%d"", &n, &m);\n\n\tpw1[0] = pw2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tpw1[i] = mult(pw1[i - 1], n);\n\t\tpw2[i] = mult(pw2[i - 1], m);\n\t}\n\n\tll ans = 0;\n\tfor (int k = 1; k < n - 1 && k <= m; k++) {\n\t\tll cur = k + 1;\n\t\tcur = mult(cur, pw1[n - k - 2]);\n\t\tcur = mult(cur, f[n - 2]);\n\t\tcur = mult(cur, rf[n - k - 1]);\n\t\tcur = mult(cur, f[m - 1]);\n\t\tcur = mult(cur, rf[k - 1]);\n\t\tcur = mult(cur, rf[m - k]);\n\t\tcur = mult(cur, pw2[n - 1 - k]);\n\t\tans = add(ans, cur);\n\t}\n\tif (n - 1 <= m) {\n\t\tll cur = f[n - 2];\n\t\tcur = mult(cur, f[m - 1]);\n\t\tcur = mult(cur, rf[n - 2]);\n\t\tcur = mult(cur, rf[m - n + 1]);\n\t\tans = add(ans, cur);\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['brute force', 'combinatorics', 'dp', 'math', 'trees']",2400
https://codeforces.com//contest/1811/problem/A,A. Insert Digit,You have a number of length n and one additional digit You can insert this digit anywhere in the number including at the beginning or at the end Your task is to make the result as large as possible For example you have the number 76543 and the additional digit is 4 Then the maximum number you can get is 765443 and it can be obtained in two ways by inserting a digit after the 3th or after the 4th digit of the number ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n  int tt; cin >> tt;\n  while (tt--) {\n    int n, d;\n    cin >> n >> d;\n    string s;\n    cin >> s;\n    bool ok = 0;\n    for (int i = 0; i < s.size(); i++) {\n      if (s[i] - \'0\' < d) {\n        s.insert(i, 1, char(d + \'0\'));\n        ok = 1;\n        break;\n      }\n    }\n    if (!ok) {\n      s.push_back(char(d + \'0\'));\n    }\n    cout << s << ""\\n"";\n  }\n  return 0;\n}\n']","['greedy', 'math', 'strings']",800
https://codeforces.com//contest/1153/problem/A,A. Serval and Bus,It is raining heavily But this is the first day for Serval who just became 3 years old to go to the kindergarten Unfortunately he lives far from kindergarten and his father is too busy to drive him there The only choice for this poor little boy is to wait for a bus on this rainy day Under such circumstances the poor boy will use the first bus he sees no matter where it goes If several buses come at the same time he will choose one randomly Serval will go to the bus station at time t and there are n bus routes which stop at this station For the i th bus route the first bus arrives at time s i minutes and each bus of this route comes d i minutes later than the previous one As Serval s best friend you wonder which bus route will he get on If several buses arrive at the same time you can print any of them ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tint n, t, s, d;\n\tcin >> n >> t;\n\tpair<int, int> p={1e9, -1};\n\tfor(int i=0; i<n; ++i) {\n\t\tcin >> s >> d;\n\t\twhile(s<t) {\n\t\t\ts+=d;\n\t\t}\n\t\tp=min(pair<int,int>(s,i),p);\n\t}\n\tcout << p.second+1;\n\n\treturn 0;\n}']","['brute force', 'math']",1000
https://codeforces.com//contest/1909/problem/B,B. Make Almost Equal With Mod,You are given an array a 1 a 2 dots a n of distinct positive integers You have to do the following operation choose a positive integer k for each i from 1 to n replace a i with a i text mod k dagger Find a value of k such that 1 leq k leq 10 18 and the array a 1 a 2 dots a n contains 2 distinct values at the end of the operation It can be shown that under the constraints of the problem at least one such k always exists If there are multiple solutions you can print any of them dagger a text mod b denotes the remainder after dividing a by b For example 7 text mod 3 1 since 7 3 cdot 2 1 15 text mod 4 3 since 15 4 cdot 3 3 21 text mod 1 0 since 21 21 cdot 1 0 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tfor(int w=1;;w<<=1){\n\t\tvi b(n);\n\t\trep(i,n)b[i]=a[i]%w;\n\t\tmkuni(b);\n\t\tif(si(b)==2){\n\t\t\tprint(w);\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['bitmasks', 'constructive algorithms', 'math', 'number theory']",1200
https://codeforces.com//contest/1295/problem/F,F. Good Contest,An online contest will soon be held on ForceCoders a large competitive programming platform The authors have prepared n problems and since the platform is very popular 998244351 coder from all over the world is going to solve them For each problem the authors estimated the number of people who would solve it for the i th problem the number of accepted solutions will be between l i and r i inclusive The creator of ForceCoders uses different criteria to determine if the contest is good or bad One of these criteria is the number of inversions in the problem order An inversion is a pair of problems x y such that x is located earlier in the contest x y but the number of accepted solutions for y is greater Obviously both the creator of ForceCoders and the authors of the contest want the contest to be good Now they want to calculate the probability that there will be inversions in the problem order assuming that for each problem i any number of accepted solutions for it between l i and r i is equally probable and all these numbers are independent ,"['// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n        assert(~c);\n    }\n    if (c == \'-\') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 105;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nvoid iadd(int &dp, const int &val) {\n    dp += val;\n    if (dp >= MOD) {\n        dp -= MOD;\n    }\n}\n\nvoid ladd(int &dp, const LL &val) {\n    dp = (dp + val) % MOD;\n}\n\nint inv[N];\n\nvoid prep_inv() {\n    inv[0] = 1;\n    for (unsigned i = 1; i < N; ++i) {\n        inv[i] = (LL) inv[i - 1] * qpow(i, MOD - 2) % MOD;\n    }\n}\n\nint comb(int l, int n) {\n    if (!n) return 1;\n    int ret = (LL) inv[n] * qpow(l, MOD - 1 - n) % MOD;\n    for (int i = 0; i < n; ++i) {\n        ret = (LL) ret * (l + i) % MOD;\n    }\n    return ret;\n}\n\nint n, l[N], r[N];\nint f[N][N][N];\n\nint main() {\n    prep_inv();\n    n = read();\n    vector<int> vc = {-1};\n    for (int i = 0; i < n; ++i) {\n        l[i] = read();\n        r[i] = read() + 1;\n        vc.emplace_back(l[i]);\n        vc.emplace_back(r[i]);\n    }\n    reverse(l, l + n);\n    reverse(r, r + n);\n    sort(vc.begin(), vc.end());\n    vc.erase(unique(vc.begin(), vc.end()), vc.end());\n    int segs = (int) vc.size() - 1;\n    f[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        int sum = 0;\n        for (int id = 0; id < segs; ++id) {\n            int lb = vc[id], rb = vc[id + 1];\n            if (l[i] <= lb && rb <= r[i]) {\n                int prob = min(rb, r[i]) - max(lb, l[i]);\n                f[i + 1][id][1] = (LL) sum * prob % MOD;\n                for (int j = 1; j < n; ++j) {\n                    f[i + 1][id][j + 1] = (LL) f[i][id][j] * prob % MOD;\n                }\n            }\n            for (int j = 0; j < n; ++j) {\n                if (f[i][id][j]) {\n                    if (id) {\n                        ladd(sum, (LL) f[i][id][j] * comb(rb - lb, j));\n                    } else {\n                        ladd(sum, f[i][id][j]);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < segs; ++i) {\n        int len = vc[i + 1] - vc[i];\n        for (int j = 1; j <= n; ++j) {\n            ladd(ans, (LL) f[n][i][j] * comb(len, j));\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        ans = (LL) ans * qpow(r[i] - l[i], MOD - 2) % MOD;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","['combinatorics', 'dp', 'probabilities']",2700
https://codeforces.com//contest/1634/problem/D,D. Finding Zero,We picked an array of whole numbers a 1 a 2 ldots a n 0 le a i le 10 9 and concealed zero in it Your goal is to find the location of this zero that is to find i such that a i 0 You are allowed to make several queries to guess the answer For each query you can think up three distinct indices i j k and we will tell you the value of max a i a j a k min a i a j a k In other words we will tell you the difference between the maximum and the minimum number among a i a j and a k You are allowed to make no more than 2 cdot n 2 queries and after that you have two tries to guess where the zero is That is you have to tell us two numbers i and j and you win if a i 0 or a j 0 Can you guess where we hid the zero Note that the array in each test case is fixed beforehand and will not change during the game In other words the interactor is not adaptive ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nconst int mxn=1e3+3;\nint n;\nint a[mxn],b[mxn];\ninline int ask(int x,int y,int z){\n\tcout<<""? ""<<x<<\' \'<<y<<\' \'<<z<<endl;\n\tfflush(stdout);\n\tint rt;cin>>rt;\n\treturn rt;\n}\ninline void print(int x,int y){\n\tcout<<""! ""<<x<<\' \'<<y<<endl;\n\tfflush(stdout);\n\treturn;\n}\ninline void solve(){\n\tcin>>n;\n\tmemset(a,0,sizeof(a));\n\tmemset(b,0,sizeof(b));\n\tint pos1=1;\n\tint allsame=1;\n\tint lst=-1;\n\tfor(int i=3;i<=n;++i){\n\t\ta[i]=ask(1,2,i);\n\t\tif(a[i]>a[pos1])pos1=i;\n\t\tif(lst==-1)lst=a[i];\n\t\telse{\n\t\t\tif(a[i]!=lst){\n\t\t\t\tlst=a[i];\n\t\t\t\tallsame=0;\n\t\t\t}\n\t\t}\n\t}\n\tint allsame2=1,lst2=-1;\n\tint pos2=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(i==pos1)continue;\n\t\tb[i]=ask(1,i,pos1);\n\t\tif(b[i]>=b[pos2])pos2=i;\n\t\tif(lst2==-1)lst2=b[i];\n\t\telse if(lst2!=b[i])allsame2=0;\n\t}\n\tif(pos2==2)++pos2;\n\tif(pos2==pos1)++pos2;\n\n\tif(allsame==1){//this can all be x[1]-x[2]\n\t\tint t=ask(1,pos1,pos2);\n\t\tif(t<lst){\n\t\t\tprint(1,2);\n\t\t\treturn;\n\t\t}\n\t}\n//\tcerr<<""! wtf ""<<pos1<<\' \'<<pos2<<\'\\n\';\n\t//now if both x[1] and x[2] isn\'t 0 this is okay\n\t//if x[2] is 0? what will happen?\n\t//a[i] will be x[i]. How to ensure it?\n\t//we can ask(2,pos1,pos2) to check\n\t//if x[1] is 0: it is smaller than either a[pos1] or a[pos2] we can return [1,1]\n\t//if x[2] is 0: this returns a[pos1 or pos2] then we can return [2,pos1 or pos2]\n\t//otherwise we can return [pos1,pos2]\n\t//oops,there still can be x[1] is max and pos1 is zero\n\tif(allsame2==1){\n\t\tprint(1,pos1);\n\t\treturn;\n\t}\n\tint t=ask(2,pos1,pos2);\n\tif((t<a[pos1] and t<=a[pos2]) or (t<=a[pos1] and t<a[pos2])){\n\t\tprint(1,2);\n\t\treturn;\n\t}\n\tif(t==a[pos1]){\n\t\tprint(2,pos1);\n\t\treturn;\n\t}\n\tif(t==a[pos2]){\n\t\tprint(2,pos2);\n\t\treturn;\n\t}\n\n\tprint(pos1,pos2);\n\treturn;\n}\nint main(){\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}']","['constructive algorithms', 'interactive', 'math']",2000
https://codeforces.com//contest/1760/problem/B,B. Atilla's Favorite Problem,In order to write a string Atilla needs to first learn all letters that are contained in the string Atilla needs to write a message which can be represented as a string s He asks you what is the minimum alphabet size required so that one can write this message The alphabet of size x 1 leq x leq 26 contains x Latin letters For example an alphabet of size 4 contains the characters texttt a texttt b texttt c and texttt d ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ios ios::sync_with_stdio(false); cin.tie(NULL);\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define fr first\n#define sc second\n#define int long long\n#define endl \'\\n\'\nvoid fopn(string name){\n  freopen((name+"".in"").c_str(),""r"",stdin);\n  freopen((name+"".out"").c_str(),""w"",stdout);\n}\nconst int INF=1e18,mod=1e9+7;\nint binpow(int a,int b){\n  int cur=1;\n  while(b){\n    if(b&1)\n      cur=(cur*a)%mod;\n    a*=a;\n    a%=mod;\n    b/=2;\n  }\n  return cur;\n}\nint n;\nvoid solve(){\n  cin>>n;\n  string s;\n  cin>>s;\n  int res=0;\n  for(int i=0;i<n;i++)\n    res=max(res,(s[i]-\'a\'+1)*1ll);\n  cout<<res<<endl;\n}\nmain(){\n  //fopn(""balance"");\n  ios;\n  int T=1;\n  cin>>T;\n  while(T--){\n    solve();\n  }\n}']","['greedy', 'implementation', 'strings']",800
https://codeforces.com//contest/1113/problem/B,B. Sasha and Magnetic Machines,One day Sasha visited the farmer 2D and his famous magnetic farm On this farm the crop grows due to the influence of a special magnetic field Maintaining of the magnetic field is provided by n machines and the power of the i th machine is a i This year 2D decided to cultivate a new culture but what exactly he didn t say For the successful growth of the new culture it is necessary to slightly change the powers of the machines 2D can choose an arbitrary integer x then choose one machine and reduce the power of its machine by x times and at the same time increase the power of one another machine by x times powers of all the machines must stay Note that he may not do that if he wants More formally 2D can choose two such indices i and j and one integer x such that x is a divisor of a i and change powers as following a i frac a i x a j a j cdot xSasha is very curious that s why he wants to calculate the total power the farmer can reach There are too many machines and Sasha can t cope with computations help him ,"['#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n, a[50000];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a+n);\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) sum += a[i];\n\n    int sol = sum;\n    for (int i = 1; i < n; i++) {\n        for (int d = 2; d <= a[i]; d++) {\n            if(a[i] % d != 0) continue;\n            sol = min(sol, sum-a[0]-a[i] + d*a[0] + a[i]/d);\n        }\n    }\n    cout << sol << endl;\n    return 0;\n}\n']","['greedy', 'number theory']",1300
https://codeforces.com//contest/1713/problem/C,C. Build Permutation,A array a of size n is called if for all valid indices i 0 le i le n 1 a i i is a perfect square dagger Given an integer n Find a permutation ddagger p of 0 1 2 ldots n 1 that is good or determine that no such permutation exists dagger An integer x is said to be a perfect square if there exists an integer y such that x y 2 ddagger An array b is a permutation of an array a if b consists of the elements of a in arbitrary order For example 4 2 3 4 is a permutation of 3 2 4 4 while 1 2 2 is not a permutation of 1 2 3 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nconst int MAX = 200200;\n\nconst int MOD = 998244353;\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vi res(n);\n\n    int curr = n-1;\n\n    while (curr > 0) {\n        int base;\n        for (base = 0; base*base < curr; base++);\n        int need = base*base-curr;\n        int start = curr;\n        for (int i = need; i <= start; i++) {\n            res[i] = curr;\n            curr--;\n        }\n    }\n    for (int i = 0; i < n; i++) cout << res[i] << "" "";\n    cout << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""input.in"", ""r"", stdin);\n    // freopen(""input.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}']","['constructive algorithms', 'dp', 'math']",1200
https://codeforces.com//contest/1582/problem/B,B. Luntik and Subsequences,Luntik came out for a morning stroll and found an array a of length n He calculated the sum s of the elements of the array s sum i 1 n a i Luntik calls a subsequence of the array a if the sum of the numbers in that subsequence is equal to s 1 Luntik really wants to know the number of subsequences of the array a But he needs to come home so he asks you to solve that problem A sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several possibly zero or all elements ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""b.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tll c0 = 0;\n\t\tll c1 = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint val;\n\t\t\tcin >> val;\n\t\t\tif (val == 0) {\n\t\t\t\t++c0;\n\t\t\t} else if (val == 1) {\n\t\t\t\t++c1;\n\t\t\t}\n\t\t}\n\t\tll r = (c1 << c0);\n\t\tcout << r << endl;\n\t}\n\treturn 0;\n}\n']","['combinatorics', 'math']",900
https://codeforces.com//contest/1675/problem/A,A. Food for Animals,In the pet store on sale there are a packs of dog food b packs of cat food c packs of universal food such food is suitable for both dogs and cats Polycarp has x dogs and y cats Is it possible that he will be able to buy food for all his animals in the store Each of his dogs and each of his cats should receive one pack of suitable food for it ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nint T,a,b,c,x,y;\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\ta = read(),b = read(),c = read(),x = read(),y = read();\n\t\tbool f1 = 0,f2 = 0;\n\t\tif (a >= x) f1 = 1;\n\t\telse if (a + c >= x) c -= x - a,f1 = 1;\n\t\tif (b >= y) f2 = 1;\n\t\telse if (b + c >= y) c -= y - b,f2 = 1;\n\t\tif (f1 && f2) puts(""YES"");\n\t\telse puts(""NO"");\n\t}\n\treturn 0;\n}']","['greedy', 'math']",800
https://codeforces.com//contest/612/problem/C,C. Replace To Make Regular Bracket Sequence,You are given string consists of opening and closing brackets of four kinds There are two types of brackets opening and closing You can replace any bracket by another of the same type For example you can replace by the bracket but you can t replace it by or The following definition of a regular bracket sequence is well known so you can be familiar with it Let s define a regular bracket sequence RBS Empty string is RBS Let and be a RBS then the strings are also RBS For example the string is RBS but the strings and are not Determine the least number of replaces to make the string RBS ,"['/*\nHide from the public eye, choose to appear when it suits you\nClaim you\'re just, killing women and children\nFight, when you choose to fight, hide in a cave when you\'re hunted\nLike a beast spawned from hell, utilizing fear\n\nChosen by god or a coward insane?\nStand up and show me your face!\n\nSuicidal, in a trance\nA religious army\nFight without a uniform and hide in the crowd\nCall it holy, call it just\nAuthorized by heaven\nLeave your wounded as they die, and call it gods will\n\nRun when its time to pay, fear consequence of your action\nReappear, when you\'re almost forgotten\nDream of a world in peace, yet you cause pain and destruction\nKill your own, a response of your actions\n\nCaptured in all you lies, fear is in your eyes\nCreature who\'s gone insane, your war is in vain\nTrapped in a cage of stone, we\'ll destroy your home\nConsequence of your action\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nstring st;\nstack<char> S;\nint ans;\n\nint get_type(char c)\n{\n\tif (c == \'<\' || c == \'{\' || c == \'[\' || c == \'(\')\n\t\treturn 1;\n\treturn 2;\n}\n\nbool paired(char a, char b)\n{\n\tif (a == \'<\'&&b == \'>\')\n\t\treturn true;\n\tif (a == \'(\'&&b == \')\')\n\t\treturn true;\n\tif (a == \'[\'&&b == \']\')\n\t\treturn true;\n\tif (a == \'{\'&&b == \'}\')\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> st;\n\n\tfor (int i = 0; i < st.size(); i++)\n\t{\n\t\tif (get_type(st[i]) == 1)\n\t\t{\n\t\t\tS.push(st[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S.size() == 0)\n\t\t{\n\t\t\tcout << ""Impossible"" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tchar val = S.top();\n\t\tif (!paired(val, st[i]))\n\t\t\t++ans;\n\t\tS.pop();\n\t}\n\n\tif (S.size())\n\t{\n\t\tcout << ""Impossible"" << endl;\n\t\treturn 0;\n\t}\n\telse\n\n\t\tcout << ans << endl;\n\tcin.get(); cin.get();\n\treturn 0;\n}']","['data structures', 'expression parsing', 'math']",1400
https://codeforces.com//contest/1476/problem/E,E. Pattern Matching,You are given n patterns p 1 p 2 dots p n and m strings s 1 s 2 dots s m Each pattern p i consists of k characters that are either lowercase Latin letters or wildcard characters denoted by underscores All patterns are pairwise distinct Each string s j consists of k lowercase Latin letters A string a matches a pattern b if for each i from 1 to k either b i is a wildcard character or b i a i You are asked to rearrange the patterns in such a way that the first pattern the j th string matches is p mt j You are allowed to leave the order of the patterns unchanged Can you perform such a rearrangement If you can then print any valid order ,"['#include<bits/stdc++.h>\nusing namespace std;\n//dengyaotriangle!\n\nconst int maxn=1e5+2;\n\nvector<int> adj[maxn];\nbool vis[maxn];\nbool ifa[maxn];\nvector<int> ans;\nvoid dfs(int u){\n    vis[u]=ifa[u]=1;\n    for(int i=0;i<adj[u].size();i++){\n        int v=adj[u][i];\n        if(vis[v]){\n            if(ifa[v]){cout<<""NO"";exit(0);}\n        }else dfs(v);\n    }\n    ifa[u]=0;\n    ans.push_back(u);\n}\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n    int n,m,k;\n    cin>>n>>m>>k;\n    map<string,int> mp;\n    for(int i=1;i<=n;i++){\n        string h;cin>>h;mp[h]=i;\n    }\n    for(int i=1;i<=m;i++){\n        string x;cin>>x;int id;cin>>id;\n        bool ok=0;\n        for(int s=0;s<(1<<k);s++){\n            string t=x;\n            for(int i=0;i<k;i++)if((s>>i)&1)t[i]=\'_\';\n            if(mp.find(t)!=mp.end()){\n                if(mp[t]==id)ok=1;\n                else{\n                    adj[mp[t]].push_back(id);\n                }\n            }\n        }\n        if(!ok){cout<<""NO"";return 0;}\n    }\n    for(int i=1;i<=n;i++){\n        if(!vis[i])dfs(i);\n    }\n    cout<<""YES\\n"";\n    for(int x:ans)cout<<x<<\' \';\n    return 0;\n}']","['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",2300
https://codeforces.com//contest/1644/problem/F,F. Basis,For an array of integers a let s define a as the number of elements in it Let s denote two functions F a k is a function that takes an array of integers a and a positive integer k The result of this function is the array containing a first elements of the array that you get by replacing each element of a with exactly k copies of that element For example F 2 2 1 3 5 6 8 2 is calculated as follows first you replace each element of the array with 2 copies of it so you obtain 2 2 2 2 1 1 3 3 5 5 6 6 8 8 Then you take the first 7 elements of the array you obtained so the result of the function is 2 2 2 2 1 1 3 G a x y is a function that takes an array of integers a and two integers x and y The result of this function is the array a with every element equal to x replaced by y and every element equal to y replaced by x For example G 1 1 2 3 5 3 1 3 3 2 1 5 An array a is a of the array b if either there exists a positive integer k such that F a k b or there exist two different integers x and y such that G a x y b An array a is an of the array b if there exists a finite sequence of arrays c 0 c 1 dots c m m ge 0 such that c 0 is a c m is b and for every i in 1 m c i 1 is a parent of c i You are given two integers n and k Your goal is to construct a sequence of arrays s 1 s 2 dots s m in such a way that every array s i contains exactly n elements and all elements are integers from 1 to k for every array a consisting of exactly n integers from 1 to k the sequence contains at least one array s i such that s i is an ancestor of a Print the minimum number of arrays in such sequence ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (""avx2"")\n#pragma GCC optimization (""O3"")\n#pragma GCC optimization (""unroll-loops"")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;\n\nvector<int> stirling(int n)\n{\n    vector<int> a(n+1);\n    for (int i = 0; i<=n; i++)\n    {\n        a[i] = invfacs[i];\n        if (i%2) a[i] = sub(0, a[i]);\n    }\n    vector<int> b(n+1);\n    for (int i = 0; i<=n; i++)\n    {\n        b[i] = mul(po(i, n), invfacs[i]);\n    }\n\n    auto res = ntt.product(a, b);\n    res.resize(n+1);\n    return res;\n}\n\nmap<int, vector<int>> cool;\n\nvoid print(vector<int> a)\n{\n    for (auto it: a) cout<<it<<\' \';\n    cout<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    init();\n\n    int n, k; cin>>n>>k;\n\n    if (n==1 || k==1)\n    {\n        cout<<1<<endl;\n        return 0;\n    }\n\n    vector<int> dp(n+1);\n\n    dp[n] = 0;\n    for (int len = n-1; len>=1; len--)\n    {\n        int cnt = (n+len-1)/len;\n\n        if (cool.find(cnt)==cool.end())\n        {\n            cool[cnt] = stirling(cnt);\n        }\n\n        for (int groups = 1; groups<=min(k, cnt); groups++)\n        {\n            dp[len] = add(dp[len], cool[cnt][groups]);\n        }\n\n        dp[len] = sub(dp[len], 1);\n\n        for (int i = 2*len; i<=n; i+=len) dp[len] = sub(dp[len], dp[i]);\n    }\n\n    /*for (auto it: cool)\n    {\n        cout<<it.first<<"": ""; print(it.second);\n    }*/\n\n    cout<<dp[1];\n\n}\n']","['combinatorics', 'fft', 'math', 'number theory']",2900
https://codeforces.com//contest/1609/problem/G,G. A Stroll Around the Matrix,William has two arrays of numbers a 1 a 2 dots a n and b 1 b 2 dots b m The arrays satisfy the conditions of being convex Formally an array c of length k is considered convex if c i c i 1 c i 1 c i for all i from 2 to k 1 and c 1 c 2 Throughout William s life he observed q changes of two types happening to the arrays Add the arithmetic progression d d cdot 2 d cdot 3 dots d cdot k to the suffix of the array a of length k The array after the change looks like this a 1 a 2 dots a n k a n k 1 d a n k 2 d cdot 2 dots a n d cdot k The same operation but for array b After each change a matrix d is created from arrays a and b of size n times m where d i j a i b j William wants to get from cell 1 1 to cell n m of this matrix From cell x y he can only move to cells x 1 y and x y 1 The length of a path is calculated as the sum of numbers in cells visited by William including the first and the last cells After each change William wants you to help find out the minimal length of the path he could take ,"['/**\n *    author:  tourist\n *    created: 28.11.2021 18:24:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  auto init_b = b;\n  vector<long long> da(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    da[i] = a[i + 1] - a[i];\n  }\n  vector<long long> db(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    db[i] = b[i + 1] - b[i];\n  }\n  fenwick<int> fenw(m - 1);\n  fenwick<long long> fenw2(m - 1);\n  long long ans = 0;\n  for (int i = 0; i < m - 1; i++) {\n    ans += db[i] * (m - 1 - i);\n  }\n  while (q--) {\n    int type, k, d;\n    cin >> type >> k >> d;\n    if (type == 1) {\n      if (k == n) {\n        a[0] += d;\n        k -= 1;\n      }\n      for (int i = 0; i < k; i++) {\n        a[n - k + i] += d * (i + 1);\n        da[n - k + i - 1] += d;\n      }\n    } else {\n      if (k == m) {\n        b[0] += d;\n        k -= 1;\n      }\n      fenw.modify(m - k - 1, d);\n      fenw2.modify(m - k - 1, ((long long) -d) * (m - k - 2));\n      ans += ((long long) d) * k * (k + 1LL) / 2;\n    }\n    long long res = ans;\n    res += (a[0] + b[0]) * (n + m - 1);\n    for (int i = 0; i < n - 1; i++) {\n      int low = 0, high = m - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        if (db[mid] + fenw.get(mid) > da[i]) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      int my_id = (n - 2 - i) + (m - 1 - low) + 1;\n      res += da[i] * my_id;\n      res += init_b[low] - init_b[0];\n      res += fenw.get(low - 1) * (long long) (low - 1) + fenw2.get(low - 1);\n    }\n    cout << res << \'\\n\';\n  }\n  return 0;\n}\n']","['data structures', 'greedy', 'math']",3000
https://codeforces.com//contest/1722/problem/G,G. Even-Odd XOR,Given an integer n find any array a of n nonnegative integers less than 2 31 such that the bitwise XOR of the elements on odd indices equals the bitwise XOR of the elements on even indices ,"['#include <bits/stdc++.h>\n#ifdef LOCAL\n#include ""txm/debug.h""\n#endif\n#define int long long\nusing namespace std;\nusing ll=long long;\nconst int N=200005;\nint n,a[N];\nvoid solve()\n{\n\tcin>>n;\n\tif(n==3) {cout<<""2 1 3\\n""; return;}\n\tbool bj=0;\n\tif(n%2) n--,bj=1;\n\tfor(int i=1;i<=n;i+=2) a[i]=i/2+1;\n\tfor(int i=2;i<=n;i+=2) a[i]=i/2;\n\tif(n%4==0)\n\t{\n\t\tfor(int i=2;i<=n;i+=2) a[i]|=(1<<30);\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<n;i+=2) a[i]|=(1<<30);\n\t\tfor(int i=n;i>=4;i-=2) a[i]|=(1<<29);\n\t}\n\tif(bj) a[++n]=0;\n\tfor(int i=1;i<=n;i++) cout<<a[i]<<"" \\n""[i==n];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}\n']","['bitmasks', 'constructive algorithms', 'greedy']",1500
https://codeforces.com//contest/1657/problem/E,E. Star MST,In this problem we will consider undirected graphs consisting of n vertices with weighted edges The weight of each edge is an integer from 1 to k An undirected graph is considered if the sum of weights of all edges incident to vertex 1 is equal to the weight of MST in the graph MST is the minimum spanning tree a tree consisting of n 1 edges of the graph which connects all n vertices and has the minimum sum of weights among all such trees the weight of MST is the sum of weights of all edges in it Calculate the number of graphs having exactly n vertices and the weights of edges from 1 to k Since the answer might be large print it modulo 998244353 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = 253;\nconst int M = N * N / 2;\nMint C[N][N];\nMint pw[N][M];\nMint dp[N][N];\nint n, k;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\tfor (int i = 1; i < N; i++) {\n\t\tpw[i][0] = 1;\n\t\tfor (int j = 1; j < M; j++)\n\t\t\tpw[i][j] = pw[i][j - 1] * i;\n\t}\n\n\tscanf(""%d%d"", &n, &k);\n\tdp[0][n - 1] = 1;\n\tfor (int i = 1; i <= k; i++)\n\t\tfor (int x = 0; x < n; x++)\n\t\t\tfor (int y = 0; y <= x; y++) {\n\t\t\t\tdp[i][x - y] += dp[i - 1][x] * C[x][y] * pw[i][x * (x - 1) / 2 - (x - y) * (x - y - 1) / 2];\n\t\t\t}\n\tprintf(""%u\\n"", dp[k][0].x);\n\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'graph matchings', 'math']",2200
https://codeforces.com//contest/1838/problem/A,A. Blackboard List,Two integers were written on a blackboard After that the following step was carried out n 2 times Select any two integers on the board and write the absolute value of their difference on the board After this process was complete the list of n integers was shuffled You are given the final list Recover of the initial two numbers You do need to recover the other one You are guaranteed that the input can be generated using the above process ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t; cin>>t;\n    for (int ti = 0; ti < t; ++ti) {\n        int n; cin>>n;\n        vector<int> v(n);\n        for (auto& a : v) {\n            cin>>a;\n        }\n        int ans = 0;\n        for (auto a : v) {\n            if (a < 0) {\n                cout << a << ""\\n"";\n                goto next;\n            }\n            ans = max(ans,a);\n        }\n        cout << ans << ""\\n"";\n    next:;}\n}\n']","['constructive algorithms', 'math']",800
https://codeforces.com//contest/242/problem/A,A. Heads or Tails,Petya and Vasya are tossing a coin Their friend Valera is appointed as a judge The game is very simple First Vasya tosses a coin times then Petya tosses a coin times If the tossing player gets head he scores one point If he gets tail nobody gets any points The winner is the player with most points by the end of the game If boys have the same number of points the game finishes with a draw At some point Valera lost his count and so he can not say exactly what the score is at the end of the game But there are things he remembers for sure He remembers that the entire game Vasya got heads at least times and Petya got heads at least times Moreover he knows that the winner of the game was Vasya Valera wants to use this information to know every possible outcome of the game which do not contradict his memories ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint x, y, a, b; scanf(""%d%d%d%d"", &x, &y, &a, &b);\n\n\tvector<pair<int, int> > ans;\n\tfor (int i = a; i <= x; ++i)\n\t\tfor (int j = b; j <= y; ++j)\n\t\t\tif (i > j) ans.push_back(make_pair(i, j));\n\n\tsort(ans.begin(), ans.end());\n\tprintf(""%d\\n"", (int)ans.size());\n\tfor (int i = 0; i < ans.size(); ++i) printf(""%d %d\\n"", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n']","['brute force', 'implementation']",1100
https://codeforces.com//contest/356/problem/E,E. Xenia and String Problem,Xenia the coder went to The Olympiad of Informatics and got a string problem Unfortunately Xenia isn t fabulous in string algorithms Help her solve the problem is a sequence of characters where record shows the length of the string of string is string String is a string if it meets the conditions the length of string is odd character occurs exactly once in the string either or substrings and are the same and are Gray strings For example strings are Gray strings and strings are not The of string is the sum of the squares of the lengths of all substrings of string that are Gray strings In other words consider all pairs of values If substring is a Gray string you should add to the beauty Xenia has got string consisting of lowercase English letters She is allowed to replace at most one letter of the string by any other English letter The task is to get a string of maximum beauty ,"['// WRONG ANSWER\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n#include <tuple>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntypedef pair<int, char> change;\n\nstatic char get(\n    const vector<vector<char> > &gray,\n    const vector<vector<map<change, char> > > &changes,\n    int level, int pos, change ch)\n{\n    int side = (1 << level) - 1;\n    int left = pos - side;\n    int right = pos + side;\n    if (ch.first < left || ch.first > right)\n        return gray[level][pos];\n    else\n    {\n        auto p = changes[level][pos].find(ch);\n        if (p == changes[level][pos].end())\n            return 0;\n        else\n            return p->second;\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    string str;\n    int L;\n    cin >> str;\n    L = str.size();\n    int N = 0;\n    while ((1 << (N + 1)) - 1 <= L)\n        N++;\n\n    vector<ll> value(N);\n    for (int i = 0; i < N; i++)\n    {\n        ll len = (1 << (i + 1)) - 1;\n        value[i] = len * len;\n    }\n\n    vector<vector<char> > gray(N, vector<char>(L, \'\\0\'));\n    vector<vector<map<change, char> > > changes(N, vector<map<change, char> >(L));\n    for (int i = 0; i < L; i++)\n    {\n        gray[0][i] = str[i];\n        for (int j = 0; j < 26; j++)\n            if (\'a\' + j != str[i])\n                changes[0][i].insert(make_pair(change(i, \'a\' + j), \'a\' + j));\n    }\n\n    ll score = L;\n    vector<ll> lose(L);\n    vector<vector<ll> > gain(26, vector<ll>(L));\n    for (int i = 1; i < N; i++)\n    {\n        const int side = (1 << i) - 1;\n        const int step = 1 << (i - 1);\n        for (int j = side; j < L - side; j++)\n        {\n            char left = gray[i - 1][j - step];\n            char right = gray[i - 1][j + step];\n            char mid = gray[i - 1][j];\n            gray[i][j] = (left && mid && right\n                && left == right && left != mid) ? str[j] : 0;\n            for (int jump = -step; jump <= step; jump += step)\n            {\n                for (auto cx : changes[i - 1][j + jump])\n                {\n                    const change c = cx.first;\n                    char l2 = get(gray, changes, i - 1, j - step, c);\n                    char m2 = get(gray, changes, i - 1, j, c);\n                    char r2 = get(gray, changes, i - 1, j + step, c);\n                    if (l2 && m2 && r2 && l2 == r2 && l2 != m2)\n                        changes[i][j].insert(make_pair(c, m2));\n                }\n            }\n            if (gray[i][j])\n            {\n                score += value[i];\n                for (int k = j - side; k <= j + side; k++)\n                    lose[k] += value[i];\n            }\n            for (auto cx : changes[i][j])\n                gain[cx.first.second - \'a\'][cx.first.first] += value[i];\n        }\n    }\n\n    ll ans = score;\n    for (int i = 0; i < 26; i++)\n        for (int j = 0; j < L; j++)\n        {\n            ll cur = score - lose[j] + gain[i][j];\n            ans = max(ans, cur);\n        }\n\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']","['dp', 'hashing', 'implementation', 'string suffix structures', 'strings']",3000
https://codeforces.com//contest/1562/problem/B,B. Scenes From a Memory,During the hypnosis session Nicholas suddenly remembered a positive integer n which Soon when he returned home he got curious what is the maximum number of digits that can be removed from the number so that the number becomes that is either composite or equal to one For some numbers doing so is impossible for example for number 53 it s impossible to delete some of its digits to obtain a not prime integer However Note that you cannot remove all the digits from the number A prime number is a number that has no divisors except one and itself A composite is a number that has more than two divisors 1 is neither a prime nor a composite number ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint t,n;\nbool a[105];\nstring s;\ninline bool prime(int p){\n    if(p==1)return 1;\n    for(register int i=2;i*i<=p;i++)if(p%i==0)return 1;\n    return 0;\n}\nsigned main(){\n    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n    cin>>t;\n    for(register int i=1;i<=100;i++)a[i]=prime(i);\n    while(t--){\n        cin>>n>>s;\n        bool flag=1;\n        for(register int i=0;i<n&&flag;i++)if(s[i]==\'1\'||s[i]==\'4\'||s[i]==\'6\'||s[i]==\'9\'||s[i]==\'8\'){cout<<""1\\n""<<s[i]<<endl;flag=0;}\n        if(!flag)continue;\n        for(register int i=0;i<n&&flag;i++)\n        for(register int j=i+1;j<n&&flag;j++)if(a[(s[i]-\'0\')*10+s[j]-\'0\']){\n            cout<<""2\\n""<<s[i]<<s[j]<<endl;\n            flag=0;\n        }\n    }\n    return 0;\n}']","['brute force', 'constructive algorithms', 'implementation', 'math', 'number theory']",1000
https://codeforces.com//contest/1080/problem/F,F. Katya and Segments Sets,It is a very important day for Katya She has a test in a programming class As always she was given an interesting problem that she solved very fast Can you solve that problem You are given n ordered segments sets Each segment can be represented as a pair of two integers l r where l leq r Each set can contain an arbitrary number of segments even 0 It is possible that some segments are equal You are also given m queries each of them can be represented as four numbers a b x y For each segment find out whether it is true that each set p a leq p leq b contains at least one segment l r that lies entirely on the segment x y that is x leq l leq r leq y Find out the answer to each query Note that you need to solve this problem That is you will get a new query only after you print the answer for the previous query ,"['#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 300050;\nconst int NN = N * 20;\nconst int INF = 2000000000;\n\nint root[N], maxv[NN], lc[NN], rc[NN], cnt = 1;\n\nvoid insert(int &o, int l, int r, int p, int y) {\n  maxv[cnt] = maxv[o];\n  lc[cnt] = lc[o];\n  rc[cnt] = rc[o];\n  o = cnt++;\n  if (l == r) maxv[o] = std::min(maxv[o], y);\n  else {\n    int mid = (l + r) / 2;\n    if (p <= mid) insert(lc[o], l, mid, p, y);\n    else insert(rc[o], mid + 1, r, p, y);\n    maxv[o] = std::max(maxv[lc[o]], maxv[rc[o]]);\n  }\n}\n\nint query(int o, int l, int r, int L, int R) {\n  if (l > R || L > r) return 0;\n  if (!o) return INF;\n  if (L <= l && r <= R) return maxv[o];\n  int mid = (l + r) / 2;\n  return std::max(query(lc[o], l, mid, L, R), query(rc[o], mid + 1, r, L, R));\n}\n\nstruct Interval {\n  int l, r, p;\n  friend bool operator<(const Interval &a, const Interval &b) {\n    return a.l > b.l;\n  }\n} I[N];\n\nint n, m, k;\n\nint main(){\n  maxv[0] = INF;\n  lc[0] = rc[0] = 0;\n  scanf(""%d%d%d"", &n, &m, &k);\n  for (int i = 0; i < k; ++i)\n    scanf(""%d%d%d"", &I[i].l, &I[i].r, &I[i].p);\n  std::sort(I, I + k);\n  root[0] = 0;\n  for (int i = 0; i < k; ++i) {\n    //printf(""  %d %d %d %d\\n"", i, I[i].l, I[i].r, I[i].p);\n    insert(root[i + 1] = root[i], 1, n, I[i].p, I[i].r);\n  }\n  while (m--) {\n    int a, b, x, y;\n    scanf(""%d%d%d%d"", &a, &b, &x, &y);\n    Interval t;\n    t.l = x;\n    int i = std::upper_bound(I, I + k, t) - I;\n    //printf(""  %d "", i);\n    puts(query(root[i], 1, n, a, b) <= y ? ""yes"" : ""no"");\n    fflush(stdout);\n  }\n  return 0;\n}']","['data structures', 'interactive', 'sortings']",2400
https://codeforces.com//contest/1244/problem/B,B. Rooms and Staircases,Nikolay lives in a two storied house There are n rooms on each floor arranged in a row and numbered from one from left to right So each room can be represented by the number of the floor and the number of the room on this floor room number is an integer between 1 and n If Nikolay is currently in some room he can move to any of the neighbouring rooms if they exist Rooms with numbers i and i 1 on each floor are neighbouring for all 1 leq i leq n 1 There may also be staircases that connect two rooms from different floors having the same numbers If there is a staircase connecting the room x on the first floor and the room x on the second floor then Nikolay can use it to move from one room to another Nikolay wants to move through some rooms in his house To do this he firstly chooses any room where he starts Then Nikolay moves between rooms according to the aforementioned rules Nikolay never visits the same room twice he won t enter a room where he has already been Calculate the maximum number of rooms Nikolay can visit during his tour if he can start and ,"['#include <bits/stdc++.h>\nusing namespace std;\nchar s[100010];\nint n, t;\nint main() {\n    scanf(""%d"", &t);\n    while(t--) {\n        scanf(""%*d%s"", s + 1);\n        n = strlen(s + 1);\n        int _min = n + 1, _max = 0;\n        for(int i = 1; i <= n; i++) if(s[i] == \'1\') _min = min(_min, i), _max = max(_max, i);\n        if(_max == 0) printf(""%d\\n"", n);\n        else printf(""%d\\n"", max(_max, n - _min + 1) * 2);\n    }\n}']","['brute force', 'implementation']",1000
https://codeforces.com//contest/821/problem/B,B. Okabe and Banana Trees,Okabe needs bananas for one of his experiments for some strange reason So he decides to go to the forest and cut banana trees Consider the point in the 2D plane such that and are integers and There is a tree in such a point and it has bananas There are no trees nor bananas in other points Now Okabe draws a line with equation Okabe can select a single rectangle with axis aligned sides with all points on or under the line and cut all the trees in all points that are inside or on the border of this rectangle and take their bananas Okabe s rectangle can be degenerate that is it can be a line segment or even a point Help Okabe and find the maximum number of bananas he can get if he chooses the rectangle wisely Okabe is sure that the answer does not exceed You can trust him ,"['#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn \ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') ch = getchar();\n\twhile (ch >= \'0\' && ch <= \'9\')\n\t\tx = x * 10 + ch - \'0\', ch = getchar();\n}\nint m, b;\nll ans;\nint main() {\n\tgn(m); gn(b);\n\tfor (int y = 0; y <= b; ++y) {\n\t\tint x = m * (b - y);\n\t\tans = max(ans, 1ll * x * (x + 1) / 2ll * (y + 1) + 1ll * y * (y + 1) / 2ll * (x + 1));\n\t}\n\tprintf(""%I64d\\n"", ans);\n\treturn 0;\n}\n\n\n']","['brute force', 'math']",1300
https://codeforces.com//contest/402/problem/B,B. Trees in a Row,The Queen of England has trees growing in a row in her garden At that the th tree from the left has height meters Today the Queen decided to update the scenery of her garden She wants the trees heights to meet the condition for all where is the number the Queen chose Unfortunately the royal gardener is not a machine and he cannot fulfill the desire of the Queen instantly In one minute the gardener can either decrease the height of a tree to any positive integer height or increase the height of a tree to any positive integer height How should the royal gardener act to fulfill a whim of Her Majesty in the minimum number of minutes ,"['//Codeforces 236\n#include <cmath>\n\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int MAX_N = 1005;\n\nint N, K;\nint h[MAX_N];\n\nint main() {\n  cin >> N >> K;\n  for (int i = 1; i <= N; i += 1) cin >> h[i];\n\n  int start = INF, best = INF;\n  for (int l = 1; l <= MAX_N; l += 1) {\n    int nh = l, cost = 0;\n    for (int i = 1; i <= N; i += 1) {\n      cost += (abs(h[i] - nh) != 0);\n      nh += K;\n    }\n    if (cost < best) {\n      best = cost;\n      start = l;\n    }\n  }\n\n  int nh = start;\n  cout << best << \'\\n\';\n  for (int i = 1; i <= N; i += 1) {\n    if (h[i] - nh > 0) {\n      cout << ""- "" << i << \' \' << h[i] - nh << \'\\n\';\n    } else if (nh - h[i] > 0) {\n      cout << ""+ "" << i << \' \' << nh - h[i] << \'\\n\';\n    }\n    nh += K;\n  }\n\n  return 0;\n}\n\n']","['brute force', 'implementation']",1400
https://codeforces.com//contest/1187/problem/A,A. Stickers and Toys,Your favorite shop sells n Kinder Surprise chocolate eggs You know that exactly s stickers and exactly t toys are placed in n eggs in total Each Kinder Surprise can be one of three types it can contain a single sticker and it can contain a single toy and it can contain both a single sticker a single toy But you which type a particular Kinder Surprise has All eggs look identical and indistinguishable from each other What is the minimum number of Kinder Surprise Eggs you have to buy to be sure that whichever types they are you ll obtain at least one sticker and at least one toy Note that you do not open the eggs in the purchasing process that is you just buy some number of eggs It s guaranteed that the answer always exists ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\tfor (int i=1; i<=t; i++)\n\t{\n\t\tll n, a, b;\n\t\tscanf(""%lld%lld%lld"", &n, &a, &b);\n\t\tif (a>b)\n\t\t\tswap(a, b);\n\t\tll x=b-(a+b-n)+1;\n\t\tprintf(""%lld\\n"", x);\n\t}\n\treturn 0;\n}\n']",['math'],900
https://codeforces.com//contest/1836/problem/B,B. Astrophysicists,In many many years far far away there will be a launch of the first flight to Mars To celebrate the success n astrophysicists working on the project will be given bonuses of a total value of k gold coins You have to distribute the money among the astrophysicists and to make it easier you have to assign bonuses in silver coins Each gold coin is worth g silver coins so you have to distribute all k cdot g silver coins among n people Unfortunately the company has some financial troubles right now Therefore instead of paying the number of silver coins written on the bonus they decided to round this amount to the nearest integer number of gold coins The rounding procedure is as follows If an astrophysicist has bonus equal to x silver coins and we denote r x bmod g then If r geq lceil frac g 2 rceil the astrophysicist receives x g r silver coins Otherwise an astrophysicists receives x r silver coins Note that due to rounding the total sum of actually paid money is not in general equal to k cdot g silver coins The operation a bmod b denotes the remainder of the division of a by b Sum of values before rounding but some workers can be assigned 0 silver coins You aim to distribute the bonuses so that the company saves as many silver coins due to rounding as possible Please note that there is always a distribution in which the company spends no more than k cdot g silver coins ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint n, k, g;\n\t\tcin >> n >> k >> g;\n\t\tlong long total = k * 1LL * g;\n\t\tlong long at_first = min(total, (g - 1) / 2 * 1LL * n);\n\t\tlong long used = total - at_first;\n\t\tif (used % g > 0) used += g - (used % g);\n\t\t\n\t\tcout << total - used << endl;\n\t}\n\t\n\treturn 0;\n}\n']","['greedy', 'math']",1100
https://codeforces.com//contest/1693/problem/C,C. Keshi in Search of AmShZ,AmShZ has traveled to Italy from Iran for the Thom Yorke concert There are n cities in Italy indexed from 1 to n and m roads indexed from 1 to m Initially Keshi is located in the city 1 and wants to go to AmShZ s house in the city n Since Keshi doesn t know the map of Italy AmShZ helps him to see each other as soon as possible In the beginning of each day AmShZ can send one of the following two messages to Keshi AmShZ sends the index of one road to Keshi as a road Then Keshi will understand that he should never use that road and he will remain in his current city for the day AmShZ tells Keshi to move Then Keshi will randomly choose one of the cities reachable from his current city and move there city B is reachable from city A if there s an out going road from city A to city B which hasn t become yet If there are no such cities Keshi will remain in his current city Note that AmShZ always knows Keshi s current location AmShZ and Keshi want to find the smallest possible integer d for which they can make sure that they will see each other after at most d days Help them find d ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\n\nint wyn[nax];\n\nint jesz[nax];\nvi graf[nax];\n\nint wiem[nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[b].push_back(a);\n\t\tjesz[a]++;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\twiem[i]=-1;\n\tpriority_queue<pii> kol;\n\tkol.push({0, n});\n\twhile(!kol.empty())\n\t{\n\t\tint odl=-kol.top().first;\n\t\tint v=kol.top().second;\n\t\tkol.pop();\n\t\tif (wiem[v]>=0)\n\t\t\tcontinue;\n\t\twiem[v]=odl;\n\t\tfor (int i : graf[v])\n\t\t{\n\t\t\tjesz[i]--;\n\t\t\tkol.push({-(1+odl+jesz[i]), i});\n\t\t}\n\t}\n\tprintf(""%d\\n"", wiem[1]);\n\treturn 0;\n}\n']","['graphs', 'greedy', 'shortest paths']",2300
https://codeforces.com//contest/1038/problem/B,B. Non-Coprime Partition,Find out if it is possible to partition the first n positive integers into two disjoint sets S 1 and S 2 such that mathrm gcd mathrm sum S 1 mathrm sum S 2 1 Here mathrm sum S denotes the sum of all elements present in set S and mathrm gcd means thegreatest common divisor Every integer number from 1 to n should be present in of S 1 or S 2 ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(""%lld"", &x); return x;}\nvoid read(char *s){scanf(""%s"", s);}\nvoid no(){printf(""No""); exit(0);}\n\n#define maxn 120000\n#define maxm\n\n\nint main(){\n\tLL n = read();\n\tLL s = n * (n + 1) / 2;\n\tfor(int i = 2; i <= n; i += 1){\n\t\tif(s % i == 0){\n\t\t\tprintf(""Yes\\n1 %d\\n%lld "", i, n - 1);\n\t\t\tfor(int j = 1; j <= n; j += 1) if(j != i) printf(""%d "", j);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tno();\n}']","['constructive algorithms', 'math']",1100
https://codeforces.com//contest/1456/problem/A,A. Bouncing Ball,You re creating a game level for some mobile game The level should contain some number of cells aligned in a row from left to right and numbered with consecutive integers starting from 1 and in each cell you can either put a platform or leave it empty In order to pass a level a player must throw a ball from the left so that it first lands on a platform in the cell p then bounces off it then bounces off a platform in the cell p k then a platform in the cell p 2k and so on every k th platform until it goes farther than the last cell If any of these cells has no platform you can t pass the level with these p and k You already have some level pattern a 1 a 2 a 3 a n where a i 0 means there is no platform in the cell i and a i 1 means there is one You want to modify it so that the level can be passed with given p and k In x seconds you can add a platform in some empty cell In y seconds you can remove the first cell completely reducing the number of cells by one and renumerating the other cells keeping their order You can t do any other operation You reduce the number of cells to less than p What is the minimum number of seconds you need to make this level passable with given p and k ,"[""#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, P, K; cin >> N >> P >> K; P--;\n\t\tstring s; cin >> s;\n\t\tvector<int64_t> A(N);\n\n\t\tint64_t X, Y; cin >> X >> Y;\n\t\tint64_t ans = N * X;\n\t\tfor (int i = N-1; i >= P; i--) {\n\t\t\tA[i] = (s[i] == '1' ? 0 : X);\n\t\t\tif (i+K < N) {\n\t\t\t\tA[i] += A[i+K];\n\t\t\t}\n\t\t\tans = min(ans, A[i] + Y * (i - P));\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n""]","['brute force', 'dp', 'implementation']",1400
https://codeforces.com//contest/1314/problem/C,C. Au Pont Rouge,VK just opened its second HQ in St Petersburg Side of its office building has a huge string s written on its side This part of the office is supposed to be split into m meeting rooms in such way that meeting room walls are strictly between letters on the building Obviously meeting rooms should not be of size 0 but can be as small as one letter wide Each meeting room will be named after the substring of s written on its side For each possible arrangement of m meeting rooms we ordered a test meeting room label for the meeting room with lexicographically name When delivered those labels got sorted lexicographically What is printed on kth label of the delivery ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nvector<int> z_algorithm(const T& a) {\n  int n = a.size();\n  vector<int> z(n);\n  z[0] = n;\n  int l = -1, r = -1;\n  for (int i = 1; i < n; ++i) {\n    z[i] = i >= r ? 0 : min(r - i, z[i - l]);\n    while (i + z[i] < n && a[i + z[i]] == a[z[i]]) {\n      ++z[i];\n    }\n    if (i + z[i] > r) {\n      l = i;\n      r = i + z[i];\n    }\n  }\n  return z;\n}\n\nconst int N = 523456;\n\nint tot = 1, pr[N], nxt[N][26];\nchar val[N];\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  long long k;\n  string s;\n  cin >> n >> m >> k >> s;\n  for (int i = 0; i < n; ++i) {\n    int x = 1;\n    for (int j = i; j < n; ++j) {\n      if (!nxt[x][s[j] - \'a\']) {\n        nxt[x][s[j] - \'a\'] = ++tot;\n        val[tot] = s[j];\n        pr[tot] = x;\n      }\n      x = nxt[x][s[j] - \'a\'];\n    }\n  }\n  vector<int> order;\n  function<void(int)> dfs = [&](int v) {\n    for (int i = 0; i < 26; ++i) {\n      if (nxt[v][i]) {\n        order.push_back(nxt[v][i]);\n        dfs(nxt[v][i]);\n      }\n    }\n  };\n  dfs(1);\n  auto get = [&](int v) {\n    string res;\n    while (v != 1) {\n      res.push_back(val[v]);\n      v = pr[v];\n    }\n    reverse(res.begin(), res.end());\n    return res;\n  };\n  auto check = [&](string t) {\n    vector<int> z = z_algorithm(t + s);\n    vector<int> lcp(n);\n    for (int i = 0; i < n; ++i) {\n      lcp[i] = min(z[i + t.size()], (int) t.size() - 1);\n    }\n    vector<long long> dp(n + 1);\n    dp[0] = 1;\n    for (int tt = 0; tt < m; ++tt) {\n      vector<long long> new_dp(n + 1);\n      for (int i = 0; i < n; ++i) {\n        if (s[i + lcp[i]] >= t[lcp[i]]) {\n          new_dp[i + lcp[i] + 1] = min(k, new_dp[i + lcp[i] + 1] + dp[i]);\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        new_dp[i] = min(k, new_dp[i] + new_dp[i - 1]);\n      }\n      swap(dp, new_dp);\n    }\n    return dp[n] >= k;\n  };\n  int l = 0, r = order.size() - 1;\n  while (l < r) {\n    int mid = (l + r + 1) >> 1;\n    string t = get(order[mid]);\n    if (check(t)) {\n      l = mid;\n    } else {\n      r = mid - 1;\n    }\n  }\n  cout << get(order[l]) << ""\\n"";\n  return 0;\n}\n']","['binary search', 'dp', 'sortings', 'strings']",2800
https://codeforces.com//contest/1888/problem/C,C. You Are So Beautiful,You are given an array of integers a 1 a 2 ldots a n Calculate the number of of this array 1 leq l leq r leq n such that The array b a l a l 1 ldots a r occurs in the array a as a exactly once In other words there is exactly one way to select a set of indices 1 leq i 1 i 2 ldots i r l 1 leq n such that b j a i j for all 1 leq j leq r l 1 ,"['#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<map>\ntypedef long long ll;\nconst int maxn=2e5+5;\nint t;\nint n;\nint a[maxn],fir[maxn],las[maxn];\nstd::map<int,bool>apr;\nsigned main(){\n\tscanf(""%d"",&t);\n\tfor(int wc=1;wc<=t;wc++){\n\t\tapr.clear();\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i),fir[i]=(!apr[a[i]]),apr[a[i]]=true;\n\t\tapr.clear(),las[n+1]=0;\n\t\tfor(int i=n;i;i--)las[i]=las[i+1]+(!apr[a[i]]),apr[a[i]]=true;\n\t\tll ans=0;\n\t\tfor(int i=1;i<=n;i++)ans+=fir[i]*las[i];\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n//namespace burningContract\n']",['data structures'],1400
https://codeforces.com//contest/148/problem/B,B. Escape,The princess is going to escape the dragon s cave and she needs to plan it carefully The princess runs at miles per hour and the dragon flies at miles per hour The dragon will discover the escape after hours and will chase the princess immediately Looks like there s no chance to success but the princess noticed that the dragon is very greedy and not too smart To delay him the princess decides to borrow a couple of bijous from his treasury Once the dragon overtakes the princess she will drop one bijou to distract him In this case he will stop pick up the item return to the cave and spend hours to straighten the things out in the treasury Only after this will he resume the chase again from the very beginning The princess is going to run on the straight The distance between the cave and the king s castle she s aiming for is miles How many bijous will she need to take from the treasury to be able to reach the castle If the dragon overtakes the princess at exactly the same moment she has reached the castle we assume that she reached the castle before the dragon reached her and doesn t need an extra bijou to hold him off ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint main()\n{\n    int i,j,k;\n    double v1,v2,t,f,c;\n    cin>>v1>>v2>>t>>f>>c;\n    if (dblcmp(v1-v2)>=0)\n    {\n        puts(""0"");\n        return 0;\n    }\n    double x=0,y=0;\n    int ans=0;\n    x+=v1*t;\n    while (dblcmp(x-c)<0)\n    {\n        double d=x-y;\n        double s=d/(v2-v1);\n        x+=v1*s;\n        y+=v2*s;\n        if (dblcmp(x-c)>=0)\n        {\n            printf(""%d\\n"",ans);\n            return 0;\n        }\n        ans++;\n        x+=v1*(f+y/v2);\n        y=0;\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n        ']","['implementation', 'math']",1500
https://codeforces.com//contest/53/problem/B,B. Blog Photo,One popular blog site edits the uploaded photos like this It cuts a rectangular area out of them so that the ratio of height to width i e the quotient can vary from 0 8 to 1 25 inclusively Besides at least one side of the cut area should have a size equal to some power of number 2 for some integer If those rules don t indicate the size of the cut are clearly then the way with which the cut part possesses the largest area is chosen Of course both sides of the cut area should be integer If there are several answers to this problem you should choose the answer with the maximal height ,"['#pragma comment(linker,""/stack:67108864"")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <sstream>\n#include <fstream>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <ctime>\n#include <numeric>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#include <bitset>\n#include <string>\n#include <list>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <typeinfo>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<int(n);++i)\n#define forn1(i,n) for(int i=1;i<=int(n);++i)\n#define ford(i,n) for(int i=int(n)-1;i>=0;--i)\n#define ford1(i,n) for(int i=int(n);i>0;--i)\n#define foran(i,l,r) for(int i=int(l);i<int(r);++i)\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define sqr(x) (x)*(x)\n#define all(v) (v).begin(),(v).end()\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair <ld ,ld > pt;\n\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932384626433832795;\n\nconst int INF=1000*1000*1000;\nconst int CF=1;\n\nint main()\n{\n    if(!CF) freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    ll h,w;\n    cin >>h >>w;\n    vector <ll> p;\n    ll t=1;\n    while(t<=max(h,w))\n    {       \n        p.push_back(t);\n        t*=2;\n    }\n    vector <pair<ll,pair<ll,ll> >> ans;\n    forn(i,p.size())\n    {\n        if(w<p[i]) break;\n        if(h<0.8*p[i]) break;\n        ans.push_back(mp(min(h,ll(1.25*p[i]))*p[i],mp(min(h,ll(1.25*p[i])),p[i])));\n    }\n    forn(i,p.size())\n    {\n        if(h<p[i]) break;\n        if(w<0.8*p[i]) break;\n        ans.push_back(mp(p[i]*min(w,ll(1.25*p[i])),mp(p[i],min(w,ll(1.25*p[i])))));\n    }\n    sort(all(ans));\n    cout <<ans.back().second.first <<"" "" <<ans.back().second.second<<endl;\n    return 0;\n}']","['binary search', 'implementation']",1700
https://codeforces.com//contest/1914/problem/G1,G1. Light Bulbs  Easy Version , There are 2n light bulbs arranged in a row Each light bulb has a color from 1 to n Initially all light bulbs are turned off You choose a set of light bulbs S that you initially turn on After that you can perform the following operations in any order any number of times choose two light bulbs i and j exactly one of which is on and turn on the second one choose three light bulbs i j k such that both light bulbs i and k and the light bulb j is between them i j k and turn on the light bulb j You want to choose a set of light bulbs S that you initially turn on in such a way that by performing the described operations you can ensure that all light bulbs are turned on Calculate two numbers the minimum size of the set S that you initially turn on the number of sets S of minimum size taken modulo 998244353 ,"['//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<int,int>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=2e5+5,mod=998244353;\nint gmi[20][2*N],lg[2*N],gma[20][2*N],R[N];\nii pos[N];\nll n,a[2*N],par[N];\nii get (ll l, ll r){\n    ii d;\n    ll g=lg[r-l+1];\n    d.F=min(gmi[g][l],gmi[g][r-(1<<g)+1]);\n    d.S=max(gma[g][l],gma[g][r-(1<<g)+1]);\n    return d;\n}\nll find (ll u){\n    if (u==par[u]) return u;\n    return (par[u]=find(par[u]));\n}\nvoid join (ll u, ll v){\n    ll x=find(u),y=find(v);\n    if (x==y) return;\n    par[x]=y;\n}\nvoid prep(){\n    rep(i,2,2*N-1) lg[i]=lg[i/2]+1;\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) pos[i]={0,0},par[i]=i;\n    rep(i,1,2*n){\n        cin>>a[i];\n        if (pos[a[i]].F==0) pos[a[i]].F=i;\n        else \n        {\n            pos[a[i]].S=i;\n            ll pf=pos[a[i]].F,ps=i;\n            gmi[0][pf]=pf;\n            gmi[0][ps]=pf;\n            gma[0][pf]=ps;\n            gma[0][ps]=ps;\n        }\n    }\n    rep(i,1,19)\n    rep(j,1,2*n) if (j+(1<<i)-1<=2*n) gmi[i][j]=min(gmi[i-1][j],gmi[i-1][j+(1<<(i-1))]);\n    rep(i,1,19)\n    rep(j,1,2*n) if (j+(1<<i)-1<=2*n) gma[i][j]=max(gma[i-1][j],gma[i-1][j+(1<<(i-1))]);\n    rep(i,1,n){\n        ll l=pos[i].F,r=pos[i].S;\n        ii pd=get(l,r);\n        ll x=pd.F,y=pd.S;\n        join(i,a[x]);\n        join(i,a[y]);\n    }\n    sort(pos+1,pos+n+1);\n    ll res=0,mx=0;\n    rep(i,1,n) if (pos[i].F>mx){\n        R[res]=mx;\n        res++;\n        mx=pos[i].S;\n    }\n    else mx=max(mx,(ll)pos[i].S);\n    cout<<res<<"" "";\n    R[res]=2*n;\n    res=1;\n    ll tmp=1;\n    ll cnt=0;\n    rep(i,1,2*n){\n        if (i>R[cnt]){\n            cnt++;\n            (res*=tmp)%=mod;\n            tmp=0;\n        }\n        if (find(a[i])==find(a[R[cnt]])) tmp++;\n    }\n    (res*=tmp)%=mod;\n    cout<<res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']","['brute force', 'combinatorics', 'dfs and similar', 'dp', 'dsu', 'graphs', 'math', 'trees']",2100
https://codeforces.com//contest/334/problem/A,A. Candy Bags,Gerald has younger brothers and their number happens to be even One day he bought candy bags One bag has one candy one bag has two candies one bag has three candies and so on In fact for each integer from to he has exactly one bag with candies Help him give bags of candies to each brother so that all brothers got the same number of candies ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <stack>\n#include <sstream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define FOR(i,a,b)                              for (i=a;i<b;i++)\n#define FORL(i,size)                            for (i=0;i<size;i++)\n#define FORR(i,size)                            for (i=size-1;i>=0;i--)\n#define s(n)                                    scanf(""%d"",&n)\n#define p(n)                                    printf(""%d\\n"",n)\n#define ps(n)                                   printf(""%s\\n"",n)\n#define sd(n)                                   int n;scanf(""%d"",&n)\n#define pb(n)                                   push_back(n)\n#define clr(a)                                  memset(a,0,sizeof(a))\n#define all(c)                                  (c).begin(),(c).end()\n#define mp(a,b)                                 make_pair(a,b)\n#define PI 3.14159265\n\ntypedef vector <int> vi;\ntypedef vector <vi> vvi;\ntypedef vector <string> vst;\ntypedef vector <bool> vb;\ntypedef long long ll;\nint i, j, k;\n\nint main() {\n\n    int T = 1;\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    //T = g_fi.ReadNext();\n    //cin>>T;\n\n    FOR(k, 0, T) {\n        sd(n);\n        FOR(i,0,n*n/2)\n        {\n            if(i && i%(n/2)==0)\n                cout<<endl;\n            cout<<i+1<<"" ""<<n*n-i<<"" "";\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n\n']",['implementation'],1000
https://codeforces.com//contest/1323/problem/B,B. Count Subrectangles,You are given an array a of length n and array b of length m both consisting of only integers 0 and 1 Consider a matrix c of size n times m formed by following rule c i j a i cdot b j i e a i multiplied by b j It s easy to see that c consists of only zeroes and ones too How many of size area k consisting only of ones are there in c A is an intersection of a consecutive subsequent segment of rows and a consecutive subsequent segment of columns I e consider four integers x 1 x 2 y 1 y 2 1 le x 1 le x 2 le n 1 le y 1 le y 2 le m a subrectangle c x 1 dots x 2 y 1 dots y 2 is an intersection of the rows x 1 x 1 1 x 1 2 dots x 2 and the columns y 1 y 1 1 y 1 2 dots y 2 The size area of a subrectangle is the total number of cells in it ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\n\ntypedef pair<int,int>   ii;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int m;  cin >> m;\n    int k;  cin >> k;\n\n    vector<int> row;\n    vector<int> col;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        int x;  cin >> x;\n        if (x)  row.pb(i);\n    }\n    for(int j = 0 ; j < m ; ++j)    {\n        int x;  cin >> x;\n        if (x)  col.pb(j);\n    }\n\n    ll  ans = 0;\n\n    auto cal = [&](int R,int C) {\n        int cnt0 = 0;\n        int cnt1 = 0;\n        for(int i = R - 1 ; i < sz(row) ; ++i)  if (row[i - R + 1] == row[i] - R + 1)   cnt0++;\n        for(int i = C - 1 ; i < sz(col) ; ++i)  if (col[i - C + 1] == col[i] - C + 1)   cnt1++;\n\n        ans += 1ll * cnt0 * cnt1;\n    };\n\n    for(int i = 1 ; i * i <= k ; ++i)   if (k % i == 0) {\n        cal(i,k / i);\n        if (i * i < k)\n            cal(k / i,i);\n    }\n    cout << ans << endl;\n}']","['binary search', 'greedy', 'implementation']",1500
https://codeforces.com//contest/723/problem/A,A. The New Year  Meeting Friends,There are three friend living on the straight line in Lineland The first friend lives at the point the second friend lives at the point and the third friend lives at the point They plan to celebrate the New Year together so they need to meet at one point What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year It s guaranteed that the optimal answer is always integer ,"['#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\nint main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tcout << max(max(a, b), c) - min(min(a, b), c) << endl;\n}\n']","['implementation', 'math', 'sortings']",800
https://codeforces.com//contest/1514/problem/B,"B. AND 0, Sum Big",Baby Badawy s first words were AND 0 SUM BIG so he decided to solve the following problem Given two integers n and k count the number of arrays of length n such that all its elements are integers between 0 and 2 k 1 inclusive the bitwise AND of all its elements is 0 the sum of its elements is as large as possible Since the answer can be very large print its remainder when divided by 10 9 7 ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int mod = 1e9 + 7;\n        int n, k;\n        cin >> n >> k;\n        int z = 1;\n        for (int i = 0; i < k; i++) {\n            z = (z * (long long)n) % mod;\n        }\n        cout << z << '\\n';\n    }\n}""]","['bitmasks', 'combinatorics', 'math']",1200
https://codeforces.com//contest/1282/problem/A,A. Temporarily unavailable,Polycarp lives on the coordinate axis Ox and travels from the point x a to x b It moves uniformly rectilinearly at a speed of one unit of distance per minute On the axis Ox at the point x c the base station of the mobile operator is placed It is known that the radius of its coverage is r Thus if Polycarp is at a distance less than or equal to r from the point x c then he is in the network coverage area otherwise no The base station can be located both on the route of Polycarp and outside it Print the time in minutes during which Polycarp will in the coverage area of the network with a rectilinear uniform movement from x a to x b His speed one unit of distance per minute ,"['#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nll a[MAXN], b[MAXN];\nvector<ll> f;\nvector<ll> g[MAXN];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        ll a, b, c, r;\n        cin >> a >> b >> c >> r;\n        ll l = c - r;\n        r = c + r;\n        if (a > b) {\n            swap(a, b);\n        }\n        ll aa = max(a, l);\n        ll bb = min(b, r);\n        ll diff = max(bb - aa, 0LL);\n        cout << b - a - diff << ""\\n"";\n    }\n\n\n\n    return 0;\n}']","['implementation', 'math']",900
https://codeforces.com//contest/1420/problem/A,A. Cubes Sorting,Wheatley decided to try to make a test chamber He made a nice test chamber but there was only one detail absent cubes For completing the chamber Wheatley needs n cubes i th cube has a volume a i Wheatley has to place cubes in such a way that they would be sorted in a non decreasing order by their volume Formally for each i 1 a i 1 le a i must hold To achieve his goal Wheatley can exchange two cubes It means that for any i 1 you can exchange cubes on positions i 1 and i But there is a problem Wheatley is very impatient If Wheatley needs more than frac n cdot n 1 2 1 exchange operations he won t do this boring work Wheatly wants to know can cubes be sorted under this conditions ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=1e5+5;\nint a[N],n;\nvoid solve(){\n\tscanf(""%d"",&n);\n\tint x=1;\n\trep(i,1,n) scanf(""%d"",a+i);\n\trep(i,1,n-1){\n\t\tif(a[i]<=a[i+1]) x=0;\n\t}\n\tputs(x?""NO"":""YES"");\n}\nint main(){\n\tint T; scanf(""%d"",&T);\n\twhile(T--) solve();\n\treturn 0;\n}\n']","['math', 'sortings']",900
https://codeforces.com//contest/83/problem/A,A. Magical Array,Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written He immediately thought that the numbers in this array were not random As a result of extensive research Valera worked out a wonderful property that a magical array should have an array is defined as magic if its He decided to share this outstanding discovery with you but he asks you for help in return Despite the tremendous intelligence and wit Valera counts very badly and so you will have to complete his work All you have to do is count the number of magical subarrays of the original array of numbers written on the parchment Subarray is defined as ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint a[100000];\nint64 res;\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tres = 0;\n\tscanf (""%d"", &n);\n\tforn (i, n)\n\t\tscanf (""%d"", &a[i]);\n\tint l = 0;\n\twhile (l < n) {\n\t\tint r = l;\n\t\twhile (r + 1 < n && a[r+1] == a[l])\n\t\t\tr ++;\n\t\tint64 d = r - l + 1;\n\t\tres += d * (d + 1) / 2;\n\t\tl = r + 1;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n']",['math'],1300
https://codeforces.com//contest/1382/problem/B,B. Sequential Nim,There are n piles of stones where the i th pile has a i stones Two people play a game where they take alternating turns removing stones In a move a player may remove a positive number of stones from the the pile with the minimal index that has at least one stone The first player who cannot make a move because all piles are empty loses the game If both players play optimally determine the winner of the game ,"['#pragma comment(linker, ""/STACK:10000000000"")\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <set>\n#include <stack>\n#include <vector>\n#include <time.h>\n#include <random>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <complex>\n#define rt return\n#define mp make_pair\n#define endl \'\\n\'\n#define sqr(x) ((x) * (x))\n#define all(x) (x).begin(), (x).end()\n#define rep(x) for (int rep_iter = 0; rep_iter < x; ++rep_iter)\n#define fnd(x, y) (x.find(y) != x.end())\n#define fndv(x, y) (find(all(x), y) != end(x))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<db, db> pdd;\ntypedef unsigned char bt;\ntypedef unsigned int uint;\nconst int MOD = 1000000007;\nconst int INF = 1000000007LL;\nconst ll INF2 = 1LL << 62LL;\nconst long double EPS = 1e-9;\n#ifdef _DEBUG\nconst int SIZE = 120;\n#endif\n#ifndef _DEBUG\nconst int SIZE = 200010; //200010\n#endif\nmt19937 rng(time(0));\nuniform_int_distribution<int> uid(-1000000000, 1000000000);\n\nint flag, u[SIZE], d[SIZE], a[SIZE], n;\n\nint rec(int i) {\n\tif (i == n - 1)\n\t\trt 1;\n\tif (u[i] == flag)\n\t\trt d[i];\n\tu[i] = flag;\n\tif (a[i] == 1) {\n\t\trt d[i] = !rec(i + 1);\n\t}\n\trt d[i] = 1;\n}\n\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tint tt;\n\tcin >> tt;\n\trep(tt) {\n\t\tcin >> n;\n\t\t++flag;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\ta[i] = min(2, a[i]);\n\t\t}\n\t\tif (rec(0))\n\t\t\tcout << ""First"";\n\t\telse\n\t\t\tcout << ""Second"";\n\t\tcout << endl;\n\t}\n\n\n\n\treturn 0;\n}']","['dp', 'games']",1100
https://codeforces.com//contest/1760/problem/E,E. Binary Inversions,You are given a binary array dagger of length n You are allowed to perform one operation on it In an operation you can choose any element and flip it turn a 0 into a 1 or vice versa What is the maximum number of inversions ddagger the array can have after performing operation dagger A binary array is an array that contains only zeroes and ones ddagger The number of inversions in an array is the number of pairs of indices i j such that i j and a i a j ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ios ios::sync_with_stdio(false); cin.tie(NULL);\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define fr first\n#define sc second\n#define int long long\n#define endl \'\\n\'\nvoid fopn(string name){\n  freopen((name+"".in"").c_str(),""r"",stdin);\n  freopen((name+"".out"").c_str(),""w"",stdout);\n}\nconst int INF=1e18,mod=1e9+7;\nint binpow(int a,int b){\n  int cur=1;\n  while(b){\n    if(b&1)\n      cur=(cur*a)%mod;\n    a*=a;\n    a%=mod;\n    b/=2;\n  }\n  return cur;\n}\nint n;\nint cnt(vector<int> vec){\n  int c=0,res=0;\n  for(int i=0;i<n;i++){\n    if(vec[i]) c++;\n    else res+=c;\n  }\n  return res;\n}\nvoid solve(){\n  cin>>n;\n  vector<int> vec(n),tmp;\n  for(int i=0;i<n;i++)\n    cin>>vec[i];\n  tmp=vec;\n  int res=cnt(vec);\n  for(int i=n-1;i>=0;i--)\n    if(tmp[i]==1){\n      tmp[i]=0;\n      break;\n    }\n  res=max(res,cnt(tmp));\n  tmp=vec;\n  for(int i=0;i<n;i++){\n    if(tmp[i]==0){\n      tmp[i]=1;\n      break;\n    }\n  }\n  res=max(res,cnt(tmp));\n  cout<<res<<endl;\n}\nmain(){\n  //fopn(""balance"");\n  ios;\n  int T=1;\n  cin>>T;\n  while(T--){\n    solve();\n  }\n}']","['data structures', 'greedy', 'math']",1100
https://codeforces.com//contest/111/problem/B,B. Petya and Divisors,Little Petya loves looking for numbers divisors One day Petya came across the following problem You are given queries in the form For each query Petya should count how many divisors of number divide none of the numbers Help him ,"['// Authored by dolphinigle\n// CodeForces 83\n// 3 Sep 2011\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define FORN(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define DEBUG(x) cout << \'>\' << #x << \':\' << x << \'\\n\';\n\n#define REP(X,Y,Z) for (int (X) = (Y);(X) < (Z);++(X))\n#define RESET(Z,Y) memset(Z,Y,sizeof(Z))\n\n#define SZ(Z) ((int)Z.size())\n#define ALL(W) W.begin(), W.end()\n#define PB push_back\n\n#define MP make_pair\n#define A first\n#define B second\n\n#define INF 1023123123\n#define EPS 1e-11\n\n#define MX(Z,Y) Z = max((Z),(Y))\n#define MN(X,Y) X = min((X),(Y))\n\n#define FORIT(X,Y) for(typeof((Y).begin()) X = (Y).begin();X!=(Y).end();X++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\n\nvector< ll > GetDivisors(long long number) {\n\tvector<ll> ret;\n\tfor (ll i = 1; i <= ceil(sqrt(number)); ++i) {\n\t\tif (number % i == 0) {\n\t\t\tret.PB(i);\n\t\t\tret.PB(number / i);\n\t\t}\n\t}\n\tsort(ALL(ret));\n\tret.erase(unique(ALL(ret)), ret.end());\n\treturn ret;\n}\n//vector<ll> divs = GetDivisors(6); {1,2,3,6} O(sqrt(N))\n\n\n\nint main() {\n\n  int n;\n  cin >> n;\n  int lastdiv[100500];\n  FORN(i, 100500) lastdiv[i] = -1;\n  FORN(i, n) {\n    int num;\n    int last;\n    scanf(""%d%d"", &num, &last);\n    vector<ll> divisors = GetDivisors(num);\n    int ret = 0;\n    FORN(j, SZ(divisors)) {\n      int d = divisors[j];\n      if (lastdiv[d] >= i-last) {\n      } else {\n        ++ret;\n      }\n      lastdiv[d] = i;\n    }\n    printf(""%d\\n"", ret);\n  }\n\n  return 0;\n}\n']","['binary search', 'data structures', 'number theory']",1900
https://codeforces.com//contest/1800/problem/D,D. Remove Two Letters,Dmitry has a string s consisting of lowercase Latin letters Dmitry decided to remove two characters from the string s and you are wondering how many different strings can be obtained after such an operation For example Dmitry has a string You can get the following different strings by deleting the first two or second and third characters by deleting the third and fourth characters by deleting the fourth and the fifth character and by deleting the last two ,"['// I am teacher of MakaPakka\n// LOUGI_ID:643723\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(x,y) for(int x=0;x<(y);x++)\ninline int in(){\n  int x;\n  cin >> x;\n  return x;\n}\nvoid solve(){\n  int n=in();\n  string s;cin>>s;\n  s=""$""+s+""$"";\n  int ans=0;\n  for(int i=1;i+1<=n;i++){\n    ans+=(s[i-1]!=s[i+1]);\n  }\n  cout<<ans<<""\\n"";\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while(T--) solve();\n}']","['data structures', 'greedy', 'hashing', 'strings']",1200
https://codeforces.com//contest/966/problem/A,A. Stairs and Elevators,In the year of 30XX participants of some world programming championship live in a single large hotel The hotel has n floors Each floor has m sections with a single corridor connecting all of them The sections are enumerated from 1 to m along the corridor and all sections with equal numbers on different floors are located exactly one above the other Thus the hotel can be represented as a rectangle of height n and width m We can denote sections with pairs of integers i j where i is the floor and j is the section number on the floor The guests can walk along the corridor on each floor use stairs and elevators Each stairs or elevator occupies all sections 1 x 2 x ldots n x for some x between 1 and m All sections not occupied with stairs or elevators contain guest rooms It takes one time unit to move between neighboring sections on the same floor or to move one floor up or down using stairs It takes one time unit to move up to v floors in any direction using an elevator You can assume you don t have to wait for an elevator and the time needed to enter or exit an elevator is negligible You are to process q queries Each query is a question what is the minimum time needed to go from a room in section x 1 y 1 to a room in section x 2 y 2 ,"['#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,m,q,na,nb,a[100010],b[100010],v,p;\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,sx,sy,tx,ty;\n\tscanf(""%d%d%d%d%d"",&n,&m,&na,&nb,&v);\n\tfor(i=1;i<=na;i++)\n\t  scanf(""%d"",&a[i]);\n\tfor(i=1;i<=nb;i++)\n\t  scanf(""%d"",&b[i]);\n\tsort(a+1,a+na+1);\n\tsort(b+1,b+nb+1);\n\tscanf(""%d"",&q);\n\twhile(q--)\n\t  {\n       scanf(""%d%d%d%d"",&sx,&sy,&tx,&ty);\n       p=1e9;\n       if(na)\n         {\n          i=lower_bound(a+1,a+na+1,sy)-a;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n          i--;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n         }\n       if(nb)\n         {\n          i=lower_bound(b+1,b+nb+1,sy)-b;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n          i--;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n         }\n       if(sx==tx)\n         p=abs(ty-sy);\n       printf(""%d\\n"",p);\n      }\n\treturn 0;\n}\n']","['binary search', 'data structures', 'greedy']",1600
https://codeforces.com//contest/1559/problem/D1,D1. Mocha and Diana  Easy Version ,A forest is an undirected graph without cycles not necessarily connected Mocha and Diana are friends in Zhijiang both of them have a forest with nodes numbered from 1 to n and they would like to add edges to their forests such that After adding edges both of their graphs are still forests They add the same edges That is if an edge u v is added to Mocha s forest then an edge u v is added to Diana s forest and vice versa Mocha and Diana want to know the maximum number of edges they can add and which edges to add ,"['#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,ssse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#include <bits/stdc++.h>\n//#define int long long\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define dwn(i, a, b) for(int i = a; i >= b; i--)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nconst int INF = 0x3f3f3f3f;\nconst int NINF = -INF - 1;\nconst int N = 1e3 + 10;\nconst int mod = 1e9+7;\nint n, m1, m2, fa[2][N];\nvoid init(int m) { rep(i, 1, m) fa[0][i] = fa[1][i] = i; }\nint get(int i, int x) { return fa[i][x] == x ? x : fa[i][x] = get(i, fa[i][x]); }\nint solve() {\n    std::vector< std::pair<int, int> > ans;\n    rep(i, 1, n) {\n        rep(j, i+1, n) {\n            if(get(0, i) != get(0, j) && get(1, i) != get(1, j)) {\n                fa[0][get(0, i)] = get(0, j);\n                fa[1][get(1, i)] = get(1, j);\n                ans.eb(i, j);\n            }\n        }\n    }\n    std::cout << ans.size() <<std::endl;\n    for(auto x : ans) std::cout << x.fi << "" "" << x.se << std::endl;\n    return 0;\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n >> m1 >> m2;\n    init(n);\n    rep(i, 1, m1) {\n        int u, v; std::cin >> u >> v;\n        fa[0][get(0, u)] = get(0, v);\n    }\n    rep(i, 1, m2) {\n        int u, v; std::cin >> u >> v;\n        fa[1][get(1, u)] = get(1, v);\n    }\n    return solve();\n}']","['brute force', 'constructive algorithms', 'dsu', 'graphs', 'greedy', 'trees']",1400
https://codeforces.com//contest/1553/problem/I,I. Stairs,For a permutation p of numbers 1 through n we define a a as follows a i is length of the longest segment of permutation which contains position i and is made of consecutive values in sorted order x x 1 ldots y 1 y or y y 1 ldots x 1 x for some x leq y For example for permutation p 4 1 2 3 7 6 5 we have a 1 3 3 3 3 3 3 You are given the stair array a Your task is to calculate the number of permutations which have stair array equal to a Since the number can be big compute it modulo 998 244 353 Note that this number can be equal to zero ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$. \n \t* For XOR convolution ignore \\texttt{m} within \\texttt{fft}. \n * Time: O(N\\log N)\n * Source: \n \t* KACTL (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n \t* https://cp-algorithms.com/algebra/fft.html\n \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n \t* maroonrk\n \t* https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp\n * Verification: \n\t* https://judge.yosupo.jp/problem/convolution_mod\n\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding\n\t* http://codeforces.com/contest/632/problem/E\n */\n\n// #include ""ModInt.h""\n// const int MOD = 998244353;\n\ntemplate<class T> void fft(V<T>& A, bool inv = 0) { // NTT\n\tint n = sz(A); assert((T::mod-1)%n == 0); V<T> B(n);\n\tfor(int b = n/2; b; b /= 2, swap(A,B)) {\n\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1; // n/b\'th root of unity\n\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {\n\t\t\tT u = A[i+j], v = A[i+j+b]*m;\n\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;\n\t\t}\n\t}\n\tif (inv) { reverse(1+all(A)); \n\t\tT z = T(1)/T(n); each(t,A) t *= z; }\n}\ntemplate<class T> V<T> mul(V<T> A, V<T> B) { // only special moduli for NTT\n\tif (!min(sz(A),sz(B))) return {};\n\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);\n\tbool eq = A == B; A.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i,n) A[i] *= B[i];\n\tfft(A,1); A.rsz(s); return A;\n}\ntemplate<class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T>& v) {\n\t\tV<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];\n\t\treturn w; };\n\treturn mul(con(x),con(y));\n}\ntemplate<class T> V<T> MUL(const V<T>& A, const V<T>& B) { // arbitrary moduli\n\tusing m0 = mint<(119<<23)+1,62>; auto c0 = mulMod<m0>(A,B);\n\tusing m1 = mint<(5<<25)+1,  62>; auto c1 = mulMod<m1>(A,B);\n\tusing m2 = mint<(7<<26)+1,  62>; auto c2 = mulMod<m2>(A,B);\n\tint n = sz(c0); V<T> res(n);\n\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);\n\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;\n\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod\n\t}\n\treturn res;\n}\n\n/**\n * Description: Basic poly ops including division. Can replace \\texttt{T} with double, complex.\n * Source: Own. Also see\n\t* https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/PolyInterpolate.h\n\t* https://github.com/ecnerwala/icpc-book/blob/master/content/numerical/fft.cpp\n * Verification: see FFT\n */\n\n// #include ""../../number-theory (11.1)/Modular Arithmetic/ModInt.h""\n\nusing T = mi; using poly = V<T>;\nvoid remz(poly& p) { while (sz(p)&&p.bk==T(0)) p.pop_back(); }\npoly REMZ(poly p) { remz(p); return p; }\npoly rev(poly p) { reverse(all(p)); return p; }\npoly shift(poly p, int x) { \n\tif (x >= 0) p.insert(begin(p),x,0); \n\telse assert(sz(p)+x >= 0), p.erase(begin(p),begin(p)-x);\n\treturn p; \n}\npoly RSZ(const poly& p, int x) { \n\tif (x <= sz(p)) return poly(begin(p),begin(p)+x);\n\tpoly q = p; q.rsz(x); return q;  }\nT eval(const poly& p, T x) { // evaluate at point x\n\tT res = 0; R0F(i,sz(p)) res = x*res+p[i]; \n\treturn res; }\npoly dif(const poly& p) { // differentiate\n\tpoly res; FOR(i,1,sz(p)) res.pb(T(i)*p[i]); \n\treturn res; }\npoly integ(const poly& p) { // integratepoly integ(const poly& p) { // integrate\n\tstatic poly invs{0,1};\n\tfor (int i = sz(invs); i <= sz(p); ++i) \n\t\tinvs.pb(-MOD/i*invs[MOD%i]);\n\tpoly res(sz(p)+1); F0R(i,sz(p)) res[i+1] = p[i]*invs[i+1];\n\treturn res; \n}\n\npoly& operator+=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] += r[i]; \n\treturn l; }\npoly& operator-=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] -= r[i]; \n\treturn l; }\npoly& operator*=(poly& l, const T& r) { each(t,l) t *= r; \n\treturn l;\t }\npoly& operator/=(poly& l, const T& r) { each(t,l) t /= r; \n\treturn l; }\npoly operator+(poly l, const poly& r) { return l += r; }\npoly operator-(poly l, const poly& r) { return l -= r; }\npoly operator-(poly l) { each(t,l) t *= -1; return l; }\npoly operator*(poly l, const T& r) { return l *= r; }\npoly operator*(const T& r, const poly& l) { return l*r; }\npoly operator/(poly l, const T& r) { return l /= r;\t }\npoly operator*(const poly& l, const poly& r) {\n\tif (!min(sz(l),sz(r))) return {};\n\tpoly x(sz(l)+sz(r)-1); \n\tF0R(i,sz(l)) F0R(j,sz(r)) x[i+j] += l[i]*r[j];\n\treturn x;\n}\npoly& operator*=(poly& l, const poly& r) { return l = l*r; }\n\npair<poly,poly> quoRem(poly a, poly b) { \n\tremz(a); remz(b); assert(sz(b));\n\tT lst = b.bk, B = T(1)/lst; each(t,a) t *= B; \n\teach(t,b) t *= B;\n\tpoly q(max(sz(a)-sz(b)+1,0));\n\tfor (int dif; (dif=sz(a)-sz(b)) >= 0; remz(a)) {\n\t\tq[dif] = a.bk; F0R(i,sz(b)) a[i+dif] -= q[dif]*b[i]; }\n\teach(t,a) t *= lst;\n\treturn {q,a}; // quotient, remainder\n}\npoly operator/(const poly& a, const poly& b) { return quoRem(a,b).f; }\npoly operator%(const poly& a, const poly& b) { return quoRem(a,b).s; }\n/**poly a = {1,3,5,8,6,0,0,0,0}, b = {1,5,1};\nps(quoRem(a,b)); a = 2*a, b = 2*b; ps(quoRem(a,b));*/\npoly gcd(poly a, poly b) { return b == poly{} ? a : gcd(b,a%b); }\nT resultant(poly a, poly b) { // R(A,B)\n\t// =b_m^n*prod_{j=1}^mA(mu_j)\n\t// =b_m^na_m^n*prod_{i=1}^nprod_{j=1}^m(mu_j-lambda_i)\n\t// =(-1)^{mn}a_n^m*prod_{i=1}^nB(lambda_i)\n\t// =(-1)^{nm}R(B,A)\n\t// Also, R(A,B)=b_m^{deg(A)-deg(A-CB)}R(A-CB,B)\n\tint ad = sz(a)-1, bd = sz(b)-1; \n\tif (bd <= 0) return bd < 0 ? 0 : pow(b.bk,ad);\n\tint pw = ad; a = a%b; pw -= (ad = sz(a)-1);\n\treturn resultant(b,a)*pow(b.bk,pw)*T((bd&ad&1)?-1:1);\n}\n\n/**\n * Description: Multiply small polys directly, otherwise use FFT.\n * Source: KACTL, https://cp-algorithms.com/algebra/fft.html\n */\n\n// #include ""Poly.h""\n// #include ""FFT.h""\n\nbool small(const poly& a, const poly& b) { // multiply directly\n\treturn min(sz(a),sz(b)) <= 60; }\n// vmi smart(const vmi& a, const vmi& b) { return mul(a,b); }\n// vl smart(const vl& a, const vl& b) {\n// \tauto X = mul(vcd(all(a)),vcd(all(b)));\n// \tvl x(sz(X)); F0R(i,sz(X)) x[i] = round(X[i].real());\n// \treturn x; }\npoly conv(const poly& a, const poly& b) {\n\treturn small(a,b) ? a*b : mul(a,b); } \n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvmi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = mi(-(ll)MOD/i*(int)invs[MOD%i]);\n\tFOR(i,1,SZ) {\n\t\tfac[i] = fac[i-1]*i;\n\t\tifac[i] = ifac[i-1]*invs[i];\n\t}\n}\nmi comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn fac[a]*ifac[b]*ifac[a-b];\n}\n\nvoid fassert(bool b) {\n\tif (!b) {\n\t\tps(0);\n\t\texit(0);\n\t}\n}\n\nvmi stor[100005][2][2];\n\nconst mi i2 = (MOD+1)/2;\nvmi calc(int len, int l, int r) {\n\tif (l > r) swap(l,r);\n\tif (sz(stor[len][l][r])) return stor[len][l][r];\n\tif (len == 0) return stor[len][l][r] = {1};\n\tif (len == 1) return stor[len][l][r] = {1,pow(mi(2),2-l-r)*i2};\n\tif (len == 2) return stor[len][l][r] = {1,4-l-r,pow(mi(2),2-l-r)*i2};\n\tF0R(i,2) {\n\t\tvmi a = calc((len-1)/2,l,i);\n\t\tvmi b = calc(len/2,i,r);\n\t\tvmi res = conv(a,b);\n\t\tif (i == 1) {\n\t\t\tres *= 2;\n\t\t\tres.ins(begin(res),0);\n\t\t}\n\t\tstor[len][l][r] += res;\n\t}\n\treturn stor[len][l][r];\n}\n\nvmi conv_all(const V<vmi>& v, int l, int r) {\n\tif (l == r) return {1};\n\tif (l+1 == r) return v[l];\n\tint m = (l+r)/2;\n\treturn conv(conv_all(v,l,m),conv_all(v,m,r));\n}\n\nstruct Dat {\n\tvmi v;\n\tDat(vmi _v):v(_v){}\n\tfriend bool operator<(const Dat& x, const Dat& y) {\n\t\treturn sz(x.v) > sz(y.v);\n\t}\n};\n\nint main() {\n\tsetIO();\n\tvi segs;\n\tints(N); vi A(N); re(A);\n\tgenFac(N+2);\n\tfor (int i = 0; i < N; ) {\n\t\tint lef = min(N-i,A[i]);\n\t\tvi v; rep(lef) v.pb(A[i++]);\n\t\tfassert(sz(v) == v.ft);\n\t\teach(t,v) fassert(t == v[0]);\n\t\tif (sz(v) > 1) segs.pb(2);\n\t\telse segs.pb(1);\n\t}\n\tV<vmi> all_conv;\n\tpriority_queue<Dat> pq;\n\tfor (int l = 0; l < sz(segs); ++l) {\n\t\tif (segs[l] != 1) continue;\n\t\tint r = l; while (r+1 < sz(segs) && segs[r+1] == 1) ++r;\n\t\tvmi v = calc(r-l + (l != 0) + (r != sz(segs)-1), l != 0, r != sz(segs)-1);\n\t\tl = r;\n\t\tpq.push(Dat(v));\n\t}\n\tint pairs = 0;\n\tF0R(l,sz(segs)-1) if (segs[l] != 1 && segs[l+1] != 1) ++pairs;\n\tvmi tmp(pairs+1);\n\tmi cur_term = 1;\n\tF0R(i,sz(tmp)) {\n\t\ttmp[i] = comb(pairs,i)*cur_term;\n\t\tcur_term *= i2;\n\t}\n\tpq.push(Dat(tmp));\n\twhile (sz(pq) > 1) {\n\t\tDat a = pq.top(); pq.pop();\n\t\tDat b = pq.top(); pq.pop();\n\t\tpq.push(Dat(conv(a.v,b.v)));\n\t}\n\n\t// all_conv.pb(tmp);\n\t// // dbg(""GOT ALL CONV"",all_conv);\n\t// vmi res = conv_all(all_conv,0,sz(all_conv));\n\tmi ans;\n\tvmi res = pq.top().v;\n\tF0R(i,sz(res)) {\n\t\tres[i] *= fac[sz(segs)-i];\n\t\tif (i&1) ans -= res[i];\n\t\telse ans += res[i];\n\t}\n\teach(t,segs) if (t == 2) ans *= 2;\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['combinatorics', 'divide and conquer', 'dp', 'fft', 'math']",3400
https://codeforces.com//contest/288/problem/A,A. Polo the Penguin and Strings,Little penguin Polo adores strings But most of all he adores strings of length One day he wanted to find a string that meets the following conditions The string consists of lowercase English letters that is the string s length equals exactly of these letters are distinct No two neighbouring letters of a string coincide that is if we represent a string as then the following inequality holds Among all strings that meet points 1 and 2 the required string is lexicographically smallest Help him find such string or state that such string doesn t exist String is than string if either and or there is such number that and The characters of the strings are compared by their ASCII codes ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 1000010\nint n,m;char s[N];\nint main()\n{\n    scanf(""%d%d"",&n,&m);\n    if(m==1)\n    {\n        if(n==1)puts(""a"");else puts(""-1"");\n        return 0;\n    }\n    if(n<m){puts(""-1"");return 0;}\n    for(int i=0;i<n;i++)s[i]=\'a\'+(i&1);\n    for(int i=m-1;i>=2;i--)\n        s[n-1-(m-1-i)]=\'a\'+i;\n    puts(s);\n    return 0;\n}']",['greedy'],1300
https://codeforces.com//contest/148/problem/C,C. Terse princess,Next please the princess called and cast an estimating glance at the next groom The princess intends to choose the most worthy groom this is the richest one Whenever she sees a groom who is more rich than each of the previous ones she says a measured Oh Whenever the groom is richer than all previous ones added together she exclaims Wow no Oh in this case At the sight of the first groom the princess stays calm and says nothing The fortune of each groom is described with an integer between 1 and 50000 You know that during the day the princess saw grooms said Oh exactly times and exclaimed Wow exactly times Your task is to output a sequence of integers where describes the fortune of th groom If several sequences are possible output any of them If no sequence exists that would satisfy all the requirements output a single number ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\nint n,a,b;\n\nint main(){\n    //freopen(""1.txt"",""r"",stdin);\n    //freopen(""2.txt"",""w"",stdout);\n    scanf(""%d%d%d"",&n,&a,&b);\n    if (b)\n    {\n       for (int i=0;i<=b;i++) printf(""%d "",1<<i);\n       for (int i=1;i<=a;i++) printf(""%d "",(1<<b)+i);\n       for (int i=n-1-a-b;i>=1;--i) printf(""1 "");\n    }\n    else\n    if (a)\n    {\n       if (n==a+1) \n       {\n          printf(""-1\\n"");\n          return 0;\n       }\n       printf(""1 1 "");\n       for (int i=1;i<=a;i++) printf(""%d "",1+i);\n       for (int i=n-a-2;i>=1;--i) printf(""1 "");\n    }\n    else\n       for (int i=1;i<=n;i++) printf(""1 "");    \n}\n']","['constructive algorithms', 'greedy']",1700
https://codeforces.com//contest/1162/problem/B,B. Double Matrix,You are given n times m matrices containing integers A sequence of integers is strictly increasing if each next number is greater than the previous one A row is strictly increasing if all numbers from left to right are strictly increasing A column is strictly increasing if all numbers from top to bottom are strictly increasing A matrix is increasing if all rows are strictly increasing all columns are strictly increasing For example the matrix begin bmatrix 9 10 11 11 12 14 end bmatrix is increasing because each individual row and column is strictly increasing On the other hand the matrix begin bmatrix 1 1 2 3 end bmatrix is not increasing because the first row is not strictly increasing Let a position in the i th row from top and j th column from left in a matrix be denoted as i j In one operation you can choose any two numbers i and j and swap the number located in i j in the first matrix with the number in i j in the second matrix In other words you can swap two numbers in different matrices if they are located in the corresponding positions You would like to make both matrices increasing by performing some number of operations possibly none Determine if it is possible to do this If it is print otherwise print ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, M;\n    scanf(""%d%d"", &N, &M);\n    vector<vector<int> > A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n        A[i].resize(M);\n        for (int j = 0; j < M; ++j) {\n            scanf(""%d"", &A[i][j]);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        B[i].resize(M);\n        for (int j = 0; j < M; ++j) {\n            scanf(""%d"", &B[i][j]);\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (i < N - 1 && (min(A[i][j], B[i][j]) >= min(A[i+1][j], B[i+1][j]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n            if (i < N - 1 && (max(A[i][j], B[i][j]) >= max(A[i+1][j], B[i+1][j]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n            if (j < M - 1 && (min(A[i][j], B[i][j]) >= min(A[i][j+1], B[i][j+1]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n            if (j < M - 1 && (max(A[i][j], B[i][j]) >= max(A[i][j+1], B[i][j+1]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n        }\n    }\n    printf(""Possible\\n"");\n    return 0;\n}\n']","['brute force', 'greedy']",1400
https://codeforces.com//contest/1209/problem/G1,G1. Into Blocks  easy version , A sequence of integers is called if its elements are arranged in blocks like in 3 3 3 4 1 1 Formally if two elements are equal everything in between must also be equal Let s define of a sequence as a minimum possible number of elements to change to get a nice sequence However if you change at least one element of value x to value y you must also change all other elements of value x into y as well For example for 3 3 1 3 2 1 2 it isn t allowed to change first 1 to 3 and second 1 to 2 You need to leave 1 s untouched or change them to the same value You are given a sequence of integers a 1 a 2 ldots a n and q updates Each update is of form i x change a i to x Updates are not independent the change stays for the future Print the difficulty of the initial sequence and of the sequence after every update ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000,M=200000;\nint n,l[N],r[N],cnt[N],gor[N],a[N],f[N],ans;\n\nint main() {\n\tscanf(""%d%*d"",&n);\n\trep(i,1,M+1) l[i]=n+1,r[i]=0;\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",a+i);\n\t\tl[a[i]]=min(l[a[i]],i);\n\t\tr[a[i]]=max(r[a[i]],i);\n\t\tcnt[a[i]]++;\n\t}\n\trep(i,1,n+1) gor[i]=r[a[i]];\n\tint p=1;\n\twhile (p<=n) {\n\t\tint mr=gor[p];\n\t\tint md=0;\n\t\twhile (p<=mr) {\n\t\t\tmd=max(md,cnt[a[p]]);\n\t\t\tmr=max(mr,gor[p]);\n\t\t\tp++;\n\t\t}\n\t\tans+=md;\n\t}\n\tprintf(""%d\\n"",n-ans);\n}\n']","['data structures', 'dsu', 'greedy', 'implementation', 'two pointers']",2000
https://codeforces.com//contest/1889/problem/B,B. Doremy s Connecting Plan,Doremy lives in a country consisting of n cities numbered from 1 to n with a i people living in the i th city It can be modeled as an undirected graph with n nodes Initially there are no edges in the graph Now Doremy wants to make the graph To do this she can add an edge between i and j if sum k in S a k ge i cdot j cdot c where S is the set of all the nodes that are currently in the same connected component of either i or j and c is a given constant Can Doremy make the graph connected Two nodes i j are in the same connected component if there exists a path from i to j A graph is connected if all its nodes are in the same connected component ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tdef(int, N, C);\n\tvl A(N + 1);\n\tFOR(i, 1, N + 1) re(A[i]);\n\tvpl thresh;\n\tFOR(i, 2, N + 1) { thresh.pb({(ll)i * C - A[i], A[i]}); }\n\tsor(thresh);\n\tll sum1 = A[1];\n\tfor (auto [x, y] : thresh) {\n\t\tif (sum1 < x) {\n\t\t\tps(""NO"");\n\t\t\treturn;\n\t\t}\n\t\tsum1 += y;\n\t}\n\tps(""YES"");\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['constructive algorithms', 'greedy', 'math', 'sortings']",1700
https://codeforces.com//contest/1487/problem/B,B. Cat Cycle,Suppose you are living with two cats A and B There are n napping spots where both cats usually sleep Your cats like to sleep and also like all these spots so they change napping spot each hour cyclically Cat A changes its napping place in order n n 1 n 2 dots 3 2 1 n n 1 dots In other words at the first hour it s on the spot n and then goes in decreasing order cyclically Cat B changes its napping place in order 1 2 3 dots n 1 n 1 2 dots In other words at the first hour it s on the spot 1 and then goes in increasing order cyclically The cat B is much younger so they have a strict hierarchy A and B don t lie together In other words if both cats d like to go in spot x then the A takes this place and B moves to the next place in its order if x n then to x 1 but if x n then to 1 Cat B follows his order so Calculate where cat B will be at hour k ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    ll N, K; cin >> N >> K;\n    if (N % 2 == 0) {\n        ll ans = K%N; if (ans == 0) ans = N;\n        cout << ans << nl;\n        return;\n    }\n    ll skip = (K - 1) / (N/2);\n    ll ans = (K+skip)%N; if (ans == 0) ans = N;\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['math', 'number theory']",1200
https://codeforces.com//contest/670/problem/B,B. Game of Robots,In late autumn evening robots gathered in the cheerful company of friends Each robot has a unique identifier an integer from to At some moment robots decided to play the game Snowball Below there are the rules of this game First all robots stand in a row Then the first robot says his identifier After that the second robot says the identifier of the first robot and then says his own identifier Then the third robot says the identifier of the first robot then says the identifier of the second robot and after that says his own This process continues from left to right until the th robot says his identifier Your task is to determine the th identifier to be pronounced ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nint main() {\n\n   // freopen(""input.txt"", ""r"", stdin);\n //   freopen(""output.txt"", ""w"", stdout);\n\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector <int> a(n);\n    for (int i =0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    int i = 0;\n    while(k - (i + 1) > 0) {\n        k -= i + 1;\n        i++;\n    }\n    cout << a[k - 1] << \'\\n\';\n    return 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/1688/problem/C,C. Manipulating History,As a human she can erase history of its entirety As a she can create history out of nothingness Keine has the ability to manipulate history The history of Gensokyo is a string s To fix the chaos caused by Yukari she needs to do the following operations n times for the i th time She chooses a t 2i 1 of s She replaces t 2i 1 with a string t 2i Note that the lengths of strings t 2i 1 and t 2i can be different Note that if t 2i 1 occurs more than once in s of them will be replaced For example let s t 2i 1 and t 2i After the operation s becomes or After n operations Keine got the final string and an operation sequence t of length 2n Just as Keine thinks she has finished Yukari appears again and shuffles the order of t Worse still Keine forgets the initial history Help Keine find the initial history of Gensokyo Recall that a substring is a sequence of consecutive characters of the string For example for string its substrings are and some others But the following strings are not its substring You cannot make hacks in this problem ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline void solve()\n{\n  int n; cin >> n; // the number of operations\n  vector<int> cnt(26);\n  vector<string> s(n * 2 + 1);\n  for (int i = 0; i < n * 2 + 1; i ++)\n  {\n    cin >> s[i];\n    for (char ch : s[i])\n      cnt[ch - 'a'] ^= 1;\n  }\n  for (int i = 0; i < 26; i ++)\n    if (cnt[i])\n      cout << char(i + 'a') << '\\n';\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}""]","['constructive algorithms', 'greedy', 'strings']",1700
https://codeforces.com//contest/785/problem/D,D. Anton and School - 2,As you probably know Anton goes to school One of the school subjects that Anton studies is Bracketology On the Bracketology lessons students usually learn different sequences that consist of round brackets characters and without quotes On the last lesson Anton learned about the regular simple bracket sequences RSBS A bracket sequence of length is an RSBS if the following conditions are met It is not empty that is The length of the sequence is even First charactes of the sequence are equal to Last charactes of the sequence are equal to For example the sequence is an RSBS but the sequences and are not RSBS Elena Ivanovna Anton s teacher gave him the following task as a homework Given a bracket sequence Find the number of its distinct subsequences such that they are RSBS Note that a subsequence of is a string that can be obtained from by deleting some of its elements Two subsequences are considered distinct if distinct sets of positions are deleted Because the answer can be very big and Anton s teacher doesn t like big numbers she asks Anton to find the answer modulo Anton thought of this task for a very long time but he still doesn t know how to solve it Help Anton to solve this task and write a program that finds the answer for it ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst LL md=1000000007LL;\nconst int MX=400111;\nLL fac[MX],facinv[MX],inv[MX];\ninline LL C(LL x,LL y){\n\treturn fac[x]*facinv[y]%md*facinv[x-y]%md;\n}\nvoid ini(){\n\tfac[0]=1LL,facinv[0]=1LL;\n\tinv[1]=1LL;\n\tfor(LL i=2;i<=400000;i++)inv[i]=(md-md/i)*inv[md%i]%md;\n\tfor(LL i=1;i<=400000;i++)fac[i]=fac[i-1]*i%md;\n\tfor(LL i=1;i<=400000;i++)facinv[i]=facinv[i-1]*inv[i]%md;\n}\nchar s[MX];\nint n;LL lc,rc;\nint main(){\n\tini();\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\tfor(int i=0;i<n;i++)if(s[i]==\'(\')lc++;else rc++;\n\tLL tx=0LL,ty=rc,ans=0LL;\n\tfor(LL i=0;i<n;i++){\n\t\tif(!ty)break;\n\t\tif(s[i]==\'(\'){\n\t\t\ttx++;ans=(ans+C(tx+ty-1,ty-1))%md;\n\t\t}else ty--;\n\t}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math', 'number theory']",2300
https://codeforces.com//contest/1503/problem/F,F. Balance the Cards,A balanced bracket sequence is defined as an integer sequence that can be built with the following rules The empty sequence is balanced If a 1 ldots a n and b 1 ldots b m are balanced then their concatenation a 1 ldots a n b 1 ldots b m is balanced If x is a positive integer and a 1 ldots a n is balanced then x a 1 ldots a n x is balanced The positive numbers can be imagined as opening brackets and the negative numbers as closing brackets where matching brackets must have the same type absolute value For example 1 2 2 1 and 1 3 3 2 2 1 are balanced but 1 2 1 2 and 1 1 are not balanced There are 2n cards Each card has a number on the front and a number on the back Each integer 1 1 2 2 ldots n n appears exactly once on the front of some card and exactly once on the back of some not necessarily the same card You can reorder the cards however you like You are allowed to flip cards so numbers cannot move between the front and back Your task is to order the cards so that the sequences given by the front numbers and the back numbers are both balanced or report that it is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n;\n\tcin >> n;\n\tn *= 2;\n\tvector<vector<int> > card(n, vector<int>(2));\n\tvector<map<int,int> > idx(2);\n\tauto sgn = [&](int a) -> int {\n\t\treturn a / abs(a);\n\t};\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> card[i][0] >> card[i][1];\n\t\tidx[0][card[i][0]] = i;\n\t\tidx[1][card[i][1]] = i;\n\t}\n\tvector<vector<int> > ocard = card;\n\tset<int> exists;\n\tfor(int i = 0; i < n; i++) exists.insert(i);\n\tvector<vector<int> > ins(n);\n\tauto check = [&](int v) -> int {\n\t\tif(!exists.count(v)) return -1;\n\t\tint a = card[v][0];\n\t\tint b = card[v][1];\n\t\tassert(idx[0].count(-a));\n\t\tassert(idx[1].count(-b));\n\t\tif(sgn(a) != sgn(b)){\n\t\t\tint p, q;\n\t\t\tif(sgn(a) == -1){\n\t\t\t\tp = idx[0][-a];\n\t\t\t\tq = idx[1][-b];\n\t\t\t} else {\n\t\t\t\tp = idx[1][-b];\n\t\t\t\tq = idx[0][-a];\n\t\t\t}\n\t\t\tins[p].push_back(v);\n\t\t\tins[p].push_back(q);\n\t\t\tins.push_back({p, v, q});\n\t\t\tfor(int x : {p, v, q}){\n\t\t\t\tidx[0].erase(card[x][0]);\n\t\t\t\tidx[1].erase(card[x][1]);\n\t\t\t}\n\t\t\texists.erase(v);\n\t\t\texists.erase(q);\n\t\t\tif(sgn(a) == -1){\n\t\t\t\tcard[p][0] = card[q][0];\n\t\t\t} else {\n\t\t\t\tcard[p][1] = card[q][1];\n\t\t\t}\n\t\t\tidx[0][card[p][0]] = p;\n\t\t\tidx[1][card[p][1]] = p;\n\t\t\treturn p;\n\t\t}\n\t\treturn -1;\n\t};\n\tvector<int> b;\n\tfor(int i = 0; i < n; i++) b.push_back(i);\n\tint s = 0;\n\twhile(s < (int)b.size()){\n\t\tint v = b[s];\n\t\ts++;\n\t\tint k = check(v);\n\t\tif(k >= 0) b.push_back(k);\n\t}\n\tvector<int> ans;\n\tfor(int i = 0; i < n; i++){\n\t\tif(exists.count(i)){\n\t\t\tassert(sgn(card[i][0]) == sgn(card[i][1]));\n\t\t\tif(sgn(card[i][0]) == -1) continue;\n\t\t\tint v = idx[0][-card[i][0]];\n\t\t\tint w = idx[1][-card[i][1]];\n\t\t\tif(v != w){\n\t\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\texists.erase(i);\n\t\t\texists.erase(v);\n\t\t\tauto add_vals = y_combinator(\n\t\t\t\t[&](auto self, int x) -> void {\n\t\t\t\t\tans.push_back(x);\n\t\t\t\t\tfor(int y : ins[x]){\n\t\t\t\t\t\tself(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tadd_vals(i);\n\t\t\tadd_vals(v);\n\t\t}\n\t}\n\tvector<vector<int> > seq(2);\n\tfor(int p : ans){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tif(!seq[j].empty() && seq[j].back() > 0 && seq[j].back() == -ocard[p][j]){\n\t\t\t\tseq[j].pop_back();\n\t\t\t} else {\n\t\t\t\tseq[j].push_back(ocard[p][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif((int)ans.size() == n && seq[0].empty() && seq[1].empty()){\n\t\tcout << ""YES"" << \'\\n\';\n\t\tfor(int p : ans){\n\t\t\tcout << ocard[p][0] << \' \' << ocard[p][1] << \'\\n\';\n\t\t}\n\t} else {\n\t\tcout << ""NO"" << \'\\n\';\n\t}\n}']","['constructive algorithms', 'data structures', 'divide and conquer', 'geometry', 'graphs', 'implementation']",3500
https://codeforces.com//contest/1340/problem/F,F. Nastya and CBS,A string s is given It consists of k kinds of pairs of brackets Each bracket has the form t it is an integer such that 1 leq t leq k If the bracket has a form t then If t 0 then it s an opening bracket of the type t If t 0 then it s a closing bracket of the type t Thus there are k types of pairs of brackets in total The queries need to be answered Replace the bracket at position i with the bracket of the form t Check if the substring from the l th to r th position including is the correct bracket sequence Recall the definition of the correct bracket sequence An empty sequence is correct If A and B are two correct bracket sequences then their concatenation A B is also correct bracket sequence If A is the correct bracket sequence c 1 leq c leq k is a type of brackets then the sequence c A c is also correct bracket sequence ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename U, typename V> struct pairnum {\n\tU u;\n\tV v;\n\n\tpairnum() : u(0), v(0) {}\n\tpairnum(long long val) : u(val), v(val) {}\n\tpairnum(const U& u_, const V& v_) : u(u_), v(v_) {}\n\n\tfriend std::ostream& operator << (std::ostream& out, const pairnum& n) { return out << \'(\' << n.u << \',\' << \' \' << n.v << \')\'; }\n\tfriend std::istream& operator >> (std::istream& in, pairnum& n) { long long val; in >> val; n = pairnum(val); return in; }\n\n\tfriend bool operator == (const pairnum& a, const pairnum& b) { return a.u == b.u && a.v == b.v; }\n\tfriend bool operator != (const pairnum& a, const pairnum& b) { return a.u != b.u || a.v != b.v; }\n\n\tpairnum inv() const {\n\t\treturn pairnum(u.inv(), v.inv());\n\t}\n\tpairnum neg() const {\n\t\treturn pairnum(u.neg(), v.neg());\n\t}\n\tpairnum operator- () const {\n\t\treturn pairnum(-u, -v);\n\t}\n\tpairnum operator+ () const {\n\t\treturn pairnum(+u, +v);\n\t}\n\n\tpairnum& operator ++ () {\n\t\t++u, ++v;\n\t\treturn *this;\n\t}\n\tpairnum& operator -- () {\n\t\t--u, --v;\n\t\treturn *this;\n\t}\n\n\tpairnum& operator += (const pairnum& o) {\n\t\tu += o.u;\n\t\tv += o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator -= (const pairnum& o) {\n\t\tu -= o.u;\n\t\tv -= o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator *= (const pairnum& o) {\n\t\tu *= o.u;\n\t\tv *= o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator /= (const pairnum& o) {\n\t\tu /= o.u;\n\t\tv /= o.v;\n\t\treturn *this;\n\t}\n\n\tfriend pairnum operator ++ (pairnum& a, int) { pairnum r = a; ++a; return r; }\n\tfriend pairnum operator -- (pairnum& a, int) { pairnum r = a; --a; return r; }\n\tfriend pairnum operator + (const pairnum& a, const pairnum& b) { return pairnum(a) += b; }\n\tfriend pairnum operator - (const pairnum& a, const pairnum& b) { return pairnum(a) -= b; }\n\tfriend pairnum operator * (const pairnum& a, const pairnum& b) { return pairnum(a) *= b; }\n\tfriend pairnum operator / (const pairnum& a, const pairnum& b) { return pairnum(a) /= b; }\n};\n\nusing mnum = modnum<998244353>;\nusing hsh = pairnum<mnum, mnum>;\n\nconst uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\nmt19937 mt(FIXED_RANDOM);\nconst hsh BASE = hsh(mnum(mt()), mnum(mt()));\n\nconst int MAXN = 1.1e5;\nhsh BASE_POW[MAXN];\n\nstruct treap {\n\tint c[2] = {0,0};\n\tmt19937::result_type pri = mt();\n\n\thsh hash_val;\n\tint sz;\n\tint val;\n\n\tvoid update();\n\n};\nconst int TREAP_SZ = int(9.1e6);\ntreap treap_pool[TREAP_SZ];\nint TREAP_IND = 1;\nint alloc_treap() {\n\tint n = TREAP_IND++;\n\tassert(n < TREAP_SZ);\n\treturn n;\n}\n\nint get_sz(int a) {\n\treturn a ? treap_pool[a].sz : 0;\n}\nhsh get_hash_val(int a) {\n\treturn a ? treap_pool[a].hash_val : hsh(0);\n}\n\nvoid treap::update() {\n\tsz = 1 + get_sz(c[0]) + get_sz(c[1]);\n\thash_val = hsh(val);\n\tif (c[1]) {\n\t\thash_val = hash_val + BASE * get_hash_val(c[1]);\n\t}\n\tif (c[0]) {\n\t\thash_val = get_hash_val(c[0]) + BASE_POW[get_sz(c[0])] * hash_val;\n\t}\n}\n\nint merge(int a, int b) {\n\tif (!a) return b;\n\tif (!b) return a;\n\tint n = alloc_treap();\n\ttreap* r = &treap_pool[n];\n\tif (treap_pool[a].pri < treap_pool[b].pri) {\n\t\t*r = treap_pool[a];\n\t\tr->c[1] = merge(treap_pool[a].c[1], b);\n\t} else {\n\t\t*r = treap_pool[b];\n\t\tr->c[0] = merge(a, treap_pool[b].c[0]);\n\t}\n\tr->update();\n\treturn n;\n}\n\npair<int, int> split(int a, int k) {\n\tif (k == 0) return {0, a};\n\tassert(a);\n\tassert(k <= get_sz(a));\n\tif (k == get_sz(a)) return {a, 0};\n\n\tint l, r;\n\n\tint n = alloc_treap();\n\ttreap_pool[n] = treap_pool[a];\n\n\tif (k <= get_sz(treap_pool[a].c[0])) {\n\t\tr = n;\n\t\ttie(l, treap_pool[r].c[0]) = split(treap_pool[a].c[0], k);\n\t} else {\n\t\tl = n;\n\t\ttie(treap_pool[l].c[1], r) = split(treap_pool[a].c[1], k - 1 - get_sz(treap_pool[a].c[0]));\n\t}\n\n\ttreap_pool[n].update();\n\tassert(get_sz(l) == k);\n\treturn {l, r};\n}\n\nconst int S = 1 << 17;\nstruct seg_node {\n\tint pref = 0;\n\tint suff = 0;\n\tbool good = false;\n} seg[2*S];\n\nseg_node init_node(int v) {\n\tint ind = alloc_treap();\n\ttreap* n = &treap_pool[ind];\n\tn->pri = mt();\n\tn->c[0] = n->c[1] = 0;\n\tn->val = abs(v);\n\tn->update();\n\n\tif (v > 0) {\n\t\t// this is a suffix\n\t\treturn {0, ind, true};\n\t} else {\n\t\t// this is a prefix\n\t\treturn {ind, 0, true};\n\t}\n}\n\nseg_node merge_nodes(seg_node a, seg_node b) {\n\tif (!a.good || !b.good) {\n\t\treturn seg_node{0, 0, false};\n\t}\n\n\tint OLD_TREAP_IND = TREAP_IND;\n\n\tif (get_sz(a.suff) >= get_sz(b.pref)) {\n\t\tauto [x, y] = split(a.suff, get_sz(b.pref));\n\t\tassert(get_sz(x) == get_sz(b.pref));\n\t\tif (get_hash_val(x) != get_hash_val(b.pref)) {\n\t\t\tTREAP_IND = OLD_TREAP_IND;\n\t\t\treturn seg_node{0, 0, false};\n\t\t}\n\t\treturn {a.pref, merge(b.suff, y), true};\n\t} else {\n\t\tauto [x, y] = split(b.pref, get_sz(a.suff));\n\t\tassert(get_sz(x) == get_sz(a.suff));\n\t\tif (get_hash_val(x) != get_hash_val(a.suff)) {\n\t\t\tTREAP_IND = OLD_TREAP_IND;\n\t\t\treturn seg_node{0, 0, false};\n\t\t}\n\t\treturn {merge(a.pref, y), b.suff, true};\n\t}\n\n\tassert(false);\n}\n\nvoid updateNode(int i) {\n\tif (i >= S) {\n\t\t// do nothing\n\t} else {\n\t\tseg[i] = merge_nodes(seg[2*i], seg[2*i+1]);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tBASE_POW[0] = hsh(1);\n\tfor (int i = 1; i < MAXN; i++) BASE_POW[i] = BASE_POW[i-1] * BASE;\n\n\tint N, K; cin >> N >> K;\n\tvector<int> V(N);\n\tfor (int i = 0; i < N; i++) cin >> V[i];\n\n\tauto init = [&]() {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tseg[S+i] = init_node(V[i]);\n\t\t}\n\t\tfor (int i = S-1; i; i--) updateNode(i);\n\t};\n\tinit();\n\n\tconst int reset_thresh = int(TREAP_SZ * 0.9);\n\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tif (TREAP_IND >= reset_thresh) {\n\t\t\tTREAP_IND = 1;\n\t\t\tinit();\n\t\t}\n\n\t\tint op; cin >> op;\n\t\tif (op == 1) {\n\t\t\tint i; cin >> i; i--; cin >> V[i];\n\t\t\tseg[S+i] = init_node(V[i]);\n\t\t\tfor (int a = S+i; a; a /= 2) updateNode(a);\n\t\t} else if (op == 2) {\n\t\t\tint OLD_TREAP_IND = TREAP_IND;\n\n\t\t\tint l, r; cin >> l >> r; l--, r--;\n\t\t\tseg_node lval = {0, 0, true};\n\t\t\tseg_node rval = {0, 0, true};\n\t\t\tfor (int a = S+l, b = S+r+1; a < b; a /= 2, b /= 2) {\n\t\t\t\tif (a & 1) lval = merge_nodes(lval, seg[a++]);\n\t\t\t\tif (b & 1) rval = merge_nodes(seg[--b], rval);\n\t\t\t}\n\n\t\t\tseg_node val = merge_nodes(lval, rval);\n\t\t\tcout << (val.good && val.pref == 0 && val.suff == 0 ? ""Yes"" : ""No"") << \'\\n\';\n\n\t\t\tTREAP_IND = OLD_TREAP_IND;\n\t\t} else assert(false);\n\t}\n\n\treturn 0;\n}\n']","['brute force', 'data structures', 'hashing']",3300
https://codeforces.com//contest/1677/problem/B,B. Tokitsukaze and Meeting,Tokitsukaze is arranging a meeting There are n rows and m columns of seats in the meeting hall There are exactly n cdot m students attending the meeting including several naughty students and several serious students The students are numerated from 1 to n cdot m The students will enter the meeting hall in order When the i th student enters the meeting hall he will sit in the 1 st column of the 1 st row and the students who are already seated will move back one seat Specifically the student sitting in the j th 1 leq j leq m 1 column of the i th row will move to the j 1 th column of the i th row and the student sitting in m th column of the i th row will move to the 1 st column of the i 1 th row For example there is a meeting hall with 2 rows and 2 columns of seats shown as below There will be 4 students entering the meeting hall in order represented as a binary string of which represents naughty students and represents serious students The changes of seats in the meeting hall are as follows Denote a row or a column good if and only if there is at least one serious student in this row or column Please predict the number of good rows and columns just after the i th student enters the meeting hall for all i ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tstring s;cin>>s;\n\tvi base(n*m),sum(n*m);\n\tvi has(m);\n\tint pre=-inf;\n\trep(i,si(s))if(s[i]==\'1\'){\n\t\tif(!has[i%m]){\n\t\t\tbase[i]++;\n\t\t\thas[i%m]=1;\n\t\t}\n\t\tint dif=min(i-pre,m);\n\t\trng(j,i+m-dif,min(n*m,i+m))sum[j]++;\n\t\tpre=i;\n\t}\n\trep(i,n*m-1)base[i+1]+=base[i];\n\trep(i,n*m-m)sum[i+m]+=sum[i];\n\trep(i,n*m)base[i]+=sum[i];\n\tprint(base);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'implementation', 'math']",1700
https://codeforces.com//contest/1453/problem/F,F. Even Harder,Gildong is now developing a puzzle game The puzzle consists of n platforms numbered from 1 to n The player plays the game as a character that can stand on each platform and the goal of the game is to move the character from the 1 st platform to the n th platform The i th platform is labeled with an integer a i 0 le a i le n i When the character is standing on the i th platform the player can move the character to any of the j th platforms where i 1 le j le i a i If the character is on the i th platform where a i 0 and i ne n the player loses the game Since Gildong thinks the current game is not hard enough he wants to make it even harder He wants to change some possibly zero labels to 0 so that there remains exactly one way to win He wants to modify the game as little as possible so he s asking you to find the number of platforms that should have their labels changed Two ways are different if and only if there exists a platform the character gets to in one way but not in the other way ,"['#include<bits/stdc++.h>\nusing namespace std;\nint _,n,dp[3005][3005],tot,a[3005],F[3005];\nint main(){\n    cin >> _;\n    while (_--){\n        cin >> n;\n        for (int i=1;i<=n;i++) cin >> a[i];\n        for (int i=1;i<=n+1;i++)\n        for (int j=1;j<=n+1;j++) dp[i][j]=n+1;\n        dp[1][1]=0;\n        F[1]=0;\n        for (int i=2;i<=n;i++) F[i]=n+1;\n        for (int i=2;i<=n;i++){\n            for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][i]);\n            tot=0;\n            for (int j=i-1;j;j--){\n                if (j+a[j]>=i){\n                    dp[i][j+a[j]+1]=min(dp[i][j+a[j]+1],F[j]+tot);\n                    ++tot;\n                }\n            }\n        }\n        for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][n+1]);\n        cout << F[n] << endl;\n    }\n    return 0;\n}\n']",['dp'],2700
https://codeforces.com//contest/403/problem/C,C. Strictly Positive Matrix,You have matrix of size Let s number the rows of the matrix from to from top to bottom let s number the columns from to from left to right Let s use to represent the element on the intersection of the th row and the th column Matrix meets the following two conditions for any numbers the following inequality holds Matrix is if for any numbers the inequality holds You task is to determine if there is such integer that matrix is strictly positive ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\ninline void die(int a) {\n\tif (!a) printf(""NO\\n""); else\n\t\tprintf(""YES\\n"");\n\texit(0);\n}\nint a, b, c, d, n, m, k;\nbool sm[2002][2002];\nbool used[2002];\nint dfs(int v) {\n\tif (used[v]) return 0;\n\tused[v] = 1;\n\tint ans = 1;\n\trept(i, n) {\n\t\tif (sm[v][i]) ans += dfs(i);\n\t}\n\treturn ans;\n}\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\n\tscanf(""%d"", &n);\n\trept(i, n) {\n\t\trept(j, n) {\n\t\t\tscanf(""%d"", &a);\n\t\t\tif (a) sm[i][j] = 1;\n\t\t}\n\t}\n\n\tC(used);\n\tif (dfs(0) != n) die(0);\n\tC(used);\n\trept(i, n) {\n\t\trept(j, i) {\n\t\t\tswap(sm[i][j], sm[j][i]);\n\t\t}\n\t}\n\tif (dfs(0) != n) die(0);\n\tdie(1);\n}']","['graphs', 'math']",2200
https://codeforces.com//contest/680/problem/B,B. Bear and Finding Criminals,There are cities in Bearland numbered through Cities are arranged in one long row The distance between cities and is equal to Limak is a police officer He lives in a city His job is to catch criminals It s hard because he doesn t know in which cities criminals are Though he knows that there is criminal in each city Limak is going to use a BCD Bear Criminal Detector The BCD will tell Limak how many criminals there are for every distance from a city After that Limak can catch a criminal in each city for which he that there must be a criminal You know in which cities criminals are Count the number of criminals Limak will catch after he uses the BCD ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nint a , n , x[110] , o[110];\nint main(){\n    cin >> n >> a;\n    rep(i,1,n+1) cin >> x[i];\n    int ans = 0;\n    for(int i=a,j=a;i>=1||j<=n;--i,++j){\n        bool ok = true;\n        if(i >= 1 && !x[i]) ok = false;\n        if(j <= n && !x[j]) ok = false;\n        if(ok){\n            if(i >= 1) o[i] = true;\n            if(j <= n) o[j] = true;\n        }\n    }\n    rep(i,1,n+1) ans += o[i];\n    cout << ans << endl;\n    return 0;\n}\n']","['constructive algorithms', 'implementation']",1000
https://codeforces.com//contest/1015/problem/F,F. Bracket Substring,You are given a bracket sequence s not necessarily a regular one A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not Your problem is to calculate the number of regular bracket sequences of length 2n containing the given bracket sequence s as a substring consecutive sequence of characters modulo 10 9 7 1000000007 ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define p_b push_back\n#define pll pair<ll,ll>\n#define endl ""\\n""\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define ld long double\n\nusing namespace std;\ntypedef long long ll;\nconst ll MAXN = 1123456;\n\ntemplate <typename T>\nT sqr(T x){\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s){\n    cout << s << endl;\n    exit(0);\n}\n\nll bp(ll a,ll n){\n    ll res = 1;\n    while(n){\n        if(n % 2)res *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\nconst ll mod = 1e9 + 7;\n\nll dp[201][201][201];\n\nvoid f(ll& a, ll b){a = (a + b) % mod;}\n\nll z[MAXN];\n\nint main(){\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    ll m = s.size();\n    vector <ll> a(m + 1);\n    dp[0][0][0] = 1;\n    for(int i = 1; i <= m; i++){\n        if(s[i - 1] == \')\')a[i] = -1;else a[i] = 1;\n    }\n    z[0] = 1e18;\n    for(ll i = 1, l = 0, r = 0; i < m; i++){\n        if (i <= r)z[i] = min (r - i + 1, z[i - l]);\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]])++z[i];\n\t\tif (i + z[i] - 1 > r)l = i,  r = i + z[i] - 1;\n    }\n    for(int i = 1; i <= 2 * n; i++){\n\n        for(int j = 0; j <= 101; j++)\n        for(int i1 = 0; i1 <= m; i1++){\n\n            for(int j1 = -1; j1 < 2; j1++)if(j1 != 0){\n                ll kol = dp[i - 1][j][i1];\n                if(j1 + j >= 0 && kol){\n                    if(i1 == m)dp[i][j1 + j][m] = (dp[i][j1 + j][m] + kol) % mod;\n                    else if(j1 == a[i1 + 1])dp[i][j1 + j][i1 + 1] = (dp[i][j1 + j][i1 + 1] + kol) % mod;\n                    else{\n                        for(int jj = i1; jj >= 0; jj--){\n                            bool ok = 0;\n                            if(!jj)ok = 1;\n                            else if(jj == 1 && a[1] == j1)ok = 1;\n                            else if(a[jj] == j1 && z[i1 - jj + 1] >= jj - 1)ok = 1;\n                            if(ok){\n                                dp[i][j1 + j][jj] = (dp[i][j1 + j][jj] + kol) % mod;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n    cout << dp[2 * n][0][m] << endl;\n    return 0;\n}\n']","['dp', 'strings']",2300
https://codeforces.com//contest/986/problem/A,A. Fair,Some company is going to hold a fair in Byteland There are n towns in Byteland and m two way roads between towns Of course you can reach any town from any other town using roads There are k types of goods produced in Byteland and every town produces only one type To hold a fair you have to bring at least s different types of goods It costs d u v coins to bring goods from town u to town v where d u v is the length of the shortest path from u to v Length of a path is the number of roads in this path The organizers will cover all travel expenses but they can choose the towns to bring goods from Now they want to calculate minimum expenses to hold a fair in each of n towns ,"['/**\n *    author:  tourist\n *    created: 29.05.2018 18:34:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k, s;\n  cin >> n >> m >> k >> s;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  vector<vector<int>> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<vector<int>> dist(k, vector<int>(n, -1));\n  for (int type = 0; type < k; type++) {\n    vector<int> que;\n    for (int i = 0; i < n; i++) {\n      if (a[i] == type) {\n        dist[type][i] = 0;\n        que.push_back(i);\n      }\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (dist[type][u] == -1) {\n          dist[type][u] = dist[type][que[b]] + 1;\n          que.push_back(u);\n        }\n      }\n    }\n  }\n  vector<int> d(k);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < k; j++) {\n      d[j] = dist[j][i];\n    }\n    sort(d.begin(), d.end());\n    long long sum = 0;\n    for (int j = 0; j < s; j++) {\n      sum += d[j];\n    }\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << sum;\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","['graphs', 'greedy', 'number theory', 'shortest paths']",1600
https://codeforces.com//contest/1862/problem/G,G. The Great Equalizer,Tema bought an old device with a small screen and a worn out inscription The Great Equalizer on the side The seller said that the device needs to be given an array a of integers as input after which The Great Equalizer will work as follows Sort the current array in non decreasing order and remove duplicate elements leaving only one occurrence of each element If the current length of the array is equal to 1 the device stops working and outputs the single number in the array output value of the device Add an arithmetic progression n n 1 n 2 ldots 1 to the current array where n is the length of the current array In other words n i is added to the i th element of the array when indexed from zero Go to the first step To test the operation of the device Tema came up with a certain array of integers a and then wanted to perform q operations on the array a of the following type Assign the value x 1 le x le 10 9 to the element a i 1 le i le n Give the array a as input to the device and find out the result of the device s operation Help Tema find out the output values of the device after each operation ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#pragma GCC optimize(""Ofast,no-stack-protector"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY int\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e9)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,m,a[MAXN];\nmultiset<TY> s,num;\nIL void insert(TY now){\n\tmultiset<TY>::iterator itl=num.lower_bound(now),itr=num.upper_bound(now);\n\tTY A=-1,B=-1;\n\tif(itl!=num.begin()){\n\t\t--itl;A=*itl;\n\t\ts.insert(now-A);\n\t}if(itr!=num.end()){\n\t\tB=*itr;\n\t\ts.insert(B-now);\n\t}if(A!=-1&&B!=-1)s.erase(s.find(B-A));\n}IL void erase(TY now){\n\tmultiset<TY>::iterator itl=num.lower_bound(now),itr=num.upper_bound(now);\n\tTY A=-1,B=-1;\n\tif(itl!=num.begin()){\n\t\t--itl;A=*itl;\n\t\ts.erase(s.find(now-A));\n\t}if(itr!=num.end()){\n\t\tB=*itr;\n\t\ts.erase(s.find(B-now));\n\t}if(A!=-1&&B!=-1)s.insert(B-A);\n}IL void Insert(TY now){if(num.find(now)==num.end())insert(now);num.insert(now);}\nIL void Erase(TY now){num.erase(num.find(now));if(num.find(now)==num.end())erase(now);}\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tn=qr();For(i,1,n)a[i]=qr(),Insert(a[i]);\n\t\tm=qr();For(i,1,m){\n\t\t\tTY u=qr(),v=qr();\n\t\t\tErase(a[u]);a[u]=v;\n\t\t\tInsert(a[u]);\n\t\t\tqw(*--num.end()+(s.empty()?0:*--s.end()),\' \');\n\t\t}putchar(\'\\n\');\n\t\ts.clear();num.clear();\n\t}\n    return 0;\n}']","['binary search', 'data structures', 'math', 'sortings']",2000
https://codeforces.com//contest/1034/problem/C,C. Region Separation,There are n cities in the Kingdom of Autumn numbered from 1 to n People can travel between any two cities using n 1 two directional roads This year the government decides to separate the kingdom There will be regions of different levels The whole kingdom will be the region of level 1 Each region of i th level should be separated into several at least two regions of i 1 th level unless i th level is the last level Each city should belong to exactly one region of each level and for any two cities in the same region it should be possible to travel between them passing the cities in the same region only According to research for each city i there is a value a i which describes the importance of this city All regions of the same level should have an equal sum of city importances Your task is to find how many plans there are to determine the separation of the regions that all the conditions are satisfied Two plans are considered different if and only if their numbers of levels are different or there exist two cities in the same region of one level in one plan but in different regions of this level in the other plan Since the answer may be very large output it modulo 10 9 7 ,"['#include<cstdio>\nconst int mod=1000000007,hmod=10000019;\nint n,a[1000010],p[1000010],f[1000010];\nlong long sz[1000010];\nint g[1000010];\nlong long gcd(long long a,long long b){return b?gcd(b,a%b):a;}\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i),sz[i]=a[i];\n\tfor(int i=2;i<=n;i++)scanf(""%d"",p+i);\n\tfor(int i=n;i>1;i--)sz[p[i]]+=sz[i];\n\tfor(int i=1;i<=n;i++){\n\t\tlong long j=sz[1]/gcd(sz[1],sz[i]);\n\t\tif(j<=n)g[j]++;\n\t}\n\tfor(int i=n;i;i--)\n\t\tfor(int j=i*2;j<=n;j+=i)g[j]+=g[i];\n\tfor(int i=n;i>=1;i--)if(g[i]>=i){\n\t\tf[i]=1;\n\t\tfor(int j=i*2;j<=n;j+=i)(f[i]+=f[j])%=mod;\n\t}\n\tprintf(""%d\\n"",f[1]);\n}\n']","['combinatorics', 'dp', 'number theory', 'trees']",2700
https://codeforces.com//contest/1323/problem/A,A. Even Subset Sum Problem,You are given an array a consisting of n positive integers Find a subset of its elements such that their sum is i e divisible by 2 or determine that there is no such subset Both the given array and required subset may contain equal values ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    \n    int itest;\n    cin >> itest;\n    \n    while (itest--) {\n        int n;  cin >> n;\n        \n        vector<int> S0;\n        vector<int> S1;\n        \n        for(int i = 1 ; i <= n ; ++i)    {\n            int x;  cin >> x;\n            if (x & 1)  S1.push_back(i);\n            else        S0.push_back(i);\n        }\n        if (S0.size())  {\n            cout << ""1\\n"";\n            cout << S0[0] << ""\\n"";\n            continue;\n        }\n        if (S1.size() > 1)  {\n            cout << ""2\\n"";\n            cout << S1[0] << "" "" << S1[1] << ""\\n"";\n            continue;\n        }\n        cout << ""-1\\n"";\n    }\n}']","['brute force', 'dp', 'greedy', 'implementation']",800
https://codeforces.com//contest/1625/problem/E1,E1. Cats on the Upgrade  easy version , Interplanetary Software Inc together with Robots of Cydonia Ltd has developed and released robot cats These electronic pets can meow catch mice and entertain the owner in various ways The developers from Interplanetary Software Inc have recently decided to release a software update for these robots After the update the cats must solve the problems about bracket sequences One of the problems is described below First we need to learn a bit of bracket sequence theory Consider the strings that contain characters and Call a string if it can be transformed to an empty string by one or more operations of removing either single characters or a continuous substring For instance the string is an RBS as it can be transformed to an empty string with the following sequence of removals rightarrow rightarrow rightarrow rightarrow We got an empty string so the initial string was an RBS At the same time the string is not an RBS as it is not possible to apply such removal operations to it An RBS is if this RBS is not empty doesn t start with and doesn t end with Denote the of the string s as its sequential subsegment In particular s l dots r s ls l 1 dots s r where s i is the i th character of the string s Now move on to the problem statement itself You are given a string s initially consisting of characters and You need to answer the queries of the following kind Given two indices l and r 1 le l r le n and it s that the substring s l dots r is a You need to find the number of substrings in s l dots r such that they are simple RBS In other words find the number of index pairs i j such that l le i j le r and s i dots j is a simple RBS You are an employee in Interplanetary Software Inc and you were given the task to teach the cats to solve the problem above after the update ,"['#include <bits/stdc++.h>\n#define rep(i,n) for (i=1;i<=(n);i++)\nusing namespace std;\nint n,m,i,mat[300007];\nmap<int,int> id[300007];\nchar s[300007];\nint dfc,nfd[600007],deg[600007],fa[600007],ord[600007];\nlong long r[600007];\nvoid add(int x,long long v){\n\twhile(x<=600006){\n\t\tr[x]+=v;\n\t\tx+=(x&-x);\n\t}\n}\nlong long qsum(int x){\n\tlong long ans=0;\n\twhile(x){\n\t\tans+=r[x];\n\t\tx&=(x-1);\n\t}\n\treturn ans;\n}\nint solve(int l,int r){\n\tint u=++dfc;\n\tid[l][r]=u;\n\tl++;r--;\n\tif(l>r){\n\t\tnfd[u]=dfc;\n\t\treturn u;\n\t}\n\twhile(l<=r){\n\t\tint son;\n\t\tfa[son=solve(l,mat[l])]=u;\n\t\tl=mat[l]+1;\n\t\tdeg[u]++;\n\t\tord[son]=deg[u];\n\t}\n\tadd(u,1ll*deg[u]*(deg[u]+1)/2);\n\tnfd[u]=dfc;\n\treturn u;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tscanf("" %s"",s+1);\n\tstack<int> c;\n\trep(i,n){\n\t\tif(s[i]==\'(\') c.push(i);\n\t\telse if(!c.empty()){\n\t\t\tmat[c.top()]=i;\n\t\t\tmat[i]=c.top();\n\t\t\tc.pop();\n\t\t}\n\t}\n\tint tt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(mat[i]){\n\t\t\tord[solve(i,mat[i])]=++tt;\n\t\t\ti=mat[i];\n\t\t}\n\t}\n\twhile(m--){\n\t\tint op,l,r;\n\t\tscanf(""%d%d%d"",&op,&l,&r);\n\t\tif(op==2){\n\t\t\tint lid=id[l][mat[l]];\n\t\t\tint rid=id[mat[r]][r];\n\t\t\tprintf(""%lld\\n"",qsum(nfd[rid])-qsum(lid-1)+1ll*(ord[rid]-ord[lid]+1)*(ord[rid]-ord[lid]+2)/2);\n\t\t}\n\t}\n\treturn 0;\n}']","['brute force', 'data structures', 'dfs and similar', 'divide and conquer', 'dp', 'graphs', 'trees']",2500
https://codeforces.com//contest/1857/problem/G,G. Counting Graphs,Given a tree consisting of n vertices A tree is a connected undirected graph without cycles Each edge of the tree has its weight w i Your task is to count the number of different graphs that satisfy all four conditions The graph does not have self loops and multiple edges The weights on the edges of the graph are integers and do not exceed S The graph has minimum spanning tree The minimum spanning tree of the graph is the given tree Two graphs are considered different if their sets of edges are different taking into account the weights of the edges The answer can be large output it modulo 998244353 ,"[""#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n\nusing ll = long long;\nusing ld = long double;\n\nconst int MOD = 998244353;\n\n#define int long long\n\nstruct dsu {\n    vector<int> p, s;\n    dsu(int n) {\n        p.resize(n);\n        iota(all(p), 0);\n        s.assign(n, 1);\n    }\n    int get(int v) {\n        if (v == p[v]) return v;\n        p[v] = get(p[v]);\n        return p[v];\n    }\n    int unite(int u, int v) {\n        u = get(u), v = get(v);\n        if (u == v) return 0;\n        if (s[u] < s[v]) swap(u, v);\n        int res = 0;\n        res -= s[u] * (s[u] - 1) / 2;\n        res -= s[v] * (s[v] - 1) / 2;\n        s[u] += s[v];\n        p[v] = u;\n        res += s[u] * (s[u] - 1) / 2;\n        res--;\n        return res;\n    }\n};\n\nint mpow(int x, int e) {\n    int c = x, r = 1;\n    while (e) {\n        if (e & 1) r = r * c % MOD;\n        c = c * c % MOD;\n        e >>= 1;\n    }\n    return r;\n}\n\nvoid solve() {\n    int n, S;\n    cin >> n >> S;\n    vector <array <int, 3>> edg;\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u, --v;\n        edg.push_back({w, u, v});\n    }\n    sort(all(edg));\n    int ans = 1;\n    dsu z(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int add = z.unite(edg[i][1], edg[i][2]);\n        ans = ans * mpow(S - edg[i][0] + 1, add) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n}""]","['combinatorics', 'divide and conquer', 'dsu', 'graphs', 'greedy', 'sortings', 'trees']",2000
https://codeforces.com//contest/696/problem/C,C. PLEASE,As we all know Barney s job is PLEASE and he has not much to do at work That s why he started playing cups and key In this game there are three identical cups arranged in a line from left to right Initially key to Barney s heart is under the middle cup Then at one turn Barney swaps the cup in the middle with any of other two cups randomly he choses each with equal probability so the chosen cup becomes the middle one Game lasts turns and Barney a cup to swap with the middle one within each turn and the key always remains in the cup it was at the start After th turn Barney asks a girl to guess which cup contains the key The girl points to the middle one but Barney was distracted while making turns and doesn t know if the key is under the middle cup That s why he asked you to tell him the probability that girl guessed right Number of game turns can be extremely large that s why Barney did not give it to you Instead he gave you an array such that in other words is multiplication of all elements of the given array Because of precision difficulties Barney asked you to tell him the answer as an irreducible fraction In other words you need to find it as a fraction such that where is the greatest common divisor Since and can be extremely large you only need to find the remainders of dividing each of them by Please note that we want of and to be after dividing by ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint k;\nll x;\nint main() {\n\tscanf(""%d"",&k);\n\tll q=(mod-1)/2,d=2;\n\trep(i,0,k) {\n\t\tscanf(""%lld"",&x);\n\t\tq=powmod(q,x);\n\t\td=powmod(d,x);\n\t}\n\td=d*powmod(2,mod-2)%mod;\n\tq=(q*2+1)%mod*powmod(3,mod-2)%mod;\n\tll p=q*d%mod;\n\tprintf(""%lld/%lld\\n"",p,d);\n}\n']","['combinatorics', 'dp', 'implementation', 'math', 'matrices']",2000
https://codeforces.com//contest/1255/problem/A,A. Changing Volume,Bob watches TV every day He always sets the volume of his TV to b However today he is angry to find out someone has changed the volume to a Of course Bob has a remote control that can change the volume There are six buttons 5 2 1 1 2 5 on the control which in one press can either increase or decrease the current volume by 1 2 or 5 The volume can be arbitrarily large but can never be negative In other words Bob cannot press the button if it causes the volume to be lower than 0 As Bob is so angry he wants to change the volume to b using as few button presses as possible However he forgets how to do such simple calculations so he asks you for help Write a program that given a and b finds the minimum number of presses to change the TV volume from a to b ,"['#include <bits/stdc++.h>\n\n#define ii pair<int, int>\n#define lli long long int\n#define ll pair<lli, lli>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\nint main() {\n\tint tc, a, b, c, ans;\n\tscanf(""%d"", &tc);\n\twhile (tc--) {\n\t\tscanf(""%d %d"", &a, &b);\n\t\tc = abs(a - b);\n\t\tans = c / 5;\n\t\tc %= 5;\n\t\tans += (c / 2);\n\t\tc %= 2;\n\t\tans += c;\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}']",['math'],800
https://codeforces.com//contest/678/problem/D,D. Iterated Linear Function,Consider a linear function Let s define and for For the given integer values and find the value of modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int Q = 1e9 + 7;\nstruct Matrix {\n    int n , m , a[2][2];\n    Matrix (int _n = 0, int _m = 0) {\n        n = _n , m = _m;\n        memset(a , 0 , sizeof(a));\n    }\n    Matrix operator * (const Matrix &R) const {\n        Matrix res(n , R.m);\n        for (int i = 0 ; i < n ; ++ i) {\n            for (int j = 0 ; j < m ; ++ j) {\n                for (int k = 0 ; k < R.m ; ++ k) {\n                    res.a[i][k] += (LL)a[i][j] * R.a[j][k] % Q;\n                    res.a[i][k] %= Q;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    LL A , B , n , x;\n    cin >> A >> B >> n >> x;\n    Matrix I(1 , 2);\n    I.a[0][0] = x , I.a[0][1] = 1;\n    Matrix P(2 , 2);\n    P.a[0][0] = A;\n    P.a[1][0] = B;\n    P.a[1][1] = 1;\n    while (n) {\n        if (n & 1) {\n            I = I * P;\n        }\n        P = P * P;\n        n >>= 1;\n    }\n    cout << I.a[0][0] << endl;\n}\n']","['math', 'number theory']",1700
https://codeforces.com//contest/1529/problem/B,B. Sifid and Strange Subsequences,A sequence b 1 b 2 ldots b k is called if the absolute difference between any pair of its elements is greater than or equal to the maximum element in the sequence Formally speaking it s strange if for every pair i j with 1 le i j le k we have a i a j geq MAX where MAX is the largest element of the sequence In particular any sequence of length at most 1 is strange For example the sequences 2021 1 1 1 and 1 0 1 are strange but 3 0 1 is not because 0 1 3 Sifid has an array a of n integers Sifid likes everything big so among all the strange subsequences of a he wants to find the length of the one Can you help him A sequence c is a subsequence of an array d if c can be obtained from d by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n    int ntest; cin >> ntest;\n    while(ntest--) {\n        int n; cin >> n;\n        vector<int> a(n);\n        for(int i = 0; i < n; ++i) cin >> a[i];\n\n        sort(a.begin(), a.end());\n\n        int ans = 0, cntzero = 0, cntlarger = 0;\n        for(int i = 0; i < n; ++i) {\n            if(a[i] < 0) ans++;\n            else {\n                if (a[i] == 0) cntzero += 1;\n            }\n        }\n\n        int res = ans + cntzero, mn = 1e9;\n        for(int i = 0; i + 1 < n; ++i) {\n            if (a[i + 1] > 0) break;\n            mn = min(mn, a[i + 1] - a[i]);\n        }\n\n        for(int i = 0; i < n; ++i) if (a[i] > 0 && a[i] <= mn) cntlarger += 1;\n\n        res = max(res, ans + (cntzero > 0) + (cntlarger > 0));\n\n        cout << res << ""\\n"";\n    }\n\n    return 0;\n}']","['greedy', 'math', 'sortings']",1100
https://codeforces.com//contest/542/problem/B,B. Duck Hunt,A duck hunter is doing his favorite thing hunting He lives in a two dimensional world and is located at point As he doesn t like walking for his prey he prefers to shoot only vertically up because in this case the ducks fall straight into his hands The hunter doesn t reload the gun immediately or more seconds must pass between the shots When the hunter shoots up the bullet immediately hits all the ducks who are directly above the hunter In a two dimensional world each duck is a horizontal segment that moves horizontally in the negative direction of the axis at the speed length unit per second For each duck we know the values and the coordinates of its head the left end of the segment and its tail the right end of the segment at time The height where the duck is flying isn t important as the gun shoots vertically up to the infinite height and hits all the ducks on its way What maximum number of ducks can the hunter shoot The duck is considered shot by the hunter if at the moment of the shot at least one of its point intersects the axis After the hunter shoots the duck it falls and it can t be shot anymore The hunter cannot make shots before the moment of time 0 ,"['#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<"" = ""<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\nint n, d;\nstruct Node {\n\tint mx, ad;\n}seg[200010*12];\n\ntypedef pair<int, int> IV;\nIV inp[200010];\nmap<int, int> dis;\nint inv[200010*4];\n\nint cn = 0;\nint cmi = 0;\nint lav = -1;\nint cl = 0;\n\nvoid assignV(int ed) {\n\ttypeof(dis.begin()) it = dis.upper_bound(lav);\n\tfor(; it != dis.end() && it->first <= ed; ++it) {\n\t\t//printf(""M: %d-%d\\n"", cn, it->first);\n\t\tinv[cn] = it->first;\n\t\tit->second = cn++;\n\t}\n\tlav = ed; \n}\n\nvoid s_add(int i, int l, int r, int st, int ed, int av) {\n\t//if (i == 0) printf(""A: %d %d %d\\n"", st, ed, av);\n\tif (ed <= st) return;\n\tif (st == l && ed == r) {\n\t\tseg[i].mx += av;\n\t\tseg[i].ad += av;\n\t\treturn;\n\t}\n\tint m = (l+r)/2;\n\tif (m <= st) s_add(i*2+2, m, r, st, ed, av);\n\telse if (m >= ed) s_add(i*2+1, l, m, st, ed, av);\n\telse {\n\t\ts_add(i*2+1, l, m, st, m, av);\n\t\ts_add(i*2+2, m, r, m, ed, av);\n\t}\n\tseg[i].mx = max(seg[2*i+1].mx, seg[2*i+2].mx) + seg[i].ad;\n}\n\nint s_getMinId(int i, int l, int r, int av, int cv) {\n\t//printf(""Q: %d %d %d %d\\n"", i, l, r, cv);\n\tif (seg[i].mx+av < cv) return r;\n\tif (l+1 == r) return l;\n\tint m = (l+r)/2;\n\tif (seg[2*i+1].mx+av+ seg[i].ad >= cv) return s_getMinId(i*2+1, l, m, av + seg[i].ad, cv);\n\telse return s_getMinId(i*2+2, m, r, av + seg[i].ad, cv);\n}\n\nvoid lemon() { \n\tscanf(""%d%d"", &n, &d);\n\trep(i,0,n-1) {\n\t\tint s, t;\n\t\tscanf(""%d%d"", &s, &t);\n\t\tif (t < 0) i--, n--;\n\t\telse {\n\t\t\ts = max(s, 0);\n\t\t\tinp[i] = IV(t+1,s);\n\t\t\tdis[s]=0, dis[t+1]=0;\n\t\t}\n\t} \n\tsort(inp, inp+n);\n\tint maxd = n * 3 + 1;\n\tinv[maxd] = 1000000001;\n\n\trep(i,0,n-1) {\n\t\tint np = inv[s_getMinId(0, 0, maxd, 0, cmi+1)];\n\t\tnp += d;\n\t\t//printf(""%d: [%d, %d) %d %d\\n"", i, inp[i].second, inp[i].first, np, cl);\n\t\tif (np < cl) np = cl;\n\t\tif (np <= inp[i].first) {\n\t\t\tcmi++;\n\t\t\tif (dis.find(np) == dis.end())dis[np] = 0;\n\t\t\tassignV(np);\n\t\t\ts_add(0, 0, maxd, dis[np], maxd, 1);\n\t\t\tcl = np;\n\t\t\ti--;\n\t\t} else {\n\t\t\tassignV(inp[i].first);\n\t\t\ts_add(0, 0, maxd, dis[inp[i].second], dis[inp[i].first], 1);\n\t\t\tcl = inp[i].first;\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", seg[0].mx);\n}\nint main() {\n  ios::sync_with_stdio(true);\n  #ifndef ONLINE_JUDGE\n  //  freopen("""",""r"",stdin);\n  #endif\n  lemon();\n  return 0;\n}']",['data structures'],3100
https://codeforces.com//contest/1229/problem/F,F. Mateusz and Escape Room,Mateusz likes to travel However on his 42nd visit to Saint Computersburg there is not much left to sightsee That s why he decided to go to an escape room with his friends The team has solved all riddles flawlessly There is only one riddle remaining a huge circular table There are n weighing scales lying on top of the table distributed along the circle Each scale is adjacent to exactly two other scales for each i in 1 2 dots n 1 the i th and the i 1 th scales are adjacent to each other as well as the first and the n th scale The i th scale initially contains a i heavy coins Mateusz can perform moves each move consists of fetching a single coin from one scale and putting it on any adjacent scale It turns out that the riddle will be solved when there is a specific amount of coins on each of the scales Specifically each scale has parameters l i and r i If each coin lies on a single scale and for each i the i th scale contains at least l i and at most r i coins the riddle will be solved and Mateusz s team will win Mateusz is aiming for the best possible time Therefore he wants to solved the riddle as quickly as possible What is the minimum possible number of moves required to fulfill all the conditions ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n \nconst int N=35100;\nint a[N],l[N],r[N],n;\n\nstruct pq {\n\tll q[2*N];\n\tint sz=0;\n\tll offset=0;\n\tvoid init(ll val) {\n\t\tsz=n+1;\n\t\trep(i,0,sz) q[i]=-val;\n\t}\n\tll top() {\n\t\treturn -q[0]+offset;\n\t}\n\tvoid push(ll x) {\n\t\tq[sz++]=-(x-offset);\n\t\tpush_heap(q,q+sz);\n\t}\n\tvoid shift(ll x) {\n\t\toffset+=x;\n\t}\n\tvoid pop() {\n\t\tpop_heap(q,q+sz); --sz;\n\t}\n};\n\nll solve(ll t) {\n\tpq L,R;\n\tL.init(-t); R.init(t);\n\tll key=abs(t);\n\trep(i,0,n) {\n\t\tL.shift(a[i]-l[i]); R.shift(r[i]-a[i]);\n\t\tif (i!=n-1) {\n\t\t\tll pL=L.top(),pR=R.top();\n\t\t\tif (pL>=0&&pR>=0) {\n\t\t\t\tL.push(0); R.push(0);\n\t\t\t} else if (pR<0) {\n\t\t\t\tkey+=-pR;\n\t\t\t\tL.push(-pR); R.pop();\n\t\t\t\tR.push(0); R.push(0);\n\t\t\t} else {\n\t\t\t\tkey+=-pL;\n\t\t\t\tR.push(-pL); L.pop();\n\t\t\t\tL.push(0); L.push(0);\n\t\t\t}\n\t\t}\n\t}\n\tL.shift(t); R.shift(-t);\n\tll pL=L.top(),pR=R.top();\n\tif (pL>=0&&pR>=0) return key;\n\tif (pR<0) {\n\t\tint k=0;\n\t\twhile (1) {\n\t\t\tR.pop();\n\t\t\tll cR=R.top(); ++k;\n\t\t\tif (cR>=0) return key+k*(-pR);\n\t\t\tkey+=k*(cR-pR); pR=cR;\n\t\t}\n\t} else {\n\t\tint k=0;\n\t\twhile (1) {\n\t\t\tL.pop();\n\t\t\tll cL=L.top(); ++k;\n\t\t\tif (cL>=0) return key+k*(-pL);\n\t\t\tkey+=k*(cL-pL); pL=cL;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n \nint sa;\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d%d%d"",a+i,l+i,r+i),sa+=a[i];\n\tint pL=-sa,pR=sa;\n\twhile (pL+4<pR) {\n\t\tint fl=(pL+pR)/2,fr=fl+1;\n\t\tif (solve(fl)>solve(fr)) pL=fl;\n\t\telse pR=fr;\n\t}\n\tll ans=1ll<<60;\n\trep(i,pL,pR+1) {\n\t\tans=min(ans,solve(i));\n\t}\n\tprintf(""%lld\\n"",ans);\n}']",['dp'],3500
https://codeforces.com//contest/1353/problem/E,E. K-periodic Garland,You are given a garland consisting of n lamps States of the lamps are represented by the string s of length n The i th character of the string s i equals if the i th lamp is turned off or if the i th lamp is turned on You are also given a positive integer k In one move you can choose and change its state i e turn it on if it is turned off and vice versa The garland is called k periodic if the distance between is k Consider the case k 3 Then garlands and are good but garlands and are not Note that i e the first turned on lamp is not going after the last turned on lamp and vice versa Your task is to find the number of moves you need to make to obtain k periodic garland from the given one You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,k;\n           cin>>a>>k;\n           string s;\n           \n           vector <int> col(k); \n           vector <int> sum(k);\n           vector <vector<int>> kek(k); \n           for (int i=0;i<a;i++) {\n               char t; cin>>t; sum[i%k]+=(t-\'0\'); col[i%k]++; kek[i%k].push_back(t-\'0\');  \n           }\n           //cout<<sum1<<""""\n           int min1=1000000000;\n           int sum1=0;\n           for (int i=0;i<k;i++) sum1+=sum[i]; \n           for (int i=0;i<k;i++) {\n               int cur=sum1; cur-=sum[i]; \n               int kek1=sum[i];\n               int lol=0;\n               \n               vector <pair<int,int>> pref1(kek[i].size()+1);\n               for (int j=0;j<kek[i].size();j++) {\n                   if (j==0) {pref1[j]={0,0}; } else pref1[j]=pref1[j-1]; \n                   if (kek[i][j]==0) pref1[j].first++; else pref1[j].second++;\n                   kek1=min(kek1,sum[i]+pref1[j].first-pref1[j].second-lol); \n                   lol=max(lol,-pref1[j].second+pref1[j].first); \n               }\n               min1=min(min1,cur+kek1); \n           }\n           cout<<min1<<""\\n""; \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","['brute force', 'dp', 'greedy']",1900
https://codeforces.com//contest/144/problem/A,A. Arrival of the General,A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper Having learned the news the colonel ordered to all squad soldiers to line up on the parade ground By the military charter the soldiers should stand in the order of non increasing of their height But as there s virtually no time to do that the soldiers lined up in the arbitrary order However the general is rather short sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height Please note that the way other solders are positioned does not matter including the case when there are several soldiers whose height is maximum or minimum Only the heights of the and the soldier are important For example the general considers the sequence of heights correct and the sequence wrong Within one second the colonel can swap any two neighboring soldiers Help him count the minimum time needed to form a line up which the general will consider correct ,"['#include <string>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <utility>\n#include <time.h>\n#include <string.h>\nusing namespace std;\n\n\nint main( void )\n{\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor( int i = 0; i < n; i ++ )\n\t\tcin >> a[i];\n\n\tint M = 0, Mi = -1;\n\tfor( int i = 0; i < n; i ++ )\n\t\tif( M < a[i] )\n\t\t\tM = a[i], Mi = i;\n\tint m = 1000, mi = -1;\n\tfor( int i = n - 1; i >= 0; i -- )\n\t\tif( m > a[i] )\n\t\t\tm = a[i], mi = i;\n\tif( Mi < mi ){\n\t\tcout << (Mi + (n-1-mi)) << endl;\n\t}\n\telse{\n\t\tcout << (Mi + (n-1-mi) - 1) << endl;\n\t}\n}\n']",['implementation'],800
https://codeforces.com//contest/1338/problem/C,C. Perfect Triples,Consider the infinite sequence s of positive integers created by repeating the following steps Find the lexicographically smallest triple of positive integers a b c such that a oplus b oplus c 0 where oplus denotes the bitwise XOR operation a b c are not in s Here triple of integers a 1 b 1 c 1 is considered to be lexicographically smaller than triple a 2 b 2 c 2 if sequence a 1 b 1 c 1 is lexicographically smaller than sequence a 2 b 2 c 2 Append a b c to s in this order Go back to the first step You have integer n Find the n th element of s You have to answer t independent test cases A sequence a is lexicographically smaller than a sequence b if in the first position where a and b differ the sequence a has a smaller element than the corresponding element in b ,"[""/**\n *    author:  tourist\n *    created: 12.04.2020 17:26:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\npair<long long, long long> Get(int bit, long long idx) {\n  if (bit == 0) {\n    return make_pair(1, 2);\n  }\n  long long some = 1LL << (bit - 2);\n  auto q = Get(bit - 2, idx % some);\n  q.first ^= (1LL << (bit - 2));\n  q.second ^= (1LL << (bit - 1));\n  long long cs = idx / some;\n  if (cs == 1) {\n    q.first ^= (1LL << (bit - 2));\n    q.second ^= (1LL << (bit - 1));\n  }\n  if (cs == 2) {\n    q.first ^= (1LL << (bit - 1));\n    q.second ^= (1LL << (bit - 1)) ^ (1LL << (bit - 2));\n  }\n  if (cs == 3) {\n    q.first ^= (1LL << (bit - 1)) ^ (1LL << (bit - 2));\n    q.second ^= (1LL << (bit - 2));\n  }\n  q.first ^= 1LL << bit;\n  q.second ^= 1LL << (bit + 1);\n  return q;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long n;\n    cin >> n;\n    long long idx = (n - 1) / 3;\n    long long pos = (n - 1) % 3;\n    for (int bit = 0; ; bit += 2) {\n      long long here = 1LL << bit;\n      if (idx < here) {\n        auto p = Get(bit, idx);\n        cout << (pos == 0 ? p.first : (pos == 1 ? p.second : (p.first ^ p.second))) << '\\n';\n        break;\n      }\n      idx -= here;\n    }\n  }\n  return 0;\n}\n""]","['bitmasks', 'brute force', 'constructive algorithms', 'divide and conquer', 'math']",2200
https://codeforces.com//contest/599/problem/B,B. Spongebob and Joke,While Patrick was gone shopping Spongebob decided to play a little trick on his friend The naughty Sponge browsed through Patrick s personal stuff and found a sequence of length consisting of integers from to not necessarily distinct Then he picked some sequence of length and for each number got number To finish the prank he erased the initial sequence It s hard to express how sad Patrick was when he returned home from shopping We will just say that Spongebob immediately got really sorry about what he has done and he is now trying to restore the original sequence Help him do this or determine that this is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\nint used[100005];\nint f[100005];\nint o[100005];\nint freq[100005], rev[100005];\nint main() {\n  int n, m, x;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(""%d"", &f[i]);\n    freq[f[i]]++;\n    rev[f[i]] = i;\n  }\n  bool amb = false;\n  for (int i = 1; i <= m; i++) {\n    scanf(""%d"", &x);\n    if (freq[x] == 1) {\n      o[i] = rev[x];\n    } else if (freq[x] == 0) {\n      printf(""Impossible\\n"");\n      return 0;\n    } else {\n      amb = true;\n    }\n  }\n  if (amb) {\n    printf(""Ambiguity\\n"");\n    return 0;\n  }\n  printf(""Possible\\n"");\n  for (int i = 1; i <= m; i++) {\n    printf(""%d%c"", o[i], i == m ? \'\\n\' : \' \');\n  }\n  return 0;\n}\n']",['implementation'],1500
https://codeforces.com//contest/1698/problem/E,E. PermutationForces II,You are given a permutation a of length n Recall that permutation is an array consisting of n distinct integers from 1 to n in arbitrary order You have a strength of s and perform n moves on the permutation a The i th move consists of the following Pick two integers x and y such that i leq x leq y leq min i s n and swap the positions of the integers x and y in the permutation a Note that you select x y in the operation in which case no swap will occur You want to turn a into another permutation b after n moves However some elements of b are missing and are replaced with 1 instead Count the number of ways to replace each 1 in b with some integer from 1 to n so that b is a permutation and it is possible to turn a into b with a strength of s Since the answer can be large output it modulo 998 244 353 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define N 300005\n#define ll long long\n#define mod 998244353\nint T,n,i,j,qwq,s,c[N],fl,p[N],a[N],b[N];\nll ans;\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>s;\n\t\tfor(i=1;i<=n;++i)cin>>a[i];\n\t\tfor(i=1;i<=n;++i)cin>>b[i],p[a[i]]=b[i];\n\t\tfl=0;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tif(p[i]!=-1&&p[i]<i-s)fl=1;\n\t\t\tif(p[i]!=-1)c[p[i]]=1;\n\t\t}ans=1;\n\t\tj=1;qwq=0;\n\t\tfor(i=1;i<=n;++i){\n\t\t\twhile(j<=i+s&&j<=n){if(p[j]==-1)++qwq;++j;}\n\t\t\tif(!c[i]&&qwq==0)fl=1;\n\t\t\telse if(!c[i])ans=ans*qwq%mod,--qwq;\n\t\t}\n\t\tfor(i=1;i<=n;++i)c[i]=0;\n\t\tif(fl==1)cout<<""0\\n"";\n\t\telse cout<<ans<<""\\n"";\n\t}\n} ']","['brute force', 'combinatorics', 'greedy', 'sortings', 'trees', 'two pointers']",2300
https://codeforces.com//contest/1579/problem/E1,E1. Permutation Minimization by Deque,A permutation p of size n is given A of size n is an array of size n in which each integer from 1 to n occurs exactly once For example 1 4 3 2 and 4 2 1 3 are correct permutations while 1 2 4 and 1 2 2 are not Let us consider an empty deque double ended queue A deque is a data structure that supports adding elements to both the beginning and the end So if there are elements 1 5 2 currently in the deque adding an element 4 to the beginning will produce the sequence color red 4 1 5 2 and adding same element to the end will produce 1 5 2 color red 4 The elements of the permutation are sequentially added to the initially empty deque starting with p 1 and finishing with p n Before adding each element to the deque you may choose whether to add it to the beginning or the end For example if we consider a permutation p 3 1 2 4 one of the possible sequences of actions looks like this quad 1 add 3 to the end of the deque deque has a sequence color red 3 in it quad 2 add 1 to the beginning of the deque deque has a sequence color red 1 3 in it quad 3 add 2 to the end of the deque deque has a sequence 1 3 color red 2 in it quad 4 add 4 to the end of the deque deque has a sequence 1 3 2 color red 4 in it Find the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed A sequence x 1 x 2 ldots x n is than the sequence y 1 y 2 ldots y n if there exists such i leq n that x 1 y 1 x 2 y 2 ldots x i 1 y i 1 and x i y i In other words if the sequences x and y have some possibly empty matching prefix and the next element of the sequence x is strictly smaller than the corresponding element of the sequence y For example the sequence 1 3 2 4 is smaller than the sequence 1 3 4 2 because after the two matching elements 1 3 in the start the first sequence has an element 2 which is smaller than the corresponding element 4 in the second sequence ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"")\n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005],n;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        deque <int> dq;\n        for(int i = 1;i <= n;i++) {\n            int x; cin >> x;\n            if(dq.empty()) dq.pb(x);\n            else {\n                if(x < dq.front()) dq.push_front(x);\n                else dq.push_back(x);\n            }\n        }\n        while(!dq.empty()) {\n            cout << dq.front() << \' \';\n            dq.pop_front();\n        }\n        cout << \'\\n\';\n    }\n}\n']","['constructive algorithms', 'greedy', 'math']",1000
https://codeforces.com//contest/1882/problem/C,C. Card Game,There are n cards stacked in a deck Initially a i is written on the i th card from the top The value written on a card does not change You will play a game Initially your score is 0 In each turn you can do of the following operations Choose an odd dagger positive integer i which is not greater than the number of cards left in the deck Remove the i th card from the top of the deck The remaining cards will be reindexed starting from the top Choose an even ddagger positive integer i which is not greater than the number of cards left in the deck Remove the i th card from the top of the deck The remaining cards will be reindexed starting from the top End the game You can end the game whenever you want you have to remove all cards from the initial deck What is the maximum score you can get when the game ends dagger An integer i is odd if there exists an integer k such that i 2k 1 ddagger An integer i is even if there exists an integer k such that i 2k ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T,ans,flg;\nint a[maxn];\nstring s;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tlong long ans=0;\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(""%d"",&a[i]);\n\t\tlong long s=0;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tif(i&1)\n\t\t\t\tans=max(ans,s+a[i]);\n\t\t\telse ans=max(ans,s);\n\t\t\ts+=max(a[i],0);\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n']","['brute force', 'greedy']",1500
https://codeforces.com//contest/1254/problem/B1,B1. Send Boxes to Alice  Easy Version ,Christmas is coming and our protagonist Bob is preparing a spectacular present for his long time best friend Alice This year he decides to prepare n boxes of chocolate numbered from 1 to n Initially the i th box contains a i chocolate pieces Since Bob is a typical nice guy he will not send Alice n empty boxes In other words Since Alice dislikes coprime sets she will be happy only if there exists some integer k 1 such that the number of pieces in each box is divisible by k Note that Alice won t mind if there exists some empty boxes Charlie Alice s boyfriend also is Bob s second best friend so he decides to help Bob by rearranging the chocolate pieces In one second Charlie can pick up a piece in box i and put it into either box i 1 or box i 1 if such boxes exist Of course he wants to help his friend as quickly as possible Therefore he asks you to calculate the minimum number of seconds he would need to make Alice happy ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\n\nint n;\nll tab[nax];\n\nll s;\n\nvll pie;\n\nll wyn=inf;\n\nvoid check(ll v)\n{\n\tll ret=0;\n\ts=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ts+=tab[i];\n\t\ts%=v;\n\t\tret+=min(s, v-s);\n\t}\n\twyn=min(wyn, ret);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tif (s==1)\n\t{\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tfor (ll i=2; i*i<=s; i++)\n\t{\n\t\tif (!(s%i))\n\t\t{\n\t\t\tpie.push_back(i);\n\t\t\ts/=i;\n\t\t\ti--;\n\t\t}\n\t}\n\tpie.push_back(s);\n\tfor (ll i : pie)\n\t\tcheck(i);\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'math', 'number theory', 'ternary search', 'two pointers']",1800
https://codeforces.com//contest/363/problem/C,C. Fixing Typos,Many modern text editors automatically check the spelling of the user s text Some editors even suggest how to correct typos In this problem your task to implement a small functionality to correct two types of typos in a word We will assume that three identical letters together is a typo for example word contains a typo Besides a couple of identical letters immediately followed by another couple of identical letters is a typo too for example words and contain typos Write a code that deletes the minimum number of letters from a word correcting described typos in the word You are allowed to delete letters from both ends and from the middle of the word ,"['#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <ctime>\n#include <deque>\n#include <bitset>\n#include <cctype>\n#include <utility>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\n#define Rep(i,n) for(int i = 0; i < (n); ++i)\n#define Repd(i,n) for(int i = (n)-1; i >= 0; --i)\n#define For(i,a,b) for(int i = (a); i <= (b); ++i)\n#define Ford(i,a,b) for(int i = (a); i >= (b); --i)\n#define Fit(i,v) For(__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++i)\n#define Fitd(i,v) For(__typeof((v).rbegin()) i = (v).rbegin(); i != (v).rend(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(), (a).end()\n#define ms(a,x) memset(a, x, sizeof(a))\n\ntemplate<class F, class T> T convert(F a, int p = -1) { stringstream ss; if (p >= 0) ss << fixed << setprecision(p); ss << a; T r; ss >> r; return r; }\ntemplate<class T> T gcd(T a, T b) { T r; while (b != 0) { r = a % b; a = b; b = r; } return a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<class T> T sqr(T x) { return x * x; }\ntemplate<class T> T cube(T x) { return x * x * x; }\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcount(s); }\nconst int bfsz = 1 << 16; char bf[bfsz + 5]; int rsz = 0;int ptr = 0;\nchar gc() { if (rsz <= 0) { ptr = 0; rsz = (int) fread(bf, 1, bfsz, stdin); if (rsz <= 0) return EOF; } --rsz; return bf[ptr++]; }\nvoid ga(char &c) { c = EOF; while (!isalpha(c)) c = gc(); }\nint gs(char s[]) { int l = 0; char c = gc(); while (isspace(c)) c = gc(); while (c != EOF && !isspace(c)) { s[l++] = c; c = gc(); } s[l] = \'\\0\'; return l; }\ntemplate<class T> bool gi(T &v) {\n    v = 0; char c = gc(); while (c != EOF && c != \'-\' && !isdigit(c)) c = gc(); if (c == EOF) return false; bool neg = c == \'-\'; if (neg) c = gc();\n    while (isdigit(c)) { v = v * 10 + c - \'0\'; c = gc(); } if (neg) v = -v; return true;\n}\n\ntypedef pair<int, int> II;\n\nconst ld PI = acos(ld(-1.0));\nconst ld eps = 1e-9;\n\nconst int inf = (int)1e9 + 5;\nconst ll linf = (ll)1e17 + 5;\nint dr[4] = {-1, 0, +1, 0};\nint dc[4] = {0, -1, 0, +1};\nconst ll mod = 1000000007;\n\n#define maxn 1000015\n\nint len, n;\nint a[maxn];\nchar ch[maxn];\nstring s;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(""in.txt"", ""r"", stdin);\n    cin >> s;\n    len = (int)s.length();\n    int run = 1, n = 0;\n    For(i, 1, len - 1){\n        if(s[i] == s[i - 1]) run++;\n        else{\n            n++;\n            ch[n] = s[i - 1];\n            a[n] = run;\n            run = 1;\n        }\n    }\n    n++; ch[n] = s[len - 1]; a[n] = run;\n    bool have = false;\n    For(i, 1, n){\n        if(a[i] >= 2){\n            if(have){\n                a[i] = 1;\n                have = false;\n            }\n            else{\n                a[i] = 2;\n                have = true;\n            }\n        }\n        else have = false;\n    }\n\n    string res = """";\n    For(i, 1, n){\n        Rep(j, a[i]){\n            res.pb(ch[i]);\n        }\n    }\n    cout << res;\n\n    return 0;\n}\n']","['greedy', 'implementation']",1400
https://codeforces.com//contest/1889/problem/F,F. Doremy s Average Tree,Doremy has a rooted tree of size n whose root is vertex r Initially there is a number w i written on vertex i Doremy can use her power to perform this operation k times Choose a vertex x 1 leq x leq n Let s frac 1 T sum i in T w i where T is the set of all vertices in x s subtree For all i in T assign w i s Doremy wants to know what is the lexicographically smallest dagger array w after performing all the operations Can you help her If there are multiple answers you may output any one dagger For arrays a and b both of length n a is lexicographically smaller than b if and only if there exist an index i 1 leq i le n such that a i b i and for all indices j such that j i a j b j is satisfied ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng(0);\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: Generate various types of trees.\n * Source: Own + Dhruv Rohatgi\n */\n\n////////////// DISTRIBUTIONS\n\n// return int in [L,R] inclusive\nint rng_int(int L, int R) {\n\tassert(L <= R);\n\treturn uniform_int_distribution<int>(L, R)(rng);\n}\nll rng_ll(ll L, ll R) {\n\tassert(L <= R);\n\treturn uniform_int_distribution<ll>(L, R)(rng);\n}\n\n// return double in [L,R] inclusive\ndb rng_db(db L, db R) {\n\tassert(L <= R);\n\treturn uniform_real_distribution<db>(L, R)(rng);\n}\n\n// http://cplusplus.com/reference/random/geometric_distribution/geometric_distribution/\n// flip a coin which is heads with probability p until you flip heads\n// mean value of c is 1/p-1\nint rng_geo(db p) {\n\tassert(0 < p && p <= 1);  // p large -> closer to 0\n\treturn geometric_distribution<int>(p)(rng);\n}\n\n////////////// VECTORS + PERMS\n\n// shuffle a vector\ntemplate <class T> void shuf(vector<T> &v) { shuffle(all(v), rng); }\n\n// generate random permutation of [0,N-1]\nvi randPerm(int N) {\n\tvi v(N);\n\tiota(all(v), 0);\n\tshuf(v);\n\treturn v;\n}\n\n// random permutation of [0,N-1] with first element 0\nvi randPermZero(int N) {\n\tvi v(N - 1);\n\tiota(all(v), 1);\n\tshuf(v);\n\tv.ins(bg(v), 0);\n\treturn v;\n}\n\n// shuffle permutation of [0,N-1]\nvi shufPerm(vi v) {\n\tint N = sz(v);\n\tvi key = randPerm(N);\n\tvi res(N);\n\tF0R(i, N) res[key[i]] = key[v[i]];\n\treturn res;\n}\n\n// vector with all entries in [L,R]\nvi rng_vec(int N, int L, int R) {\n\tvi res;\n\tF0R(_, N) res.pb(rng_int(L, R));\n\treturn res;\n}\n\n// vector with all entries in [L,R], unique\nvi rng_vec_unique(int N, int L, int R) {\n\tset<int> so_far;\n\tvi res;\n\tF0R(_, N) {\n\t\tint x;\n\t\tdo { x = rng_int(L, R); } while (so_far.count(x));\n\t\tso_far.ins(x);\n\t\tres.pb(x);\n\t}\n\treturn res;\n}\n\n////////////// GRAPHS\n\n// relabel edges ed according to perm, shuffle\nvpi relabelAndShuffle(vpi ed, vi perm) {\n\teach(t, ed) {\n\t\tt.f = perm[t.f], t.s = perm[t.s];\n\t\tif (rng() & 1) swap(t.f, t.s);\n\t}\n\tshuf(ed);\n\treturn ed;\n}\n\n// shuffle graph with vertices [0,N-1]\nvpi shufGraph(int N, vpi ed) {  // randomly swap endpoints, rearrange labels\n\treturn relabelAndShuffle(ed, randPerm(N));\n}\nvpi shufGraphZero(int N, vpi ed) {\n\treturn relabelAndShuffle(ed, randPermZero(N));\n}\n\n// shuffle tree given N-1 edges\nvpi shufTree(vpi ed) { return shufGraph(sz(ed) + 1, ed); }\n// randomly swap endpoints, rearrange labels\nvpi shufRootedTree(vpi ed) {\n\treturn relabelAndShuffle(ed, randPermZero(sz(ed) + 1));\n}\n\nvoid pgraphOne(int N, vpi ed) {\n\tps(N, sz(ed));\n\teach(e, ed) ps(1 + e.f, 1 + e.s);\n}\n\n////////////// GENERATING TREES\n\n// for generating tall tree\npi geoEdge(int i, db p) {\n\tassert(i > 0);\n\treturn {i, max(0, i - 1 - rng_geo(p))};\n}\n\n// generate edges of tree with verts [0,N-1]\n// smaller back -> taller tree\nvpi treeRand(int N, int back) {\n\tassert(N >= 1 && back >= 0);\n\tvpi ed;\n\tFOR(i, 1, N) ed.eb(i, i - 1 - rng_int(0, min(back, i - 1)));\n\treturn ed;\n}\n\n// generate path\nvpi path(int N) { return treeRand(N, 0); }\n\n// generate tall tree (large diameter)\n// the higher the p the taller the tree\nvpi treeTall(int N, db p) {\n\tassert(N >= 1);\n\tvpi ed;\n\tFOR(i, 1, N) ed.pb(geoEdge(i, p));\n\treturn ed;\n}\n\n// generate tall tree, then add rand at end\nvpi treeTallShort(int N, db p) {\n\tassert(N >= 1);\n\tint mid = (N + 1) / 2;\n\tvpi ed = treeTall(mid, p);\n\tFOR(i, mid, N) ed.eb(i, rng_int(0, i - 1));\n\treturn ed;\n}\n\n// lots of stuff connected to either heavy1 or heavy2\nvpi treeTallHeavy(int N, db p) {\n\tassert(N >= 1);  // + bunch of rand\n\tvpi ed;\n\tint heavy1 = 0, heavy2 = N / 2;\n\tFOR(i, 1, N) {\n\t\tif (i < N / 4) ed.eb(i, heavy1);\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\n\t\telse ed.pb(geoEdge(i, p));\n\t}\n\treturn ed;\n}\n\n// heavy tall tree + random\n// lots of verts connected to heavy1 or heavy2\nvpi treeTallHeavyShort(int N, db p) {\n\tassert(N >= 1);  // + almost-path + rand\n\tvpi ed;\n\tint heavy1 = 0, heavy2 = N / 2;\n\tFOR(i, 1, N) {\n\t\tif (i < N / 4) ed.eb(i, heavy1);\n\t\telse if (i <= heavy2) ed.pb(geoEdge(i, p));  // tall -> heavy1\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\n\t\telse ed.eb(i, rng_int(0, i - 1));\n\t}\n\treturn ed;\n}\n\nint rand_prime(int l, int r) {\n\twhile (1) {\n\t\tint x = rng_int(l, r);\n\t\tbool bad = 0;\n\t\tfor (int i = 2; i * i <= x; ++i)\n\t\t\tif (x % i == 0) bad = 1;\n\t\tif (!bad) return x;\n\t}\n}\n\nstruct Frac {\n\tll n, d;\n\tbool operator<(const Frac &o) const { return n * o.d < o.n * d; }\n\tbool operator==(const Frac &o) const { return n * o.d == o.n * d; }  // OK\n};\n\nostream &operator<<(ostream &os, const Frac &f) {\n\tos << ""Frac("" << f.n << "", "" << f.d << "")"";\n\treturn os;\n}\n\nstruct RangeInfo {\n\tpair<int, Frac> d0, d1;\n\tbool single_value() const { return d1.f == INT_MAX; }\n\tpair<int, Frac> first_dif(Frac f) const {\n\t\tif (d0.s == f) return d1;\n\t\treturn d0;\n\t}\n\tbool greater_than(Frac f) {\n\t\tauto [idx, val] = first_dif(f);\n\t\tif (idx == INT_MAX) return false;\n\t\tassert(!(f == val));\n\t\treturn f < val;\n\t}\n\tbool greater_or_equal(Frac f) {\n\t\tauto [idx, val] = first_dif(f);\n\t\tif (idx == INT_MAX) return true;\n\t\tassert(!(f == val));\n\t\treturn f < val;\n\t}\n};\n\nostream &operator<<(ostream &os, const pair<int, Frac> &p) {\n\tos << ""{"" << p.f << "", "" << p.s << ""}"";\n\treturn os;\n}\n\nostream &operator<<(ostream &os, const RangeInfo &i) {\n\tos << ""RangeInfo{"" << i.d0 << "", "" << i.d1 << ""}"";\n\treturn os;\n}\n\nRangeInfo operator+(RangeInfo l, RangeInfo r) {\n\tif (l.d0.f > r.d0.f) swap(l, r);\n\tassert(l.d0.f < r.d0.f);\n\treturn RangeInfo{l.d0, min(l.d1, l.d0.s == r.d0.s ? r.d1 : r.d0)};\n}\n\nstruct Info {\n\tint k, first_different;\n\tpi prev_pair;\n\tRangeInfo r;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n\tos << ""Info{"" << i.k << "", "" << i.first_different << "", ""\n\t   << ""{"" << i.prev_pair.f << "", "" << i.prev_pair.s << ""}""\n\t   << "", "" << i.r << ""}"";\n\treturn os;\n}\n\nInfo info_single(int x, int w) {\n\treturn {0, INT_MAX, {-1, -1}, RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}};\n}\n\nint N, K;\nV<V<Info>> dp, stor;\nvi W;\nV<vi> adj;\nvl sum;\nvi num;\n\nV<Info> conv(const V<Info> &dp_l, const V<Info> &dp_r) {\n\t// dbg(""COMPUTING"", sz(dp_l), sz(dp_r));\n\tint max_ops = min(dp_l.bk.k + dp_r.bk.k, K);\n\tV<vpi> cands(max_ops + 1);\n\tF0R(i, sz(dp_l)) F0R(j, sz(dp_r)) if (dp_l[i].k + dp_r[j].k <= K) {\n\t\tcands[dp_l[i].k + dp_r[j].k].pb({i, j});\n\t}\n\tauto better_pair = [&](pi a, pi b) {\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\n\t\tswap(a, b);\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\n\t\tif (a.f > b.f) swap(a, b);\n\t\tassert(a.f < b.f && a.s > b.s);\n\t\tint min_dif_a = INT_MAX;\n\t\tFOR(i, a.f + 1, b.f + 1) ckmin(min_dif_a, dp_l.at(i).first_different);\n\t\tint min_dif_b = INT_MAX;\n\t\tFOR(i, b.s + 1, a.s + 1) ckmin(min_dif_b, dp_r.at(i).first_different);\n\t\tif (min_dif_a < min_dif_b) return b;\n\t\treturn a;\n\t};\n\tauto first_different = [&](pi a, pi b) {\n\t\tint min_dif = INT_MAX;\n\t\tFOR(i, min(a.f, b.f) + 1, max(a.f, b.f) + 1)\n\t\tckmin(min_dif, dp_l.at(i).first_different);\n\t\tFOR(i, min(a.s, b.s) + 1, max(a.s, b.s) + 1)\n\t\tckmin(min_dif, dp_r.at(i).first_different);\n\t\treturn min_dif;\n\t};\n\tvpi best;\n\tF0R(i, sz(cands)) {\n\t\twhile (sz(cands[i]) > 1) {\n\t\t\tend(cands[i])[-2] =\n\t\t\t    better_pair(end(cands[i])[-2], end(cands[i])[-1]);\n\t\t\tcands[i].pop_back();\n\t\t}\n\t\tif (sz(cands[i])) {\n\t\t\tif (sz(best) && better_pair(best.bk, cands[i].bk) == best.bk)\n\t\t\t\tcontinue;\n\t\t\tbest.pb(cands[i].bk);\n\t\t\t// ret.pb();\n\t\t}\n\t}\n\tV<Info> ndp;\n\tF0R(i, sz(best)) {\n\t\tauto [l, r] = best[i];\n\t\tndp.pb({dp_l[l].k + dp_r[r].k,\n\t\t        i == 0 ? INT_MAX : first_different(best.at(i - 1), best.at(i)),\n\t\t        {l, r},\n\t\t        dp_l[l].r + dp_r[r].r});\n\t}\n\treturn ndp;\n\t// V<Info> ndp;\n\t// F0R(ops, max_ops + 1) {  // SLOW\n\t// \tint l = 0, r = 0;\n\t// \tint last_mn = INT_MAX;\n\t// \twhile (true) {\n\t// \t\tint mn = INT_MAX;\n\t// \t\tpi best;\n\t// \t\tFOR(i, l + 1, sz(dp_l))\n\t// \t\tif (dp_l[i].k + dp_r[r].k <= ops) {\n\t// \t\t\tif (ckmin(mn, dp_l[i].first_different)) { best = {0, i}; }\n\t// \t\t} else break;\n\t// \t\tFOR(j, r + 1, sz(dp_r))\n\t// \t\tif (dp_l[l].k + dp_r[j].k <= ops) {\n\t// \t\t\tif (ckmin(mn, dp_r[j].first_different)) { best = {1, j}; }\n\t// \t\t} else break;\n\t// \t\tif (mn == INT_MAX) {\n\t// \t\t\tif (dp_l[l].k + dp_r[r].k == ops) {\n\t// \t\t\t\tndp.pb({ops, last_mn, {l, r}, dp_l[l].r + dp_r[r].r});\n\t// \t\t\t}\n\t// \t\t\tbreak;\n\t// \t\t} else {\n\t// \t\t\tif (best.f == 0) l = best.s;\n\t// \t\t\telse r = best.s;\n\t// \t\t\tlast_mn = mn;\n\t// \t\t}\n\t// \t}\n\t// }\n\t// return ret;\n}\n\nvoid construct(int x, int p) {\n\tsum[x] = W[x];\n\tnum[x] = 1;\n\tdp[x] = {info_single(x, W[x])};\n\n\t// {{INT_MAX, RangeInfo{{x, Frac{W[x], 1}}, {INT_MAX, {}}}}};\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tconstruct(y, x);\n\t\t\tsum[x] += sum[y];\n\t\t\tnum[x] += num[y];\n\t\t\tauto ndp = conv(dp[x], dp[y]);\n\t\t\tswap(dp[x], stor[y]);\n\t\t\tswap(dp[x], ndp);\n\t\t}\n\tFrac f{sum[x], num[x]};\n\tif (!dp[x][0].r.greater_than(f)) return;\n\tif (sz(dp[x]) > 1) {\n\t\tassert(dp[x].at(1).k == 1);\n\t\tif (!dp[x].at(1).r.greater_than(f)) return;\n\t}\n\tint idx = 1;\n\twhile (idx < sz(dp[x]) && dp[x][idx].r.greater_or_equal(f)) ++idx;\n\tV<Info> ndp{dp[x][0]};\n\t{\n\t\tRangeInfo r{{dp[x][0].r.d0.f, f}, {INT_MAX, {}}};\n\t\tndp.pb({1, dp[x][0].r.first_dif(f).f, {-1, -1}, r});\n\t}\n\tif (idx < sz(dp[x])) {\n\t\tFOR(i, idx, sz(dp[x])) {\n\t\t\tassert(!dp[x][i].r.greater_or_equal(f));\n\t\t\tif (i == idx) {\n\t\t\t\tdp[x][i].first_different = dp[x][i].r.first_dif(f).f;\n\t\t\t\tndp.pb(dp[x][i]);\n\t\t\t} else {\n\t\t\t\tndp.pb(dp[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dp[x], ndp);\n}\n\nvoid reconstruct(vi &ans, int idx, int x, int p) {\n\tif (idx == 0) return;\n\tassert(idx < sz(dp[x]));\n\tauto [lhs, rhs] = dp[x].at(idx).prev_pair;\n\tif (lhs == -1) {\n\t\tans.pb(x);\n\t\treturn;\n\t}\n\tassert(lhs >= 0 && rhs >= 0);\n\tR0F(y_idx, sz(adj[x])) {\n\t\tint y = adj[x][y_idx];\n\t\tif (y == p) continue;\n\t\tassert(lhs < sz(stor[y]));\n\t\tassert(rhs < sz(dp[y]));\n\t\treconstruct(ans, rhs, y, x);\n\t\ttie(lhs, rhs) = stor[y].at(lhs).prev_pair;\n\t}\n\tassert(lhs == -1 && rhs == -1);\n}\n\nstruct NaiveSol {\n\tV<pair<int, Frac>> result;\n\tvi moves;\n};\n\ntemplate <class T> V<T> operator+(V<T> a, V<T> b) {\n\ta.ins(end(a), all(b));\n\treturn a;\n}\n\nNaiveSol operator+(NaiveSol a, NaiveSol b) {\n\tNaiveSol c{a.result + b.result, a.moves + b.moves};\n\tsor(c.result);\n\treturn c;\n}\n\nV<NaiveSol> brute(int x, int p) {\n\tsum[x] = W[x];\n\tnum[x] = 1;\n\tV<NaiveSol> dp;\n\tdp.pb({{{x, Frac{W[x], 1}}}, {}});\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tauto child_dp = brute(y, x);\n\t\t\tsum[x] += sum[y];\n\t\t\tnum[x] += num[y];\n\t\t\tV<NaiveSol> ndp;\n\t\t\tF0R(i, sz(dp)) F0R(j, sz(child_dp)) if (i + j <= K) {\n\t\t\t\tauto s = dp[i] + child_dp[j];\n\t\t\t\tif (i + j == sz(ndp)) {\n\t\t\t\t\tndp.pb(s);\n\t\t\t\t} else {\n\t\t\t\t\tif (s.result < ndp.at(i + j).result) ndp.at(i + j) = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp, ndp);\n\t\t}\n\t{\n\t\tauto result = dp.at(0).result;\n\t\teach(t, result) t.s = Frac{sum[x], num[x]};\n\t\tNaiveSol kill_sub{result, {x}};\n\t\tif (sz(dp) == 1) dp.pb(kill_sub);\n\t\telse if (kill_sub.result < dp[1].result) dp[1] = kill_sub;\n\t}\n\treturn dp;\n}\n\nvi solve1(int R) {\n\tauto cands = brute(R, 0);\n\tFOR(i, 1, sz(cands)) if (cands[i].result < cands[0].result) {\n\t\tcands[0] = cands[i];\n\t}\n\tvi ans = cands[0].moves;\n\treturn ans;\n}\n\nvi solve2(int R) {\n\tconstruct(R, 0);\n\tint k = dp[R].bk.k;\n\tvi ans;\n\treconstruct(ans, sz(dp[R]) - 1, R, 0);\n\tassert(sz(ans) == k);\n\treturn ans;\n}\n\n/**\n * Description: wraps a lambda so it can call itself\n * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\n */\n\nnamespace std {\n\ntemplate <class Fun> class y_combinator_result {\n\tFun fun_;\n\n  public:\n\ttemplate <class T>\n\texplicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\n\n\ttemplate <class... Args> decltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate <class Fun> decltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n}  // namespace std\n\nvoid y_comb_demo() {\n\tcout << y_combinator([](auto gcd, int a, int b) -> int {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t})(20, 30)\n\t     << ""\\n"";  // outputs 10\n}\n\nV<Frac> eval(int R, vi v) {\n\tV<Frac> res(N + 1);\n\t// dbg(""EVAL"", R, v);\n\ty_combinator([&](auto dfs_set, int x, int p, Frac val) -> void {\n\t\tif (!val.d) {\n\t\t\tif (find(all(v), x) != end(v)) val = Frac{sum[x], num[x]};\n\t\t}\n\t\t// dbg(""AT"", x, p, val);\n\t\tif (val.d) {\n\t\t\tres[x] = val;\n\t\t} else {\n\t\t\tres[x] = Frac{W[x], 1};\n\t\t}\n\t\tfor (int y : adj[x])\n\t\t\tif (y != p) dfs_set(y, x, val);\n\t})(R, 0, Frac{});\n\treturn res;\n}\n\nvoid solve(int tc, bool gen = true) {\n\t// dbg(""DOING"", tc);\n\tint R;\n\tif (gen) {\n\t\tN = 6;\n\t\t// N = rng_int(2, 5);\n\t\tR = rng_int(1, N);\n\t\tK = rng_int(0, N);\n\t} else {\n\t\tre(N, R, K);\n\t}\n\tW.rsz(N + 1);\n\tint mx = rng_int(1, 10);\n\tFOR(i, 1, N + 1) {\n\t\tif (gen) {\n\t\t\tW[i] = rng_int(1, mx);\n\t\t} else re(W[i]);\n\t}\n\tadj = V<vi>(N + 1);\n\tFOR(i, 2, N + 1) {\n\t\tif (gen) {\n\t\t\tint u = rng_int(1, i - 1), v = i;\n\t\t\tadj[u].pb(v), adj[v].pb(u);\n\t\t} else {\n\t\t\tdef(int, u, v);\n\t\t\tadj[u].pb(v), adj[v].pb(u);\n\t\t}\n\t}\n\t// dbg(tc);\n\t// if (tc == 47336) { dbg(N, R, K, W, adj); }\n\tdp = {};\n\tdp.rsz(N + 1);\n\tstor = {};\n\tstor.rsz(N + 1);\n\tsum = vl(N + 1);\n\tnum = vi(N + 1);\n\n\t// vi ans = solve1(R);\n\tvi ans = solve2(R);\n\t// ps(eval(R, ans));\n\t// if (!gen) {\n\tps(sz(ans));\n\tps(ans);\n\t// } else {\n\t// \tif (eval(R, ans) != eval(R, ans2)) {\n\t// \t\tdbg(""WHOOPS"", tc, N, R, K, W, adj);\n\t// \t\tdbg(ans, eval(R, ans));\n\t// \t\tdbg(ans2, eval(R, ans2));\n\t// \t\tFOR(i, 1, N + 1) dbg(i, dp[i]);\n\t// \t\texit(0);\n\t// \t}\n\t// }\n}\n\nint main() {\n\tsetIO();\n\t// RangeInfo r1{{1, Frac{2, 5}}, {2, Frac{2, 7}}};\n\t// RangeInfo r2{{3, Frac{2, 6}}, {4, Frac{2, 3}}};\n\t// auto r3 = r1 + r2;\n\t// dbg(r3.d0.f, r3.d1.f);\n\t// exit(0);\n\n\t// RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}\n\t// ps(Frac{1, 2} < Frac{2, 4});\n\t// ps(Frac{2, 4} < Frac{1, 2});\n\t// ps(Frac{1, 2} < Frac{2, 3});\n\t// exit(0);\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i, false);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['data structures', 'dp', 'greedy', 'trees']",3500
https://codeforces.com//contest/1098/problem/E,E. Fedya the Potter,Fedya loves problems involving data structures Especially ones about different queries on subsegments Fedya had a nice array a 1 a 2 ldots a n and a beautiful data structure This data structure given l and r 1 le l le r le n could find the greatest integer d such that d divides each of a l a l 1 a r Fedya really likes this data structure so he applied it to every non empty contiguous subarray of array a put all answers into the array and sorted it He called this array b It s easy to see that array b contains n n 1 2 elements After that Fedya implemented another cool data structure that allowed him to find sum b l b l 1 ldots b r for given l and r 1 le l le r le n n 1 2 Surely Fedya applied this data structure to every contiguous subarray of array b called the result c and sorted it Help Fedya find the lower median of array c Recall that for a sorted array of length k the is an element at position lfloor frac k 1 2 rfloor if elements of the array are enumerated starting from 1 For example the lower median of array 1 1 2 3 6 is 2 and the lower median of 0 17 23 96 is 17 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n\nint n;\nint tab[nax];\n\nll ile[nax];\n\nll m;\n\nvoid rek(int a, int b)\n{\n\tif (a>b)\n\t\treturn;\n\tint s=(a+b)>>1;\n\tvector <pll> l, p;\n\tint x=0;\n\tfor (int i=s; i>=a; i--)\n\t{\n\t\tx=__gcd(x, tab[i]);\n\t\tif (l.empty() || x!=l.back().first)\n\t\t\tl.push_back({x, 0});\n\t\tl.back().second++;\n\t}\n\tx=0;\n\tfor (int i=s; i<=b; i++)\n\t{\n\t\tx=__gcd(x, tab[i]);\n\t\tif (p.empty() || x!=p.back().first)\n\t\t\tp.push_back({x, 0});\n\t\tp.back().second++;\n\t}\n\tfor (pll i : l)\n\t\tfor (pll j : p)\n\t\t\tile[__gcd(i.first, j.first)]+=i.second*j.second;\n\trek(a, s-1);\n\trek(s+1, b);\n}\n\nll brut(ll v)\n{\n\tvll wek;\n\tfor (int i=1; i<nax; i++)\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t\twek.push_back(i);\n\tll ret=0;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=i; j<(int)wek.size(); j++)\n\t\t{\n\t\t\ts+=wek[j];\n\t\t\tif (s>v)\n\t\t\t\tbreak;\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll brut2(ll v)\n{\n\tvll wek;\n\tfor (int i=1; i<nax; i++)\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t\twek.push_back(i);\n\tll ret=0;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=i; j<(int)wek.size(); j++)\n\t\t{\n\t\t\ts+=wek[j];\n\t\t\tif (s>v)\n\t\t\t\tbreak;\n\t\t\tif (wek[j]!=wek[i])\n\t\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll daj(pll v)\n{\n\treturn v.first*v.second;\n}\n\nll sum[nax];\n\nll magiabr(ll lim, ll a, ll m1, ll b, ll m2)\n{\n\tll ret=0;\n\tfor (ll i=1; i<=m1; i++)\n\t\tfor (ll j=1; j<=m2; j++)\n\t\t\tif (i*a+j*b<=lim)\n\t\t\t\tret++;\n\t//~ debug() << imie(ret);\n\treturn ret;\n}\n\nnamespace copypaste\n{\n  void eukl(ll &x, ll &y, ll a, ll b) {\n  if (!a) { x = 0; y = 1; return; }\n  eukl(y, x, b % a, a);\n  x -= y * (b / a);\n}\n\nll euklides(ll y, ll x, ll d)\n{\n\tif (!y)\n\t\treturn d+1;\n\tif (y>=x)\n\t{\n\t\tll dz=y/x;\n\t\tll ile=d*(d+1)/2;\n\t\treturn euklides(y%x, x, d)+dz*ile;\n\t}\n\telse\n\t{\n\t\tll ile=(d*y+x-1)/x;\n\t\tll sum=(d+1)*(ile+1)+1+d/x+((ile*x)/y-d);\n\t\treturn sum-euklides(x, y, ile);\n\t}\n}\n\nll main2(ll a, ll b, ll c)\n{\n\t//~ ll a, b, c;\n\t//~ scanf(""%lld%lld%lld"", &a, &b, &c);\n\tif (a>c || b>c)\n\t{\n\t\t//~ printf(""%lld\\n"", 1+c/a+c/b);\n\t\treturn 1+c/a+c/b;\n\t\t//~ return 0;\n\t}\n\tll g=__gcd(a, b);\n\tc/=g;\n\ta/=g;\n\tb/=g;\n\tll x, y;\n\teukl(x, y, a, b);\n\tx*=(c%a);\n\ty*=(c%a);\n\tx+=(c/a);\n\tassert(x*a+b*y==c);\n\t\n\tif (x<0)\n\t{\n\t\tll ile=(-x-1)/b;\n\t\tx+=ile*b;\n\t\ty-=ile*a;\n\t}\n\tif (x>=0)\n\t{\n\t\tll ile=x/b+1;\n\t\tx-=ile*b;\n\t\ty+=ile*a;\n\t}\n\t\n\tassert(x*a+b*y==c);\n\tassert(x<0);\n\tassert(x+b>=0);\n\t\n\tll p=c/b;\n\t\n\tll wyn=x*(p+1);\n\twyn-=euklides(b, a, y-p-1);\n\twyn+=euklides(b, a, y);\n\t\n\treturn wyn;\n\t//~ printf(""%lld\\n"", wyn);\n\t//~ return 0;\n}\n}//copy\n\nll trzesienie(ll a, ll b, ll c) {\n\tif (c<0) return 0;\n\tif (a>b) swap(a, b);\n\tll p=c/b;\n\tll k=b/a;\n\tll d=(c-p*b)/a;\n\treturn trzesienie(b-k*a, a, c-a*(k*p+d+1))+(p+1)*(d+1)+k*p*(p+1)/2;\n}\n\nll eukl(ll lim, ll a, ll b)\n{\n\tif (lim<0)\n\t\treturn 0;\n\treturn trzesienie(a, b, lim);\n\t//~ if (!a)\n\t\t//~ return lim/b+1;\n\t//~ if (!b)\n\t\t//~ return lim/a+1;\n\t//~ ll ret=0;\n\t//~ for (ll i=0; i*a<=lim; i++)\n\t//~ {\n\t\t//~ for (ll j=0; j*b<=lim; j++)\n\t\t\t//~ if (i*a+j*b<=lim)\n\t\t\t\t//~ ret++;\n\t//~ }\n\t//~ return ret;\n}\n\nll magia(ll lim, ll a, ll x, ll b, ll y)\n{\n\tlim-=a+b;\n\tif (lim<0)\n\t\treturn 0;\n\tif (lim>=(x-1)*a+(y-1)*b)\n\t\treturn x*y;\n\t//~ return eukl(lim, a, x, b, y);\n\treturn eukl(lim, a, b)-eukl(lim-x*a, a, b)-eukl(lim-y*b, a, b)+eukl(lim-x*a-y*b, a, b);\n}\n\nll licz(ll v)\n{\n\t//~ return brut(v);\n\tll ret=0;\n\tfor (int i=1; i<nax; i++)\n\t{\n\t\tif (!ile[i])\n\t\t\tcontinue;\n\t\tll w=min(ile[i], v/i);\n\t\tret+=w*(2*ile[i]-w+1)/2;\n\t}\n\t//~ return ret+brut2(v);\n\tvector<pll> wek;\n\tfor (int i=1; i<nax; i++)\n\t\tif (ile[i])\n\t\t\twek.push_back({i, ile[i]});\n\tint r=wek.size();\n\tint w=0;\n\tll trz=0;\n\tsum[0]=0;\n\tfor (int i=0; i<r; i++)\n\t\tsum[i+1]=sum[i]+wek[i].second;\n\t//~ debug() << ""jade "" << v << "" "" << wek;\n\tfor (int i=0; i<r; i++)\n\t{\n\t\tw=max(w, i);\n\t\tif (w==i)\n\t\t\ttrz=0;\n\t\twhile(w+1<r && trz+daj(wek[w+1])<=v)\n\t\t{\n\t\t\tw++;\n\t\t\ttrz+=daj(wek[w]);\n\t\t}\n\t\tif (w+1!=r)\n\t\t\tret+=magia(v-trz, wek[i].first, wek[i].second, wek[w+1].first, wek[w+1].second);\n\t\t//~ debug() << ""kurwa "" << i << "" "" << w << ""    "" << trz;\n\t\tll ter=trz;\n\t\tfor (int j=w; j>i; j--)\n\t\t{\n\t\t\tter-=daj(wek[j]);\n\t\t\tif (ter+daj(wek[j])+daj(wek[i])<=v)\n\t\t\t{\n\t\t\t\tret+=wek[i].second*(sum[j+1]-sum[i+1]);\n\t\t\t\t//~ debug() << ""hurt "" << wek[i].second*(sum[j+1]-sum[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret+=magia(v-ter, wek[i].first, wek[i].second, wek[j].first, wek[j].second);\n\t\t}\n\t\t\n\t\tif (i+1!=r)\n\t\t\ttrz-=daj(wek[i+1]);\n\t}\n\t//~ assert(ret==brut(v));\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\trek(1, n);\n\t//~ for (int i=1; i<nax; i++)\n\t\t//~ if (ile[i])\n\t\t\t//~ debug() << i << "" "" << ile[i];\n\tll pom=n*(n+1LL)/2;\n\tm=(pom*(pom+1))/2;\n\tm=(m+1)/2;\n\tdebug() << imie(m);\n\tll bsa=1;\n\tll bsb=0;\n\tfor (int i=1; i<nax; i++)\n\t\tbsb+=i*ile[i];\n\t//~ debug() << imie(bsb);\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb)>>1;\n\t\tif (licz(bss)>=m)\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\tprintf(""%lld\\n"", bsa);\n\treturn 0;\n}\n']","['binary search', 'implementation', 'math', 'number theory']",3400
https://codeforces.com//contest/830/problem/A,A. Office Keys,There are people and keys on a straight line Every person wants to get to the office which is located on the line as well To do that he needs to reach some point with a key take the key and then go to the office Once a key is taken by somebody it couldn t be taken by anybody else You are to determine the minimum time needed for all people to get to the office with keys Assume that people move a unit distance per second If two people reach a key at the same time only one of them can take the key A person can pass through a point with a key without taking it ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint A[1100],B[2100],n,K,p;\nint check(long long lim){\n\tint now=1;\n\tfor (int i=1;i<=K;i++)\n\t\tif (abs(B[i]-A[now])+abs(B[i]-p)<=lim){\n\t\t\tnow++; if (now>n) return 1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tscanf(""%d%d%d"",&n,&K,&p);\n\tfor (int i=1;i<=n;i++) scanf(""%d"",&A[i]);\n\tfor (int i=1;i<=K;i++) scanf(""%d"",&B[i]);\n\tsort(A+1,A+n+1);\n\tsort(B+1,B+K+1);\n\tlong long l=0,r=2e9+10,ans=0;\n\twhile (l<r){\n\t\tlong long mid=l+r>>1;\n\t\tif (check(mid)) r=mid,ans=mid; else l=mid+1;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}']","['binary search', 'brute force', 'dp', 'greedy', 'sortings']",1800
https://codeforces.com//contest/903/problem/G,G. Yet Another Maxflow Problem,In this problem you will have to deal with a very special network The network consists of two parts part and part Each part consists of vertices th vertex of part is denoted as and th vertex of part is denoted as For each index there is a directed edge from vertex to vertex and from to respectively Capacities of these edges are given in the input Also there might be several directed edges going from part to part but never from to You have to calculate the maximum flow value from to in this network Capacities of edges connecting to might sometimes change and you also have to maintain the maximum flow value after these changes Apart from that the network is fixed there are no changes in part no changes of edges going from to and no edge insertions or deletions Take a look at the example and the notes to understand the structure of the network better ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nclass Node {\npublic:\n\tll mn, v;\n\tNode() {\n\t\tmn = v = 0;\n\t}\n};\nNode indt[600000];\nvoid propagate(int n) {\n\tll v = indt[n].v;\n\tindt[2 * n].mn += v;\n\tindt[2 * n].v += v;\n\tindt[2 * n + 1].mn += v;\n\tindt[2 * n + 1].v += v;\n\tindt[n].v = 0;\n}\nvoid update(int st, int en, int S, int E, int n, ll v) {\n\tif (en < S || E < st) return;\n\tif (st <= S && E <= en) {\n\t\tindt[n].v += v;\n\t\tindt[n].mn += v;\n\t\treturn;\n\t}\n\tpropagate(n);\n\n\tint M = (S + E) / 2;\n\tupdate(st, en, S, M, 2 * n, v);\n\tupdate(st, en, M + 1, E, 2 * n + 1, v);\n\tindt[n].mn = min(indt[2 * n].mn, indt[2 * n + 1].mn);\n}\nll getmn(int st, int en, int S, int E, int n) {\n\tif (en < S || E < st) return LL_INF;\n\tif (st <= S && E <= en) return indt[n].mn;\n\tpropagate(n);\n\n\tint M = (S + E) / 2;\n\treturn min(getmn(st, en, S, M, 2 * n), getmn(st, en, M + 1, E, 2 * n + 1));\n}\n\nll X[200050];\nll Y[200050];\nvector <pll> Ve[200050];\n\nll ans[200050];\nmultiset <ll> Sa;\nint main() {\n\tint N, M, Q, i, j;\n\tscanf(""%d %d %d"", &N, &M, &Q);\n\tfor (i = 1; i < N; i++) scanf(""%lld %lld"", &X[i], &Y[i]);\n\n\tfor (i = 1; i < N; i++) update(i, i, 0, IT_MAX - 1, 1, Y[i]);\n\twhile (M--) {\n\t\tint t1, t2, t3;\n\t\tscanf(""%d %d %d"", &t1, &t2, &t3);\n\t\tVe[t1].emplace_back(t3, t2);\n\t}\n\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (auto it : Ve[i]) update(0, it.second - 1, 0, IT_MAX - 1, 1, it.first);\n\t\tans[i] = getmn(0, N - 1, 0, IT_MAX - 1, 1);\n\t}\n\tfor (i = 1; i <= N; i++) {\n\t\tans[i] += X[i];\n\t\tSa.insert(ans[i]);\n\t}\n\tprintf(""%lld\\n"", *(Sa.begin()));\n\twhile (Q--) {\n\t\tint t1, t2;\n\t\tscanf(""%d %d"", &t1, &t2);\n\t\tSa.erase(Sa.lower_bound(ans[t1]));\n\t\tans[t1] -= X[t1];\n\t\tX[t1] = t2;\n\t\tans[t1] += X[t1];\n\t\tSa.insert(ans[t1]);\n\t\tprintf(""%lld\\n"", *(Sa.begin()));\n\t}\n\treturn 0;\n}']","['data structures', 'flows', 'graphs']",2700
https://codeforces.com//contest/1130/problem/A,A. Be Positive,You are given an array of n integers a 1 a 2 ldots a n Your task is to find some d 10 3 leq d leq 10 3 such that after each number in the array is divided by d the number of positive numbers that are presented in the array is greater than or equal to half of the array size i e at least lceil frac n 2 rceil Note that those positive numbers do not need to be an integer e g a 2 5 counts as a positive number If there are multiple values of d that satisfy the condition you may print any of them In case that there is no such d print a single integer 0 Recall that lceil x rceil represents the smallest integer that is not less than x and that zero 0 is neither positive nor negative ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, d, u, x;\n\nint main()\n{\n\t\n\tscanf(""%d"", &n);\n\tfor(int i=0; i<n; ++i)\n\t{\n\t\tscanf(""%d"", &x);\n\t\tif(x>0)\n\t\t{\n\t\t\t++d;\n\t\t}\n\t\telse if(x<0)\n\t\t{\n\t\t\t++u;\n\t\t}\n\t}\n\tif(d*2>=n)\n\t{\n\t\tprintf(""1"");\n\t}\n\telse if(u*2>=n)\n\t{\n\t\tprintf(""-1"");\n\t}\n\telse\n\t{\n\t\tprintf(""0"");\n\t}\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1656/problem/E,E. Equal Tree Sums,You are given an undirected unrooted tree i e a connected undirected graph without cycles You must assign a integer weight to each vertex so that the following is satisfied if any vertex of the tree is removed then each of the remaining connected components has the same sum of weights in its vertices ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--;\n        v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<int> ans(n);\n    auto dfs = [&](auto self, int u, int p, int x) -> void {\n        ans[u] = x;\n        for (auto v : adj[u]) {\n            if (v == p) {\n                continue;\n            }\n            self(self, v, u, x == 0 ? 1 : -x);\n            ans[u] -= x == 0 ? 1 : -x;\n        }\n    };\n    dfs(dfs, 0, -1, 0);\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'dfs and similar', 'math', 'trees']",2200
https://codeforces.com//contest/705/problem/A,A. Hulk,Dr Bruce Banner hates his enemies like others don t As we all know he can barely talk when he turns into the incredible Hulk That s why he asked you to help him to express his feelings Hulk likes the Inception so much and like that his feelings are complicated They have layers The first layer is hate second one is love third one is hate and so on For example if then his feeling is or if it s and if it s and so on Please help Dr Banner ,"['#include ""stdio.h""\n\nint n;\n\nint main(){\n\tscanf(""%d"",&n);\n\tprintf(""I hate"");\n\tfor(int i = 1; i < n; i++){\n\t\tif(i%2==1) printf("" that I love"");\n\t\telse printf("" that I hate"");\n\t}\n\tprintf("" it\\n"");\n}']",['implementation'],800
https://codeforces.com//contest/1605/problem/A,A. A.M. Deviation,A number a 2 is said to be the arithmetic mean of two numbers a 1 and a 3 if the following condition holds a 1 a 3 2 cdot a 2 We define an arithmetic mean deviation of three numbers a 1 a 2 and a 3 as follows d a 1 a 2 a 3 a 1 a 3 2 cdot a 2 Arithmetic means a lot to Jeevan He has three numbers a 1 a 2 and a 3 and he wants to minimize the arithmetic mean deviation d a 1 a 2 a 3 To do so he can perform the following operation any number of times possibly zero Choose i j from 1 2 3 such that i ne j and increment a i by 1 and decrement a j by 1 Help Jeevan find out the minimum value of d a 1 a 2 a 3 that can be obtained after applying the operation any number of times ,"['// Problem: A. A.M. Deviation\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/A\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),m=read(),k=read();\n\t\tif((n+m+k)%3) puts(""1""); else puts(""0"");\n\t}\n\treturn 0;\n}']","['math', 'number theory']",800
https://codeforces.com//contest/650/problem/E,E. Clockwork Bomb,My name is James diGriz I m the most clever robber and treasure hunter in the whole galaxy There are books written about my adventures and songs about my operations though you were able to catch me up in a pretty awkward moment I was able to hide from cameras outsmart all the guards and pass numerous traps but when I finally reached the treasure box and opened it I have accidentally started the clockwork bomb Luckily I have met such kind of bombs before and I know that the clockwork mechanism can be stopped by connecting contacts with wires on the control panel of the bomb in a certain manner I see contacts connected by wires Contacts are numbered with integers from to Bomb has a security mechanism that ensures the following condition if there exist contacts forming a circuit i e there exist wires between contacts and and and then the bomb immediately explodes and my story ends here In particular if two contacts are connected by more than one wire they form a circuit of length It is also prohibited to connect a contact with itself On the other hand if I disconnect more than one wire i e at some moment there will be no more than wires in the scheme then the other security check fails and the bomb also explodes So the only thing I can do is to unplug some wire and plug it into a new place ensuring the fact that no circuits appear I know how I should put the wires in order to stop the clockwork But my time is running out Help me get out of this alive find the sequence of operations each of which consists of unplugging some wire and putting it into another place so that the bomb is defused ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint p[N];\n\ninline int find_set(int x) {\n  if (x != p[x]) {\n    p[x] = find_set(p[x]);\n  }\n  return p[x];\n}\n\nvector < pair <int, int> > edges[N];\n\ninline void unite(int x, int y) {\n  x = find_set(x);\n  y = find_set(y);\n  if (x == y) {\n    return;\n  }\n  p[x] = y;\n  if (edges[x].size() > edges[y].size()) {\n    swap(edges[x], edges[y]);\n  }\n  while (!edges[x].empty()) {\n    edges[y].push_back(edges[x].back());\n    edges[x].pop_back();\n  }\n}\n\nvector < pair <int, int> > g[N];\nbool rem[N], add[N];\nbool done[N];\nint bx[N], by[N];\n\ninline void dfs(int v, int pr) {\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    dfs(u, v);\n    int id = g[v][j].second;\n    if (!rem[id]) {\n      unite(u, v);\n      continue;\n    }\n    pair <int, int> e = edges[u].back();\n    while (done[e.second]) {\n      edges[u].pop_back();\n      e = edges[u].back();\n    }\n    done[e.second] = true;\n    printf(""%d %d %d %d\\n"", u + 1, v + 1, bx[e.second] + 1, by[e.second] + 1);\n    edges[u].pop_back();\n    unite(u, e.first);\n  }\n}\n\nint ax[N], ay[N];\npair < pair <int, int>, int > ev[2 * N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n - 1; i++) {\n    scanf(""%d %d"", ax + i, ay + i);\n    ax[i]--; ay[i]--;\n    if (ax[i] > ay[i]) {\n      swap(ax[i], ay[i]);\n    }\n    ev[i] = make_pair(make_pair(ax[i], ay[i]), i);\n    rem[i] = false;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    scanf(""%d %d"", bx + i, by + i);\n    bx[i]--; by[i]--;\n    if (bx[i] > by[i]) {\n      swap(bx[i], by[i]);\n    }\n    ev[n - 1 + i] = make_pair(make_pair(bx[i], by[i]), ~i);\n    add[i] = false;\n  }\n  sort(ev, ev + n - 1 + n - 1);\n  int ans = 0;\n  for (int i = n - 1 + n - 1 - 1; i >= 0; i--) {\n    if (i > 0 && ev[i].first == ev[i - 1].first) {\n      i--;\n      continue;\n    }\n    int x = ev[i].second;\n    if (x >= 0) {\n      rem[x] = true;\n      ans++;\n    } else {\n      add[~x] = true;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    g[ax[i]].push_back(make_pair(ay[i], i));\n    g[ay[i]].push_back(make_pair(ax[i], i));\n  }\n  for (int i = 0; i < n; i++) {\n    edges[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    if (!add[i]) {\n      continue;\n    }\n    done[i] = false;\n    edges[bx[i]].push_back(make_pair(by[i], i));\n    edges[by[i]].push_back(make_pair(bx[i], i));\n  }\n  for (int i = 0; i < n; i++) {\n    p[i] = i;\n  }\n  printf(""%d\\n"", ans);\n  dfs(0, -1);\n  return 0;\n}\n']","['data structures', 'dfs and similar', 'dsu', 'greedy', 'trees']",3200
https://codeforces.com//contest/1878/problem/B,B. Aleksa and Stack,Vasilije gave Aleksa a positive integer n n ge 3 and asked him to construct a strictly increasing array of size n of positive integers such that 3 cdot a i 2 is not divisible by a i a i 1 for each i 1 le i le n 2 Note that a strictly increasing array a of size n is an array where a i a i 1 for each i 1 le i le n 1 Since Aleksa thinks he is a bad programmer now he asked you to help him find such an array ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcout << 10 + i << ' ';\n\t\tcout << '\\n';\n\t}\n}""]","['constructive algorithms', 'math']",800
https://codeforces.com//contest/1333/problem/C,C. Eugene and an array,Eugene likes working with arrays And today he needs your help in solving one challenging task An array c is a subarray of an array b if c can be obtained from b by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end Let s call a nonempty array if for every nonempty subarray of this array sum of the elements of this subarray is nonzero For example array 1 2 3 is as all arrays 1 1 2 1 2 3 2 2 3 3 have nonzero sums of elements However array 1 2 1 3 isn t as his subarray 1 2 1 has sum of elements equal to 0 Help Eugene to calculate the number of nonempty subarrays of a given array a ,"['#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\nmap<ll, int> frec;\nint const nmax = 200000;\n\nint main()\n{\n  int n;\n  cin >> n;\n  ll result = 0, sum = 0;\n  int st = 1;\n  frec[0] = 1;\n  for(int i = 1;i <= n; i++){\n    int val;\n    cin >> val;\n    sum += val;\n    st = max(st, frec[sum] + 1);\n    frec[sum] = i + 1;\n    result += (i + 1 - st);\n  }\n  cout << result;\n  return 0;\n}\n']","['binary search', 'data structures', 'implementation', 'two pointers']",1700
https://codeforces.com//contest/660/problem/F,F. Bear and Bowling 4,Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,"['# include <cstdio>\n# include <vector>\nusing namespace std;\nconst int MN = 2e5 + 44;\nlong long a[MN];\nvector <pair <int, long long> > hull;\nbool bad(pair <int, long long> x)\n{\n\tif (hull.size() < 2)\n\t\treturn false;\n\tpair <int, long long> y = hull.back();\n\tpair <int, long long> z = hull[hull.size() - 2];\n\treturn (x.second - y.second) * (z.first - y.first) < (z.second - y.second) * (x.first - y.first);\n}\nlong long eval(pair <int, long long> a, long long x, long long y)\n{\n// \tprintf(""return %I64d\\n"", a.first * x + a.second + y);\n\treturn a.first * x + a.second + y;\n}\nlong long sufsum[MN];\nlong long sufscores[MN];\nint main()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%I64d"", a + i);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufsum[i] = sufsum[i + 1] + a[i];\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufscores[i] = sufscores[i + 1] + sufsum[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tpair <int, long long> add = make_pair(i, sufscores[i]);\n// \t\tprintf(""add %d %I64d\\n"", add.first, add.second);\n\t\twhile (bad(add))\n\t\t\thull.pop_back();\n\t\thull.push_back(add);\n\t}\n// \tfor (auto x : hull)\n// \t\tprintf(""%d %I64d\\n"", x.first, x.second);\n\tlong long res = 0;\n\tlong long x = 0, y = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t{\n// \t\tprintf(""i = %d x = %I64d y = %I64d\\n"", i, x, y);\n\t\tint low = 0, high = hull.size() - 1;\n\t\twhile (low < high - 3)\n\t\t{\n\t\t\tint med = (low + high) / 2;\n\t\t\tif (hull[med].first > i)\n\t\t\t\thigh = med - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong long val = eval(hull[med], x, y);\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[med].first, hull[med].second);\n\t\t\t\tres = max(res, val);\n\t\t\t\tif (eval(hull[med], x, y) > eval(hull[med + 1], x, y))\n\t\t\t\t\thigh = med;\n\t\t\t\telse\n\t\t\t\t\tlow = med;\n\t\t\t}\n\t\t}\n// \t\tprintf(""binsearch done\\n"");\n\t\tfor (int k = low; k <= high; ++k)\n\t\t\tif (hull[k].first <= i)\n\t\t\t{\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[k].first, hull[k].second);\n\t\t\t\tres = max(res, eval(hull[k], x, y));\n\t\t\t}\n\t\ty -= (i + 1) * a[i];\n\t\tx += a[i];\n\t}\n\tprintf(""%I64d\\n"", res);\n}']","['binary search', 'data structures', 'divide and conquer', 'geometry', 'ternary search']",2500
https://codeforces.com//contest/1878/problem/D,D. Reverse Madness,You are given a string s of length n containing lowercase Latin letters Next you will be given a positive integer k and two arrays l and r of length k It is guaranteed that the following conditions hold for these 2 arrays l 1 1 r k n l i le r i for each positive integer i such that 1 le i le k l i r i 1 1 for each positive integer i such that 2 le i le k Now you will be given a positive integer q which represents the number of modifications you need to do on s Each modification is defined with one positive integer x Find an index i such that l i le x le r i notice that such i is unique Let a min x r i l i x and let b max x r i l i x Reverse the substring of s from index a to index b Reversing the substring a b of a string s means to make s equal to s 1 s 2 dots s a 1 s b s b 1 dots s a 1 s a s b 1 s b 2 dots s n 1 s n Print s after the last modification is finished ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200000], b[200000], d[200001];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, k, q;\n\t\tstring s;\n\t\tcin >> n >> k >> s;\n\t\tfor (int i = 0; i ^ k; ++i)\n\t\t\tcin >> a[i], --a[i];\n\t\tfor (int i = 0; i ^ k; ++i)\n\t\t\tcin >> b[i], --b[i];\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\td[i] = 0;\n\t\tcin >> q;\n\t\tfor (; q--;) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t--x;\n\t\t\tint p = upper_bound(a, a + k, x) - a - 1;\n\t\t\tint l = min(x, a[p] + b[p] - x);\n\t\t\tint r = max(x, a[p] + b[p] - x);\n\t\t\t++d[l], --d[r + 1];\n\t\t}\n\t\tint p = 0, cur = 0;\n\t\tfor (int i = 0; i ^ n; ++i) {\n\t\t\tcur += d[i];\n\t\t\tif (p < k && i > b[p])\n\t\t\t\t++p;\n\t\t\tif (cur & 1)\n\t\t\t\tcout << s[a[p] + b[p] - i];\n\t\t\telse\n\t\t\t\tcout << s[i];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]","['data structures', 'greedy']",1600
https://codeforces.com//contest/375/problem/D,D. Tree and Queries,You have a rooted tree consisting of vertices Each vertex of the tree has some color We will assume that the tree vertices are numbered by integers from 1 to Then we represent the color of vertex as The tree root is a vertex with number 1 In this problem you need to answer to queries Each query is described by two integers The answer to query is the number of such colors of vertices that the subtree of vertex contains at least vertices of color You can find the definition of a rooted tree by the following link ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\n\nstruct TA {\n\tvector<int> a;\n\tint n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\ta.assign(n, 0);\n\t}\n\tvoid add(int p, int x) {\n\t\tfor (p++; p <= n; p += p & -p)\n\t\t\ta[p - 1] += x;\n\t}\n\tint get(int p) {\n\t\tint r = 0;\n\t\tfor (p++; p; p -= p & -p)\n\t\t\tr += a[p - 1];\n\t\treturn r;\n\t}\n};\n\nstruct Data {\n\tTA ta;\n\tvector<int> a;\n\tint n, tot;\n\n\tData() {\n\t\tn = 1;\n\t\ta.resize(n);\n\t\tta.init(n);\n\t\ttot = 0;\n\t}\n\n\tvoid grow() {\n\t\tta.init(2 * n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tta.add(i, a[i]);\n\t\t}\n\t\ta.resize(2 * n);\n\t\tn <<= 1;\n\t}\n\n\tvoid add(int p, int x) {\n\t\twhile (p >= n)\n\t\t\tgrow();\n\t\tta.add(p, x), tot += x;\n\t\ta[p] += x;\n\t}\n\n\tint get(int p) { //<=p\n\t\tp = min(p, n - 1);\n\t\treturn ta.get(p);\n\t}\n};\n\nint n, m;\nint c[MAX_N];\nvector<int> E[MAX_N];\n\nvector<pair<int, int> > by[MAX_N];\nint ans[MAX_N];\nint L[MAX_N], R[MAX_N], seq[MAX_N], pt;\nvector<int> color[MAX_N];\n\nint size[MAX_N];\n\nvoid dfs1(int u, int par) {\n\tL[u] = pt, seq[pt++] = u, size[u] = 1;\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (*e != par) {\n\t\t\tdfs1(*e, u);\n\t\t\tsize[u] += size[*e];\n\t\t}\n\tR[u] = pt;\n}\n\nint mask[MAX_N], cmask;\n\nint calc(int v, int L, int R) { //v occur in [L,R)\n\tvector<int>&arr = color[v];\n\treturn lower_bound(arr.begin(), arr.end(), R)\n\t\t\t- lower_bound(arr.begin(), arr.end(), L);\n}\n\nvoid update(Data*me, int v, int L, int R, int pL, int pR) {\n\tif (mask[v] == cmask)\n\t\treturn;\n\tmask[v] = cmask;\n\tint old = calc(v, pL, pR), now = calc(v, L, R);\n\tif (old == now)\n\t\treturn;\n\tif (old == 0) {\n\t\tme->add(now, 1);\n\t} else {\n\t\tme->add(old, -1);\n\t\tme->add(now, 1);\n\t}\n}\n\nData*dfs2(int u, int par) {\n\tint v = -1;\n\tData*me = 0;\n\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (*e != par) {\n\t\t\tData*c = dfs2(*e, u);\n\t\t\tif (v == -1 || size[*e] > size[v]) {\n\t\t\t\tif (me != 0)\n\t\t\t\t\tdelete me;\n\t\t\t\tv = *e, me = c;\n\t\t\t} else\n\t\t\t\tdelete c;\n\t\t}\n\n\tif (me == 0) {\n\t\tme = new Data;\n\t\tme->add(1, 1);\n\t} else {\n\t\t//update it!\n\t\t++cmask;\n\t\tint L = ::L[u], R = ::R[u];\n\t\tint pL = ::L[v], pR = ::R[v];\n\n\t\tfor (int i = L; i < pL; ++i) {\n\t\t\tupdate(me, c[seq[i]], L, R, pL, pR);\n\t\t}\n\n\t\tfor (int i = pR; i < R; ++i) {\n\t\t\tupdate(me, c[seq[i]], L, R, pL, pR);\n\t\t}\n\t}\n\n\tfor (vector<pair<int, int> >::iterator e = by[u].begin(); e != by[u].end();\n\t\t\t++e) {\n\t\tans[e->second] = me->tot - me->get(e->first - 1);\n\t}\n\treturn me;\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(""%d"", c + i);\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b), --a, --b;\n\t\tE[a].push_back(b), E[b].push_back(a);\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint v, k;\n\t\tscanf(""%d%d"", &v, &k), --v;\n\t\tby[v].push_back(make_pair(k, i));\n\t}\n\n\tdfs1(0, -1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint u = seq[i];\n\t\tcolor[c[u]].push_back(i);\n\t}\n\n\tData*me = dfs2(0, -1);\n//\tfor (int i = 0; i < me->a.size(); ++i) {\n//\t\tcout << i << "":"" << me->a[i] << endl;\n//\t}\n////\tcout << me->tot << endl;\n//\tcout << me->get(1) << endl;\n\n//\tdelete dfs2(0, -1);\n\tdelete me;\n\tfor (int i = 0; i < m; ++i) {\n\t\tprintf(""%d\\n"", ans[i]);\n\t}\n}\n']","['data structures', 'dfs and similar', 'trees']",2400
https://codeforces.com//contest/713/problem/A,A. Sonya and Queries,Today Sonya learned about long integers and invited all her friends to share the fun Sonya has an initially empty multiset with integers Friends give her queries each of one of the following type add non negative integer to the multiset Note that she has a multiset thus there may be many occurrences of the same integer delete a single occurrence of non negative integer from the multiset It s guaranteed that there is at least one in the multiset count the number of integers in the multiset with repetitions that match some pattern consisting of and In the pattern stands for the even digits while stands for the odd Integer matches the pattern if the parity of the th from the right digit in decimal notation matches the th from the right digit of the pattern If the pattern is shorter than this integer it s supplemented with s from the left Similarly if the integer is shorter than the pattern its decimal notation is supplemented with the s from the left For example if the pattern is than integers and match the pattern while integers and do not ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, ap[(1 << 19) + 2];\nchar sir[30];\n\nint main ()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nscanf (""%d\\n"", &M);\nwhile (M --)\n{\n    char type;\n    scanf (""%c "", &type);\n    if (type == \'+\' || type == \'-\')\n    {\n        long long x;\n        scanf (""%I64d\\n"", &x);\n        long long msk = 0;\n        for (int i=18; i>=0; i--)\n        {\n            int dig = x % 10;\n            if (dig & 1) msk |= 1 << i;\n            x /= 10;\n        }\n        if (type == \'+\') ap[msk] ++;\n        else ap[msk] --;\n        continue;\n    }\n    gets (sir + 1), N = strlen (sir + 1);\n    int j = N, msk = 0;\n    for (int i=18; i>=0; i--)\n    {\n        bool curr = 0;\n        if (j >= 1) curr = sir[j] - \'0\', j --;\n        if (curr) msk |= 1 << i;\n    }\n    printf (""%d\\n"", ap[msk]);\n}\n\nreturn 0;\n}\n']","['data structures', 'implementation']",1400
https://codeforces.com//contest/1183/problem/D,D. Candy Box  easy version ,There are n candies in a candy box The type of the i th candy is a i 1 le a i le n You have to prepare a gift using some of these candies with the following restriction the numbers of candies of each type presented in a gift should be all distinct i e for example a gift having two candies of type 1 and two candies of type 2 is bad It is also possible that of some types will be taken to a gift Your task is to find out the possible size of the single gift you can prepare using the candies you have You have to answer q independent queries ,"['#include<bits/stdc++.h>\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nll t,n,i,a[202020],d[202020],e[202020],has,sisa,z[202020];\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tvector<ll> isi;\n\t\tcin>>n;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t\td[a[i]]++;\n\t\t\te[a[i]]++;\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\td[a[i]]--;\n\t\t\tif(d[a[i]]==0)\n\t\t\t\tz[e[a[i]]]++;\n\t\t}\n\t\thas=0;\n\t\tsort(isi.begin(),isi.end());\n\t\treverse(isi.begin(),isi.end());\n\t\tsisa=0;\n\t\tfor(i=n;i>=1;i--)\n\t\t{\n\t\t\tz[i]+=sisa;\n\t\t\tif(z[i])\n\t\t\t{\n\t\t\t\thas+=i;\n\t\t\t\tsisa=z[i]-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tsisa=0;\n\t\t}\n\t\tcout<<has<<""\\n"";\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\td[a[i]]=0;\n\t\t\te[a[i]]=0;\n\t\t\tz[i]=0;\n\t\t}\n\t}\n}']","['greedy', 'sortings']",1400
https://codeforces.com//contest/567/problem/F,F. Mausoleum,King of Berland Berl IV has recently died Hail Berl V As a sign of the highest achievements of the deceased king the new king decided to build a mausoleum with Berl IV s body on the main square of the capital The mausoleum will be constructed from blocks each of them has the shape of a cuboid Each block has the bottom base of a meter square Among the blocks exactly two of them have the height of one meter exactly two have the height of two meters exactly two have the height of meters The blocks are arranged in a row without spacing one after the other Of course not every arrangement of blocks has the form of a mausoleum In order to make the given arrangement in the form of the mausoleum it is necessary that when you pass along the mausoleum from one end to the other the heights of the blocks first were i e increasing or remained the same and then decrease or remained unchanged It is possible that any of these two areas will be omitted For example the following sequences of block height meet this requirement Suddenly more requirements appeared Each of the requirements has the form where is the height of the th block and a is one of the five possible signs equals less than more than less than or equals more than or equals Thus each of the additional requirements is given by a pair of indexes and sign Find the number of possible ways to rearrange the blocks so that both the requirement about the shape of the mausoleum see paragraph 3 and the additional requirements were met ,"['#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define ll long long\nusing namespace std;\nint n,k;\nll f[110][110];\nstruct P{\n    int c,x,y;\n}a[110];\nbool check(int p,int q,int l,int r){\n    for (int i=1;i<=k;i++){\n        if (a[i].x==a[i].y){\n            if (a[i].c==1) return false;else continue;\n        }\n        if (a[i].c==0){\n            if (a[i].x==p&&a[i].y!=q) return false;\n            if (a[i].x==q&&a[i].y!=p) return false;\n            if (a[i].x>=l&&a[i].x<=r&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n            if (a[i].y>=l&&a[i].y<=r&&(!(a[i].x>=l&&a[i].x<=r))) return false; \n        }\n        if (a[i].c==1){\n            if (a[i].x==p&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n            if (a[i].x==q&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n            if ((a[i].x>=l&&a[i].x<=r)&&(!(a[i].y>=l&&a[i].y<=r))) return false; \n        }\n        if (a[i].c==2){\n            if (a[i].x==p&&(!((a[i].y>=l&&a[i].y<=r)||(a[i].y==q)))) return false;\n            if (a[i].x==q&&(!((a[i].y>=l&&a[i].y<=r)||(a[i].y==p)))) return false;\n            if (a[i].x>=l&&a[i].x<=r&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n        } \n    }\n    return true;\n}\nint main(){\n//  freopen(""test.in"",""r"",stdin);\n    scanf(""%d%d"",&n,&k);\n    char ch1,ch2;\n    for (int i=1;i<=k;i++){\n        scanf(""%d%c%c%c%d\\n"",&a[i].x,&ch1,&ch1,&ch2,&a[i].y);\n        if (ch1==\'=\') a[i].c=0;\n        if (ch1==\'<\'&&ch2==\' \') a[i].c=1;\n        if (ch1==\'<\'&&ch2==\'=\') a[i].c=2;\n        if (ch1==\'>\'&&ch2==\' \') a[i].c=3;\n        if (ch1==\'>\'&&ch2==\'=\') a[i].c=4;\n        if (a[i].c==3) a[i].c=1,swap(a[i].x,a[i].y);\n        if (a[i].c==4) a[i].c=2,swap(a[i].x,a[i].y);\n    }\n    memset(f,0,sizeof(f));\n    for (int i=1;i<2*n;i++) if (check(i,i+1,0,0)) f[i][i+1]=1;\n    for (int l=4;l<=2*n;l+=2)\n        for (int i=1;i+l-1<=2*n;i++){\n            int j=i+l-1;\n            if (check(i,j,i+1,j-1)) f[i][j]+=f[i+1][j-1];\n            if (check(i,i+1,i+2,j)) f[i][j]+=f[i+2][j];\n            if (check(j-1,j,i,j-2)) f[i][j]+=f[i][j-2];\n        }\n    printf(""%I64d"",f[1][2*n]);\n    return 0;\n}']",['dp'],2400
https://codeforces.com//contest/461/problem/A,A. Appleman and Toastman,Appleman and Toastman play a game Initially Appleman gives one group of numbers to the Toastman then they start to complete the following tasks Each time Toastman gets a group of numbers he sums up all the numbers and adds this sum to the score Then he gives the group to the Appleman Each time Appleman gets a group consisting of a single number he throws this group out Each time Appleman gets a group consisting of more than one number he splits the group into two non empty groups he can do it in any way and gives each of them to Toastman After guys complete all the tasks they look at the score value What is the maximum possible value of score they can get ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(""%d"", &a[i]);\n\t}\n\tlong long ret = 0;\n\tsort(a.begin(), a.end());\n\tfor (int i = 0; i < n; ++i) {\n\t\tret += a[i];\n\t}\n\tif (n > 1) {\n\t\tlong long cur = a.back() + a[n - 2];\n\t\tret += cur;\n\t\tfor (int i = n - 3; i >= 0; --i) {\n\t\t\tcur += a[i];\n\t\t\tret += cur;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n']","['greedy', 'sortings']",1200
https://codeforces.com//contest/1692/problem/G,G. 2 Sort,Given an array a of length n and an integer k find the number of indices 1 leq i leq n k such that the subarray a i dots a i k with length k 1 with length k has the following property If you multiply the first element by 2 0 the second element by 2 1 and the k 1 st element by 2 k then this subarray is sorted in strictly increasing order More formally count the number of indices 1 leq i leq n k such that 2 0 cdot a i 2 1 cdot a i 1 2 2 cdot a i 2 dots 2 k cdot a i k ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""G""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        cin >> a;\n        vector<int> ok(n);\n        for(int i = 1; i < n; ++i)\n            ok[i] = (a[i] * 2 > a[i - 1]);\n        vector<int> pref(n + 1, 0);\n        for(int i = 0; i < n; ++i)\n            pref[i + 1] = pref[i] + ok[i];\n        int ans = 0;\n        for(int i = 0; i + k <= n; ++i)\n            ans += (pref[i + k] - pref[i] == k);\n        cout << ans << endl;\n    }\n}']","['data structures', 'dp', 'sortings', 'two pointers']",1400
https://codeforces.com//contest/1527/problem/C,C. Sequence Pair Weight,The of a sequence is defined as the number of unordered pairs of indexes i j here i lt j with same value a i a j For example the weight of sequence a 1 1 2 2 1 is 4 The set of unordered pairs of indexes with same value are 1 2 1 5 2 5 and 3 4 You are given a sequence a of n integers Print the sum of the weight of all subsegments of a A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n//#pragma GCC optimize(""Ofast,no-stack-protector"")\n//#pragma GCC optimize(""fast-math"")\n//#pragma GCC target(""avx2"")\n// if avx2 not supported, use this instead\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n\n// something\n//#pragma GCC optimize(""O3"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""avx"")  //Enable AVX\n\n#include <bits/stdc++.h>\n#ifdef ONPC\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored ""-Wunused-const-variable""\n#endif\n#define all(x) (x).begin(), (x).end()\n#define fr first\n#define sc second\n#define m_p make_pair\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define low_bo(a, x) ((int)(lower_bound(a.begin(), a.end(), x) - a.begin()))\n#define up_bo(a, x) ((int)(upper_bound(a.begin(), a.end(), x) - a.begin()))\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define popcnt(x) __builtin_popcount(x)\n#define shuffle(a) shuffle(a.begin(), a.end(), rnd)\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nusing namespace std;\n\n/*\nconst int MEMSIZE = 1e9;\nchar memory[MEMSIZE];\nint memorypos;\ninline void * operator new(size_t n){\n    if (memorypos + n >= MEMSIZE)\n        memorypos = MEMSIZE / 3;\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\ninline void operator delete(void *){}\n*/\n\nusing ll = long long;\n\n#ifndef ONPC\n#define cerr cerr_maksim\nstruct Cerr : public ostream {\n    template<typename T>\n    Cerr& operator<<(T const&) {\n        return *this;\n    }\n} cerr;\n#endif\n\n#ifdef ONPC\nmt19937 rnd(223);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n\ntemplate<typename T>\nvoid setmin(T &x, T y) {\n    x = min(x, y);\n}\n\ntemplate<typename T>\nvoid setmax(T &x, T y) {\n    x = max(x, y);\n}\n\nnamespace Ment {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n\n    template<typename T>\n    class Modular {\n    public:\n        using Type = typename decay<decltype(T::value)>::type;\n\n        constexpr Modular() : value() {}\n\n        template<typename U>\n        Modular(const U &x) {\n            value = normalize(x);\n        }\n\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n\n        const Type &operator()() const { return value; }\n\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n\n        constexpr static Type mod() { return T::value; }\n\n        Modular &operator+=(const Modular &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n\n        Modular &operator-=(const Modular &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n\n        template<typename U>\n        Modular &operator+=(const U &other) { return *this += Modular(other); }\n\n        template<typename U>\n        Modular &operator-=(const U &other) { return *this -= Modular(other); }\n\n        Modular &operator++() { return *this += 1; }\n\n        Modular &operator--() { return *this -= 1; }\n\n        Modular operator++(int) {\n            Modular result(*this);\n            *this += 1;\n            return result;\n        }\n\n        Modular operator--(int) {\n            Modular result(*this);\n            *this -= 1;\n            return result;\n        }\n\n        Modular operator-() const { return Modular(-value); }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n#ifdef _WIN32\n            uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n            uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n            asm(\n            ""divl %4; \\n\\t""\n            : ""=a"" (d), ""=d"" (m)\n            : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n            );\n            value = m;\n#else\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n\n        Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n        template<typename U>\n        friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\n    private:\n        Type value;\n    };\n\n    template<typename T>\n    bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\n\n    template<typename T, typename U>\n    bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\n\n    template<typename T, typename U>\n    bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\n    template<typename T>\n    bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T>\n    bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\n    template<typename T>\n    Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T>\n    Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T>\n    Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T>\n    Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> power(const Modular<T> &a, const U &b) {\n        assert(b >= 0);\n        Modular<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    string to_string(const Modular<T> &number) {\n        return to_string(number());\n    }\n\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n        return stream << number();\n    }\n\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n        typename common_type<typename Modular<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = Modular<T>::normalize(x);\n        return stream;\n    }\n\n    constexpr int md = 1e9 + 7;\n    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n}\nusing Ment::Mint;\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\n#define TIME (clock() * 1.0 / CLOCKS_PER_SEC)\n\n// WARNING!!!!!!\n// Maksim reads solution\n// be careful!!!!\n\n// solution starts here\n\nusing ld = double;\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 1e5 + 100, maxw = (1 << 20) + 5, inf = 1e9 + 100;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    map<int, vector<int>> q;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        q[x].push_back(i);\n    }\n    ll ans = 0;\n    const int B = 300;\n    vector<int> b(n);\n    for (auto &[_, a] : q) {\n        if (a.size() < B) {\n            for (int i : a)\n                for (int j : a)\n                    if (i < j)\n                        ans += (i + 1) * (ll)(n - j);\n        } else {\n            ll s = 0;\n            fill(b.begin(), b.end(), 0);\n            for (int i : a)\n                b[i] = 1;\n            ll z = 0;\n            for (int i = 0; i < n; i++) {\n                if (b[i] == 1) {\n                    s += z;\n                    z += i + 1;\n                }\n                ans += s;\n            }\n        }\n    }\n    cout << ans << \'\\n\';\n}\n\n// check test counter\n\nint main() {\n#ifdef ONPC\n    freopen(""../a.in"", ""r"", stdin);\n    freopen(""../a.out"", ""w"", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(20);\n    //precalc();\n    if (false) {\n        int te = 0;\n        while (1) {\n            cerr << ++te << \'\\n\';\n            solve();\n        }\n    }\n    int ts;\n    ts = 1;\n    cin >> ts;\n    for (int its = 1; its <= ts; its++) {\n        //cerr << ""\\nts "" << its << \'\\n\';\n        //cout << ""Case #"" << its << "": "";\n        solve();\n    }\n#ifdef ONPC\n    cerr << ""\\n\\nConsumed "" << TIME << \'\\n\';\n#endif\n}']","['hashing', 'implementation', 'math']",1600
https://codeforces.com//contest/1484/problem/B,B. Restore Modulo,For the first place at the competition Alex won many arrays of integers and was assured that these arrays are very expensive After the award ceremony Alex decided to sell them There is a rule in arrays pawnshop you can sell array only if it can be compressed to a generator This generator takes four non negative numbers n m c s n and m must be positive s non negative and for c it must be true that 0 leq c m The array a of length n is created according to the following rules a 1 s bmod m here x bmod y denotes remainder of the division of x by y a i a i 1 c bmod m for all i such that 1 i le n For example if n 5 m 7 c 4 and s 10 then a 3 0 4 1 5 Price of such an array is the value of m in this generator Alex has a question how much money he can get for each of the arrays Please help him to understand for every array whether there exist four numbers n m c s that generate this array If yes then maximize m ,"['#include<bits/stdc++.h>\n#define R register\n#define N 1000201\n\nint z,f,a[N],b[N];\n\ninline void solve(){\n\tz=-1,f=-1;\n\tR int n;\n\tscanf(""%d"",&n);\n\tfor(R int i=1;i<=n;++i) scanf(""%d"",&a[i]);\n\tfor(R int i=1;i<n;++i){\n\t\tR int qwq=a[i+1]-a[i];\n\t\tif(qwq>0){\n\t\t\tif(z==-1) z=qwq;\n\t\t\telse if(qwq!=z){\n\t\t\t\tprintf(""-1\\n"");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t} else{\n\t\t\tqwq=-qwq;\n\t\t\tif(f==-1) f=qwq;\n\t\t\telse if(qwq!=f){\n\t\t\t\tprintf(""-1\\n"");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif(f==-1||z==-1) return (void)printf(""0\\n"");\n\tR int m=z+f;\n\tb[1]=a[1];\n\tif(a[1]>=m){\n\t\tprintf(""-1\\n"");\n\t\treturn;\n\t}\n\tfor(R int i=2;i<=n;++i){\n\t\tb[i]=(b[i-1]+z)%m;\n\t\tif(b[i]!=a[i]){\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(""%d %d\\n"",m,z);\n\t\n}\n\nint main(){\n\tR int T;\n\tstd::cin>>T;\n\twhile(T--)\n\t\tsolve();\n}']","['implementation', 'math']",1500
https://codeforces.com//contest/1709/problem/F,F. Multiset of Strings,You are given three integers n k and f Consider all binary strings i e all strings consisting of characters 0 and or 1 of length from 1 to n For every such string s you need to choose an integer c s from 0 to k A multiset of binary strings of length n is considered beautiful if for every binary string s with length from 1 to n the number of strings in the multiset such that s is their prefix is not exceeding c s For example let n 2 c 0 3 c 00 1 c 01 2 c 1 1 c 10 2 and c 11 3 The multiset of strings 11 01 00 01 is beautiful since for the string 0 there are 3 strings in the multiset such that 0 is their prefix and 3 le c 0 for the string 00 there is one string in the multiset such that 00 is its prefix and 1 le c 00 for the string 01 there are 2 strings in the multiset such that 01 is their prefix and 2 le c 01 for the string 1 there is one string in the multiset such that 1 is its prefix and 1 le c 1 for the string 10 there are 0 strings in the multiset such that 10 is their prefix and 0 le c 10 for the string 11 there is one string in the multiset such that 11 is its prefix and 1 le c 11 Now for the problem itself You have to calculate the number of ways to choose the integer c s for every binary string s of length from 1 to n in such a way that the possible size of a beautiful multiset is f ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int LOG = 20; // CHECK!!!!\nPowers W;\nvector<int> binRev;\nvoid initFFT() {\n\tbinRev = vector<int>((1 << LOG) + 3, 0);\n\tMint w = 2;\n\twhile(true) {\n\t\tMint x = w;\n\t\tfor (int i = 1; i < LOG; i++)\n\t\t\tx *= x;\n\t\tif (x == -1) break;\n\t\tw += 1;\n\t}\n\tW = Powers(1 << LOG, w);\n\tfor (int mask = 1; mask < (1 << LOG); mask++) {\n\t\tbinRev[mask] = (binRev[mask >> 1] >> 1) ^ ((mask & 1) << (LOG - 1));\n\t}\n}\n\ntemplate<unsigned mod = MOD> struct Poly {\n\tusing Mint = mint<mod>;\n\tvector<Mint> a;\n\n\tPoly() : a() {}\n\tPoly(vector<Mint> _a) {\n\t\ta = _a;\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t}\n\n\tvoid print(int n = -1) {\n\t\tif (n == -1) n = (int)a.size();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(""%u "", at(i).x);\n\t\tprintf(""\\n"");\n\t}\n\tvoid eprint() {\n\t\teprintf(""["");\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\teprintf(""%u "", a[i].x);\n\t\teprintf(""]\\n"");\n\t}\n\n\tstatic void fft(vector<Mint> &A) {\n\t\tint L = (int)A.size();\n\t\tassert((L & (L - 1)) == 0);\n\t\tint k = 0;\n\t\twhile((1 << k) < L) k++;\n\t\tfor (int i = 0; i < L; i++) {\n\t\t\tint x = binRev[i] >> (LOG - k);\n\t\t\tif (i < x) swap(A[i], A[x]);\n\t\t}\n\t\tfor (int lvl = 0; lvl < k; lvl++) {\n\t\t\tint len = 1 << lvl;\n\t\t\tfor (int st = 0; st < L; st += (len << 1))\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tMint x = A[st + i], y = A[st + len + i] * W.pow(i << (LOG - 1 - lvl));\n\t\t\t\t\tA[st + i] = x + y;\n\t\t\t\t\tA[st + len + i] = x - y;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tMint& operator [] (const int i) {\n\t\tassert(0 <= i && i <= deg()); \n\t\treturn a[i];\n\t}\n\tMint at(const int i) const {\n\t\tif (i < 0 || i > deg()) return 0;\n\t\treturn a[i];\n\t}\n\tint deg() const { // deg of polynomial 0 is -1\n\t\treturn (int)a.size() - 1;\n\t}\n\tMint eval(const Mint &x) const {\n\t\tMint res = 0;\n\t\tfor (int i = deg(); i >= 0; i--)\n\t\t\tres = res * x + a[i];\n\t\treturn res;\n\t}\n\tPoly substr(const int &l, const int &r) const {\n\t\tvector<Mint> f(r - l);\n\t\tfor (int i = l; i < r; i++)\n\t\t\tf[i - l] = at(i);\n\t\treturn f;\n\t}\n\n\tPoly& operator += (const Poly &A) {\n\t\tif (deg() < A.deg()) a.resize(A.a.size());\n\t\tfor (int i = 0; i <= A.deg(); i++)\n\t\t\ta[i] += A.a[i];\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t\treturn *this;\n\t}\n\tPoly& operator -= (const Poly &A) {\n\t\tif (deg() < A.deg()) a.resize(A.a.size());\n\t\tfor (int i = 0; i <= A.deg(); i++)\n\t\t\ta[i] -= A.a[i];\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t\treturn *this;\n\t}\n\tPoly& operator *= (const Mint &k) {\n\t\tif (k == 0) a.clear();\n\t\tfor (Mint &x : a) x *= k;\n\t\treturn *this;\n\t}\n\tPoly& operator /= (const Mint &k) {\n\t\tMint ki = k.inv();\n\t\tfor (Mint &x : a) x *= ki;\n\t\treturn *this;\n\t}\n\tPoly operator + (const Poly &A) const {\n\t\treturn Poly(*this) += A;\n\t}\n\tPoly operator - (const Poly &A) const {\n\t\treturn Poly(*this) -= A;\n\t}\n\tPoly operator * (const Mint &k) const {\n\t\treturn Poly(*this) *= k;\n\t}\n\tPoly operator / (const Mint &k) const {\n\t\treturn Poly(*this) /= k;\n\t}\n\t\n\tPoly& operator *= (const Poly &A) {\n\t\tif (a.empty() || A.a.empty()) {\n\t\t\ta.clear();\n\t\t\treturn *this;\n\t\t}\n\t\tint nd = deg() + A.deg();\n\t\t\n\t\tif (deg() < LOG || A.deg() < LOG) {\n\t\t\tvector<Mint> res(nd + 1, 0);\n\t\t\tfor (int i = 0; i <= deg(); i++)\n\t\t\t\tfor (int j = 0; j <= A.deg(); j++)\n\t\t\t\t\tres[i + j] += a[i] * A.a[j];\n\t\t\treturn *this = Poly(res);\n\t\t}\n\t\t\n\t\tint k = 0;\n\t\twhile((1 << k) <= nd) k++;\n\t\tint L = 1 << k;\n\t\tvector<Mint> f = a, g = A.a;\n\t\tf.resize(L, 0);\n\t\tg.resize(L, 0);\n\t\tfft(f);\n\t\tfft(g);\n\t\tfor (int i = 0; i < L; i++)\n\t\t\tf[i] *= g[i];\n\t\tfft(f);\n\t\treverse(f.begin() + 1, f.end());\n\t\treturn *this = (Poly(f) / L);\n\t}\n\tPoly operator * (const Poly &A) const {\n\t\treturn Poly(*this) *= A;\n\t}\n\n\tPoly inv(int n) const {\n\t\tassert(deg() >= 0 && at(0) != 0);\n\t\tif (n <= 0) return Poly();\n\t\tvector<Mint> res(n);\n\t\tres[0] = a[0].inv();\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tfor (int i = 0; i < 2 * L && i <= deg(); i++)\n\t\t\t\tf[i] = a[i];\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tg[i] = res[i];\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tf[i] = 0;\n\t\t\tfor (int i = L; i < 2 * L; i++)\n\t\t\t\tf[i] = Mint() - f[i];\n\t\t\tfft(f);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tLi *= Li;\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic vector<Mint> div_stupid(vector<Mint> A, vector<Mint> B) {\n\t\tint n = (int)A.size(), m = (int)B.size();\n\t\tMint Bi = B.back().inv();\n\t\tfor (auto &x : B) x *= Bi;\n\t\tvector<Mint> C(n - m + 1);\n\t\tfor (int i = n; i >= m; i--) {\n\t\t\tC[i - m] = A[i - 1] * Bi;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tA[i - m + j] -= B[j] * A[i - 1];\n\t\t}\n\t\treturn C;\n\t}\n\tPoly& operator /= (const Poly &A) {\n\t\tint d1 = deg(), d2 = A.deg();\n\t\tassert(d2 >= 0);\n\t\tif (d1 < d2) return *this = Poly();\n\t\tif (d2 < 4 * LOG || d1 - d2 < 4 * LOG)\n\t\t\treturn *this = div_stupid(a, A.a);\n\t\tvector<Mint> f = a, g = A.a;\n\t\treverse(all(f));\n\t\treverse(all(g));\n\t\tPoly H = Poly(vector<Mint>(f.begin(), f.begin() + d1 - d2 + 1)) * Poly(g).inv(d1 - d2 + 1);\n\t\tvector<Mint> t = vector<Mint>(H.a.begin(), H.a.begin() + d1 - d2 + 1);\n\t\treverse(all(t));\n\t\treturn *this = t;\n\t}\n\tPoly operator / (const Poly &A) const {\n\t\treturn Poly(*this) /= A;\n\t}\n\tPoly& operator %= (const Poly &A) {\n\t\tassert(A.deg() >= 0);\n\t\tif (deg() < A.deg()) return *this;\n\t\treturn *this -= A * (*this / A);\n\t}\n\tPoly operator % (const Poly &A) const {\n\t\treturn Poly(*this) %= A;\n\t}\n\n\tPoly derivate() const {\n\t\tint n = deg();\n\t\tif (n <= 0) return Poly();\n\t\tvector<Mint> f(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tf[i] = a[i + 1] * (i + 1);\n\t\treturn f;\n\t}\n\tPoly integrate() const {\n\t\tint n = deg();\n\t\tif (n < 0) return Poly();\n\t\tn += 2;\n\t\tvector<Mint> f(n);\n\t\tInverses I = Inverses(n);\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = a[i - 1] * I.inv(i);\n\t\treturn f;\n\t}\n\tPoly log(int n) const {\n\t\tif (n <= 1) return Poly();\n\t\tassert(deg() >= 0 && at(0) == 1);\n\t\treturn (derivate() * inv(n)).substr(0, n - 1).integrate();\n\t}\n\tPoly exp(int n) const {\n\t\tif (n <= 0) return Poly();\n\t\tif (deg() < 0) return Poly({1});\n\t\tassert(at(0) == 0);\n\t\tvector<Mint> res(n);\n\t\tres[0] = 1;\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tPoly LG = Poly(vector<Mint>(res.begin(), res.begin() + L)).log(2 * L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tassert(at(i) == LG.at(i));\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tf[i] = res[i];\n\t\t\t\tg[i] = at(L + i) - LG.at(L + i);\n\t\t\t}\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i - L] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\tPoly sqr(int n) const {\n\t\treturn (*this * *this).substr(0, n);\n\t}\n\tPoly pow_(Mint k, int n) const { // k can be non-negative rational (k = 1/2 is sqrt), but assert(a[0] == 1);\n\t\tif (deg() < 0 || n <= 0) return Poly();\n\t\treturn (log(n) * k).exp(n);\n\t}\n\tPoly pow(ll k, int n) const { // k is non-negative integer\n\t\tif (n <= 0) return Poly();\n\t\tif (k == 0) return Poly({1});\n\t\tif (k == 1) return substr(0, n);\n\t\tif (k == 2) return sqr(n);\n\t\tif (k < LOG) {\n\t\t\tPoly cur = substr(0, n);\n\t\t\tPoly res = Poly({1});\n\t\t\twhile(k) {\n\t\t\t\tif (k & 1) res = (res * cur).substr(0, n);\n\t\t\t\tcur = cur.sqr(n);\n\t\t\t\tk >>= 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tint z = 0;\n\t\twhile(z * k < n && at(z) == 0) z++;\n\t\tif (z * k >= n) return Poly();\n\t\tPoly A = substr(z, z + n - z * k);\n\t\tMint cf = A[0].pow(k);\n\t\tA /= A[0];\n\t\tA = A.pow_(k, n - z * k) * cf;\n\t\treturn A.substr(-z * k, n - z * k);\n\t}\n\tPoly sqrt_(int n) const {\n\t\tif (deg() < 0 || n <= 0) return Poly();\n\t\tassert(at(0) == 1);\n//\t\treturn pow_(Mint(2).inv(), n);\n\t\tvector<Mint> res(n);\n\t\tres[0] = 1;\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tf[i] = res[i];\n\t\t\tfft(f);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= f[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= Li;\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] = at(i) - f[i];\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tassert(f[i] == 0);\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tf[i] = f[i + L];\n\t\t\t\tf[i + L] = 0;\n\t\t\t}\n\t\t\tPoly Q = Poly(vector<Mint>(res.begin(), res.begin() + L)).inv(L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tg[i] = Q.at(i);\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tLi /= 2;\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i - L] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\tbool sqrt(int n, Poly &R) const {\n\t\tif (deg() < 0) {\n\t\t\tR = Poly();\n\t\t\treturn true;\n\t\t}\n\t\tif (at(0) == 1) {\n\t\t\tR = sqrt_(n);\n\t\t\treturn true;\n\t\t}\n\t\tint z = 0;\n\t\twhile(at(z) == 0) z++;\n\t\tif (z & 1) return false;\n\t\tPoly A = substr(z, n + z / 2);\n\t\tMint cf;\n\t\tif (!A[0].sqrt(cf)) return false;\n\t\tA /= A[0];\n\t\tA = A.sqrt_(n - z / 2) * cf;\n\t\tR = A.substr(-z / 2, n - z / 2);\n\t\treturn true;\n\t}\n\n\tstatic Poly multiply_all(vector<Poly> polys) {\n\t\tif (polys.empty()) return Poly({1});\n\t\tset<pii> setik;\n\t\tfor (int i = 0; i < (int)polys.size(); i++)\n\t\t\tsetik.insert(mp(polys[i].deg(), i));\n\t\twhile((int)setik.size() > 1) {\n\t\t\tint p = setik.begin()->second;\n\t\t\tsetik.erase(setik.begin());\n\t\t\tint q = setik.begin()->second;\n\t\t\tsetik.erase(setik.begin());\n\t\t\tpolys[p] *= polys[q];\n\t\t\tsetik.insert(mp(polys[p].deg(), p));\n\t\t}\n\t\treturn polys[setik.begin()->second];\n\t}\n\tstatic Poly given_roots(const vector<Mint> &xs) {\n\t\tint n = (int)xs.size();\n\t\tvector<Poly> polys(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpolys[i] = Poly({Mint() - xs[i], 1});\n\t\treturn multiply_all(polys);\n\t}\n\n\tvector<Mint> multipoint(const vector<Mint> &xs) const {\n\t\tint n = (int)xs.size();\n\t\tif (n == 0) return {};\n\t\tif (n == 1) return {eval(xs[0])};\n\t\tint L = n;\n\t\twhile(L & (L - 1)) L++;\n\t\tvector<Poly> tree(2 * L);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttree[L + i] = Poly({Mint() - xs[i], 1});\n\t\tfor (int i = n; i < L; i++)\n\t\t\ttree[L + i] = Poly({1});\n\t\tfor (int i = L - 1; i > 0; i--)\n\t\t\ttree[i] = tree[2 * i] * tree[2 * i + 1];\n\t\ttree[1] = *this % tree[1];\n\t\tfor (int i = 2; i < L + n; i++)\n\t\t\ttree[i] = tree[i / 2] % tree[i];\n\t\tvector<Mint> res(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = tree[L + i].at(0);\n\t\treturn res;\n\t}\n\tstatic pair<Poly, Poly> interpolate_(const vector<pair<Mint, Mint>> &vals, int l, int r) {\n\t\tif (r - l == 1) return mp(Poly({vals[l].second}), Poly({Mint() - vals[l].first, 1}));\n\t\tint m = (l + r) / 2;\n\t\tauto L = interpolate_(vals, l, m), R = interpolate_(vals, m, r);\n\t\treturn mp(L.first * R.second + R.first * L.second, L.second * R.second);\n\n\t}\n\tstatic Poly interpolate(vector<pair<Mint, Mint>> vals) {\n\t\tif (vals.empty()) return Poly();\n\t\tint n = (int)vals.size();\n\t\tvector<Mint> xs(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\txs[i] = vals[i].first;\n\t\tPoly P = given_roots(xs);\n\t\tP = P.derivate();\n\t\tvector<Mint> cf = P.multipoint(xs);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvals[i].second /= cf[i];\n\t\treturn interpolate_(vals, 0, (int)vals.size()).first;\n\t}\n\tPoly x_k_mod_this(ll k) const { // x^k % P\n\t\tPoly res = Poly({1});\n\t\tint t = 0;\n\t\twhile((1LL << t) <= k) t++;\n\t\tfor (int i = t - 1; i >= 0; i--) {\n\t\t\tres *= res;\n\t\t\tif ((k >> i) & 1) res = res.substr(-1, res.deg() + 1);\n\t\t\tres %= *this;\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<Mint> chirp_z(Mint z, int n) const { // eval at [z^0, z^1, ..., z^(n-1)]\n\t\tint m = deg();\n\t\tif (m < 0 || n == 0) return vector<Mint>(n);\n\t\tif (z == 0) {\n\t\t\tvector<Mint> res(n, at(0));\n\t\t\tres[0] = eval(1);\n\t\t\treturn res;\n\t\t}\n\t\tMint zi = z.inv();\n\t\tvector<Mint> Z(n + m, 1), Zi(max(m + 1, n), 1);\n\t\tMint w = 1, wi = 1;\n\t\tfor (int i = 1; i < (int)Z.size(); i++) {\n\t\t\tZ[i] = Z[i - 1] * w;\n\t\t\tw *= z;\n\t\t}\n\t\tfor (int i = 1; i < (int)Zi.size(); i++) {\n\t\t\tZi[i] = Zi[i - 1] * wi;\n\t\t\twi *= zi;\n\t\t}\n\t\tvector<Mint> f(m + 1);\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tf[i] = at(i) * Zi[i];\n\t\treverse(all(Z));\n\t\tPoly C = Poly(f) * Z;\n\t\tvector<Mint> res(n);\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tres[k] = C.at(n + m - 1 - k) * Zi[k];\n\t\treturn res;\n\t}\n\n\tPoly shift_c(Mint c) const { // P(x + c)\n\t\tint n = deg();\n\t\tif (n < 0) return Poly();\n\t\tFactorials F(n);\n\t\tPowers P(n, c);\n\t\tvector<Mint> f(n + 1), g(n + 1);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tf[i] = at(i) * F.f[i];\n\t\t\tg[i] = P.pow(i) * F.fi[i];\n\t\t}\n\t\treverse(all(g));\n\t\tPoly C = Poly(f) * g;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tf[i] = C.at(n + i) * F.fi[i];\n\t\treturn f;\n\t}\n};\n\ntemplate<uint mod = MOD>\nvector<mint<mod>> BerlekampMassey(vector<mint<mod>> x) {\n    using Mint = mint<mod>;\n    vector<Mint> ls, cur;\n    int lf;\n    Mint ld;\n    for (int i = 0; i < (int)x.size(); i++) {\n        Mint t = 0;\n        for (int j = 0; j < (int)cur.size(); j++)\n            t += cur[j] * x[i - j - 1];\n        if (t == x[i]) continue;\n        if (cur.empty()) {\n            cur.resize(i + 1);\n            lf = i;\n            ld = t - x[i];\n            continue;\n        }\n        Mint k = (t - x[i]) / ld;\n        vector<Mint> c(i - lf - 1);\n        c.push_back(k);\n        for (auto t : ls) {\n            c.push_back(Mint() - t * k);\n        }\n        if (c.size() < cur.size()) c.resize(cur.size());\n        for (int j = 0; j < (int)cur.size(); j++)\n            c[j] += cur[j];\n        if (i - lf + (int)ls.size() >= (int)cur.size()) {\n            ls = cur;\n            lf = i;\n            ld = t - x[i];\n        }\n        cur = c;\n    }\n    return cur;\n}\n\n// CALL initFFT() and CHECK LOG\n\nconst int N = 200200;\nint n, k, f;\nMint a[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\t\n\tinitFFT();\n\n\tscanf(""%d%d%d"", &n, &k, &f);\n\tfor (int i = 0; i <= k; i++)\n\t\ta[i] = 1;\n\tn--;\n\twhile(n--) {\n\t\tvector<Mint> b(k + 1, 0);\n\t\tfor (int i = 0; i <= k; i++)\n\t\t\tb[i] = a[i];\n\t\tPoly<> C = Poly<>(b) * Poly<>(b);\n\t\tMint sum = 0;\n\t\tfor (int i = C.deg(); i >= 0; i--) {\n\t\t\tsum += C.at(i);\n\t\t\tif (i <= k) {\n\t\t\t\ta[i] = sum;\n\t\t\t\ta[i] += C.at(i) * (k - i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<Mint> b(k + 1, 0);\n\tfor (int i = 0; i <= k; i++)\n\t\tb[i] = a[i];\n\tPoly<> C = Poly<>(b) * Poly<>(b);\n\tprintf(""%u\\n"", C.at(f).x);\n\treturn 0;\n}\n']","['bitmasks', 'brute force', 'dp', 'fft', 'flows', 'graphs', 'math', 'meet-in-the-middle', 'trees']",2500
https://codeforces.com//contest/576/problem/B,B. Invariance of Tree,A tree of size is an undirected connected graph consisting of vertices without cycles Consider some tree with vertices We call a tree relative to permutation if for any two vertices of the tree and the condition holds vertices and are connected by an edge if and only if vertices and are connected by an edge You are given permutation of size Find some tree size invariant relative to the given permutation ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint p[MAX];\nint wyn[MAX];\nint n;\nvoid nie(){\n  puts(""NO"");\n  exit(0);\n}\nmain(){\n  make(n);\n  R(i,n){\n    make(p[i]);\n    p[i]--;\n  }\n  R(i,n){\n    if(p[i] == i){\n      puts(""YES"");\n      R(j,n){\n        if(i!=j)\n          printf(""%d %d\\n"",i+1,j+1);\n      }\n      return 0;\n    }\n  }\n  R(i,n)wyn[i] = -1;\n  R(i,n){\n    if(p[p[i]] == i){   \n      int k = p[i];\n      R(j,n){\n        if(wyn[j] == -1 && j != i && j!=k){\n          int ak = j;\n          int w = i;\n          while(wyn[ak] == -1){\n            wyn[ak] = w;\n            ak = p[ak];\n            w = i+k - w;\n          }\n          if(w != i)nie();\n        }\n      }\n      puts(""YES"");\n      printf(""%d %d\\n"",i+1,k+1);\n      R(j,n){\n        if(i!=j && j!=k)\n          printf(""%d %d\\n"",wyn[j]+1,j+1);\n      }\n      return 0;\n    }\n  }\n  nie();\n}\n']","['constructive algorithms', 'dfs and similar', 'greedy', 'trees']",2100
https://codeforces.com//contest/581/problem/D,D. Three Logos,Three companies decided to order a billboard with pictures of their logos A billboard is a big board A logo of each company is a rectangle of a non zero area Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left When you put a logo on the billboard you should rotate it so that the sides were parallel to the sides of the billboard Your task is to determine if it is possible to put the logos of all the three companies on some square billboard without breaking any of the described rules ,"['#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint main()\n{\n    int a,b,c,d,e,f,ans=0,k=-1,n1,n2;\n    cin>>a>>b>>c>>d>>e>>f;\n    ans=a*b+c*d+e*f;\n    for(n1=1;n1<=1000;n1++)\n        if(n1*n1==ans)\n        {\n            k=n1;\n            break;\n        }\n    if(k==-1)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(b==k)\n        swap(a,b);\n    if(d==k)\n        swap(c,d);\n    if(f==k)\n        swap(e,f);\n    if(a==k&&c==k&&e==k)\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'A\');\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=d;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'B\');\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=f;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'C\');\n            printf(""\\n"");\n        }\n        return 0;\n    }\n    int sd=0;\n    if(c==k)\n    {\n        sd=1;\n        swap(a,c);\n        swap(b,d);\n    }\n    else\n    if(e==k)\n    {\n        sd=2;\n        swap(a,e);\n        swap(b,f);\n    }\n    if(a!=k)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(d==k-b)\n        swap(c,d);\n    if(f==k-b)\n        swap(e,f);\n    if(c!=k-b||e!=k-b)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'A\'+sd);\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=k-b;n1++)\n        {\n            if(sd!=1)\n            for(n2=1;n2<=d;n2++)\n                putchar(\'B\');\n            else\n            for(n2=1;n2<=d;n2++)\n                putchar(\'A\');   \n            if(sd!=2)                       \n            for(n2=1;n2<=f;n2++)\n                putchar(\'C\');\n            else\n            for(n2=1;n2<=f;n2++)\n                putchar(\'A\');\n            printf(""\\n"");\n        }\n        return 0;\n    }           \n}\n']","['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1700
https://codeforces.com//contest/625/problem/C,C. K-special Tables,People do many crazy things to stand out in a crowd Some of them dance some learn by heart rules of Russian language some try to become an outstanding competitive programmers while others collect funny math objects Alis is among these collectors Right now she wants to get one of special tables In case you forget the table is called special if the following three conditions are satisfied every integer from to appears in the table exactly once in each row numbers are situated in increasing order the sum of numbers in the th column is maximum possible Your goal is to help Alice and find at least one special table of size Both rows and columns are numbered from to with rows numbered from top to bottom and columns numbered from left to right ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int inf = 1001001001;\n\nint n,k,a[1111][1111],q,ans;\n\nint main()\n{\n    //freopen(""input.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n\n    cin >> n >> k;\n    for (int i=1; i<=n; i++){\n        for (int j=1; j<k; j++){\n            q++;\n            a[i][j]=q;\n        }\n    }\n    for (int i=1; i<=n; i++){\n        for (int j=k; j<=n; j++){\n            q++;\n            if (j==k) ans+=q;\n            a[i][j]=q;\n        }\n    }\n    cout << ans << endl;\n    for (int i=1; i<=n; i++){\n        for (int j=1; j<=n; j++){\n            cout << a[i][j] << \' \';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n']","['constructive algorithms', 'implementation']",1300
https://codeforces.com//contest/673/problem/B,B. Problems for Round,There are problems prepared for the next Codeforces round They are arranged in ascending order by their difficulty and no two problems have the same difficulty Moreover there are pairs of similar problems Authors want to split problems between two division according to the following rules Problemset of each division should be non empty Each problem should be used in exactly one division yes it is unusual requirement Each problem used in division 1 should be harder than any problem used in division 2 If two problems are similar they should be used in different divisions Your goal is count the number of ways to split problem between two divisions and satisfy all the rules Two ways to split problems are considered to be different if there is at least one problem that belongs to division 1 in one of them and to division 2 in the other Note that the relation of similarity transitive That is if problem is similar to problem and problem is similar to problem it doesn t follow that is similar to ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <limits.h>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N_ = 100500;\nconst int M_ = 100500;\n\nint N, M;\nvector<int> gph[N_];\n\nvector<int> A, B;\n\nint main() {\n\tscanf(""%d%d"", &N, &M);\n\tfor(int e = 1; e <= M; e++) {\n\t\tint u, v; scanf(""%d%d"", &u, &v);\n\t\tif(u > v) swap(u, v);\n\t\tA.push_back(u); B.push_back(v);\n\t}\n\n\tif(M == 0) {\n\t\tprintf(""%d\\n"", N-1);\n\t}else {\n\t\tint a = *max_element(A.begin(), A.end());\n\t\tint b = *min_element(B.begin(), B.end());\n\t\tprintf(""%d\\n"", max(0, b-a));\t\n\t}\n    return 0;\n}\n']","['greedy', 'implementation']",1300
https://codeforces.com//contest/688/problem/A,A. Opponents,Arya has opponents in the school Each day he will fight with all opponents who are present this day His opponents have some fighting plan that guarantees they will win but implementing this plan requires presence of them all That means if one day at least one of Arya s opponents is absent at the school then Arya will beat all present opponents Otherwise if all opponents are present then they will beat Arya For each opponent Arya knows his schedule whether or not he is going to present on each particular day Tell him the maximum number of days that he will beat all present opponents Note that if some day there are no opponents present Arya still considers he beats all the present opponents ,"[""// VSCF.cpp : Defines the entry point for the console application.\n//\n#include <unordered_map>\n#include <iomanip>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <set>\n#include <deque>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<string> inp(d);\n\tREP(i, d) {\n\t\tcin >> inp[i];\n\t}\n\tvector<bool> ok(d);\n\tREP(i, d) {\n\t\tREP(j, n) {\n\t\t\tif (inp[i][j] == '0') {\n\t\t\t\tok[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint co = 0;\n\tint maxCo = 0;\n\tREP(i, d) {\n\t\tif (ok[i]) {\n\t\t\tco++;\n\t\t\tmaxCo = max(co, maxCo);\n\t\t} else {\n\t\t\tco = 0;\n\t\t}\n\t}\n\tcout << maxCo;\n\treturn 0;\n}\n\n""]",['implementation'],800
https://codeforces.com//contest/115/problem/C,C. Plumber,Little John aspires to become a plumber Today he has drawn a grid consisting of rows and columns consisting of square cells In each cell he will draw a pipe segment He can only draw four types of segments numbered from to illustrated as follows Each pipe segment has two ends illustrated by the arrows in the picture above For example segment has ends at top and left side of it Little John considers the piping system to be leaking if there is at least one pipe segment inside the grid whose end is not connected to another pipe s end or to the border of the grid The image below shows an example of leaking and non leaking systems of size Now you will be given the grid that has been partially filled by Little John Each cell will either contain one of the four segments above or be empty Find the number of possible different non leaking final systems after Little John finishes filling of the empty cells with pipe segments Print this number modulo Note that rotations or flipping of the grid are not allowed and so two configurations that are identical only when one of them has been rotated or flipped either horizontally or vertically are considered two different configurations ,"['#include <vector>\n#include <cstring>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <stdlib.h>\n#include <ctime>\n#include <string>\n#include <complex>\n#ifdef __ASD__\n#include <windows.h>\n#endif\nusing namespace std;\n#define all(a) a.begin(),a.end()\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define fornn(i,n) for(i=0;i<(n);++i)\n#define lng long long\n#define SQ(a) ((a)*(a))\n#define forv(i,v) for(int i=0;i<(int)v.size();++i)\n#define mp make_pair\n#define pb push_back\n#define ABS(a) ((a)<0?-(a):(a))\n#define iinf 1000000000\n#define linf 1000000000000000000LL\n#define dinf 1e200\n#define left asdleft\n#define prev asdprev\n#define eps 1e-12\n#define y1 asdy1\n#define y2 asdy2\n#define EQ(a,b) abs((a)-(b))<eps\n#define PI 3.1415926535897932384626433832795\n#define DEG2RAD PI/180\n#define ulng unsigned lng\n#define next asdnext\n#define prev asdprev\nvoid mytimer(string task){\n#ifdef __ASD__\n        static LARGE_INTEGER prev;      LARGE_INTEGER cur,freq; QueryPerformanceCounter(&cur);  QueryPerformanceFrequency(&freq);       if(task!="""")            cout<<task<<"" took ""<<(cur.QuadPart-prev.QuadPart)*1.0/freq.QuadPart<<endl;     prev=cur;\n#endif\n}\nvoid ext(int c){\n#ifdef __ASD__\n        exit(c);\n#endif\n}\n\nbool was[2][510000][2];\nchar line[510000];\n\nconst int mod=1000003;\n\n#define taska ""burai""\nint main(){\n#ifdef __ASD__\n    freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#else\n    //freopen(taska"".in"",""r"",stdin);freopen(taska"".out"",""w"",stdout);\n#endif\n\n    int n,m;\n    cin>>n>>m;\n    gets(line);\n    forn(i,n){\n        gets(line);\n        forn(j,m){\n            char c=line[j];\n            if(c==\'.\')\n                continue;\n            int v=c-\'1\';\n            int v1=v/2;\n            int v2=(v+1)%4/2;\n            was[0][i][(j%2)^v1]=true;\n            was[1][j][(i%2)^v2]=true;\n        }\n    }\n    int len[]={n,m};\n\n    int res=1;\n    forn(q,2){\n        forn(i,len[q]){\n            bool w1=was[q][i][0];\n            bool w2=was[q][i][1];\n            if(w1&&w2)\n                res=0;\n            else if(!w1&&!w2)\n                res=res*2%mod;\n        }\n    }\n\n    cout<<res;\n\n    return 0;\n}\n']",['math'],2200
https://codeforces.com//contest/906/problem/A,A. Shockers,Valentin participates in a show called Shockers The rules are quite easy jury selects one letter which Valentin doesn t know He should make a small speech but every time he pronounces a word that contains the selected letter he receives an electric shock He can make guesses which letter is selected but for each incorrect guess he receives an electric shock too The show ends when Valentin guesses the selected letter correctly Valentin can t keep in mind everything so he could guess the selected letter much later than it can be uniquely determined and get excessive electric shocks Excessive electric shocks are those which Valentin got after the moment the selected letter can be uniquely determined You should find out the number of excessive electric shocks ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,val[30],unq,duang;\nchar s[101000],t[101000];\nint main() {\n\tscanf(""%d"",&n);\n\trep(j,0,26) val[j]=1;\n\tunq=0;\n\trep(i,0,n) {\n\t\tscanf(""%s%s"",s,t);\n\t\tint l=strlen(t);\n\t\tif (s[0]==\'?\') {\n\t\t\tif (i==n-1) {\n\t\t\t\tint id=t[0]-\'a\';\n\t\t\t\trep(j,0,26) val[j]=j==id;\n\t\t\t} else {\n\t\t\t\tint id=t[0]-\'a\';\n\t\t\t\tval[id]=0;\n\t\t\t\tif (unq) duang+=1;\n\t\t\t}\n\t\t} else if (s[0]==\'.\') {\n\t\t\trep(j,0,l) val[t[j]-\'a\']=0;\n\t\t} else {\n\t\t\tif (unq) duang+=1;\n\t\t\tint S=0;\n\t\t\trep(j,0,l) S|=1<<(t[j]-\'a\'); S^=(1<<26)-1;\n\t\t\trep(j,0,26) if (S&(1<<j)) val[j]=0;\n\t\t}\n\t\tint cnt=0;\n\t\trep(j,0,26) cnt+=val[j];\n\t\tif (cnt==1) unq=1;\n\t}\n\tprintf(""%d\\n"",duang);\n}\n']","['implementation', 'strings']",1600
https://codeforces.com//contest/160/problem/A,A. Twins,Imagine that you have a twin brother or sister Having another person that looks exactly like you seems very unusual It s hard to say if having something of an alter ego is good or bad And if you do have a twin then you very well know what it s like Now let s imagine a typical morning in your family You haven t woken up yet and Mom is already going to work She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria She fished in the purse and found some number of coins or to be exact coins of arbitrary values But as Mom was running out of time she didn t split the coins for you two So she scribbled a note asking you to split the money equally As you woke up you found Mom s coins and read her note But why split the money equally you thought After all your twin is sleeping and he won t know anything So you decided to act like that pick for yourself some subset of coins so that the sum of values of your coins is than the sum of values of the remaining coins that your twin will have However you correctly thought that if you take too many coins the twin will suspect the deception So you ve decided to stick to the following strategy to avoid suspicions you take the whose sum of values is strictly more than the sum of values of the remaining coins On this basis determine what number of coins you need to take to divide them in the described manner ,"['/*\n * a.cpp\n *\n *  Created on: 2012-3-6\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint dp[12000];\n\tfill(dp, dp + 12000, INT_MAX / 2);\n\tdp[0] = 0;\n\tint sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a;\n\t\tcin >> a;\n\t\tsum += a;\n\t\tfor (int j = 12000 - 1; j >= 0; --j) {\n\t\t\tif (j + a < 12000)\n\t\t\t\tdp[j + a] = min(dp[j + a], dp[j] + 1);\n\t\t}\n\t}\n\tint ans = INT_MAX / 2;\n\tfor (int i = 0; i < 12000; ++i) {\n\t\tif (i + i > sum)\n\t\t\tans = min(ans, dp[i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","['greedy', 'sortings']",900
https://codeforces.com//contest/1632/problem/E1,E1. Distance Tree  easy version , A tree is a connected undirected graph without cycles A weighted tree has a weight assigned to each edge The distance between two vertices is the minimum sum of weights on the path connecting them You are given a weighted tree with n vertices each edge has a weight of 1 Denote d v as the distance between vertex 1 and vertex v Let f x be the minimum possible value of max limits 1 leq v leq n d v if you can temporarily add an edge with weight x between any two vertices a and b 1 le a b le n Note that after this operation the graph is no longer a tree For each integer x from 1 to n find f x ,"['#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint T, n, d1[303000], rt, d2[303000];\n\nvector<int>G[303000];\n\nvoid dfs(int x,int fff,int *d){\n    if (fff!=0) d[x]=d[fff]+1;\n    else d[x]=0;\n    for (auto y:G[x])\n        if (y!=fff)\n            dfs(y,x,d);\n}\n\nint f[303000];\nvoid U(int &x,int y){\n    x=max(x,y);\n}\n\nbool check(int mid,int x){\n    if (d1[rt]<=mid) return 1;\n    int d=f[mid+1];\n    if (d==0) return x<=mid;\n    return mid>=x+(d+1)/2;\n}\n\nint main(){\n    for (cin>>T;T--;){\n        scanf(""%d"",&n);\n        for (int i=1;i<=n;++i) G[i].clear();\n        for (int i=1;i<n;++i){\n            int x, y; scanf(""%d%d"",&x,&y);\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        dfs(1,0,d1);\n        rt=max_element(d1+1,d1+n+1)-d1;\n        dfs(rt,0,d2);\n        for (int i=0;i<=n+1;++i) f[i]=0;\n        for (int i=1;i<=n;++i)\n            U(f[d1[i]],d2[i]);\n        for (int i=n;i>=0;--i){\n            U(f[i],f[i+1]);\n        }\n        for (int i=1;i<=n;++i){\n            int l=1, r=n, ans=n;\n            while (l<=r){\n                int mid=l+r>>1;\n                if (check(mid,i)){\n                    ans=mid; r=mid-1;\n                }else{\n                    l=mid+1;\n                }\n            }\n            printf(""%d "",ans);\n        }\n        puts("""");\n    }\n}']","['binary search', 'data structures', 'dfs and similar', 'graphs', 'shortest paths', 'trees']",2400
https://codeforces.com//contest/1521/problem/D,D. Nastia Plays with a Tree,The girl will perform the following operation with her tree as long as she needs Remove any existing edge Add an edge between any pair of vertices What is the number of operations Nastia needs to get a bamboo from a tree A bamboo is a tree in which no node has a degree greater than 2 ,"['#include <bits/stdc++.h>\n \n#define int long long\n \n#define ext exit(0)\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define data data228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << "": "" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n \nconst int maxn = 3e5 + 7, mod = 1e9 + 7, MAXN = 2e6 + 7;\nconst double eps = 1e-9;                                        \nconst ll INF = 1e18, inf = 1e15;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());                       \nint n; \nvector<int> gr[maxn]; \nint dp[maxn][2]; \nint PR[maxn]; \n \nvoid dfs(int u, int pr) {\n    PR[u] = pr; \n    vector<int> vertex; \n    for (auto v : gr[u]) {\n        if (v == pr) continue; \n        dfs(v, u); \n        vertex.pb(v); \n    }\n    dp[u][0] = inf; \n    {\n        int cur = 0; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n        }\n        dp[u][0] = cur + 1; \n    }\n \n    {\n        int cur = 0; \n        vector<pii> type; \n        bool ok = false; \n        int mn = inf; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            if (dp[x][0] <= dp[x][1]) {\n                ok = true; \n            } else {\n                mn = min(mn, dp[x][0] - dp[x][1]); \n            }\n        }\n        if (ok) {\n            dp[u][0] = min(dp[u][0], cur); \n        } else {\n            dp[u][0] = min(dp[u][0], cur + mn); \n        }                      \n    }\n \n \n    dp[u][1] = inf; \n    if ((int)vertex.size() < 2) return; \n    {\n        int cur = 0; \n        vector<int> change; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            change.pb(max(0ll, dp[x][0] - dp[x][1])); \n        }\n        sort(all(change)); \n        cur += change[0]; \n        cur += change[1]; \n        dp[u][1] = cur - 1;             \n    }\n}\n \nint color[maxn]; \nint pt = 0; \n \nvoid solve(int u, int type, int cl) {\n    vector<int> vertex; \n    for (auto v : gr[u]) {\n        if (v == PR[u]) continue; \n        vertex.pb(v); \n    }\n    color[u] = cl; \n    if (type == 0) {\n        {\n \n        int cur = 0; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n        }\n        if (dp[u][0] == cur + 1) {\n            for (auto x : vertex) {\n                if (dp[x][0] < dp[x][1]) {\n                    ++pt; \n                    solve(x, 0, pt); \n                } else {\n                    ++pt; \n                    solve(x, 1, pt); \n                }\n            }                   \n            return; \n        }\n \n        }\n \n        /////////////////////////////////////////////////////////////////////////////////\n        {\n \n        int cur = 0; \n        vector<pii> type; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            type.pb({max(0ll, dp[x][0] - dp[x][1]), x}); \n        }\n        sort(all(type)); \n \n        solve(type[0].ss, 0, cl); \n        for (auto x : vertex) {\n            if (x == type[0].ss) continue;\n            if (dp[x][0] < dp[x][1]) {\n                ++pt; \n                solve(x, 0, pt); \n            } else {\n                ++pt; \n                solve(x, 1, pt); \n            }\n        }\n        return; \n        }\n        return;                    \n    }\n \n    int cur = 0; \n    vector<pii> change; \n    for (auto x : vertex) {\n        cur += min(dp[x][0], dp[x][1]); \n        change.pb({max(0ll, dp[x][0] - dp[x][1]), x}); \n    }\n    sort(all(change)); \n    int v1 = change[0].ss; \n    int v2 = change[1].ss; \n    solve(v1, 0, cl); \n    solve(v2, 0, cl); \n    for (auto x : vertex) {\n        if (x == v1 || x == v2) continue; \n        if (dp[x][0] > dp[x][1]) {  \n            ++pt; \n            solve(x, 1, pt); \n        } else {\n            ++pt; \n            solve(x, 0, pt); \n        }\n    }\n}\n \nvector<int> start[maxn]; \n \nvoid solve() {\n    cin >> n; \n    for (int i = 0; i < n; ++i) {\n        gr[i].clear(); \n        start[i].clear(); \n        PR[i] = -1; \n        dp[i][0] = dp[i][1] = inf; \n    }\n    vector<pii> e; \n    for (int i = 0; i < n - 1; ++i) {\n        int a, b; cin >> a >> b, --a, --b; \n        gr[a].pb(b); \n        gr[b].pb(a); \n        e.pb({a, b}); \n    }\n    dfs(0, 0); \n    cout << min(dp[0][0], dp[0][1]) - 1 << \'\\n\'; \n    pt = 0; \n    if (dp[0][0] < dp[0][1]) {\n        solve(0, 0, 0); \n    } else {\n        solve(0, 1, 0); \n    }\n    vector<pii> del; \n    for (auto v : e) {\n        if (color[v.ff] != color[v.ss]) {\n            del.pb(v); \n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        int bad = 0; \n        for (auto v : gr[i]) {\n            if (color[i] == color[v]) {\n                ++bad; \n            }\n        } \n        if (bad <= 1) {\n            start[color[i]].pb(i);                        \n        }\n    }\n    for (int i = 0; i <= pt; ++i) {\n        if (start[i].size() == 1) {\n            start[i].pb(start[i][0]);         \n        }                \n    }         \n    vector<pii> ms; \n    for (int i = 0; i <= pt; ++i) ms.pb({start[i][0], start[i][1]}); \n    int lst = ms[0].ss; \n    for (int i = 1; i < (int)ms.size(); ++i) {\n        pii x = del.back(); \n        del.pop_back(); \n        cout << x.ff + 1 << "" "" << x.ss + 1 << "" ""; \n        cout << lst + 1 << "" "" << ms[i].ff + 1 << \'\\n\'; \n        lst = ms[i].ss; \n    }\n}                                \n \nsigned main() {          \n#ifdef LOCAL\n    freopen(""TASK.in"", ""r"", stdin);\n    freopen(""TASK.out"", ""w"", stdout);\n#endif // LOCAL                                                                             \n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; cin >> t; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  ']","['constructive algorithms', 'data structures', 'dfs and similar', 'dp', 'dsu', 'greedy', 'implementation', 'trees']",2500
https://codeforces.com//contest/545/problem/A,A. Toy Cars,Little Susie thanks to her older brother likes to play with cars Today she decided to set up a tournament between them The process of a tournament is described in the next paragraph There are toy cars Each pair collides The result of a collision can be one of the following no car turned over one car turned over both cars turned over A car is good if it turned over in no collision The results of the collisions are determined by an matrix there is a number on the intersection of the th row and th column that describes the result of the collision of the th and the th car if this pair of cars never collided occurs only on the main diagonal of the matrix if no car turned over during the collision if only the th car turned over during the collision if only the th car turned over during the collision if both cars turned over during the collision Susie wants to find all the good cars She quickly determined which cars are good Can you cope with the task ,"[""//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ans;\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n;i++){\n        int f = 0;\n        for(int j = 0; j < n;j++){\n            int p;\n            cin >> p;\n            if(p == 1 || p == 3) f = 1;\n        }\n        if(!f) ans.push_back(i + 1);\n    }\n    cout << ans.size() << endl;\n    for(int i = 0; i < ans.size();i++) cout << ans[i] << ' ';\n    return 0;\n}""]",['implementation'],900
https://codeforces.com//contest/623/problem/E,E. Transforming Sequence,Let s define the transformation of a sequence of integers as where for all where is the bitwise OR operation Vasya consequently applies the transformation to all sequences of length consisting of integers from to inclusive He wants to know how many of these sequences have such property that their transformation is a sequence Help him to calculate this number modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=301000;\nll ret[N],coef[N],tmp[N],fnv[N],n;\nint k,K;\nvoid mult(ll *x,ll y) {\n\tll c=1;\n\trep(i,0,K+1) {\n\t\tx[i]=x[i]*c%mod;\n\t\tc=c*y%mod;\n\t}\n}\nvoid multt(ll *x,ll y) {\n\trep(i,0,K+1) x[i]=x[i]*y%mod;\n}\n\nll buffer[N],buffer_pos,size=32768;\n\nvoid multiply(int size,ll a[],ll b[],ll r[]) {\n\tif (size<=16) {\n\t\tfor (int i=0;i<size+size;i++) r[i]=0;\n\t\tfor (int i=0;i<size;i++) if (a[i]) for (int j=0;j<size;j++) {\n\t\t\tr[i+j]+=a[i]*b[j];\n\t\t\tif (r[i+j]>=8000000000000000000ll) r[i+j]%=mod;\n\t\t}\n\t\tfor (int i=0;i<size+size;i++) r[i]%=mod;\n\t\treturn;\n\t}\n\tint s=size/2;\n\tmultiply(s,a,b,r);\n\tmultiply(s,a+s,b+s,r+size);\n\tll *a2=buffer+buffer_pos; buffer_pos+=s;\n\tll *b2=buffer+buffer_pos; buffer_pos+=s;\n\tll *r2=buffer+buffer_pos; buffer_pos+=size;\n\tfor (int i=0;i<s;i++) { a2[i]=a[i]+a[i+s]; if (a2[i]>=mod) a2[i]-=mod; }\n\tfor (int i=0;i<s;i++) { b2[i]=b[i]+b[i+s]; if (b2[i]>=mod) b2[i]-=mod; }\n\tmultiply(s,a2,b2,r2);\n\tfor (int i=0;i<size;i++) r2[i]-=r[i]+r[i+size];\n\tfor (int i=0;i<size;i++) { r[i+s]+=r2[i]; r[i+s]%=mod; if (r[i+s]<0) r[i+s]+=mod; }\n\tbuffer_pos-=(s+s+size);\n}\nvoid mul(ll *a,ll *b) {\n\tll *r=buffer+buffer_pos;\n\tbuffer_pos+=size+size;\n\tmultiply(size,a,b,r);\n\tfor (int i=0;i<size;i++) a[i]=r[i];\n\tbuffer_pos-=size+size;\t\n}\nvoid poww(int n) {\n\tif (n==1) {\n\t\trep(i,0,K+1) ret[i]=coef[i];\n\t} else if (n%2==1) {\n\t\tpoww(n-1);\n\t\tmult(ret,2);\n\t\tmultt(ret,powmod(2,n-1));\n\t\tmul(ret,coef);\n\t} else {\n\t\tpoww(n/2);\n\t\trep(i,0,K+1) tmp[i]=ret[i];\n\t\tmult(tmp,powmod(2,n/2));\n\t\tmultt(tmp,powmod(2,(n/2)*(n/2)));\n\t\tmul(ret,tmp);\n\t}\n}\nint main() {\n\tscanf(""%I64d%d"",&n,&k);\n\tif (n>k) {\n\t\tputs(""0"");\n\t\treturn 0;\n\t}\n\tfnv[0]=1;\n\tK=k-n;\n\twhile (size/2>K+1) size/=2;\n\trep(i,1,k+1) fnv[i]=fnv[i-1]*powmod(i,mod-2)%mod;\n\trep(i,0,K+1) coef[i]=fnv[i+1];\n\tret[0]=1;\n\tpoww(n);\n\tll ans=0;\n\trep(i,n,k+1) {\n\t\tans=(ans+ret[i-n]*fnv[k-i])%mod;\n\t}\n\trep(i,1,k+1) ans=ans*i%mod;\n\tprintf(""%I64d\\n"",ans);\n}\n']","['combinatorics', 'dp', 'fft', 'math']",3300
https://codeforces.com//contest/825/problem/D,D. Suitable Replacement,You are given two strings and consisting of small Latin letters string can also contain characters of string is calculated by following metric Any two letters can be swapped positions these operations can be performed arbitrary number of times over any pair of positions Among all resulting strings you choose the one with the largest number of occurrences of string is this number of occurrences You should replace all characters with small Latin letters in such a way that the of string is maximal ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <array>\n\nvoid run(std::istream &in, std::ostream &out) {\n    std::string s, t;\n    in >> s >> t;\n    std::array<int, 26> statT = {};\n    for (char c : t) {\n        statT[c - \'a\']++;\n    }\n    std::array<int, 26> statS = {};\n    int empty = 0;\n    for (char c : s) {\n        if (c == \'?\') {\n            empty++;\n        } else {\n            statS[c - \'a\']++;\n        }\n    }\n    int k;\n    for (k = 1; ; k++) {\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += std::max(statT[i] * k - statS[i], 0);\n        }\n        if (res > empty) {\n            k--;\n            break;\n        }\n    }\n    std::string res;\n    for (int i = 0; i < 26; i++) {\n        int d = std::max(statT[i] * k - statS[i], 0);\n        res.append(d, \'a\' + i);\n    }\n    size_t pos = 0;\n    for (char& c : s) {\n        if (c == \'?\') {\n            if (pos < res.size()) {\n                c = res[pos];\n                pos++;\n            } else {\n                c = \'a\';\n            }\n        }\n    }\n    out << s << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","['binary search', 'greedy', 'implementation']",1500
https://codeforces.com//contest/1801/problem/E,E. Gasoline prices,Berland is a huge country consisting of n cities The road network of Berland can be represented as a root tree that is there is only n 1 road in the country and you can get from any city to any other exactly one way if you do not visit any city twice For the convenience of representing the country for each city i the city p i is fixed equal to the first city to which you need to go from the city i to get to the city 1 In other words the city p i is equal to the ancestor of the city i if the tree is hung for the city 1 There is one gas station in each city of Berland Gas stations have special pricing and for each gas station there is a fixed range of prices for which they are ready to sell gasoline A gas station in the city with the number i is ready to sell gasoline at any price from l i to r i inclusive The King of Berland is an exemplary family man and for m years two sons were born to him every year The king s children have been involved in public affairs since early childhood and at the end of each year they check the honesty of gasoline prices From birth the king s children who are born in the year i are responsible for checking gasoline prices on the ways from the city of a i to the city of b i and from the city of c i to the city of d i respectively The check is as follows both children simultaneously start their journey from the cities a i and c i respectively The first son of the king born in the year i moves along the path from the city a i to the city b i and the second from the city c i to the city d i Children check that the price of gasoline in the city of a i coincides with the price of gasoline in the city of c i Next they check that the price of gasoline in the second city on the way from a i to b i coincides with the price in the second city on the way from c i to d i Then they repeat the same thing for a couple of third cities on their paths and so on At the end they check that the price of gasoline in the city of b i coincides with the price of gasoline in the city of d i It is guaranteed that the length of the path from the city a i to the city b i coincides with the length of the path from the city c i to the city d i Gas stations must strictly obey the laws and therefore all checks of gasoline prices should not reveal violations Help Berland gas stations find out how many ways they can set gasoline prices for m years In other words for each i from 1 to m calculate how many ways you can set gasoline prices at all gas stations so that after the birth of the first i pairs of the king s children all their checks did not reveal violations and at any gas station the price was in the acceptable price range Since the number of such methods can be large calculate the answer modulo 10 9 7 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tvoid clear(){\n\t\tfill(all(p),-1);\n\t\tfill(all(s),1);\n\t\tc=si(p);\n\t}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//Lyft Level 5 Challenge 2018 - Final F\n//CF635F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n+10)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<int> t(n);\n\trng(i,1,n){\n\t\tint p;cin>>p;p--;\n\t\tt[p].pb(i);\n\t}\n\tbool bad=false;\n\tmint ans=1;\n\tvc<pi> lr(n);\n\trep(i,n){\n\t\tlr[i]=readpi();\n\t\tlr[i].b++;\n\t\tans*=lr[i].b-lr[i].a;\n\t}\n\tdoubling<int> z(t,0);\n\tunionfind uf(n);\n\tvc<unionfind> es(z.h,unionfind(2*n));\n\tauto mg=[&](auto self,int lv,int k,int a,int b)->void{\n\t\tbool x=es[lv].unite(a,k*n+b);\n\t\tbool y=es[lv].unite(n+a,(1-k)*n+b);\n\t\tif(x||y){\n\t\t\tif(lv==0){\n\t\t\t\ta=uf.find(a);\n\t\t\t\tb=uf.find(b);\n\t\t\t\tif(a!=b){\n\t\t\t\t\tans/=lr[a].b-lr[a].a;\n\t\t\t\t\tans/=lr[b].b-lr[b].a;\n\t\t\t\t\tchmax(lr[a].a,lr[b].a);\n\t\t\t\t\tchmin(lr[a].b,lr[b].b);\n\t\t\t\t\tif(lr[a].a>=lr[a].b)bad=true;\n\t\t\t\t\tans*=lr[a].b-lr[a].a;\n\t\t\t\t\tuf.unite(a,b);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(k==0){\n\t\t\t\t\tself(self,lv-1,0,a,b);\n\t\t\t\t\tself(self,lv-1,0,z.par[lv-1][a],z.par[lv-1][b]);\n\t\t\t\t}else{\n\t\t\t\t\tself(self,lv-1,1,a,z.par[lv-1][b]);\n\t\t\t\t\tself(self,lv-1,1,z.par[lv-1][a],b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tint m;cin>>m;\n\tvi x(z.h),y(z.h);\n\trep(_,m){\n\t\tint v[2][2];rep(i,2)rep(j,2){cin>>v[i][j];v[i][j]--;}\n\t\tint lca[2]{};\n\t\trep(k,2)lca[k]=z.lca(v[k][0],v[k][1]);\n\t\trep(j,2){\n\t\t\tint u=inf;\n\t\t\trep(i,2)chmin(u,z.dep[v[i][j]]-z.dep[lca[i]]);\n\t\t\tper(lv,z.h)if(u&1<<lv){\n\t\t\t\tmg(mg,lv,0,v[0][j],v[1][j]);\n\t\t\t\trep(i,2)v[i][j]=z.par[lv][v[i][j]];\n\t\t\t}\n\t\t}\n\t\tif(z.dep[v[0][0]]<z.dep[v[0][1]]){\n\t\t\trep(i,2)swap(v[i][0],v[i][1]);\n\t\t}\n\t\tassert(z.dep[v[0][0]]-z.dep[v[0][1]]==z.dep[v[1][1]]-z.dep[v[1][0]]);\n\t\tint u=z.dep[v[0][0]]-z.dep[v[0][1]]+1;\n\t\tfill(all(x),-1);\n\t\tfill(all(y),-1);\n\t\trep(lv,z.h)if(u&1<<lv){\n\t\t\tx[lv]=v[0][0];\n\t\t\tv[0][0]=z.par[lv][v[0][0]];\n\t\t}\n\t\tper(lv,z.h)if(u&1<<lv){\n\t\t\ty[lv]=v[1][1];\n\t\t\tv[1][1]=z.par[lv][v[1][1]];\n\t\t}\n\t\trep(lv,z.h)if(x[lv]!=-1){\n\t\t\tmg(mg,lv,1,x[lv],y[lv]);\n\t\t}\n\t\tif(bad)print(0);\n\t\telse print(ans);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'divide and conquer', 'dsu', 'hashing', 'trees']",3000
https://codeforces.com//contest/1872/problem/E,E. Data Structures Fan,You are given an array of integers a 1 a 2 ldots a n as well as a binary string dagger s consisting of n characters Augustin is a big fan of data structures Therefore he asked you to implement a data structure that can answer q queries There are two types of queries 1 l r 1 le l le r le n replace each character s i for l le i le r with its opposite That is replace all texttt 0 with texttt 1 and all texttt 1 with texttt 0 2 g g in 0 1 calculate the value of the bitwise XOR of the numbers a i for all indices i such that s i g Note that the operatorname XOR of an empty set of numbers is considered to be equal to 0 Please help Augustin to answer all the queries For example if n 4 a 1 2 3 6 s texttt 1001 consider the following series of queries 2 0 we are interested in the indices i for which s i tt 0 since s tt 1001 these are the indices 2 and 3 so the answer to the query will be a 2 oplus a 3 2 oplus 3 1 1 1 3 we need to replace the characters s 1 s 2 s 3 with their opposites so before the query s tt 1001 and after the query s tt 0111 2 1 we are interested in the indices i for which s i tt 1 since s tt 0111 these are the indices 2 3 and 4 so the answer to the query will be a 2 oplus a 3 oplus a 4 2 oplus 3 oplus 6 7 1 2 4 s tt 0111 to s tt 0000 2 1 s tt 0000 there are no indices with s i tt 1 so since the operatorname XOR of an empty set of numbers is considered to be equal to 0 the answer to this query is 0 dagger A binary string is a string containing only characters texttt 0 or texttt 1 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\n#define pll pair<ll,ll>\n\nstruct SEG {\n    vector<pll> arr;\n    vector<bool> tswap;\n\n    void make(ll n) {\n        arr.resize(4*n);\n        tswap.resize(4*n);\n    }\n\n    void pull(ll v) {\n        arr[v] = arr[v*2];\n        arr[v].first ^= arr[v*2+1].first;\n        arr[v].second ^= arr[v*2+1].second;\n    }\n\n    void dswap(ll v) {\n        tswap[v] = !tswap[v];\n        swap(arr[v].first, arr[v].second);\n    }\n\n    void push(ll v) {\n        if (tswap[v]) {\n            dswap(v*2);\n            dswap(v*2+1);\n            tswap[v] = 0;\n        }\n    }\n\n    void set(ll v, ll tl, ll tr, ll ind, pll val) {\n        if (tl == tr) {\n            arr[v] = val;\n            return;\n        }\n        ll tm = (tl + tr) / 2;\n        if (ind <= tm)\n            set(v*2, tl, tm, ind, val);\n        else set(v*2+1, tm+1, tr, ind, val);\n        pull(v);\n    }\n\n    void rswap(ll v, ll tl, ll tr, ll l, ll r) {\n        if (l > r) return;\n        if (tl == l && tr == r) {\n            dswap(v);\n            return;\n        }\n        push(v);\n        ll tm = (tl + tr) / 2;\n        rswap(v*2, tl, tm, l, min(r, tm));\n        rswap(v*2+1, tm+1, tr, max(l,tm+1), r);\n        pull(v);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        SEG seg;\n        seg.make(n);\n        for (ll i = 0; i < n; i++) {\n            ll v;\n            cin >> v;\n            seg.set(1, 0, n-1, i, {v, 0});\n        }\n        for (ll i = 0; i < n; i++) {\n            char c;\n            cin >> c;\n            if (c == '1') seg.rswap(1, 0, n-1, i, i);\n        }\n        ll q;\n        cin >> q;\n        while (q--) {\n            ll t;\n            cin >> t;\n            if (t == 1) {\n                ll l, r;\n                cin >> l >> r;\n                seg.rswap(1, 0, n-1, l-1, r-1);\n            } else {\n                ll g;\n                cin >> g;\n                if (g == 0) {\n                    cout << seg.arr[1].first << ' ';\n                } else {\n                    cout << seg.arr[1].second << ' ';\n                }\n            }\n        }\n        cout << '\\n';\n    }\n}""]","['binary search', 'bitmasks', 'data structures', 'dp']",1500
https://codeforces.com//contest/1732/problem/A,A. Bestie,You are given an array a consisting of n integers a 1 a 2 ldots a n Friends asked you to make the greatest common divisor GCD of all numbers in the array equal to 1 In one operation you can do the following Select an arbitrary index in the array 1 leq i leq n Make a i gcd a i i where gcd x y denotes the GCD of integers x and y The cost of such an operation is n i 1 You need to find the minimum total cost of operations we need to perform so that the GCD of the all array numbers becomes equal to 1 ,"[""#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n,a[25],res,dp[25],b[25];\nbool vis[25];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n);\n\t\tint fk=0;\n\t\tfor(int i=1;i<=n;i++)gi(a[i]),b[i]=__gcd(i,a[i]),fk=__gcd(fk,a[i]);\n\t\tif(fk==1){\n\t\t\tpi(0,'\\n');\n\t\t\tcontinue;\n\t\t}\n\t\tres=1e9;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++)dp[j]=1e9;\n\t\t\tdp[__gcd(a[i],i)]=n-i+1;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[__gcd(b[j],k)]=min(dp[__gcd(b[j],k)],dp[k]+n-j+1);\n\t\t\t\t\tdp[__gcd(a[j],k)]=min(dp[__gcd(a[j],k)],dp[k]);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tres=min(res,dp[1]);\n\t\t}\n\t\tpi(res,'\\n');\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/""]","['brute force', 'combinatorics', 'constructive algorithms', 'implementation', 'math', 'number theory']",1000
https://codeforces.com//contest/375/problem/B,B. Maximum Submatrix 2,You are given a matrix consisting of digits zero and one its size is You are allowed to rearrange its rows What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations Let s assume that the rows of matrix are numbered from 1 to from top to bottom and the columns are numbered from 1 to from left to right A matrix cell on the intersection of the th row and the th column can be represented as Formally a submatrix of matrix is a group of four integers We will assume that the submatrix contains cells The area of the submatrix is the number of cells it contains ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int MAX_N = 5000 + 10;\nchar map[MAX_N][MAX_N];\nint rt[MAX_N][MAX_N];\nint n, m;\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int r = 0; r < n; ++r) {\n\t\tscanf(""%s"", map[r]);\n\t}\n\n\tfor (int r = 0; r < n; ++r) {\n\t\trt[r][m] = 0;\n\t\tfor (int c = m - 1; c >= 0; --c) {\n\t\t\trt[r][c] = map[r][c] == \'1\' ? rt[r][c + 1] + 1 : 0;\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor (int c = 0; c < m; ++c) {\n\t\tstatic int a[MAX_N];\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\ta[r] = rt[r][c];\n\t\t}\n\t\tsort(a, a + n);\n\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tans = max(ans, a[r] * (n - r));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n']","['data structures', 'dp', 'implementation', 'sortings']",1600
https://codeforces.com//contest/1185/problem/A,A. Ropewalkers,Polycarp decided to relax on his weekend and visited to the performance of famous ropewalkers Agafon Boniface and Konrad The rope is straight and infinite in both directions At the beginning of the performance Agafon Boniface and Konrad are located in positions a b and c respectively At the end of the performance the distance between each pair of ropewalkers was d Ropewalkers can walk on the rope In one second only one ropewalker can change his position Every ropewalker can change his position exactly by 1 i e shift by 1 to the left or right direction on the rope Agafon Boniface and Konrad move at the same time Ropewalkers can be at the same positions at the same time and can walk past each other You should find the minimum duration in seconds of the performance In other words find the minimum number of seconds needed so that the distance between each pair of ropewalkers can be greater or equal to d Ropewalkers can walk to negative coordinates due to the rope is infinite to both sides ,"[""///Mn kotr el labawy mb2t4 nawy\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main(){\n\n  int a, b, c, d;\n\n  cin >> a >> b >> c >> d;\n  int x[]={a,b,c};\n  sort(x,x+3);\n\n  cout<<max(0,d-abs(x[0]-x[1]))+max(0,d-abs(x[1]-x[2]))<<'\\n';\n\n\n  return 0;\n}\n""]",['math'],800
https://codeforces.com//contest/1554/problem/B,B. Cobb,You are given n integers a 1 a 2 ldots a n and an integer k Find the maximum value of i cdot j k cdot a i a j over all pairs i j of integers with 1 le i j le n Here is the bitwise OR operator ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint t,n,k,a[100005];\nint main()\n{\n    scanf(""%d"",&t);\n    while(t--)\n    {\n        scanf(""%d%d"",&n,&k);\n        for(int i=1;i<=n;i++)\n        {\n            scanf(""%d"",&a[i]);\n        }\n        long long ans=-1e9;\n        for(int i=max(1,n-105);i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                ans=max(ans,((long long)i)*j-(a[i]|a[j])*k);\n            }\n        }\n        printf(""%lld\\n"",ans);\n    }\n}']","['bitmasks', 'brute force', 'greedy', 'math']",1700
https://codeforces.com//contest/116/problem/B,B. Little Pigs and Wolves,Once upon a time there were several little pigs and several wolves on a two dimensional grid of size Each cell in this grid was either empty containing one little pig or containing one wolf A little pig and a wolf are adjacent if the cells that they are located at share a side The little pigs are afraid of wolves so there will be at most one wolf adjacent to each little pig But each wolf may be adjacent to any number of little pigs They have been living peacefully for several years But today the wolves got hungry One by one each wolf will choose one of the little pigs adjacent to it if any and eats the poor little pig This process is not repeated That is each wolf will get to eat at most one little pig Once a little pig gets eaten it disappears and cannot be eaten by any other wolf What is the maximum number of little pigs that may be eaten by the wolves ,"[""#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <numeric>\n \nusing namespace std;\n \nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n \n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nint M, N;\nstring grid[20];\n\nbool check(int i, int j) {\n\tif(i > 0 && grid[i-1][j] == 'P') return true;\n\tif(i < M-1 && grid[i+1][j] == 'P') return true;\n\tif(j > 0 && grid[i][j-1] == 'P') return true;\n\tif(j < N-1 && grid[i][j+1] == 'P') return true;\n\treturn false;\n}\n\nint main() {\n\tcin >> M >> N;\n\tFOR(i,0,M) cin >> grid[i];\n\tint ct = 0;\n\tFOR(i,0,M) FOR(j,0,N) {\n\t\tif(grid[i][j] == 'W' && check(i,j)) ct++;\n\t}\n\tcout << ct << endl;\n\treturn 0;\n}\n\n""]","['greedy', 'implementation']",1100
https://codeforces.com//contest/406/problem/B,B. Toy Sum,Little Chris is very keen on his toy blocks His teacher however wants Chris to solve more problems so he decided to play a trick on Chris There are exactly blocks in Chris s set each block has a unique number from 1 to Chris s teacher picks a subset of blocks and keeps it to himself He will give them back only if Chris can pick such a non empty subset from the remaining blocks that the equality holds Are you kidding me asks Chris For example consider a case where and Chris s teacher took the blocks with numbers 1 4 and 5 One way for Chris to choose a set is to pick the blocks with numbers 3 and 6 see figure Then the required sums would be equal However now Chris has exactly blocks Given the set of blocks his teacher chooses help Chris to find the required set ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA ""sequence""\n\nconst int N=1000000;\nbool A0[N+100];\nbool A[N+100];\n\nint main(){\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n\t//freopen(TASKA"".in"", ""r"", stdin); freopen(TASKA"".out"", ""w"", stdout);\n#endif\n\t\n\tint n;\n\tcin>>n;\n\tforn(i,n){\n\t\tint a;\n\t\tscanf(""%d"",&a);\n\t\tA0[a]=true;\n\t\tA[a]=true;\n\t}\n\tvector<int> res;\n\tint c=0;\n\tfor(int i=1;i<=N;++i){\n\t\tif(A0[i]){\n\t\t\tif(A0[N-i+1]){\n\t\t\t\tif(N-i+1>=i)\n\t\t\t\t\t++c;\n\t\t\t}else{\n\t\t\t\tA[N-i+1]=true;\n\t\t\t\tres.pb(N-i+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tif(!c)\n\t\t\tbreak;\n\t\tif(A[i])\n\t\t\tcontinue;\n\t\tif(A[N-i+1])\n\t\t\texit(123);\n\t\t--c;\n\t\tA[i]=A[N-i+1]=true;\n\t\tres.pb(i);\n\t\tres.pb(N-i+1);\n\t}\n\t\n\tcout<<sz(res)<<endl;\n\tforv(i,res){\n\t\tprintf(""%d "",res[i]);\n\t}\n\t\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy']",1700
https://codeforces.com//contest/1144/problem/B,B. Parity Alternated Deletions,Polycarp has an array a consisting of n integers He wants to play a game with this array The game consists of several moves On the first move he chooses any element and deletes it after the first move the array contains n 1 elements For each of the next moves he chooses any element with the only restriction its parity should differ from the parity of the element deleted on the previous move In other words he alternates parities even odd even odd or odd even odd even of the removed elements Polycarp stops if he can t make a move Formally If it is the first move he chooses any element and deletes it If it is the second or any next move if the last deleted element was Polycarp chooses any element and deletes it if the last deleted element was Polycarp chooses any element and deletes it If after some move Polycarp cannot make a move the game ends Polycarp s goal is to the sum of elements of the array after end of the game If Polycarp can delete the whole array then the sum of elements is zero Help Polycarp find this value ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\npriority_queue<int,vector<int> ,greater<int> >q,p;\nint main(){\n\tint odd = 0,even = 0,k;\n\tscanf(""%d"",&n);\n\tfor (int i = 0; i < n; ++i){\n\t\tscanf(""%d"",&k);\n\t\tif (k & 1) q.push(k),odd++; else\n\t\tp.push(k),even++;\n\t}\n\tlong long ans = 0;\n\tif (odd < even){\n\t\teven -= odd;\n\t\tif (even) even--;\n\t\twhile(even){\n\t\t\tans += p.top(); \n\t\t\tp.pop(); \n\t\t\teven--;\n\t\t}\n\t} else{\n\t\todd -= even;\n\t\tif (odd) odd--;\n\t\twhile(odd){\n\t\t\tans += q.top();\n\t\t\tq.pop(); \n\t\t\todd--;\n\t\t}\n\t}\n\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}']","['greedy', 'implementation', 'sortings']",900
https://codeforces.com//contest/1195/problem/F,F. Geometers Anonymous Club,Denis holds a Geometers Anonymous Club meeting in SIS He has prepared n convex polygons numbered from 1 to n for the club He plans to offer members of the club to calculate Minkowski sums of these polygons More precisely he plans to give q tasks the i th of them asks to calculate the sum of Minkowski of polygons with indices from l i to r i inclusive The sum of Minkowski of two sets A and B is the set C a b a in A b in B It can be proven that if A and B are convex polygons then C will also be a convex polygon Sum of two convex polygons To calculate the sum of Minkowski of p polygons p 2 you need to calculate the sum of Minkowski of the first p 1 polygons and then calculate the sum of Minkowski of the resulting polygon and the p th polygon For the convenience of checking answers Denis has decided to prepare and calculate the number of vertices in the sum of Minkowski for each task he prepared Help him to do it ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\n\nint sz[N], bd[N], kt[N], x[N], y[N], a[N], last[N], le[N], ri[N], pos[N], bit[N], kq[N];\n\nbool cmp(int i, int j) {\n    return ri[i] < ri[j] || (ri[i] == ri[j] && i < j);\n}\n\nint main() {\n    int n;\n    scanf(""%d"", &n);\n    int cnt = 1;\n    map<pair<int,int>,int> mp;\n    int dem = 0;\n    for (int i = 1; i <= n; i++) {\n        scanf(""%d"", sz+i);\n        bd[i] = cnt;\n        int ss = sz[i];\n        for (int j = 0; j <= ss; j++) {\n            if (j == ss) {\n                x[j] = x[0];\n                y[j] = y[0];\n            }\n            else\n                scanf(""%d%d"", x+j, y+j);\n            if (j > 0) {\n                int xx = x[j] - x[j-1];\n                int yy = y[j] - y[j-1];\n                int g = __gcd(abs(xx), abs(yy));\n                xx /= g;\n                yy /= g;\n                auto p = make_pair(xx, yy);\n                int z = mp[p];\n                if (z == 0) {\n                    z = ++dem;\n                    mp[p] = z;\n                }\n                a[cnt++] = z;\n            }\n        }\n        kt[i] = cnt-1;\n    }\n    int q;\n    scanf(""%d"", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(""%d%d"", le+i, ri+i);\n        le[i] = bd[le[i]];\n        ri[i] = kt[ri[i]];\n        pos[i] = i;\n    }\n    sort(pos, pos+q, cmp);\n    int cur = 1;\n    for (int i = 0; i < q; i++) {\n        int l = le[pos[i]];\n        int r = ri[pos[i]];\n        while (cur <= r) {\n            int val = a[cur];\n            if (last[val] > 0) {\n                for (int u = last[val]; u <= cnt; u += u & (-u))\n                    bit[u]--;\n            }\n            last[val] = cur;\n            for (int u = cur; u <= cnt; u += u & (-u))\n                bit[u]++;\n            cur++;\n        }\n        int res = 0;\n        for (int u = r; u > 0; u -= u & (-u))\n            res += bit[u];\n        for (int u = l-1; u > 0; u -= u & (-u))\n            res -= bit[u];\n        kq[pos[i]] = res;\n    }\n    for (int i = 0; i < q; i++) printf(""%d\\n"", kq[i]);\n}']","['data structures', 'geometry', 'math', 'sortings']",2500
https://codeforces.com//contest/1426/problem/F,F. Number of Subsequences,You are given a string s consisting of lowercase Latin letters and and question marks Let the number of question marks in the string s be k Let s replace each question mark with one of the letters and Here we can obtain all 3 k possible strings consisting only of letters and For example if s then we can obtain the following strings Your task is to count the total number of subsequences in all resulting strings Since the answer can be very large print it modulo 10 9 7 A subsequence of the string t is such a sequence that can be derived from the string t after removing some possibly zero number of letters without changing the order of remaining letters For example the string contains two subsequences a subsequence consisting of letters at positions 2 5 6 and a subsequence consisting of letters at positions 3 5 6 ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl ""\\n""\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<\'(\'<<p.F<< "",""<<p.S<<\')\'; \n}\n\n    \nconst int MOD=1000000007;\nstruct Mint {\n    int val;\n \n    Mint(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n        if (v >= MOD)\n            v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        int g = m, r = a, x = 0, y = 1;\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        } \n        return x < 0 ? x + m : x;\n    } \n    explicit operator int() const {\n        return val;\n    }\n    Mint& operator+=(const Mint &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    Mint& operator-=(const Mint &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n           #if !defined(_WIN32) || defined(_WIN64)\n                return x % m;\n           #endif\n           unsigned x_high = x >> 32, x_low = (unsigned) x;\n           unsigned quot, rem;\n           asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n           return rem;\n    }\n    Mint& operator*=(const Mint &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n    Mint& operator/=(const Mint &other) {\n        return *this *= other.inv();\n    }\n    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }\n    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }\n    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }\n    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }\n    Mint& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n    Mint& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }\n    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }\n    Mint operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n    bool operator==(const Mint &other) const { return val == other.val; }\n    bool operator!=(const Mint &other) const { return val != other.val; }\n    Mint inv() const {\n        return mod_inv(val);\n    }\n    Mint power(long long p) const {\n        assert(p >= 0);\n        Mint a = *this, result = 1;\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n        return result;\n    }\n    friend ostream& operator << (ostream &stream, const Mint &m) {\n        return stream << m.val;\n    }\n    friend istream& operator >> (istream &stream, Mint &m) {\n        return stream>>m.val;   \n    }\n};\n\n\nconst int N = 200005;\nstring s;\nint n;\n\nMint dp[N][3];\n\nint _runtimeTerror_()\n{\n    cin>>n>>s;\n    int cnt = 0;\n    for(int i=1;i<=n;++i)\n    {\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = dp[i-1][1];\n        dp[i][2] = dp[i-1][2];\n        char c = s[i-1];\n        if(s[i-1] != \'?\')\n        {\n            if(c==\'a\')\n                dp[i][0] += Mint(3).power(cnt);\n            else if(c==\'b\')\n                dp[i][1] += dp[i-1][0];\n            else if(c==\'c\')\n                dp[i][2] += dp[i-1][1];\n        }\n        else\n        {\n            dp[i][0] += Mint(3).power(cnt)+ 2*dp[i-1][0];\n            dp[i][1] += dp[i-1][0] + 2*dp[i-1][1];\n            dp[i][2] += dp[i-1][1] + 2*dp[i-1][2];\n        }\n        if(s[i-1]==\'?\')\n            ++cnt;\n    }\n    // for(int i=1;i<=n;++i)\n    // {\n    //     for(int j=0;j<3;++j)\n    //         cout<<dp[i][j]<<"" "";\n    //     cout<<""\\n"";\n    // }\n    cout<<dp[n][2]<<""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    //cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","['combinatorics', 'dp', 'strings']",2000
https://codeforces.com//contest/1242/problem/A,A. Tile Painting,Ujan has been lazy lately but now has decided to bring his yard to good shape First he decided to paint the path from his house to the gate The path consists of n consecutive tiles numbered from 1 to n Ujan will paint each tile in some color He will consider the path if for any two tiles with numbers i and j such that j i is a divisor of n greater than 1 they have the same color Formally the colors of two tiles with numbers i and j should be the same if i j 1 and n bmod i j 0 where x bmod y is the remainder when dividing x by y Ujan wants to brighten up space What is the maximum number of different colors that Ujan can use so that the path is aesthetic ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nnamespace factorBasic {\n\ttemplate<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine\n\t\tvector<pair<T,int>> pri;\n\n\t\tfor (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n\t\t\tint t = 0;\n\t\t\twhile (x % i == 0) x /= i, t ++;\n\t\t\tpri.pb({i,t});\n\t\t}\n\n\t\tif (x > 1) pri.pb({x,1});\n\t\treturn pri;\n\t}\n\n\t/* Note:\n\t * number of operations needed s.t.\n\t *\t\t\t\t  phi(phi(...phi(n)...))=1\n\t * is O(log n).\n\t * Euler\'s theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1\n\t */\n\n\tll phi(ll x) {\n\t\ttrav(a,factor(x)) x -= x/a.f;\n\t\treturn x;\n\t}\n\n\ttemplate<class T> void tour(vector<pair<T,int>>& v, vector<T>& V, int ind, T cur) {\n\t\tif (ind == sz(v)) V.pb(cur);\n\t\telse {\n\t\t\tT mul = 1;\n\t\t\tF0R(i,v[ind].s+1) {\n\t\t\t\ttour(v,V,ind+1,cur*mul);\n\t\t\t\tmul *= v[ind].f;\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate<class T> vector<T> getDivi(T x) {\n\t\tauto v = factor(x);\n\t\tvector<T> V; tour(v,V,0,(T)1); sort(all(V));\n\t\treturn V;\n\t}\n}\n\nusing namespace factorBasic;\n\nll n;\n\nint main() {\n\tsetIO(); re(n);\n\tauto a = factor(n);\n\tif (sz(a) == 1) ps(a[0].f);\n\telse ps(1);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']","['constructive algorithms', 'math', 'number theory']",1500
https://codeforces.com//contest/1349/problem/D,D. Slime and Biscuits,Slime and his n friends are at a party Slime has designed a game for his friends to play At the beginning of the game the i th player has a i biscuits At each second Slime will choose a biscuit randomly uniformly among all a 1 a 2 ldots a n biscuits and the owner of this biscuit will give it to a random uniform player among n 1 players except himself The game stops when one person will have all the biscuits As the host of the party Slime wants to know the expected value of the time that the game will last to hold the next activity on time For convenience as the answer can be represented as a rational number frac p q for coprime p and q you need to find the value of p cdot q 1 mod 998 244 353 You can prove that q mod 998 244 353 neq 0 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 300300;\nll f[N];\nint n, s;\nint a[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\ts += a[i];\n\t}\n\n\tf[0] = 0;\n\tf[1] = mult(n - 1, rev(n));\n\tfor (int x = 1; x < s; x++) {\n\t\tll val = mult(s, rev(n));\n\t\tval = sub(val, mult(x, sub(f[x - 1], f[x])));\n\t\tval = mult(val, n - 1);\n\t\tval = mult(val, rev(s - x));\n\t\tf[x + 1] = add(val, f[x]);\n\t}\n\tll ans = f[s];\n\tfor (int i = 0; i < n; i++)\n\t\tans = sub(ans, f[a[i]]);\n\tprintf(""%lld\\n"", ans);\n\t//printf(""%lld\\n"", mult(ans, 3));\n\n\treturn 0;\n}\n']","['math', 'probabilities']",3200
https://codeforces.com//contest/504/problem/C,C. Misha and Palindrome Degree,Misha has an array of integers indexed by integers from to Let s define of array as the number of such index pairs that the elements from the th to the th one inclusive can be rearranged in such a way that the array will be a palindrome In other words pair should meet the condition that after some rearranging of numbers on positions from to inclusive it is allowed not to rearrange the numbers at all for any following condition holds Your task is to find the of Misha s array ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <set>\n#include <map>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint n, a[210000], sum[210000];\nlong long ans;\n\nbool in(int k, int l, int r) {\n\treturn l <= k && k <= r;\n}\n\nbool can(int l, int r) {\n\tfor (int i = 1; i <= n; i++)\n\t\tsum[i] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!in(i, l, r) && !in(n - i + 1, l, r) && a[i] != a[n - i + 1])\n\t\t\treturn false;\n\tfor (int i = l; i <= r; i++)\n\t\tsum[a[i]]++;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!in(i, l, r) && in(n - i + 1, l, r)) {\n\t\t\tsum[a[i]]--;\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (sum[a[i]] < 0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]), sum[a[i]]++;\n\tint s = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\ts += sum[i] % 2;\n\tif (s > 1) {\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tbool ok = true;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] != a[n - i + 1])\n\t\t\tok = false;\n\tif (ok) {\n\t\tprintf(""%I64d\\n"", 1LL * n * (n + 1) / 2);\n\t\treturn 0;\n\t}\n\tint l = 1;\n\twhile (a[l] == a[n - l + 1])\n\t\tl++;\n\tint q = l - 1, h = n, mid;\n\twhile (q < h - 1) {\n\t\tmid = (q + h) / 2;\n\t\tif (can(l, mid))\n\t\t\th = mid;\n\t\telse\n\t\t\tq = mid;\n\t}\n\tans += 1LL * l * (n - h + 1);\n\tfor (int i = 1; i <= n - i + 1; i++)\n\t\tswap(a[i], a[n - i + 1]);\n\tq = l - 1;\n\th = n;\n\twhile (q < h - 1) {\n\t\tmid = (q + h) / 2;\n\t\tif (can(l, mid))\n\t\t\th = mid;\n\t\telse\n\t\t\tq = mid;\n\t}\n\tans += 1LL * l * (n - l + 1 - h);\n\tprintf(""%I64d\\n"", ans);\n}']","['implementation', 'math']",2500
https://codeforces.com//contest/1067/problem/A,A. Array Without Local Maximums ,Ivan unexpectedly saw a present from one of his previous birthdays It is array of n numbers from 1 to 200 Array is old and some numbers are hard to read Ivan remembers that for all elements at least one of its neighbours ls not less than it more formally a 1 le a 2 a n le a n 1 anda i le max a i 1 a i 1 for all i from 2 to n 1 Ivan does not remember the array and asks to find the number of ways to restore it Restored elements also should be integers from 1 to 200 Since the number of ways can be big print it modulo 998244353 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst int d=200;\n\nint n;\n\nll dps[nax][2];\nll dpn[nax][2];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\ninline int mog(int v, int i)\n{\n\tif (v==i)\n\t\treturn 1;\n\tif (v==-1)\n\t\treturn i>0;\n\treturn 0;\n}\n\nvoid upd(int v)\n{\n\tfor (int i=0; i<=d; i++)\n\t{\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tdps[i][j]=dpn[i][j];\n\t\t\tdpn[i][j]=0;\n\t\t}\n\t}\n\tll s=0;\n\tfor (int i=0; i<=d; i++)\n\t{\n\t\tif (mog(v, i))\n\t\t\tdod(dpn[i][0], s);\n\t\tdod(s, dps[i][0]+dps[i][1]);\n\t}\n\ts=0;\n\tfor (int i=d; i>=0; i--)\n\t{\n\t\tif (mog(v, i))\n\t\t\tdod(dpn[i][1], s);\n\t\tdod(s, dps[i][1]);\n\t}\n\tfor (int i=0; i<=d; i++)\n\t{\n\t\tif (mog(v, i))\n\t\t\tdod(dpn[i][1], dps[i][0]+dps[i][1]);\n\t}\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tdpn[0][1]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tupd(x);\n\t}\n\tupd(0);\n\tprintf(""%lld\\n"", dpn[0][1]);\n\treturn 0;\n}\n']",['dp'],1900
https://codeforces.com//contest/1109/problem/A,A. Sasha and a Bit of Relax,Sasha likes programming Once during a very long contest Sasha decided that he was a bit tired and needed to relax So he did But since Sasha isn t an ordinary guy he prefers to relax unusually During leisure time Sasha likes to upsolve unsolved problems because upsolving is very useful Therefore Sasha decided to upsolve the following problem You have an array a with n integers You need to count the number of pairs l r l leq r To check if a pair l r is a pair take mid frac l r 1 2 then if r l 1 is an number and a l oplus a l 1 oplus ldots oplus a mid a mid 1 oplus a mid 2 oplus ldots oplus a r then the pair is In other words oplus of elements of the left half of the subarray from l to r should be equal to oplus of elements of the right half Note that oplus denotes the bitwise XOR operation It is time to continue solving the contest so Sasha asked you to solve this task ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int C = (1 << 20) + 3;\nll a[2][C];\nll ans = 0;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint n;\n\tscanf(""%d"", &n);\n\tint bal = 0;\n\ta[0][bal]++;\n\tint t = 0;\n\twhile(n--) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tbal ^= x;\n\t\tt ^= 1;\n\t\tans += a[t][bal];\n\t\ta[t][bal]++;\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['dp', 'implementation']",1600
https://codeforces.com//contest/1294/problem/F,F. Three Paths on a Tree,You are given an unweighted tree with n vertices Recall that a tree is a connected undirected graph without cycles Your task is to choose vertices a b c on this tree such that the number of edges which belong to one of the simple paths between a and b b and c or a and c is the maximum possible See the notes section for a better understanding The simple path is the path that visits each vertex at most once ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nint de[N];\nint fa[N];\nvector<int>G[N];\nint root;\nint ed;\nint vis[N];\nint d[N];\nvoid dfs(int x){\n    for(int i=0;i<G[x].size();i++){\n        int &y=G[x][i];\n        if(!de[y]){\n            fa[y]=x;\n            de[y]=de[x]+1;\n            dfs(y);\n        }\n    }\n}\nqueue<int>q;\nvoid dfs1(int x){\n    vis[x]=1;\n    q.push(x);\n    if(fa[x]<=0)return;\n    dfs1(fa[x]);\n}\nint main()\n{\n    cin>>n;\n    for(int i=1,u,v;i<n;i++){\n        scanf(""%d%d"",&u,&v);\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n    de[1]=1;\n    dfs(1);\n    for(int i=1;i<=n;i++){\n        if(de[i]>de[root])root=i;\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)de[i]=fa[i]=0;\n    de[root]=1;\n    dfs(root);\n    for(int i=1;i<=n;i++){\n        if(de[i]>de[ed])ed=i;\n    }\n    ans=de[ed]-1;\n    dfs1(ed);\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        for(int i=0;i<G[x].size();i++){\n            int &y=G[x][i];\n            if(!vis[y]){\n                vis[y]=1;\n                d[y]=d[x]+1;\n                q.push(y);\n            }\n        }\n    }\n    int mx=1;\n    while(mx==root||mx==ed)mx++;\n    for(int i=1;i<=n;i++)if(d[i]>d[mx])mx=i;\n    ans+=d[mx];\n    //cout<<root<<\' \'<<ed<<endl;\n    cout<<ans<<endl;\n    cout<<root<<\' \'<<mx<<\' \'<<ed<<endl;\n    return 0;\n}\n']","['dfs and similar', 'dp', 'greedy', 'trees']",2000
https://codeforces.com//contest/309/problem/C,C. Memory for Arrays,You get to work and turn on the computer You start coding and give little thought to the RAM role in the whole process In this problem your task is to solve one of the problems you encounter in your computer routine We ll consider the RAM as a sequence of cells that can contain data Some cells already contain some data some are empty The empty cells form the so called Thus a memory cluster is a sequence of some consecutive empty memory cells You have exactly memory clusters the th cluster consists of cells You need to find memory for arrays in your program The th array takes consecutive memory cells There possibly isn t enough memory for all arrays so your task is to determine what maximum number of arrays can be located in the available memory clusters Of course the arrays cannot be divided between the memory clusters Also no cell can belong to two arrays ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\nconst int L = 30;\nint N, M;\nint A[1000010], B[1000010];\n\nint cnt[110];\n\nbool check(int m) {\n\tint i, j, l;\n\tmemset(cnt, 0, L * 4);\n\tfor (j = 0; j < m; ++j) {\n\t\t++cnt[B[j]];\n\t}\n\tfor (i = N; i--; ) {\n\t\tint a = A[i];\n\t\tfor (l = L; l--; ) {\n\t\t\tint tmp = min(cnt[l], a >> l);\n\t\t\tcnt[l] -= tmp;\n\t\t\ta -= tmp << l;\n\t\t}\n\t}\n\tfor (l = 0; l < L; ++l) {\n\t\tif (cnt[l] > 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main() {\n\tint i, j;\n\t\n\tfor (; ~scanf(""%d%d"", &N, &M); ) {\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tA[i] = in();\n\t\t}\n\t\tfor (j = 0; j < M; ++j) {\n\t\t\tB[j] = in();\n\t\t}\n\t\tsort(A, A + N);\n\t\tsort(B, B + M);\n\t\tint lo = 0, ho = M + 1;\n\t\tfor (; lo + 1 < ho; ) {\n\t\t\tint mo = (lo + ho) / 2;\n\t\t\t(check(mo) ? lo : ho) = mo;\n\t\t}\n\t\tprintf(""%d\\n"", lo);\n\t}\n\t\n\treturn 0;\n}\n\n']","['binary search', 'bitmasks', 'greedy']",1900
https://codeforces.com//contest/1693/problem/A,A. Directional Increase,We have an array of length n Initially each element is equal to 0 and there is a pointer located on the first element We can do the following two kinds of operations any number of times possibly zero in any order If the pointer is not on the last element increase the element the pointer is currently on by 1 Then move it to the next element If the pointer is not on the first element decrease the element the pointer is currently on by 1 Then move it to the previous element But there is one additional rule You are given an array a Determine whether it s possible to obtain a after some operations or not ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""Yes\\n"");\n\telse\n\t\tprintf(""No\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tll s=0;\n\tint bylo=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ts+=tab[i];\n\t\tif (s<0)\n\t\t{\n\t\t\tans(0);\n\t\t\treturn;\n\t\t}\n\t\tif (!s)\n\t\t{\n\t\t\tbylo=1;\n\t\t}\n\t\tif (bylo && s)\n\t\t{\n\t\t\tans(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (s)\n\t{\n\t\tans(0);\n\t\treturn;\n\t}\n\tans(1);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",['greedy'],1300
https://codeforces.com//contest/761/problem/E,E. Dasha and Puzzle,Dasha decided to have a rest after solving the problem She had been ready to start her favourite activity origami but remembered the puzzle that she could not solve The tree is a non oriented connected graph without cycles In particular there always are edges in a tree with vertices The puzzle is to position the vertices at the points of the Cartesian plane with integral coordinates so that the segments between the vertices connected by edges are parallel to the coordinate axes Also the intersection of segments is allowed only at their ends Distinct vertices should be placed at different points Help Dasha to find any suitable way to position the tree vertices on the plane It is guaranteed that if it is possible to position the tree vertices on the plane without violating the condition which is given above then you can do it by using points with integral coordinates which don t exceed in absolute value ,"['#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == \'-\')\n\t\t\ts = -1, c = getChar();\n\t\twhile (\'0\' <= c && c <= \'9\')\n\t\t\tx = x * 10 + c - \'0\', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar(\'-\'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)(\'0\' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 100;\n\nvector <int> g[N];\n\nlong long location[N][2];\n\nlong long cur[2] = { 0LL, 0LL };\nlong long dirx[4] = { -1, 0, 1, 0 };\nlong long diry[4] = { 0, 1, 0, -1 };\nlong long step = 1LL << 30;\n\nvoid dfs(int v, int p = -1, int dirfrom = -1)\n{\n\tlocation[v][0] = cur[0];\n\tlocation[v][1] = cur[1];\n\tvector <int> havedirs;\n\tfor (int i = 0; i < 4; ++i)\n\t\tif (i != dirfrom)\n\t\t\thavedirs.push_back(i);\n\tint id = 0;\n\tfor (int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tif (g[v][i] == p)\n\t\t\tcontinue;\n\t\tint dir = havedirs[id++];\n\n\t\tcur[0] += dirx[dir] * step;\n\t\tcur[1] += diry[dir] * step;\n\t\tstep >>= 1;\n\n\t\tdfs(g[v][i], v, (dir + 2) % 4);\n\n\t\tstep <<= 1;\n\t\tcur[0] -= dirx[dir] * step;\n\t\tcur[1] -= diry[dir] * step;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tn = readInt();\n\tfor (int i = 0; i < n - 1; ++i)\n\t{\n\t\tint a = readInt(), b = readInt();\n\t\t--a, --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tif (g[i].size() > 4)\n\t\t{\n\t\t\twriteWord(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\tdfs(rand() % n);\n\twriteWord(""YES\\n"");\n\tfor (int i = 0; i < n; ++i)\n\t\twriteInt(location[i][0], \' \'),\n\t\twriteInt(location[i][1], \'\\n\');\n\n\treturn 0;\n}']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",2000
https://codeforces.com//contest/1334/problem/F,F. Strange Function,Let s denote the following function f This function takes an array a of length n and returns an array Initially the result is an empty array For each integer i from 1 to n we add element a i to the end of the resulting array if it is greater than all previous elements more formally if a i max limits 1 le j i a j Some examples of the function f if a 3 1 2 7 7 3 6 7 8 then f a 3 7 8 if a 1 then f a 1 if a 4 1 1 2 3 then f a 4 if a 1 3 1 2 6 8 7 7 4 11 10 then f a 1 3 6 8 11 You are given two arrays array a 1 a 2 dots a n and array b 1 b 2 dots b m You can delete some elements of array a possibly zero To delete the element a i you have to pay p i coins the value of p i can be negative then you get p i coins if you delete this element Calculate the minimum number of coins possibly negative you have to spend for fulfilling equality f a b ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=501000;\nstruct node {\n\tll fg;\n\tll val;\n}nd[4*N];\nvoid upd(int p) {\n\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v;\n\tnd[p].val+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tnd[p].val=1ll<<60;\n\tif (l==r) {\n\t\tif (l==0) nd[p].val=0;\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nll query(int p,int l,int r,int x) {\n\tif (l==r) return nd[p].val;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (x<=md) return query(p+p,l,md,x);\n\t\telse return query(p+p+1,md+1,r,x);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint n,a[N],p[N],b[N],m;\n\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,1,n+1) scanf(""%d"",p+i);\n\tscanf(""%d"",&m);\n\trep(i,1,m+1) scanf(""%d"",b+i);\n\tb[m+1]=1<<30;\n\tbuild(1,0,m);\n\trep(i,1,n+1) {\n\t\tint j=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (b[j]==a[i]) {\n\t\t\tmodify(1,0,m,j+1,m,min(p[i],0));\n\t\t\tll a=query(1,0,m,j);\n\t\t\tll x=a+min(p[i],0),y=query(1,0,m,j-1);\n\t\t\tmodify(1,0,m,j,j,min(x,y)-a);\n\t\t\tmodify(1,0,m,0,j-1,p[i]);\n\t\t} else {\n\t\t\tmodify(1,0,m,j,m,min(p[i],0));\n\t\t\tmodify(1,0,m,0,j-1,p[i]);\n\t\t}\n\t\t//rep(j,0,m+1) printf(""%lld "",query(1,0,m,j));\n\t\t//puts("""");\n\t}\n\tll a=query(1,0,m,m);\n\tif (a>=1ll<<55) puts(""NO""); else printf(""YES\\n%lld\\n"",a);\n}']","['binary search', 'data structures', 'dp', 'greedy']",2500
https://codeforces.com//contest/269/problem/A,A. Magical Boxes,Emuskald is a well known illusionist One of his trademark tricks involves a set of magical boxes The essence of the trick is in packing the boxes inside other boxes From the top view each magical box looks like a square with side length equal to is an integer units A magical box can be put inside a magical box if side length of is strictly less than the side length of In particular Emuskald can put 4 boxes of side length into one box of side length or as in the following figure Emuskald is about to go on tour performing around the world and needs to pack his magical boxes for the trip He has decided that the best way to pack them would be inside another magical box but magical boxes are quite expensive to make Help him find the smallest magical box that can fit all his boxes ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""A""\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nint main(){\n  #ifdef LOCAL\n    freopen(TASKNAME"".in"",""r"",stdin);\n    freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n    vector<pair<int,int> > a;\n    int n;\n    scanf(""%d"",&n);\n\n    for (int i = 0; i < n; i++){\n        int k,b;\n        cin >> k >> b;\n        a.pb(mp(k,b));\n    }\n\n    sort(a.begin(),a.end());\n\n    int ans = a.back().first+1;\n\n    while (true){\n        bool q = true;\n        for (int i = 0; i < n; i++)\n            if (ans - a[i].first <= 15 && (1<<(2*(ans - a[i].first))) < a[i].second){\n                q = false;\n            }\n        if (q)\n            break;\n        ans++;\n    }\n\n    cout << ans << endl;\n\n      \n  return 0;\n}']","['greedy', 'math']",1600
https://codeforces.com//contest/89/problem/C,C. Chip Play,Let s consider the following game We have a rectangular field in size Some squares of the field contain chips Each chip has an arrow painted on it Thus each chip on the field points in one of the following directions up down left or right The player may choose a chip and make a move with it The move is the following sequence of actions The chosen chip is marked as the current one After that the player checks whether there are more chips in the same row or in the same column with the current one that are pointed by the arrow on the current chip If there is at least one chip then the closest of them is marked as the new current chip and the former current chip is removed from the field After that the check is repeated This process can be repeated several times If a new chip is not found then the current chip is removed from the field and the player s move ends By the end of a move the player receives several points equal to the number of the deleted chips By the given initial chip arrangement determine the maximum number of points that a player can receive during one move Also determine the number of such moves ,"['#include<stdio.h>\nchar in[5010][5010];\nshort xp[5010][5010],xn[5010][5010];\nshort yp[5010][5010],yn[5010][5010];\ninline void del(int x,int y){\n    xn[xp[x][y]][y]=xn[x][y];\n    xp[xn[x][y]][y]=xp[x][y];\n    yn[x][yp[x][y]]=yn[x][y];\n    yp[x][yn[x][y]]=yp[x][y];\n}\ninline void add(int x,int y){\n    xn[xp[x][y]][y]=x;\n    xp[xn[x][y]][y]=x;\n    yn[x][yp[x][y]]=y;\n    yp[x][yn[x][y]]=y;\n}\nint n,m;\ninline int go(int x,int y){\n    if(x==0||y==0||x==n+1||y==m+1)return 0;\n    del(x,y);\n    int d;\n    if(in[x][y]==\'D\')d=go(xn[x][y],y);\n    else if(in[x][y]==\'U\')d=go(xp[x][y],y);\n    else if(in[x][y]==\'R\')d=go(x,yn[x][y]);\n    else if(in[x][y]==\'L\')d=go(x,yp[x][y]);\n    add(x,y);\n    return d+1;\n}\nint main(){\n    int i,j;\n    scanf(""%d%d"",&n,&m);\n    for(i=1;i<=n;i++)scanf(""%s"",in[i]+1);\n    for(i=1;i<=n;i++){\n\tint p=0;\n\tfor(j=1;j<=m+1;j++){\n\t    if(in[i][j]!=\'.\'){\n\t\tyn[i][p]=j;\n\t\typ[i][j]=p;\n\t\tp=j;\n\t    }\n\t}\n    }\n    for(j=1;j<=m;j++){\n\tint p=0;\n\tfor(i=1;i<=n+1;i++){\n\t    if(in[i][j]!=\'.\'){\n\t\txn[p][j]=i;\n\t\txp[i][j]=p;\n\t\tp=i;\n\t    }\n\t}\n    }\n    int ans=0,ac=0;\n    for(i=1;i<=n;i++){\n\tfor(j=1;j<=m;j++){\n\t    if(in[i][j]!=\'.\'){\n\t\tint d=go(i,j);\n\t\tif(d>ans){\n\t\t    ans=d;ac=1;\n\t\t}else if(d==ans)ac++;\n\t    }\n\t}\n    }\n    printf(""%d %d\\n"",ans,ac);\n}\n']","['brute force', 'data structures', 'implementation']",2300
https://codeforces.com//contest/1111/problem/C,C. Creative Snap,Thanos wants to destroy the avengers base but he needs to destroy the avengers along with their base Let we represent their base with an array where each position can be occupied by many avengers but one avenger can occupy only one position Length of their base is a perfect power of 2 Thanos wants to destroy the base using minimum power He starts with the whole base and in one step he can do either of following if the current length is at least 2 divide the base into 2 equal halves and destroy them separately or burn the current base If it contains no avenger in it it takes A amount of power otherwise it takes his B cdot n a cdot l amount of power where n a is the number of avengers and l is the length of the current base Output the minimum power needed by Thanos to destroy the avengers base ,"['#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl ""\\n""\n#define ll long long\n\nint n, k, a, b;\n\nll dfs(int l, int r, vector<int> &c) {\n\tif(!c.size()) {\n\t\treturn a;\n\t}\n\tll a1=(ll)b*(r-l+1)*c.size();\n\tif(l<r) {\n\t\tint m=(l+r)/2;\n\t\tvector<int> d, e;\n\t\tfor(int ci : c) {\n\t\t\tif(ci<=m)\n\t\t\t\td.push_back(ci);\n\t\t\telse\n\t\t\t\te.push_back(ci);\n\t\t}\n\t\ta1=min(dfs(l, m, d)+dfs(m+1, r, e), a1);\n\t}\n\treturn a1;\n}\n\nint32_t main()\n{\n\tIOS;\n\tcin >> n >> k >> a >> b;\n\tvector<int> c(k);\n\tfor(int i=0; i<k; ++i)\n\t\tcin >> c[i], --c[i];\n\tcout << dfs(0, (1<<n)-1, c);\n\treturn 0;\n}\n']","['binary search', 'brute force', 'divide and conquer', 'math']",1700
https://codeforces.com//contest/1774/problem/F1,F1. Magician and Pigs  Easy Version ,Little09 has been interested in magic for a long time and it s so lucky that he meets a magician The magician will perform n operations each of them is one of the following three 1 x Create a pig with x Health Points 2 x Reduce the Health Point of all living pigs by x 3 Repeat all previous operations Formally assuming that this is the i th operation in the operation sequence perform the first i 1 operations including Repeat operations involved in turn A pig will die when its Health Point is less than or equal to 0 Little09 wants to know how many living pigs there are after all the operations Please print the answer modulo 998 244 353 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst ll INF = (ll)1e10;\nconst int N = 800800;\nPowers P2 = Powers(N, Mint(2));\nvector<int> allDoubles;\nint cntDoubles[N];\nll sumDamage[N];\nll sumDamageDoulbed[N];\nint a[N][2];\nint n;\nMint ANS;\nll b[100];\nll c[100];\nint m;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcntDoubles[i + 1] = cntDoubles[i];\n\t\tsumDamage[i + 1] = sumDamage[i];\n\t\tsumDamageDoulbed[i + 1] = sumDamageDoulbed[i];\n\t\tscanf(""%d"", &a[i][0]);\n\t\tif (a[i][0] == 1) {\n\t\t\tscanf(""%d"", &a[i][1]);\n\t\t} else if (a[i][0] == 2) {\n\t\t\tscanf(""%d"", &a[i][1]);\n\t\t\tsumDamage[i + 1] += a[i][1];\n\t\t\tsumDamageDoulbed[i + 1] = min(INF, sumDamageDoulbed[i + 1] + a[i][1]);\n\t\t} else {\n\t\t\tcntDoubles[i + 1] += 1;\n\t\t\tsumDamageDoulbed[i + 1] = min(INF, sumDamageDoulbed[i + 1] * 2);\n\t\t\tif (sumDamage[i] > 0) allDoubles.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (a[i][0] == 1) {\n\t\tll x = a[i][1];\n\t\tx -= sumDamage[n] - sumDamage[i];\n\t\tif (x <= 0) continue;\n\t\tm = 0;\n\t\tint p = lower_bound(all(allDoubles), i) - allDoubles.begin();\n\t\tif (p == (int)allDoubles.size()) {\n\t\t\tANS += P2.pow(cntDoubles[n] - cntDoubles[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tint q = p;\n\t\tint pw = cntDoubles[allDoubles[p]] - cntDoubles[i];\n\t\tassert(pw >= 0);\n\t\twhile(m < 32 && p < (int)allDoubles.size()) {\n\t\t\tb[m] = sumDamage[allDoubles[p]];\n\t\t\tif (b[m] >= x) break;\n\t\t\tm++;\n\t\t\tp++;\n\t\t}\n\t\tif (m == 0) {\n\t\t\tANS += P2.pow(pw);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = m - 1; i > 0; i--)\n\t\t\tb[i] -= b[i - 1];\n\t\tb[0] = sumDamageDoulbed[allDoubles[q]];\n\t\tc[0] = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tc[i + 1] = min(x + 1, 2 * c[i] + b[i]);\n\t\teprintf(""x = %lld\\n"", x);\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\teprintf(""%lld "", c[i]);\n\t\teprintf(""\\n"");\n\t\tll res = 1;\n\t\tfor (int i = m; i > 0; i--) {\n\t\t\tif (x <= c[i]) continue;\n\t\t\tres += 1LL << (i - 1);\n\t\t\tx -= c[i];\n\t\t}\n\t\tANS += Mint(res) * P2.pow(pw);\n\t}\n\tprintf(""%u\\n"", ANS.x);\n\n\treturn 0;\n}\n']","['brute force', 'data structures', 'implementation']",2400
https://codeforces.com//contest/710/problem/E,E. Generate a String,wants to generate an input file for some programming competition problem His input is a string consisting of letters a He is too lazy to write a generator so he will manually generate the input in a text editor Initially the text editor is empty It takes him seconds to insert or delete a letter a from the text file and seconds to copy the contents of the entire text file and duplicate it wants to find the minimum amount of time needed for him to create the input file of exactly letters a Help him to determine the amount of time needed to generate the input ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <ctype.h>\n#include <deque>\n#include <queue>\n#include <cstring>\n#include <set>\n#include <list>\n#include <map>\n#include <random>\n#include <unordered_map>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<bool> vb;\ntypedef std::vector<string> vs;\ntypedef std::vector<double> vd;\ntypedef std::vector<long long> vll;\ntypedef std::vector<std::vector<int> > vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef std::vector<std::pair<int, int> > vpi;\ntypedef vector<vpi> vvpi;\ntypedef std::pair<int, int> pi;\ntypedef std::pair<ll, ll> pll;\ntypedef std::vector<pll> vpll;\n\nconst long long mod = 1000000007;\n\n#define all(c) (c).begin(),(c).end()\n#define sz(c) (int)(c).size()\n#define forn(i, a, b) for(int i = a; i < b; i++)\n\n#define pb push_back\n#define mp make_pair\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n    int n,x,y;\n    cin>>n>>x>>y;\n    vll ans(n+1);\n    ans[1] = x;\n    forn(k,2,n+1) {\n        ans[k] = ans[k-1] + x;\n        if (k%2 == 0) ans[k] = min(ans[k], ans[k/2] + y);\n        else {\n            ans[k] = min(ans[k], ans[(k+1)/2] + x + y);\n        }\n    }\n    cout<<ans[n];\n    \n    \n    \n}\n\n\n']","['dfs and similar', 'dp']",2000
https://codeforces.com//contest/254/problem/C,C. Anagram,String is an of string if we can rearrange the letters in string and get exact string For example strings and are anagrams so are strings and but strings and are not You are given two strings and of the same length consisting of uppercase English letters You need to get the anagram of string from string You are permitted to perform the replacing operation every operation is replacing some character from the string by any other character Get the anagram of string in the least number of replacing operations If you can get multiple anagrams of string in the least number of operations get the lexicographically minimal one The lexicographic order of strings is the familiar to us dictionary order Formally the string of length is lexicographically smaller than string of the same length if for some Here characters in the strings are numbered from 1 The characters of the strings are compared in the alphabetic order ,"['#include<cstdio>\n#include<cstring>\nusing namespace std;\nint sn[30],tn[30];\nchar s[200000],t[200000];\nint main()\n{\n\tfreopen( ""input.txt"", ""r"", stdin );\n\tfreopen( ""output.txt"", ""w"", stdout );\n\tscanf( ""%s"", s );\n\tscanf( ""%s"", t );\n\tint l = strlen( s );\n\tfor ( int i = 0; i < l; i++ )\n\t\tsn[s[i]-\'A\']++;\n\tfor ( int i = 0; i < l; i++ )\n\t\ttn[t[i]-\'A\']++;\n\tint ac = 0;\n\tfor ( int i = 0; i < l; i++ )\n\t{\n\t\tif ( sn[s[i]-\'A\'] > tn[s[i]-\'A\'] )\n\t\t{\n\t\t\tint ll;\n\t\t\tfor ( int j = 0; j < 26; j++ ) if ( sn[j] < tn[j] )\n\t\t\t{\n\t\t\t\tll = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( s[i]-\'A\' > ll )\n\t\t\t{\n\t\t\t\tsn[s[i]-\'A\']--;\n\t\t\t\ts[i] = \'A\' + ll;\n\t\t\t\tsn[ll]++;\n\t\t\t\tac++;\n\t\t\t}\n\t\t\telse if ( tn[s[i]-\'A\'] != 0 )\n\t\t\t{\n\t\t\t\tsn[s[i]-\'A\']--;\n\t\t\t\ttn[s[i]-\'A\']--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsn[s[i]-\'A\']--;\n\t\t\t\ts[i] = \'A\' + ll;\n\t\t\t\tsn[ll]++;\n\t\t\t\tac++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf( ""%d\\n"", ac );\n\tprintf( ""%s\\n"", s );\n\treturn 0;\n}']","['greedy', 'strings']",1800
https://codeforces.com//contest/1646/problem/B,B. Quality vs Quantity,def myred1 color red underline bf 1 def myblue1 color blue overline bf 1 def RED myred Red def BLUE myblue Blue You are given a sequence of n non negative integers a 1 a 2 ldots a n Initially all the elements of the sequence are unpainted You can paint each number RED or BLUE but not both or For a color c text Count c is the number of elements in the sequence painted with that color and text Sum c is the sum of the elements in the sequence painted with that color For example if the given sequence is 2 8 6 3 1 and it is painted this way myblue 2 8 myred 6 myblue 3 1 where 6 is painted red 2 and 3 are painted blue 1 and 8 are unpainted then text Sum RED 6 text Sum BLUE 2 3 5 text Count RED 1 and text Count BLUE 2 Determine if it is possible to paint the sequence so that text Sum RED text Sum BLUE and text Count RED text Count BLUE ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int t;\n    for (cin >> t; t; t -= 1) {\n        int n;\n        cin >> n;\n        vector<LL> a(n);\n        for (LL& x : a) cin >> x;\n        ranges::sort(a);\n        LL s = 0;\n        for (int i = 0; i < (n - 1) / 2; i += 1)\n            s += a[n - i - 1];\n        for (int i = 0; i < (n - 1) / 2 + 1; i += 1)\n            s -= a[i];\n        cout << (s > 0 ? ""YES\\n"" : ""NO\\n"");\n    }\n    return 0;\n}']","['brute force', 'constructive algorithms', 'greedy', 'sortings', 'two pointers']",800
https://codeforces.com//contest/1623/problem/D,D. Robot Cleaner Revisit,A robot cleaner is placed on the floor of a rectangle room surrounded by walls The floor consists of n rows and m columns The rows of the floor are numbered from 1 to n from top to bottom and columns of the floor are numbered from 1 to m from left to right The cell on the intersection of the r th row and the c th column is denoted as r c The initial position of the robot is r b c b In one second the robot moves by dr rows and dc columns that is after one second the robot moves from the cell r c to r dr c dc Initially dr 1 dc 1 If there is a vertical wall the left or the right walls in the movement direction dc is before the movement so the new value of dc is dc And if there is a horizontal wall the upper or lower walls dr is before the movement so the new value of dr is dr Each second including the moment before the robot starts moving the robot cleans every cell lying in the same row the same column as its position There is only one dirty cell at r d c d The job of the robot is to clean that dirty cell After a lot of testings in problem A the robot is now broken It cleans the floor as described above but at each second the cleaning operation is performed with probability frac p 100 only and not performed with probability 1 frac p 100 The cleaning or not cleaning outcomes are independent each second Given the floor size n and m the robot s initial position r b c b and the dirty cell s position r d c d find the for the robot to do its job It can be shown that the answer can be expressed as an irreducible fraction frac x y where x and y are integers and y not equiv 0 pmod 10 9 7 Output the integer equal to x cdot y 1 bmod 10 9 7 In other words output such an integer a that 0 le a 10 9 7 and a cdot y equiv x pmod 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint mpow(int x, int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % mod;\n\t\ty >>= 1; x = 1ll * x * x % mod;\n\t}\n\treturn ret;\n}\n\nint norm(int x) {\n\treturn x >= mod ? x - mod : x;\n}\n\nint reduce(int x) {\n\treturn x < 0 ? x + mod : x;\n}\n\nconst int d[2] = {-1, 1};\n\nint vis[100005][2][2];\n\nstruct state {\n\tint x, y, dx, dy;\n\tstate(int x_ = 0, int y_ = 0, int dx_ = 0, int dy_ = 0) : x(x_), y(y_), dx(dx_), dy(dy_) {}\n};\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, m, x, y, a, b, p;\n\t\tcin >> n >> m >> x >> y >> a >> b >> p;\n\t\tauto s = [&](int x, int y) { return (x - 1) * m + y; };\n\t\tp = 1ll * p * mpow(100, mod - 2) % mod; p = reduce(1 - p);\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvector<state> seq;\n\t\tstate now = state(x, y, 1, 1);\n\t\tint pos = 0;\n\t\twhile (1) {\n\t\t\tseq.push_back(now);\n\t\t\tif (vis[s(now.x, now.y)][now.dx][now.dy]) {\n\t\t\t\tpos = vis[s(now.x, now.y)][now.dx][now.dy];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[s(now.x, now.y)][now.dx][now.dy] = (int)seq.size();\n\t\t\tif (now.x + d[now.dx] < 1 || now.x + d[now.dx] > n) now.dx ^= 1;\n\t\t\tif (now.y + d[now.dy] < 1 || now.y + d[now.dy] > m) now.dy ^= 1;\n\t\t\tnow.x += d[now.dx]; now.y += d[now.dy];\n\t\t}\n\t\t--pos;\n\t\tint ca = 1, cb = 0;\n\t\t// for (int i = 0; i < (int)seq.size(); i++) cout << seq[i].x << "" "" << seq[i].y << endl;\n\t\tfor (int i = (int)seq.size() - 2; i >= pos; i--) {\n\t\t\tif (seq[i].x == a || seq[i].y == b) {\n\t\t\t\tca = 1ll * p * ca % mod, cb = 1ll * p * cb % mod;\n\t\t\t\tcb = norm(cb + p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcb = (cb + 1) % mod;\n\t\t}\n\t\tint ans = 1ll * cb * mpow(reduce(1 - ca), mod - 2) % mod;\n\t\tfor (int i = pos - 1; i >= 0; i--) {\n\t\t\tif (seq[i].x == a || seq[i].y == b) {\n\t\t\t\tans = 1ll * ans * p % mod;\n\t\t\t\tans = norm(ans + p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = (ans + 1) % mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}']","['implementation', 'math', 'probabilities']",2300
https://codeforces.com//contest/848/problem/D,D. Shake It ,A is an unordered graph in whose vertex set there are two special vertices and An has vertex set and an edge between them A total of changes took place in an In each change a new vertex is added into is chosen and two edges and are added into Note that it s possible that some edges are chosen in more than one change It s known that the capacity of the minimum cut of the resulting graph is that is at least edges need to be removed in order to make and disconnected Count the number of that can be built under the constraints modulo We define two similar if they are isomorphic and there is isomorphism in which the and vertices are not relabelled Formally two and are considered similar if there is a bijection between their vertex sets such that Two vertices and of are adjacent in if and only if and are adjacent in ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll F[1005];\nll Finv[1005];\nll C(ll a, ll b) {\n\tll rv = Finv[b];\n\tfor (ll i = a; i > a - b; i--) rv = (rv * (i + MOD)) % MOD;\n\treturn rv;\n}\nll H(ll a, ll b) {\n\treturn C(a + b - 1, b);\n}\n\nll dp[55][55];\nll dp2[55][55];\n\nll tdp[55][55];\nll tdp2[55][55];\n\nint main() {\n\tint N, M, i, j, k, l, m, n;\n\tF[0] = 1;\n\tfor (i = 1; i <= 1000; i++) F[i] = F[i - 1] * i % MOD;\n\tfor (i = 0; i <= 1000; i++) Finv[i] = mul_inv(F[i]);\n\n\n\tscanf(""%d %d"", &N, &M);\n\tdp[0][1] = 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tint a1 = j, a2 = i - 1 - j;\n\t\t\tfor (k = 1; k <= a1 + 1; k++) {\n\t\t\t\tfor (l = 1; l <= a2 + 1; l++) {\n\t\t\t\t\tll v = dp[a1][k] * dp[a2][l];\n\t\t\t\t\tdp2[i][min(k, l)] = (dp2[i][min(k, l)] + v) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(tdp, 0, sizeof(tdp));\n\t\ttdp[0][1] = 1;\n\t\tfor (j = 1; j <= i; j++) {\n\t\t\tfor (k = 0; k <= j + 1; k++) {\n\t\t\t\tmemset(tdp2, 0, sizeof(tdp2));\n\t\t\t\tll x = dp2[j][k];\n\t\t\t\tfor (l = 0;; l++) {\n\t\t\t\t\tint a1 = l * j, a2 = l * k;\n\t\t\t\t\tif (a1 > i) break;\n\t\t\t\t\tll v = C(x + l - 1, l);\n\t\t\t\t\tfor (m = 0; m <= i - a1; m++) {\n\t\t\t\t\t\tfor (n = 0; n <= i + 1 - a2; n++) {\n\t\t\t\t\t\t\ttdp2[m + a1][n + a2] = (tdp2[m + a1][n + a2] + tdp[m][n] * v) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (l = 0; l <= i; l++) for (m = 0; m <= i + 1; m++) tdp[l][m] = tdp2[l][m];\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= i; j++) for (k = 1; k <= i + 1; k++) dp[j][k] = tdp[j][k];\n\t}\n\treturn !printf(""%lld\\n"", dp[N][M]);\n}']","['combinatorics', 'dp', 'flows', 'graphs']",2900
https://codeforces.com//contest/1076/problem/D,D. Edge Deletion,You are given an undirected connected weighted graph consisting of n vertices and m edges Let s denote the length of the shortest path from vertex 1 to vertex i as d i You have to erase some edges of the graph so that at most k edges remain Let s call a vertex i if there still exists a path from 1 to i with length d i after erasing the edges Your goal is to erase the edges in such a way that the number of vertices is maximized ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 3e5 + 7;\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint n, m, k;\nvector <int> res;\n\nPII p[N];\nLL dist[N];\nbool vis[N];\nvector <PII> T[N];\nvector <pair <PII, int> > G[N];\n\nvoid Dijkstra(int s){\n\tfor(int i = 1; i <= n; ++i)\n\t\tdist[i] = INF;\n\tdist[s] = 0;\n\t\n\tpriority_queue <PLL> Q;\n\tQ.push({0, s});\n\t\n\twhile(!Q.empty()){\n\t\tint u = Q.top().nd;\n\t\tQ.pop();\n\t\t\n\t\tif(vis[u])\n\t\t\tcontinue;\n\t\tvis[u] = true;\n\t\t\n\t\tif(p[u].st > 0)\n\t\t\tT[p[u].st].push_back({u, p[u].nd});\n\t\t\n\t\tfor(auto v: G[u])\n\t\t\tif(dist[v.st.st] > dist[u] + v.st.nd){\n\t\t\t\tdist[v.st.st] = dist[u] + v.st.nd;\n\t\t\t\tp[v.st.st] = {u, v.nd};\n\t\t\t\tQ.push({-dist[v.st.st], v.st.st});\n\t\t\t}\n\t}\n}\n\nvoid dfs(int u){\n\tfor(auto v: T[u]){\n\t\tif((int)res.size() < k)\n\t\t\tres.push_back(v.nd);\n\t\tdfs(v.st);\n\t}\n}\n\nint main(){\n//\tios_base::sync_with_stdio(false);\n//\tcin.tie(NULL);\n//\tcout.tie(NULL);\n\n\tscanf(""%d %d %d"", &n, &m, &k);\n\tfor(int i = 1; i <= m; ++i){\n\t\tint u, v, c;\n\t\tscanf(""%d %d %d"", &u, &v, &c);\n\n\t\tG[u].push_back({{v, c}, i});\n\t\tG[v].push_back({{u, c}, i});\n\t}\n\t\n\tDijkstra(1);\n\tdfs(1);\n\t\n\tprintf(""%d\\n"", (int)res.size());\n\tfor(int v: res)\n\t\tprintf(""%d "", v);\n\treturn 0;\n}\n']","['graphs', 'greedy', 'shortest paths']",1800
https://codeforces.com//contest/653/problem/C,C. Bear and Up-Down,The life goes up and down just like nice sequences Sequence is called if the following two conditions are satisfied for each odd for each even For example sequences and are nice while and are not Bear Limak has a sequence of positive integers This sequence now and Limak wants to fix it by a single swap He is going to choose two indices and swap elements and in order to get a nice sequence Count the number of ways to do so Two ways are considered different if indices of elements chosen for a swap are different ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=151000;\nint n,t[N],ans,s,val[N];\nset<PII> ret;\nVI pos;\nbool valid(int x) {\n\tif (x%2==0) {\n\t\treturn (x==n-1||t[x]<t[x+1])&&(x==0||t[x]<t[x-1]);\n\t} else {\n\t\treturn (x==n-1||t[x]>t[x+1])&&(x==0||t[x]>t[x-1]);\n\t}\n}\nvoid upd(int x) {\n\tif (x<0||x>=n) return;\n\ts-=val[x];\n\tval[x]=valid(x);\n\ts+=val[x];\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d"",t+i);\n\trep(i,0,n) {\n\t\tval[i]=valid(i);\n\t\tif (!val[i]) pos.pb(i);\n\t\ts+=val[i];\n\t}\n\tif (SZ(pos)>=10) {\n\t\tputs(""0""); return 0;\n\t}\n\tfor (auto u:pos) rep(v,0,n) {\n\t\tswap(t[u],t[v]);\n\t\tupd(u-1); upd(u); upd(u+1); upd(v-1); upd(v); upd(v+1);\n\t\tif (s==n) {\n\t\t\tret.insert(mp(min(u,v),max(u,v)));\n\t\t}\n\t\tswap(t[u],t[v]);\n\t\tupd(u-1); upd(u); upd(u+1); upd(v-1); upd(v); upd(v+1);\n\t}\n\tprintf(""%d\\n"",SZ(ret));\n}\n']","['brute force', 'implementation']",1900
https://codeforces.com//contest/702/problem/C,C. Cellular Network,You are given points on the straight line the positions coordinates of the cities and points on the same line the positions coordinates of the cellular towers All towers work in the same way they provide cellular network for all cities which are located at the distance which is no more than from this tower Your task is to find minimal that each city has been provided by cellular network i e for each city there is at least one cellular tower at the distance which is no more than If then a tower provides cellular network only for the point where it is located One tower can provide cellular network for any number of cities but all these cities must be at the distance which is no more than from this tower ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nll A[101010];\nll B[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) cin>>A[i];\n\tB[0]=-1LL<<40;\n\tFOR(i,M) cin>>B[i+1];\n\tB[M+1]=1LL<<40;\n\tM+=2;\n\t\n\tll mi=0;\n\tFOR(i,N) {\n\t\tx = lower_bound(B,B+M,A[i])-B;\n\t\tmi=max(mi,min(A[i]-B[x-1],B[x]-A[i]));\n\t} \n\tcout<<mi<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n""]","['binary search', 'implementation', 'two pointers']",1500
https://codeforces.com//contest/1272/problem/C,C. Yet Another Broken Keyboard,Recently Norge found a string s s 1 s 2 ldots s n consisting of n lowercase Latin letters As an exercise to improve his typing speed he decided to type all substrings of the string s Yes all frac n n 1 2 of them A substring of s is a non empty string x s a ldots b s a s a 1 ldots s b 1 leq a leq b leq n For example and are substrings of Shortly after the start of the exercise Norge realized that his keyboard was broken namely he could use only k Latin letters c 1 c 2 ldots c k out of 26 After that Norge became interested in how many substrings of the string s he could still type using his broken keyboard Help him to find this number ,"['#define task ""test""\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\n\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n\nconst ll LINF = 1E18;\nconst int INF = 1E9;\nconst int MOD = 1E9 + 7;\nconst int N = 2E5 + 5;\n\nint t = 1;\n\nint n, k, F[N][30];\nstring s;\n\nchar a[30];\n\nll res = 0;\n\nbool avail[30];\n\nvoid Input()\n{\n    cin >> n >> k;\n    cin >> s; s = "" "" + s;\n    for (int i = 1; i <= k; i++) cin >> a[i];\n}\n\nvoid Prepare()\n{\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 26; j++) F[i][j] = F[i - 1][j];\n        F[i][s[i] -\'a\']++;\n    }\n    memset(avail, 0, sizeof(avail));\n    for (int i = 1; i <= k; i++) avail[a[i] - \'a\'] = true;\n}\n\nvoid Solve()\n{\n    ll R = 0;\n    for (int i = 1; i <= n; i++) {\n        if (R < i) R = i;\n\n        while (R <= n) {\n            bool ok = 1;\n            for (int j = 0; j < 26; j++) if (F[R][j] - F[i - 1][j] > 0) {\n                if (!avail[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) break;\n            R++;\n        }\n        res += (ll) (R - i);\n      //  cout << i << "" "" << R << endl;\n    }\n\n    cout << res;\n\n}\n\nint main()\n{\n    if (fopen(task "".inp"",""r"")){\n        freopen(task "".inp"",""r"",stdin);\n        freopen(task "".out"",""w"",stdout);\n    }\n    Input();\n    Prepare();\n    while (t--) Solve();\n}\n\n']","['combinatorics', 'dp', 'implementation']",1200
https://codeforces.com//contest/554/problem/B,B. Ohana Cleans Up,Ohana Matsumae is trying to clean a room which is divided up into an by grid of squares Each square is initially either clean or dirty Ohana can sweep her broom over columns of the grid Her broom is very strange if she sweeps over a clean square it will become dirty and if she sweeps over a dirty square it will become clean She wants to sweep some columns of the room to maximize the number of rows that are completely clean It is not allowed to sweep over the part of the column Ohana can only sweep the whole column Return the maximum number of rows that she can make completely clean ,"['#pragma comment (linker, ""/STACK:1000000000"")\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nconst int maxn = 110;\n\nstring s[maxn];\n\nmap <string, int> m;\n\nint main() {\n\tint n;\n\n\tscanf(""%d"", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tm[s[i]]++;\n\t}\n\n\tmap <string, int>::iterator  it;\n\n\tint ans = 0;\n\n\tfor (it = m.begin(); it != m.end(); it++) {\n\t\tans = max(ans, it->second);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n']","['brute force', 'greedy', 'strings']",1200
https://codeforces.com//contest/1508/problem/A,A. Binary Literature,A bitstring is a string that contains only the characters and Koyomi Kanou is working hard towards her dream of becoming a writer To practice she decided to participate in the The writing prompt for the contest consists of three bitstrings of length 2n A valid novel for the contest is a bitstring of length at most 3n that contains of the three given strings as subsequences Koyomi has just received the three prompt strings from the contest organizers Help her write a valid novel for the contest A string a is a subsequence of a string b if a can be obtained from b by deletion of several possibly zero characters ,"[""#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tarray<string, 3> S;\n\t\tarray<int, 3> cnt{0,0,0};\n\t\tarray<bool, 3> dir{0,0,0};\n\t\tfor (int z = 0; z < 3; z++) {\n\t\t\tcin >> S[z];\n\t\t\tfor (char c : S[z]) cnt[z] += c - '0';\n\t\t\tdir[z] = (cnt[z] >= N);\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = i + 1; j < 3; j++) {\n\t\t\t\tif (dir[i] == dir[j]) {\n\t\t\t\t\tchar d = dir[i] + '0';\n\t\t\t\t\tauto a = S[i].begin(), b = S[j].begin();\n\t\t\t\t\tstring res; res.reserve(3*N);\n\t\t\t\t\tfor (int z = 0; z < N; z++) {\n\t\t\t\t\t\twhile (*a != d) {\n\t\t\t\t\t\t\tres += *a;\n\t\t\t\t\t\t\t++a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (*b != d) {\n\t\t\t\t\t\t\tres += *b;\n\t\t\t\t\t\t\t++b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres += d;\n\t\t\t\t\t\t++a, ++b;\n\t\t\t\t\t}\n\t\t\t\t\tres.insert(res.end(), a, S[i].end());\n\t\t\t\t\tres.insert(res.end(), b, S[j].end());\n\t\t\t\t\tassert(int(res.size()) == 3*N);\n\t\t\t\t\tcout << res << '\\n';\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(false);\ndone:;\n\t}\n\n\treturn 0;\n}\n""]","['constructive algorithms', 'greedy', 'implementation', 'strings', 'two pointers']",1900
https://codeforces.com//contest/1228/problem/F,F. One Node is Gone,You have an integer n Let s define following tree generation as Make a complete and full binary tree of 2 n 1 vertices Complete and full binary tree means a tree that exactly one vertex is a root all leaves have the same depth distance from the root and all non leaf nodes have exactly two child nodes Select a non root vertex v from that binary tree Remove v from tree and make new edges between v s parent and v s direct children If v has no children then no new edges will be made You have a tree Determine if this tree can be made by McDic s generation If yes then find the parent vertex of removed vertex in tree ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define GG do{puts(""0""); exit(0);}while (false);\n#define ASRT(S) if (!(S)) GG;\n\nconst int N = 17, V = (1 << N) + 5;\n\nint ver;\nvector<int> g[V];\nint cnt[5];\nbool vis[V];\n\nvoid chk(int u, int d) {\n  vis[u] = true;\n  int cnt = 0;\n  for (int v : g[u])\n    if (!vis[v]) {\n      chk(v, d - 1);\n      ++cnt;\n    }\n  if (cnt == 0) {\n    ASRT(d == 1);\n  } else\n    ASRT(cnt == 2);\n}\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  int n;\n  scanf(""%d"", &n);\n  if (n == 2) {\n    puts(""2\\n1 2"");\n    return 0;\n  }\n\n  // 2 -- 3 -- 1\n  ver = (1 << n) - 2;\n  for (int rep = 1; rep < ver; ++rep) {\n    int u, v;\n    scanf(""%d%d"", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  for (int i = 1; i <= ver; ++i) {\n    ASRT(g[i].size() <= 4 && g[i].size() > 0);\n    ++cnt[g[i].size()];\n  }\n\n  if (0 == cnt[2]) { // p = root\n    ASRT(cnt[1] == 1 << (n - 1));\n    ASRT(cnt[4] == 0);\n\n    static int dis[V];\n    queue<int> q;\n    for (int i = 1; i <= ver; ++i)\n      if (g[i].size() == 1) {\n        q.push(i);\n        dis[i] = 1;\n      }\n    vector<int> ans;\n    while (!q.empty()) {\n      int u = q.front(); q.pop();\n      if (dis[u] == n - 1)\n        ans.push_back(u);\n      if (dis[u] > n - 1)\n        GG;\n      for (int v : g[u])\n        if (!dis[v]) {\n          dis[v] = dis[u] + 1;\n          q.push(v);\n        }\n    }\n    ASRT(ans.size() == 2);\n    int rt1 = ans[0], rt2 = ans[1];\n    bool fl = false;\n    for (int v : g[rt1])\n      if (v == rt2) {\n        fl = true;\n        break;\n      }\n    ASRT(fl);\n    vis[rt1] = true;\n    vis[rt2] = true;\n    chk(rt1, n - 1);\n    chk(rt2, n - 1);\n    if (rt1 > rt2)\n      swap(rt1, rt2);\n    printf(""2\\n%d %d\\n"", rt1, rt2);\n  } else if (cnt[2] == 2) { // v = leaf\n    ASRT(cnt[4] == 0);\n    ASRT(cnt[1] == ((1 << (n - 1)) - 1));\n    int ans = -1, rt = -1;\n    for (int i = 1; i <= ver; ++i) {\n      if (g[i].size() != 2)\n        continue;\n      bool f = false;\n      for (int v : g[i])\n        if (g[v].size() == 1) {\n          f = true;\n        }\n      if (!f) {\n        rt = i;\n      } else {\n        g[i].push_back(ver + 1);\n        ans = i;\n      }\n    }\n    if (ans == -1 || rt == -1)\n      GG;\n    chk(rt, n);\n    printf(""1\\n%d\\n"", ans);\n  } else {\n    ASRT(cnt[4] == 1);\n    ASRT(cnt[2] == 1);\n    ASRT(cnt[1] == 1 << (n - 1));\n    int rt = -1, ans = -1;\n    for (int i = 1; i <= ver; ++i)\n      if (g[i].size() == 2)\n        rt = i;\n      else if (g[i].size() == 4)\n        ans = i;\n\n    static int dis[V];\n    queue<int> q;\n    for (int i = 1; i <= ver; ++i)\n      if (g[i].size() == 1) {\n        q.push(i);\n        dis[i] = 1;\n      }\n    while (!q.empty()) {\n      int u = q.front(); q.pop();\n      for (int v : g[u])\n        if (!dis[v]) {\n          dis[v] = dis[u] + 1;\n          q.push(v);\n        }\n    }\n    vector<pair<int, int>> vv;\n    for (int v : g[ans])\n      vv.emplace_back(dis[v], v);\n    sort(vv.begin(), vv.end());\n    vector<int> ng;\n    for (int v : g[ans])\n      if (vv[0].second != v && vv[1].second != v)\n        ng.push_back(v);\n    ng.push_back(ver + 1);\n    g[ver + 1].push_back(vv[0].second);\n    g[ver + 1].push_back(vv[1].second);\n    g[ans] = ng;\n    for (int& v : g[vv[0].second])\n      if (v == ans) {\n        v = ver + 1;\n        break;\n      }\n    for (int& v : g[vv[1].second])\n      if (v == ans) {\n        v = ver + 1;\n        break;\n      }\n    chk(rt, n);\n    printf(""1\\n%d\\n"", ans);\n  }\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']","['constructive algorithms', 'implementation', 'trees']",2500
https://codeforces.com//contest/788/problem/E,E. New task,On the 228 th international Uzhlyandian Wars strategic game tournament teams from each country are called The teams should consist of participants The team of Uzhlyandia will consist of soldiers because there are no gamers Masha is a new minister of defense and gaming The prime duty of the minister is to calculate the efficiency of the Uzhlandian army The army consists of soldiers standing in a row enumerated from to For each soldier we know his in Uzhlyandian Wars the th soldier s skill is It was decided that the team will consist of three players and two assistants The skills of players should be same and the assistants skills should not be greater than the players skill Moreover it is important for Masha that one of the assistants should stand in the row to the left of the players and the other one should stand in the row to the right of the players Formally a team is five soldiers with indexes such that and The efficiency of the army is the number of different teams Masha can choose Two teams are considered different if there is such such that the th soldier is a member of one team but not a member of the other team Initially all players are able to be players For some reasons sometimes some soldiers become unable to be players Sometimes some soldiers that were unable to be players become able to be players At any time any soldier is able to be an assistant Masha wants to control the efficiency of the army so she asked you to tell her the number of different possible teams modulo after each change ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nvoid precalc() {\n}\n\nstruct V {\n  int cnt;\n  int suma, sumb;\n  int dsuma, dsumb;\n\n  V() : cnt(0), suma(0), sumb(0), dsuma(0), dsumb(0) {}\n  V(int a, int b) : cnt(1), suma(a), sumb(b), dsuma(0), dsumb(0) {}\n\n  V(const V &l, const V &r) {\n    cnt = l.cnt + r.cnt;\n    suma = sum(l.suma, r.suma);\n    sumb = sum(l.sumb, r.sumb);\n    dsuma = sum(l.dsuma, r.dsuma);\n    dsumb = sum(l.dsumb, r.dsumb);\n    add(dsuma, mult(l.suma, r.cnt));\n    add(dsumb, mult(r.sumb, l.cnt));\n  }\n};\n\nstruct T {\n  int n;\n\n  int *ca, *cb;\n  V *a;\n  bool *ison;\n\n  T(vector<int> &a_, vector<int> &b_, int &res) {\n    assert(sz(a_) == sz(b_));\n    if (0) {\n      eprintf(""sz = %d\\n"", sz(a_));\n      for (int i = 0; i < sz(a_); ++i) {\n        eprintf(""%d,%d\\n"", a_[i], b_[i]);\n      }\n    }\n    for (n = 1; n < sz(a_); n <<= 1) ;\n    a = new V[2 * n - 1];\n    --a;\n\n    ca = new int[n];\n    cb = new int[n];\n    ison = new bool[n];\n\n    for (int i = 0; i < n; ++i) {\n      if (i < sz(a_)) {\n        ca[i] = a_[i];\n        cb[i] = b_[i];\n      } else {\n        ca[i] = cb[i] = 0;\n      }\n      ison[i] = 0;\n    }\n\n    for (int i = 1; i < 2 * n; ++i) {\n      a[i] = V();\n    }\n\n    for (int i = 0; i < sz(a_); ++i) {\n      int toadd = get(i);\n      //eprintf(""add %d\\n"", toadd);\n      add(res, toadd);\n      change(i, 1);\n    }\n  }\n\n  V get(int v, int l, int r, int l0, int r0) {\n    if (l >= r0 || l0 >= r) {\n      return V();\n    }\n\n    if (l0 <= l && r <= r0) {\n      return a[v];\n    }\n\n    int m = (l + r) / 2;\n    return V(get(2 * v, l, m, l0, r0), get(2 * v + 1, m, r, l0, r0));\n  }\n\n  V get(int l, int r) {\n    return get(1, 0, n, l, r);\n  }\n\n  int get(int x) {\n    auto left = get(0, x);\n    auto right = get(x + 1, n);\n    int res = 0;\n    add(res, mult(ca[x], right.dsumb));\n    add(res, mult(cb[x], left.dsuma));\n    add(res, mult(left.suma, right.sumb));\n    return res;\n  }\n\n  void change(int x, int nval) {\n    assert(ison[x] != nval);\n    ison[x] = nval;\n    if (nval) {\n      a[x + n] = V(ca[x], cb[x]);\n    } else {\n      a[x + n] = V();\n    }\n    x += n;\n\n    for (x /= 2; x; x /= 2) {\n      a[x] = V(a[2 * x], a[2 * x + 1]);\n    }\n  }\n};\n\n\nconst int maxn = (int) 1e5 + 10;\nint a[maxn];\nint n, m;\n\nint read() {\n  if (scanf(""%d"", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(""%d"", a + i);\n  }\n  scanf(""%d"", &m);\n  return 1;\n}\n\nstruct FTree {\n  int n;\n  int a[maxn];\n\n  void build(int n_) {\n    n = n_;\n    for (int i = 0; i < n; ++i) {\n      a[i] = 0;\n    }\n  }\n\n  void add(int x, int toadd) {\n    for (; x < n; x |= (x + 1)) {\n      a[x] += toadd;\n    }\n  }\n\n  int get(int x) {\n    int res = 0;\n    for (; x >= 0; x = (x & (x + 1)) - 1) {\n      res += a[x];\n    }\n    return res;\n  }\n} ftree;\n\npair<int, int> tosort[maxn];\n\nint b[maxn];\n\nint cnts[2][maxn];\n\nint ids[maxn];\n\nvoid solve() {\n  for (int i = 0; i < n; ++i) {\n    tosort[i] = mp(a[i], i);\n  }\n  sort(tosort, tosort + n);\n\n  int cnt = 0;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      b[tosort[i].second] = cnt;\n      ++i;\n    }\n    ++cnt;\n  }\n\n\n  for (int iter = 0; iter < 2; ++iter) {\n    ftree.build(cnt);\n    for (int ri = 0; ri < n; ++ri) {\n      int i = ri;\n      if (iter) {\n        i = n - 1 - i;\n      }\n\n      int y = b[i];\n      cnts[iter][i] = ftree.get(y);\n      ftree.add(y, 1);\n    }\n  }\n\n  int res = 0;\n\n  map<int, T*> tree;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      ++i;\n    }\n\n    vector<int> as(i - i0);\n    vector<int> bs(i - i0);\n    for (int j = i0; j < i; ++j) {\n      int pos = tosort[j].second;\n      ids[pos] = j - i0;\n      as[j - i0] = cnts[0][pos];\n      bs[j - i0] = cnts[1][pos];\n    }\n    tree[tosort[i0].first] = new T(as, bs, res);\n  }\n\n  for (int iter = 0; iter < m; ++iter) {\n    int type, x;\n    scanf(""%d%d"", &type, &x);\n    --type;\n    --x;\n\n    auto &t = *(tree[a[x]]);\n\n    if (!type) {\n      t.change(ids[x], 0);\n    }\n\n    int delta = t.get(ids[x]);\n    if (!type) {\n      add(res, mod - delta);\n    } else {\n      add(res, delta);\n    }\n\n    if (type) {\n      t.change(ids[x], 1);\n    }\n\n    printf(""%d\\n"", res);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK "".out"", ""w"", stdout);\n  assert(freopen(TASK "".in"", ""r"", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""Time %.2f\\n"", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']",['data structures'],2900
https://codeforces.com//contest/1641/problem/D,D. Two Arrays,Sam changed his school and on the first biology lesson he got a very interesting task about genes You are given n arrays the i th of them contains m different integers a i 1 a i 2 ldots a i m Also you are given an array of integers w of length n Find the minimum value of w i w j among all pairs of integers i j 1 le i j le n such that the numbers a i 1 a i 2 ldots a i m a j 1 a j 2 ldots a j m are distinct ,"['/**\n *    author:  tourist\n *    created: 23.02.2022 13:19:10       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n, vector<int>(m + 1));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j + 1];\n    }\n    cin >> a[i][0];\n  }\n  sort(a.begin(), a.end());\n  vector<int> w(n);\n  for (int i = 0; i < n; i++) {\n    w[i] = a[i][0];\n    a[i].erase(a[i].begin());\n  }\n  map<int, int> mp;\n  int t = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      auto it = mp.find(a[i][j]);\n      if (it == mp.end()) {\n        mp[a[i][j]] = t;\n        a[i][j] = t++;\n      } else {\n        a[i][j] = it->second;\n      }\n    }\n  }\n  vector<unsigned long long> mask(t, -1);\n  const unsigned long long one = 1;\n  const int inf = (int) 2.01e9;\n  int ans = inf;\n  for (int L = 0; L < n; L += 64) {\n    int R = min(L + 64, n);\n    unsigned long long init = 0;\n    for (int i = L; i < R; i++) {\n      init |= (one << (i - L));\n      for (int j = 0; j < m; j++) {\n        mask[a[i][j]] ^= (one << (i - L));\n      }\n    }\n    for (int i = L; i < n; i++) {\n      unsigned long long cur = init;\n      for (int j = 0; j < m; j++) {\n        cur &= mask[a[i][j]];\n      }\n      if (cur > 0) {\n        int id = L + __builtin_ctzll(cur);\n        ans = min(ans, w[i] + w[id]);\n      }\n    }\n    for (int i = L; i < R; i++) {\n      for (int j = 0; j < m; j++) {\n        mask[a[i][j]] ^= (one << (i - L));\n      }\n    }\n  }\n  cout << (ans == inf ? -1 : ans) << \'\\n\';\n  debug(clock());\n  return 0;\n}\n']","['bitmasks', 'brute force', 'combinatorics', 'greedy', 'hashing', 'math', 'two pointers']",2700
https://codeforces.com//contest/600/problem/A,A. Extract Numbers,You are given string Let s call any largest sequence of consecutive symbols without symbols comma and semicolon For example there are four in string A word can be empty for example the string contains three empty words separated by You should find all in the given string that are nonnegative INTEGER numbers without leading zeroes and build by them new string String should contain all that are numbers separating them by the order of numbers should remain the same as in the string By all other you should build string in the same way the order of numbers should remain the same as in the string Here strings are INTEGER numbers but and are not For example for the string the string would be equal to and string would be equal to ,"['/*\nYeah\n\nHere she comes again, she\'s feeling like she\'s already won\nI believe it\'s gonna end again, all for naught\nMy philosophy is things are just as wrong as they seem\nI believe it\'s gonna end this way, atrocity\n\nDo you believe in love like I believe in pain\nNobody died for you, somebody pray for me\n\nWhen you see me cut me down\nAnd I will force it underground\nThere\'s no one left to hurt but me\nAnd it\'s because of me, right?\n\nThere he walks away, he\'s feeling like he\'s having them on\nI believe he\'s gonna bend again and all for no\nMy philosophy is things are just as wrong as they seem\nI\'ve gotta get you off of my mind, in oddity\n\nDo you believe in love like I believe in pain\nNobody died for you, somebody pray for me\n\nWhen you see me cut me down\nAnd I will force it underground\nThere\'s no one left to hurt but me\nAnd it\'s because of me, right?\n\nI want to see you suffer, suffer\n\nWhen you see me cut me down\nAnd I will force it underground\nThere\'s no one left to hurt but me\nAnd it\'s because of me, right?\n\nWhen you see me cut me down\nAnd when you see me cut me down\nAnd when you see me cut me down\nAnd it\'s because of me, suffer\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring st;\nvector<string> v1,v2;\n\nbool good(string st)\n{\n\tif (st.size()==0)\n\t\treturn false;\n\tfor (int i=0;i<st.size();i++)\n\t\tif (st[i]<\'0\'||st[i]>\'9\')\n\t\t\treturn false;\n\tif (st.size()>1&&st[0]==\'0\')\n\t\treturn false;\n\treturn true;\n}\n\nvoid add_string(string st)\n{\n\tif (good(st))\n\t\tv1.push_back(st);\n\telse\n\t\tv2.push_back(st);\n}\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tgetline(cin,st);\n\t\n\tstring temp="""";\n\t\n\tfor (int i=0;i<st.size();i++)\n\t{\n\t\tif (st[i]==\';\'||st[i]==\',\')\n\t\t{\n\t\t\tadd_string(temp);\n\t\t\ttemp="""";\n\t\t}\n\t\telse\n\t\t\ttemp+=st[i];\n\t}\n\t\n\tadd_string(temp);\n\t\n\tif (v1.size()==0)\n\t\tcout<<""-""<<endl;\n\telse\n\t{\n\t\tcout<<""\\"""";\n\t\tfor (int i=0;i<v1.size();i++)\n\t\t{\n\t\t\tif (i)\n\t\t\t\tcout<<"","";\n\t\t\tcout<<v1[i];\n\t\t}\n\t\tcout<<""\\"""";\n\t\tcout<<endl;\n\t}\n\t\n\tif (v2.size()==0)\n\t\tcout<<""-""<<endl;\n\telse\n\t{\n\t\tcout<<""\\"""";\n\t\tfor (int i=0;i<v2.size();i++)\n\t\t{\n\t\t\tif (i)\n\t\t\t\tcout<<"","";\n\t\t\tcout<<v2[i];\n\t\t}\n\t\tcout<<""\\"""";\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}']","['implementation', 'strings']",1600
https://codeforces.com//contest/914/problem/E,E. Palindromes in a Tree,You are given a tree a connected acyclic undirected graph of vertices Vertices are numbered from to and each vertex is assigned a character from to A path in the tree is said to be palindromic if at least one permutation of the labels in the path is a palindrome For each vertex output the number of palindromic paths passing through it The path from vertex to vertex is considered to be the same as the path from vertex to vertex and this path will be counted only once for each of the vertices it passes through ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=210000;\nint head[N],np[N<<1],p[N<<1],tot;\nint n;\nchar _str[N];\nint col[N];\nint fa[N],size[N];\nbool vis[N],inq[N];\nint q[N];\nLL ans[N];\nint getRoot(int ss){\n\tq[q[0]=1]=ss;\n\tinq[ss]=1;\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfor(int u=head[x];u;u=np[u])if(!vis[p[u]])if(!inq[p[u]]){\n\t\t\tfa[p[u]]=x;\n\t\t\tq[++q[0]]=p[u];\n\t\t\tinq[p[u]]=1;\n\t\t}\n\t}\n\tint mi=1000000;\n\tint rp=0;\n\tper(i,q[0],1){\n\t\tint x=q[i];\n\t\tint ma=-1;\n\t\tsize[x]=1;\n\t\tfor(int u=head[x];u;u=np[u])if(!vis[p[u]])if(inq[p[u]])if(fa[p[u]]==x){\n\t\t\tsize[x]+=size[p[u]];\n\t\t\tma=max(ma,size[p[u]]);\n\t\t}\n\t\tma=max(ma,q[0]-size[x]);\n\t\tif(ma<mi){\n\t\t\tmi=ma;\n\t\t\trp=x;\n\t\t}\n\t}\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tsize[x]=fa[x];inq[x]=0;\n\t}\n\tq[0]=0;\n\treturn rp;\n}\nint val[N];\nvoid bfs1(int rt){\n\tq[q[0]=1]=rt;\n\tinq[rt]=1;\n\tval[rt]=(1<<col[rt]);\n\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfor(int u=head[x];u;u=np[u])if(!inq[p[u]])if(!vis[p[u]]){\n\t\t\tfa[p[u]]=x;\n\t\t\tinq[p[u]]=1;\n\t\t\tval[p[u]]=val[x]^(1<<col[p[u]]);\n\t\t\tq[++q[0]]=p[u];\n\t\t}\n\t}\n}\nint pp[1<<20];\nint ti[1<<20];\nint cnt[1<<20];\nint nowt;\nint meask(int t){\n\tif(ti[t]!=nowt){\n\t\tpp[t]=0;\n\t\tti[t]=nowt;\n\t}\n\treturn pp[t];\n}\nvoid meadd(int t,int v){\n\tif(ti[t]!=nowt){\n\t\tpp[t]=0;\n\t\tti[t]=nowt;\n\t}\n\tpp[t]+=v;\n}\nLL res=0;\nLL sb[N];\nvoid dfs1(int x,int ff){\n\tsb[x]=0;\n\tif(cnt[val[x]]<=1)++sb[x];\n\t//if(ff==2&&x==6)printf(""____________%d\\n"",sb[x]);\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tdfs1(p[u],x);\n\t\tsb[x]+=sb[p[u]];\n\t}\n\tans[x]+=sb[x];\n}\nint nowcol;\nvoid calc1(int x,int ff=-1){\n\tsb[x]=meask(val[x]^(1<<nowcol));\n\trep(i,0,19){\n\t\tint ot=(val[x]^(1<<nowcol));\n\t\tot^=(1<<i);\n\t\tsb[x]+=meask(ot);\n\t}\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tcalc1(p[u],x);\n\t\tsb[x]+=sb[p[u]];\n\t}\n\tans[x]+=sb[x];\n}\nvoid add1(int x,int ff=-1){\n\tmeadd(val[x],1);\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tadd1(p[u],x);\n\t}\n}\nint xp[N];\nvoid work(int ss){\n\tint rt=getRoot(ss);\n\tvis[rt]=1;\n\tbfs1(rt);\n\tnowt=rt;\n\tnowcol=col[rt];\n\t//root to it\n\tres=0;\n\tdfs1(rt,-1);\n\txp[0]=0;\n\t//rep(i,1,n)printf("".%d:%lld\\n"",i,ans[i]);\n\tfor(int u=head[rt];u;u=np[u])if(!vis[p[u]])if(inq[p[u]]){\n\t\tcalc1(p[u]);\n\t\tadd1(p[u]);\n\t\txp[++xp[0]]=p[u];\n\t\tans[rt]+=sb[p[u]];\n\t}\n\tnowt=n+rt;\n\tper(i,xp[0],1){\n\t\tint x=xp[i];\n\t\tcalc1(x);\n\t\tadd1(x);\n\t}\n\t//rep(i,1,n)printf(""%d:%lld\\n"",i,ans[i]);\n\t//rep(i,1,n)printf(""_%d:%d\\n"",i,val[i]);\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfa[x]=0;\n\t\tinq[x]=0;\n\t\tval[x]=0;\n\t\tsize[x]=0;\n\t}\n\tq[0]=0;\n\tfor(int u=head[rt];u;u=np[u])if(!vis[p[u]])work(p[u]);\n}\nint main(){\n\trep(i,1,(1<<20)-1)cnt[i]=cnt[i>>1]+(i&1);\n\tscanf(""%d"",&n);\n\trep(i,1,n-1){\n\t\tint a,b;scanf(""%d%d"",&a,&b);\n\t\t++tot;p[tot]=b;np[tot]=head[a];head[a]=tot;\n\t\t++tot;p[tot]=a;np[tot]=head[b];head[b]=tot;\n\t}\n\tscanf(""%s"",_str+1);\n\trep(i,1,n)col[i]=_str[i]-\'a\';\n\n\twork(1);\n\trep(i,1,n)printf(""%lld%c"",ans[i],i==n?\'\\n\':\' \');\n\treturn 0;\n}\n\n\n']","['bitmasks', 'data structures', 'divide and conquer', 'trees']",2400
https://codeforces.com//contest/893/problem/F,F. Subtree Minimum Query,You are given a rooted tree consisting of vertices Each vertex has a number written on it number is written on vertex Let s denote as the distance between vertices and in the tree that is the number of edges in the shortest path from to Also let s denote the of vertex as the set of vertices such that both these conditions are met is an ancestor of every vertex is an ancestor of itself You are given queries to the tree th query is represented by two numbers and and the answer to this query is the minimum value of among such vertices such that belongs to blocked subtree of Write a program that would process these queries quickly ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nstruct Vertex {\n\tint level;\n\tint val;\n\n\tVertex() {}\n\tVertex(int l, int v): level(l), val(v) {}\n\n\tbool operator <(const Vertex& ot) const {\n\t\treturn level < ot.level;\n\t}\n};\n\nconst int INF = 1e9 + 10;\n\nstruct SegTree {\n\tint n;\n\tvector<vector<Vertex>> a;\n\tvector<vector<int>> res;\n\n\tSegTree(const vector<int>& level, const vector<int>& vals) {\n\t\tn = 1;\n\t\twhile (n < (int)level.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\ta.resize(n + n);\n\t\tres.resize(n + n);\n\t\tfor (int i = 0; i < (int)level.size(); ++i) {\n\t\t\ta[n + i] = {{level[i], vals[i]}};\n\t\t\tres[n + i] = {INF, vals[i]};\n\t\t}\n\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\ta[i].resize(a[i + i].size() + a[i + i + 1].size());\n\t\t\tmerge(all(a[i + i]), all(a[i + i + 1]), a[i].begin());\n\t\t\tres[i].resize(a[i].size() + 1, INF);\n\t\t\tfor (int j = 0; j < (int)a[i].size(); ++j) {\n\t\t\t\tres[i][j + 1] = min(res[i][j], a[i][j].val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint _get(int v, int l1, int r1, int l, int r, int maxk) {\n\t\tif (l >= r1 || l1 >= r) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (l <= l1 && r >= r1) {\n\t\t\tint idx = lower_bound(all(a[v]), Vertex(maxk + 1, 0)) - a[v].begin();\n\t\t\treturn res[v][idx];\n\t\t}\n\t\tint mid = (l1 + r1) / 2;\n\t\treturn min(_get(v + v, l1, mid, l, r, maxk),\n\t\t\t\t   _get(v + v + 1, mid, r1, l, r, maxk));\n\t}\n\n\tint get(int l, int r, int maxk) {\n\t\treturn _get(1, 0, n, l, r, maxk);\n\t}\n};\n\nconst int N = 111111;\nint tin[N], tout[N], level[N];\nint timer = 0;\nvector<int> a[N];\nint val[N];\nvector<int> levels, vals;\n\nvoid dfs(int v, int p = -1) {\n\ttin[v] = timer++;\n\tlevels.push_back(level[v]);\n\tvals.push_back(val[v]);\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tlevel[x] = level[v] + 1;\n\t\tdfs(x, v);\n\t}\n\ttout[v] = timer;\n}\n\nint main() {\n\tint n = nxt(), root = nxt() - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tval[i] = nxt();\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tdfs(root);\n\n\tSegTree tree(levels, vals);\n\tint q = nxt();\n\tint last = 0;\n\twhile (q--) {\n\t\tint p1 = nxt(), p2 = nxt();\n\t\tint x = (p1 + last) % n;\n\t\tint k = (p2 + last) % n;\n\n\t\tlast = tree.get(tin[x], tout[x], level[x] + k);\n\t\tprintf(""%d\\n"", last);\n\t}\n\n\treturn 0;\n}\n']","['data structures', 'trees']",2300
https://codeforces.com//contest/954/problem/I,I. Yet Another String Matching Problem,Suppose you have two strings and and their length is equal You may perform the following operation any number of times choose two different characters and and replace every occurence of in both strings with Let s denote the between strings and as the minimum number of operations required to make these strings equal For example if is and is the between them is we may replace every occurence of with so becomes and then we may replace every occurence of with so both strings become You are given two strings and For every substring of consisting of characters you have to determine the between this substring and ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\n#define MN 262144\nconst double pi=acos(-1);\nstruct cp\n{\n\tdouble r,i;\n\tcp(double r=0,double i=0):r(r),i(i){}\n\tcp operator+(cp b){return cp(r+b.r,i+b.i);}\n\tcp operator-(cp b){return cp(r-b.r,i-b.i);}\n\tcp operator*(cp b){return cp(r*b.r-i*b.i,r*b.i+i*b.r);}\n}w[2][MN+5],x[MN+5],y[MN+5];\nint N,R[MN+5],u[MN+5][6][6],f[6];\nchar a[MN+5],b[MN+5];\nint gf(int k){return f[k]<0?k:f[k]=gf(f[k]);}\nvoid init(int n)\n{\n\tfor(N=1;N<=n;N<<=1);\n\tcp g(cos(2*pi/N),sin(2*pi/N));int i,j,k;\n\tfor(i=w[0][0].r=1;i<N;++i)w[0][i]=w[0][i-1]*g;\n\tfor(i=w[1][0].r=1;i<N;++i)w[1][i]=w[0][N-i];\n\tfor(i=j=0;i<N;R[++i]=j)for(k=N>>1;(j^=k)<k;k>>=1);\n}\nvoid fft(cp*x,int v)\n{\n\tint i,j,k;\n\tfor(i=0;i<N;++i)if(i<R[i])swap(x[i],x[R[i]]);\n\tfor(i=1;i<N;i<<=1)for(j=0;j<N;j+=i<<1)for(k=0;k<i;++k)\n\t{\n\t\tcp p=x[i+j+k]*w[v][N/(i<<1)*k];\n\t\tx[i+j+k]=x[j+k]-p;x[j+k]=x[j+k]+p;\n\t}\n\tif(v)for(i=0;i<N;++i)x[i].r/=N,x[i].i/=N;\n}\nint main()\n{\n\tint n,m,i,j,k,ans=0;\n\tscanf(""%s%s"",a+1,b+1);\n\tn=strlen(a+1);m=strlen(b+1);init(n+n);\n\tfor(i=0;i<6;++i)for(j=0;j<6;++j)if(i!=j)\n\t{\n\t\tmemset(x,0,sizeof(x));memset(y,0,sizeof(y));\n\t\tfor(k=1;k<=n;++k)x[k]=a[k]==i+\'a\';\n\t\tfor(k=1;k<=m;++k)y[n-k]=b[k]==j+\'a\';\n\t\tfft(x,0);fft(y,0);\n\t\tfor(k=0;k<N;++k)x[k]=x[k]*y[k];\n\t\tfft(x,1);\n\t\tfor(k=0;k<=n-m;++k)u[k][i][j]=x[n+k].r>0.5;\n\t}\n\tfor(k=0;k<=n-m;++k)\n\t{\n\t\tmemset(f,-1,sizeof(f));ans=0;\n\t\tfor(i=0;i<6;++i)for(j=0;j<6;++j)if(u[k][i][j]&&gf(i)!=gf(j))f[gf(i)]=gf(j),++ans;\n\t\tprintf(""%d "",ans);\n\t}\n\treturn 0;\n}']","['fft', 'math']",2200
https://codeforces.com//contest/1155/problem/B,B. Game with Telephone Numbers,A telephone number is a sequence of 11 digits such that its first digit is Vasya and Petya are playing a game Initially they have a string s of length n n is odd consisting of digits Vasya makes the first move then players alternate turns In one move the player choose a character and erase it from the current string For example if the current string after the player s move it may be or The game ends when the length of string s becomes If the resulting string is a telephone number Vasya wins otherwise Petya wins You have to determine if Vasya has a winning strategy that is if Vasya can win the game no matter which characters Petya chooses during his moves ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nchar s[N];\nint n;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d %s"", &n, s);\n\tint bal = 0;\n\tfor (int i = 0; i < n - 10; i++) {\n\t\tif (s[i] == \'8\')\n\t\t\tbal++;\n\t\telse\n\t\t\tbal--;\n\t}\n\tif (bal > 0)\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n\n\treturn 0;\n}\n']","['games', 'greedy', 'implementation']",1200
https://codeforces.com//contest/1428/problem/E,E. Carrots for Rabbits,There are some rabbits in Singapore Zoo To feed them Zookeeper bought n carrots with lengths a 1 a 2 a 3 ldots a n However rabbits are very fertile and multiply very quickly Zookeeper now has k rabbits and does not have enough carrots to feed all of them To solve this problem Zookeeper decided to cut the carrots into k pieces For some reason all resulting carrot lengths must be positive integers Big carrots are very difficult for rabbits to handle and eat so the time needed to eat a carrot of size x is x 2 Help Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\n\nint n, k;\n\nll tab[nax];\n\nll kwa(ll v)\n{\n\treturn v*v;\n}\n\nll koszt(int v, ll cz)\n{\n\tif (cz>tab[v])\n\t\treturn inf;\n\tll dz=tab[v]/cz;\n\tll resz=tab[v]%cz;\n\treturn kwa(dz+1)*resz+kwa(dz)*(cz-resz);\n}\n\nll tu[nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ttu[i]=1;\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tpriority_queue<pair<ll,int>>kol;\n\tfor (int i=1; i<=n; i++)\n\t\tkol.push({koszt(i, 1)-koszt(i, 2), i});\n\tfor (int h=n+1; h<=k; h++)\n\t{\n\t\tint v=kol.top().second;\n\t\tkol.pop();\n\t\ttu[v]++;\n\t\tkol.push({koszt(v, tu[v])-koszt(v, tu[v]+1), v});\n\t}\n\tll wyn=0;\n\tfor (int i=1; i<=n; i++)\n\t\twyn+=koszt(i, tu[i]);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['binary search', 'data structures', 'greedy', 'math', 'sortings']",2200
https://codeforces.com//contest/1340/problem/A,A. Nastya and Strange Generator,Denis bought a mysterious item and it was Random permutation generator Denis could not believed his luck When he arrived home he began to study how his generator works and learned the algorithm The process of generating a permutation consists of n steps At the i th step a place is chosen for the number i 1 leq i leq n The position for the number i is defined as follows For all j from 1 to n we calculate r j the minimum index such that j leq r j leq n and the position r j is not yet occupied in the permutation If there are no such positions then we assume that the value of r j is not defined For all t from 1 to n we calculate count t the number of positions 1 leq j leq n such that r j is defined and r j t Consider the positions that are still not occupied by permutation and among those we consider the positions for which the value in the count array is maximum The generator selects one of these positions for the number i The generator can choose position Let s have a look at the operation of the algorithm in the following example Let n 5 and the algorithm has already arranged the numbers 1 2 3 in the permutation Consider how the generator will choose a position for the number 4 The values of r will be r 3 3 3 4 times where times means an indefinite value Then the count values will be count 0 0 3 1 0 There are only two unoccupied positions in the permutation 3 and 4 The value in the count array for position 3 is 3 for position 4 it is 1 The maximum value is reached only for position 3 so the algorithm will uniquely select this position for number 4 Satisfied with his purchase Denis went home For several days without a break he generated permutations He believes that he can come up with random permutations no worse than a generator After that he wrote out the first permutation that came to mind p 1 p 2 ldots p n and decided to find out if it could be obtained as a result of the generator Unfortunately this task was too difficult for him and he asked you for help It is necessary to define whether the written permutation could be obtained using the described algorithm if the generator always selects the position Denis needs ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tvector<int> P(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> P[i]; P[i]--;\n\t\t}\n\t\tbool good = true;\n\t\tint curMin = N;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (P[i] < curMin) {\n\t\t\t\tcurMin = P[i];\n\t\t\t} else if (P[i] == P[i-1]+1) {\n\t\t\t\t// still good\n\t\t\t} else {\n\t\t\t\tgood = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (good ? ""Yes"" : ""No"") << \'\\n\';\n\t}\n\n\treturn 0;\n}\n']","['brute force', 'data structures', 'greedy', 'implementation']",1500
https://codeforces.com//contest/1059/problem/B,B. Forgery,Student Andrey has been skipping physical education lessons for the whole term and now he must somehow get a passing grade on this subject Obviously it is impossible to do this by legal means but Andrey doesn t give up Having obtained an empty certificate from a local hospital he is going to use his knowledge of local doctor s handwriting to make a counterfeit certificate of illness However after writing most of the certificate Andrey suddenly discovered that doctor s signature is impossible to forge Or is it For simplicity the signature is represented as an n times m grid where every cell is either filled with ink or empty Andrey s pen can fill a 3 times3 square without its central cell if it is completely contained inside the grid as shown below xxxx xxxx Determine whether is it possible to forge the signature on an empty n times m grid ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nint n,m;\nchar target[1010][1010],now[1010][1010];\n\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    in(n,m);\n    REP(i,0,n){\n        scanf(""%s"",target[i]);\n    }\n    REP(i,0,n)REP(j,0,m)now[i][j] = \'.\';\n    REP(i,0,n-2){\n        REP(j,0,m-2){\n            bool ok = 1;\n            REP(dx,0,3){\n                REP(dy,0,3){\n                    if(dx == 1 && dy == 1)continue;\n                    if(target[i+dx][j+dy] == \'.\')ok = 0;\n                }\n            }\n            if(ok){\n                REP(dx,0,3){\n                    REP(dy,0,3){\n                        if(dx == 1 && dy == 1)continue;\n                        now[i+dx][j+dy] = \'#\';\n                    }\n                }\n            }\n        }\n    }\n    \n    bool ok = 1;\n    REP(i,0,n)REP(j,0,m)if(now[i][j]!=target[i][j])ok = 0;\n    if(ok)cout<<""YES"";\n    else cout<<""NO"";\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']",['implementation'],1300
https://codeforces.com//contest/1842/problem/B,B. Tenzing and Books,Tenzing received 3n books from his fans The books are arranged in 3 stacks with n books in each stack Each book has a non negative integer difficulty rating Tenzing wants to read some possibly zero books At first his is 0 To read the books Tenzing will choose a non empty stack read the book on the top of the stack and then discard the book If Tenzing s knowledge is currently u then his knowledge will become u v after reading a book with difficulty rating v Here denotes the bitwise OR operation Note that Tenzing can stop reading books whenever he wants Tenzing s favourite number is x Can you help Tenzing check if it is possible for his knowledge to become x ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:04:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, x;\n    cin >> n >> x;\n    int res = 0;\n    for (int it = 0; it < 3; it++) {\n      vector<int> a(n);\n      for (int i = 0; i < n; i++) {\n        cin >> a[i];\n      }\n      for (int y : a) {\n        if ((y & x) != y) {\n          break;\n        }\n        res |= y;\n      }\n    }\n    cout << (res == x ? ""Yes"" : ""No"") << \'\\n\';\n  }\n  return 0;\n}\n']","['bitmasks', 'greedy', 'math']",1100
https://codeforces.com//contest/746/problem/B,B. Decoding,Polycarp is mad about coding that is why he writes Sveta encoded messages He calls the in a word the letter which is in the middle of the word If the word s length is even the median letter is the left of the two middle letters In the following examples the median letter is highlighted If the word consists of single letter then according to above definition this letter is the median letter Polycarp encodes each word in the following way he writes down the median letter of the word then deletes it and repeats the process until there are no letters left For example he encodes the word as You are given an encoding of some word your task is to decode it ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)301*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n;\nstring s;\nchar ans[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>s;\n    ll k=n;\n    for(int i=0;i<n;i++)ans[i]='.';\n    for(int i=0;i<s.size();i++)\n    {\n    \tll x=(k-1)/2;\n    \tfor(int j=0;j<n;j++)\n    \t{\n    \t\tif(x==0 && ans[j]=='.'){ans[j]=s[i];break;}\n    \t\tif(ans[j]=='.')x--;\n\t\t}\n    \tk--;\n\t}\n\tfor(int i=0;i<n;i++)cout<<ans[i];\n    return 0;\n}""]","['implementation', 'strings']",900
https://codeforces.com//contest/1221/problem/G,G. Graph And Numbers,You are given an undirected graph with n vertices and m edges You have to write a number on each vertex of this graph each number should be either 0 or 1 After that you write a number on each edge equal to the sum of numbers on vertices incident to that edge You have to choose the numbers you will write on the vertices so that there is at least one edge with 0 written on it at least one edge with 1 and at least one edge with 2 How many ways are there to do it Two ways to choose numbers are different if there exists at least one vertex which has different numbers written on it in these two ways ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, m;\nconst int maxN = 42;\nvector < int > g[maxN];\nint deg[maxN];\nbool ed[maxN][maxN];\nll f() {\n    return (1LL << n);\n}\nconst int maxK = 20;\nbool bad[(1 << maxK) + 10];\nint from[(1 << maxK) + 10];\nbool other_bad[(1 << maxK) + 10];\nint cnt[(1 << maxK) + 10];\nll indep() {\n    int half = n / 2;\n    for (int i = 0; i < half; i++) {\n        for (int j = i + 1; j < half; j++) {\n            if (ed[i][j]) {\n                bad[(1 << i) + (1 << j)] = true;\n            }\n        }\n        for (int j = half; j < n; j++) {\n            if (ed[i][j]) {\n                from[(1 << i)] |= (1 << (j - half));\n            }\n        }\n    }\n    for (int bit = 0; bit < half; bit++) {\n        for (int mask = 0; mask < (1 << half); mask++) {\n            if (mask & (1 << bit)) {\n                bad[mask] |= bad[mask ^ (1 << bit)];\n                from[mask] |= from[mask ^ (1 << bit)];\n            }\n        }\n    }\n    int other_half = n - half;\n    for (int i = half; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (ed[i][j]) {\n                other_bad[(1 << (i - half)) + (1 << (j - half))] = true;\n            }\n        }\n    }\n    for (int bit = 0; bit < other_half; bit++) {\n        for (int mask = 0; mask < (1 << other_half); mask++) {\n            if (mask & (1 << bit)) {\n                other_bad[mask] |= other_bad[mask ^ (1 << bit)];\n            }\n        }\n    }\n    for (int mask = 0; mask < (1 << other_half); mask++) {\n        if (!other_bad[mask]) cnt[mask] = 1;\n    }\n    for (int bit = 0; bit < other_half; bit++) {\n        for (int mask = 0; mask < (1 << other_half); mask++) {\n            if (mask & (1 << bit)) {\n                cnt[mask] += cnt[mask ^ (1 << bit)];\n            }\n        }\n    }\n    int all = (1 << other_half) - 1;\n    ll tot = 0;\n    for (int my_mask = 0; my_mask < (1 << half); my_mask++) {\n        if (bad[my_mask]) continue;\n        int bad_guys = from[my_mask];\n        int good_guys = all ^ bad_guys;\n        tot += cnt[good_guys];\n    }\n    return tot;\n}\nbool used[maxN];\nvoid dfs(int v) {\n    used[v] = true;\n    for (int to : g[v]) {\n        if (used[to]) continue;\n        dfs(to);\n    }\n}\nll ones() {\n    // just number of conn\n    int tot = 0;\n    memset(used, 0, sizeof used);\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            dfs(i);\n            tot++;\n        }\n    }\n    return (1LL << tot);\n}\nll f01() {\n    int tot = 0;\n    for (int i = 0; i < n; i++) if (deg[i] == 0) tot++;\n    return (1LL << tot);\n}\nint clr[maxN];\nbool ALL_OK = true;\nvoid other_dfs(int v) {\n    used[v] = true;\n    for (int to : g[v]) {\n        if (used[to]) {\n            if (clr[to] != clr[v] ^ 1) {\n                ALL_OK = false;\n                return;\n            }\n        }\n        else {\n            clr[to] = clr[v] ^ 1;\n            other_dfs(to);\n        }\n    }\n}\nll f02() {\n    int tot = 0;\n    memset(used, 0, sizeof used);\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            tot++;\n            other_dfs(i);\n        }\n    }\n    if (!ALL_OK) return 0;\n    return (1LL << tot);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n >> m;\n    if (m == 0) {\n        cout << 0;\n        return 0;\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        deg[a]++;\n        deg[b]++;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        ed[a][b] = ed[b][a] = true;\n    }\n    ll x = f();\n    ll y = indep();\n    ll z = ones();\n    ll t = f01();\n    ll q = f02();\n    cout << x - 2 * y - z + 2 * t + q;\n\n    return 0;\n}']","['bitmasks', 'brute force', 'combinatorics', 'dp', 'meet-in-the-middle']",2900
https://codeforces.com//contest/203/problem/E,E. Transportation,Valera came to Japan and bought many robots for his research He s already at the airport the plane will fly very soon and Valera urgently needs to bring all robots to the luggage compartment The robots are self propelled they can potentially move on their own some of them even have compartments to carry other robots More precisely for the th robot we know value the number of robots it can carry In this case each of transported robots can additionally carry other robots However the robots need to be filled with fuel to go so Valera spent all his last money and bought liters of fuel He learned that each robot has a restriction on travel distances Thus in addition to features the th robot has two features and the amount of fuel in liters needed to move the th robot and the maximum distance that the robot can go Due to the limited amount of time and fuel Valera wants to move the maximum number of robots to the luggage compartment He operates as follows First Valera selects some robots that will travel to the luggage compartment on their own In this case the total amount of fuel required to move all these robots must not exceed Then Valera seats the robots into the compartments so as to transport as many robots as possible Note that if a robot doesn t move by itself you can put it in another not moving robot that is moved directly or indirectly by a moving robot After that all selected and seated robots along with Valera go to the luggage compartment and the rest robots will be lost There are meters to the luggage compartment Therefore the robots that will carry the rest must have feature of not less than During the moving Valera cannot stop or change the location of the robots in any way Help Valera calculate the maximum number of robots that he will be able to take home and the minimum amount of fuel he will have to spend because the remaining fuel will come in handy in Valera s research ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iomanip>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<ctime>\nusing namespace std;\n\nconst int mxn=100005;\nint n,d,s;\nint a[mxn][3],b[mxn][3],m1=0,m2=0;\ninline int cmp(const void *a,const void *b)\n{\n\treturn ((int*)a)[1]-((int*)b)[1];\n}\ninline int cmp2(const void *a,const void *b)\n{\n\tif(((int*)a)[2]>=d&&((int*)b)[2]<d) return -1;\n\tif(((int*)a)[2]<d&&((int*)b)[2]>=d) return 1;\n\treturn ((int*)a)[1]-((int*)b)[1];\n}\nbool u[mxn];\n\nint main()\n{\n\tscanf(""%d%d%d"",&n,&d,&s);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint p,q,r;\n\t\tscanf(""%d%d%d"",&p,&q,&r);\n\t\tif(p==0)\n\t\t{\n\t\t\tm1++;\n\t\t\ta[m1][0]=p;a[m1][1]=q;a[m1][2]=r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm2++;\n\t\t\tb[m2][0]=p;b[m2][1]=q;b[m2][2]=r;\n\t\t}\n\t}\n\tqsort(a+1,m1,sizeof(a[0]),cmp);\n\tqsort(b+1,m2,sizeof(b[0]),cmp);\n\tint ans=0,mcost=0;\n\tfor(int i=1;i<=m1;i++)\n\t{\n\t\tif(a[i][1]+mcost<=s&&a[i][2]>=d)\n\t\t{\n\t\t\tans++;\n\t\t\tmcost+=a[i][1];\n\t\t}\n\t}\n\tif(m2==0)\n\t{\n\t\tcout<<ans<<\' \'<<mcost<<endl;\n\t\treturn 0;\n\t}\n\tint anst=0,c2=0;\n\t\n\tint rem=0;\n\tfor(int i=1;i<=m2;i++)\n\t{\n\t\tif(b[i][2]>=d&&b[i][1]<=s)\n\t\t{\n\t\t\tanst++;\n\t\t\tc2+=b[i][1];\n\t\t\trem+=b[i][0];\n\t\t\tfor(int j=i+1;j<=m2;j++)\n\t\t\t{\n\t\t\t\trem+=b[j][0];\n\t\t\t\tif(rem>n) rem=n;\n\t\t\t\tm1++;a[m1][0]=b[j][0],a[m1][1]=b[j][1],a[m1][2]=b[j][2];\n\t\t\t}\n\t\t\tfor(int j=i-1;j>=1;j--)\n\t\t\t{\n\t\t\t\trem+=b[j][0];\n\t\t\t\tif(rem>n) rem=n;\n\t\t\t\tm1++;a[m1][0]=b[j][0],a[m1][1]=b[j][1],a[m1][2]=b[j][2];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(i==m2)\n\t\t{\n\t\t\tcout<<ans<<\' \'<<mcost<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn--;\n\tqsort(a+1,n,sizeof(a[0]),cmp2);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(min(rem,n+1-i)+anst>ans||min(rem,n+1-i)+anst==ans&&c2<mcost)\n\t\t{\n\t\t\tans=min(rem,n+1-i)+anst,mcost=c2;\n\t\t}\n\t\tif(c2+a[i][1]<=s&&a[i][2]>=d)\n\t\t{\n\t\t\tc2+=a[i][1];\n\t\t\tanst++;\n\t\t}\n\t\telse if(rem>0) rem--,anst++;\n\t}\n\t\n\tif(anst>ans||anst==ans&&c2<mcost) ans=anst,mcost=c2;\n\tcout<<ans<<\' \'<<mcost<<endl;\n\t\n\treturn 0;\n}\n/*\n3 10 10\n0 12 10\n1 6 10\n0 1 1\n*/\n\n']","['greedy', 'sortings', 'two pointers']",2300
https://codeforces.com//contest/705/problem/B,B. Spider Man,Peter Parker wants to play a game with Dr Octopus The game is about cycles is a sequence of vertices such that first one is connected with the second second is connected with third and so on while the last one is connected with the first one again Cycle may consist of a single isolated vertex Initially there are cycles th of them consisting of exactly vertices Players play alternatively Peter goes first On each turn a player must choose a cycle with at least vertices for example vertices among all available cycles and replace it by two cycles with and vertices where is chosen by the player The player who cannot make a move loses the game and his life Peter wants to test some configurations of initial cycle sets before he actually plays with Dr Octopus Initially he has an empty set In the th test he adds a cycle with vertices to the set this is actually a multiset because it can contain two or more identical cycles After each test Peter wants to know that if the players begin the game with the current set of cycles who wins Peter is pretty good at math but now he asks you to help ,"['#include ""stdio.h""\n\nint n;\nlong long ai,sum;\n\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(""%I64d"",&ai);\n\t\tsum += ai-1;\n\t\tif(sum%2==1){\n\t\t\tprintf(""1\\n"");\n\t\t}else{\n\t\t\tprintf(""2\\n"");\n\t\t}\n\t}\n}']","['games', 'math']",1100
https://codeforces.com//contest/1268/problem/E,E. Happy Cactus,You are given a cactus graph in this graph each edge lies on at most one simple cycle It is given as m edges a i b i weight of i th edge is i Let s call a path in cactus if the weights of edges on this path are increasing Let s call a pair of vertices u v if there exists an increasing path that starts in u and ends in v For each vertex u find the number of other vertices v such that pair u v is happy ,"['/**\n *    author:  tourist\n *    created: 21.12.2019 15:33:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector<vector<int>> find_cycles(const graph<T> &g, int bound_cnt = 1 << 30, int bound_size = 1 << 30) {\n  vector<int> was(g.n, -1);\n  vector<int> st;\n  vector<vector<int>> cycles;\n  int total_size = 0;\n  function<void(int, int)> dfs = [&](int v, int pe) {\n    if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n      return;\n    }\n    was[v] = (int) st.size();\n    for (int id : g.g[v]) {\n      if (id == pe) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ v;\n      if (was[to] >= 0) {\n        vector<int> cycle(1, id);\n        for (int j = was[to]; j < (int) st.size(); j++) {\n          cycle.push_back(st[j]);\n        }\n        cycles.push_back(cycle);\n        total_size += (int) cycle.size();\n        if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n          return;\n        }\n        continue;\n      }\n      if (was[to] == -1) {\n        st.push_back(id);\n        dfs(to, id);\n        st.pop_back();\n      }\n    }\n    was[v] = -2;\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (was[i] == -1) {\n      dfs(i, -1);\n    }\n  }\n  return cycles;\n  // cycles are given by edge ids, all cycles are simple\n  // breaks after getting bound_cnt cycles or total_size >= bound_size\n  // digraph: finds at least one cycle in every connected component (if not broken)\n  // undigraph: finds cycle basis\n}\n\ntemplate <typename T>\nvector<int> edges_to_vertices(const graph<T> &g, const vector<int> &edge_cycle) {\n  int sz = (int) edge_cycle.size();\n  vector<int> vertex_cycle;\n  if (sz <= 2) {\n    vertex_cycle.push_back(g.edges[edge_cycle[0]].from);\n    if (sz == 2) {\n      vertex_cycle.push_back(g.edges[edge_cycle[0]].to);\n    }\n  } else {\n    for (int i = 0; i < sz; i++) {\n      int j = (i + 1) % sz;\n      auto &e = g.edges[edge_cycle[i]];\n      auto &other = g.edges[edge_cycle[j]];\n      if (other.from == e.from || other.to == e.from) {\n        vertex_cycle.push_back(e.to);\n      } else {\n        vertex_cycle.push_back(e.from);\n      }\n    }\n  }\n  return vertex_cycle;\n  // only for simple cycles!\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  undigraph<int> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  vector<vector<int>> cycles = find_cycles(g);\n  vector<vector<int>> events(m);\n  for (auto& cycle : cycles) {\n    int sz = (int) cycle.size();\n    int pos = (int) (min_element(cycle.begin(), cycle.end()) - cycle.begin());\n    rotate(cycle.begin(), cycle.begin() + pos, cycle.end());\n    pos = (int) (max_element(cycle.begin(), cycle.end()) - cycle.begin());\n    bool ok = true;\n    for (int i = 0; i < pos - 1; i++) {\n      if (cycle[i] > cycle[i + 1]) {\n        ok = false;\n        break;\n      }\n    }\n    for (int i = pos; i < sz - 1; i++) {\n      if (cycle[i] < cycle[i + 1]) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      events[cycle[pos]].push_back(cycle[0]);\n    }\n  }\n  vector<int> sub(m, 0);\n  vector<int> ans(n, 1);\n  for (int i = m - 1; i >= 0; i--) {\n    auto& e = g.edges[i];\n    int x = e.from;\n    int y = e.to;\n    int cur = ans[x] + ans[y] - sub[i];\n    ans[x] = ans[y] = cur;\n    for (int j : events[i]) {\n      sub[j] += cur;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << ans[i] - 1;\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']",['dp'],3400
https://codeforces.com//contest/1685/problem/E,E. The Ultimate LIS Problem,You are given a permutation p 1 p 2 ldots p 2n 1 of integers from 1 to 2n 1 You will have to process q updates where the i th update consists in swapping p u i p v i After each update find any cyclic shift of p with LIS le n or determine that there is no such shift Refer to the output section for details Here LIS a denotes the length of longest strictly increasing subsequence of a ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 500005;\n\nstruct ST\n{\n    int l, r;\n    ST *ch[2];\n    int lz;\n    int mn, mpl;\n} stp[maxn << 2], *root;\nvoid upd(ST *a)\n{\n    a->mn = min(a->ch[0]->mn, a->ch[1]->mn);\n    if (a->mn == a->ch[0]->mn) a->mpl = a->ch[0]->mpl;\n    else a->mpl = a->ch[1]->mpl;\n}\ninline void actlz(ST *a, int lz) {\n    a->lz += lz;\n    a->mn += lz;\n}\nvoid pushdown(ST *a) {\n    for (int i = 0; i < 2; i++)\n        actlz(a->ch[i], a->lz);\n    a->lz = 0;\n}\nint stcnt = 0;\nvoid bdtree(ST *a, int l, int r)\n{\n    a->l = l, a->r = r, a->lz = a->mn = 0, a->mpl = l;\n    if (l == r)\n        return;\n    int mid = (a->l + a->r) >> 1;\n    a->ch[0] = &stp[stcnt++];\n    a->ch[1] = &stp[stcnt++];\n    bdtree(a->ch[0], l, mid);\n    bdtree(a->ch[1], mid + 1, r);\n    upd(a);\n}\nvoid push(ST *a, int l, int r, int lz)\n{\n    if (a->l == l && a->r == r) {\n        actlz(a, lz);\n        return;\n    }\n    pushdown(a);\n    int mid = (a->l + a->r) >> 1;\n    if (r <= mid)\n        push(a->ch[0], l, r, lz);\n    else if (l > mid)\n        push(a->ch[1], l, r, lz);\n    else {\n        push(a->ch[0], l, mid, lz);\n        push(a->ch[1], mid + 1, r, lz);\n    }\n    upd(a);\n}\npi qr(ST *a, int l, int r) {\n    if (a->l == l && a->r == r)\n        return mp(a->mn, a->mpl);\n    pushdown(a);\n    int mid = (a->l + a->r) >> 1;\n    if (r <= mid)\n        return qr(a->ch[0], l, r);\n    else if (l > mid)\n        return qr(a->ch[1], l, r);\n    else\n        return min(qr(a->ch[0], l, mid), qr(a->ch[1], mid + 1, r));\n}\nint p[maxn], q[maxn]; // q : place of each\n\nint n, m;\nint md;\nint fl[maxn]; // 是否出错\nint totfl[2] = {0, 0};\nint chk(int a, int b, int c) {\n    int r = (q[b] - q[a] + n) % n;\n    int g = (q[c] - q[a] + n) % n;\n    return r < g;\n}\nvi ch[maxn];\nint ttp[maxn];\nvi ids[maxn]; // 每个点对应的需要check的\nint ccnt = 0;\nvoid push(int a, int b, int c, int tp) {\n    ccnt += 1;\n    ttp[ccnt] = tp;\n    ch[ccnt] = {a, b, c};\n    for (auto v : ch[ccnt])\n        ids[v].pb(ccnt);\n}\nvoid rec(int id) {\n    int tp = ttp[id];\n    totfl[tp] -= fl[id];\n    fl[id] = 1 ^ chk(ch[id][0], ch[id][1], ch[id][2]);\n    totfl[tp] += fl[id];\n}\nvoid upd(int id, int tp) {\n    if (p[id] == md) return ;\n    if (p[id] > md) push(root, id, n, tp);\n    else push(root, id, n, -tp);\n}\nvoid up1(int id) {\n    for (auto v : ids[id])\n        rec(v);\n}\nint cal() {\n    int pl = q[md];\n    pi cans = qr(root, 1, n); pi cc = qr(root, pl, pl);\n    if (cans.fi < cc.fi) return cans.se;\n    if (totfl[0]) return pl;\n    if (totfl[1]) return pl - 1;\n    return -1;\n}\nint main() {\n    cin >> n >> m;\n    n = 2 * n + 1;\n    root = &stp[stcnt++]; bdtree(root, 1, n);\n    md = (n + 1) / 2;\n    for (int i = 1; i <= n; i++)\n        scanf(""%d"", &p[i]), q[p[i]] = i;\n    for (int i = 1; i <= md - 3; i++)\n        push(i, i + 1, i + 2, 0);\n    push(md, 1, 2, 0);\n    for (int i = md; i <= n - 2; i++)\n        push(i, i + 1, i + 2, 1);\n    \n    for (int i = 1; i <= n; i++)\n        upd(i, 1), up1(i);\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        scanf(""%d%d"", &u, &v);\n        upd(u, -1);\n        upd(v, -1);\n        swap(p[u], p[v]);\n        int x = p[u], y = p[v]; swap(q[x], q[y]);\n        up1(x); up1(y);\n        upd(u, 1), upd(v, 1);\n        int ans = cal();\n        if (ans == n) ans = 0;\n        printf(""%d\\n"", ans);\n    }\n    return (0-0); //<3\n}']","['data structures', 'greedy']",3500
https://codeforces.com//contest/931/problem/B,B. World Cup,The last stage of Football World Cup is played using the play off system There are teams left in this stage they are enumerated from to Several rounds are held in each round the remaining teams are sorted in the order of their ids then the first in this order plays with the second the third with the fourth the fifth with the sixth and so on It is guaranteed that in each round there is even number of teams The winner of each game advances to the next round the loser is eliminated from the tournament there are no draws In the last round there is the only game with two remaining teams the round is called the Final the winner is called the champion and the tournament is over Arkady wants his two favorite teams to play in the Final Unfortunately the team ids are already determined and it may happen that it is impossible for teams to meet in the Final because they are to meet in some earlier stage if they are strong enough Determine in which round the teams with ids and can meet ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint p[1000];\n\nvoid build(int id, int l, int r) {\n\tif(l + 1 >= r) {\n\t\tp[l] = id;\n\t\treturn;\n\t}\n\tint m = (l + r)/2;\n\tbuild(2*id, l, m);\n\tbuild(2*id + 1, m, r);\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < 300; ++i) {\n\t\tp[i] = i/2;\n\t}\n\tint a,b;\n\tcin >> a >> b;\n\t--a;\n\t--b;\n\tbuild(1, 0, n);\n\tint r = 0;\n\tint xa = p[a];\n\tint xb = p[b];\n\twhile(xa != xb) {\n\t\txa /= 2;\n\t\txb /= 2;\n\t\t++r;\n\t}\n\tif((1<<r) == n) cout << ""Final!"" << endl;\n\telse cout << r << endl;\n}\n']","['constructive algorithms', 'implementation']",1200
https://codeforces.com//contest/1936/problem/E,E. Yet Yet Another Permutation Problem,You are given a permutation p of length n Please count the number of permutations q of length n which satisfy the following for each 1 le i n max q 1 ldots q i neq max p 1 ldots p i Since the answer may be large output the answer modulo 998 244 353 ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int >\n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\n#define pb emplace_back\nusing namespace std;\nconst int mod = 998244353, _G = 3, N = (1 << 21), inv2 = (mod + 1) / 2;\n#define add(a, b) (a + b >= mod ? a + b - mod : a + b)\n#define dec(a, b) (a < b ? a - b + mod : a - b)\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N + 1], ifac[N + 1], inv[N + 1];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) inv[mod % i] * (mod - mod / i) % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n}\nint C(int x, int y) {\n\treturn y < 0 || x < y ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\ninline int sgn(int x) {\n\treturn (x & 1) ? mod - 1 : 1;\n}\nint rt[N], Lim;\nvoid Pinit(int x) {\n\tfor(Lim = 1; Lim <= x; Lim <<= 1) ;\n\tfor(int i = 1; i < Lim; i <<= 1) {\n\t\tint sG = qpow (_G, (mod - 1) / (i << 1));\n\t\trt[i] = 1;\n\t\tL(j, i + 1, i * 2 - 1) rt[j] = (ll) rt[j - 1] * sG % mod;\n\t}\n}\nstruct poly {\n\tvector<int> a;\n\tint size() { return sz(a); }\n\tint & operator [] (int x) { return a[x]; }\n\tint v(int x) { return x < 0 || x >= sz(a) ? 0 : a[x]; }\n\tvoid clear() { vector<int> ().swap(a); }\n\tvoid rs(int x = 0) { a.resize(x); }\n\tpoly (int n = 0) { rs(n); }\n\tpoly (vector<int> o) { a = o; }\n\tpoly (const poly &o) { a = o.a; }\n\tpoly Rs(int x = 0) { vi res = a; res.resize(x); return res; }\n\tinline void dif() {\n\t\tint n = sz(a);\n\t\tfor (int l = n >> 1; l >= 1; l >>= 1) \n\t\t\tfor(int j = 0; j < n; j += l << 1) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint x = a[j + k], y = a[j + k + l];\n\t\t\t\t\ta[j + k] = add(x, y);\n\t\t\t\t\ta[j + k + l] = (ll) * w * dec(x, y) % mod;\n\t\t\t\t}\n\t}\n\tvoid dit () {\n\t\tint n = sz(a);\n\t\tfor(int i = 2; i <= n; i <<= 1) \n\t\t\tfor(int j = 0, l = (i >> 1); j < n; j += i) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint pa = a[j + k], pb = (ll) a[j + k + l] * *w % mod;\n\t\t\t\t\ta[j + k] = add(pa, pb), a[j + k + l] = dec(pa, pb);\n\t\t\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tfor(int i = 0, iv = qpow(n); i < n; i++) a[i] = (ll) a[i] * iv % mod;\n\t} \n\tfriend poly operator * (poly aa, poly bb) {\n\t\tif(!sz(aa) || !sz(bb)) return {};\n\t\tint lim, all = sz(aa) + sz(bb) - 1;\n\t\tfor(lim = 1; lim < all; lim <<= 1);\n\t\taa.rs(lim), bb.rs(lim), aa.dif(), bb.dif();\n\t\tL(i, 0, lim - 1) aa[i] = (ll) aa[i] * bb[i] % mod;\n\t\taa.dit(), aa.a.resize(all);\n\t\treturn aa;\n\t}\n\tpoly Inv() {\n\t\tpoly res, f, g;\n\t\tres.rs(1), res[0] = qpow(a[0]);\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = m << 1, f = res, g.rs(pn), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (*this).v(i);\n\t\t\tf.dif(), g.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit();\n\t\t\tfor(int i = 0; i < m; i++) g[i] = 0;\n\t\t\tg.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit(), res.rs(pn);\n\t\t\tfor(int i = m; i < min(pn, sz(a)); i++) res[i] = (mod - g[i]) % mod;\n\t\t} \n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly Shift (int x) {\n\t\tpoly zm (sz(a) + x);\n\t\tL(i, max(-x, 0), sz(a) - 1) zm[i + x] = a[i];\n\t\treturn zm; \n\t}\n\tfriend poly operator * (poly aa, int bb) {\n\t\tpoly res(sz(aa));\n\t\tL(i, 0, sz(aa) - 1) res[i] = (ll) aa[i] * bb % mod;\n\t\treturn res;\n\t}\n\tfriend poly operator + (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = add(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tfriend poly operator - (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = dec(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tpoly & operator += (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator -= (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += mod - o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator *= (poly o) {\n\t\treturn (*this) = (*this) * o;\n\t}\n\tpoly Integ() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) + 1);\n\t\tL(i, 1, sz(a)) res[i] = (ll) a[i - 1] * inv[i] % mod;\n\t\treturn res;\n\t}\n\tpoly Deriv() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) - 1); \n\t\tL(i, 1, sz(a) - 1) res[i - 1] = (ll) a[i] * i % mod;\n\t\treturn res;\n\t}\n\tpoly Ln() {\n\t\tpoly g = ((*this).Inv() * (*this).Deriv()).Integ();\n\t\treturn g.rs(sz(a)), g;\n\t}\n\tpoly Exp() {\n\t\tpoly res(1), f; \n\t\tres[0] = 1;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf -= res.Ln(), (f[0] += 1) %= mod, res *= f, res.rs(pn); \n\t\t}\n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly pow(int x, int rx = -1) { // x : the power % mod; rx : the power % (mod - 1)\n\t\tif(rx == -1) rx = x;\n\t\tint cnt = 0;\n\t\twhile (a[cnt] == 0 && cnt < sz(a)) cnt += 1;\n\t\t\n\t\tpoly res = (*this);\n\t\tL(i, cnt, sz(a) - 1) res[i - cnt] = res[i];\n\t\tL(i, sz(a) - cnt, sz(a) - 1) res[i] = 0;\n\t\tint c = res[0], w = qpow (res[0]);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * w % mod;\n\t\tres = res.Ln();\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * x % mod;\n\t\tres = res.Exp();\n\t\tc = qpow (c, rx);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * c % mod;\n\t\t\n\t\tif((ll) cnt * x > sz(a)) L(i, 0, sz(a) - 1) res[i] = 0;\n\t\telse if(cnt) {\n\t\t\tR(i, sz(a) - cnt * x - 1, 0) res[i + cnt * x] = res[i];\n\t\t\tL(i, 0, cnt * x - 1) res[i] = 0; \n\t\t}\n\t\treturn res;\n\t}\n\tpoly sqrt(int rt = 1) {\n\t\tpoly res(1), f; \n\t\tres[0] = rt;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf += res * res, f.rs(pn), res.rs(pn), res = f * res.Inv(), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) res[i] = (ll) res[i] * inv2 % mod;\n\t\t} \n\t\treturn res;\n\t}\n\tvoid Rev() {\n\t\treverse(a.begin(), a.end());\n\t}\n\tfriend pair < poly, poly > div (poly f, poly g) { /* f / g = first, f % g = second */\n\t\tf.rs(max(sz(f), sz(g))), f.Rev(), g.Rev();\n\t\tint n = sz(f), m = sz(g);\n\t\tpoly A = g.Rs(n - m + 1).Inv(), t;\n\t\tA *= f.Rs(n - m + 1), A.rs(n - m + 1), A.Rev(), g.Rev(), f.Rev(), t = f - A * g, t.rs(m - 1);\n\t\treturn make_pair(A, t);\n\t} \n} ;\n\nint n, p[N];\nint dp[N];\nint f[N];\ninline int A(int x, int y) {\n\treturn (ll)C(x, y) * fac[y] % mod;\n}\nint sums[N], r2[N], r3[N];\nvoid solve(int l, int r) {\n\tif(l == r) {\n\t\tint i = l;\n\t\tif(p[i] == p[i - 1]) {\n\t\t\t(dp[i] += (ll) sums[i - 1] * (p[i] - i + 1) % mod) %= mod;\n\t\t\t(dp[i] += (ll) r3[i - 1] % mod) %= mod;\n\t\t\t(dp[i] += (ll) r2[i - 1] * (mod - i) % mod) %= mod;\n\t\t} \n\t\tif(i < n) dp[i] = (mod - dp[i]) % mod;\n\t\tsums[i] = dp[i];\n\t\tr2[i] = dp[i], r3[i] = (ll) dp[i] * i % mod;\n\t\tif(p[i] == p[i - 1]) {\n\t\t\t(sums[i] += (ll)sums[i - 1] * (p[i] - i + 1) % mod) %= mod;\t\n\t\t\t(r2[i] += (ll)r2[i - 1] * (p[i] - i) % mod) %= mod;\t\n\t\t\t(r3[i] += (ll)r3[i - 1] * (p[i] - i) % mod) %= mod;\t\n\t\t} \n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tsolve(l, mid);\n\tL(cas, 0, 1) {\n\tint vl = p[mid + 1] - mid, vr = p[r] - l;\n\tpoly ls(mid - l + 1);\n\tpoly rs(vr - vl + 1);\n\tL(i, vl, vr) {\n\t\tint val = (i == 0 ? 0 : fac[i - 1]);\n\t\t(rs[i - vl] += val) %= mod;\n\t}\n\tL(i, l, mid)\n\t\tls[i - l] = cas ? (ll) dp[i] * i % mod : dp[i];\n\tls *= rs;\n\n\tif(cas == 0) {\n\tL(i, mid + 1, r)\n\t\t(dp[i] += (ll) i * ls[p[i] - l - vl] % mod * ifac[p[i] - i] % mod) %= mod;\n\t} else {\n\tL(i, mid + 1, r)\n\t\t(dp[i] += mod - (ll) ls[p[i] - l - vl] * ifac[p[i] - i] % mod) %= mod;\n\t}\n\t}\n\tsolve(mid + 1, r);\n}\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> p[i];\n\t\tp[i] = max(p[i], p[i - 1]);\n\t}\n\tL(i, 1, n) dp[i] = (ll) i * A(p[i] - 1, i - 1) % mod;\n\tL(i, 0, n) sums[i] = 0, r2[i] = 0, r3[i] = 0;\n\tsolve(1, n);\n\tcout << dp[n] << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tinit(1 << 20);\n\tPinit(1 << 20);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n} ""]","['divide and conquer', 'fft', 'math']",3400
https://codeforces.com//contest/1433/problem/B,B. Yet Another Bookshelf,There is a bookshelf which can fit n books The i th position of bookshelf is a i 1 if there is a book on this position and a i 0 otherwise It is guaranteed that there is on the bookshelf In one move you can choose some contiguous segment l r consisting of books i e for each i from l to r the condition a i 1 holds and Shift it to the right by 1 move the book at index i to i 1 for all l le i le r This move can be done only if r 1 le n and there is no book at the position r 1 Shift it to the left by 1 move the book at index i to i 1 for all l le i le r This move can be done only if l 1 ge 1 and there is no book at the position l 1 Your task is to find the number of moves required to collect all the books on the shelf as a consecutive segment i e the segment without any gaps For example for a 0 0 1 0 1 there is a gap between books a 4 0 when a 3 1 and a 5 1 for a 1 1 0 there are no gaps between books and for a 0 0 0 there are also no gaps between books You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define forinc(i,a,b) for(int i=a;i<=b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forv(i,x) for(auto &i:x)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r)\n{\n    return l+rng()%(r-l+1);\n}\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c==\'-\');for(;isdigit(c);c=getchar()) x=x*10+c-\'0\';n?-x:x;})\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define batbit(i,x) (x|(1ll<<i))\n#define getbit(i,x) ((x>>i)&1)\n\nint a[500],s[500];\n\nmain()\n{\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        int tmp=0,kq=0,mi=1e9,ma=0;\n        forinc(i,1,n)\n        {\n            cin >> a[i];\n            if(a[i]==0) s[i]=s[i-1]+1;\n            else s[i]=s[i-1];\n        }\n        forinc(i,1,n) if(a[i])\n        {\n            mi=min(mi,i);\n            ma=max(ma,i);\n        }\n        cout << s[ma]-s[mi-1] << ""\\n"";\n    }\n}\n']","['greedy', 'implementation']",800
https://codeforces.com//contest/168/problem/B,B. Wizards and Minimal Spell,Let s dive into one of the most interesting areas of magic writing spells Learning this exciting but challenging science is very troublesome so now you will not learn the magic words but only get to know the basic rules of writing spells Each spell consists of several lines The line whose first non space character is character is an and it is responsible for spell power The remaining lines are common and determine the effect of the spell You came across the text of some spell Spell was too long so you cannot understand its meaning So you want to make it as short as possible without changing the meaning The only way to shorten a spell that you know is the removal of some spaces and line breaks We know that when it comes to texts of spells the spaces carry meaning only in the amplifying lines so we should remove all spaces in other lines Newlines also do not matter unless any of the two separated lines is amplifying Thus if two consecutive lines are not amplifying they need to be joined into one i e we should concatenate the second line to the first one Removing spaces in amplifying lines and concatenating the amplifying lines to anything is forbidden Note that empty lines must be processed just like all the others they must be joined to the adjacent non amplifying lines or preserved in the output if they are surrounded with amplifying lines on both sides i e the line above it if there is one is amplifying and the line below it if there is one is amplifying too For now those are the only instructions for removing unnecessary characters that you have to follow oh yes a newline is a character too The input contains the text of the spell which should be reduced Remove the extra characters and print the result to the output ,"['#include<iostream>\n#include<string>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nint main() {\n\tstring keluar = """",s;\n\tbool last = false;\n\twhile (getline(cin,s)) {\n\t\tbool temu = false;\n\t\tfor (int i=0;i<s.length();++i) {\n\t\t\tif (s[i] != \' \') {\n\t\t\t\ttemu = (s[i] == \'#\');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (temu) {\n\t\t\tif (last) cout<<keluar<<endl;\n\t\t\tkeluar = """";\n\t\t\tcout<<s<<endl;\n\t\t\tlast = false;\n\t\t} else {\n\t\t\tlast = true;\n\t\t\tstring hasil = """";\n\t\t\tfor (int i=0;i<s.length();++i) {\n\t\t\t\tif (s[i] != \' \') hasil += s[i];\n\t\t\t}\n\t\t\tkeluar += hasil;\n\t\t}\n\t\t\n\t}\n\t\n\tif (last) cout<<keluar<<endl;\n\treturn 0;\n}']","['implementation', 'strings']",1700
https://codeforces.com//contest/1613/problem/D,D. MEX Sequences,Let s call a sequence of integers x 1 x 2 dots x k if for all i 1 le i le k x i operatorname MEX x 1 x 2 dots x i le 1 holds Where operatorname MEX x 1 dots x k is the minimum non negative integer that doesn t belong to the set x 1 dots x k For example operatorname MEX 1 0 1 3 2 and operatorname MEX 2 1 5 0 You are given an array a consisting of n non negative integers Calculate the number of non empty subsequences of a given array The number of subsequences can be very large so print it modulo 998244353 Note a subsequence of an array a is a sequence a i 1 a i 2 dots a i m meeting the constraints 1 le i 1 i 2 dots i m le n If two different ways to choose the sequence of indices i 1 i 2 dots i m yield the same subsequence the resulting subsequence should be counted twice i e two subsequences are different if their sequences of indices i 1 i 2 dots i m are not the same ,"['\n#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define imie(x) #x << "": "" << x\n\nusing namespace std;\n\ntemplate <uint32_t base>\nstruct Montgomery {\n\tusing i32 = int32_t;\n\tusing u32 = uint32_t;\n\tusing u64 = uint64_t;\n\n\tstatic constexpr u32 mod() {\n\t\treturn base;\n\t}\n\n\tstatic constexpr u32 np = []() {\n\t\tu32 x = base;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tx *= 2u - base * x;\n\t\t}\n\t\treturn -x;\n\t}();\n\tstatic constexpr u32 r2 = -(u64)(base) % base;\n\n\tstatic_assert(base < (1u << 30));\n\tstatic_assert(base * np + 1 == 0);\n\n\tstatic u32 reduce(u64 x) {\n\t\treturn (x + (u64)((u32)x * np) * base) >> 32;\n\t}\n\n\tu32 x;\n\tMontgomery(): x(0) {}\n\tconstexpr Montgomery(long long y): x(y ? reduce((u64)(y % base + base) * r2) : 0) {}\n\n\tMontgomery& operator +=(const Montgomery& ot) {\n\t\tif ((i32)(x += ot.x - 2 * base) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator -=(const Montgomery& ot) {\n\t\tif ((i32)(x -= ot.x) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator *=(const Montgomery& ot) {\n\t\tx = reduce((u64)x * ot.x);\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator /=(const Montgomery& ot) {\n\t\treturn *this *= ot.inverse();\n\t}\n\n\tfriend Montgomery operator +(Montgomery a, const Montgomery& b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator -(Montgomery a, const Montgomery& b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator *(Montgomery a, const Montgomery& b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator /(Montgomery a, const Montgomery& b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\n\tMontgomery operator -() const {\n\t\treturn Montgomery() - *this;\n\t}\n\n\tu32 get() const {\n\t\tu32 res = reduce(x);\n\t\treturn res < base ? res : res - base;\n\t}\n\n\tu32 operator ()() const {\n\t\treturn get();\n\t}\n\n\tMontgomery inverse() const {\n\t\treturn pow(base - 2);\n\t}\n\n\tMontgomery pow(int64_t p) const {\n\t\tif (p < 0) {\n\t\t\treturn pow(-p).inverse();\n\t\t}\n\t\tMontgomery res = 1;\n\t\tMontgomery a = *this;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\ta *= a;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend istream& operator >>(istream& istr, Montgomery& m) {\n\t\tlong long x;\n\t\tistr >> x;\n\t\tm = Montgomery(x);\n\t\treturn istr;\n\t}\n\n\tfriend ostream& operator <<(ostream& ostr, const Montgomery& m) {\n\t\treturn ostr << m.get();\n\t}\n\n\tbool operator ==(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) == (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\tbool operator !=(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) != (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\texplicit operator int64_t() const {\n\t\treturn x;\n\t}\n\n\texplicit operator bool() const {\n\t\treturn x;\n\t}\n};\n\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nconst int mod = 998\'244\'353;\nusing Mint = Montgomery<mod>;\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tvector<Mint> f(n + 1);\n\tvector<Mint> g(n + 1);\n\tMint ans = 0;\n\tfor (int x : a) {\n\t\tMint good = f[x];\n\t\tif (x) {\n\t\t\tgood += f[x - 1];\n\t\t} else {\n\t\t\tgood += 1;\n\t\t}\n\n\t\tMint around_smaller = 0, around_larger = 0;\n\t\taround_smaller += x >= 2 ? f[x - 2] : 0;\n\t\taround_smaller += x >= 1 ? g[x - 1] : 0;\n\t\tif (x == 1) {\n\t\t\taround_smaller += 1;\n\t\t}\n\t\taround_larger += x < n ? g[x + 1] : 0;\n\t\t// cerr << x << "": "" << good << "" "" << around_smaller << "" "" << around_larger << ""\\n"";\n\n\t\tans += good + around_larger + around_smaller;\n\n\t\tf[x] += good;\n\t\tif (x > 0) {\n\t\t\tg[x - 1] += around_smaller;\n\t\t}\n\t\tif (x < n) {\n\t\t\tg[x + 1] += around_larger;\n\t\t}\n\t}\n\n\tcout << ans << ""\\n"";\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n']","['dp', 'math']",1900
https://codeforces.com//contest/1158/problem/E,E. Strange device,Vasya enjoys solving quizzes He found a strange device and wants to know how it works This device encrypted with the tree connected undirected graph without cycles with n vertices numbered with integers from 1 to n To solve this quiz you should guess this tree Fortunately this device can make one operation using which you should guess the cipher You can give the device an array d 1 d 2 ldots d n of non negative integers On the device there are n lamps i th of them is connected with i th vertex of the tree For all i the light will turn on the i th lamp if there exist such vertex of the tree with number j neq i that dist i j leq d j Let s define dist i j as the distance between vertices i and j in tree or number of edges on the simple path between vertices i and j Vasya wants to solve this quiz using leq 80 operations with the device and guess the tree Help him ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint N;\n\nmap<vector<int>, vector<bool>> memo;\n\nvector<bool> Ask(const vector<int> &dists) {\n  if (count(ALL(dists), 0) == N) { return vector<bool>(N); }\n  auto iter = memo.find(dists);\n  if (iter != memo.end()) { return iter->nd; }\n\n  cout << ""?"";\n  for (int d : dists) { cout << "" "" << min(d, N - 1); }\n  cout << endl;\n  string ans;\n  cin >> ans;\n\n  vector<bool> ret(N);\n  for (int i = 0; i < N; ++i) {\n    ret[i] = ans[i] == \'1\';\n  }\n  return memo[dists] = ret;\n}\n\nvoid Answer(const vector<PII> &adj) {\n  cout << ""!"" << endl;\n  for (auto [u, v] : adj) {\n    cout << u + 1 << "" "" << v + 1 << endl;\n  }\n}\n\nint GetMaxH() {\n  vector<int> query(N);\n  int minh = 0, maxh = N;\n  while (maxh - minh > 1) {\n    const int mid = (minh + maxh) / 2;\n    query[0] = mid;\n    auto ans = Ask(query);\n    if (count(ALL(ans), true) == N - 1) {\n      maxh = mid;\n    } else {\n      minh = mid;\n    }\n  }\n  return maxh;\n}\n\nint32_t main() {\n  cin >> N;\n\n  const int maxh = GetMaxH();\n  debug(maxh);\n\n  VI heights(N);\n\n  VI cur_ask{0};\n\n  int cur_span = 1;\n  while (cur_span * 2 <= maxh) { cur_span *= 2; }\n\n  while (cur_span >= 1) {\n    VI next_ask;\n    debug(cur_span, cur_ask);\n    for (bool odd : {false, true}) {\n      VI query(N);\n      VI which;\n      for (int x : cur_ask) {\n        if (!!(heights[x] & (cur_span * 2)) == odd) {\n          query[x] = cur_span;\n          which.PB(x);\n        }\n      }\n\n      auto fst_ans = Ask(query);\n      for (int x : which) {\n        query[x] = cur_span - 1;\n      }\n      auto snd_ans = Ask(query);\n      for (int x : which) { fst_ans[x] = snd_ans[x] = true; }\n\n      for (int i = 0; i < N; ++i) {\n        if (!!(heights[i] & (cur_span * 2)) == odd) {\n          if (!snd_ans[i]) { heights[i] += cur_span; }\n          if (fst_ans[i] && !snd_ans[i]) {\n            next_ask.PB(i);\n          }\n        }\n      }\n    }\n\n    cur_span /= 2;\n    for (int v : next_ask) { cur_ask.PB(v); }\n  }\n\n  debug(heights);\n\n  vector<PII> edges;\n\n  for (int rem = 0; rem < 3; ++rem) {\n    VI from, to;\n    for (int i = 0; i < N; ++i) {\n      if (heights[i] % 3 == rem) {\n        from.PB(i);\n      }\n      if (heights[i] % 3 == (rem + 1) % 3) {\n        to.PB(i);\n      }\n    }\n\n    const int S = SZ(from);\n    const int T = SZ(to);\n    vector<int> to_mapping(T);\n\n    debug(from, to);\n\n    for (int b = 1; b < S; b *= 2) {\n      debug(b);\n      vector<int> query(N);\n      for (int i = 0; i < S; ++i) {\n        if (i & b) { query[from[i]] = 1; }\n      }\n      auto ans = Ask(query);\n      for (int i = 0; i < T; ++i) {\n        if (ans[to[i]]) { to_mapping[i] += b; }\n      }\n    }\n\n    for (int i = 0; i < T; ++i) {\n      if (to[i] == 0) { continue; }\n      edges.emplace_back(from[to_mapping[i]], to[i]);\n    }\n  }\n\n  Answer(edges);\n\n}\n\n']","['binary search', 'interactive', 'math', 'trees']",3400
https://codeforces.com//contest/1316/problem/D,D. Nash Matrix,Nash designed an interesting yet simple board game where a player is simply required to follow instructions written on the cell where the player currently stands This board game is played on the n times n board Rows and columns of this board are numbered from 1 to n The cell on the intersection of the r th row and c th column is denoted by r c Some cells on the board are called On each cell of the board there is written one of the following 5 characters U D L R or X instructions for the player Suppose that the current cell is r c If the character is R the player should move to the right cell r c 1 for L the player should move to the left cell r c 1 for U the player should move to the top cell r 1 c for D the player should move to the bottom cell r 1 c Finally if the character in the cell is X then this cell is the The player should remain in this cell the game for him isn t very interesting from now on It is guaranteed that the characters are written in a way that the player will never have to step outside of the board no matter at which cell he starts As a player starts from a cell he moves according to the character in the current cell The player keeps moving until he lands in a blocked zone It is also possible that the player will keep moving infinitely long For every of the n 2 cells of the board Alice your friend wants to know how will the game go if the player starts in this cell For each starting cell of the board she writes down the cell that the player stops at or that the player never stops at all She gives you the information she has written for each cell r c she wrote a pair x y meaning if a player had started at r c he would end up at cell x y or a pair 1 1 meaning if a player had started at r c he would keep moving infinitely long and would never enter the blocked zone It might be possible that Alice is trying to fool you and there s no possible grid that satisfies all the constraints Alice gave you For the given information Alice provided you you are required to decipher a possible board or to determine that such a board doesn t exist If there exist several different boards that satisfy the provided information you can find any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\npair<int, int> a[1005][1005];\nchar mp[1005][1005];\npair<int, int> stk[2000005];\nbool mark[1005][1005];\nint n, top;\nchar getch(int x) {\n\tif (x == 0) return \'L\';\n\tif (x == 1) return \'R\';\n\tif (x == 2) return \'U\';\n\treturn \'D\';\n}\n\nvoid dfs(int x, int y) {\n\tmark[x][y] = true;\n\tfor (int i = 0; i < 4; ++ i) {\n\t\tint nx = x + d[i][0];\n\t\tint ny = y + d[i][1];\n\t\tif (nx < 1 || nx > n || ny < 1 || ny > n) continue;\n\t\tif (a[x][y] != a[nx][ny]) continue;\n\t\tif (mark[nx][ny]) continue;\n\t\tmp[nx][ny] = getch(i);\n\t\tdfs(nx, ny);\n\t}\n}\n\nint main( ) {\n\tbool ok = false;\n\tint x, y;\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tscanf(""%d %d"", &x, &y);\n\t\t\tif (make_pair(x, y) == make_pair(i, j)) {\n\t\t\t\tstk[++ top] = make_pair(i, j);\n\t\t\t}\n\t\t\ta[i][j] = make_pair(x, y);\n\t\t}\n\tfor (int i = 1; i <= top; i ++) {\n\t\tdfs(stk[i].first, stk[i].second);\n\t\tmp[stk[i].first][stk[i].second] = \'X\';\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (a[i][j] != make_pair(-1, -1)) continue;\n\t\t\tint idx = -1, idy = -1;\n\t\t\tif (a[i + 1][j] == make_pair(-1, -1)) {\n\t\t\t\tidx = i + 1;\n\t\t\t\tidy = j;\n\t\t\t\tmp[i][j] = \'D\';\n\t\t\t\tmp[i + 1][j] = \'U\';\n\t\t\t}\n\t\t\tif (a[i - 1][j] == make_pair(-1, -1)) {\n\t\t\t\tidx = i - 1;\n\t\t\t\tidy = j;\n\t\t\t\tmp[i][j] = \'U\';\n\t\t\t\tmp[i - 1][j] = \'D\';\n\t\t\t}\n\t\t\tif (a[i][j - 1] == make_pair(-1, -1)) {\n\t\t\t\tidx = i;\n\t\t\t\tidy = j - 1;\n\t\t\t\tmp[i][j] = \'L\';\n\t\t\t\tmp[i][j - 1] = \'R\';\n\t\t\t}\n\t\t\tif (a[i][j + 1] == make_pair(-1, -1)) {\n\t\t\t\tidx = i;\n\t\t\t\tidy = j + 1;\n\t\t\t\tmp[i][j] = \'R\';\n\t\t\t\tmp[i][j + 1] = \'L\';\n\t\t\t}\n\t\t\tif (idx == -1 && idy == -1) continue;\n\t\t\tdfs(i, j);\n\t\t\tdfs(idx, idy);\n\t\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (!mark[i][j]) ok = true;\n\tif (ok) printf(""INVALID\\n"");\n\telse {\n\t\tprintf(""VALID\\n"");\n\t\tfor (int i = 1; i <= n; puts(""""), i ++)\n\t\t\tfor (int j = 1; j <= n; j ++)\n\t\t\t\tprintf(""%c"", mp[i][j]);\n\t}\t\n\treturn 0;\n}\n\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'implementation']",2000
https://codeforces.com//contest/547/problem/A,A. Mike and Frog,Mike has a frog and a flower His frog is named Xaniar and his flower is named Abol Initially at time height of Xaniar is and height of Abol is Each second Mike waters Abol and Xaniar So if height of Xaniar is and height of Abol is after one second height of Xaniar will become and height of Abol will become where and are some integer numbers and denotes the remainder of modulo Mike is a competitive programmer fan He wants to know the minimum time it takes until height of Xania is and height of Abol is Mike has asked you for your help Calculate the minimum time or say it will never happen ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n// template end here\nint m;\nvoid get(LL h,LL a,LL x,LL y,LL &v1,LL &v2){\n    v1=-1;\n    v2=-1;\n    int tt=0;\n    REP(i,m*5){\n        h=(x*h+y)%m;\n        if(h==a){\n            if(!tt){\n                v1=i+1;\n            }\n            else if(tt==1){\n                v2=i+1;\n            }\n            else break;\n            tt++;\n        }\n    }\n}\nint ha[SIZE];\nint main(){\n    RI(m);\n    DRII(h1,a1);\n    DRII(x1,y1);\n    DRII(h2,a2);\n    DRII(x2,y2);\n    LL v1,v2,u1,u2;\n    get(h1,a1,x1,y1,v1,v2);\n    get(h2,a2,x2,y2,u1,u2);\n    if(v1==-1||u1==-1){\n        puts(""-1"");\n    }\n    else{\n        if(u2==-1){\n            swap(v1,u1);\n            swap(v2,u2);\n        }\n        if(v2==-1){\n            if(u2==-1){\n                if(v1==u1)cout<<v1<<endl;\n                else cout<<-1<<endl;\n            }\n            else{\n                LL now=u1;\n                REP(k,m*5){\n                    if(now==v1){\n                        cout<<now<<endl;\n                        return 0;\n                    }\n                    now+=u2-u1;\n                }\n                cout<<-1<<endl;\n                return 0;\n            }\n        }\n        else{\n            LL now=u1;\n            REP(k,m*5){\n                if(now>=v1&&(now-v1)%(v2-v1)==0){\n                    cout<<now<<endl;\n                    return 0;\n                }\n                now+=u2-u1;\n            }\n            cout<<-1<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n']","['brute force', 'greedy', 'implementation', 'math']",2200
https://codeforces.com//contest/1701/problem/A,A. Grass Field,There is a field of size 2 times 2 Each cell of this field can either contain grass or be empty The value a i j is 1 if the cell i j contains grass or 0 otherwise In one move you can choose and and cut all the grass in this row and this column In other words you choose the row x and the column y then you cut the grass in all cells a x i and all cells a i y for all i from 1 to 2 After you cut the grass from a cell it becomes empty i e its value is replaced by 0 Your task is to find the minimum number of moves required to cut the grass in all non empty cells of the field i e make all a i j zeros You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:34:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a + b + c + d == 0) {\n      cout << 0 << \'\\n\';\n    } else {\n      if (a + b + c + d == 4) {\n        cout << 2 << \'\\n\';\n      } else {\n        cout << 1 << \'\\n\';\n      }\n    }\n  }\n  return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1782/problem/D,D. Many Perfect Squares,You are given a set a 1 a 2 ldots a n of distinct positive integers We define the of an integer x as the number of perfect squares among the numbers a 1 x a 2 x ldots a n x Find the maximum squareness among all integers x between 0 and 10 18 inclusive Perfect squares are integers of the form t 2 where t is a non negative integer The smallest perfect squares are 0 1 4 9 16 ldots ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7, S = sqrt(1e9) + 7;\nint n, ns = 1;\nll a[N];\nvoid check(ll k) {\n\t\n}\nint p[N], tot; \nbool Prime[N];\nvoid Main() {\n\tmap < ll, ll > mp;\n\tcin >> n;\n\tL(i, 1, n) \n\t\tcin >> a[i];\n\tsort(a + 1, a + n + 1);\n\tns = 1;\n\tL(i, 1, n) \n\t\tL(j, i + 1, n) {\n\t\t\tll dec = a[j] - a[i];\n\t\t\tL(v, 1, sqrt(dec)) if(dec % v == 0) {\n\t\t\t\tll a = v, b = dec / v;\n\t\t\t\tif(a % 2 == b % 2) {\n\t\t\t\t\tll x = (b - a) / 2, y = (a + b) / 2;\n\t\t\t\t\tmp[x * x - ::a[i]] |= (1LL << i) | (1LL << j);\n//\t\t\t\t\tcout << x * x - ::a[i] << \' \' << y * y - ::a[j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(auto u : mp) if(u.first >= 0) {\n//\t\tcout << u.first << "" : "" << u.second << endl; \n\t\tns = max(ns, __builtin_popcountll(u.second));\n\t}\n\tcout << ns << \'\\n\';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tL(i, 2, S) \n\t\tif(!Prime[i]) \n\t\t\tfor(int j = 2 * i; j <= S; j += i) \n\t\t\t\tPrime[j] = 1;\n\tL(i, 2, S) if(!Prime[i]) p[++tot] = i;\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ']","['brute force', 'dp', 'math', 'number theory']",1800
https://codeforces.com//contest/620/problem/B,B. Grandfather Dovlet’s calculator,Once Max found an electronic calculator from his grandfather Dovlet s chest He noticed that the numbers were written with seven segment indicators https en wikipedia org wiki Seven segment display Max starts to type all the values from to After typing each number Max resets the calculator Find the total number of segments printed on the calculator For example if and then at first the calculator will print segments then segments and at last it will print segments So the total number of printed segments is ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int cnt[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\n\nint main() {\n  int a, b;\n  scanf(""%d %d"", &a, &b);\n  int ans = 0;\n  for (int i = a; i <= b; i++) {\n    int x = i;\n    while (x > 0) {\n      ans += cnt[x % 10];\n      x /= 10;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/1132/problem/B,B. Discounts,You came to a local shop and want to buy some chocolate bars There are n bars in the shop i th of them costs a i coins and you want to buy all of them You have m different coupons that allow you to buy chocolate bars i th coupon allows you to buy q i chocolate bars while you have to pay only for the q i 1 most expensive ones so the cheapest bar of those q i bars is for free You can use only one coupon if you use coupon i you have to choose q i bars and buy them using the coupon and buy all the remaining n q i bars without any discounts To decide which coupon to choose you want to know what will be the minimum total amount of money you have to pay if you use one of the coupons optimally ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 300 * 1000 + 7;\n\nint a[MX];\nll f[MX];\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; i++) {\n        f[i] = f[i - 1] + a[i];\n    }\n    int q;\n    cin >> q;\n    for (int ii = 0; ii < q; ii++) {\n        int x;\n        cin >> x;\n        cout << f[n] - a[n - x + 1] << ""\\n"";\n        /*\n        int ptr = n;\n        ll ans = 0;\n        while (ptr >= x) {\n            ans += f[ptr] - f[ptr - x + 1];\n            ptr -= x;\n        }\n        ans += f[ptr];\n        cout << ans << ""\\n"";\n        */\n    }\n    return 0;\n}\n\n']","['greedy', 'sortings']",900
https://codeforces.com//contest/722/problem/A,A. Broken Clock,You are given a broken clock You know that it is supposed to show time in 12 or 24 hours format In 12 hours format hours change from to while in 24 hours it changes from to In both formats minutes change from to You are given a time in format that is currently displayed on the broken clock Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format For example if is displayed it is enough to replace the second with in order to get that is a correct time in 24 hours format However to make correct in 12 hours format one has to change at least two digits Additionally to the first change one can replace the second with and obtain ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, H, M;\n\nint main()\n{\n    scanf(""%d%d:%d"", &N, &H, &M);\n    if(N==24)\n    {\n        if(H/10>=3)\n            H%=10;\n        if(H/10==2 && H%10>=4)\n            H%=10;\n    }\n    else\n    {\n        if(H/10>=2)\n        {\n            if(H%10==0)\n                H=H%10+10;\n            else\n                H%=10;\n        }\n        if(H/10==1 && H%10>=3)\n            H=10;\n        if(H==0)\n            H=1;\n    }\n    if(M/10>=6)\n        M%=10;\n    printf(""%02d:%02d\\n"", H, M);\n    return 0;\n}\n']","['brute force', 'implementation']",1300
https://codeforces.com//contest/101/problem/B,B. Buses,Little boy Gerald studies at school which is quite far from his house That s why he has to go there by bus every day The way from home to school is represented by a segment of a straight line the segment contains exactly bus stops All of them are numbered with integers from to in the order in which they follow from Gerald s home The bus stop by Gerald s home has number and the bus stop by the school has number There are buses running between the house and the school the th bus goes from stop to visiting all the intermediate stops in the order in which they follow on the segment Besides Gerald s no idiot and he wouldn t get off the bus until it is still possible to ride on it closer to the school obviously getting off would be completely pointless In other words Gerald can get on the th bus on any stop numbered from to inclusive but he can get off the th bus only on the bus stop Gerald can t walk between the bus stops and he also can t move in the direction from the school to the house Gerald wants to know how many ways he has to get from home to school Tell him this number Two ways are considered different if Gerald crosses some segment between the stops on different buses As the number of ways can be too much find the remainder of a division of this number by ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++) \n#define REP(i,n) FOR(i,0,n) \n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nconst int mod = 1000000007 ;\n\nint n,m;\nint s[111111];\nint t[111111];\nvi x;\nvector<pii> r;\n\nint rr[444444];\n\nvoid add(int pos,int val){\n\tpos += 222222;\n\twhile(pos){\n\t\trr[pos] += val;\n\t\tif(rr[pos]>=mod) rr[pos]-=mod;\n\t\tpos>>=1;\n\t}\n}\n\nint sum(int p1,int p2){\n\tp1 += 222222;\n\tp2 += 222222;\n\n\tint res = 0;\n\twhile(p1<=p2){\n\t\tif(p1&1){\n\t\t\tres += rr[p1];\n\t\t\tif(res>=mod) res-=mod;\n\t\t}\n\t\tif(!(p2&1)){\n\t\t\tres += rr[p2];\n\t\t\tif(res>=mod) res-=mod;\n\t\t}\n\t\tp1= (p1+1)>>1;\n\t\tp2=(p2-1)>>1;\n\t}\n\treturn res;\n}\n\nint main(){ \n#ifdef LocalHost\n\tfreopen(""input.txt"",""r"",stdin);\n//\tfreopen(""output.txt"",""w"",stdout);\n#endif\n\n\tcin>>n>>m;\n\tREP(i,m) scanf(""%d %d"",s+i,t+i),x.pb(s[i]),x.pb(t[i]);\n\tx.pb(0);\n\tx.pb(n);\n\tUN(x);\n\tREP(i,m){\n\t\ts[i] = lower_bound(x.begin(),x.end(),s[i])-x.begin();\n\t\tt[i] = lower_bound(x.begin(),x.end(),t[i])-x.begin();\n\t\tr.pb(pii(t[i],s[i]));\n\t}\n\tSORT(r);\n\t\n\tadd(0,1);\n\tREP(i,r.size())\n\t\tadd(r[i].first, sum(r[i].second, r[i].first-1));\n\tcout<<sum(x.size()-1,x.size()-1)<<endl;\n\n#ifdef LocalHost\n\tcout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n\treturn 0;\n}']","['binary search', 'data structures', 'dp']",1700
https://codeforces.com//contest/300/problem/E,E. Empire Strikes Back,In a far away galaxy there is war again The treacherous Republic made precision strikes of power on the Empire possessions To cope with the republican threat the Supreme Council decided to deal a decisive blow to the enemy forces To successfully complete the conflict the confrontation balance after the blow should be a positive integer The balance of confrontation is a number that looks like where is the power of the Imperial strike After many years of war the Empire s resources are low So to reduce the costs should be a minimum positive integer that is approved by the commanders Help the Empire find the minimum positive integer where the described fraction is a positive integer ,"[""//program 300-E\n\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint Get()\n{\n  char c;\n  while(c=getchar(),c<'0'||c>'9');\n  int X=0;\n  while(c>='0'&&c<='9')\n    {\n      X=X*10+c-48;\n      c=getchar();\n    }\n  return X;\n}\n\nint Total;\nint Prime[10000000];\nlong long Count[10000000];\n\nlong long Check(long long X)\n{\n  for(int i=0;i<Total;i++)\n    {\n      long long Sum=0,T=X;\n      while(T)\n        {\n          Sum+=T/Prime[i];\n          T/=Prime[i];\n        }\n      if(Sum<Count[i])\n        return false;\n    }\n  return true;\n}\n\nint main()\n{\n  int N=Get();\n  static int A[1000000];\n  for(int i=0;i<N;i++)\n    A[i]=Get();\n  sort(A,A+N);\n  static bool Flag[10000001];\n  static int Min[10000001];\n  memset(Flag,0,sizeof(Flag));\n  Total=0;\n  for(int i=2;i<=10000000;i++)\n    {\n      if(!Flag[i])\n        {\n          Min[i]=Total;\n          Prime[Total++]=i;\n        }\n      for(int j=0;j<Total&&i*Prime[j]<=10000000;j++)\n        {\n          Flag[i*Prime[j]]=true;\n          Min[i*Prime[j]]=j;\n          if(!(i%Prime[j]))\n            break;\n        }\n    }\n  static long long Delta[10000001];\n  for(int i=10000000,j=N;i>=2;i--)\n    {\n      while(j&&A[j-1]>=i)\n        j--;\n      Delta[i]=N-j;\n    }\n  memset(Count,0,sizeof(Count));\n  for(int i=10000000;i>=2;i--)\n    {\n      Count[Min[i]]+=Delta[i];\n      Delta[i/Prime[Min[i]]]+=Delta[i];\n    }\n  long long Left=1,Right=0;\n  for(int i=0;i<N;i++)\n    Right+=A[i];\n  while(Left<Right)\n    {\n      long long Mid=(Left+Right)/2;\n      if(Check(Mid))\n        Right=Mid;\n      else\n        Left=Mid+1;\n    }\n  cout<<Left<<endl;\n  return 0;\n}\n""]","['binary search', 'math', 'number theory']",2300
https://codeforces.com//contest/1591/problem/A,A. Life of a Flower,Petya has got an interesting flower Petya is a busy person so he sometimes forgets to water it You are given n days from Petya s live and you have to determine what happened with his flower in the end The flower grows as follows If the flower isn t watered for two days in a row it dies If the flower is watered in the i th day it grows by 1 centimeter If the flower is watered in the i th and in the i 1 th day i 1 then it grows by 5 centimeters instead of 1 If the flower is not watered in the i th day it does not grow At the beginning of the 1 st day the flower is 1 centimeter tall What is its height after n days ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar(\'-\'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nint n;\n\nvoid solve(){\n    n=read();\n    int las=-1,die=0,blood=1;\n    for(int i=1;i<=n;i++){\n        int x=read();\n        if(las==0&&x==0){\n            die=1;\n        }else if(las==1&&x==1){\n            blood+=5;\n        }else if(x){\n            blood++;\n        }\n        las=x;\n    }\n    printf(""%d\\n"",die?-1:blood);\n}\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}']",['implementation'],800
https://codeforces.com//contest/204/problem/C,C. Little Elephant and Furik and Rubik,Little Elephant loves Furik and Rubik who he met in a small city Kremenchug The Little Elephant has two strings of equal length and consisting only of uppercase English letters The Little Elephant selects a pair of substrings of equal length the first one from string the second one from string The choice is equiprobable among all possible pairs Let s denote the substring of as and the substring of as The Little Elephant gives string to Furik and string to Rubik Let s assume that is the number of such positions of that where is the length of lines and and are the th characters of strings and correspondingly Help Furik and Rubik find the expected value of ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef double ll;\ntypedef double ull;\n\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nchar a[222222];\nchar b[222222];\n\nvi v1[30];\nvi v2[30];\nint n;\nint u[222222];\nint now;\null same(vi v1,vi v2){\n\tull res = 0;\n\tnow++;\n\tREP(i,v1.size()) u[v1[i]]=now;\n\tREP(i,v2.size()) if(u[v2[i]]==now) res+=ull(v2[i]+1)*(n-v2[i]);\n\treturn res;\n}\n\null solve(vi v1,vi v2){\n\tull res = 0;\n\tull sum = 0;\n\tREP(i,v2.size()) sum += n - v2[i];\n\tint pos = 0;\n\tREP(i,v1.size()){\n\t\twhile(pos<v2.size() && v2[pos]<=v1[i]) sum -= (n - v2[pos]), pos++;\n\t\tres += sum * (v1[i] + 1);\n\t\t//cout<<""add ""<<sum<<""*""<<(v1[i]+1)<<endl;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tcin>>n;\n//\tn=200000;\n\n\tscanf("" %s %s"",a,b);\n\t//REP(i,n) a[i]=b[i]=\'A\';\n\n\tREP(i,n) v1[a[i]-\'A\'].pb(i);\n\tREP(i,n) v2[b[i]-\'A\'].pb(i);\n\n\tll num = 0;\n\tFOR(i,1,n+1){\n\t\tll t = n-i+1;\n\t\tnum += t*t;\n\t}\n\tull c = 0;\n\n\tREP(i,30) if(v1[i].size() && v2[i].size()){\n\t\tc += solve(v1[i], v2[i]);\n\t\tc += solve(v2[i], v1[i]);\n\t\tc += same(v1[i], v2[i]);\n\t}\n\n\tprintf(""%.10lf\\n"",double(c)/num);\n//\tcout<<num<<endl;\n\t//cout<<c<<endl;\n\t//cout<<ll(1e18)<<endl;\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","['math', 'probabilities']",2000
https://codeforces.com//contest/1242/problem/D,D. Number Discovery,Ujan needs some rest from cleaning so he started playing with infinite sequences He has two integers n and k He creates an infinite sequence s by repeating the following steps Find k smallest distinct positive integers that are not in s Let s call them u 1 u 2 ldots u k from the smallest to the largest Append u 1 u 2 ldots u k and sum i 1 k u i to s in this order Go back to the first step Ujan will stop procrastinating when he writes the number n in the sequence s Help him find the index of n in s In other words find the integer x such that s x n It s possible to prove that all positive integers are included in s only once ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nll K;\n\nll sum(ll a, ll b) { // a to a-b+1\n\treturn b*(2*a-b+1)/2;\n}\n\nll cdiv(ll a, ll b) { return (a+b-1)/b; }\nll ind(ll a, ll b) {\n\tll num = a-b;\n\t// 1..K -> 1..K\n\t// K+1..2K -> K+2..2K+1\n\tll rem = num%K; if (rem == 0) rem = K;\n\treturn (num-1)/K*(K+1)+rem;\n\t// there are n-x.s, groups of K\n}\n\nll range(ll L, ll R) {\n\treturn (L+R)*(R-L+1)/2;\n}\n\nll range(ll L, ll R, ll X) {\n\tif (X < L) return range(L,R);\n\tif (X > R) return range(L-1,R-1);\n\treturn range(L-1,R)-X;\n}\n\npl lastSum(ll n) {\n\tif (n < K*(K+1)/2) return {0,0};\n\t// x, x-2, ..., x-K <= n -> K*x <= n+K*(K+1)/2-1\n\tll x = (n+K*(K+1)/2-1)/K; auto a = lastSum(x);\n\tif (a.f == x) {\n\t\tll xind = ind(x-1,a.s-1); int pos = xind%(K+1);\n\t\tif (pos == K) return {range(x-K,x-1),xind/(K+1)+1};\n\t\treturn {range(x-pos-K,x-pos-1),xind/(K+1)};\n\t} else {\n\t\tll xind = ind(x,a.s); int pos = xind%(K+1);\n\t\tif (range(x-pos+1,x-pos+K,a.f) <= n) return {range(x-pos+1,x-pos+K,a.f),xind/(K+1)+1};\n\t\treturn {range(x-pos+1-K,x-pos,a.f),xind/(K+1)};\n\t}\n}\n\nll solve(ll n) {\n\tauto x = lastSum(n);\n\tif (x.f == n) return x.s*(K+1);\n\treturn ind(n,x.s);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) {\n\t\tll N; re(N,K);\n\t\t/*FOR(i,1,K+1) assert(ind(i,0) == i);\n\t\tFOR(i,K+1,2*K+1) assert(ind(i,0) == i+1);\n\t\texit(0);*/\n\t\tps(solve(N));\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']",['math'],3400
https://codeforces.com//contest/1493/problem/C,C. K-beautiful Strings,You are given a string s consisting of lowercase English letters and a number k Let s call a string consisting of lowercase English letters if the number of occurrences of each letter in that string is divisible by k You are asked to find the lexicographically smallest beautiful string of length n which is lexicographically greater or equal to string s If such a string does not exist output 1 A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,""r"",stdin)\n#define Fout(s) freopen(s,""w"",stdout)\n#define file(s) Fin(s"".in""),Fout(s"".out"")\n//#define int long long\nconst int P=998244353; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline void fprint(const vector<int> &f) {for(int i=0;i<(int)f.size();i++) fprintf(stderr,""%d "",f[i]); fprintf(stderr,""\\n"");}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]=\'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\n#define N 100005\nchar s[N];\nint cnt[26],n,d;\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""pro.in"",""r"",stdin);\n\t\tfreopen(""pro.out"",""w"",stdout);\n\t#endif\n\tint T; scanf(""%d"",&T);\n\twhile(T--) {\n\t\tscanf(""%d%d"",&n,&d);\n\t\tscanf(""%s"",s+1);\n\t\tif(n%d!=0) {printf(""-1\\n""); continue;}\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tfor(int i=1;i<=n;i++) cnt[s[i]-\'a\']++;\n\t\tbool ok=1; for(int i=0;i<26;i++) if(cnt[i]%d!=0) ok=0;\n\t\tif(ok) printf(""%s\\n"",s+1);\n\t\telse {\n\t\t\tfor(int i=n;i>=1;i--) {\n\t\t\t\tcnt[s[i]-\'a\']--;\n\t\t\t\tif(s[i]==\'z\') continue;\n\t\t\t\tint ned=0,ex=0;\n\t\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\t\tif(cnt[j]%d==0) continue;\n\t\t\t\t\tned+=d-cnt[j]%d;\n\t\t\t\t\tif(j+\'a\'>s[i]) ex=1;\n\t\t\t\t}\n\t\t\t\tif(ned==n-i+1&&ex) {\n\t\t\t\t\tfor(int j=1;j<i;j++) putchar(s[j]);\n\t\t\t\t\tint minn=0; for(int j=s[i]-\'a\'+1;j<26;j++) if(cnt[j]%d!=0) {minn=j; break;}\n\t\t\t\t\tputchar(minn+\'a\'); cnt[minn]++;\n\t\t\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\t\t\twhile(cnt[j]%d!=0) putchar(j+\'a\'),cnt[j]++;\n\t\t\t\t\t}\n\t\t\t\t\tputchar(\'\\n\');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ned<n-i+1) {\n\t\t\t\t\tfor(int j=1;j<i;j++) putchar(s[j]);\n\t\t\t\t\tputchar(s[i]+1); cnt[s[i]-\'a\'+1]++;\n\t\t\t\t\tned=0;\n\t\t\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\t\t\tif(cnt[j]%d==0) continue;\n\t\t\t\t\t\tned+=d-cnt[j]%d;\n\t\t\t\t\t\tif(j+\'a\'>s[i]) ex=1;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0;j<n-i-ned;j++) putchar(\'a\');\n\t\t\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\t\t\twhile(cnt[j]%d!=0) putchar(j+\'a\'),cnt[j]++;\n\t\t\t\t\t}\n\t\t\t\t\tputchar(\'\\n\');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/']","['binary search', 'brute force', 'constructive algorithms', 'greedy', 'strings']",2000
https://codeforces.com//contest/1791/problem/D,D. Distinct Split,Let s denote the f x function for a string x as the number of distinct characters that the string contains For example f texttt abc 3 f texttt bbbbb 1 and f texttt babacaba 3 Given a string s split it into two non empty strings a and b such that f a f b is the maximum possible In other words find the maximum possible value of f a f b such that a b s the concatenation of string a and string b is equal to string s ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int               long long\n#define pb                push_back\n#define ppb               pop_back\n#define all(x)            (x).begin(),(x).end()\n#define uniq(v)           (v).erase(unique(all(v)),(v).end())\n#define sz(x)             (int)((x).size())\n#define f                 first\n#define s                 second\n#define pii               pair<int,int>\n#define rep(i,a,b)        for(int i = a; i < b; i++)\n#define repd(i,a,b)       for(int i = a; i >= b; i--)\n#define mem1(a)           memset(a, -1, sizeof(a))\n#define ppc               __builtin_popcount\n#define ppcll             __builtin_popcountll\n#define ll                long long\n#define ld                long double\n\ntemplate<typename T,typename U>istream& operator>>(istream& in,pair<T,U> &a){in>>a.f>>a.s;return in;}\ntemplate<typename T,typename U>ostream& operator<<(ostream& out,pair<T,U> a){out<<\'(\'<<a.f<<"", ""<<a.s<<\')\';return out;}\ntemplate<typename T>ostream& operator<<(ostream&cout,vector<T>const&v){cout<<""["";rep(i,0,sz(v)){if(i)cout<<"", "";cout<<v[i];}return cout<<""]"";}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n      cout << name << "" : "" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n      const char* comma = strchr(names + 1, \',\'); cout.write(names, comma - names) << "" : "" << arg1 << "" | ""; __f(comma + 1, args...);\n}\n#else\n#define dbg(...)\n#endif\n\nconst ld pi = 3.14159265358979323846;\nconst char nl = \'\\n\';\nconst long long INF=1e18;\nconst int32_t M=1e9+7;\nconst int32_t MM=998244353;\n\nconst int N=1e6+5;      \nll n, m, q, k, l, r, x, y, z, a[N], b[N], c[N];\nstring s,t;\n\n\n\nvoid KSBR(){\n      cin >> n >> s;\n      vector<int> p(n);\n      set<char> st;\n      rep(i,0,n){\n            st.insert(s[i]);\n            p[i] = sz(st);\n      }\n      st.clear();\n      int ans = 0;\n      repd(i,n-1,1){\n            st.insert(s[i]);\n            amax(ans, sz(st) + p[i-1]);\n      }\n      cout << ans << nl;\n} \nsigned main(){\n      ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n      #ifdef SIEVE\n            sieve();\n      #endif\n      #ifdef NCR\n            init();\n      #endif\n      int t=1, tc = 1;\n      cin>>t;\n      while(t--) {\n            //cout << ""Case "" << ""#"" << tc++ << "": "";\n            KSBR();\n      }\n}']","['brute force', 'greedy', 'strings']",1000
https://codeforces.com//contest/249/problem/E,E. Endless Matrix,A Russian space traveller Alisa Selezneva like any other schoolgirl of the late 21 century is interested in science She has recently visited the MIT Moscow Institute of Time where its chairman and the co inventor of the time machine academician Petrov told her about the construction of a time machine During the demonstration of the time machine performance Alisa noticed that the machine does not have high speed and the girl got interested in the reason for such disadvantage As it turns out on closer examination one of the problems that should be solved for the time machine isn t solved by an optimal algorithm If you find a way to solve this problem optimally the time machine will run faster and use less energy A task that none of the staff can solve optimally is as follows There exists a matrix which is filled by the following rule The cells are consecutive positive integers starting with one Besides if and and So after the first numbers are inserted matrix will look as follows To solve the problem you should learn to find rather quickly for the given values of and the meaning of expression As the meaning of this expression can be large enough it is sufficient to know only the last digits of the sought value So no one in MTI can solve the given task Alice was brave enough to use the time machine and travel the past to help you Your task is to write a program that uses the given values and finds the last digits of the given expression ,"['#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef double du;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, s, t) for(i = (s); i < (t); i++)\n#define RFOR(i, s, t) for(i = (s)-1; i >= (t); i--)\nconst ll MOD = 10000000000LL;\nconst ll MOD1 = 120000000000LL;\n\nll mul(ll a, ll b){\n    return (a*b - ((int)((du)a*b/MOD1) - 2) * MOD1) % MOD1;\n}\n\n//ll pow(int a, int k){\n//    ll ret = 1;\n//    while(k--)\n//        ret = ret*a%MOD;\n//    return ret;\n//}\n//\n//struct Num{\n//    int p2, p5, etc;\n//    du v;\n//    \n//    Num(){}\n//    Num(int v){\n//        p2 = p5 = 0;\n//        this->v = v;\n//        while(v % 2 == 0){\n//            p2++;\n//            v /= 2;\n//        }\n//        while(v % 5 == 0){\n//            p5++;\n//            v /= 5;\n//        }\n//        etc = v % MOD;\n//    }\n//    \n//    Num operator+(const Num& a){\n//        Num ret;\n//        ret.v = v + a.v;\n//        \n//    }\n//}\n\nll s3(int n){\n    return mul(n, mul(n, mul(n+1, n+1)))/4;\n}\n\nll s2(int n){\n    return mul(n, mul(n+1, 2*n+1))/6;\n}\n\nll s1(int n){\n    return mul(n, n+1)/2;\n}\n\nll s0(int n){\n    return n;\n}\n\nll solve(int x1, int x2, int y1, int y2){\n    if(x2 < x1 || y2 < y1)\n        return 0;\n    if(x1 == y1 && x2 == y2){\n        return (2*(s3(x2) - s3(x1-1) - s2(x2) + s2(x1-1) + s1(x2) - s1(x1-1)) - mul(2*x1-1, s2(x2) - s2(x1-1) - s1(x2) + s1(x1-1) + s0(x2) - s0(x1-1))) % MOD;\n    }\n    if(x2 < y1){\n        return (mul(x2-x1+1, s2(y2)-s2(y1-1)+s0(y2)-s0(y1-1)) - mul(y2-y1+1, s1(x2) - s1(x1-1))) % MOD;\n    }\n    if(y2 < x1){\n        return (mul(y2-y1+1, s2(x2-1)-s2(x1-2)) + mul(x2-x1+1, s1(y2) - s1(y1-1))) % MOD;\n    }\n    int p1, p2;\n    p1 = max(x1, y1);\n    p2 = min(x2, y2);\n    return (solve(x1, p1-1, y1, p1-1) + solve(x1, p1-1, p1, p2) + solve(x1, p1-1, p2+1, y2)\n            + solve(p1, p2, y1, p1-1) + solve(p1, p2, p1, p2) + solve(p1, p2, p2+1, y2)\n            + solve(p2+1, x2, y1, p1-1) + solve(p2+1, x2, p1, p2) + solve(p2+1, x2, p2+1, y2)) % MOD;\n}\n\nll f(int x, int y){\n    if(x < y)\n        return (ll)y*y+1-x;\n    return (ll)(x-1)*(x-1)+y;\n}\n\nll solve1(int x1, int x2, int y1, int y2){\n    ll ret = 0;\n    int i, j;\n    for(i = x1; i <= x2 && ret < MOD; i++)\n        for(j = y1; j <= y2 && ret < MOD; j++)\n            ret += f(i, j);\n    if(ret < MOD)\n        cout<<ret<<endl;\n    else{\n        ll t = (solve(x1, x2, y1, y2)%MOD + MOD) % MOD;\n        printf(""...%010I64d\\n"", t);\n    }\n}\n\nint main()\n{\n    #ifdef __FIO\n    freopen(""in.txt"", ""r"", stdin);\n    //freopen(""out.txt"", ""w"", stdout);\n    #endif\n    int n;\n    int x1, x2, y1, y2;\n    scanf(""%d"", &n);\n    while(n--){\n        cin>>x1>>y1>>x2>>y2;\n        solve1(y1, y2, x1, x2);\n    }\n    return 0;\n}\n']",['math'],2600
https://codeforces.com//contest/510/problem/A,A. Fox And Snake,Fox Ciel starts to learn programming The first task is drawing a fox However that turns out to be too hard for a beginner so she decides to draw a snake instead A snake is a pattern on a by table Denote th cell of th row as The tail of the snake is located at then it s body extends to then goes down rows to then goes left to and so on Your task is to draw this snake for Fox Ciel the empty cells should be represented as dot characters and the snake cells should be filled with number signs Consider sample tests in order to understand the snake pattern ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tint m;\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tputchar(\'#\');\n\t\t\t} else {\n\t\t\t\tint k = i / 2;\n\t\t\t\tif (k % 2 == 0 && j == m - 1) {\n\t\t\t\t\tputchar(\'#\');\n\t\t\t\t} else if (k % 2 == 1 && j == 0) {\n\t\t\t\t\tputchar(\'#\');\n\t\t\t\t} else {\n\t\t\t\t\tputchar(\'.\');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/509/problem/D,D. Restoring Numbers,Vasya had two arrays consisting of non negative integers of size and of size Vasya chose a positive integer and created an matrix using the following formula Vasya wrote down matrix on a piece of paper and put it in the table A year later Vasya was cleaning his table when he found a piece of paper containing an matrix He remembered making a matrix one day by the rules given above but he was not sure if he had found the paper with the matrix from those days Your task is to find out if the matrix that you ve found could have been obtained by following these rules and if it could then for what numbers it is possible ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\n#define N 110\n#define INF 1100000000\nlong long n,m,pp,w[N][N],a[N],b[N];\nint main(){\n    cin>>n>>m;\n    pp=-1;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)cin>>w[i][j];\n    for(int i=2;i<=n;i++){\n      long long t1=INF,t2=INF;\n      for(int j=1;j<=m;j++){\n              long long t=w[i][j]-w[i-1][j];\n              if(t>=0){\n                if(t1!=INF && t1!=t){printf(""NO\\n"");return 0;}\n                t1=t;\n                }\n              else{\n                if(t2!=INF && t2!=t){printf(""NO\\n"");return 0;}\n                t2=t;\n                }\n              }\n      if(t1!=INF && t2!=INF){\n        long long t=t1-t2;\n        if(pp!=-1 && pp!=t){printf(""NO\\n"");return 0;}\n        pp=t;\n        a[i]=t1;\n      }\n      else\n      if(t1!=INF)a[i]=t1;\n      else a[i]=t2;\n    }\n    for(int i=2;i<=n;i++)a[i]+=a[i-1];\n    long long t=0;\n    for(int i=1;i<=n;i++)t=min(t,a[i]);\n    for(int i=1;i<=n;i++)a[i]-=t;\n    \n    for(int j=2;j<=m;j++){\n      long long t1=INF,t2=INF;\n      for(int i=1;i<=n;i++){\n              long long t=w[i][j]-w[i][j-1];\n              if(t>=0){\n                if(t1!=INF && t1!=t){printf(""NO\\n"");return 0;}\n                t1=t;\n                }\n              else{\n                if(t2!=INF && t2!=t){printf(""NO\\n"");return 0;}\n                t2=t;\n                }\n              }\n      if(t1!=INF && t2!=INF){\n        long long t=t1-t2;\n        if(pp!=-1 && pp!=t){printf(""NO\\n"");return 0;}\n        pp=t;\n        b[j]=t1;\n      }\n      else\n      if(t1!=INF)b[j]=t1;\n      else b[j]=t2;\n    }\n    for(int j=2;j<=m;j++)b[j]+=b[j-1];\n    t=0;\n    for(int i=1;i<=m;i++)t=min(t,b[i]);\n    for(int i=1;i<=m;i++)b[i]-=t;\n    if(a[1]+b[1]>w[1][1]){printf(""NO\\n"");return 0;}\n    t=w[1][1]-a[1]-b[1];\n    for(int i=1;i<=m;i++)b[i]+=t;\n    \n    if(pp==-1)pp=INF;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)\n        if((a[i]+b[j])%pp!=w[i][j]){printf(""NO\\n"");return 0;}\n    printf(""YES\\n"");\n    cout<<pp<<endl;\n    for(int i=1;i<=n;i++)cout<<a[i]<<"" "";cout<<endl;\n    for(int i=1;i<=m;i++)cout<<b[i]<<"" "";cout<<endl;\n    return 0;\n}\n']","['constructive algorithms', 'math']",2200
https://codeforces.com//contest/834/problem/B,B. The Festive Evening,It s the end of July the time when a festive evening is held at Jelly Castle Guests from all over the kingdom gather here to discuss new trends in the world of confectionery Yet some of the things discussed here are not supposed to be disclosed to the general public the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands So it s a necessity to not let any uninvited guests in There are 26 entrances in Jelly Castle enumerated with uppercase English letters from to Because of security measures each guest is known to be assigned an entrance he should enter the castle through The door of each entrance is opened right before the first guest s arrival and closed right after the arrival of the last guest that should enter the castle through this entrance No two guests can enter the castle simultaneously For an entrance to be protected from possible intrusion a candy guard should be assigned to it There are such guards in the castle so if there are more than opened doors one of them is going to be left unguarded Notice that a guard can t leave his post until the door he is assigned to is closed Slastyona had a suspicion that there could be uninvited guests at the evening She knows the order in which the invited guests entered the castle and wants you to help her check whether there was a moment when more than doors were opened ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n#define fir first\n#define sec second\n\nint n, k;\nchar a[1000006];\nint s[1000006];\nint L[128];\nint R[128];\n\nint main() {\n\tcin >> n >> k;\n\tscanf(""%s"", a);\n\t\n\tfor (int i = 0; i < 128; ++i) {\n\t\tL[i] = INT_MAX;\n\t\tR[i] = INT_MIN;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tL[a[i]] = min(L[a[i]], i);\n\t\tR[a[i]] = max(R[a[i]], i);\n\t}\n\t\n\tfor (int i = 0; i < 128; ++i) if (L[i] != INT_MAX)\n\t\tfor (int j = L[i]; j <= R[i]; ++j)\n\t\t\t++s[j];\n\t\n\tputs(*max_element(s, s + n) <= k ? ""NO"" : ""YES"");\n\t\n\treturn 0;\n}\n']","['data structures', 'implementation']",1100
https://codeforces.com//contest/1613/problem/B,B. Absent Remainder,You are given a sequence a 1 a 2 dots a n consisting of n pairwise distinct positive integers Find left lfloor frac n 2 right rfloor different pairs of integers x and y such that x neq y x and y appear in a x mod y doesn t appear in a Note that some x or y can belong to multiple pairs lfloor x rfloor denotes the floor function the largest integer less than or equal to x x mod y denotes the remainder from dividing x by y If there are multiple solutions print any of them It can be shown that at least one solution always exists ,"['#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tsort(all(a));\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tcout << a[i + 1] << "" "" << a[0] << ""\\n"";\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","['greedy', 'implementation', 'sortings']",1000
https://codeforces.com//contest/1444/problem/E,E. Finding the Vertex,You are given a tree connected undirected graph without cycles One vertex of the tree is special and you have to find which one You can ask questions in the following form given an edge of the tree which endpoint is closer to the special vertex meaning which endpoint s shortest path to the special vertex contains fewer edges You have to find the special vertex by asking the minimum number of questions in the worst case for a given tree Please note that the special vertex might not be fixed by the interactor in advance it might change the vertex to any other one with the requirement of being consistent with the previously given answers ,"['#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << ""("" << a.first << "", "" << a.second << "")""; };\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &as) { const int sz = as.size(); os << ""[""; for (int i = 0; i < sz; ++i) { if (i >= 256) { os << "", ...""; break; } if (i > 0) { os << "", ""; } os << as[i]; } return os << ""]""; }\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << "" ""; cerr << endl; }\ntemplate <class T> bool chmin(T &t, const T &f) { if (t > f) { t = f; return true; } return false; }\ntemplate <class T> bool chmax(T &t, const T &f) { if (t < f) { t = f; return true; } return false; }\n\n\nconstexpr unsigned __int128 toUInt128(const char *s) {\n  unsigned __int128 x = 0;\n  for (; *s; ++s) x = x * 10 + (*s - \'0\');\n  return x;\n}\nconstexpr __int128 toInt128(const char *s) {\n  if (*s == \'-\') return -toInt128(s + 1);\n  __int128 x = 0;\n  for (; *s; ++s) x = x * 10 + (*s - \'0\');\n  return x;\n}\nunsigned __int128 inUInt128() {\n  static char buf[41];\n  scanf(""%s"", buf);\n  return toUInt128(buf);\n}\n__int128 inInt128() {\n  static char buf[41];\n  scanf(""%s"", buf);\n  return toInt128(buf);\n}\n\nvoid out(unsigned __int128 x) {\n  static char buf[41];\n  int len = 0;\n  do { buf[len++] = \'0\' + static_cast<int>(x % 10); } while (x /= 10);\n  for (int i = len; --i >= 0; ) putchar(buf[i]);\n}\nvoid out(__int128 x) {\n  if (x < 0) {\n    putchar(\'-\');\n    out(-static_cast<unsigned __int128>(x));\n  } else {\n    out(static_cast<unsigned __int128>(x));\n  }\n}\nstd::ostream &operator<<(std::ostream &os, unsigned __int128 x) {\n  static char buf[41];\n  int len = 0;\n  do { buf[len++] = \'0\' + static_cast<int>(x % 10); } while (x /= 10);\n  for (int i = len; --i >= 0; ) os << buf[i];\n  return os;\n}\nstd::ostream &operator<<(std::ostream &os, __int128 x) {\n  if (x < 0) {\n    os << \'-\' << -static_cast<unsigned __int128>(x);\n  } else {\n    os << static_cast<unsigned __int128>(x);\n  }\n  return os;\n}\n\n\n// T: monoid representing information of an interval.\n//   T()  should return the identity.\n//   T(S s)  should represent a single element of the array.\n//   T::merge(const T &l, const T &r)  should merge two intervals.\ntemplate <class T> struct SegmentTreePoint {\n  int logN, n;\n  vector<T> ts;\n  SegmentTreePoint() {}\n  explicit SegmentTreePoint(int n_) {\n    for (logN = 0, n = 1; n < n_; ++logN, n <<= 1) {}\n    ts.resize(n << 1);\n  }\n  template <class S> explicit SegmentTreePoint(const vector<S> &ss) {\n    const int n_ = ss.size();\n    for (logN = 0, n = 1; n < n_; ++logN, n <<= 1) {}\n    ts.resize(n << 1);\n    for (int i = 0; i < n_; ++i) at(i) = T(ss[i]);\n    build();\n  }\n  T &at(int i) {\n    return ts[n + i];\n  }\n  void build() {\n    for (int u = n; --u; ) merge(u);\n  }\n\n  inline void merge(int u) {\n    ts[u].merge(ts[u << 1], ts[u << 1 | 1]);\n  }\n\n  // Changes the value of point a to s.\n  template <class S> void change(int a, const S &s) {\n    assert(0 <= a); assert(a < n);\n    ts[a += n] = T(s);\n    for (; a >>= 1; ) merge(a);\n  }\n\n  // Applies T::f(args...) to point a.\n  template <class F, class... Args>\n  void ch(int a, F f, Args &&... args) {\n    assert(0 <= a); assert(a < n);\n    (ts[a += n].*f)(args...);\n    for (; a >>= 1; ) merge(a);\n  }\n\n  // Calculates the product for [a, b).\n  T get(int a, int b) {\n    assert(0 <= a); assert(a <= b); assert(b <= n);\n    if (a == b) return T();\n    a += n; b += n;\n    T prodL, prodR, t;\n    for (int aa = a, bb = b; aa < bb; aa >>= 1, bb >>= 1) {\n      if (aa & 1) { t.merge(prodL, ts[aa++]); prodL = t; }\n      if (bb & 1) { t.merge(ts[--bb], prodR); prodR = t; }\n    }\n    t.merge(prodL, prodR);\n    return t;\n  }\n\n  // Calculates T::f(args...) of a monoid type for [a, b).\n  //   op(-, -)  should calculate the product.\n  //   e()  should return the identity.\n  template <class Op, class E, class F, class... Args>\n#if __cplusplus >= 201402L\n  auto\n#else\n  decltype((std::declval<T>().*F())())\n#endif\n  get(int a, int b, Op op, E e, F f, Args &&... args) {\n    assert(0 <= a); assert(a <= b); assert(b <= n);\n    if (a == b) return e();\n    a += n; b += n;\n    auto prodL = e(), prodR = e();\n    for (int aa = a, bb = b; aa < bb; aa >>= 1, bb >>= 1) {\n      if (aa & 1) prodL = op(prodL, (ts[aa++].*f)(args...));\n      if (bb & 1) prodR = op((ts[--bb].*f)(args...), prodR);\n    }\n    return op(prodL, prodR);\n  }\n\n  // Find min b s.t. T::f(args...) returns true,\n  // when called for the partition of [a, b) from left to right.\n  //   Returns n + 1 if there is no such b.\n  template <class F, class... Args>\n  int findRight(int a, F f, Args &&... args) {\n    assert(0 <= a); assert(a <= n);\n    if ((T().*f)(args...)) return a;\n    if (a == n) return n + 1;\n    a += n;\n    for (; ; a >>= 1) if (a & 1) {\n      if ((ts[a].*f)(args...)) {\n        for (; a < n; ) {\n          if (!(ts[a <<= 1].*f)(args...)) ++a;\n        }\n        return a - n + 1;\n      }\n      ++a;\n      if (!(a & (a - 1))) return n + 1;\n    }\n  }\n\n  // Find max a s.t. T::f(args...) returns true,\n  // when called for the partition of [a, b) from right to left.\n  //   Returns -1 if there is no such a.\n  template <class F, class... Args>\n  int findLeft(int b, F f, Args &&... args) {\n    assert(0 <= b); assert(b <= n);\n    if ((T().*f)(args...)) return b;\n    if (b == 0) return -1;\n    b += n;\n    for (; ; b >>= 1) if ((b & 1) || b == 2) {\n      if ((ts[b - 1].*f)(args...)) {\n        for (; b <= n; ) {\n          if (!(ts[(b <<= 1) - 1].*f)(args...)) --b;\n        }\n        return b - n - 1;\n      }\n      --b;\n      if (!(b & (b - 1))) return -1;\n    }\n  }\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// given binary integers a[i]\n// minimize  \\sum_i b[i]\n// subject to  b[i] >= a[i]  &&  b[i] \\cap b[j] = 0\nstruct AdditionWithoutCarry {\n  string ans;\n  // (pos, next largest)\n  vector<pair<int, int>> ones;\n  // u: index in ones -> index in seg\n  vector<int> ord;\n\n  void addBigEndian(string s) {\n    const int len = s.size();\n    int last = -1;\n    for (int x = 0; x < len; ++x) if (s[len - 1 - x] == \'1\') {\n      ones.emplace_back(x, last);\n      last = (int)ones.size() - 1;\n    }\n  }\n  template <class T> void addInt(T a) {\n    int last = -1;\n    for (int x = 0; a; ++x) {\n      if (a >> x & 1) {\n        ones.emplace_back(x, last);\n        last = (int)ones.size() - 1;\n        a &= a - 1;\n      }\n    }\n  }\n\n  // max (pos + (index from right))\n  struct Node {\n    int mx, num, id;\n    Node() : mx(-1), num(0), id(-1) {}\n    Node(int val, int id_) : mx(val), num(1), id(id_) {}\n    void merge(const Node &l, const Node &r) {\n      if (l.mx + r.num <= r.mx) {\n        mx = r.mx;\n        id = r.id;\n      } else {\n        mx = l.mx + r.num;\n        id = l.id;\n      }\n      num = l.num + r.num;\n    }\n  };\n  SegmentTreePoint<Node> seg;\n  bool rec(int used, int r) {\n    const auto res = seg.get(0, r);\n    const int u = res.id;\n    if (!~u) return true;\n    const int x = ones[u].first;\n    const int k = seg.get(ord[u], r).num;\n    // try to assign 1 for [x, x + k)\n    if (x + k <= used) {\n      const int v = ones[u].second;\n      if (~v) seg.change(ord[v], Node(ones[v].first, v));\n      if (rec(x, ord[u])) {\n        fill(ans.begin() + x, ans.begin() + (x + k), \'1\');\n        return true;\n      }\n      if (~v) seg.change(ord[v], Node());\n    }\n    // try to assign 1 for [x + 1, x + 1 + k)\n    if (x + 1 + k <= used) {\n      if (rec(x + 1, ord[u])) {\n        fill(ans.begin() + (x + 1), ans.begin() + (x + 1 + k), \'1\');\n        return true;\n      }\n    }\n    return false;\n  }\n  void run() {\n    if (ones.empty()) {\n      // might need ""0""\n      ans = """";\n      return;\n    }\n    const int onesLen = ones.size();\n    int limX = 0;\n    for (int u = 0; u < onesLen; ++u) chmax(limX, ones[u].first + 1);\n    vector<vector<int>> uss(limX);\n    for (int u = 0; u < onesLen; ++u) uss[ones[u].first].push_back(u);\n    ord.assign(onesLen, -1);\n    {\n      int id = 0;\n      for (int j = 0; j < limX; ++j) {\n        sort(uss[j].begin(), uss[j].end(), [&](int u, int v) -> bool {\n          return (((~ones[u].second) ? ord[ones[u].second] : -1) < \n                  ((~ones[v].second) ? ord[ones[v].second] : -1));\n        });\n        for (const int u : uss[j]) ord[u] = id++;\n      }\n    }\n    seg = SegmentTreePoint<Node>(onesLen);\n    for (int u = 0; u < onesLen; ++u) {\n      if (~ones[u].second) seg.at(ord[ones[u].second]) = Node();\n      seg.at(ord[u]) = Node(ones[u].first, u);\n    }\n    seg.build();\n    ans.assign(seg.ts[1].mx + 2, \'0\');\n    rec(seg.ts[1].mx + 2, onesLen);\n    if (ans.back() == \'0\') ans.pop_back();\n    assert(!ans.empty());\n    assert(ans.back() == \'1\');\n  }\n};\n\n\nint N;\nvector<int> A, B;\n\nint Ask(int i) {\n  printf(""? %d %d\\n"", A[i] + 1, B[i] + 1);\n  fflush(stdout);\n  int u;\n  scanf(""%d"", &u);\n  --u;\n  return u;\n}\nvoid Answer(int u) {\n  printf(""! %d\\n"", u + 1);\n  fflush(stdout);\n}\n\nvector<vector<int>> G;\nvector<int> del;\n\nvector<__int128> dp;\nint neck, cut;\nvoid dfs(int u, int pi) {\n  for (const int i : G[u]) if (!del[i] && pi != i) {\n    const int v = A[i] ^ B[i] ^ u;\n    dfs(v, i);\n  }\n  __int128 mx = -1;\n  int im = -1;\n  AdditionWithoutCarry f;\n  for (const int i : G[u]) if (!del[i] && pi != i) {\n    const int v = A[i] ^ B[i] ^ u;\n    if (chmax(mx, dp[v])) {\n      im = i;\n    }\n    f.addInt(dp[v] + 1);\n  }\n  f.run();\n  dp[u] = 0;\n  for (int x = 0; x < (int)f.ans.size(); ++x) if (f.ans[x] == \'1\') {\n    dp[u] |= (__int128)1 << x;\n    if (chmax(neck, x)) {\n      cut = im;\n    }\n  }\n}\n\nint main() {\n  scanf(""%d"", &N);\n  A.resize(N - 1);\n  B.resize(N - 1);\n  for (int i = 0; i < N - 1; ++i) {\n    scanf(""%d%d"", &A[i], &B[i]);\n    --A[i];\n    --B[i];\n  }\n  \n  G.assign(N, {});\n  for (int i = 0; i < N - 1; ++i) {\n    G[A[i]].push_back(i);\n    G[B[i]].push_back(i);\n  }\n  del.assign(N - 1, 0);\n  \n  for (int r = 0; ; ) {\n    neck = -1;\n    cut = -1;\n    dp.assign(N, -1);\n    dfs(r, -1);\n// cerr<<""dp = ""<<dp<<endl;\n    if (~cut) {\n      del[cut] = 1;\n      r = Ask(cut);\n    } else {\n      Answer(r);\n      break;\n    }\n  }\n  \n  return 0;\n}\n']","['brute force', 'dfs and similar', 'dp', 'interactive', 'trees']",3500
https://codeforces.com//contest/194/problem/A,A. Exams,One day the Codeforces round author sat exams He had exams and he needed to get an integer from to for each exam He will have to re sit each failed exam i e the exam that gets mark The author would need to spend too much time and effort to make the sum of his marks strictly more than That could have spoilt the Codeforces round On the other hand if the sum of his marks is strictly less than the author s mum won t be pleased at all The Codeforces authors are very smart and they always get the mark they choose themselves Also the Codeforces authors just hate re sitting exams Help the author and find the minimum number of exams he will have to re sit if he passes the exams in the way that makes the sum of marks for all exams equal exactly ,"['#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  cout << max(3*N-K, 0) << endl;\n}\n']","['implementation', 'math']",900
https://codeforces.com//contest/371/problem/B,B. Fox Dividing Cheese,Two little greedy bears have found two pieces of cheese in the forest of weight and grams correspondingly The bears are so greedy that they are ready to fight for the larger piece That s where the fox comes in and starts the dialog Little bears wait a little I want to make your pieces equal Come off it fox how are you going to do that the curious bears asked It s easy said the fox If the mass of a certain piece is divisible by two then I can eat exactly a half of the piece If the mass of a certain piece is divisible by three then I can eat exactly two thirds and if the mass is divisible by five then I can eat four fifths I ll eat a little here and there and make the pieces equal The little bears realize that the fox s proposal contains a catch But at the same time they realize that they can not make the two pieces equal themselves So they agreed to her proposal but on one condition the fox should make the pieces equal as quickly as possible Find the minimum number of operations the fox needs to make pieces equal ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname """"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define sz size()\nint a, b, ans = INF;\n\nvoid _try(int x) {\n\tif (a % x != 0 || b % x != 0) return;\n\tint n1 = a / x, n2 = b / x;\n\tint kol = 0;\n\twhile (n1 % 2 == 0) n1 /= 2, ++kol;\n\twhile (n1 % 3 == 0) n1 /= 3, ++kol;\n\twhile (n1 % 5 == 0) n1 /= 5, ++kol;\n\twhile (n2 % 2 == 0) n2 /= 2, ++kol;\n\twhile (n2 % 3 == 0) n2 /= 3, ++kol;\n\twhile (n2 % 5 == 0) n2 /= 5, ++kol;\n\tif (n1 > 1 || n2 > 1) return;\n\tans = min(ans, kol);\n}\n\nint main ()\n{\t\n\t#ifndef ONLINE_JUDGE\n\tfreopen (fname""in"",""r"",stdin);\n\tfreopen (fname""out"",""w"",stdout);\n\t#endif\n\n\tcin >> a >> b;\n\n\tfor (int i = 1; i * i <= a; i ++ ) {\n\t\tif (a % i == 0) {\n\t\t\t_try(i);\n\t\t\t_try(a / i);\n\t\t}\n\t}\n\n\tfor (int i = 1; i * i <= b; i ++ ) {\n\t\tif (b % i == 0) {\n\t\t\t_try(i);\n\t\t\t_try(b / i);\n\t\t}\n\t}\n\t\n\tif (ans == INF) cout << -1;\n\telse cout << ans;\n\n\treturn 0;\n}']","['math', 'number theory']",1300
https://codeforces.com//contest/1280/problem/D,D. Miss Punyverse,The Oak has n nesting places numbered with integers from 1 to n Nesting place i is home to b i bees and w i wasps Some nesting places are connected by branches We call two nesting places if there exists a branch between them A from nesting place x to y is given by a sequence s 0 ldots s p of distinct nesting places where p is a non negative integer s 0 x s p y and s i 1 and s i are adjacent for each i 1 ldots p The branches of The Oak are set up in such a way that for any two pairs of nesting places x and y there exists a unique simple path from x to y Because of this biologists and computer scientists agree that The Oak is in fact a tree A is a set V of nesting places such that for any two x and y in V there exists a simple path from x to y whose intermediate nesting places all lie in V A set of villages cal P is called a if each of the n nesting places is contained in exactly one of the villages in cal P In other words no two villages in cal P share any common nesting place and altogether they contain all n nesting places The Oak holds its annual Miss Punyverse beauty pageant The two contestants this year are Ugly Wasp and Pretty Bee The winner of the beauty pageant is determined by voting which we will now explain Suppose mathcal P is a partition of the nesting places into m villages V 1 ldots V m There is a local election in each village Each of the insects in this village vote for their favorite contestant If there are more votes for Ugly Wasp than Pretty Bee then Ugly Wasp is said to in that village Otherwise Pretty Bee Whoever wins in the most number of villages wins As it always goes with these pageants bees always vote for the bee which is Pretty Bee this year and wasps always vote for the wasp which is Ugly Wasp this year Unlike their general elections no one abstains from voting for Miss Punyverse as everyone takes it very seriously Mayor Waspacito and his assistant Alexwasp wants Ugly Wasp to win He has the power to choose how to partition The Oak into exactly m villages If he chooses the partition optimally determine the maximum number of villages in which Ugly Wasp wins ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvector<vector<int> > edges;\nvector<int> votes;\n\nvoid chk_max(pair<int, ll>& a, pair<int, ll> b){\n\tif(b > a) a = b;\n}\n\nvector<pair<int, ll> > dfs(int v, int p){\n\tvector<pair<int, ll> > f = {{0, votes[v]}};\n\tfor(int w : edges[v]){\n\t\tif(w == p) continue;\n\t\tvector<pair<int, ll> > x = dfs(w, v);\n\t\tvector<pair<int, ll> > newf(f.size() + x.size(), {0, -1e16});\n\t\tfor(int i = 0; i < (int)f.size(); i++){\n\t\t\tfor(int j = 0; j < (int)x.size(); j++){\n\t\t\t\tpair<int, ll> r = f[i], s = x[j];\n\t\t\t\t{\n\t\t\t\t\tchk_max(newf[i + j], {r.first + s.first, r.second + s.second});\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tchk_max(newf[i + j + 1], {r.first + s.first + (s.second > 0), r.second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = newf;\n\t}\n\treturn f;\n}\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvotes.assign(n, 0);\n\tedges.assign(n, {});\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tvotes[i] -= x;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tvotes[i] += x;\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tvector<pair<int,ll> > res = dfs(0, -1);\n\tint ans = res[m-1].first;\n\tif(res[m-1].second > 0) ans++;\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}\n// maximum # of villages, how many at top""]","['dp', 'greedy', 'trees']",2500
https://codeforces.com//contest/1333/problem/D,D. Challenges in school №41,There are n children who study at the school 41 It is well known that they are good mathematicians Once at a break they arranged a challenge for themselves All children arranged in a row and turned heads either to the left or to the right Children can do the following in one second several pairs of neighboring children who are can turn the head in the opposite direction For instance the one who was looking at the right neighbor turns left and vice versa for the second child Moreover every second pair of neighboring children performs such action They are going to finish when there is no pair of neighboring children who are looking at each other You are given the number n the initial arrangement of children and the number k You have to find a way for the children to act if they want to finish the process in exactly k seconds More formally for each of the k moves you need to output the numbers of the children who turn left during this move For instance for the configuration shown below and k 2 children can do the following steps At the beginning two pairs make move 1 2 and 3 4 After that we receive the following configuration At the second move pair 2 3 makes the move The final configuration is reached Good job It is guaranteed that if the solution exists it takes not more than n 2 headturns ,"['#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nusing ll = long long;\nint const nmax = 3000;\nchar v[1 + nmax];\n\nvector<int> processlevel(int n){\n  vector<int> sol;\n  for(int i = 1;i < n; i++)\n    if(v[i] == \'R\' && v[i + 1] == \'L\')\n      sol.push_back(i);\n  for(int i = 0; i < sol.size(); i++)\n    swap(v[sol[i]], v[sol[i] + 1]);\n  return sol;\n}\n\nint main()\n{\n  int n, k;\n  cin >> n >> k;\n  for(int i = 1;i <= n; i++)\n    cin >> v[i];\n  vector<vector<int>> solbig;\n  int movesmax = 0;\n  while(true){\n    vector<int> sol = processlevel(n);\n    if(sol.size() == 0)\n      break;\n    movesmax += sol.size();\n    solbig.push_back(sol);\n  }\n  if(k < solbig.size() || movesmax < k){\n    cout << -1;\n    return 0;\n  }\n  int ptr = 0, movesmin = solbig.size();\n\n  while(movesmin < k){\n    if(solbig[ptr].size() == 0) {\n      ptr++;\n      movesmin--;\n    }\n    cout << 1 << "" "" << solbig[ptr].back() << \'\\n\';\n    solbig[ptr].pop_back();\n    k--;\n    if(solbig[ptr].size() == 0) {\n      ptr++;\n      movesmin--;\n    }\n  }\n\n  for(int i = ptr; i < solbig.size(); i++){\n    cout << solbig[i].size() << "" "";\n    for(int j = 0; j < solbig[i].size(); j++)\n      cout << solbig[i][j] << "" "";\n    cout << \'\\n\';\n  }\n\n  return 0;\n}\n']","['brute force', 'constructive algorithms', 'games', 'graphs', 'greedy', 'implementation', 'sortings']",2100
https://codeforces.com//contest/630/problem/G,G. Challenge Pennants,Because of budget cuts one IT company established new non financial reward system instead of bonuses Two kinds of actions are rewarded fixing critical bugs and suggesting new interesting features A man who fixed a critical bug gets I fixed a critical bug pennant on his table A man who suggested a new interesting feature gets I suggested a new feature pennant on his table Because of the limited budget of the new reward system only I fixed a critical bug pennants and I suggested a new feature pennants were bought In order to use these pennants for a long time they were made challenge ones When a man fixes a new critical bug one of the earlier awarded I fixed a critical bug pennants is passed on to his table When a man suggests a new interesting feature one of the earlier awarded I suggested a new feature pennants is passed on to his table One man can have several pennants of one type and of course he can have pennants of both types on his table There are tables in the IT company Find the number of ways to place the pennants on these tables given that each pennant is situated on one of the tables and each table is big enough to contain any number of pennants ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\nll cnk(ll n, int k)\n{\n    ll res = 1;\n    forn(i, k) res = (res * (n - i)) / (i + 1);\n    return res;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    ll n, t;\n\n    cin >> n;\n    ll res = cnk(n + 4, 5) * cnk(n + 2, 3);\n    cout << res;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","['combinatorics', 'math']",1600
https://codeforces.com//contest/1804/problem/G,G. Flow Control,Raj has a single physical network line that connects his office to the Internet This line bandwidth is b bytes per millisecond There are n users who would like to use this network line to transmit some data The i th of them will use the line from millisecond s i to millisecond f i inclusive His initial data rate will be set to d i That means he will use data rate equal to d i for millisecond s i and then it will change according to the procedure described below The flow control will happen as follows Suppose there are m users trying to transmit some data via the given network line during millisecond x Denote as t i the data rate that the i th of these m users has at the beginning of this millisecond All t i are non negative integer values If m 0 i e there are no users trying to transmit data during this millisecond nothing happens If the sum of all t i is less than or equal to b each active user successfully completes his transmission the i th active user transmits t i bytes After that the data rate of each active user grows by 1 i e each t i is increased by 1 If the sum of all t i is greater than b the congestion occurs and no data transmissions succeed this millisecond at all If that happens each t i decreases twice i e each t i is replaced with lfloor frac t i 2 rfloor Raj knows all the values n b s i f i and d i he wants to calculate the total number of bytes transmitted by all the users in the aggregate ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    const int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    void half(int p, int l, int r) {\n        if (info[p].act == 0) {\n            return;\n        }\n        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {\n            apply(p, {-(info[p].min + 1) / 2});\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        half(2 * p, l, m);\n        half(2 * p + 1, m, r);\n        pull(p);\n    }\n    void half() {\n        half(1, 0, n);\n    }\n};\n\nconstexpr i64 inf = 1E18;\n\nstruct Tag {\n    i64 add = 0;\n    \n    void apply(Tag t) {\n        add += t.add;\n    }\n};\n\nstruct Info {\n    i64 min = inf;\n    i64 max = -inf;\n    i64 sum = 0;\n    i64 act = 0;\n    \n    void apply(Tag t) {\n        min += t.add;\n        max += t.add;\n        sum += act * t.add;\n    }\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.min = std::min(a.min, b.min);\n    c.max = std::max(a.max, b.max);\n    c.sum = a.sum + b.sum;\n    c.act = a.act + b.act;\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b;\n    std::cin >> n >> b;\n    \n    i64 ans = 0;\n    \n    std::vector<std::array<int, 3>> events;\n    for (int i = 0; i < n; i++) {\n        int s, f, d;\n        std::cin >> s >> f >> d;\n        s--;\n        events.push_back({s, i, d});\n        events.push_back({f, i, 0});\n    }\n    \n    std::sort(events.begin(), events.end());\n    \n    LazySegmentTree<Info, Tag> seg(n);\n    int cur = 0;\n    for (auto [t, i, d] : events) {\n        Info last = {-1, -1, -1, -1};\n        i64 lastc = -1;\n        i64 lastans = -1;\n        while (cur < t) {\n            auto info = seg.rangeQuery(0, n);\n            if (info.act == 0) {\n                cur = t;\n                break;\n            }\n            if (info.min == last.min && info.max == last.max && info.sum == last.sum && info.max - info.min <= 1) {\n                i64 dt = cur - lastc;\n                i64 dans = ans - lastans;\n                i64 phase = (t - cur) / dt;\n                cur += phase * dt;\n                ans += phase * dans;\n            }\n            last = info;\n            lastc = cur;\n            lastans = ans;\n            i64 u = (b - info.sum + info.act) / info.act;\n            if (u > t - cur) {\n                u = t - cur;\n            }\n            if (u < 0) {\n                u = 0;\n            }\n            cur += u;\n            ans += (info.sum + info.sum + info.act * (u - 1)) * u / 2;\n            seg.rangeApply(0, n, {u});\n            if (t == cur) {\n                break;\n            }\n            cur += 1;\n            seg.half();\n        }\n        if (d != 0) {\n            seg.modify(i, {d, d, d, 1});\n        } else {\n            seg.modify(i, Info());\n        }\n    }\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}\n']","['data structures', 'dsu', 'implementation']",3500
https://codeforces.com//contest/609/problem/F,F. Frogs and mosquitoes,There are frogs sitting on the coordinate axis For each frog two values are known the position and the initial length of the tongue of the th frog it is guaranteed that all positions are different mosquitoes one by one are landing to the coordinate axis For each mosquito two values are known the coordinate of the position where the th mosquito lands and the size of the th mosquito Frogs and mosquitoes are represented as points on the coordinate axis The frog can eat mosquito if mosquito is in the same position with the frog or to the right and the distance between them is not greater than the length of the tongue of the frog If at some moment several frogs can eat a mosquito the leftmost frog will eat it with minimal After eating a mosquito the length of the tongue of a frog increases with the value of the size of eaten mosquito It s possible that after it the frog will be able to eat some other mosquitoes the frog should eat them in this case For each frog print two values the number of eaten mosquitoes and the length of the tongue after landing all mosquitoes and after eating all possible mosquitoes by frogs Each mosquito is landing to the coordinate axis only after frogs eat all possible mosquitoes landed before Mosquitoes are given in order of their landing to the coordinate axis ,"['/*\nSmashing the human horde, crushing religious filth\nNailing invertedly the ones who plant the seeds of doubt\nWasting inherent truth, confronting an inner hell\nCursing subconsciously the ones who reap the seeds of doubt\n\nHow can humans play God when all they all are slaves?\nTheir lack of souls will lead them to an early grave\nCondemned to live a life of unrelenting praise\nTheir rotted corpse remains when death replaces life\n\nTearing the vocal chords of prophets\nThat spoke of lies unwanted\nThey are the ones controlling the seeds of doubt\n\nHow can humans play God when all they all are slaves?\nTheir lack of souls will lead them to an early grave\nCondemned to live a life of unrelenting praise\nTheir rotted corpse remains when death replaces life\n\nFearing their fate, they chose a random date\nWhen all life would cease and rapture would release\nTrampling the meek, the gospel they did speak\nForetelling demise, speaking only lies, lies, lies, lies, lies\n\nFeeding the senseless souls of mindless\nInhabitants not knowing they are the ones consuming the seeds of doubt\nFinding the source of stimulation, unnurtured realization\nOf fools who will always against their will just end their lives\n\nHow can humans play God when all they all are slaves?\nTheir lack of souls will lead them to an early grave\nCondemned to live a life of unrelenting praise\nTheir rotted corpse remains when death replaces life\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int SZ = 410000;\n\nusing namespace std;\n\nint n, m;\nint orig_x[SZ];\nvector<int> xs, ux;\nint p[SZ], b[SZ];\nint x[SZ];\nint t[SZ];\nint orig_p[SZ];\nint N;\nvector<pair<int, int> > events[SZ];\nint first_shot[SZ];\nmultiset<int> active;\nmultiset<pair<int, int> >alive;\nint id_by_x[SZ];\nint killed[SZ];\nlong long ohead[SZ];\n\nvoid compress()\n{\n\tsort(xs.begin(), xs.end());\n\tfor (int i = 0; i < xs.size(); i++)\n\t{\n\t\tif (i == 0 || xs[i] != xs[i - 1])\n\t\t\tux.push_back(xs[i]);\n\t}\n}\n\nint get_x(int x)\n{\n\tint id = upper_bound(ux.begin(), ux.end(), x) - ux.begin();\n\treturn id-1;\n}\n\nint get_first()\n{\n\tif (active.size() == 0)\n\t\treturn 1e9;\n\tmultiset<int>::iterator it = active.begin();\n\treturn *it;\n}\n\nint T[SZ*4];\nint topush[SZ*4];\n\nvoid build(int v, int tl, int tr)\n{\n\tif (tl == tr)\n\t{\n\t\tT[v] = first_shot[tl];\n\t\ttopush[v] = 1e9;\n\t\t//cout << tl << ""^"" << tr << "" "" << T[v] << endl;\n\t\treturn;\n\t}\n\tint tm = tl + tr;\n\ttm /= 2;\n\tbuild(v * 2, tl, tm);\n\tbuild(v * 2 + 1, tm + 1, tr);\n\tT[v] = 1e9;\n\ttopush[v] = 1e9;\n}\n\nvoid push(int v)\n{\n\tT[v * 2] = min(T[v * 2], topush[v]);\n\tT[v * 2 + 1] = min(T[v * 2 + 1], topush[v]);\n\ttopush[v * 2] = min(topush[v * 2], topush[v]);\n\ttopush[v * 2 + 1] = min(topush[v * 2 + 1], topush[v]);\n}\n\nint get(int v, int tl, int tr, int ps)\n{\n\tif (tl == tr)\n\t{\n\t\treturn T[v];\n\t}\n\tpush(v);\n\tint tm = tl + tr;\n\ttm /= 2;\n\tif (ps <= tm)\n\t\treturn get(v * 2, tl, tm, ps);\n\telse\n\t\treturn get(v * 2 + 1, tm + 1, tr, ps);\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int val)\n{\n\tif (l > r)\n\t\treturn;\n\tif (tl == l&&tr == r)\n\t{\n\t\tT[v] = min(T[v], val);\n\t\ttopush[v] = min(topush[v], val);\n\t\treturn;\n\t}\n\tpush(v);\n\tint tm = tl + tr;\n\ttm /= 2;\n\tupdate(v * 2, tl, tm, l, min(r, tm), val);\n\tupdate(v * 2 + 1, tm + 1, tr, max(tm + 1, l), r, val);\n}\n\nvoid kill(int A, int B)\n{\n\t//cout << ""!"" << A << "" ^ "" << B << endl;\n\n\tohead[A] += b[B];\n\tkilled[A] += 1;\n\tlong long nb = orig_x[A] + ohead[A]+t[A];\n\tif (nb > 2e9)\n\t\tnb = 2e9;\n\tint rb = get_x(nb);\n\tupdate(1, 0, N - 1, x[A], rb, x[A]);\n}\n\nbool can_extend(int id)\n{\n\tif (alive.size() == 0)\n\t\treturn false;\n\tmultiset<pair<int, int> > ::iterator it;\n\tit = alive.lower_bound(make_pair(x[id], -1));// begin();\n\tif (it == alive.end())\n\t\treturn false;\n\tint ps = (*it).first;\n\tlong long reach = orig_x[id] + ohead[id] + t[id];\n\tif (reach > 2e9)\n\t\treach = 2e9;\n\treturn (ps <= get_x(reach));\n}\n\nvoid extend(int id)\n{\n\tmultiset<pair<int, int> > ::iterator it;\n\tit = alive.lower_bound(make_pair(x[id], -1));\n\tint ps = (*it).first;\n\tint id2 = (*it).second;\n\talive.erase(it);\n\tkill(id, id2);\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> x[i] >> t[i];\n\t\torig_x[i] = x[i];\n\t\txs.push_back(x[i]);\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> p[i] >> b[i];\n\t\torig_p[i] = p[i];\n\t\txs.push_back(p[i]);\n\t}\n\n\tcompress();\n\n\tfor (int i = 1; i <= n; i++)\n\t\tx[i] = get_x(x[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tp[i] = get_x(p[i]);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tid_by_x[x[i]] = i;\n\t}\n\t\n\t/*\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcout << x[i] << ""% "";\n\t}\n\tcout << endl;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcout << p[i] << ""^ "";\n\t}\n\tcout << endl;\n\t*/\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tevents[x[i]].push_back(make_pair(-1, i));\n\t\tevents[get_x(orig_x[i] + t[i])+1].push_back(make_pair(1, i));\n\t\t//cout << x[i] << ""^"" << get_x(orig_x[i] + t[i]) + 1 << endl;\n\n\t}\n\n\tN = ux.size();\n\n\tfor (int i = 0; i < ux.size(); i++)\n\t{\n\t\tfor (int j = 0; j < events[i].size(); j++)\n\t\t{\n\t\t\tint tp = events[i][j].first;\n\t\t\tint id = events[i][j].second;\n\t\t\tif (tp == -1)// open\n\t\t\t{\n\t\t\t\tactive.insert(x[id]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tactive.erase(active.find(x[id]));\n\t\t\t}\n\t\t}\n\t\tfirst_shot[i] = get_first();\n\t}\n\t/*\n\tfor (int i = 0; i < N; i++)\n\t\tcout << ux[i] << "" "";\n\tcout << endl;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcout << first_shot[i] << ""^"";\n\t}\n\tcout << endl;\n\t*/\n\tbuild(1, 0, N-1);\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\t//cout << ""%"" << i << endl;\n\n\t\tint kicks = get(1, 0, N-1, p[i]);\n//\t\tcout << ""%!"" << kicks << "" ""<<p[i]<<endl;\n\t\tif (kicks > 1e7)\n\t\t{\n\t\t\talive.insert(make_pair(p[i],i));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tkicks = id_by_x[kicks];\n\t\t//cout << ""^"" << kicks << ""&""<<i<<endl;\n\n\t\tkill(kicks, i);\n\t\twhile (true)\n\t\t{\n\t\t//\tcout << ""@"" << kicks<<endl;\n\t\t\tif (can_extend(kicks))\n\t\t\t{\n\t\t\t\t//cout << ""!"" << endl;\n\t\t\t\textend(kicks);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << killed[i] << "" "" << ohead[i] + t[i] << ""\\n"";\n\t}\n\n\tcin.get();cin.get();\n\n\treturn 0;\n}']","['data structures', 'greedy']",2500
https://codeforces.com//contest/1852/problem/D,D. Miriany and Matchstick,Miriany s matchstick is a 2 times n grid that needs to be filled with characters or He has already filled in the first row of the grid and would like you to fill in the second row You must do so in a way such that the number of dagger is equal to k If it is impossible report so dagger An is a pair of cells r 1 c 1 and r 2 c 2 1 le r 1 r 2 le 2 1 le c 1 c 2 le n such that r 1 r 2 c 1 c 2 1 and the characters in r 1 c 1 and r 2 c 2 are different ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 1; i < n; i++) {\n        k -= (s[i] != s[i - 1]);\n    }\n    if (k < 0) {\n        std::cout << ""NO\\n"";\n        return;\n    }\n    \n    std::vector dp(2, std::vector<std::vector<std::pair<int, int>>>(n));\n    dp[0][0].emplace_back(s[0] != \'A\', s[0] != \'A\');\n    dp[1][0].emplace_back(s[0] != \'B\', s[0] != \'B\');\n    for (int i = 1; i < n; i++) {\n        for (int t = 0; t < 2; t++) {\n            for (auto [l, r] : dp[t][i - 1]) {\n                dp[t][i].emplace_back(l, r);\n                dp[!t][i].emplace_back(l + 1, r + 1);\n            }\n        }\n        for (int t = 0; t < 2; t++) {\n            std::vector<std::pair<int, int>> f;\n            std::sort(dp[t][i].begin(), dp[t][i].end());\n            int d = (s[i] != \'A\' + t);\n            for (auto [l, r] : dp[t][i]) {\n                l += d;\n                r += d;\n                if (!f.empty() && l <= f.back().second + 1) {\n                    f.back().second = std::max(f.back().second, r);\n                } else {\n                    f.emplace_back(l, r);\n                }\n            }\n            dp[t][i] = f;\n        }\n    }\n    \n    auto get = [&](auto &f, int x) {\n        for (auto [l, r] : f) {\n            if (l <= x && x <= r) {\n                return true;\n            }\n        }\n        return false;\n    };\n    \n    for (int t = 0; t < 2; t++) {\n        if (get(dp[t][n - 1], k)) {\n            std::cout << ""YES\\n"";\n            auto ans = s;\n            for (int i = n - 1; i > 0; i--) {\n                k -= (s[i] != \'A\' + t);\n                ans[i] = \'A\' + t;\n                if (!get(dp[t][i - 1], k)) {\n                    t = !t;\n                    k--;\n                }\n            }\n            ans[0] = \'A\' + t;\n            std::cout << ans << ""\\n"";\n            return;\n        }\n    }\n    std::cout << ""NO\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['constructive algorithms', 'dp', 'greedy']",2800
https://codeforces.com//contest/1153/problem/F,F. Serval and Bonus Problem,Getting closer and closer to a mathematician Serval becomes a university student on math major in Japari University On the Calculus class his teacher taught him how to calculate the expected length of a random subsegment of a given segment Then he left a bonus problem as homework with the award of a garage kit from IOI The bonus is to extend this problem to the general case as follows You are given a segment with length l We randomly choose n segments by choosing two points maybe with non integer coordinates from the given segment equiprobably and the interval between the two points forms a segment You are given the number of random segments n and another integer k The 2n endpoints of the chosen segments split the segment into 2n 1 intervals Your task is to calculate the expected total length of those intervals that are covered by at least k segments of the n random segments You should find the answer modulo 998244353 ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e3;\nconst int MOD = 998244353;\n\nint n, k, l;\n\nll inverse[2*MAXN+2], factorial[2*MAXN+2], inversefactorial[2*MAXN+2], power2[2*MAXN+2], dp[MAXN+1];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n >> k >> l;\n\t\n\tinverse[1]=1;\n\tfor(int i=2; i<2*MAXN+2; ++i)\n\t\tinverse[i]=MOD-MOD/i*inverse[MOD%i]%MOD;\n\n\tfactorial[0]=inversefactorial[0]=power2[0]=1;\n\tfor(int i=1; i<2*MAXN+2; ++i) {\n\t\tfactorial[i]=factorial[i-1]*i%MOD;\n\t\tinversefactorial[i]=inversefactorial[i-1]*inverse[i]%MOD;\n\t\tpower2[i]=power2[i-1]*2%MOD;\n\t}\n\n\tfor(int i=n; i>=k; --i) {\n\t\tdp[i] = factorial[i]*factorial[i]%MOD*power2[i]%MOD*inversefactorial[2*i+1]%MOD;\n\t\tdp[i] = dp[i]*factorial[n]%MOD*inversefactorial[i]%MOD*inversefactorial[n-i]%MOD;\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tdp[i] = (dp[i]-factorial[j]*inversefactorial[i]%MOD*inversefactorial[j-i]%MOD*dp[j]%MOD+MOD)%MOD;\n\t\t}\n\t}\n\n\tll ans=0;\n\tfor(int i=k; i<=n; ++i)\n\t\tans=(ans+dp[i])%MOD;\n\tcout << ans*l%MOD << endl;\n\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math', 'probabilities']",2600
https://codeforces.com//contest/1007/problem/B,B. Pave the Parallelepiped,You are given a rectangular parallelepiped with sides of positive integer lengths A B and C Find the number of different groups of three integers a b c such that 1 leq a leq b leq c and parallelepiped A times B times C can be paved with parallelepipeds a times b times c Note that all small parallelepipeds For example parallelepiped 1 times 5 times 6 can be divided into parallelepipeds 1 times 3 times 5 but can not be divided into parallelepipeds 1 times 2 times 3 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << ""["";\n    for (auto p: v) cout << p << "", "";\n    cout << ""]"";\n    return os;\n}\n\nconst int MN = 100100;\nV<int> fac[MN];\n\nvoid first() {\n    for (int i = 1; i < MN; i++) {\n        for (int j = i; j < MN; j += i) {\n            fac[j].push_back(i);\n        }\n    }\n}\n\nvoid calc() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    V<int> res_ab, res;\n    merge(begin(fac[a]), end(fac[a]), begin(fac[b]), end(fac[b]), back_inserter(res_ab));\n    merge(begin(res_ab), end(res_ab), begin(fac[c]), end(fac[c]), back_inserter(res));\n    res.erase(unique(begin(res), end(res)), end(res));\n\n    ll cnt[8] = {};\n    for (int d: res) {\n        int f = 0;\n        if (a % d == 0) f += 1;\n        if (b % d == 0) f += 2;\n        if (c % d == 0) f += 4;\n        assert(f);\n        cnt[f]++;\n    }\n    ll ans = 0;\n    for (int i = 1; i <= 7; i++) {\n        for (int j = i; j <= 7; j++) {\n            for (int k = j; k <= 7; k++) {\n                if ((i | j | k) != 7) continue;\n                if ((i == j || j == k) && (j == 1 || j == 2 || j == 4)) continue;\n\n                ll z = cnt[j];\n                if (i == j && j == k) {\n                    ans += z * (z+1) * (z+2) / 6;\n                    continue;\n                }\n                if (i == j) {\n                    ans += z * (z+1) * cnt[k] / 2;\n                    continue;\n                }\n                if (j == k) {\n                    ans += z * (z+1) * cnt[i] / 2;\n                    continue;                    \n                }\n                ans += cnt[i] * cnt[j] * cnt[k];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    first();\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        calc();\n    }\n    return 0;\n}\n']","['bitmasks', 'brute force', 'combinatorics', 'math', 'number theory']",2400
https://codeforces.com//contest/1141/problem/A,A. Game 23,Polycarp plays Game 23 Initially he has a number n and his goal is to transform it to m In one move he can multiply n by 2 or multiply n by 3 He can perform any number of moves Print the number of moves needed to transform n to m Print if it is impossible to do so It is easy to prove that any way to transform n to m contains the same number of moves i e number of moves doesn t depend on the way of transformation ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    ll n, m;\n    cin >> n >> m;\n\n    ll ans = 0;\n\n    if(m % n != 0){\n        cout << -1;\n        return 0;\n    }\n    else{\n        m /= n;\n        while(m % 3 == 0){\n            m /= 3;\n            ans++;\n        }\n        while(m % 2 == 0){\n            m /= 2;\n            ans++;\n        }\n        if(m == 1){\n            cout << ans;\n        }\n        else{\n            cout << -1;\n        }\n    }\n\n    return 0;\n}\n']","['implementation', 'math']",1000
https://codeforces.com//contest/1870/problem/G,G. MEXanization,Let s define f S Let S be a multiset i e it can contain repeated elements of non negative integers In one operation you can choose any non empty subset of S which can also contain repeated elements remove this subset all elements in it from S and add the MEX of the removed subset to S You can perform any number of such operations After all the operations S should contain exactly 1 number f S is the largest number that could remain in S after any sequence of operations You are given an array of non negative integers a of length n For each of its n prefixes calculate f S if S is the corresponding prefix for the i th prefix S consists of the first i elements of array a The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1 << 19;\nint n;\nint a[N];\nint ans[N];\nint cnt[N];\n\nstruct node {\n\tint r;\n\tll k0, b0; // time to go\n\tll k1, b1;\n};\n\nvector < node > con[N]; \n\nint up[N];\nvoid adjust(int x) {\n\twhile(true) {\n\t\tauto &tmp = con[x].back();\n\t\tif(tmp.r * tmp.k0 + tmp.b0 > up[x]) {\n\t\t\ttmp.r = (up[x] - tmp.b0) / tmp.k0;\n\t\t}\n\t\tif(sz(con[x]) > 1 && tmp.r <= con[x][sz(con[x]) - 2].r) {\n\t\t\tcon[x].pop_back();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tR(i, sz(con[x]) - 1, 1) \n\t\tif(con[x][i].r == con[x][i - 1].r + 1) {\n\t\t\tauto &tmp = con[x][i];\n\t\t\tll v1 = tmp.r * tmp.k0 + tmp.b0;\n\t\t\tll v2 = tmp.r * tmp.k1 + tmp.b1;\n\t\t\ttmp.k0 = 1, tmp.b0 = v1 - tmp.r;\n\t\t\ttmp.k1 = 1, tmp.b1 = v2 - tmp.r;\n\t\t}\n\tassert(sz(con[x]) <= 36);\n}\nvoid upd(int x) {\n\tauto &v2 = con[x * 2];\n\tauto &v1 = con[x * 2 + 1];\n\tcon[x].clear();\n\tll cur = 0;\n\tint p1 = 0, p2 = 0;\n\twhile(true) {\n\t\twhile(p1 < sz(v1) && v1[p1].r < cur) ++p1;\n\t\tif(p1 == sz(v1)) break;\n\t\tll valc = cur * v1[p1].k0 + v1[p1].b0;\n\t\twhile(p2 < sz(v2) && v2[p2].r < valc) ++p2;\n\t\tif(p2 == sz(v2)) break;\n\t\tll r1 = v1[p1].r;\n\t\tll r2 = (v2[p2].r - v1[p1].b0) / v1[p1].k0; \n\t\tnode nw;\n\t\tnw.r = min(r1, r2);\n\t\tnw.k0 = v1[p1].k0 * v2[p2].k0, nw.b0 = v1[p1].b0 * v2[p2].k0 + v2[p2].b0;\n\t\tnw.k1 = v1[p1].k0 * v2[p2].k1 + v1[p1].k1;\n\t\tnw.b1 = v1[p1].b0 * v2[p2].k1 + v1[p1].b1 + v2[p2].b1;\n\t\tcur = nw.r + 1;\n\t\tcon[x].emplace_back(nw);\n\t}\n\tadjust(x);\n}\nvoid make(int x, int p) {\n\tnode z0, z1;\n\tz0.r = cnt[p], z0.k0 = 1, z0.b0 = 0, z0.k1 = -1, z0.b1 = cnt[p]; \n\tz1.r = n, z1.k0 = 2, z1.b0 = -cnt[p], z1.k1 = 0, z1.b1 = 0;\n\tcon[x] = vector < node > {z0, z1};\n\tadjust(x);\n}\nvoid build(int x, int L, int R) {\n\tup[x] = n / max(L - 1, 1);\n\tif(L == R) {\n\t\tmake(x, L);\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tbuild(x * 2, L, mid);\n\tbuild(x * 2 + 1, mid + 1, R);\n\tupd(x);\n}\nvoid modify(int x, int L, int R, int p) {\n\tif(L == R) {\n\t\tmake(x, L);\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tp <= mid ? modify(x * 2, L, mid, p) : modify(x * 2 + 1, mid + 1, R, p);\n\tupd(x);\n}\n\nint need, zero, curp;\nvoid slv(int x, int L, int R, int l, int r) {\n\tif(l <= L && R <= r) {\n\t\tif(need > curp / R) {\n\t\t\tneed = n * 2;\n\t\t\treturn ;\n\t\t}\n\t\tint pos = 0;\n\t\twhile(pos < sz(con[x]) && con[x][pos].r < need) ++pos;\n\t\tif(pos == sz(con[x])) {\n\t\t\tneed = n * 2;\t\n\t\t} else {\n\t\t\tzero += con[x][pos].k1 * need + con[x][pos].b1;\n\t\t\tneed = con[x][pos].k0 * need + con[x][pos].b0;\n\t\t}\n//\t\tcout << ""after "" << L << \' \' << R << "" : "" << need << \' \' << zero\n//\t\t\t<<"", "" << con[x][pos].k0 << \' \' << con[x][pos].b0 << \' \' << \n//\t\t\t\tcon[x][pos].k1 << \' \' << con[x][pos].b1 << endl;\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tif(r > mid) slv(x * 2 + 1, mid + 1, R, l, r);\n\tif(l <= mid) slv(x * 2, L, mid, l, r);\n}\n\nint a1;\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\ta1 = a[1];\n\tL(i, 1, n) {\n\t\tif(a[i] > n) {\n\t\t\ta[i] = 0;\n\t\t}\n\t}\n\tL(i, 0, n) {\n\t\tcnt[i] = 0;\n\t}\n\t\n\tbuild(1, 0, n);\n\tint ns = 1;\n\tint SUM = 0;\n\tL(i, 1, n) {\n\t\tif(a[i] >= ns) {\n\t\t\t++SUM;\n\t\t}\n\t\t++cnt[a[i]];\n\t\tmodify(1, 0, n, a[i]);\n\t\tcurp = i;\n\t\twhile(ns <= i) {\n//\t\t\tcout << ""checking "" << ns << endl;\n\t\t\tneed = 1, zero = SUM + cnt[0]; \n\t\t\tif(1 < ns) slv(1, 0, n, 1, ns - 1);\n\t\t\tif(zero < need) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSUM -= cnt[ns];\n\t\t\t++ns;\n\t\t}\n\t\tans[i] = ns - 1;\n\t}\n\t\n\tans[1] = max(ans[1], a1);\n\tL(i, 1, n) {\n\t\tcout << ans[i] << \' \';\n\t}\n\tcout << \'\\n\';\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n']",['data structures'],3300
https://codeforces.com//contest/432/problem/A,A. Choosing Teams,The Saratov State University Olympiad Programmers Training Center SSU OPTC has students For each student you know the number of times he she has participated in the ACM ICPC world programming championship According to the ACM ICPC rules each person can participate in the world championship at most 5 times The head of the SSU OPTC is recently gathering teams to participate in the world championship Each team must consist of exactly three people at that any person cannot be a member of two or more teams What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least times ,"['#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint a, b, c, nom;\n\nint main(){\n    cin >> a >> b;\n    for(int i = 0; i < a; ++i){\n\tcin >> c;\n\tif(5 - b >= c) ++nom;\n    }\n    cout << nom / 3;\n  \n    return 0;\n}']","['greedy', 'implementation', 'sortings']",800
https://codeforces.com//contest/486/problem/B,B. OR in Matrix,Let s define logical as an operation on two logical values i e values that belong to the set that is equal to if either or both of the logical values is set to otherwise it is We can define logical of three or more logical values in the same manner where is equal to if some otherwise it is equal to Nam has a matrix consisting of rows and columns The rows are numbered from to columns are numbered from to Element at row and column is denoted as All elements of are either 0 or 1 From matrix Nam creates another matrix of the same size using formula is of all elements in row and column of matrix Nam gives you matrix and challenges you to guess matrix Although Nam is smart he could probably make a mistake while calculating matrix since size of can be large ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 110\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nchar map[maxn][maxn];\nint nRow,nCol,a[maxn][maxn];\nvoid read()\n{\n    cin>>nRow>>nCol;\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            map[i][j]=\'1\';\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n        {\n            scanf(""%d"",&a[i][j]);\n            if(!a[i][j])\n            {\n                for(int k=1;k<=nRow;++k)\n                    map[k][j]=\'0\';\n                for(int k=1;k<=nCol;++k)\n                    map[i][k]=\'0\';\n            }\n        }\n}\nvoid print()\n{\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            if(a[i][j])\n            {\n                int s=0;\n                for(int k=1;k<=nRow;++k)\n                    s+=map[k][j]-\'0\';\n                for(int k=1;k<=nCol;++k)\n                    s+=map[i][k]-\'0\';\n                if(!s)\n                {\n                    printf(""NO\\n"");\n                    return ;\n                }\n            }\n    printf(""YES\\n"");\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            printf(""%c%c"",map[i][j],j<nCol?\' \':\'\\n\');\n}\nint main()\n{\n    read();\n    print();\n    return 0;\n}\n']","['greedy', 'hashing', 'implementation']",1300
https://codeforces.com//contest/1691/problem/F,F. K-Set Tree,You are given a tree G with n vertices and an integer k The vertices of the tree are numbered from 1 to n For a vertex r and a subset S of vertices of G such that S k we define f r S as the size of the smallest rooted subtree containing all vertices in S when the tree is rooted at r A set of vertices T is called a rooted subtree if all the vertices in T are connected and for each vertex in T all its descendants belong to T You need to calculate the sum of f r S over of vertices r and subsets S where S k Formally compute the following sum r in V sum S subseteq V S k f r S where V is the set of vertices in G Output the answer modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n//constexpr int mod = 998244353;\nconstexpr int mod = 1e9 + 7;\n\nint reduce(int x) {\n\tif(x < 0) x += mod;\n\tif(x >= mod) x -= mod;\n\treturn x;\n}\n\ntemplate < typename T > T qp(T x, ll t) { T res = 1; for(; t; t >>= 1, x *= x) if(t & 1) res *= x; return res; }\n\nstruct Z { // modint\n\tint x;\n\tZ(int x = 0) : x(reduce(x)) {}\n\tZ(ll x) : x(reduce(x % mod)) {}\n\tZ operator -() const { return Z(reduce(mod - x)); }\n\tint val() { return x; }\n\tZ inv() const { assert(x); return qp(*this, mod - 2); }\n\tZ &operator += (const Z &t) { x = reduce(x + t.x); return *this; }\n\tZ &operator -= (const Z &t) { x = reduce(x - t.x); return *this; }\n\tZ &operator *= (const Z &t) { x = (ll)x * t.x % mod; return *this; }\n\tZ &operator /= (const Z &t) { return *this *= t.inv(); }\n\tfriend Z operator + (const Z &a, const Z &b) { Z res = a; res += b; return res; }\n\tfriend Z operator - (const Z &a, const Z &b) { Z res = a; res -= b; return res; }\n\tfriend Z operator * (const Z &a, const Z &b) { Z res = a; res *= b; return res; }\n\tfriend Z operator / (const Z &a, const Z &b) { Z res = a; res /= b; return res; }\n};\n\nZ fac[N], ifac[N];\nZ C(int x, int y) { return x < 0 || y < 0 || x < y ? Z(0) : fac[x] * ifac[y] * ifac[x - y]; }\nvoid init(int l) {\n\tfac[0] = 1; rep(i, 1, l) fac[i] = fac[i - 1] * Z(i); ifac[l] = fac[l].inv();\n\tper(i, l - 1, 0) ifac[i] = ifac[i + 1] * Z(i + 1);\n}\n\nint n, K, siz[N], fa[N];\nZ ret[N], ans;\nvec G[N];\n\nvoid dfs(int x, int p) {\n\tsiz[x] = 1; fa[x] = p;\n\tfor(auto y : G[x]) if(y ^ p) {\n\t\t\tdfs(y, x); siz[x] += siz[y]; ret[x] += C(siz[y], K);\n\t\t}\n\tret[x] += C(n - siz[x], K);\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tn = in, K = in; rep(i, 2, n) { int u = in, v = in; G[u].eb(v), G[v].eb(u); }\n\tinit(n); dfs(1, 0);\n\trep(x, 1, n) {\n\t\tfor(auto y : G[x])\n\t\t\tif(y == fa[x]) {\n\t\t\t\tZ t = (n - siz[x]) * (C(siz[x], K) - (ret[x] - C(n - siz[x], K))) * siz[x];\n\t\t\t\tans += t;\n\t\t\t} else {\n\t\t\t\tZ t = siz[y] * (C(n - siz[y], K) - (ret[x] - C(siz[y], K))) * (n - siz[y]);\n\t\t\t\tans += t;\n\t\t\t}\n\t\tans += (C(n, K) - ret[x]) * n;\n\t}\n\tcout << ans.val() << endl;\n\treturn 0;\n}\n']","['combinatorics', 'dfs and similar', 'dp', 'math', 'trees']",2500
https://codeforces.com//contest/1895/problem/B,B. Points and Minimum Distance,You are given a sequence of integers a of length 2n You have to split these 2n integers into n pairs each pair will represent the coordinates of a point on a plane Each number from the sequence a should become the x or y coordinate of exactly one point Note that some points can be equal After the points are formed you have to choose a path s that starts from one of these points ends at one of these points and visits all n points at least once The length of path s is the sum of distances between all adjacent points on the path In this problem the distance between two points x 1 y 1 and x 2 y 2 is defined as x 1 x 2 y 1 y 2 Your task is to form n points and choose a path s in such a way that the length of path s is minimized ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<int> A(N*2);\n\trep(i,0,N*2) cin>>A[i];\n\tSo(A);\n\tint ans=0;\n\trep(i,1,N*2) if(i!=N) ans+=A[i]-A[i-1];\n\tcout<<ans<<""\\n"";\n\trep(i,0,N) cout<<A[i]<<"" ""<<A[i+N]<<""\\n"";\n}']","['greedy', 'math', 'sortings']",800
https://codeforces.com//contest/313/problem/A,A. Ilya and Bank Account,Ilya is a very clever lion he lives in an unusual city ZooVille In this city all the animals have their rights and obligations Moreover they even have their own bank accounts The state of a bank account is an integer The state of a bank account can be a negative number This means that the owner of the account owes the bank money Ilya the Lion has recently had a birthday so he got a lot of gifts One of them the gift of the main ZooVille bank is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once For example if the state of Ilya s bank account is 123 then Ilya can delete the last digit and get his account balance equal to 12 also he can remove its digit before last and get the account balance equal to 13 Of course Ilya is permitted not to use the opportunity to delete a digit from the balance Ilya is not very good at math and that s why he asks you to help him maximize his bank account Find the maximum state of the bank account that can be obtained using the bank s gift ,"['#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n, a, b, c;\n\tbool flag;\n\tscanf(""%d"", &n);\n\tif (n > 0) flag = 0; else flag = 1;\n\tn = abs(n);\n\ta = n;\n\tb = n / 10;\n\tc = b / 10 * 10 + n % 10;\n\tif (flag)\n\t\ta = -a, b = -b, c = -c;\n\tprintf(""%d\\n"", max(a, max(b, c)));\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n']","['implementation', 'number theory']",900
https://codeforces.com//contest/1173/problem/A,A. Nauuo and Votes,Nauuo is a girl who loves writing comments One day she posted a comment on Codeforces wondering whether she would get upvotes or downvotes It s known that there were x persons who would upvote y persons who would downvote and there were also another z persons who would vote but you don t know whether they would upvote or downvote Note that each of the x y z people would vote exactly one time There are three different results if there are more people upvote than downvote the result will be if there are more people downvote than upvote the result will be otherwise the result will be 0 Because of the z unknown persons the result may be uncertain i e there are more than one possible results More formally the result is uncertain if and only if there exist two different situations of how the z persons vote that the results are different in the two situations Tell Nauuo the result or report that the result is uncertain ,"['//2019.6.7 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n//inline void add(res &x,const res &y,const res &kcz){\n//    x+=y,x>=kcz?x-=kcz:(x<0?x+=kcz:1);\n//}\n//inline int Add(const res &x,const res &y,const res &kcz){\n//    return x+y>=kcz?x+y-kcz:(x+y<0?x+y+kcz:x+y);\n//}\n//inline int mul(const res &x,const res &y,const res &kcz){\n//    return int(1LL*x*y%kcz);\n//}\n//inline int qpow(res x,res y,const res &kcz){\n//    res ret=1;\n//    while(y){\n//        if(y&1)ret=mul(ret,x,kcz);\n//        y>>=1,x=mul(x,x,kcz);\n//    }\n//    return ret;\n//}\n #define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<\'0\'||ch>\'9\')ch=gc();\n    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=gc();}\n//    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<\'0\'||ch>\'9\')ch=gc();\n//    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=gc();}\n//    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n//    return s*w;\n//}\n//inline void swap(res &x,res &y) {\n//    x^=y^=x^=y;\n//}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nnamespace MAIN {\n    int x,y,z;\n    inline void MAIN(){\n        x=read(),y=read(),z=read();\n        bool fl1=0,fl2=0;\n        if(x>y+z){puts(""+"");return;}\n        if(y>x+z){puts(""-"");return;}\n        if(z==0&&x==y){puts(""0"");return;}\n        puts(""?"");\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n    // freopen(""zao.in"",""r"",stdin);\n    // freopen(""std.out"",""w"",stdout);\n    MAIN::MAIN();\n    return 0;\n}']",['greedy'],800
https://codeforces.com//contest/490/problem/F,F. Treeland Tour,The Road Accident band is planning an unprecedented tour around Treeland The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have Treeland consists of cities some pairs of cities are connected by bidirectional roads Overall the country has roads We know that it is possible to get to any city from any other one The cities are numbered by integers from 1 to For every city we know its value the number of people in it We know that the band will travel along some path having concerts in cities along the path The band s path will not pass one city twice each time they move to the city that hasn t been previously visited Thus the musicians will travel along some path without visiting any city twice and in some not necessarily all cities along the way they will have concerts The band plans to gather all the big stadiums and concert halls during the tour so every time they will perform in a city which population is than the population of the previously visited city In other words the sequence of population in the cities where the concerts will be held is In a recent interview with the leader of the road accident band promised to the fans that the band will in the largest possible number of cities Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities so that the population number will increase and the number of concerts will be the largest possible The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland Looks like they can t manage without some help from a real programmer Help the fans find the sought number of concerts ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct node{\n     node *next;\n     int where;\n} *first[10001], a[100001];\n\nint ans, l, v[10001], dist[10001], n, c[10001], f[10001], len;\nbool b[6001];\n\ninline void makelist(int x, int y){\n     a[++l].where = y;\n     a[l].next = first[x];\n     first[x] = &a[l];\n}\n\ninline void soso(int now){\n     b[now] = true;\n     if (!len || v[now] > f[len]) \n     {\n          f[++len] = v[now];\n          ans = max(ans, len); \n          for (node *x = first[now]; x; x = x->next) \n               if (!b[x->where]) soso(x->where);\n          --len;\n     }\n     else\n     {\n          int Left = 0, Right = len, Mid = (Left + Right) >> 1;\n          for (; Left + 1 < Right; Mid = (Left + Right) >> 1)\n               if (v[now] > f[Mid]) Left = Mid;\n               else Right = Mid;\n          if (v[now] < f[Right]) \n          {\n               int dhh = f[Right];\n               f[Right] = v[now];\n               for (node *x = first[now]; x; x = x->next) \n                    if (!b[x->where]) soso(x->where);\n               f[Right] = dhh;\n          }\n          else\n               for (node *x = first[now]; x; x = x->next) \n                    if (!b[x->where]) soso(x->where);\n     }\n}         \n          \nint main(){\n    // freopen(""f.in"", ""r"", stdin);\n    // freopen(""f.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 1; i <= n; i++) scanf(""%d"", &v[i]);\n     memset(first, 0, sizeof(first)); l = 0;\n     for (int i = 1; i < n; i++)\n     {\n          int x, y;\n          scanf(""%d%d"", &x, &y);\n          makelist(x, y); makelist(y, x);\n     }\n     ans = 0;\n     for (int i = 1; i <= n; i++)\n     {\n          memset(b, false, sizeof(b));\n          len = 0; \n          soso(i);\n     }\n     printf(""%d\\n"", ans);\n}\n']","['data structures', 'dfs and similar', 'dp', 'trees']",2200
https://codeforces.com//contest/1859/problem/B,B. Olya and Game with Arrays,Artem suggested a game to the girl Olya There is a list of n arrays where the i th array contains m i ge 2 positive integers a i 1 a i 2 ldots a i m i Olya can move possibly 0 integer from array to another array Note that integers can be moved from one array only once but integers can be added to one array and all the movements are done The of the list of arrays is defined as the sum sum i 1 n min j 1 m i a i j In other words for each array we find the minimum value in it and then sum up these values The goal of the game is to maximize the beauty of the list of arrays Help Olya win this challenging game ,"['#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt"")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include""dbg.h""\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return\'\\n\';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between \'\\n\'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<\'0\'||c>\'9\'){if(c==\'-\')f*=-1;c=getchar();}x=0;while(c>=\'0\'&&c<=\'9\'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<\'0\'||c>\'9\')&&c!=\'-\'&&c!=\'.\'){if(c==\'-\')f*=-1;c=getchar();}while(c>=\'0\'&&c<=\'9\'&&c!=\'.\')x=x*10+(c^48),c=getchar();if(c==\'.\')c=getchar();else return x*=f,*this;while(c>=\'0\'&&c<=\'9\')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str[len++]=c,c=getchar();str[len]=\'\\0\';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl=\'\\n\';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<\'\\n\';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar(\'0\'),*this;if(x<0)putchar(\'-\'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar(\'-\'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;putchar(\'.\');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tint sum=0,mi=1000000000,mii=1000000000;\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tint m;\n\t\t\tcin>>m;\n\t\t\tvector<int>b(m);\n\t\t\tcin>>b;\n\t\t\tsort(b.begin(),b.end());\n\t\t\tsum+=b[1];\n\t\t\tmi=min(mi,b[0]),mii=min(mii,b[1]);\n\t\t}\n\t\tcout<<sum+mi-mii<<endl;\n\t}\n}']","['constructive algorithms', 'greedy', 'math', 'sortings']",1000
https://codeforces.com//contest/873/problem/B,B. Balanced Substring,You are given a string consisting only of characters and A substring of is a string and its length equals to A substring is called if the number of zeroes equals to the number of ones in this substring You have to determine the length of the longest substring of ,"['#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(""input.txt"");\n\t//ofstream cout(""output.txt"");\n\n\tint n;\n\tcin >> n;\n\n\tmap<int, int> mapa;\n\tstring s;\n\tcin >> s;\n\n\tint x = 0, y = 0;\n\tmapa[0] = -1;\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == \'0\') {\n\t\t\t++x;\n\t\t} else {\n\t\t\t++y;\n\t\t}\n\t\tif (mapa.count(y - x)) {\n\t\t\tans = max(ans, i - mapa[y - x]);\n\t\t} else {\n\t\t\tmapa[y - x] = i;\n\t\t}\t\t\n\t}\n\n\tcout << ans << ""\\n"";\n\n}']","['dp', 'implementation']",1500
https://codeforces.com//contest/1730/problem/B,B. Meeting on the Line,n people live on the coordinate line the i th one lives at the point x i 1 le i le n They want to choose a position x 0 to meet The i th person will spend x i x 0 minutes to get to the meeting place Also the i th person needs t i minutes to get dressed so in total he or she needs t i x i x 0 minutes Here y denotes the absolute value of y These people ask you to find a position x 0 that minimizes the time in which all n people can gather at the meeting place ,"['#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2"")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1e9+7;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret="""";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint T,n;\nint x[100005],t[100005];\nbool check(int cur){\n\tint lb=-2e9,rb=2e9;\n\tfor(int i=1;i<=n;i++){\n\t\tlb=max(lb,x[i]-(cur-t[i]));\n\t\trb=min(rb,x[i]+(cur-t[i]));\n\t}\n\treturn lb<=rb;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++)cin>>x[i],x[i]*=2;\n\t\tfor(int i=1;i<=n;i++)cin>>t[i],t[i]*=2;\n\t\tint l=*max_element(t+1,t+n+1)-1,r=1e9;\n\t\twhile(r-l>1){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(check(mid))r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tint cur=r;\n\t\tint lb=-2e9,rb=2e9;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tlb=max(lb,x[i]-(cur-t[i]));\n\t\t\trb=min(rb,x[i]+(cur-t[i]));\n\t\t}\n//\t\tcerr<<lb<<"" ""<<rb<<endl;\n//\t\tif(lb!=rb)assert(0);\n\t\tprintf(""%lf\\n"",lb/2.0);\n\t}\n\treturn 0;\n}']","['binary search', 'geometry', 'greedy', 'implementation', 'math', 'ternary search']",1600
https://codeforces.com//contest/914/problem/F,F. Substrings in a String,Given a string process queries each having one of the following forms Change the th character in the string to Consider the substring of starting at position and ending at position Output the number of times occurs as a substring in it ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<bitset>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nchar s[N];\nchar t[N];\nint n,Q;\nbitset<N>f[27];\nint main(){\n\tscanf(""%s"",s+1);\n\tn=strlen(s+1);\n\trep(i,1,n)f[s[i]-\'a\'][i]=1;\n\tscanf(""%d"",&Q);\n\twhile(Q--){\n\t\tint ty;scanf(""%d"",&ty);\n\t\tif(ty==1){\n\t\t\tint x;char ss[4];scanf(""%d"",&x);scanf(""%s"",ss);\n\t\t\tf[s[x]-\'a\'][x]=0;\n\t\t\ts[x]=ss[0];\n\t\t\tf[s[x]-\'a\'][x]=1;\n\t\t}\n\t\telse{\n\t\t\tint l,r;scanf(""%d%d"",&l,&r);\n\t\t\tscanf(""%s"",t+1);\n\t\t\tint len=strlen(t+1);\n\t\t\tr-=len-1;\n\t\t\tif(r<l){\n\t\t\t\tputs(""0"");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbitset<N> gt;gt.reset();gt=~gt;\n\t\t\trep(i,1,len)gt&=(f[t[i]-\'a\']>>(i-1));\n\n\t\t\tgt>>=l;\n\t\t\tint ans=gt.count();\n\t\t\tgt>>=(r-l+1);\n\t\t\tans-=gt.count();\n\t\t\tprintf(""%d\\n"",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n']","['bitmasks', 'brute force', 'data structures', 'string suffix structures', 'strings']",3000
https://codeforces.com//contest/1810/problem/G,G. The Maximum Prefix,You re going to generate an array a with a length of at most n where each a i equals either 1 or 1 You generate this array in the following way First you choose some integer k 1 le k le n which decides the length of a Then for each i 1 le i le k you set a i 1 with probability p i otherwise set a i 1 with probability 1 p i After the array is generated you calculate s i a 1 a 2 a 3 ldots a i Specially s 0 0 Then you let S equal to displaystyle max i 0 k s i That is S is the maximum prefix sum of the array a You are given n 1 integers h 0 h 1 ldots h n The of an array a with maximum prefix sum S is h S Now for each k you want to know the expected score for an array of length k modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = 1;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 1;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<Z> p(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        p[i] = Z(x) / y;\n    }\n    \n    std::vector<Z> h(n + 1);\n    for (int i = 0; i <= n; i++) {\n        std::cin >> h[i];\n    }\n    \n    for (int k = 1; k <= n; k++) {\n        std::vector<Z> g(n + 1);\n        g[0] += h[0] * (1 - p[k - 1]);\n        g[1] += h[0] * (1 - p[k - 1]);\n        for (int i = 1; i <= n; i++) {\n            g[i - 1] += h[i] * p[k - 1];\n            if (i < n) {\n                g[i + 1] += h[i] * (1 - p[k - 1]);\n            }\n        }\n        h = std::move(g);\n        Z ans = h[0];\n        std::cout << ans << "" \\n""[k == n];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",['dp'],3200
https://codeforces.com//contest/1767/problem/D,D. Playoff,2 n teams participate in a playoff tournament The tournament consists of 2 n 1 games They are held as follows in the first phase of the tournament the teams are split into pairs team 1 plays against team 2 team 3 plays against team 4 and so on so 2 n 1 games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only 2 n 1 teams remain If only one team remains it is declared the champion otherwise the second phase begins where 2 n 2 games are played in the first one of them the winner of the game 1 vs 2 plays against the winner of the game 3 vs 4 then the winner of the game 5 vs 6 plays against the winner of the game 7 vs 8 and so on This process repeats until only one team remains The skill level of the i th team is p i where p is a permutation of integers 1 2 2 n a permutation is an array where each element from 1 to 2 n occurs exactly once You are given a string s which consists of n characters These characters denote the results of games in each phase of the tournament as follows if s i is equal to then during the i th phase the phase with 2 n i games in each match the team with the lower skill level wins if s i is equal to then during the i th phase the phase with 2 n i games in each match the team with the higher skill level wins Let s say that an integer x is if it is possible to find a permutation p such that the team with skill x wins the tournament Find all winning integers ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nint n;\nint dp[2][N];\nchar s[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tscanf("" %s"", s);\n\treverse(s, s + n);\n\tdp[0][0] = 1;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i <= (1 << (k + 1)); i++)\n\t\t\tdp[1][i] = 0;\n\t\tfor (int w = 0; w < (1 << k); w++) if (dp[0][w]) {\n\t\t\tint curW = w;\n\t\t\tint curL = (1 << k) - 1 - w;\n\t\t\tint l, r;\n\t\t\tif (s[k] == \'0\') {\n\t\t\t\tl = curL;\n\t\t\t\tr = 2 * curL;\n\t\t\t\tswap(l, r);\n\t\t\t\tl = (1 << (k + 1)) - 1 - l;\n\t\t\t\tr = (1 << (k + 1)) - 1 - r;\n\t\t\t} else {\n\t\t\t\tl = curW;\n\t\t\t\tr = 2 * curW;\n\t\t\t}\n\t\t\tdp[1][l]++;\n\t\t\tdp[1][r + 1]--;\n\t\t}\n\t\tint bal = 0;\n\t\tfor (int i = 0; i < (1 << (k + 1)); i++) {\n\t\t\tbal += dp[1][i];\n\t\t\tdp[0][i] = min(1, bal);\n\t\t}\n\t}\n\tfor (int i = (1 << n) - 1; i >= 0; i--) if (dp[0][i])\n\t\tprintf(""%d "", (1 << n) - i);\n\n\treturn 0;\n}\n']","['combinatorics', 'constructive algorithms', 'dp', 'greedy', 'math']",1500
https://codeforces.com//contest/1735/problem/D,D. Meta-set,You like the card board game Set Each card contains k features each of which is equal to a value from the set 0 1 2 The deck contains all possible variants of cards that is there are 3 k different cards in total A feature for three cards is called if it is the same for these cards or pairwise distinct Three cards are called a if all k features are good for them For example the cards 0 0 0 0 2 1 and 0 1 2 form a set but the cards 0 2 2 2 1 2 and 1 2 0 do not as for example the last feature is not good A group of cards is called a if there is strictly more than one set among them How many meta sets there are among given n distinct cards ,"[""// LUOGU_RID: 91547278\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+'0');\n}\n#define writesp(x) write(x),putchar(' ')\n#define writeln(x) write(x),putchar('\\n')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=1010;\n\nint n,k;\n\nstruct Node {\n\tint c[24];\n\tvoid init() {\n\t\trep(i,1,k) c[i]=read();\n\t}\n} a[N];\nNode operator + (const Node& a,const Node& b) {\n\tNode ret;\n\trep(i,1,k) ret.c[i]=(3-(a.c[i]+b.c[i])%3)%3;\n\treturn ret;\n}\n\null cal(Node x) {\n\tull ret=0;\n\trep(i,1,k) {\n\t\tret=ret*3ll+x.c[i];\n\t}\n\treturn ret;\n}\n\nmap<ull,int> M;\n\nint main() {\n\tn=read(),k=read();\n\trep(i,1,n) a[i].init();\n\tM.clear();\n\trep(i,1,n) rep(j,i+1,n) {\n\t\tNode res=a[i]+a[j];\n\t\tM[cal(res)]++;\n\t}\n\tll ans=0;\n\trep(i,1,n) {\n\t\tll cnt=M[cal(a[i])];\n\t\tans+=1ll*cnt*(cnt-1)/2;\n\t}\n\twriteln(ans);\n\treturn 0;\n}\n""]","['brute force', 'combinatorics', 'data structures', 'hashing', 'math']",1700
https://codeforces.com//contest/1909/problem/D,D. Split Plus K,There are n positive integers a 1 a 2 dots a n on a blackboard You are also given a positive integer k You can perform the following operation some possibly 0 times choose a number x on the blackboard erase one occurrence of x write two integers y z such that y z x k on the blackboard Is it possible to make all the numbers on the blackboard equal If yes what is the minimum number of operations you need ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi a=readvi(n,-k);\n\tif(a==vi(n,0))return print(0);\n\tsoin(a);\n\t\n\tif(0<a[0]){\n\t\t\n\t}else if(a[n-1]<0){\n\t\t\n\t}else{\n\t\treturn print(-1);\n\t}\n\tint g=0;\n\tfor(auto v:a)g=gcd(g,v);\n\tint ans=0;\n\tfor(auto v:a){\n\t\tans+=abs(v/g);\n\t}\n\tprint(ans-n);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['greedy', 'math', 'number theory']",1900
https://codeforces.com//contest/1023/problem/A,A. Single Wildcard Pattern Matching,You are given two strings s and t The string s consists of lowercase Latin letters and wildcard character the string t consists only of lowercase Latin letters The length of the string s equals n the length of the string t equals m The wildcard character in the string s if any can be replaced with an arbitrary sequence possibly empty of lowercase Latin letters No other character of s can be replaced with anything If it is possible to replace a wildcard character in s to obtain a string t then the string t matches the pattern s For example if s then the following strings match it and but the following strings do not match If the given string t matches the given string s print otherwise print ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nstring s1, s2;\n\nint main(){\n\tcin >> n >> m;\n\tcin >> s1 >> s2;\n\tint idx = -1;\n\tfor(int i=0; i<n; i++){\n\t\tif(s1[i] == \'*\') idx = i;\n\t}\n\tif(idx == -1){\n\t\tputs(s1 == s2 ? ""YES"" : ""NO"");\n\t\treturn 0;\n\t}\n\tint rem = m - (n - 1);\n\tif(rem < 0){\n\t\tputs(""NO"");\n\t\treturn 0;\n\t}\n\ts1 = s1.substr(0, idx) + s2.substr(idx, rem) + s1.substr(idx + 1, n - idx - 1);\n\tputs(s1 == s2 ? ""YES"" : ""NO"");\n\treturn 0;\n}\n']","['brute force', 'implementation', 'strings']",1200
https://codeforces.com//contest/1649/problem/B,B. Game of Ball Passing,Daniel is watching a football team playing a game during their training session They want to improve their passing skills during that session The game involves n players making multiple passes towards each other Unfortunately since the balls were moving too fast after the session Daniel is unable to know how many balls were involved during the game The only thing he knows is the number of passes delivered by each player during all the session Find the minimum possible amount of balls that were involved in the game ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#ifndef ONLINE_JUDGE\n#include ""debug.h""\n#else\n#define deb(...) 4\n#endif\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>v(n);\n\t\tfor(int i=0;i<n;i++) cin>>v[i];\n\t\tint sm=0;\n\t\tfor(auto x:v) sm+=x;\n\t\tif(sm==0){\n\t\t\tcout<<""0\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tint mx=*max_element(v.begin(),v.end());\n\t\tcout<<1+max(0LL,mx-sm+mx-1)<<\'\\n\';\n\t}\n\treturn 0;\n}']","['greedy', 'implementation']",1300
https://codeforces.com//contest/1671/problem/B,B. Consecutive Points Segment,You are given n points with integer coordinates on a coordinate axis OX The coordinate of the i th point is x i All points coordinates are distinct and given in strictly increasing order For each point i you can do the following operation take this point and move it by 1 to the left or to the right i e you can change its coordinate x i to x i 1 or to x i 1 In other words for each point you choose separately its new coordinate For the i th point it can be either x i 1 x i or x i 1 Your task is to determine if you can move some points as described above in such a way that the new set of points forms a of integers i e for some integer l the coordinates of points should be equal to l l 1 ldots l n 1 Note that the resulting points should have coordinates You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:36:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n      a[i] -= i;\n    }\n    int L = *min_element(a.begin(), a.end());\n    int R = *max_element(a.begin(), a.end());\n    cout << (R - L <= 2 ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'math', 'sortings']",1000
https://codeforces.com//contest/268/problem/C,C. Beautiful Sets of Points,Manao has invented a new mathematical term a beautiful set of points He calls a set of points on a plane if it meets the following conditions The coordinates of each point in the set are integers For any two points from the set the distance between them is a non integer Consider all points which satisfy the inequations Choose their subset of maximum size such that it is also a beautiful set of points ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint main()\n{\n  int i,j,m,n;\n  scanf(""%d%d"",&n,&m);\n  if (n<m) printf(""%d\\n"",n+1);\n  else printf(""%d\\n"",m+1);\n  for (i=0;i<=n&&i<=m;i++)\n  {\n    printf(""%d %d\\n"",i,m-i);\n  }\n}\n']","['constructive algorithms', 'implementation']",1500
https://codeforces.com//contest/1858/problem/D,D. Trees and Segments,The teachers of the Summer Informatics School decided to plant n trees in a row and it was decided to plant only oaks and firs To do this they made a plan which can be represented as a binary string s of length n If s i 0 then the i th tree in the row should be an oak and if s i 1 then the i th tree in the row should be a fir The day of tree planting is tomorrow and the day after tomorrow an inspector will come to the School The inspector loves nature very much and he will evaluate the beauty of the row as follows First he will calculate l 0 as the maximum number of consecutive oaks in the row the maximum substring consisting of zeros in the plan s If there are no oaks in the row then l 0 0 Then he will calculate l 1 as the maximum number of consecutive firs in the row the maximum substring consisting of ones in the plan s If there are no firs in the row then l 1 0 Finally he will calculate the of the row as a cdot l 0 l 1 for some a the inspector s favourite number The teachers know the value of the parameter a but for security reasons they cannot tell it to you They only told you that a is an integer from 1 to n Since the trees have not yet been planted the teachers decided to change the type of no more than k trees to the opposite i e change s i from 0 to 1 or from 1 to 0 in the plan in order to maximize the beauty of the row of trees according to the inspector For each integer j from 1 to n answer the following question What is the maximum beauty of the row of trees that the teachers can achieve by changing the type of no more than k trees if the inspector s favourite number a is equal to j ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""debug.h""\n#else\n#define debug(...)\n#endif\n\nconst int N = 3005;\n\nint n, k;\nstring s;\nint mx1[N + 1];\nint ps[N + 1];\nint f[N + 1][N];\nint g[N + 1][N];\n\nint sum(int l, int r) { return ps[r + 1] - ps[l]; }\n\nvoid solve() {\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == \'1\');\n  for (int op = 0; op <= k; op++) {\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n      while (j <= i && sum(j, i) > op) j++;\n      if (j <= i) {\n        f[op][i] = i - j + 1;\n      } else {\n        f[op][i] = -1e9;\n      }\n      if (i > 0) f[op][i] = max(f[op][i], f[op][i - 1]);\n    }\n  }\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == \'0\');\n  for (int op = 0; op <= k; op++) {\n    int j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n      while (j >= i && sum(i, j) > op) j--;\n      if (j >= i) {\n        g[op][i] = j - i + 1;\n      } else {\n        g[op][i] = -1e9;\n      }\n      if (i < n - 1) g[op][i] = max(g[op][i], g[op][i + 1]);\n    }\n  }\n  for (int u = 0; u <= k; u++) {\n    if (f[u][n - 1] >= 0) {\n      mx1[f[u][n - 1]] = max(mx1[f[u][n - 1]], 0);\n    }\n    if (g[u][0] >= 0) {\n      mx1[0] = max(mx1[0], g[u][0]);\n    }\n    for (int i = 0; i < n - 1; i++) {\n      if (f[u][i] >= 0) {\n        mx1[f[u][i]] = max(mx1[f[u][i]], g[k - u][i + 1]);\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    cin >> s;\n    for (int i = 0; i <= n; i++) {\n      mx1[i] = -1e9;\n    }\n    solve();\n    reverse(s.begin(), s.end());\n    solve();\n    for (int a = 1; a <= n; a++) {\n      int ans = 0;\n      for (int i = 0; i <= n; i++) ans = max(ans, i * a + mx1[i]);\n      cout << ans << "" \\n""[a == n];\n    }\n  }\n}']","['brute force', 'data structures', 'dp', 'greedy', 'two pointers']",2200
https://codeforces.com//contest/1285/problem/D,D. Dr. Evil Underscores,Today as a friendship gift Bakry gave Badawy n integers a 1 a 2 dots a n and challenged him to choose an integer X such that the value underset 1 leq i leq n max a i oplus X is minimum possible where oplus denotes the bitwise XOR operation As always Badawy is too lazy so you decided to help him and find the minimum possible value of underset 1 leq i leq n max a i oplus X ,"['#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nconst int maxn = 100100, lg = 30;\nint to[maxn * lg][2], nds = 1;\nvoid insert(int x){\n\tint cur = 0;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tint & v = to[cur][(x>>i)&1];\n\t\tif(v == 0) v = nds++;\n\t\tcur = v;\n\t}\n}\nint get(int r, int b){\n\tif(to[r][0] == 0 && to[r][1] == 0) return 0;\n\tif(to[r][0] == 0) return get(to[r][1], b - 1);\n\tif(to[r][1] == 0) return get(to[r][0], b - 1);\n\treturn min(get(to[r][0], b - 1), get(to[r][1], b - 1)) + (1<<b);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tinsert(x);\n\t}\n\tcout << get(0, 29) << endl;\n\treturn 0;\n}\n']","['bitmasks', 'brute force', 'dfs and similar', 'divide and conquer', 'dp', 'greedy', 'strings', 'trees']",1900
https://codeforces.com//contest/446/problem/C,C. DZY Loves Fibonacci Numbers,In mathematical terms the sequence of Fibonacci numbers is defined by the recurrence relation DZY loves Fibonacci numbers very much Today DZY gives you an array consisting of integers Moreover there are queries each query has one of the two types Format of the query In reply to the query you need to add to each element where Format of the query In reply to the query you should output the value of modulo Help DZY reply to all the queries ,"['#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n#include <cassert>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n#define prev PREV\n#define j0 j1347829\n#define j1 j234892\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nconst int mod = 1000*1000*1000+9;\nconst int N = 300000;\nconst int M = 1 << 19;\n\nint n;\nint m;\nii f[N + 1];\nii s[N + 1];\nint tree[2 * M + 10];\nii add[2 * M + 10];\nint x[N + 1];\n\nii mrg (ii a, ii b) {\n    re mp ((a.fi + b.fi) % mod, (a.se + b.se) % mod);\n}\n\nint build (int x, int l, int r) {\n    if (l == r) re tree[x] = ::x[l];\n    int s = (l + r) / 2;\n    re tree[x] = (build (x * 2 + 1, l, s) + build (x * 2 + 2, s + 1, r)) % mod;\n}\n\nii shift (ii x, int len) {\n    int a = ((ll)f[len + 1].fi * x.fi + (ll)f[len + 1].se * x.se) % mod;\n    int b = ((ll)f[len + 2].fi * x.fi + (ll)f[len + 2].se * x.se) % mod;\n    re mp (a, b);\n}\n\nint getsum (ii x, int len) {\n    re ((ll)s[len].fi * x.fi + (ll)s[len].se * x.se) % mod;\n}\n\nint push (int x, int l, int r) {\n    if (add[x].fi == 0 && add[x].se == 0) re 0;\n    if (l != r) {\n        int s = (l + r) / 2;\n        add[x * 2 + 1] = mrg (add[x * 2 + 1], add[x]);\n        add[x * 2 + 2] = mrg (add[x * 2 + 2], shift (add[x], s - l + 1));\n    }\n    tree[x] = (tree[x] + getsum (add[x], r - l + 1)) % mod;\n    add[x] = mp (0, 0);\n    re 0;\n}     \n\nint get (int x, int l, int r, int lc, int rc) {\n    push (x, l, r);\n    if (r < lc || l > rc) re 0;\n    if (l >= lc && r <= rc) re tree[x];\n    int s = (l + r) / 2;\n    re (get (x * 2 + 1, l, s, lc, rc) + get (x * 2 + 2, s + 1, r, lc, rc)) % mod;\n}       \n\nint upd (int x, int l, int r, int lc, int rc, ii y) {\n    push (x, l, r);\n    if (r < lc || l > rc) re tree[x];\n    if (l >= lc && r <= rc) {\n        y = shift (y, l - lc);\n        add[x] = mrg (add[x], y);\n        push (x, l, r);\n        re tree[x];\n    }\n    int s = (l + r) / 2;\n    re tree[x] = (upd (x * 2 + 1, l, s, lc, rc, y) + upd (x * 2 + 2, s + 1, r, lc, rc, y)) % mod;\n}\n                              \nint main () {\n    ii a (1, 0), b (0, 1), cur (1, 1);\n    f[1] = a;\n    f[2] = b;\n    s[1] = a;\n    s[2] = cur;\n    for (int i = 3; i <= N; i++) {\n        ii c = mrg (a, b);\n        f[i] = c;\n        cur = mrg (cur, c);\n        s[i] = cur;\n        a = b;\n        b = c;\n    }\n    scanf (""%d%d"", &n, &m);\n    for (int i = 0; i < n; i++) scanf (""%d"", &x[i]);\n    build (0, 0, n - 1);\n    for (int i = 0; i < m; i++) {\n        int t, a, b;\n        scanf (""%d%d%d"", &t, &a, &b); a--; b--;\n        if (t == 1) {\n            upd (0, 0, n - 1, a, b, mp (1, 1));\n        } else {\n            printf (""%d\\n"", get (0, 0, n - 1, a, b));\n        }\n    }\n    return 0;\n}']","['data structures', 'math', 'number theory']",2400
https://codeforces.com//contest/623/problem/B,B. Array GCD,You are given array of length You may consecutively apply two operations to this array remove some subsegment continuous subsequence of length and pay for it coins change some elements of the array by at most and pay coins for each change Please note that each of operations may be applied at most once and may be not applied at all so you can remove only one segment and each number may be changed increased or decreased by at most Also note that you are not allowed to delete the whole array Your goal is to calculate the minimum number of coins that you need to spend in order to make the greatest common divisor of the elements of the resulting array be greater than ,"['#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\nint N, A, B;\nint arr[MAXN];\nint tval[MAXN];\nset <int> pfac;\n\nvoid run (int x)\n{\n    for (int i = 2; i * i <= x; i++)\n    {\n        if (x % i == 0)\n            pfac.insert(i);\n        while (x % i == 0)\n            x /= i;\n    }\n    if (x > 1)\n        pfac.insert(x);\n}\n\nll solve (int x)\n{\n    int mlo = N, mhi = -1;\n    for (int i = 0; i < N; i++)\n    {\n        int k = (arr[i] + 1) % x;\n        if (k == 1) tval[i] = 0;\n        else if (k == 0 || k == 2) tval[i] = 1;\n        else\n        {\n            mlo = min (mlo, i);\n            mhi = max (mhi, i);\n        }\n    }\n    \n    ll tot = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (i >= mlo && i <= mhi)\n            tot += A;\n        else tot += B * tval[i];\n    }\n    \n    if (mlo < N)\n    {\n        ll bhi = 0, btot = 0;\n        for (int i = mhi + 1; i < N; i++)\n        {\n            btot += A - tval[i] * B;\n            bhi = min (bhi, btot);\n        }\n        ll blo = 0;\n        btot = 0;\n        for (int i = mlo - 1; i >= 0; i--)\n        {\n            btot += A - tval[i] * B;\n            blo = min (blo, btot);\n        }\n        \n        return tot + blo + bhi;\n    }\n    else\n    {\n        ll bans = 0, bhi = 0, btot = 0;\n        for (int i = 0; i < N; i++)\n        {\n            btot += A - tval[i] * B;\n            bans = min (bans, btot - bhi);\n            bhi = max (bhi, btot);\n        }\n        return tot + bans;\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> N >> A >> B;\n    \n    for (int i = 0; i < N; i++)\n        cin >> arr[i];\n    \n    pfac.clear();\n    for (int i = -1; i <= 1; i++)\n    {\n        run (arr[0] + i);\n        run (arr[N-1] + i);\n    }\n    \n    ll ans = 1e17;\n    for (set<int>::iterator it = pfac.begin(); it != pfac.end(); it++)\n        ans = min (ans, solve (*it));\n    \n    cout << ans << ""\\n"";\n    //system (""Pause"");\n    return 0;\n}\n']","['dp', 'greedy', 'number theory']",2300
https://codeforces.com//contest/837/problem/D,D. Round Subset,Let s call the of the number the number of zeros to which it ends You have an array of numbers You need to choose a subset of exactly numbers so that the of the product of the selected numbers will be maximum possible ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nint dp[205][8010];\nint tdp[205][8010];\nint in[205][2];\nint main() {\n\tint N, K, i, j, k;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tll t;\n\t\tscanf(""%lld"", &t);\n\t\twhile (t % 2 == 0) {\n\t\t\tin[i][0]++;\n\t\t\tt /= 2;\n\t\t}\n\t\twhile (t % 5 == 0) {\n\t\t\tin[i][1]++;\n\t\t\tt /= 5;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) tdp[j][k] = dp[j][k];\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tfor (k = 0; k <= 8000; k++) {\n\t\t\t\tint j2 = j + 1, k2 = k + in[i][1];\n\t\t\t\tif (k2 <= 8000) tdp[j2][k2] = max(tdp[j2][k2], dp[j][k] + in[i][0]);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) dp[j][k] = tdp[j][k];\n\t}\n\n\tint ans = 0;\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) ans = max(ans, min(j, dp[i][j]));\n\treturn !printf(""%d\\n"", ans);\n}']","['dp', 'math']",2100
https://codeforces.com//contest/1029/problem/A,A. Many Equal Substrings,You are given a string t consisting of n lowercase Latin letters and an integer number k Let s define a substring of some string s with indices from l to r as s l dots r Your task is to construct such string s of minimum possible length that there are exactly k positions i such that s i dots i n 1 t In other words your task is to construct such string s of minimum possible length that there are exactly k substrings of s equal to t It is guaranteed that the answer is always unique ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n\n\nint n,k;\n\nstring t;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n >> k >> t;\n    int mx=0;\n    for(int i=1;i<n;i++){\n        int gd=1;\n        for(int j=0;j<i;j++){\n            if(t[j]!=t[n-i+j]) gd=0;\n        }\n        if(gd) mx=i;\n    }\n    cout << t;\n    for(int i=2;i<=k;i++){\n        for(int j=mx;j<n;j++) cout << t[j];\n    }\n}\n']","['implementation', 'strings']",1300
https://codeforces.com//contest/1086/problem/A,A. Connect Three,The Squareland national forest is divided into equal 1 times 1 square plots aligned with north south and east west directions Each plot can be uniquely described by integer Cartesian coordinates x y of its south west corner Three friends Alice Bob and Charlie are going to buy three distinct plots of land A B C in the forest Initially all plots in the forest including the plots A B C are covered by trees The friends want to visit each other so they want to clean some of the plots from trees After cleaning one should be able to reach any of the plots A B C from any other one of those by moving through adjacent cleared plots Two plots are adjacent if they share a side Of course the friends don t want to strain too much Help them find out the smallest number of plots they need to clean from trees ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int xs[3], ys[3];\n  for (int i = 0; i < 3; ++i)\n    cin >> xs[i] >> ys[i];\n\n  int x1 = -1, y1 = -1;\n  const int M = 1024;\n  int ans = 1e9;\n\n  for (int x = 0; x <= M; ++x)\n    for (int y = 0; y <= M; ++y) {\n      int cand = 0;\n      for (int i = 0; i < 3; ++i)\n        cand += abs(xs[i] - x) + abs(ys[i] - y);\n      if (ans > cand) {\n        mini(ans, cand);\n        x1 = x; y1 = y;\n      }\n    }\n\n  set<PII> s;\n  for (int i = 0; i < 3; ++i) {\n    int x = x1, y = y1;\n    s.emplace(x, y);\n    while (x != xs[i]) {\n      if (x > xs[i]) { --x; } else { ++x; }\n      s.emplace(x, y);\n    }\n    while (y != ys[i]) {\n      if (y > ys[i]) { --y; } else { ++y; }\n      s.emplace(x, y);\n    }\n    debug(x, y, x1, y1);\n  }\n\n  cout << SZ(s) << ""\\n"";\n  for (auto [x, y] : s)\n    cout << x << "" "" << y << ""\\n"";\n}\n\n']","['greedy', 'implementation']",1600
https://codeforces.com//contest/939/problem/D,D. Love Rescue,Valya and Tolya are an ideal pair but they quarrel sometimes Recently Valya took offense at her boyfriend because he came to her in t shirt with lettering that differs from lettering on her pullover Now she doesn t want to see him and Tolya is seating at his room and crying at her photos all day long This story could be very sad but fairy godmother Tolya s grandmother decided to help them and restore their relationship She secretly took Tolya s t shirt and Valya s pullover and wants to make the letterings on them same In order to do this for one unit of mana she can buy a spell that can change some letters on the clothes Your task is calculate the minimum amount of mana that Tolya s grandmother should spend to rescue love of Tolya and Valya More formally letterings on Tolya s t shirt and Valya s pullover are two strings with same length consisting only of lowercase English letters Using one unit of mana grandmother can buy a spell of form where and are some lowercase English letters which can arbitrary number of times transform a single letter to and vise versa on both Tolya s t shirt and Valya s pullover You should find the minimum amount of mana that grandmother should spend to buy a set of spells that can make the letterings equal In addition you should output the required set of spells ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n;\nstring s, t;\nbool vis[MAXN];\nint sec[MAXN], sz;\nvector<int> adj[MAXN];\n\nvoid dfs(int v){\n\tvis[v] = true;\n\tfor (int u:adj[v])\n\t\tif (!vis[u])\n\t\t\tdfs(u);\n\tsec[sz++] = v;\n}\n\npii ans[MAXN];\nint cc;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> s >> t;\n\tfor (int i = 0; i < n; i++){\n\t\tint a = (int)(s[i] - \'a\');\n\t\tint b = (int)(t[i] - \'a\');\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tfor (int v = 0; v < 200; v++)\n\t\tif (!vis[v]){\n\t\t\tsz = 0;\n\t\t\tdfs(v);\n\t\t\tfor (int i = 0; i + 1 < sz; i++)\n\t\t\t\tans[cc++] = {sec[i], sec[i+1]};\n\t\t}\n\tcout << cc << ""\\n"";\n\tfor (int i = 0; i < cc; i++)\n\t\tcout << char(ans[i].F+\'a\') << "" "" << char(ans[i].S+\'a\') << ""\\n"";\n\treturn 0;\n}\n']","['dfs and similar', 'dsu', 'graphs', 'greedy', 'strings']",1600
https://codeforces.com//contest/1371/problem/F,F. Raging Thunder,You are a warrior fighting against the machine god Thor Thor challenge you to solve the following problem There are n conveyors arranged in a line numbered with integers from 1 to n from left to right Each conveyor has a symbol or The initial state of the conveyor i is equal to the i th character of the string s There are n 1 holes numbered with integers from 0 to n The hole 0 is on the left side of the conveyor 1 and for all i geq 1 the hole i is on the right side of the conveyor i When a ball is on the conveyor i the ball moves by the next rules If the symbol is on the conveyor i then If i 1 the ball falls into the hole 0 If the symbol is on the conveyor i 1 the ball moves to the conveyor i 1 If the symbol is on the conveyor i 1 the ball falls into the hole i 1 If the symbol is on the conveyor i then If i n the ball falls into the hole n If the symbol is on the conveyor i 1 the ball moves to the conveyor i 1 If the symbol is on the conveyor i 1 the ball falls into the hole i You should answer next q queries each query is defined by the pair of integers l r 1 leq l leq r leq n First for all conveyors l l 1 r the symbol changes to and vice versa After that put on each conveyor l l 1 r Then each ball falls into some hole Find the maximum number of balls in one hole ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 1000005;\nint n, m;\nstring str;\nstruct Tree\n{\n\tint lt, rt, ll, lr, rl, rr, lmaxi1, lmaxi2, rmaxi1, rmaxi2, maxi1, maxi2;\n\t/*\n\t\tll : Left \'<\'\n\t\tlr : Left \'>\'\n\t\trl : Right \'<\'\n\t\trr : Right \'>\'\n\t\tlmaxi1 : Left max{a + b} (a * \'>\' + b * \'<\', a, b may be 0)\n\t\trmaxi1 : Right max.....\n\t\tlmaxi2 : Left max{a + b} (a * \'<\' + b * \'>\')\n\t\trmaxi2 : Right max.....\n\t\tmaxi1 : max{a + b} (a * \'>\' + b * \'<\')\n\t\tmaxi2 : max{a + b} (a * \'<\' + b * \'>\')\n\t*/\n\tbool tag;\n} tree[4 * Maxn];\nTree Swap(Tree x)\n{\n\tswap(x.ll, x.lr), swap(x.rr, x.rl), swap(x.lmaxi1, x.lmaxi2), swap(x.rmaxi1, x.rmaxi2), swap(x.maxi1, x.maxi2);\n\treturn x;\n}\nTree merge(Tree x, Tree y)\n{\n\tif (x.tag) x.tag = false, x = Swap(x);\n\tif (y.tag) y.tag = false, y = Swap(y);\n\tTree ans;\n\tans.tag = false;\n\tans.lt = x.lt, ans.rt = y.rt;\n\tif (x.ll == x.rt - x.lt) ans.ll = x.ll + y.ll;\n\telse ans.ll = x.ll;\n\tif (y.rr == y.rt - y.lt) ans.rr = y.rr + x.rr;\n\telse ans.rr = y.rr;\n\tif (x.lr == x.rt - x.lt) ans.lr = x.lr + y.lr;\n\telse ans.lr = x.lr;\n\tif (y.rl == y.rt - y.lt) ans.rl = y.rl + x.rl;\n\telse ans.rl = y.rl;\n\tans.maxi1 = max(x.maxi1, y.maxi1);\n\tans.maxi1 = max(ans.maxi1, max(x.rr + y.lmaxi1, x.rmaxi1 + y.ll));\n\tans.maxi2 = max(x.maxi2, y.maxi2);\n\tans.maxi2 = max(ans.maxi2, max(x.rl + y.lmaxi2, x.rmaxi2 + y.lr));\n\tans.lmaxi1 = max(x.lmaxi1 + (x.lmaxi1 == x.rt - x.lt) * y.ll, (x.lr == x.rt - x.lt) ? x.lr + y.lmaxi1 : 0);\n\tans.rmaxi1 = max(y.rmaxi1 + (y.rmaxi1 == y.rt - y.lt) * x.rr, (y.rl == y.rt - y.lt) ? y.rl + x.rmaxi1 : 0);\n\tans.lmaxi2 = max(x.lmaxi2 + (x.lmaxi2 == x.rt - x.lt) * y.lr, (x.ll == x.rt - x.lt) ? x.ll + y.lmaxi2 : 0);\n\tans.rmaxi2 = max(y.rmaxi2 + (y.rmaxi2 == y.rt - y.lt) * x.rl, (y.rr == y.rt - y.lt) ? y.rr + x.rmaxi2 : 0);\n\treturn ans;\n}\nvoid pushdown(int root)\n{\n\tif (tree[root].tag)\n\t{\n\t\ttree[root].tag = 0;\n\t\ttree[root << 1].tag ^= 1, tree[root << 1 | 1].tag ^= 1;\n\t\ttree[root] = Swap(tree[root]);\n\t}\n}\nvoid build(int root, int lt, int rt)\n{\n\ttree[root] = (Tree){lt, rt};\n\tif (lt + 1 == rt)\n\t{\n\t\tif (str[lt - 1] == \'<\') tree[root].ll = tree[root].rl = tree[root].maxi1 = tree[root].maxi2 = tree[root].lmaxi1 = tree[root].rmaxi2 = tree[root].rmaxi1 = tree[root].lmaxi2 = 1;\n\t\telse tree[root].lr = tree[root].rr = tree[root].maxi1 = tree[root].maxi2 = tree[root].lmaxi1 = tree[root].rmaxi2 = tree[root].rmaxi1 = tree[root].lmaxi2 = 1;\n\t}\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tbuild(root << 1, lt, mid);\n\t\tbuild(root << 1 | 1, mid, rt);\n\t\ttree[root] = merge(tree[root << 1], tree[root << 1 | 1]);\n\t}\n}\nvoid modify(int root, int lt, int rt)\n{\n\tif (lt == tree[root].lt && rt == tree[root].rt)\n\t\ttree[root].tag ^= 1;\n\telse\n\t{\n\t\tpushdown(root);\n\t\tint mid = (tree[root].lt + tree[root].rt) >> 1;\n\t\tif (lt >= mid) modify(root << 1 | 1, lt, rt);\n\t\telse if (rt <= mid) modify(root << 1, lt, rt);\n\t\telse modify(root << 1, lt, mid), modify(root << 1 | 1, mid, rt);\n\t\ttree[root] = merge(tree[root << 1], tree[root << 1 | 1]);\n\t}\n}\nTree ask(int root, int lt, int rt)\n{\n\tif (lt == tree[root].lt && rt == tree[root].rt)\n\t{\n\t\tpushdown(root);\n\t\treturn tree[root];\n\t}\n\telse\n\t{\n\t\tpushdown(root);\n\t\tint mid = (tree[root].lt + tree[root].rt) >> 1;\n\t\tif (lt >= mid) return ask(root << 1 | 1, lt, rt);\n\t\telse if (rt <= mid) return ask(root << 1, lt, rt);\n\t\telse return merge(ask(root << 1, lt, mid), ask(root << 1 | 1, mid, rt));\n\t}\n}\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tcin >> str;\n\tbuild(1, 1, n + 1);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tmodify(1, l, r + 1);\n\t\tTree res = ask(1, l, r + 1);\n\t\tprintf(""%d\\n"", res.tag ? res.maxi2 : res.maxi1);\n\t}\n\treturn 0;\n}']","['data structures', 'divide and conquer', 'implementation']",2800
https://codeforces.com//contest/534/problem/B,B. Covered Path,The on board computer on Polycarp s car measured that the car speed at the beginning of some section of the path equals meters per second and in the end it is meters per second We know that this section of the route took exactly seconds to pass Assuming that at each of the seconds the speed is constant and between seconds the speed can change at most by meters per second in absolute value i e the difference in the speed of any two adjacent seconds does not exceed in absolute value find the maximum possible length of the path section in meters ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define For(i,a,b) for(int i=a;i<b;i++)\n#define pb push_back\n#define mod 1000000007\n#define reset(s,val) memset(s,val,sizeof(s))\n#define eps 0.0000001\n#define pi acos(-1)\n#define sqr(x) (x)*(x)\n#define maxn 32000\n\nint v1,v2,t,d,ans,v;\n\nint main( ){\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    cin>>v1>>v2>>t>>d;\n    ans=v1+v2;\n    v=v1;\n    For(i,2,t)\n    {\n        v=min(v+d,v2+d*(t-i));\n        ans+=v;\n        //cout<<v<<endl;\n    }\n    cout<<ans;\n}\n']","['dp', 'greedy', 'math']",1400
https://codeforces.com//contest/1762/problem/B,B. Make Array Good,An array b of m positive integers is if for all pairs i and j 1 leq i j leq m max b i b j is divisible by min b i b j You are given an array a of n positive integers You can perform the following operation Select an index i 1 leq i leq n and an integer x 0 leq x leq a i and add x to a i in other words a i a i x After this operation a i leq 10 18 should be satisfied You have to construct a sequence of n operations that will make a good It can be proven that under the constraints of the problem such a sequence of operations exists ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstruct s\n{\n    long long a;\n    int p;\n}a[100005];\nbool cmp(s a,s b)\n{\n    return a.a < b.a;\n}\nlong long up(long long a,long long b)\n{\n    long long d = (a + b - 1) / b;\n    return b*d;\n}\nvoid solve()\n{\n    scanf(""%d"",&n);\n    for(int i = 1;i <= n;i++) scanf(""%lld"",&a[i].a) ,a[i].p = i;\n    sort(a+1,a+n+1,cmp);\n    printf(""%d\\n"",n - 1);\n    for(int i = 2;i <= n;i++) {\n        long long d = up(a[i].a , a[i - 1].a);\n        printf(""%d %lld\\n"",a[i].p , d - a[i].a) ; a[i].a = d;\n    }\n    return;\n}\nint main() {\n    // freopen(""in.txt"",""r"",stdin);\n    int t;scanf(""%d"",&t);\n    while(t--) solve();\n    return 0;\n}\n']","['constructive algorithms', 'implementation', 'number theory', 'sortings']",1100
https://codeforces.com//contest/555/problem/B,B. Case of Fugitive,Andrewid the Android is a galaxy famous detective He is now chasing a criminal hiding on the planet Oxa 5 the planet almost fully covered with water The only dry land there is an archipelago of narrow islands located in a row For more comfort let s represent them as non intersecting segments on a straight line island has coordinates besides for To reach the goal Andrewid needs to place a bridge between each pair of islands A bridge of length can be placed between the th and the th islads if there are such coordinates of and that and The detective was supplied with bridges each bridge can be used at most once Help him determine whether the bridges he got are enough to connect each pair of adjacent islands ,"['#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\nconst int MAX = 200005;\npair<long long, long long> a[MAX], p[MAX];\npair<pair<long long, long long>, int> seg[MAX];\nbool cmp(pair<pair<long long, long long>, int> a, pair<pair<long long, long long>, int> b)\n{\n\tif (a.first.second != b.first.second)\n\t\treturn (a.first.second < b.first.second);\n\tif (a.first.first != b.first.first)\n\t\treturn (a.first.first < b.first.first);\n\treturn (a.second < b.second);\n}\nint ans[MAX];\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i].first >> a[i].second;\n\tn--;\n\tfor (int i = 0; i < n; i++)\n\t\tseg[i] = make_pair(make_pair(a[i + 1].first - a[i].second, a[i + 1].second - a[i].first), i);\n\tsort(seg, seg + n, cmp);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> p[i].first;\n\t\tp[i].second = i;\n\t}\n\tsort(p, p + m);\n\tset<pair<long long, int> > s;\n\tint ptr = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\twhile (ptr < m && p[ptr].first <= seg[i].first.second)\n\t\t\ts.insert(p[ptr++]);\n\t\tset<pair<long long, int> >::iterator it = s.lower_bound(make_pair(seg[i].first.first, -1));\n\t\tif (it == s.end())\n\t\t{\n\t\t\tcout << ""No\\n"";\n\t\t\treturn 0;\n\t\t}\n\t\tans[seg[i].second] = it->second;\n\t\ts.erase(it);\n\t}\n\tcout << ""Yes\\n"";\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] + 1 << "" "";\n\tcout << ""\\n"";\n\treturn 0;\n}\n']","['data structures', 'greedy', 'sortings']",2000
https://codeforces.com//contest/988/problem/F,F. Rain and Umbrellas,Polycarp lives on a coordinate line at the point x 0 He goes to his friend that lives at the point x a Polycarp can move only from left to right he can pass one unit of length each second Now it s raining so some segments of his way are in the rain Formally it s raining on n non intersecting segments the i th segment which is in the rain is represented as l i r i 0 le l i r i le a There are m umbrellas lying on the line the i th umbrella is located at point x i 0 le x i le a and has weight p i When Polycarp begins his journey he doesn t have any umbrellas During his journey from x 0 to x a Polycarp can pick up and throw away umbrellas Polycarp picks up and throws down any umbrella instantly He can carry any number of umbrellas at any moment of time Because Polycarp doesn t want to get wet he must carry at least one umbrella while he moves from x to x 1 if a segment x x 1 is in the rain i e if there exists some i such that l i le x and x 1 le r i The condition above is the only requirement For example it is possible to go without any umbrellas to a point where some rain segment starts pick up an umbrella at this point and move along with an umbrella Polycarp can swap umbrellas while he is in the rain Each unit of length passed increases Polycarp s fatigue by the sum of the weights of umbrellas he carries while moving Can Polycarp make his way from point x 0 to point x a If yes find the minimum total fatigue after reaching x a if Polycarp picks up and throws away umbrellas optimally ,"['/// In The Name Of God\n\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl \'\\n\'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)5e5 + 7;\nconst int inf = (int)2e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint a, n, m;\nint take[N];\n\nint pos[N], w[N];\n\nll dp[2001][2001];\nbool bad[N];\nll calc(int x = 0, int last = 0, int cost = 0) {\n\tif (x == a) return 0;\n\tif (~dp[x][last]) return dp[x][last];\n\tll res = inf;\t\n\tif (bad[x]) {\n\t\tif (!last) {\n\t\t\tif (take[x]) {\n\t\t\t\tlast = take[x];\n\t\t\t\tres = min(res, calc(x + 1, last, cost + w[last]) + w[last]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tres = min(res, calc(x + 1, last, cost + w[last]) + w[last]);\n\t\t\tif (take[x]) res = min(res, calc(x + 1, take[x], cost + w[take[x]]) + w[take[x]]);\n\t\t}\n\t}\n\telse {\n\t\tif (take[x]) res = min(res, calc(x + 1, take[x], cost + w[take[x]]) + w[take[x]]);\n\t\tres = min(res, calc(x + 1, last, cost + w[last]) + w[last]);\n\t\tres = min(res, calc(x + 1, 0, cost));\n\t}\n\n\treturn dp[x][last] = res;\n}\nint l[N], r[N];\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (""in.txt"", ""r"", stdin);\n\t#endif\n\tKazakhstan\n\tcin >> a >> n >> m;\n\trep(i, 1, n) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\trep(x, 0, a) {\n\t\trep(i, 1, n) {\n\t\t\tif (l[i] <= x && x + 1 <= r[i]) {\n\t\t\t\tbad[x] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1, m) {\t\n\t\tcin >> pos[i] >> w[i];\n\t\tif (!take[pos[i]]) take[pos[i]] = i;\n\t\telse if (w[take[pos[i]]] > w[i]) take[pos[i]] = i;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tll res = calc();\n\tif (res >= inf) res = -1;\n\tcout << res;\n\tioi\n}\n']",['dp'],2100
https://codeforces.com//contest/1720/problem/B,B. Interesting Sum,You are given an array a that contains n integers You can choose any proper subsegment a l a l 1 ldots a r of this array meaning you can choose any two integers 1 le l le r le n where r l 1 n We define the of a given subsegment as the value of the following expression max a 1 a 2 ldots a l 1 a r 1 a r 2 ldots a n min a 1 a 2 ldots a l 1 a r 1 a r 2 ldots a n max a l ldots a r min a l ldots a r Please find the maximum beauty among all proper subsegments ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector<int> a(n);\n\t\tcin>>a;\n\t\tsort(all(a));\n\t\tcout<<a[n-1]+a[n-2]-a[1]-a[0]<<\'\\n\';\n\t}\n}\n']","['brute force', 'data structures', 'greedy', 'math', 'sortings']",800
https://codeforces.com//contest/785/problem/A,A. Anton and Polyhedrons,Anton s favourite geometric figures are regular polyhedrons Note that there are five kinds of regular polyhedrons Tetrahedron has triangular faces Cube has square faces Octahedron has triangular faces Dodecahedron has pentagonal faces Icosahedron has triangular faces All five kinds of polyhedrons are shown on the picture below Anton has a collection of polyhedrons One day he decided to know how many faces his polyhedrons have in total Help Anton and find this number ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\nconst int MX=22;\nint n;\n\nint main(){\n\tint ans=0;char s[MX];\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(""%s"",s);\n\t\tif(s[0]==\'T\')ans+=4;\n\t\telse if(s[0]==\'C\')ans+=6;\n\t\telse if(s[0]==\'O\')ans+=8;\n\t\telse if(s[0]==\'D\')ans+=12;\n\t\telse ans+=20;\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']","['implementation', 'strings']",800
https://codeforces.com//contest/1328/problem/F,F. Make k Equal,You are given the array a consisting of n elements and the integer k le n You want to obtain k equal elements in the array a In one move you can make one of the following two operations Take of the minimum elements of the array and increase its value by one more formally if the minimum value of a is mn then you choose such index i that a i mn and set a i a i 1 take of the maximum elements of the array and decrease its value by one more formally if the maximum value of a is mx then you choose such index i that a i mx and set a i a i 1 Your task is to calculate the minimum number of moves required to obtain k equal elements in the array ,"[""// clang-format off\n// powered by c++11\n// by Isaunoya\n#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i=(x);i<=(y);++i)\n#define Rep(i,x,y) for(register int i=(x);i>=(y);--i)\nusing namespace std;using db=double;using ll=long long;\nusing uint=unsigned int;using ull=unsigned long long;\nusing pii=pair<int,int>;\n#define Tp template\n#define fir first\n#define sec second\nTp<class T>void cmax(T&x,const T&y){if(x<y)x=y;}Tp<class T>void cmin(T&x,const T&y){if(x>y)x=y;}\n#define all(v) v.begin(),v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\nTp<class T>void sort(vector<T>&v){sort(all(v));}Tp<class T>void reverse(vector<T>&v){reverse(all(v));}\nTp<class T>void unique(vector<T>&v){sort(all(v)),v.erase(unique(all(v)),v.end());}inline void reverse(string&s){reverse(s.begin(),s.end());}\nconst int SZ=1<<23|233;\nstruct FILEIN{char qwq[SZ],*S=qwq,*T=qwq,ch;\n#ifdef __WIN64\n#define GETC getchar\n#else\ninline char GETC(){return(S==T)&&(T=(S=qwq)+fread(qwq,1,SZ,stdin),S==T)?EOF:*S++;}\n#endif\ninline FILEIN&operator>>(char&c){while(isspace(c=GETC()));return*this;}inline FILEIN&operator>>(string&s){s.clear();while(isspace(ch=GETC()));if(!~ch)return*this;s=ch;while(!isspace(ch=GETC())&&~ch)s+=ch;return*this;}\ninline FILEIN&operator>>(char*str){char*cur=str;while(*cur)*cur++=0;cur=str;while(isspace(ch=GETC()));if(!~ch)return*this;*cur=ch;while(!isspace(ch=GETC())&&~ch)*++cur=ch;*++cur=0;return*this;}\nTp<class T>inline void read(T&x){bool f=0;while((ch=GETC())<48&&~ch)f^=(ch==45);x=~ch?(ch^48):0;while((ch=GETC())>47)x=x*10+(ch^48);x=f?-x:x;}\ninline FILEIN&operator>>(int&x){return read(x),*this;}inline FILEIN&operator>>(ll&x){return read(x),*this;}inline FILEIN&operator>>(uint&x){return read(x),*this;}inline FILEIN&operator>>(ull&x){return read(x),*this;}\ninline FILEIN&operator>>(double&x){read(x);bool f=x<0;x=f?-x:x;if(ch^'.')return*this;double d=0.1;while((ch=GETC())>47)x+=d*(ch^48),d*=.1;return x=f?-x:x,*this;}\n}in;\nstruct FILEOUT{const static int LIMIT=1<<22;char quq[SZ],ST[233];int sz,O,pw[233];\nFILEOUT(){set(7);rep(i,pw[0]=1,9)pw[i]=pw[i-1]*10;}~FILEOUT(){flush();}\ninline void flush(){fwrite(quq,1,O,stdout),fflush(stdout),O=0;}\ninline FILEOUT&operator<<(char c){return quq[O++]=c,*this;}inline FILEOUT&operator<<(string str){if(O>LIMIT)flush();for(char c:str)quq[O++]=c;return*this;}\ninline FILEOUT&operator<<(char*str){if(O>LIMIT)flush();char*cur=str;while(*cur)quq[O++]=(*cur++);return*this;}\nTp<class T>void write(T x){if(O>LIMIT)flush();if(x<0){quq[O++]=45;x=-x;}do{ST[++sz]=x%10^48;x/=10;}while(x);while(sz)quq[O++]=ST[sz--];}\ninline FILEOUT&operator<<(int x){return write(x),*this;}inline FILEOUT&operator<<(ll x){return write(x),*this;}inline FILEOUT&operator<<(uint x){return write(x),*this;}inline FILEOUT&operator<<(ull x){return write(x),*this;}\nint len,lft,rig;void set(int l){len=l;}inline FILEOUT&operator<<(double x){bool f=x<0;x=f?-x:x,lft=x,rig=1.*(x-lft)*pw[len];return write(f?-lft:lft),quq[O++]='.',write(rig),*this;}\n}out;\n#define int long long\nstruct Math{\nvector<int>fac,inv;int mod;\nvoid set(int n,int Mod){fac.resize(n+1),inv.resize(n+1),mod=Mod;rep(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;inv[n]=qpow(fac[n],mod-2);Rep(i,n-1,0)inv[i]=inv[i+1]*(i+1)%mod;}\nint qpow(int x,int y){int ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}int C(int n,int m){if(n<0||m<0||n<m)return 0;return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint gcd(int x,int y){return!y?x:gcd(y,x%y);}int lcm(int x,int y){return x*y/gcd(x,y);}\n}math;\n// clang-format on\n\nconst int maxn = 4e5 + 54;\nint a[maxn];\nint sum = 0;\nint n , k;\nint ans = 1e18;\n\n\nstruct bit {\n\tint c[maxn];\n\tint low(int x) {\n\t\treturn x & -x;\n\t}\n\t\n\tvoid add(int x , int y) {\n\t\tfor( ; x < maxn ; x += low(x))\n\t\t\tc[x] += y; \n\t}\n\t\n\tint qry(int x) {\n\t\tint ans = 0 ;\n\t\tfor( ; x ; x ^= low(x))\n\t\t\tans += c[x];\n\t\treturn ans;\n\t}\n} bit;\n\nint b[maxn];\nint rev[maxn];\nint t[maxn];\nsigned main(){\n\t//code begin.\n\t\n\tauto init = [&]() {\n\t\tin >> n >> k;\n\t\trep(i , 1 , n) in >> a[i];\n\t\trep(i , 1 , n) sum += a[i];\n\t\tsort(a + 1 , a + n + 1);\n\t\trep(i , 1 , n) b[i] = a[i];\n\t\tint len = unique(b + 1 , b + n + 1) - b - 1;\n\t\trep(i , 1 , n) {\n\t\t\ta[i] = lower_bound(b + 1 , b + len + 1 , a[i]) - b ;\n\t\t\tif(a[i] != a[i - 1]) rev[a[i]] = i;\n\t\t}\n\t\trep(i , 1 , n) t[a[i]] ++;\n\t\trep(i , 1 , n) bit.add(a[i], b[a[i]]);\n\t\trev[len + 1] = n + 1;\n\t} ;\n\tinit();\n\tauto solve = [&](int x) {\n\t\tint qwq = rev[a[x]] - 1;\n\t\tint qwq2 = n - rev[a[x] + 1] + 1;\n\t\tint sum1 = qwq * (b[a[x]] - 1) - bit.qry(a[x] - 1);\n\t\tint sum2 = sum - bit.qry(a[x]) - qwq2 * (b[a[x]] + 1);\n\t\tif(t[a[x]] >= k) {\n\t\t\tcmin(ans , 0ll);\n\t\t\tout << ans << '\\n';\n\t\t\texit(0);\n\t\t}\n\t\tbool flag = 1;\n\t\tif(t[a[x]] + qwq >= k) {\n\t\t\tcmin(ans, sum1 + k - t[a[x]]);\n\t\t\tflag = 0;\n\t\t}\n\t\tif(t[a[x]] + qwq2 >= k) {\n\t\t\tcmin(ans, sum2 + k - t[a[x]]);\n\t\t\tflag = 0;\n\t\t}\n\t\tif(flag) cmin(ans, sum1 + sum2 + k - t[a[x]]);\n\t} ;\n\trep(i , 1 , n) {\n\t\tif(a[i] == a[i - 1]) continue;\n\t\tsolve(i);\n\t}\n\tout << ans << '\\n';\n\treturn 0;\n\t//code end.\n}""]",['greedy'],2200
https://codeforces.com//contest/1785/problem/C,C. Monsters  hard version ,In a computer game you are fighting against n monsters Monster number i has a i health points all a i are integers A monster is alive while it has at least 1 health point You can cast spells of two types Deal 1 damage to any single alive monster of your choice Deal 1 damage to all alive monsters If at least one monster dies ends up with 0 health points as a result of this action then repeat it and keep repeating while at least one monster dies every time Dealing 1 damage to a monster reduces its health by 1 Spells of type 1 can be cast any number of times while a spell of type 2 can be cast at most once during the game For every k 1 2 ldots n answer the following question Suppose that only the first k monsters with numbers 1 2 ldots k are present in the game What is the smallest number of times you need to cast spells of type 1 to kill all k monsters ,"['#include <bits/stdc++.h>\nusing namespace std;\n#include <bits/extc++.h> /** keep-include */\nusing namespace __gnu_pbds;\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nconstexpr int bsf_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\nusing ll = int64_t;\n\nusing S = ll;\nusing F = ll;\n\nS op(S x, S y) { return min(x, y); }\nS e(){ return ll(1e9); }\nS mapping(F f, S x) { return f + x; }\nF composition(F f, F g) { return f + g; }\nF id() { return 0; }\n\ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<ll> A(N);\n\tfor(ll& x : A) cin >> x;\n\tvector<int> ord(N);\n\tfor(int i = 0; i < N; i++) ord[i] = i;\n\tsort(ord.begin(), ord.end(), [&](int x, int y) { return A[x] < A[y]; });\n\tvector<int> inv_ord(N);\n\tfor(int i = 0; i < N; i++) inv_ord[ord[i]] = i;\n\tatcoder::lazy_segtree<S, op, e, F, mapping, composition, id> seg(N);\n\tll cnt = 0;\n\tll in_seg_sum = 0;\n\n\tordered_set<int> in_set_idx;\n\tfor(int i = 0; i < N; i++){\n\t\tint loc = inv_ord[i];\n\n\t\tint nbefore = in_set_idx.order_of_key(loc);\n\t\tin_set_idx.insert(loc);\n\t\tseg.set(loc, A[i] - nbefore - 1);\n\t\tseg.apply(loc+1, N, -1);\n\t\tcnt += 1;\n\t\tin_seg_sum += A[i];\n\t\tint f = seg.max_right(0, [&](S x) -> bool {\n\t\t\treturn x >= 0;\n\t\t});\n\t\tif(f < N){\n\t\t\tassert(seg.get(f) < 0);\n\t\t\tseg.set(f, e());\n\t\t\tseg.apply(f+1, N, 1);\n\t\t\tin_set_idx.erase(f);\n\t\t\tcnt -= 1;\n\t\t\tin_seg_sum -= A[ord[f]];\n\t\t}\n\t\tll ans = in_seg_sum - ll(cnt) * ll(cnt + 1) / 2;\n\t\tcout << ans << "" \\n""[i == N-1];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","['data structures', 'greedy', 'implementation']",2200
https://codeforces.com//contest/1388/problem/A,A. Captain Flint and Crew Recruitment,Recently out of blue Captain Flint has been interested in math and even defined a new class of integers Let s define a positive integer x as if it can be represented as p cdot q where 1 p q and p and q are prime numbers For example integers 6 and 10 are nearly primes since 2 cdot 3 6 and 2 cdot 5 10 but integers 1 3 4 16 17 or 44 are not Captain Flint guessed an integer n and asked you can you represent it as where of them should be Uncle Bogdan easily solved the task and joined the crew Can you do the same ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main() {\n\tint a[N];\n\tf(i, N)a[i] = 0;\n\tint n, k, t;\n\tint x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(""%d"", &t);\n\tf(tt, t) {\n\t\tscanf(""%d"", &n);\n\t\tif (n < 31)printf(""NO\\n"");\n\t\telse if (n == 36) {\n\t\t\tprintf(""YES\\n"");\n\t\t\tprintf(""5 6 10 15\\n"");\n\t\t}\n\t\telse if (n == 40) {\n\t\t\tprintf(""YES\\n"");\n\t\t\tprintf(""2 6 10 22\\n"");\n\t\t}\n\t\telse if (n == 44) {\n\t\t\tprintf(""YES\\n"");\n\t\t\tprintf(""6 7 10 21\\n"");\n\t\t}\n\t\telse {\n\t\t\tprintf(""YES\\n"");\n\t\t\tprintf(""6 10 14 %d\\n"",n - 30);\n\t\t}\n\t}\n\n\treturn 0;\n}']","['brute force', 'greedy', 'math', 'number theory']",800
https://codeforces.com//contest/403/problem/B,B. Upgrading Array,You have an array of positive integers and a set of prime numbers The prime numbers that do not occur in the set are considered The of array is the sum where function is determined as follows Let s assume that is the minimum prime divisor of If is a good prime then otherwise You are allowed to perform an arbitrary probably zero number of operations to improve array The is the following sequence of actions Choose some number and calculate the value GCD Apply the assignments What is the maximum beauty of the array you can get ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\ninline int gcd(int a, int b) {\n\tfor (; b; swap(a, b)) a %= b;\n\treturn a;\n}\nint a, b, c, d, n, m, k;\nint mas[5002];\nint pr[32000];\n\nint dp[5002], cg[5002];\nint cntg[5002], cntb[5002];\nset<int> bad;\npii calc(int t) {\n\tint cb = 0, cg = 0;\n\tfor (int j = 0; j < k && pr[j] * pr[j] <= t; ++j) {\n\t\tif (t % pr[j]) continue;\n\t\tbool good = !bad.count(pr[j]);\n\t\twhile (t % pr[j] == 0) {\n\t\t\tif (!good) ++cb; else\n\t\t\t\t++cg;\n\t\t\tt /= pr[j];\n\t\t}\n\t}\n\tif (t > 1) {\n\t\tif (bad.count(t)) ++cb; else\n\t\t\t++cg;\n\t}\n\treturn mp(cg, cb);\n}\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\trept(i, n) scanf(""%d"", &mas[i]);\n\trept(i, m) {\n\t\tscanf(""%d"", &a);\n\t\tbad.insert(a);\n\t}\n\n\tfor (int i = 2; i * i <= INF; ++i) {\n\t\tbool ok = 1;\n\t\tfor (int j = 2; j * j <= i; ++j) {\n\t\t\tif (i % j == 0) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) pr[k++] = i;\n\t}\n\n\tcg[0] = mas[0];\n\trep(i, n - 1) {\n\t\tcg[i] = gcd(cg[i - 1], mas[i]);\n\t}\n\tcg[n] = 1;\n\n\tmemset(dp, 63, sizeof(dp));\n\tdp[n] = 0;\n\n\trept(i, n + 1) {\n\t\tpii r = calc(cg[i]);\n\t\tcntg[i] = r.x;\n\t\tcntb[i] = r.y;\n\t}\n\tFORD(i, n - 1, 0) {\n\t\tdp[i] = -INF;\n\t\tFOR(j, i + 1, n) {\n\t\t\tint cur = dp[j] + (i + 1) * (cntb[i] - cntb[j]) - (i + 1) * (cntg[i] - cntg[j]);\n\t\t\tdp[i] = max(dp[i], cur);\n\t\t}\n\t}\n\n\tint ans = *max_element(dp, dp + n + 1);\n\trept(i, n) {\n\t\tpii r = calc(mas[i]);\n\t\tans += r.x;\n\t\tans -= r.y;\n\t}\n\tprintf(""%d\\n"", ans);\n}\n']","['dp', 'greedy', 'math', 'number theory']",1800
https://codeforces.com//contest/1511/problem/B,B. GCD Length,You are given three integers a b and c Find two positive integers x and y x 0 y 0 such that the decimal representation of x without leading zeroes consists of a digits the decimal representation of y without leading zeroes consists of b digits the decimal representation of gcd x y without leading zeroes consists of c digits gcd x y denotes the greatest common divisor GCD of integers x and y Output x and y If there are multiple answers output any of them ,"[""#include <bits/stdc++.h>\n\ntemplate <class T>\nconstexpr T power(T a, int64_t n) {\n  assert(n >= 0);\n  T res = n & 1 ? a : 1;\n  while (n >>= 1) {\n    a *= a;\n    if (n & 1) res *= a;\n  }\n  return res;\n}\n\ntemplate <int Id>\nclass DynamicModularInt64 {\n  using D = DynamicModularInt64;\n\n public:\n  static int64_t modulus() { return modulus_; }\n  static void modulus(int64_t modulus) {\n    assert(modulus >= 1);\n    modulus_ = modulus;\n  }\n  static D raw(uint64_t v) { return *reinterpret_cast<D*>(&v); }\n\n  DynamicModularInt64() : v_(0) {}\n  DynamicModularInt64(int64_t v)\n      : v_((v %= modulus()) < 0 ? v + modulus() : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  D& operator++() { return v_ = ++v_ == modulus_ ? 0 : v_, *this; }\n  D& operator--() { return --(v_ ? v_ : v_ = modulus_), *this; }\n  D operator+() const { return *this; }\n  D operator-() const { return raw(v_ ? modulus_ - v_ : 0); }\n  D& operator*=(D o) {\n    v_ = v_ * o.v_ - uint64_t((long double)v_ * o.v_ / modulus_) * modulus_;\n    v_ = int64_t(v_) < 0 ? v_ + modulus_ : v_;\n    v_ = v_ >= modulus_ ? v_ - modulus_ : v_;\n    return *this;\n  }\n  D& operator/=(D o) {\n    auto [inv, gcd] = extgcd(o.v_, modulus_);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  D& operator+=(D o) {\n    return v_ = int64_t(v_ += o.v_ - modulus_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n  D& operator-=(D o) {\n    return v_ = int64_t(v_ -= o.v_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n\n  friend D operator++(D& a, int) { return std::exchange(a, ++D(a)); }\n  friend D operator--(D& a, int) { return std::exchange(a, --D(a)); }\n  friend D operator*(D a, D b) { return a *= b; }\n  friend D operator/(D a, D b) { return a /= b; }\n  friend D operator+(D a, D b) { return a += b; }\n  friend D operator-(D a, D b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, D& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, D x) { return os << x.v_; }\n  friend bool operator==(D a, D b) { return a.v_ == b.v_; }\n  friend bool operator!=(D a, D b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int64_t, int64_t> extgcd(int64_t a, int64_t b) {\n    std::array<int64_t, 2> x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  static inline uint64_t modulus_ = std::numeric_limits<int64_t>::max();\n\n  uint64_t v_;\n};\n\nbool miller_rabin(int64_t n, std::initializer_list<int64_t> bases) {\n  using Mint = DynamicModularInt64<__COUNTER__>;\n  Mint::modulus(n);\n  int tz = __builtin_ctzll(n - 1);\n  for (Mint a : bases) {\n    if (a == 0) continue;\n    a = power(a, n >> tz);\n    int i = tz;\n    while (a != 1 and a != -1 and i--) a *= a;\n    if (a != -1 and i != tz) return false;\n  }\n  return true;\n}\n\nbool is_prime(int64_t n) {\n  if (n < 2 or n % 6 % 4 != 1) return n == 2 or n == 3;\n  if (n < 291831) return miller_rabin(n, {126401071349994536});\n  if (n < 1050535501) return miller_rabin(n, {336781006125, 9639812373923155});\n  if (n < 273919523041)\n    return miller_rabin(n, {15, 7363882082, 992620450144556});\n  if (n < 47636622961201)\n    return miller_rabin(n, {2, 2570940, 211991001, 3749873356});\n  if (n < 7999252175582851)\n    return miller_rabin(n, {2, 4130806001517, 149795463772692060,\n                            186635894390467037, 3967304179347715805});\n  if (n < 585226005592931977)\n    return miller_rabin(\n        n, {2, 123635709730000, 9233062284813009, 43835965440333360,\n            761179012939631437, 1263739024124850375});\n  return miller_rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n}\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  vector<int> x, y;\n  for (int i : Rep(9)) {\n    int p = power(10, i);\n    while (not is_prime(p)) ++p;\n    x.push_back(p);\n    ++p;\n    while (not is_prime(p)) ++p;\n    y.push_back(p);\n  }\n  DUMP(x);\n  DUMP(y);\n  for (int tt = scan(); tt--;) {\n    int a = scan() - 1;\n    int b = scan() - 1;\n    int c = scan() - 1;\n    cout << x[a - c] * power(10, c) << ' ' << y[b - c] * power(10, c) << '\\n';\n  }\n}\n""]","['constructive algorithms', 'math', 'number theory']",1100
https://codeforces.com//contest/289/problem/D,D. Polo the Penguin and Houses ,Little penguin Polo loves his home village The village has houses indexed by integers from 1 to Each house has a plaque containing an integer the th house has a plaque containing integer Little penguin Polo loves walking around this village The walk looks like that First he stands by a house number Then he goes to the house whose number is written on the plaque of house that is to house then he goes to the house whose number is written on the plaque of house that is to house and so on We know that When the penguin starts walking from any house indexed from 1 to inclusive he can walk to house number 1 When the penguin starts walking from any house indexed from to inclusive he definitely cannot walk to house number 1 When the penguin starts walking from house number 1 he can get back to house number 1 after some non zero number of walks from a house to a house You need to find the number of ways you may write the numbers on the houses plaques so as to fulfill the three above described conditions Print the remainder after dividing this number by ,"['#include<iostream>\n#include<cstring> \nusing namespace std;\nint v[9],p[9],n,m,i,mod=1000000007;\nlong long ans;\n\nbool go(int x)\n{\n    if(v[x]==1) return 1;\n    if(v[x]==-1) return 0;\n    v[x]=-1;\n    if(go(p[x])) return v[x]=1;\n    return 0;\n}\n\nvoid dfs(int x)\n{\n    int i;\n    if(x>m)\n    {\n        memset(v,0,sizeof(v));\n        v[1]=1;\n        for(i=2;i<=m;i++)\n            if(!go(i)) break;\n        ans+=i>m;\n        return;\n    }\n    for(i=1;i<=m;i++)\n        if(x==1||i!=x)\n        {\n            p[x]=i;\n            dfs(x+1);\n        }\n}\n\nint main()\n{\n    cin>>n>>m;\n    dfs(1);\n    for(i=1;i<=n-m;i++) ans=ans*(n-m)%mod;\n    cout<<ans<<endl;\n}']","['brute force', 'combinatorics', 'dfs and similar', 'math']",1500
https://codeforces.com//contest/448/problem/A,A. Rewards,Bizon the Champion is called the Champion for a reason Bizon the Champion has recently got a present a new glass cupboard with shelves and he decided to put all his presents there All the presents can be divided into two types medals and cups Bizon the Champion has first prize cups second prize cups and third prize cups Besides he has first prize medals second prize medals and third prize medals Naturally the rewards in the cupboard must look good that s why Bizon the Champion decided to follow the rules any shelf cannot contain both cups and medals at the same time no shelf can contain more than five cups no shelf can have more than ten medals Help Bizon the Champion find out if we can put all the rewards so that all the conditions are fulfilled ,"['#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m;\nint main() {\n\tint A,B;\n\tA=B=0;\n\tFor(i,1,3) scanf(""%d"",&k),A+=k;\n\tFor(i,1,3) scanf(""%d"",&k),B+=k;\n\tif (A) A=(A-1)/5+1;\n\tif (B) B=(B-1)/10+1;\n\tscanf(""%d"",&k);\n\tprintf(""%s\\n"",A+B>k?""NO"":""YES"");\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/993/problem/D,D. Compute Power,You need to execute several tasks each associated with number of processors it needs and the compute power it will consume You have sufficient number of analog computers each with enough processors for any task Each computer can execute up to one task at a time and no more than two tasks total The first task can be any the second task on each computer must use strictly less power than the first You will assign between 1 and 2 tasks to each computer You will then first execute the first task on each computer wait for all of them to complete and then execute the second task on each computer that has two tasks assigned If the average compute power per utilized processor the sum of all consumed powers for all tasks presently running divided by the number of utilized processors across all computers exceeds some unknown threshold during the execution of the first tasks the entire system will blow up There is no restriction on the second tasks execution Find the lowest threshold for which it is possible Due to the specifics of the task you need to print the answer multiplied by 1000 and rounded up ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define mp make_pair\n\nconst ll INF = (ll)1e18;\nconst ll C = (ll)1e14;\nconst int N = 55;\nint n;\nll a[N][2];\npll b[N];\nll dp[N][N];\n\nbool solve(ll X) {\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = mp(a[i][0], a[i][0] - a[i][1] * X);\n\tsort(b, b + n);\n\treverse(b, b + n);\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tdp[i][j] = INF;\n\tdp[0][0] = 0;\n\tint L = 0;\n\twhile(L < n) {\n\t\tint R = L;\n\t\twhile(R < n && b[L].first == b[R].first) R++;\n\t\tfor (int was = 0; was <= L; was++) {\n\t\t\tif (dp[L][was] == INF) continue;\n\t\t\tll sum = dp[L][was];\n\t\t\tfor (int i = L; i < R; i++)\n\t\t\t\tsum += b[i].second;\n\t\t\tfor (int cnt = 0; cnt <= R - L; cnt++) {\n\t\t\t\tif (cnt <= was)\n\t\t\t\t\tdp[R][was - cnt + R - L - cnt] = min(dp[R][was - cnt + R - L - cnt], sum);\n\t\t\t\tsum -= b[L + cnt].second;\n\t\t\t}\n\t\t}\n\t\tL = R;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tif (dp[n][i] <= 0)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tscanf(""%lld"", &a[j][i]);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i][0] *= 1000;\n\tll L = 0, R = C;\n\twhile(R - L > 1) {\n\t\tll x = (L + R) / 2;\n\t\tif (solve(x))\n\t\t\tR = x;\n\t\telse\n\t\t\tL = x;\n\t}\n\tprintf(""%lld\\n"", R);\n\n\treturn 0;\n}\n']","['binary search', 'dp', 'greedy']",2500
https://codeforces.com//contest/1521/problem/E,E. Nastia and a Beautiful Matrix,Let a i be how many numbers i 1 le i le k you have An n times n matrix is called beautiful if it contains the numbers you have and for 2 times 2 submatrix of the original matrix is satisfied The number of occupied cells doesn t exceed 3 The numbers on each diagonal are distinct Make a beautiful matrix of size ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#pragma GCC target(""avx,avx2,sse,sse2"")\n\n\n    #define int long long\n    \n\n#define YES cout<<""YES\\n"";return; \n#define NO cout<<""NO\\n"";return; \n#define write(a) cout<<a<<""\\n"";return; \n#define F first \n#define S second\n\nusing namespace std;\nusing vi=vector<int>; \nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\nlong long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n}\nlong long gcd(long long a, long long b) {\n    if (a==0) return b;\n    if (b==0) return a;\n    if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n}\nint prime(int p) { // 1 - простое\nif (p==1) return 0; \n    for (int i=2;i*i<=p;i++) {\n    if (p%i==0 && i<p) return i;  \n    }\n    return 1;\n}\n        \n int inv(int a, int mod) {\n    return powmod(a,mod-2,mod); \n}\n            \n int random_modul() {\n        \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n    \ntemplate <typename T1> void ifmax(T1 &max, T1 kek) {\n    if (kek>max) max=kek; \n    return; \n}\ntemplate <typename T1> void ifmin(T1 &min, T1 kek) {\n    if (kek<min) min=kek;\n    return; \n}\n     \n\ntemplate <typename T1> istream& operator>> (std::istream& in, pair<T1,T1> & a) {\nin>>a.first>>a.second; \nreturn in; \n    \n}\n    \ntemplate <typename T1> istream& operator>> (std::istream& in, vector<T1> & a) {\n    for (int i=0;i<a.size();i++) in>>a[i]; \n    return in;\n} \n     \ntemplate <typename T1>  ostream& operator<< (std::ostream& out, vector <T1> &b) {\n    for (int i=0;i<b.size();i++) out<<b[i]; \n    return out; \n} \ntemplate <typename T1> void sort(vector <T1> &m) {\n    sort(m.begin(),m.end());\n}\n\ntemplate <typename T1> void reverse(vector <T1> &m) {\n reverse(m.begin(),m.end());\n}\nint mod=1000000007; \nint fac[200005];\nint inv_fac[200005]; \nint co(int a, int b) {\n    int ans=1;\n    ans*=fac[b]; \n    ans*=inv_fac[b-a]; ans%=mod; \n    ans*=inv_fac[a]; \n    return ans%mod; \n}    \n\n\nvoid solve () {\n           \n           \n     /* ---- !! F, S !!  ---- */\n         \n   int k,a;\n   cin>>k>>a;\n   vector <pair<int,int>> m(a);\n   for (int i=0;i<a;i++) {\n       cin>>m[i].first; m[i].second=i; \n   }\n   sort(m);\n   for (int i=1;i<=1000;i++) {\n       if (i%2==0) {\n           int blocked=(i*i)/4; \n           int free=(i*i)/4;\n           int maximal=(i*i)/4;\n           int check=1; \n           if ((3*i*i)/4<k) check=0;\n           if (check) {\n               int need=0; \n               for (int j=a-1;j>=0;j--) {\n                   if (m[j].first>maximal) {need+=m[j].first-maximal; } else break; \n               }\n               if (need>free) check=0; \n           }\n           if (check==1) {\n               cout<<i<<""\\n""; \n               vector <vector <int>> ans(i, vector <int> (i));  \n               int BLOCK=0; \n               vector <pair<int,int>> p_free; \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==1 && y%2==1) {\n                           ans[x][y]=BLOCK; \n                       }\n                       if (x%2==0 && y%2==0) {\n                          p_free.push_back({x,y}); \n                       }\n                   }\n               }\n               \n                   int find=-1; \n                   if (m[a-1].first>=maximal) {find=m[a-1].second+1; }\n                   vector <pair<int,int>> omegalul1;\n                   vector <pair<int,int>> omegalul2;\n                   for (int x=0;x<i;x++) {\n                       for (int y=0;y<i;y++) {\n                           if (x%2==0 && y%2==1) omegalul1.push_back({x,y});\n                           if (x%2==1 && y%2==0) omegalul2.push_back({x,y}); \n                       }\n                   }\n                   \n                  \n                   if (find!=-1) {\n                      for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==0 && y%2==1) {\n                           ans[x][y]=find; \n                       }\n                       \n                   }\n               }\n               m[a-1].first-=maximal; \n               for (int j=0;j<omegalul2.size();j++) p_free.push_back(omegalul2[j]); \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<"" ""; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=p_free[cur].first; \n                       int y1=p_free[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<"" ""; \n                       \n                   } cout<<""\\n""; \n               } return; \n                }\n                \n                \n                \n                vector <pair<int,int>> poses;\n                for (int i=0;i<omegalul1.size();i++) poses.push_back(omegalul1[i]); \n                for (int i=0;i<p_free.size();i++) poses.push_back(p_free[i]); \n                 for (int i=0;i<omegalul2.size();i++) poses.push_back(omegalul2[i]);   \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<"" ""; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=poses[cur].first; \n                       int y1=poses[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<"" ""; \n                       \n                   } cout<<""\\n""; \n               } return; \n               return; \n           }\n       }\n       \n       else {\n           int blocked=((i-1)*(i-1))/4;\n           int free=(i+1)*(i+1)/4;\n           int maximal=(i/2)*(i-i/2); \n           int check=1; \n           if (free+maximal*2<k) check=0;\n           if (check) {\n               int need=0; \n               for (int j=a-1;j>=0;j--) {\n                   if (m[j].first>maximal) {need+=m[j].first-maximal; } else break; \n               }\n               if (need>free) check=0; \n           }\n           if (check==1) {\n               cout<<i<<""\\n"";\n               \n               vector <vector <int>> ans(i, vector <int> (i));  \n               int BLOCK=0; \n               vector <pair<int,int>> p_free; \n               vector <pair<int,int>> omegalul1;\n               vector <pair<int,int>> omegalul2; \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==1 && y%2==1) {\n                           ans[x][y]=BLOCK; \n                       }\n                       if (x%2==0 && y%2==0) {\n                          p_free.push_back({x,y}); \n                       }\n                   }\n               }\n               \n                for (int x=0;x<i;x++) {\n                       for (int y=0;y<i;y++) {\n                           if (x%2==0 && y%2==1) omegalul1.push_back({x,y});\n                           if (x%2==1 && y%2==0) omegalul2.push_back({x,y}); \n                       }\n                   }\n               \n               int find=-1; \n                   if (m[a-1].first>=maximal) {find=m[a-1].second+1; }\n                   \n                   if (find!=-1) {\n                      for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==0 && y%2==1) {\n                           ans[x][y]=find; \n                       }\n                       \n                   }\n               }\n               m[a-1].first-=maximal; \n               for (int j=0;j<omegalul2.size();j++) p_free.push_back(omegalul2[j]); \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<"" ""; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=p_free[cur].first; \n                       int y1=p_free[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<"" ""; \n                       \n                   } cout<<""\\n""; \n               } return; \n                }\n                \n                \n                \n                vector <pair<int,int>> poses;\n                for (int i=0;i<omegalul1.size();i++) poses.push_back(omegalul1[i]); \n                for (int i=0;i<p_free.size();i++) poses.push_back(p_free[i]); \n                 for (int i=0;i<omegalul2.size();i++) poses.push_back(omegalul2[i]);   \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<"" ""; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=poses[cur].first; \n                       int y1=poses[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<"" ""; \n                       \n                   } cout<<""\\n""; \n               } return; \n               \n               \n               return; \n           }\n       }\n   }\n    \n    /* --------- */  \n    return;\n    }\n         \n         \n         \n    signed main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0); \n           \n           \n      cout<<fixed<<setprecision(10); \n           \n           \n        int multitest = 1 ;    \n           \n      int tututu;\n      tututu=1;\n      \n      \n     int combinatorics = 0;  \n      \n      if (combinatorics) { \n     fac[1]=1;\n     fac[0]=1; \n     for (int i=2;i<200005;i++) {\n         fac[i]=fac[i-1]*i; fac[i]%=mod; \n     }\n     for (int i=0;i<200005;i++) {\n         inv_fac[i]=inv(fac[i],mod); \n     }\n      } \n      \n      \n      \n      if (multitest) cin>>tututu; // если нет запросов, то закоментить\n            \n      for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n          \n           \n    return 0;\n}\n']","['binary search', 'constructive algorithms', 'dp', 'greedy']",2700
https://codeforces.com//contest/1486/problem/A,A. Shifting Stacks,You have n stacks of blocks The i th stack contains h i blocks and it s height is the number of blocks in it In one move you can take a block from the i th stack if there is at least one block and put it to the i 1 th stack Can you make the sequence of heights strictly increasing Note that the number of stacks always remains n stacks don t disappear when they have 0 blocks ,"['//#pragma GCC target(""avx,avx2"")\t\n#include<bits/stdc++.h>\n//#include<immintrin.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nchar readc()\n{\n\tchar c;\n\twhile(isspace(gc));\n\treturn c;\n}\nint read()\n{\n\tchar c;\n\twhile(gc<\'-\');\n\tif(c==\'-\')\n\t{\n\t\tint x=gc-\'0\';\n\t\twhile(gc>=\'0\')x=x*10+c-\'0\';\n\t\treturn -x;\n\t}\n\tint x=c-\'0\';\n\twhile(gc>=\'0\')x=x*10+c-\'0\';\n\treturn x;\n}\n#undef gc\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(""1.in"",""r"",stdin);//freopen(""1.out"",""w"",stdout);\n#endif\t\n\tint tt=read();\n\twhile(tt--)\n\t{\n\t\tint n=read();\n\t\ts64 sum=0;\n\t\tbool ok=1;\n\t\trep(i,1,n)\n\t\t{\n\t\t\tsum+=read();\n\t\t\tok&=sum>=s64(i)*(i-1)/2;\n\t\t}\n\t\tputs(ok?""YES"":""NO"");\n\t}\n}\n']","['greedy', 'implementation']",900
https://codeforces.com//contest/1857/problem/E,E. Power of Points,You are given n points with integer coordinates x 1 dots x n which lie on a number line For some integer s we construct segments s x 1 s x 2 dots s x n Note that if x i s then the segment will look like x i s The segment a b covers all integer points a a 1 a 2 dots b We define the of a point p as the number of segments that intersect the point with coordinate p denoted as f p Your task is to compute sum limits p 1 10 9 f p for each s in x 1 dots x n i e the sum of f p for all integer points from 1 to 10 9 For example if the initial coordinates are 1 2 5 7 1 and we choose s 5 then the segments will be 1 5 2 5 5 5 5 7 1 5 And the powers of the points will be f 1 2 f 2 3 f 3 3 f 4 3 f 5 5 f 6 1 f 7 1 f 8 0 dots f 10 9 0 Their sum is 2 3 3 3 5 1 1 18 ,"[""#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n\nusing ll = long long;\nusing ld = long double;\n\n#define int long long\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<pair<int,int>> a(n);\n    vector<int> ans(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i].first;\n        a[i].second = i;\n    }\n    sort(a.begin(), a.end());\n    int cur = 0;\n    for (int i = 0; i < n; ++i) {\n        cur += a[i].first - a[0].first + 1;\n    }\n    ans[a[0].second] = cur;\n    for (int i = 1; i < n; ++i) {\n        cur += i * (a[i].first - a[i - 1].first);\n        cur -= (n - i) * (a[i].first - a[i - 1].first);\n        ans[a[i].second] = cur;\n    }\n    for (int i = 0; i < n; ++i) cout << ans[i] << ' ';\n    cout << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n}""]","['math', 'sortings']",1500
https://codeforces.com//contest/240/problem/C,C. Practice,Little time is left before Berland annual football championship Therefore the coach of team Losewille Rangers decided to resume the practice that were indefinitely interrupted for uncertain reasons Overall there are players in Losewille Rangers Each player on the team has a number a unique integer from 1 to To prepare for the championship the coach Mr Floppe decided to spend some number of practices Mr Floppe spent some long nights of his holiday planning how to conduct the practices He came to a very complex practice system Each practice consists of one game all players of the team take part in the game The players are sorted into two teams in some way In this case the teams may have different numbers of players but each team must have at least one player The coach wants to be sure that after the series of the practice sessions each pair of players had at least one practice when they played in different teams As the players energy is limited the coach wants to achieve the goal in the least number of practices Help him to schedule the practices ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tint n;\n\tcin >> n;\n\tfor (int m = 1;; ++m) {\n\t\tif ((1 << m) < n)\n\t\t\tcontinue;\n\t\tcout << m << endl;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tvector<int> a, b;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (j >> i & 1)\n\t\t\t\t\ta.push_back(j);\n\t\t\t}\n\t\t\tcout << a.size() << "" "";\n\t\t\tfor (int j = 0; j < a.size(); ++j) {\n\t\t\t\tcout << a[j] + 1;\n\t\t\t\tif (j + 1 < a.size())\n\t\t\t\t\tcout << "" "";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation']",1600
https://codeforces.com//contest/1453/problem/A,A. Cancel the Trains,Gildong s town has a train system that has 100 trains that travel from the bottom end to the top end and 100 trains that travel from the left end to the right end The trains starting from each side are numbered from 1 to 100 respectively and all trains have the same speed Let s take a look at the picture below The train system can be represented as coordinates on a 2D plane The i th train starting at the bottom end is initially at i 0 and will be at i T after T minutes and the i th train starting at the left end is initially at 0 i and will be at T i after T minutes All trains arrive at their destinations after 101 minutes However Gildong found that some trains scheduled to depart at a specific time simultaneously are very dangerous At this time n trains are scheduled to depart from the bottom end and m trains are scheduled to depart from the left end If two trains are both at x y at the same time for some x and y they will crash into each other Therefore he is asking you to find the number of trains that should be cancelled to prevent all such crashes ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nint T,n,m,num[105],tx;\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(T);\n\twhile(T--){\n\t\tread(n),read(m);\n\t\tF(i,1,100)num[i]=0;\n\t\tF(i,1,n)read(tx),num[tx]=1;\n\t\tF(i,1,m)read(tx),num[tx]=1;\n\t\tint res=0;\n\t\tF(i,1,100)res+=num[i];\n\t\tcout<<n+m-res<<\'\\n\';\n\t} \n    return 0;\n}']",['implementation'],800
https://codeforces.com//contest/1398/problem/B,B. Substring Removal Game,Alice and Bob play a game They have a binary string s a string such that each character in it is either 0 or 1 Alice moves first then Bob then Alice again and so on During their move the player can choose any number not less than one of in s and delete them For example if the string is 10110 there are 6 possible moves deleted characters are bold textbf 1 0110 to 0110 1 textbf 0 110 to 1110 10 textbf 1 10 to 1010 101 textbf 1 0 to 1010 10 textbf 11 0 to 100 1011 textbf 0 to 1011 After the characters are removed the characters to the left and to the right of the removed block become adjacent I e the following sequence of moves is valid 10 textbf 11 0 to 1 textbf 00 to 1 The game ends when the string becomes empty and the score of each player is Each player wants to maximize their score Calculate the resulting score of Alice ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 5555;\nint n;\nchar s[N];\n\nvoid solve() {\n\n\tscanf(""%s"", s + 1);\n\ts[0] = \'0\';\n\tn = strlen(s);\n\ts[n++] = \'0\';\n\tvector<int> a;\n\tint len = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == \'0\') {\n\t\t\tif (len > 0) a.push_back(len);\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\tlen++;\n\t\t}\n\t}\n\tsort(all(a));\n\treverse(all(a));\n\tint ans = 0;\n\tfor (int i = 0; i < (int)a.size(); i += 2)\n\t\tans += a[i];\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['games', 'greedy', 'sortings']",800
https://codeforces.com//contest/752/problem/D,D. Santa Claus and a Palindrome,Santa Claus likes palindromes very much There was his birthday recently of his friends came to him to congratulate him and each of them presented to him a string having the same length We denote the beauty of the th string by It can happen that is negative that means that Santa doesn t find this string beautiful at all Santa Claus is crazy about palindromes He is thinking about the following question what is the maximum possible total beauty of a palindrome which can be obtained by concatenating some possibly all of the strings he has Each present can be used at most once Note that all strings have Recall that a palindrome is a string that doesn t change after one reverses it Since the empty string is a palindrome too the answer can t be negative Even if all s are negative Santa can obtain the empty string ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint K, N;\nstring s[100100];\nll m[2]={1000000007ll, 1000000009ll}, k[100100];\nmap<ll, vector<ll>> mp;\nmap<ll, ll> opp;\n\nll mxodd, res;\n\nint main () {\n\tcin >> K >> N;\n\tfo(z, 0, K) {\n\t\tll v;\n\t\tcin >> s[z] >> v;\n\t\tll h[2] = {0ll, 0ll}, g[2] = {0ll, 0ll};\n\t\tfor (char c : s[z]) fo(i, 0, 2) h[i] = (h[i] * 137 + c) % m[i];\n\t\treverse(s[z].begin(), s[z].end());\n\t\tfor (char c : s[z]) fo(i, 0, 2) g[i] = (g[i] * 137 + c) % m[i];\n\n\t\tll H = h[0] * 1000000009ll + h[1];\n\t\tll G = g[0] * 1000000009ll + g[1];\n\n\t\tmp[H].PB(v);\n\t\topp[H] = G;\n\t}\n\n\tfor (auto& i : mp) {\n\t\tsort(i.second.begin(), i.second.end());\n\t}\n\n\tfor (auto& x : mp) {\n\t\tll h = x.first;\n\t\tif (h == opp[h]) {\n\t\t\tvector<ll>& a = x.second;\n\t\t\tll X=-1e18, Y=-1e18;\n\t\t\twhile ((int) a.size() >= 2 && a[(int)a.size()-2] + a[(int)a.size()-1] >= 0) {\n\t\t\t\tres += a.back(), X = a.back(), a.pop_back();\n\t\t\t\tres += a.back(), Y = a.back(), a.pop_back();\n\t\t\t}\n\t\t\tif (X != -1e18) {\n\t\t\t\tmxodd = max(mxodd, -Y);\n\t\t\t}\n\t\t\tif (a.size()) mxodd = max(mxodd, a.back());\n\t\t} else if (h < opp[h]) {\n\t\t\tvector<ll> a = x.second, b = mp[opp[h]];\n\t\t\twhile (a.size() && b.size() && a.back() + b.back() >= 0) {\n\t\t\t\tres += a.back() + b.back();\n\t\t\t\ta.pop_back(), b.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(""%lld\\n"", res + mxodd);\n\n\treturn 0;\n}\n\n']","['data structures', 'greedy', 'hashing', 'strings']",2100
https://codeforces.com//contest/794/problem/A,A. Bank Robbery,A robber has attempted to rob a bank but failed to complete his task However he had managed to open all the safes Oleg the bank client loves money who doesn t and decides to take advantage of this failed robbery and steal some money from the safes There are many safes arranged in a line where the th safe from the left is called safe There are banknotes left in all the safes in total The th banknote is in safe Oleg is now at safe There are two security guards one of which guards the safe such that i e the first guard is to the left of Oleg The other guard guards the safe so that i e he is to the right of Oleg The two guards are very lazy so they do not move In every second Oleg can either take all the banknotes from the current safe or move to any of the neighboring safes However he cannot visit any safe that is guarded by security guards at any time becaues he might be charged for stealing Determine the maximum amount of banknotes Oleg can gather ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\t\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tint n, ans = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif ((x > b) && (x < c)) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']","['brute force', 'implementation']",800
https://codeforces.com//contest/631/problem/E,E. Product Sum,Blake is the boss of Kris however this doesn t spoil their friendship They often gather at the bar to talk about intriguing problems about maximising some values This time the problem is really special You are given an array of length The of this array is the value the sum of the products of the values by One may perform the following operation pick some element of the array and move to any position In particular it s allowed to move the element to the beginning or to the end of the array Also it s allowed to put it back to the initial position The goal is to get the array with the maximum possible value of characteristic ,"[""#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 200011;\ntypedef long long intl;\n\nintl a[N];\nintl sum[N];\n\nintl dp[N];\n\n#define x first\n#define y second\npair <intl, intl> sta[N];\n\nintl cross(pair <intl, intl> lhs, pair <intl, intl> rhs)\n{\n\treturn lhs.x * rhs.y - lhs.y * rhs.x;\n}\npair <intl, intl> sub(pair <intl, intl> lhs, pair <intl, intl> rhs)\n{\n\treturn {lhs.x - rhs.x, lhs.y - rhs.y};\n}\n\nintl calc(intl k, int n)\n{\n\treturn -k * sta[n].x + sta[n].y;\n}\n\nintl solve(intl k, int n)\n{\n\tint left = 0, right = n;\n\twhile(left + 1 < right)\n\t{\n\t\tint mid = (left + right) / 2;\n\t\tif(calc(k, mid) >= calc(k, mid - 1))\n\t\t\tleft = mid;\n\t\telse\n\t\t\tright = mid;\n\t}\n\treturn calc(k, left);\n}\n\nint main()\n{\n\tios :: sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tintl offset = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tcin >> a[i];\n\t\toffset += a[i] * i;\n\t\tsum[i] = sum[i - 1] + a[i];\n\t}\n\tif(n == 1)\n\t{\n\t\tcout << offset << '\\n';\n\t\treturn 0;\n\t}\n\tfill(dp + 1, dp + n + 1, -1e18);\n\tint top = 0;\n\tsta[top ++] = {n, -sum[n]};\n\tfor(int i = n - 1; i >= 1; i --)\n\t{\n\t\tdp[i] = max(dp[i], solve(-a[i], top) + sum[i] - i * a[i]);\n\t\twhile(top >= 2 && cross(sub({i, -sum[i]}, sta[top - 1]),\n\t\t\tsub(sta[top - 1], sta[top - 2])) >= 0)\n\t\t\ttop --;\n\t\tsta[top ++] = {i, -sum[i]};\n\t}\n\t\n\ttop = 0;\n\tsta[top ++] = {1, 0};\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tdp[i] = max(dp[i], solve(-a[i], top) + sum[i - 1] - i * a[i]);\n\t\twhile(top >= 2 && cross(sub({i, -sum[i - 1]}, sta[top - 1]),\n\t\t\tsub(sta[top - 1], sta[top - 2])) <= 0)\n\t\t\ttop --;\n\t\tsta[top ++] = {i, -sum[i - 1]};\n\t}\n\n\tintl ans = offset;\n\tfor(int i = 1; i <= n; i ++)\n\t\tans = max(ans, dp[i] + offset);\n\tcout << ans << '\\n';\n\treturn 0;\n}""]","['data structures', 'dp', 'geometry']",2600
https://codeforces.com//contest/1495/problem/B,B. Let s Go Hiking,On a weekend Qingshan suggests that she and her friend Daniel go hiking Unfortunately they are busy high school students so they can only go hiking on scratch paper A permutation p is written from left to right on the paper First Qingshan chooses an integer index x 1 le x le n and tells it to Daniel After that Daniel chooses another integer index y 1 le y le n y ne x The game progresses turn by turn and as usual Qingshan moves first The rules follow If it is Qingshan s turn Qingshan must change x to such an index x that 1 le x le n x x 1 x ne y and p x p x at the same time If it is Daniel s turn Daniel must change y to such an index y that 1 le y le n y y 1 y ne x and p y p y at the same time The person who can t make her or his move loses and the other wins You as Qingshan s fan are asked to calculate the number of possible x to make Qingshan win in the case both players play optimally ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nint lew[nax];\nint pra[nax];\n\nint lewo[nax];\nint prao[nax];\n\nint wyn;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &tab[i]);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (tab[i]>tab[i-1])\n\t\t\tlew[i]=lew[i-1];\n\t\tlew[i]++;\n\t\t\n\t\tif (tab[i]<tab[i-1])\n\t\t\tlewo[i]=lewo[i-1];\n\t\tlewo[i]++;\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]>tab[i+1])\n\t\t\tpra[i]=pra[i+1];\n\t\tpra[i]++;\n\t\t\n\t\tif (tab[i]<tab[i+1])\n\t\t\tprao[i]=prao[i+1];\n\t\tprao[i]++;\n\t}\n\tint naj=0;\n\tvi wek;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tnaj=max(naj, max(lew[i], pra[i]));\n\t\twek.push_back(max(lew[i], pra[i]));\n\t}\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\tdebug() << wek;\n\tif (wek[0]==wek[1] || !(naj&1))\n\t{\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tdebug() << ""no"";\n\tfor (int i=1; i<=n; i++)\n\t\twyn+=(lew[i]==naj && pra[i]==naj);\n\tprintf(""%d\\n"", wyn);\n\treturn 0;\n}\n']","['games', 'greedy']",1900
https://codeforces.com//contest/254/problem/E,E. Dormitory,Student Vasya came to study in Berland State University from the country so he is living in a dormitory A semester has days and in each of those days his parents send him some food In the morning of the th day he receives kilograms of food that can be eaten on that day and on the next one then the food goes bad and becomes unfit for consumption Every day Vasya eats kilograms of food It is known that Vasya s parents do not allow him to starve so there always is enough food for Vasya Vasya has friends who sometimes live with him Let s index the friends from 1 to Friend number lives with Vasya from day to day inclusive Also the th friend requires kilograms of food per day Usually Vasya s friends eat in the canteen but sometimes generous Vasya feeds some of them Every day Vasya can feed some friends who live with him this day or may feed nobody Every time Vasya feeds his friend he gives him as much food as the friend needs for the day and Vasya s popularity rating at the University increases by one Vasya cannot feed the same friend multiple times in one day In addition he knows that eating habits must be regular so he always eats kilograms of food per day Vasya wants so choose whom he will feed each day of the semester to make his rating as high as possible Originally Vasya s rating is 0 because he is a freshman ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[405][405];\nint dpl[405][405];\nint re[405][405];\nint a[405];\nstruct node\n{\n\tint l,r,v,i;\n}b[405];\nbool cmp( node a, node b )\n{\n\treturn a.v < b.v;\n}\nint main()\n{\n\tfreopen(""input.txt"",""r"",stdin);\n\tfreopen(""output.txt"",""w"",stdout);\n\tmemset( dp, -1, sizeof( dp ));\n\n\tint n,v;\n\tscanf( ""%d%d"", &n, &v );\n\tfor ( int i = 1; i <= n; i++ )\n\t\tscanf( ""%d"", &a[i] );\n\n\tint m;\n\tscanf( ""%d"", &m );\n\tfor ( int i = 0; i < m; i++ )\n\t{\n\t\tscanf( ""%d%d%d"", &b[i].l, &b[i].r, &b[i].v );\n\t\tb[i].i = i + 1;\n\t}\n\n\tsort( b, b + m, cmp );\n\n\tdp[0][0] = 0;\n\n\tfor ( int i = 1; i <= n; i++ )\n\t{\n\t\tfor ( int j = 0; j <= 400; j++ )\n\t\tif ( dp[i-1][j] != -1 )\n\t\tif ( j + a[i] >= v )\n\t\t{\n\t\t\tint s = 0;\n\t\t\tint s1 = 0;\n\t\t\tif ( j >= v )\n\t\t\t{\n\t\t\t\tif ( dp[i][a[i]] < dp[i-1][j] ) \n\t\t\t\t{\n\t\t\t\t\tdp[i][a[i]] = dp[i-1][j];\n\t\t\t\t\tdpl[i][a[i]] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tif ( dp[i][a[i]+j-v] < dp[i-1][j] ) \n\t\t\t\t{\t\n\t\t\t\t\t dp[i][a[i]+j-v] = dp[i-1][j];\n\t\t\t\t\t dpl[i][a[i]+j-v] = j;\n\t\t\t\t}\n\t\t\tfor ( int k = 0; k < m; k++ )\n\t\t\tif ( b[k].l <= i && b[k].r >= i && j + a[i] >= v + s + b[k].v )\n\t\t\t{\n\t\t\t\ts += b[k].v;\n\t\t\t\ts1++;\n\t\t\t\tif ( j >= v + s )\n\t\t\t\t{\n\t\t\t\t\tif ( dp[i][a[i]] < dp[i-1][j] + s1 ) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][a[i]] = dp[i-1][j] + s1;\n\t\t\t\t\t\tdpl[i][a[i]] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( dp[i][a[i]+j-v-s] < dp[i-1][j] + s1 ) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][a[i]+j-v-s] = dp[i-1][j] + s1;\n\t\t\t\t\t\tdpl[i][a[i]+j-v-s] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\tfor ( int i = 0; i <= 400; i++ )\n\tif ( dp[n][i] > dp[n][mm] ) mm = i;\n\tint ans = dp[n][mm];\n\tprintf( ""%d\\n"", ans );\n\tfor ( int i = n; i >= 1; i-- )\n\t{\n//\t\tprintf(""%d %d %d\\n"",i,dpl[i][mm],dp[i][mm]);\n//\t\tprintf(""%d %d\\n"",i,dp[i][mm]);\n\t\tint k = dp[i][mm] - dp[i-1][dpl[i][mm]];\n\t\tmm = dpl[i][mm];\n\t\tfor( int j = 0; j < m; j++ )\n\t\t{\n\t\t\tif ( k == 0 ) break;\n\t\t\tif ( b[j].l <= i && b[j].r >= i )\n\t\t\t{\n\t\t\t\tre[i][++re[i][0]] = b[j].i;\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tfor ( int i = 1; i <= n; i++ )\n\t{\n\t\tprintf(""%d"",re[i][0]);\n\t\tfor ( int j = 1; j <= re[i][0]; j++ )\n\t\t\tprintf("" %d"",re[i][j]);\n\t\tputs("""");\n\t}\n\treturn 0;\n}']","['dp', 'implementation']",2100
https://codeforces.com//contest/1768/problem/A,A. Greatest Convex,You are given an integer k Find the largest integer x where 1 le x k such that x x 1 dagger is a multiple of ddagger k or determine that no such x exists dagger y denotes the factorial of y which is defined recursively as y y cdot y 1 for y geq 1 with the base case of 0 1 For example 5 5 cdot 4 cdot 3 cdot 2 cdot 1 cdot 0 120 ddagger If a and b are integers then a is a multiple of b if there exists an integer c such that a b cdot c For example 10 is a multiple of 5 but 9 is not a multiple of 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=2e5+10;\nint a[maxn],m,n,t_case;\nint main(){\n\tscanf(""%d"",&t_case);\n\twhile(t_case--){\n\t\tscanf(""%d"",&n);\n\t\tprintf(""%d\\n"",n-1);\n\t}\n\treturn 0;\n}\n']","['greedy', 'math', 'number theory']",800
https://codeforces.com//contest/903/problem/C,C. Boxes Packing,Mishka has got empty boxes For every th box is a cube with side length Mishka can put a box into another box if the following conditions are met th box is not put into another box th box doesn t contain any other boxes box is smaller than box Mishka can put boxes into each other an arbitrary number of times He wants to minimize the number of boxes A box is called iff it is not put into some another box Help Mishka to determine the minimum possible number of boxes ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nmap <int, int> Mx;\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\twhile (N--) {\n\t\tscanf(""%d"", &i);\n\t\tMx[i]++;\n\t}\n\n\tint ans = 0;\n\tfor (auto it : Mx) ans = max(ans, it.second);\n\treturn !printf(""%d\\n"", ans);\n}']",['greedy'],1200
https://codeforces.com//contest/1012/problem/F,F. Passports,Gleb is a famous competitive programming teacher from Innopolis He is planning a trip to programming camps in the nearest future Each camp will be held in a different country For each of them Gleb needs to apply for a visa For each of these trips Gleb knows three integers the number of the first day of the trip the length of the trip in days and the number of days this country s consulate will take to process a visa application and stick a visa in a passport Gleb has valid passports and is able to decide which visa he wants to put in which passport For each trip Gleb will have a flight to that country early in the morning of the day and will return back late in the evening of the day To apply for a visa on the day Gleb needs to be in Innopolis in the middle of this day So he can t apply for a visa while he is on a trip including the first and the last days If a trip starts the next day after the end of the other one Gleb can t apply for a visa between them as well The earliest Gleb can apply for a visa is day 1 After applying for a visa of country on day Gleb will get his passport back in the middle of the day Consulates use delivery services so Gleb can get his passport back even if he is not in Innopolis on this day Gleb can apply for another visa on the same day he received his passport back if he is in Innopolis this day Gleb will not be able to start his trip on day if he doesn t has a passport with a visa for the corresponding country in the morning of day In particular the passport should not be in another country s consulate for visa processing Help Gleb to decide which visas he needs to receive in which passport and when he should apply for each visa ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = INT_MAX;\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  int n, m;\n  scanf(""%d %d"", &n, &m);\n  vector<int> s(n), length(n), t(n), by_s(n), by_t(n), by(n), day(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(""%d %d %d"", &s[i], &length[i], &t[i]);\n    by_s[i] = by_t[i] = i;\n  }\n  vector<int> f(1 << n, inf);\n  vector<pair<int, int>> from(1 << n);\n  f[0] = 1;\n  sort(by_s.begin(), by_s.end(), [&](const int &x, const int &y) {\n    return s[x] < s[y];\n  });\n  sort(by_t.begin(), by_t.end(), [&](const int &x, const int &y) {\n    return t[x] < t[y];\n  });\n  for (int i = 0; i < 1 << n; ++i) {\n    if (f[i] != inf) {\n      int pointer = 0, value = f[i];\n      for (auto j : by_t) {\n        if (!(i >> j & 1)) {\n          while (pointer < n && value + t[j] >= s[by_s[pointer]]) {\n            int p = by_s[pointer++];\n            if ((i >> p & 1) || value >= s[p]) {\n              value = max(value, s[p] + length[p]);\n            }\n          }\n          if (value + t[j] < s[j] && f[i | 1 << j] > value + t[j]) {\n            f[i | 1 << j] = value + t[j];\n            from[i | 1 << j] = make_pair(j, value);\n          }\n        }\n      }\n    }\n  }\n  function<void(int, int)> rec = [&](int x, int type) {\n    if (!x) {\n      return;\n    }\n    int i = from[x].first;\n    by[i] = type;\n    day[i] = from[x].second;\n    rec(x ^ 1 << i, type);\n  };\n  if (m == 1) {\n    if (f[(1 << n) - 1] != inf) {\n      puts(""YES"");\n      rec((1 << n) - 1, 1);\n      for (int i = 0; i < n; ++i) {\n        printf(""%d %d\\n"", by[i], day[i]);\n      }\n    } else {\n      puts(""NO"");\n    }\n  } else {\n    int p = -1;\n    for (int i = 0; i < (1 << n); ++i) {\n      if (f[i] != inf && f[(1 << n) - 1 ^ i] != inf) {\n        p = i;\n        break;\n      }\n    }\n    if (!~p) {\n      puts(""NO"");\n    } else {\n      puts(""YES"");\n      rec(p, 1);\n      rec((1 << n) - 1 ^ p, 2);\n      for (int i = 0; i < n; ++i) {\n        printf(""%d %d\\n"", by[i], day[i]);\n      }\n    }\n  }\n  return 0;\n}\n']","['dp', 'implementation']",3400
https://codeforces.com//contest/1920/problem/E,E. Counting Binary Strings,Patrick calls a substring dagger of a binary string ddagger if this substring contains exactly one Help Patrick count the number of binary strings s such that s contains exactly n good substrings and has no good substring of length strictly greater than k Note that substrings are differentiated by their location in the string so if s you should count both occurrences of dagger A string a is a substring of a string b if a can be obtained from b by the deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ddagger A binary string is a string that only contains the characters and ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int N=2510, mod=998244353;\nint f[N][N], n, k;\n\nvoid add(int &x, int y){\n   x=x+y>=mod?x+y-mod:x+y;\n}\n\nvoid solve(){\n   cin >> n >> k;\n   for (int i=0; i<=n; ++i) f[0][i]=1;\n   for (int i=1; i<=n; ++i){\n      for (int j=0; j<=i; ++j){\n         for (int t=0; t<=n; ++t){\n            int d=i-(j+1)*(t+1);\n            if (d<0 || j+t+1>k) break;\n            add(f[i][j], f[d][t]);\n         }\n      }\n   }\n   int ans=0;\n   for (int i=0; i<=n; ++i) add(ans, f[n][i]);\n   cout << ans << '\\n';\n   for (int i=0; i<=n; ++i) for (int j=0; j<=n; ++j) f[i][j]=0;\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n""]","['combinatorics', 'dp', 'math']",2100
https://codeforces.com//contest/604/problem/A,A. Uncowed Forces,Kevin Sun has just finished competing in Codeforces Round 334 The round was 120 minutes long and featured five problems with maximum point values of 500 1000 1500 2000 and 2500 respectively Despite the challenging tasks Kevin was uncowed and bulldozed through all of them distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia Kevin knows his submission time for each problem the number of wrong submissions that he made on each problem and his total numbers of successful and unsuccessful hacks Because Codeforces scoring is complicated Kevin wants you to write a program to compute his final score Codeforces scores are computed as follows If the maximum point value of a problem is and Kevin submitted correctly at minute but made wrong submissions then his score on that problem is His total score is equal to the sum of his scores for each problem In addition Kevin s total score gets increased by points for each successful hack but gets decreased by points for each unsuccessful hack All arithmetic operations are performed with absolute precision and no rounding It is guaranteed that Kevin s final score is an integer ,"['#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, t[10], w[10], a, b;\n\ndouble mod (double x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nint main()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nfor (int i=1; i<=5; i++)\n    scanf (""%d"", &t[i]);\nfor (int i=1; i<=5; i++)\n    scanf (""%d"", &w[i]);\nscanf (""%d %d"", &a, &b);\ndouble val = 100.0 * a - 50.0 * b;\nfor (int i=1; i<=5; i++)\n{\n    double x = i * 500.0;\n    double curr = x - (double) x * t[i] / 250.0 - 50.0 * w[i];\n    if (0.3 * x > curr) curr = 0.3 * x;\n    val += curr;\n}\n/*int sol = (int) val, pos, mini = 10000.0;\nfor (int i=sol - 2; i<=sol + 2; i++)\n    if (mod ((double) i - val) < mini)\n        mini = mod ((double) i - val), pos = i;\nprintf (""%d\\n"", pos);*/\nprintf (""%.lf\\n"", val);\n\nreturn 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/1150/problem/A,A. Stock Arbitraging,Welcome to Codeforces Stock Exchange We re pretty limited now as we currently allow trading on one stock Codeforces Ltd We hope you ll still be able to make profit from the market In the morning there are n opportunities to buy shares The i th of them allows to buy as many shares as you want each at the price of s i bourles In the evening there are m opportunities to sell shares The i th of them allows to sell as many shares as you want each at the price of b i bourles You can t sell more shares than you have It s morning now and you possess r bourles and no shares What is the maximum number of bourles you can hold after the evening ,"['#include<bits/stdc++.h>\nconst int MAXN=30+5;\nint n,m,r;\nint s[MAXN+5],b[MAXN+5];\nint mins=1000,maxb=1;\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&r);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(""%d"",&s[i]);\n\t\tmins=std::min(mins,s[i]);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(""%d"",&b[i]);\n\t\tmaxb=std::max(maxb,b[i]);\n\t}\n\tif(mins>=maxb){\n\t\tprintf(""%d\\n"",r);\n\t}else{\n\t\tprintf(""%d\\n"",r%mins+r/mins*maxb);\n\t}\n\treturn 0;\n}']","['greedy', 'implementation']",800
https://codeforces.com//contest/1190/problem/D,D. Tokitsukaze and Strange Rectangle,There are n points on the plane the i th of which is at x i y i Tokitsukaze wants to draw a strange rectangular area and pick all the points in the area The strange area is enclosed by three lines x l y a and x r as its left side its bottom side and its right side respectively where l r and a can be any real numbers satisfying that l r The upper side of the area is boundless which you can regard as a line parallel to the x axis at infinity The following figure shows a strange rectangular area A point x i y i is in the strange rectangular area if and only if l x i r and y i a For example in the above figure p 1 is in the area while p 2 is not Tokitsukaze wants to know how many different non empty sets she can obtain by picking all the points in a strange rectangular area where we think two sets are different if there exists at least one point in one set of them but not in the other ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\npii a[N];\nint xs[N];\nint xsSz;\nint n;\nint fenv[N];\nbool used[N];\n\nvoid addFenv(int p, int x) {\n\tfor(; p < N; p |= p + 1)\n\t\tfenv[p] += x;\n}\nint getFenv(int r) {\n\tint res = 0;\n\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\tres += fenv[r];\n\treturn res;\n}\nint getSum(int l, int r) {\n\treturn getFenv(r - 1) - getFenv(l - 1);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d%d"", &a[i].second, &a[i].first);\n\tsort(a, a + n);\n\tn = unique(a, a + n) - a;\n\tfor (int i = 0; i < n; i++) {\n\t\txs[xsSz++] = a[i].second;\n\t}\n\tsort(xs, xs + xsSz);\n\txsSz = unique(xs, xs + xsSz) - xs;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i].second = lower_bound(xs, xs + xsSz, a[i].second) - xs;\n\tll ans = 0;\n\tint l = 0;\n\treverse(a, a + n);\n\tll m = 0;\n\twhile(l < n) {\n\t\tint r = l;\n\t\twhile(r < n && a[l].first == a[r].first) r++;\n\t\tvector<int> z;\n\t\tfor (int i = l; i < r; i++)\n\t\t\tz.push_back(a[i].second);\n\t\tz.push_back(-1);\n\t\tz.push_back(xsSz);\n\t\tsort(z.begin(), z.end());\n\t\tz.resize(unique(z.begin(), z.end()) - z.begin());\n\t\tfor (int i = 0; i < (int)z.size() - 1; i++) {\n\t\t\tint L = z[i] + 1, R = z[i + 1];\n\t\t\tll w = getSum(L, R);\n\t\t\tans -= w * (w + 1) / 2;\n\t\t}\n\t\twhile(l < r) {\n\t\t\tif (!used[a[l].second]) {\n\t\t\t\tm++;\n\t\t\t\tused[a[l].second] = 1;\n\t\t\t\taddFenv(a[l].second, 1);\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tans += m * (m + 1) / 2;\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['data structures', 'divide and conquer', 'sortings', 'two pointers']",2000
https://codeforces.com//contest/138/problem/E,E. Hellish Constraints,Katya recently started to invent programming tasks and prepare her own contests What she does not like is boring and simple constraints Katya is fed up with all those does not exceed a thousand and the sum of does not exceed a million and she decided to come up with something a little more complicated The last problem written by Katya deals with strings The input is a string of small Latin letters To make the statement longer and strike terror into the people who will solve the contest Katya came up with the following set of restrictions of the same type characters in restrictions can be repeated and some restrictions may contradict each other The number of characters in a string is not less than and not more than The number of characters in a string is not less than and not more than The number of characters in a string is not less than and not more than However having decided that it is too simple and obvious Katya added the following condition a string meets no less than and not more than constraints from the above given list Katya does not like to compose difficult and mean tests so she just took a big string and wants to add to the tests all its substrings that meet the constraints However Katya got lost in her conditions and asked you to count the number of substrings of the string that meet the conditions each occurrence of the substring is counted separately ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MAXL = 1e6;\nchar s[MAXL + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(""std.in"", ""r"", stdin);\n  freopen(""std.out"", ""w"", stdout);\n  #endif\n\n  int k, L, R;\n  while (scanf(""%s%d%d%d"", s, &k, &L, &R) >= 1) {\n    k *= 2;\n    vector<char> cs(k);\n    vi mivs(k), ks(k);\n    for (int i = 0; i < k;) {\n      int l, r;\n      scanf("" %c%d%d"", &cs[i], &l, &r), cs[i];\n      mivs[i] = r + 1; ks[i] = -1;\n      i++;\n\n      cs[i] = cs[i - 1];\n      mivs[i] = l; ks[i] = 1;\n      i++;\n    }\n    int n = strlen(s);\n\n    vvi poses(128);\n    vi pid(n);\n    for (int i = n - 1; i >= 0; i--) {\n      int c = s[i];\n      pid[i] = sz(poses[c]);\n      poses[c].pb(i);\n    }\n\n    int zcnt = 0;\n    for (int i = 0; i < k; i++)\n      if (mivs[i] == 0)\n        zcnt += ks[i];\n\n    vi cnt(n, zcnt);\n    int ccnt = 0;\n    ll ans = 0;\n    for (int st = n - 1; st >= 0; st--) {\n      int c = s[st];\n//      eprintf(""st=%d: %c; cnt=%d\\n"", st, c, cnt[st]);\n\n      if (L <= cnt[st] && cnt[st] <= R)\n        ccnt++;\n\n      for (int i = 0; i < k; i++) if (cs[i] == c && mivs[i] >= 1 && mivs[i] <= pid[st] + 1) {\n//        eprintf(""  cond: >=%d, k=%d\\n"", mivs[i], ks[i]);\n        int npid = pid[st] - mivs[i] + 1;\n        assert(npid >= 0);\n        int l = poses[c][npid];\n        int r = npid > 0 ? poses[c][npid - 1] : n;\n//        eprintf(""  l=%d, r=%d\\n"", l, r);\n\n        assert(st <= l && l <= r && r <= n);\n        for (int i2 = l; i2 < r; i2++) {\n          bool ov = L <= cnt[i2] && cnt[i2] <= R;\n          cnt[i2] += ks[i];\n//          eprintf(""  cnt[%d]=%d\\n"", i2, cnt[i2]);\n          bool nv = L <= cnt[i2] && cnt[i2] <= R;\n          ccnt += ((int)nv - ov);\n        }\n      }\n\n//      eprintf("" ccnt=%d\\n"", ccnt);\n      ans += ccnt;\n    }\n    printf(""%I64d\\n"", ans);\n  }\n  return 0;\n}\n']","['brute force', 'dp', 'two pointers']",2900
https://codeforces.com//contest/185/problem/D,D. Visit of the Great,The Great Mushroom King descended to the dwarves but not everyone managed to see him Only the few chosen ones could see the King We know that only dwarves can see the Great Mushroom King Numbers are chosen by the Great Mushroom King himself in some complicated manner which is unclear to common dwarves The dwarven historians decided to document all visits of the Great Mushroom King For each visit the dwarven historians know three integers chosen by the Great Mushroom King for this visit They also know a prime number Help them to count the remainder of dividing the number of dwarves who can see the King by number for each visit ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nll power(ll x, ll n, ll p){\n    if(n == 0) return 1;\n    ll y = power(x, n/2, p);\n    y = y * y % p;\n    if(n % 2 == 1) y = y * x % p;\n    return y;\n}\n\nll power2(ll x, ll n, ll p){ // (x ^ (2 ^ n)) mod p\n    if(x % p == 0) return 0;\n    ll tmp = power(2, n, p-1);\n    return power(x, tmp, p);\n}\n\nll func(ll x, ll l, ll r, ll p){\n    int i;\n    \n    if(p == 2){\n        if(x%2 == 0) return 1;\n        return 0;\n    }\n    \n    ll y = power2(x, l, p);\n    \n    ll z;\n    if(y == 1){\n        z = power(2, r+1-l, p);\n    } else {\n        ll a = power2(x, r+1, p);\n        a = (a + p - 1) % p;\n        ll b = y;\n        b = (b + p - 1) % p;\n        z = a * power(b, p-2, p) % p;\n    }\n    \n    if(x % 2 == 0) return z;\n    \n    ll ord_sum = r - l + 1;\n    ll max_ord = 1;\n    \n    if(l == 0){\n        ll tmp = x + 1;\n        max_ord = 0;\n        while(tmp % 2 == 0){\n            tmp /= 2;\n            max_ord++;\n        }\n        ord_sum += max_ord - 1;\n    }\n    \n    ord_sum -= max_ord;\n    ll two = power(2, ord_sum, p);\n    z = z * power(two, p-2, p) % p;\n    \n    return z;\n}\n\nint main(void){\n    int T,t;\n    ll x,l,r,p;\n    \n    cin >> T;\n    REP(t,T){\n        cin >> x >> l >> r >> p;\n        ll ans = func(x, l, r, p);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n']","['math', 'number theory']",2600
https://codeforces.com//contest/932/problem/G,G. Palindrome Partition,Given a string find the number of ways to split to substrings such that if there are substrings in partition then for all and is even Since the number of ways can be large print it modulo ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst ll mod=1000*1000*1000+7;\n\nconst int maxn=1000*1000+7, alfa=26;\nint len[maxn], link[maxn], to[maxn][alfa], slink[maxn], diff[maxn];\nint sz, last, n;\nchar s[maxn];\n\nvoid init() {\n\ts[n++]=len[1]=-1;\n\tlink[0]=1;\n\tsz=2;\n}\nint get_link(int v) {\n\twhile(s[n-len[v]-2]!=s[n-1]) v=link[v];\n\treturn v;\n}\nvoid add_letter(char c) {\n\ts[n++]=c-=\'a\';\n\tlast=get_link(last);\n\tif(!to[last][c]) {\n\t\tlen[sz]=len[last]+2;\n\t\tlink[sz]=to[get_link(link[last])][c];\n\t\tdiff[sz]=len[sz]-len[link[sz]];\n\t\tslink[sz]=(diff[sz]==diff[link[sz]] ? slink[link[sz]] : link[sz]);\n\t\tto[last][c]=sz++;\n\t}\n\tlast=to[last][c];\n}\n\nconst int nax=1e6+7;\nint m;\nchar wcz[nax];\nchar tekst[nax];\n\nll dp[nax];\nll serdp[nax];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main() {\n\tscanf(""%s"", wcz+1);\n\tm=strlen(wcz+1);\n\tfor (int i=1; i<=m/2; i++)\n\t{\n\t\ttekst[2*i-1]=wcz[i];\n\t\ttekst[2*i]=wcz[m+1-i];\n\t}\n\tinit();\n\tdp[0]=1;\n\tfor(int i=1; i<=m; i++) {\n\t\tadd_letter(tekst[i]);\n\t\tfor(int v=last; len[v]>0; v=slink[v]) {\n\t\t\tserdp[v]=dp[i-(len[slink[v]]+diff[v])];\n\t\t\tif(diff[v] == diff[link[v]])\n\t\t\t\tdod(serdp[v], serdp[link[v]]);\n\t\t\tif (!(i&1)) {\n\t\t\t\tdod(dp[i], serdp[v]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"", dp[m]);\n}\n']","['dp', 'string suffix structures', 'strings']",2900
https://codeforces.com//contest/353/problem/A,A. Domino,Valera has got domino pieces in a row Each piece consists of two halves the upper one and the lower one Each of the halves contains a number from to Valera loves even integers very much so he wants the sum of the numbers on the upper halves and the sum of the numbers on the lower halves to be even To do that Valera can rotate the dominoes by degrees After the rotation the upper and the lower halves swap places This action takes one second Help Valera find out the minimum time he must spend rotating dominoes to make his wish come true ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n    cin.sync_with_stdio(0);\n    int N, sa =0, sb =0,a,b;\n    cin >> N;\n    int rev =0;\n    for(int i =0; i < N; i++) {\n        cin >> a >> b;\n        sa +=a, sb +=b;\n        if((a-b)%2 != 0) rev++;}\n    \n    if((sb+sa)%2 != 0) cout << ""-1\\n"";\n    else {\n        if(rev > 0) cout << (int)(sa%2 != 0) << ""\\n"";\n        else {if(sa%2 == 0) cout << ""0\\n""; else cout << ""-1\\n"";}}\n    return 0;}\n']","['implementation', 'math']",1200
https://codeforces.com//contest/1834/problem/A,A. Unit Array,Given an array a of length n which elements are equal to 1 and 1 Let s call the array a if the following conditions are held at the same time a 1 a 2 ldots a n ge 0 a 1 cdot a 2 cdot ldots cdot a n 1 In one operation you can select an arbitrary element of the array a i and change its value to the opposite In other words if a i 1 you can assign the value to a i 1 and if a i 1 then assign the value to a i 1 Determine the minimum number of operations you need to perform to make the array a good It can be shown that this is always possible ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvoid mermermer()\n{\n\tint n;\n\tcin >> n;\n\tint x=0,y=0;\n\twhile(n--)\n\t{\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t==1) ++x;\n\t\telse ++y;\n\t}\n\tint ans=0;\n\twhile(!(x-y>=0&&y%2==0)) --y,++x,++ans;\n\tcout << ans << ""\\n"";\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) mermermer();\n\treturn 0;\n}\n//bu pa kun nan!!!']","['greedy', 'math']",800
https://codeforces.com//contest/893/problem/E,E. Counting Arrays,You are given two positive integer numbers and An array is called an of iff the following conditions are met There are elements in and all of them are integer numbers You have to count the number of pairwise distinct arrays that are factorizations of Two arrays and are considered different iff there exists at least one index such that Since the answer can be very large print it modulo ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nconst int N = 1111111;\nint erat[N];\n\nconst int mod = 1000000007;\nint fact[N];\nint invfact[N];\n\nlong long pw(long long a, long long b) {\n\tlong long res = 1;\n\twhile (b) {\n\t\tif (b & 1ll) {\n\t\t\tres = res * a % mod;\n\t\t}\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nlong long C(int n, int k) {\n\treturn fact[n] * 1ll * invfact[n - k] % mod * invfact[k] % mod;\n}\n\nint main() {\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (erat[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\terat[i] = i;\n\t\tif (1.0 * i * i < N + N) {\n\t\t\tfor (int j = i * i; j < N; j += i) {\n\t\t\t\tif (erat[j] == 0) {\n\t\t\t\t\terat[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfact[i] = 1ll * i * fact[i - 1] % mod;\n\t}\n\tinvfact[N - 1] = pw(fact[N - 1], mod - 2);\n\tfor (int i = N - 2; i >= 0; --i) {\n\t\tinvfact[i] = 1ll * invfact[i + 1] * (i + 1) % mod;\n\t}\n\n\tint q = nxt();\n\twhile (q--) {\n\t\tint x = nxt(), y = nxt();\n\t\tlong long ans = 1;\n\t\tint last = 0;\n\t\tint cnt = 0;\n\t\twhile (x > 1) {\n\t\t\tint p = erat[x];\n\t\t\tif (p == last) {\n\t\t\t\t++cnt;\n\t\t\t} else {\n\t\t\t\tans = ans * C(cnt + y - 1, cnt) % mod;\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t\tlast = p;\n\t\t\tx /= p;\n\t\t}\n\t\tans = ans * C(cnt + y - 1, cnt) % mod;\n\t\tans = ans * pw(2, y - 1) % mod;\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math', 'number theory']",2000
https://codeforces.com//contest/1068/problem/A,A. Birthday,Ivan is collecting coins There are only N different collectible coins Ivan has K of them He will be celebrating his birthday soon so all his M freinds decided to gift him coins They all agreed to three terms Everyone must gift as many coins as others All coins given to Ivan must be different Not less than L coins from gifts altogether must be new in Ivan s collection But his friends don t know which coins have Ivan already got in his collection They don t want to spend money so they want to buy minimum quantity of coins that satisfy all terms irrespective of the Ivan s collection Help them to find this minimum number of coins or define it s not possible to meet all the terms ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tlong long n, m, k, l; cin >> n >> m >> k >> l;\n\tlong long need = k + l;\n\tlong long ans = (need + m - 1) / m;\n\tif (ans * m > n) ans = -1;\n\tcout << ans << '\\n';\n}\n""]",['math'],1400
https://codeforces.com//contest/1840/problem/D,D. Wooden Toy Festival,In a small town there is a workshop specializing in woodwork Since the town is small only carvers work there Soon a wooden toy festival is planned in the town The workshop employees want to prepare for it They know that n people will come to the workshop with a request to make a wooden toy People are different and may want different toys For simplicity let s denote the pattern of the toy that the i th person wants as a i 1 le a i le 10 9 Each of the carvers can choose an integer pattern x 1 le x le 10 9 in advance x is the integer During the preparation for the festival the carvers will perfectly work out the technique of making the toy of the chosen pattern which will allow them to cut it out of wood instantly To make a toy of pattern y for a carver who has chosen pattern x it will take x y time because the more the toy resembles the one he can make instantly the faster the carver will cope with the work On the day of the festival when the next person comes to the workshop with a request to make a wooden toy the carvers can choose who will take on the job At the same time the carvers are very skilled people and can work on orders for different people Since people don t like to wait the carvers want to choose patterns for preparation in such a way that the waiting time over all people is as as possible Output the maximum waiting time that the carvers can achieve ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200000], n;\ninline bool check(long long x) {\n\tlong long pre = a[0] + x;\n\tint cnt = 1;\n\tfor (int i = 0; i ^ n; ++i) {\n\t\tif (abs(a[i] - pre) > x) {\n\t\t\t++cnt;\n\t\t\tpre = a[i] + x;\n\t\t}\n\t}\n\treturn cnt <= 3;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tcin >> n;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> a[i];\n\t\tsort(a, a + n);\n\t\tlong long l = 0, r = 1000000000, mid;\n\t\tfor (; l < r;) {\n\t\t\tmid = l + r >> 1;\n\t\t\tif (check(mid))\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid + 1;\n\t\t}\n\t\tcout << l << '\\n';\n\t}\n}\n""]","['binary search', 'greedy', 'sortings']",1400
https://codeforces.com//contest/806/problem/A,A. Success Rate,You are an experienced Codeforces user Today you found out that during your activity on Codeforces you have made submissions out of which have been successful Thus your current success rate on Codeforces is equal to Your favorite rational number in the range is Now you wonder what is the smallest number of submissions you have to make if you want your success rate to be ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nll solve() {\n    ll x, y, p, q;\n    cin >> x >> y >> p >> q;\n    if (p == 1 && q == 1) {\n        if (x == y) return 0;\n        return -1;\n    }\n    if (p == 0) {\n        if (x == 0) return 0;\n        return -1;\n    }\n    ll k = 0;\n    k = max(k, (y+q-1)/q);\n    k = max(k, (x+p-1)/p);\n    k = max(k, (y-x+q-p-1)/(q-p));\n    return k*q-y;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        cout << solve() << endl;\n    }\n    return 0;\n}\n']","['binary search', 'math']",1700
https://codeforces.com//contest/1490/problem/G,G. Old Floppy Drive ,Polycarp was dismantling his attic and found an old floppy drive on it A round disc was inserted into the drive with n integers written on it Polycarp wrote the numbers from the disk into the a array It turned out that the drive works according to the following algorithm the drive takes one positive number x as input and puts a pointer to the first element of the a array after that the drive starts rotating the disk every second moving the pointer to the next element counting the sum of all the elements that have been under the pointer Since the disk is round in the a array the last element is again followed by the first one as soon as the sum is at least x the drive will shut down Polycarp wants to learn more about the operation of the drive but he has absolutely no free time So he asked you m questions To answer the i th of them you need to find how many seconds the drive will work if you give it x i as input Please note that in some cases the drive can work infinitely For example if n 3 m 3 a 1 3 4 and x 1 5 2 then the answers to the questions are as follows the answer to the first query is 0 because the drive initially points to the first item and the initial sum is 1 the answer to the second query is 6 the drive will spin the disk completely twice and the amount becomes 1 3 4 1 3 4 1 5 the answer to the third query is 2 the amount is 1 3 4 2 ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int SIZE = 1 << 20;\nconst int len = 1 << 19;\nlong long tree[SIZE];\nint n, m;\nint arr[200010];\n\nvoid update(int idx, long long value)\n{\n\tidx += len;\n\ttree[idx] = value;\n\tidx /= 2;\n\twhile (idx >= 1)\n\t{\n\t\ttree[idx] = max(tree[2 * idx], tree[2 * idx + 1]);\n\t\tidx /= 2;\n\t}\n}\n\nint get(int idx, int s, int e, long long value)\n{\n\tint mid;\n\n\tif (idx >= len) return s;\n\n\tmid = (s + e) / 2;\n\n\tif (tree[2 * idx] >= value) return get(2 * idx, s, mid, value);\n\telse return get(2 * idx + 1, mid + 1, e, value);\n}\n\nint main()\n{\n\tint t;\n\tint i;\n\tlong long x;\n\tlong long sum;\n\tlong long cycle;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n >> m;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\tsum = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tsum += arr[i];\n\n\t\t\tupdate(i, sum);\n\t\t}\n\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> x;\n\n\t\t\tif (tree[1] >= x)\n\t\t\t{\n\t\t\t\tcout << get(1, 0, len - 1, x) << ' ';\n\t\t\t}\n\t\t\telse if (sum <= 0)\n\t\t\t{\n\t\t\t\tcout << -1 << ' ';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcycle = (x - tree[1]) / sum + ((x - tree[1]) % sum != 0);\n\t\t\t\tx -= sum * cycle;\n\t\t\t\tcout << get(1, 0, len - 1, x) + n * cycle << ' ';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tupdate(i, 0);\n\t\t}\n\t}\n}""]","['binary search', 'data structures', 'math']",1900
https://codeforces.com//contest/352/problem/A,A. Jeff and Digits,Jeff s got cards each card contains either digit 0 or digit 5 Jeff can choose several cards and put them in a line so that he gets some number What is the largest possible number divisible by 90 Jeff can make from the cards he s got Jeff must make the number without leading zero At that we assume that number 0 doesn t contain any leading zeroes Jeff doesn t have to use all the cards ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#if __cplusplus > 201103L\n#include <initializer_list>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#define DEBUG\n#endif\n\n#define oo 0x3F3F3F3F\n#define fst first\n#define snd second\n#define PB push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, a, b) for (int _end_ = (b), i = (a); i <= _end_; ++i)\n#define ROF(i, a, b) for (int _end_ = (b), i = (a); i >= _end_; --i)\n\ntypedef unsigned int uint;\ntypedef long long int64;\ntypedef unsigned long long uint64;\ntypedef long double real;\n\nint64 fpm(int64 b, int64 e, int64 m) { int64 t = 1; for (; e; e >>= 1, b = b * b % m) e & 1 ? t = t * b % m : 0; return t; }\ntemplate<class T> inline bool chkmin(T &a, T b) {return a > b ? a = b, true : false;}\ntemplate<class T> inline bool chkmax(T &a, T b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline T sqr(T x) {return x * x;}\ntemplate <typename T> T gcd(T x, T y) {for (T t; x; ) t = x, x = y % x, y = t; return y; }\n\ntemplate<class edge> struct Graph {\n    vector<vector<edge> > adj;\n    Graph(int n) {adj.clear(); adj.resize(n + 5);}\n    Graph() {adj.clear(); }\n    void resize(int n) {adj.resize(n + 5); }\n    void add(int s, edge e){adj[s].push_back(e);}\n    void del(int s, edge e) {adj[s].erase(find(iter(adj[s]), e)); }\n    vector<edge>& operator [](int t) {return adj[t];}\n};\n\nint main(int argc, char **argv) {\n#ifndef ONLINE_JUDGE\n    freopen(""A.in"" , ""r"", stdin);\n    freopen(""A.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n\n    int n, a = 0, b = 0;\n    cin >> n;\n    FOR (i, 1, n) {\n        int x;\n        cin >> x;\n        if (x == 5) ++a;\n        else ++b;\n    }\n    if (b == 0) cout << -1 << endl;\n    else if (a < 9) cout << 0 << endl;\n    else {\n        FOR (j, 1, a - a % 9) cout << 5;\n        FOR (j, 1, b) cout << 0;\n        cout << endl;\n    }\n\n    return 0; \n}\n']","['brute force', 'implementation', 'math']",1000
https://codeforces.com//contest/1580/problem/A,A. Portal,CQXYM found a rectangle A of size n times m There are n rows and m columns of blocks Each block of the rectangle is an obsidian block or empty CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation A rectangle M size of a times b is called a portal if and only if it satisfies the following conditions a geq 5 b geq 4 For all 1 x a blocks M x 1 and M x b are obsidian blocks For all 1 x b blocks M 1 x and M a x are obsidian blocks For all 1 x a 1 y b block M x y is an empty block M 1 1 M 1 b M a 1 M a b Note that the there must be a rows and b columns not b rows and a columns CQXYM wants to know the minimum number of operations he needs to make at least one sub rectangle a portal ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nchar A[405][405];\nint psum[405][405];\nint frec(int l0, int r0, int l1, int r1)\n{\n\treturn psum[r0][r1] - (l0 == 0 ? 0 : psum[l0 - 1][r1]) - (l1 == 0 ? 0 : psum[r0][l1 - 1]) + (l0 == 0 || l1 == 0 ? 0 : psum[l0 - 1][l1 - 1]);\n}\n\nint c0[405], c1[405];\nint calc(int l, int r)\n{\n\trep(i, m) {\n\t\tc0[i] = (A[l][i] == \'0\') + (A[r][i] == \'0\') + frec(l + 1, r - 1, i, i);\n\t\tc1[i] = r - l - 1 - frec(l + 1, r - 1, i, i);\n\t}\n\t\n\tint ret = INF, tmp = INF;\n\trep(i, m - 3) {\n\t\ttmp = min(tmp + c0[i], c1[i]);\n\t\tret = min(ret, tmp + c0[i + 1] + c0[i + 2] + c1[i + 3]);\n\t}\n\treturn ret;\n}\n\nvoid solve()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, n) scanf(""%s"", A[i]);\n\trep(i, n) rep(j, m) psum[i][j] = A[i][j] == \'1\';\n\trep(i, n) rep(j, m) psum[i][j + 1] += psum[i][j];\n\trep(i, n) rep(j, m) psum[i + 1][j] += psum[i][j];\n\t\n\tint ans = INF;\n\trep(l, n) for(int r = l + 4; r < n; r ++) ans = min(ans, calc(l, r));\n\tprintf(""%d\\n"", ans); \n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']","['brute force', 'data structures', 'dp', 'greedy', 'implementation']",1700
https://codeforces.com//contest/1409/problem/A,A. Yet Another Two Integers Problem,You are given two integers a and b In one move you can choose some k from 1 to 10 and add it to a or subtract it from a In other words you choose an integer k in 1 10 and perform a a k or a a k You may use values of k in different moves Your task is to find the number of moves required to obtain b from a You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long lli;\ntypedef pair<int, int> ii;\ntypedef pair<lli, lli> ll;\n\nint main() {\n\tint tc, a, b;\n\tscanf(""%d"", &tc);\n\twhile (tc--) {\n\t\tscanf(""%d %d"", &a, &b);\n\t\tprintf(""%d\\n"", (abs(a - b) + 9) / 10);\n\t}\n\treturn 0;\n}']","['greedy', 'math']",800
https://codeforces.com//contest/1732/problem/C1,C1. Sheikh  Easy version ,You are given an array of integers a 1 a 2 ldots a n The cost of a subsegment of the array l r 1 leq l leq r leq n is the value f l r operatorname sum l r operatorname xor l r where operatorname sum l r a l a l 1 ldots a r and operatorname xor l r a l oplus a l 1 oplus ldots oplus a r oplus stands for bitwise XOR You will have q 1 query Each query is given by a pair of numbers L i R i where 1 leq L i leq R i leq n You need to find the subsegment l r L i leq l leq r leq R i with maximum value f l r If there are several answers then among them you need to find a subsegment with the minimum length that is the minimum value of r l 1 ,"[""#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n,q,a[100005];\nLL s[100005],s2[100005];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n),gi(q);\n\t\tfor(int i=1;i<=n;i++)gi(a[i]),s[i]=s[i-1]^a[i],s2[i]=s2[i-1]+a[i];\n\t\twhile(q--){\n\t\t\tint L,R;\n\t\t\tgi(L),gi(R);\n\t\t\tint ansl=-1,ansr=-1;\n\t\t\tLL mx=s2[R]-s2[L-1]-(s[R]^s[L-1]);\n\t\t\tfor(int i=L;i<=R;i++){\n\t\t\t\tint l=i,r=R,ans=-1;\n\t\t\t\twhile(l<=r){\n\t\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\t\tLL val=s2[mid]-s2[i-1]-(s[mid]^s[i-1]);\n\t\t\t\t\tif(val==mx)ans=mid,r=mid-1;\n\t\t\t\t\telse l=mid+1;\n\t\t\t\t}\n\t\t\t\tif(ans!=-1){\n\t\t\t\t\tif(ansl==-1)ansl=i,ansr=ans;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ans-i+1<ansr-ansl+1)\n\t\t\t\t\t\t\tansl=i,ansr=ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpi(ansl,' ');\n\t\t\tpi(ansr,'\\n');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/""]","['binary search', 'bitmasks', 'greedy', 'two pointers']",1800
https://codeforces.com//contest/1369/problem/A,A. FashionabLee,Lee thinks a regular n sided convex polygon is if and only if he can rotate it in such a way that at least one of its edges is parallel to the OX axis and at least one of its edges is parallel to the OY axis at the same time Recall that a regular n sided polygon is a convex polygon with n vertices such that all the edges and angles are equal Now he is shopping the market has t regular polygons For each of them print if it is beautiful and otherwise ,"['// You may love a girl deeply\n// but you can\'t express in it more than 7-8 inches...\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(ass) ass.begin(), ass.end()\nusing namespace std;\n\ntypedef long long ll;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007;\nconst ll N = 2e5 + 85;\nconst ll Inf = 1e18;\nconst ll Log = 69;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++){\n\t\tll n;\n\t\tcin >> n;\n\t\tcout << (n % 4 ? ""NO"" : ""YES"") << \'\\n\';\n\t}\n\treturn 0;\n}\n']","['geometry', 'math']",800
https://codeforces.com//contest/1428/problem/B,B. Belted Rooms,In the snake exhibition there are n rooms numbered 0 to n 1 arranged in a circle with a snake in each room The rooms are connected by n conveyor belts and the i th conveyor belt connects the rooms i and i 1 bmod n In the other words rooms 0 and 1 1 and 2 ldots n 2 and n 1 n 1 and 0 are connected with conveyor belts The i th conveyor belt is in one of three states If it is clockwise snakes can only go from room i to i 1 bmod n If it is anticlockwise snakes can only go from room i 1 bmod n to i If it is off snakes can travel in either direction Above is an example with 4 rooms where belts 0 and 3 are off 1 is clockwise and 2 is anticlockwise Each snake wants to leave its room and come back to it later A room is if the snake there can leave the room and later come back to it using the conveyor belts How many such rooms are there ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nint ile;\n\nint lew, pra;\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz);\n\tile=0;\n\tfor (int i=0; i<n; i++)\n\t\tif (wcz[i]==\'-\' || wcz[(i+1)%n]==\'-\')\n\t\t\tile++;\n\tlew=pra=0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (wcz[i]==\'<\')\n\t\t\tlew=1;\n\t\tif (wcz[i]==\'>\')\n\t\t\tpra=1;\n\t}\n\tif (!lew || !pra)\n\t\tile=n;\n\tprintf(""%d\\n"", ile);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['graphs', 'implementation']",1200
https://codeforces.com//contest/108/problem/A,A. Palindromic Times,This is a well known formula among Tattah s colleagues On a Wednesday afternoon Tattah was attending Professor HH s lecture At right before falling asleep he was staring at the digital watch around Saher s wrist He noticed that the digits on the clock were the same when read from both directions i e a palindrome In his sleep he started dreaming about such rare moments of the day when the time displayed on a digital clock is a palindrome As soon as he woke up he felt destined to write a program that finds the next such moment However he still hasn t mastered the skill of programming while sleeping so your task is to help him ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n#include <string>\n\nusing namespace std;\n\nint toInt(string s){\n    int h=(s[0]-\'0\')*10+(s[1]-\'0\');\n    int m=(s[3]-\'0\')*10+(s[4]-\'0\');\n    return h*60+m;\n}\n\nint ispal(int a){\n    int h=a/60, m=a%60;\n    return (m==(h%10)*10+(h/10));\n}\n\nstring tostring(int a){\n    string s=""..:.."";\n    int h=a/60, m=a%60;\n    s[0]=(h/10)+\'0\';\n    s[1]=(h%10)+\'0\';\n    s[3]=(m/10)+\'0\';\n    s[4]=(m%10)+\'0\';\n    return s;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    int a=toInt(s);\n    for(int i=1; i<24*60; i++){\n\tint cur=(a+i)%(24*60);\n\tif(ispal(cur)){\n\t    cout << tostring(cur) << endl;\n\t    break;\n\t}\n    }\n}\n']","['implementation', 'strings']",1000
https://codeforces.com//contest/1876/problem/C,C. Autosynthesis,Chaneka writes down an array a of n positive integer elements Initially all elements are not circled In one operation Chaneka can circle an element It is possible to circle the same element more than once After doing all operations Chaneka makes a sequence r consisting of all elements of a following the order of their indices Chaneka also makes another sequence p such that its length is equal to the number of operations performed and p i is the of the element that is circled in the i th operation Chaneka wants to do several operations such that sequence r is equal to sequence p Help her achieve this or report if it is impossible Note that if there are multiple solutions you can print any of them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\n\nint n;\nint tab[nax];\n\nvi graf[nax];\nint sto[nax];\n\nint blok[nax];\nint biore[nax];\nint out[nax];\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tgraf[tab[i]].push_back(i);\n\t\tsto[tab[i]]++;\n\t}\n\tqueue<int> kol;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!sto[i])\n\t\t\tkol.push(i);\n\twhile(!kol.empty())\n\t{\n\t\tint v=kol.front();\n\t\tkol.pop();\n\t\tout[v]=1;\n\t\tif (!blok[v])\n\t\t{\n\t\t\tblok[tab[v]]=1;\n\t\t\tbiore[v]=1;\n\t\t}\n\t\tsto[tab[v]]--;\n\t\tif (!sto[tab[v]])\n\t\t\tkol.push(tab[v]);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (out[i])\n\t\t\tcontinue;\n\t\tvi cyk;\n\t\tint v=i;\n\t\twhile(cyk.empty() || v!=i)\n\t\t{\n\t\t\tcyk.push_back(v);\n\t\t\tout[v]=1;\n\t\t\tv=tab[v];\n\t\t}\n\t\tdebug() << cyk;\n\t\tint r=cyk.size();\n\t\tfor (int i=0; i<r; i++)\n\t\t{\n\t\t\tif (blok[cyk[i]])\n\t\t\t{\n\t\t\t\tvi pom;\n\t\t\t\tfor (int j=0; j<r; j++)\n\t\t\t\t\tpom.push_back(cyk[(i+j)%r]);\n\t\t\t\tcyk=pom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (blok[cyk[0]])\n\t\t{\n\t\t\tint v=0;\n\t\t\twhile(v<r)\n\t\t\t{\n\t\t\t\tif (blok[cyk[v]])\n\t\t\t\t{\n\t\t\t\t\tv++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint u=v;\n\t\t\t\twhile(u<r && !blok[cyk[u]])\n\t\t\t\t\tu++;\n\t\t\t\tvi ter;\n\t\t\t\tfor (int i=v; i<u; i++)\n\t\t\t\t\tter.push_back(cyk[i]);\n\t\t\t\tfor (int j=0; j<(int)ter.size(); j+=2)\n\t\t\t\t\tbiore[ter[j]]=1;\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (r&1)\n\t\t\t\tnope();\n\t\t\tfor (int i=0; i<r; i+=2)\n\t\t\t\tbiore[cyk[i]]=1;\n\t\t}\n\t}\n\tvi res;\n\tfor (int i=1; i<=n; i++)\n\t\tif (biore[i])\n\t\t\tres.push_back(tab[i]);\n\tprintf(""%d\\n"", (int)res.size());\n\tfor (int i : res)\n\t\tprintf(""%d "", i);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'sortings']",2100
https://codeforces.com//contest/1277/problem/D,D. Let s Play the Words ,Polycarp has n binary words A word called binary if it contains only characters and For example these words are binary and Polycarp wants to offer his set of n binary words to play a game words In this game players name words and each next word starting from the second must start with the last character of the previous word The first word can be any For example these sequence of words can be named during the game Word reversal is the operation of reversing the order of the characters For example the word after the reversal becomes the word after the reversal becomes Probably Polycarp has such a set of words that there is no way to put them in the order correspondent to the game rules In this situation he wants to reverse some words from his set so that the final set of n words still contains words i e all words are unique there is a way to put all words of the final set of words in the order so that the final sequence of n words is consistent with the game rules Polycarp wants to reverse minimal number of words Please help him ,"['#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(t_, t){\n    int n;cin>>n;\n    vector<int> n01,n00,n10,n11;\n    vector<string> s01,s10;\n    reps(i,n){\n      string s;\n      cin>>s;\n      if(s[0] == \'0\'){\n        if(s[s.size()-1] == \'0\'){\n          n00.push_back(i);\n        }else{\n          n01.push_back(i);\n          s01.push_back(s);\n        }\n      }else{\n        if(s[s.size()-1] == \'0\'){\n          n10.push_back(i);\n          s10.push_back(s);\n        }else{\n          n11.push_back(i);\n        }\n      }\n    }\n    if(n01.size() == 0 && n10.size() == 0 && n00.size() > 0 && n11.size() > 0){\n      cout<<-1<<endl;\n      continue;\n    }\n    if(n01.size() > n10.size()){\n      vector<int> tmp = n01;\n      n01 = n10;\n      n10 = tmp;\n      vector<string> tmps = s01;\n      s01 = s10;\n      s10 = tmps;\n    }\n    set<string> used;\n    rep(i, n01.size()){\n      reverse(all(s01[i]));\n      used.insert(s01[i]);\n    }\n    cout<<(n10.size() - n01.size())/2<<endl;\n    int count = 0;\n    int i = 0;\n    while(count < (n10.size() - n01.size())/2){\n      if(used.count(s10[i]) > 0){\n        i++;\n        continue;\n      }\n      cout<<n10[i]<<"" "";\n      count++;\n      i++;\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}\n']","['data structures', 'hashing', 'implementation', 'math']",1900
https://codeforces.com//contest/1105/problem/A,A. Salem and Sticks ,Salem gave you n sticks with integer positive lengths a 1 a 2 ldots a n For every stick you can change its length to any other positive integer length that is either shrink or stretch it The cost of changing the stick s length from a to b is a b where x means the absolute value of x A stick length a i is called for some integer t if a i t le 1 Salem asks you to change the lengths of some sticks possibly all or none such that all sticks lengths are almost good for some positive integer t and the total cost of changing is minimum possible The value of t is not fixed in advance and you can choose it as any positive integer As an answer print the value of t and the minimum cost If there are multiple optimal choices for t print any of them ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch=\'*\'; (ch<\'0\'||ch>\'9\')&&ch!=\'-\'; ch=getchar());\n    if(ch==\'-\') fu=1, ch=getchar();\n    for(v=0; ch>=\'0\'&&ch<=\'9\'; ch=getchar()) v=v*10+ch-\'0\';\n    if(fu) v=-v;\n}\nconst int INF=1e9+10;\nint ans,t,n,ANS,a[500010];\nint main(){\n//\tfreopen(""t.in"",""r"",stdin);\n//\tfreopen(""t.out"",""w"",stdout);\n\tcin>>n;\n\tFOR(i,1,n) getint(a[i]);\n\tANS=INF;\n\tFOR(i,1,200){\n\t\tt=0;\n\t\tFOR(j,1,n)\n\t\t\tif (a[j]<i-1) t+=i-1-a[j];\n\t\t\telse if (a[j]>i+1) t+=a[j]-i-1;\n\t\tif (t<ANS){\n\t\t\tans=i;\n\t\t\tANS=t;\n\t\t}\n\t}\n\tcout<<ans<<\' \'<<ANS<<endl;\n\treturn 0;\n}\n']","['brute force', 'implementation']",1100
https://codeforces.com//contest/1538/problem/F,F. Interesting Function,You are given two integers l and r where l r We will add 1 to l until the result is equal to r Thus there will be exactly r l additions performed For each such addition let s look at the number of digits that will be changed after it For example if l 909 then adding one will result in 910 and 2 digits will be changed if you add one to l 9 the result will be 10 and 2 digits will also be changed if you add one to l 489999 the result will be 490000 and 5 digits will be changed Changed digits always form a suffix of the result written in the decimal system Output the total number of changed digits if you want to get r from l adding 1 each time ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nint n,m,i,j,k,t,t1,u,v,a,b;\nll res=0;\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>a>>b;\n        res=0;\n        u=1;\n        for (i=0;i<10;i++)\n        {\n            res+=b/u-a/u;\n            u*=10;\n        }\n        cout<<res<<endl;\n    }\n}\n']","['binary search', 'dp', 'math', 'number theory']",1500
https://codeforces.com//contest/1644/problem/E,E. Expand the Path,Consider a grid of size n times n The rows are numbered top to bottom from 1 to n the columns are numbered left to right from 1 to n The robot is positioned in a cell 1 1 It can perform two types of moves move one cell down move one cell right The robot is not allowed to move outside the grid You are given a sequence of moves s the initial path of the robot This path doesn t lead the robot outside the grid You are allowed to perform an arbitrary number of modifications to it possibly zero With one modification you can duplicate one move in the sequence That is replace a single occurrence of with or a single occurrence of with Count the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn t move outside the grid ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (""avx2"")\n#pragma GCC optimization (""O3"")\n#pragma GCC optimization (""unroll-loops"")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    ll n; cin>>n;\n    string s; cin>>s;\n    int cntr = 0; int cntd = 0;\n    for (auto c: s)\n    {\n        if (c==\'D\') cntd++;\n        else cntr++;\n    }\n\n\n    int x = 1; int y = 1;\n\n    map<int, int> xmap, ymap;\n\n    xmap[1] = 1;\n    ymap[1] = 1;\n\n    for (auto c: s)\n    {\n        if (c==\'D\') y++;\n        else x++;\n        xmap[x] = y;\n        ymap[y] = x;\n    }\n\n    ll leftr = n-x;\n    ll leftd = n-y;\n\n\n    ll ans = 1 + (int)s.size();\n    for (auto it: xmap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftd);\n    }\n\n    for (auto it: ymap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftr);\n    }\n\n    if (x>1 && y>1) ans+=1ll*min(n-x, leftr)*min(n-y, leftd);\n    cout<<ans<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n/*\n1\n3\nD\n */']","['brute force', 'combinatorics', 'data structures', 'implementation', 'math']",1900
https://codeforces.com//contest/1162/problem/A,A. Zoning Restrictions Again,You are planning to build housing on a street There are n spots available on the street on which you can build a house The spots are labeled from 1 to n from left to right In each spot you can build a house with an integer height between 0 and h In each spot if a house has height a you will gain a 2 dollars from it The city has m zoning restrictions The i th restriction says that the tallest house from spots l i to r i inclusive must be at most x i You would like to build houses to maximize your profit Determine the maximum profit possible ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, H, M;\n    scanf(""%d%d%d"", &N, &H, &M);\n    vector<int> house(N, H);\n    for (int i = 0; i < M; ++i) {\n        int L, R, B;\n        scanf(""%d%d%d"", &L, &R, &B);\n        for (int i = L - 1; i < R; ++i) {\n            house[i] = min(house[i], B);\n        }\n    }\n    int ans = 0;\n    for (auto& x : house) {\n        ans += x * x;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/71/problem/B,B. Progress Bar,A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed Let s take a look at the following form of such a bar A bar is represented as squares located in line To add clarity let s number them with positive integers from to from the left to the right Each square has saturation for the th square which is measured by an integer from to When the bar for some is displayed squares has the saturation squares has the saturation and the saturation of the square can have any value from to So some first squares of the progress bar always have the saturation Some last squares always have the saturation And there is no more than one square that has the saturation different from and The degree of the process s completion is measured in percents Let the process be ,"['#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint out[110];\n\nmain(){\n\tint n, k, t, i;\n\t\n\tscanf ( ""%d %d %d"", &n, &k, &t );\n\tt = t * n * k;\n\tmemset ( out, 0, sizeof ( out ) );\n\tfor ( i = 0; i <= n * k; i ++ )\n\t\tif ( i * 100 <= t && t < i * 100 + 100 )\n\t\t\tbreak;\n\t\telse\n\t\t\tout[ i / k ] ++;\n\tfor ( i = 0; i < n; i ++ )\n\t\tprintf( ""%d "", out[i] );\n\tprintf( ""\\n"" );\n\t\n\treturn 0;\n}\n']","['implementation', 'math']",1300
https://codeforces.com//contest/1601/problem/E,E. Phys Ed Online,Students of one unknown college don t have PE courses That s why q of them decided to visit a gym nearby by themselves The gym is open for n days and has a ticket system At the i th day the cost of one ticket is equal to a i You are free to buy more than one ticket per day You can activate a ticket purchased at day i either at day i or any day later Each activated ticket is valid only for k days In other words if you activate ticket at day t it will be valid only at days t t 1 dots t k 1 You know that the j th student wants to visit the gym at each day from l j to r j inclusive Each student will use the following strategy of visiting the gym at any day i l j le i le r j person comes to a desk selling tickets placed near the entrance and buy several tickets with cost a i apiece possibly zero tickets if the person has at least one activated and still valid ticket they just go in Otherwise they activate one of tickets purchased today or earlier and go in Note that each student will visit gym only starting l j so each student has to buy at least one ticket at day l j Help students to calculate the minimum amount of money they have to spend in order to go to the gym ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, q, k, a[300005], ak[300005], ql[300005], qr[300005];\nLL ans[300005];\nvector<int> qy[300005];\n\nstruct fwt\n{\n\tint B;\n\tLL dat[300005], sum;\n\tvoid clear()\n\t{\n\t\tB = n / k + 2; sum = 0;\n\t\tfor(int i = B; i >= 0; i --) dat[i] = 0;\n\t}\n\tvoid add(int id, LL val)\n\t{\n\t\tsum += val;\n\t\tfor(; id <= B; id += id & -id) dat[id] += val;\n\t}\n\tLL query(int id)\n\t{\n\t\tLL ret = 0;\n\t\tfor(; id > 0; id -= id & -id) ret += dat[id];\n\t\treturn ret;\n\t}\n}t0, t1;\nvoid add_t(int r, LL val)\n{\n\tif(r == 0) return;\n\tt0.add(r, val); t1.add(r, 1LL * r * val);\n}\nLL query_t(int r)\n{\n\tif(r == 0) return 0;\n\treturn 1LL * r * (t0.sum - t0.query(r)) + t1.query(r);\n}\nvoid add_t(int l, int r, LL val)\n{\n\tadd_t(l, -val); add_t(r + 1, val);\n}\nLL query_t(int l, int r)\n{\n\treturn query_t(r + 1) - query_t(l);\n}\n\nPII sta[300005];\nint siz;\ndeque<PII> que;\nint main()\n{\n\tscanf(""%d%d%d"", &n, &q, &k);\n\trep1(i, n) scanf(""%d"", &a[i]);\n\trep(i, q) scanf(""%d%d"", &ql[i], &qr[i]);\n\t\n\tfor(int i = n; i >= 1; i --) {\n\t\tif(!que.empty() && que.front().second == i + k) que.pop_front();\n\t\twhile(!que.empty() && que.back().first >= a[i]) que.pop_back();\n\t\tque.push_back(MP(a[i], i));\n\t\tak[i] = que.front().first;\n\t}\n\t\n\trep(i, q) {\n\t\tans[i] = a[ql[i]];\n\t\tqr[i] = (qr[i] - ql[i]) / k;\n\t\tqy[ql[i] + 1].push_back(i);\n\t}\n\t\n\tfor(int i = n; i > n - k; i --) {\n\t\tt0.clear(); t1.clear();\n\t\tsiz = 1; sta[0] = MP(-1, i / k + 1);\n\t\tfor(int j = i; j >= 1; j -= k) {\n\t\t\twhile(sta[siz - 1].first >= ak[j]) {\n\t\t\t\tadd_t(sta[siz - 1].second, sta[siz - 2].second - 1, ak[j] - sta[siz - 1].first);\n\t\t\t\tsiz --;\n\t\t\t}\n\t\t\tint cj = j / k;\n\t\t\tsta[siz ++] = MP(ak[j], cj);\n\t\t\tadd_t(cj, cj, ak[j]);\n\t\t\trep(iq, qy[j].size()) {\n\t\t\t\tint cq = qy[j][iq], cv = a[j - 1];\n\t\t\t\tint cpos = lower_bound(sta, sta + siz, MP(cv, -1)) - sta - 1;\n\t\t\t\tif(cj + qr[cq] <= sta[cpos].second) ans[cq] += 1LL * cv * qr[cq];\n\t\t\t\telse ans[cq] += 1LL * cv * (sta[cpos].second - cj) + query_t(sta[cpos].second, cj + qr[cq] - 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, q) printf(""%lld\\n"", ans[i]);\n\treturn 0;\n}']","['data structures', 'dp', 'greedy']",2900
https://codeforces.com//contest/1925/problem/D,D. Good Trip,There are n children in a class m pairs among them are friends The i th pair who are friends have a friendship value of f i The teacher has to go for k excursions and for each of the excursions she chooses a pair of children randomly equiprobably and independently If a pair of children who are friends is chosen their friendship value increases by 1 for all subsequent excursions the teacher can choose a pair of children more than once The friendship value of a pair who are not friends is considered 0 and it does not change for subsequent excursions Find the expected value of the sum of friendship values of all k pairs chosen for the excursions at the time of being chosen It can be shown that this answer can always be expressed as a fraction dfrac p q where p and q are coprime integers Calculate p cdot q 1 bmod 10 9 7 ,"[""#include <iostream>\n#include <vector>\n#include <string>\n\nconst int64_t MOD = 1000000007LL;\n\nusing namespace std;\n\nbool __hack = ios::sync_with_stdio(false);\nauto __hack1 = cin.tie(nullptr);\n\ntemplate<typename T>\nT next() {\n    T x;\n    cin >> x;\n    return x;\n}\n\nint64_t mod_pow(int64_t a, int64_t b) {\n    int64_t r = 1;\n    while (b) {\n        if (b & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return r;\n}\n\nint64_t mod_inv(int64_t a) {\n    return mod_pow(a, MOD - 2);\n}\n\nint main() {\n    vector<int64_t> fact(200001);\n    fact[0] = 1;\n    for (int i = 1; i < fact.size(); ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    vector<int64_t> inv_fact(200001);\n    inv_fact[fact.size() - 1] = mod_inv(fact[fact.size() - 1]);\n    for (int i = fact.size() - 2; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n    auto binomial = [&](int n, int k) {\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n    };\n    int tests = next<int>();\n    for (int test = 0; test < tests; ++test) {\n        int64_t n = next<int>();\n        int64_t m = next<int>();\n        int64_t k = next<int>();\n        int64_t ans = 0;\n        int64_t p = mod_inv(n * (n - 1) / 2 % MOD);\n        int64_t q = (1 + MOD - p) % MOD;\n        int64_t coeff = k * p % MOD;\n        int64_t add = 0;\n        for (int64_t i = 1; i <= k; ++i) {\n            int64_t s = i * (i - 1) / 2 % MOD;\n            add = (add + s * binomial(k, i) % MOD * mod_pow(p, i) % MOD * mod_pow(q, k - i) % MOD) % MOD;\n        }\n        for (int i = 0; i < m; ++i) {\n            int a = next<int>();\n            int b = next<int>();\n            int64_t f = next<int64_t>();\n            if (f) {\n                ans = (ans + coeff * f + add) % MOD;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n""]","['combinatorics', 'dp', 'math', 'probabilities']",1900
https://codeforces.com//contest/585/problem/A,A. Gennady the Dentist,Gennady is one of the best child dentists in Berland Today children got an appointment with him they lined up in front of his office All children love to cry loudly at the reception at the dentist We enumerate the children with integers from to in the order they go in the line Every child is associated with the value of his The children take turns one after another to come into the office each time the child that is the first in the line goes to the doctor While Gennady treats the teeth of the th child the child is crying with the volume of At that the of the first child in the line is reduced by the amount of the second one by value and so on The children in the queue after the th child almost do not hear the crying so their remains unchanged If at any point in time the of the th child is less than zero he begins to cry with the volume of and leaves the line running towards the exit without going to the doctor s office At this the of all the children after the th one in the line is reduced by the amount of All these events occur immediately one after the other in some order Some cries may lead to other cries causing a chain reaction Once in the hallway it is quiet the child who is first in the line goes into the doctor s office Help Gennady the Dentist to determine the numbers of kids whose teeth he will cure Print their numbers in the chronological order ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 4040;\nint n;\nint m;\nint v[N], d[N], p[N];\nint ans[N];\nbool used[N];\nint q[N];\nint topQ;\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n        scanf(""%d%d%d"", &v[i], &d[i], &p[i]);\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (used[i]) continue;\n        ans[m++] = i + 1;\n        int r = v[i];\n        for (int j = i + 1; j < n && r > 0; j++)\n        {\n            if (used[j]) continue;\n            p[j] -= r;\n            if (p[j] < 0)\n            {\n                used[j] = 1;\n                q[topQ++] = j;\n            }\n            r--;\n        }\n        while(k < topQ)\n        {\n            int v = q[k++];\n            for (int j = v + 1; j < n; j++)\n            {\n                if (used[j]) continue;\n                p[j] -= d[v];\n                if (p[j] < 0)\n                {\n                    used[j] = 1;\n                    q[topQ++] = j;\n                }\n            }\n        }\n    }\n    printf(""%d\\n"", m);\n    for (int i = 0; i < m; i++)\n        printf(""%d "", ans[i]);\n\n    return 0;\n}']","['brute force', 'implementation']",1800
https://codeforces.com//contest/78/problem/A,A. Haiku,Haiku is a genre of Japanese traditional poetry A haiku poem consists of 17 syllables split into three phrases containing 5 7 and 5 syllables correspondingly the first phrase should contain exactly 5 syllables the second phrase should contain exactly 7 syllables and the third phrase should contain exactly 5 syllables A haiku masterpiece contains a description of a moment in those three phrases Every word is important in a small poem which is why haiku are rich with symbols Each word has a special meaning a special role The main principle of haiku is to say much using a few words To simplify the matter in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there Only the following letters are regarded as vowel letters and Three phases from a certain poem are given Determine whether it is haiku or not ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n\nchar S[1000];\nint C[] = { 5, 7, 5};\n\nint main() {\n\n    bool ok = 1;\n    for (int i = 0; i < 3 && ok; i++) {\n        gets(S);\n        int c = 0;\n        for (int j = 0; S[j]; j++) {\n            if (S[j]==\'a\' || S[j]==\'e\' || S[j]==\'i\' || S[j]==\'o\' || S[j]==\'u\') c++;\n        }\n        if (c != C[i]) ok = false;\n    }\n    if (ok) puts(""YES"");\n    else puts(""NO"");\n\n    return 0;\n}\n']","['implementation', 'strings']",800
https://codeforces.com//contest/1569/problem/A,A. Balanced Substring,You are given a string s consisting of n letters each letter is either or The letters in the string are numbered from 1 to n s l r is a continuous substring of letters from index l to r of the string inclusive A string is called balanced if the number of letters in it is equal to the number of letters For example strings and are balanced and strings and are not Find any non empty balanced substring s l r of string s Print its l and r 1 le l le r le n If there is no such substring then print 1 1 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    string S; cin >> S;\n    F0R(i, N-1) {\n        if (S[i] != S[i+1]) {\n            cout << i+1 << "" "" << i+2 << nl; return;\n        }\n    }\n    cout << ""-1 -1"" << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']",['implementation'],800
https://codeforces.com//contest/341/problem/A,A. Tourist Problem,Iahub is a big fan of tourists He wants to become a tourist himself so he planned a trip There are destinations on a straight road that Iahub wants to visit Iahub starts the excursion from kilometer 0 The destinations are described by a non negative integers sequence The number represents that the th destination is at distance kilometers from the starting point No two destinations are located in the same place Iahub wants to visit each destination only once Note that crossing through a destination is not considered visiting unless Iahub explicitly wants to visit it at that point Also after Iahub visits his last destination he doesn t come back to kilometer 0 as he stops his trip at the last destination The distance between destination located at kilometer and next destination located at kilometer is kilometers We call a route an order of visiting the destinations Iahub can visit destinations in any order he wants as long as he visits all destinations and he doesn t visit a destination more than once Iahub starts writing out on a paper all possible routes and for each of them he notes the total distance he would walk He s interested in the average number of kilometers he would walk by choosing a route As he got bored of writing out all the routes he asks you to help him ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n;\n  while (scanf(""%d"", &n) >= 1) {\n    vi as(n);\n    for (int i = 0; i < n; i++)\n      scanf(""%d"", &as[i]);\n    sort(as.begin(), as.end());\n\n    ll suml = 0, sumr = 0;\n    for (int i = 0; i < n; i++) sumr += as[i];\n\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n      sumr -= as[i];\n\n      ll sumLen = 0;\n      sumLen += sumr - ll(n - i - 1) * as[i];\n      sumLen += ll(i) * as[i] - suml;\n//      eprintf(""%I64d (%I64d %I64d)\\n"", sumLen, suml, sumr);\n      ans += sumLen;\n\n      suml += as[i];\n    }\n//    eprintf(""%I64d %I64d\\n"", ans, ansb);\n    for (int i = 0; i < n; i++)\n      ans += as[i];\n    ll ansb = n;\n    ll x = gcd(ans, ansb);\n    ans /= x;\n    ansb /= x;\n    printf(""%I64d %I64d\\n"", ans, ansb);\n  }\n  return 0;\n}\n']",['math'],1600
https://codeforces.com//contest/1592/problem/D,D. Hemose in ICPC  ,Zeyad knows that Hemose loves tree problems so he gave him a tree problem with a very special device Hemose has a weighted tree with n nodes and n 1 edges Unfortunately Hemose doesn t remember the weights of edges Let s define Dist u v for u neq v as the greatest common divisor of the weights of all edges on the path from node u to node v Hemose has a special device Hemose can give the device a set of nodes and the device will return the largest Dist between any two nodes from the set More formally if Hemose gives the device a set S of nodes the device will return the largest value of Dist u v over all pairs u v with u v in S and u neq v Hemose can use this Device and wants to find any two distinct nodes a b such that Dist a b is maximum possible Can you help him ,"['#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,l,sz[1005],vv[1005];\nint cnt,cur,c;\nint hd[1005],nxt[2005],to[2005],tot=1,vis[2005];\nvector<int> qry,edg;\nvoid add(int x,int y)\n{\n\ttot++;nxt[tot]=hd[x];to[tot]=y;hd[x]=tot;\n}\nvoid dfs(int x,int fa)\n{\n\tvv[x]=sz[x]=1;\n\tif(fa&&(cur+1)*2<=cnt)\n\t{\n\t\tc=1;\n\t\tcur++;edg.push_back(fa/2);\n\t\tqry.push_back(x);\n\t}\n\tint i;\n\tfor(i=hd[x];i;i=nxt[i])if(i/2!=fa/2&&!vis[i/2])\n\t{\n\t\tdfs(to[i],i);\n\t}\n\tif(c&&!fa) qry.push_back(x);\n}\nvoid solve()\n{\n\tcin>>n;\n\trep(i,n-1)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tcout<<""? ""<<n;rep(i,n)cout<<\' \'<<i;cout<<endl<<flush;\n\tint mx;cin>>mx;\n\twhile(1)\n\t{\n\t\tcnt=cur=0;\n\t\trep(i,n-1) cnt+=!vis[i];\n\t\tif(cnt==1) break;\n\t\tmemset(vv,0,sizeof(vv));\n\t\tqry.clear();edg.clear();\n\t\trep(i,n) if(!vv[i]) c=0,dfs(i,0);\n\t\tcout<<""? ""<<qry.size();\n\t\tfor(int i=0;i<qry.size();i++)\n\t\t{\n\t\t\tcout<<\' \'<<qry[i];\n\t\t}\n\t\tcout<<endl<<flush;\n\t\tint tmp;cin>>tmp;\n\t\tif(tmp==mx)\n\t\t{\n\t\t\trep(i,n-1) vis[i]=1;\n\t\t\tfor(int i=0;i<edg.size();i++) vis[edg[i]]=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<edg.size();i++) vis[edg[i]]=1;\n\t\t}\n\t}\n\trep(i,n-1) if(!vis[i])\n\t{\n\t\tcout<<""! ""<<to[i*2]<<\' \'<<to[i*2+1]<<endl<<flush;\n\t}\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}']","['binary search', 'dfs and similar', 'implementation', 'interactive', 'math', 'number theory', 'trees']",2300
https://codeforces.com//contest/1538/problem/G,G. Gift Set,Polycarp has x of red and y of blue candies Using them he wants to make gift sets Each gift set contains either a red candies and b blue candies or a blue candies and b red candies Any candy can belong to at most one gift set Help Polycarp to find the largest number of gift sets he can create For example if x 10 y 12 a 5 and b 2 then Polycarp can make three gift sets In the first set there will be 5 red candies and 2 blue candies In the second set there will be 5 blue candies and 2 red candies In the third set will be 5 blue candies and 2 red candies Note that in this example there is one red candy that Polycarp does not use in any gift set ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nll n,m,i,j,k,t,t1,u,v,a,b,x,y;\nint check(ll c)\n{\n    ll xx=x-a*c;\n    ll yy=y-a*c;\n    if (a==b)\n    {\n        return ((xx>=0)and(yy>=0));\n    }\n    else\n    {\n        if ((xx<0)or(yy<0)) return 0;\n        xx/=(b-a);\n        yy/=(b-a);\n        return (xx+yy>=c);\n    }\n}\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>x>>y>>a>>b;\n        if (a>b) swap(a,b);\n        ll l=0,r=1e9;\n        ll mid;\n        while(l<r)\n        {\n            mid=(l+r)/2;\n            if (check(mid+1)) l=mid+1;\n            else r=mid;\n        }\n        cout<<l<<endl;\n    }\n}\n']","['binary search', 'greedy', 'math', 'ternary search']",2100
https://codeforces.com//contest/1435/problem/A,A. Finding Sasuke,Naruto has sneaked into the Orochimaru s lair and is now looking for Sasuke There are T rooms there Every room has a door into it each door can be described by the number n of seals on it and their integer energies a 1 a 2 a n All energies a i are and do not exceed 100 by absolute value Also In order to open a door Naruto must find such n seals with integer energies b 1 b 2 b n that the following equality holds a 1 cdot b 1 a 2 cdot b 2 a n cdot b n 0 All b i must as well as a i are and also by absolute value Please find required seals for every room there ,"[""#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nconst int N = 100 + 20;\n\nint T;\n\nint n, a[N];\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> T;\n\n    while (T--) {\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        for (int i = 0; i < n; i+= 2) {\n            cout << a[i + 1] << ' ' << -a[i] << ' ';\n        }\n        cout << '\\n';\n    }\n}\n""]",['math'],800
https://codeforces.com//contest/355/problem/B,B. Vasya and Public Transport,Vasya often uses public transport The transport in the city is of two types trolleys and buses The city has buses and trolleys the buses are numbered by integers from to the trolleys are numbered by integers from to Public transport is not free There are 4 types of tickets A ticket for one ride on some bus or trolley It costs burles A ticket for an unlimited number of rides on some bus or on some trolley It costs burles A ticket for an unlimited number of rides on all buses or all trolleys It costs burles A ticket for an unlimited number of rides on all buses and trolleys It costs burles Vasya knows for sure the number of rides he is going to make and the transport he is going to use He asked you for help to find the minimum sum of burles he will have to spend on the tickets ,"['#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\nlong long a[1111],b[1111],cost[11],n,m;\n\nint main()\n{\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tcin >> cost[i];\n\t}\n\tcin >> n >> m;\n\tfor(int i=0; i<n; i++) cin >> a[i]; \n\tfor(int i=0; i<m; i++) cin >> b[i];\n\tlong long ans=min(cost[3],2*cost[2]);\n\tlong long mi=0;\n\tfor(int i=0; i<n; i++) \n\t{\n\t\tlong long cur =min(a[i]*cost[0],cost[1]);\n\t\tmi+=cur;\n\t} \n\tmi=min(mi,cost[2]);\n\tlong long mmi=0;\n\tfor(int i=0; i<m; i++) \n\t{\n\t\tlong long cur=min(b[i]*cost[0],cost[1]);\n\t\tmmi+=cur;\n\t} \t\n\tmmi=min(mmi,cost[2]);\n\tmi+=mmi;\n\tans=min(mi,ans);\n\tcout << ans << endl;\t\n\tcin >> n;\n\treturn 0;\n}\n']","['greedy', 'implementation']",1100
https://codeforces.com//contest/255/problem/E,E. Furlo and Rublo and Game,Furlo and Rublo play a game The table has piles of coins lying on it the th pile has coins Furlo and Rublo move in turns Furlo moves first In one move you are allowed to choose some pile let s denote the current number of coins in it as choose some integer and decrease the number of coins in this pile to In other words after the described move the pile will have coins left The player who can t make a move loses Your task is to find out who wins in the given game if both Furlo and Rublo play optimally well ,"['#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint sg[1010101];\nvector<int>sg_pos[1010];\n\nbool found(int v,int l,int r){\n    vector<int>::iterator it;\n    it=lower_bound(sg_pos[v].begin(),sg_pos[v].end(),l);\n    if(it==sg_pos[v].end())\n        return false;\n    if((*it)<=r)\n        return true;\n    return false;\n}\n\nint main(){\n    for(int i=0;i<1010;i++)\n        sg_pos[i].clear();\n    for(int i=1;i<1010101;i++){\n        sg[i]=0;\n        int l=ceil(sqrt(sqrt(i))),r=sqrt(i);\n        if(r>=i)\n            r=i-1;\n        while(found(sg[i],l,r))\n            sg[i]++;\n        sg_pos[sg[i]].push_back(i);\n    }\n\n    int ans=0;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++){\n        long long v;\n        scanf(""%I64d"",&v);\n        int t=0;\n        int l=ceil(sqrt(sqrt(v))),r=sqrt(v);\n        if(r>=v)\n            r=v-1;\n        while(found(t,l,r))\n            t++;\n        ans^=t;\n    }\n    if(ans!=0)\n        printf(""Furlo\\n"");\n    else\n        printf(""Rublo\\n"");\n\n    return 0;\n}']","['games', 'implementation', 'math']",2200
https://codeforces.com//contest/1208/problem/B,B. Uniqueness,You are given an array a 1 a 2 ldots a n You can remove subsegment from it The remaining elements should be pairwise distinct In other words time you can choose two integers l and r 1 leq l leq r leq n and delete integers a l a l 1 ldots a r from the array Remaining elements should be pairwise distinct Find the minimum size of the subsegment you need to remove to make all remaining elements distinct ,"[""/**\n *    author:  tourist\n *    created: 25.08.2019 17:36:33       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> b = a;\n  sort(b.begin(), b.end());\n  b.resize(unique(b.begin(), b.end()) - b.begin());\n  if ((int) b.size() == n) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    a[i] = (int) (lower_bound(b.begin(), b.end(), a[i]) - b.begin());\n  }\n  int ans = 0;\n  vector<int> mark(n, 0);\n  for (int i = 0; i < n; i++) {\n    int take = 0;\n    for (int j = 0; j < n; j++) {\n      if (mark[a[n - 1 - j]] > 0) {\n        break;\n      }\n      mark[a[n - 1 - j]] = 1;\n      ++take;\n    }\n    ans = max(ans, i + take);\n    for (int j = 0; j < take; j++) {\n      mark[a[n - 1 - j]] = 0;\n    }\n    if (mark[a[i]]) {\n      break;\n    }\n    mark[a[i]] = 1;\n  }\n  cout << n - ans << '\\n';\n  return 0;\n}\n""]","['binary search', 'brute force', 'implementation', 'two pointers']",1500
https://codeforces.com//contest/366/problem/A,A. Dima and Guards,Nothing has changed since the last round Dima and Inna still love each other and want to be together They ve made a deal with Seryozha and now they need to make a deal with the dorm guards There are four guardposts in Dima s dorm Each post contains two guards in Russia they are usually elderly women You can bribe a guard by a chocolate bar or a box of juice For each guard you know the minimum price of the chocolate bar she can accept as a gift and the minimum price of the box of juice she can accept as a gift If a chocolate bar for some guard costs less than the minimum chocolate bar price for this guard is or if a box of juice for some guard costs less than the minimum box of juice price for this guard is then the guard doesn t accept such a gift In order to pass through a guardpost one needs to bribe both guards The shop has an unlimited amount of juice and chocolate of any price starting with Dima wants to choose some guardpost buy one gift for each guard from the guardpost and spend rubles on it Help him choose a post through which he can safely sneak Inna or otherwise say that this is impossible Mind you Inna would be very sorry to hear that ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main ()\n{\n\tint n, a, b, c, d;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tscanf(""%d%d%d%d"", &a, &b, &c, &d);\n\t\ta = min(a, b);\n\t\tc = min(c, d);\n\t\tif (a + c <= n)\n\t\t{\n\t\t\tprintf(""%d %d %d\\n"", i + 1, a, n - a);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""-1\\n"");\n\treturn 0;\n}\n\n']",['implementation'],1100
https://codeforces.com//contest/1324/problem/D,D. Pair of Topics,The next lecture in a high school requires two topics to be discussed The i th topic is interesting by a i units for the teacher and by b i units for the students The pair of topics i and j i j is called if a i a j b i b j i e it is more interesting for the teacher Your task is to find the number of pairs of topics ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int k;\n    cin >> k;\n    vector<ll> a, b, c, d;\n    a.resize(k);\n    b.resize(k);\n    for (int i = 0; i < k; i++)\n    \tcin >> a[i];\n    for (int i = 0; i < k; i++)\n    \tcin >> b[i];\n    for (int i = 0; i < k; i++)\n    \ta[i] -= b[i];\n\n    for (int i = 0; i < k; i++)\n    \tif (a[i] > 0)\n    \t\tc.push_back(a[i]);\n    \telse\n    \t\td.push_back(a[i]);\n\n\tsort(c.begin(), c.end());\n\tsort(d.rbegin(), d.rend());\n\tint j = 0;\n\tll ans = 0;\n\tfor (int i = 0; i < c.size(); i++) {\n\t\twhile (j < d.size() && c[i] + d[j] > 0)\n\t\t\tj++;\n\t\tans += j;\n\t}\n\tans += ((long long)c.size() * (c.size() - 1)) / 2;\t\n\n\tcout << ans << endl;\n\n    return 0;\n}']","['binary search', 'data structures', 'sortings', 'two pointers']",1400
https://codeforces.com//contest/1740/problem/H,H. MEX Tree Manipulation,Given a rooted tree define the value of vertex u in the tree recursively as the MEX dagger of the Note that it is only the children not all of its descendants In particular the value of a leaf is 0 Pak Chanek has a rooted tree that initially only contains a single vertex with index 1 which is the root Pak Chanek is going to do q queries In the i th query Pak Chanek is given an integer x i Pak Chanek needs to add a new vertex with index i 1 as the child of vertex x i After adding the new vertex Pak Chanek needs to recalculate the values of all vertices and report the sum of the values of all vertices in the current tree dagger The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For example the MEX of 0 1 1 2 6 7 is 3 and the MEX of 6 9 is 0 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Info {\n    int in;\n    int out[2];\n    int sum[2];\n    Info() : in(-1), out{-1, -1}, sum{0, 0} {}\n    Info(int x, int eq, int neq, int l) : in(x), out{neq, eq}, sum{neq + l, eq + l} {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.in = a.in;\n    if (a.out[1] == b.in) {\n        c.out[1] = b.out[1];\n        c.sum[1] = a.sum[1] + b.sum[1];\n    } else {\n        c.out[1] = b.out[0];\n        c.sum[1] = a.sum[1] + b.sum[0];\n    }\n    if (a.out[0] == b.in) {\n        c.out[0] = b.out[1];\n        c.sum[0] = a.sum[0] + b.sum[1];\n    } else {\n        c.out[0] = b.out[0];\n        c.sum[0] = a.sum[0] + b.sum[0];\n    }\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    n++;\n    std::vector<int> p(n * 2, -1), parent(n, -1);\n    for (int i = 1; i < n; i++) {\n        std::cin >> parent[i];\n        parent[i]--;\n    }\n    \n    std::vector<int> ch1(2 * n), ch2(2 * n);\n    \n    std::vector<std::array<int, 20>> cnt(n);\n    std::vector<int> ans(2 * n, -1), sum(2 * n), lsum(2 * n);\n    std::vector<Info> info(2 * n);\n    std::function<int(int)> update = [&](int x) {\n        int in = 0;\n        while (cnt[x][in]) {\n            in++;\n        }\n        int out = in + 1;\n        while (cnt[x][out]) {\n            out++;\n        }\n        info[x] = Info(in, out, in, lsum[x]);\n        int t = x;\n        while (p[t] >= n) {\n            t = p[t];\n            info[t] = info[ch1[t]] + info[ch2[t]];\n        }\n        if (p[t] >= 0 && ans[t] != -1) {\n            lsum[p[t]] -= sum[t];\n            cnt[p[t]][ans[t]]--;\n        }\n        ans[t] = info[t].out[0];\n        sum[t] = info[t].sum[0];\n        if (p[t] >= 0) {\n            lsum[p[t]] += sum[t];\n            cnt[p[t]][ans[t]]++;\n            return update(p[t]);\n        }\n        return sum[t];\n    };\n    \n    int cur = n;\n    \n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        adj[parent[i]].push_back(i);\n    }\n    \n    std::vector<int> siz(n);\n    std::function<void(int)> dfs1 = [&](int x) {\n        siz[x] = 1;\n        for (auto &y : adj[x]) {\n            dfs1(y);\n            siz[x] += siz[y];\n            if (siz[y] > siz[adj[x][0]]) {\n                std::swap(y, adj[x][0]);\n            }\n        }\n    };\n    dfs1(0);\n    \n    std::function<int(int, int)> work = [&](int l, int r) {\n        if (r == (adj[l].empty() ? -1 : adj[l][0])) {\n            for (auto x : adj[l]) {\n                if (x != adj[l][0]) {\n                    p[work(x, -1)] = l;\n                }\n            }\n            return l;\n        }\n        int x = l;\n        while (r != (adj[x].empty() ? -1 : adj[x][0]) && siz[x] * 2 >= siz[l] + (r >= 0 ? siz[r] : 0)) {\n            x = adj[x][0];\n        }\n        int a = work(l, x);\n        int b = work(x, r);\n        int c = cur++;\n        ch1[c] = b;\n        ch2[c] = a;\n        p[a] = p[b] = c;\n        return c;\n    };\n    \n    work(0, -1);\n    \n    update(0);\n    for (int i = 1; i < n; i++) {\n        std::cout << update(i) << ""\\n"";\n    }\n    \n    return 0;\n}\n']","['data structures', 'trees']",3300
https://codeforces.com//contest/1753/problem/E,E. N Machines,You have been invited as a production process optimization specialist to some very large company The company has n machines at its factory standing one behind another in the production chain Each machine can be described in one of the following two ways a i or a i If a workpiece with the value x is supplied to the machine of kind a i then the output workpiece has value x a i If a workpiece with the value x is supplied to the machine of kind a i then the output workpiece has value x cdot a i The whole production process is as follows The workpiece with the value 1 is supplied to the first machine then the workpiece obtained after the operation of the first machine is supplied to the second machine then the workpiece obtained after the operation of the second machine is supplied to the third machine and so on The company is not doing very well so now the value of the resulting product does not exceed 2 cdot 10 9 The directors of the company are not satisfied with the efficiency of the production process and have given you a budget of b coins to optimize it To optimize production you can change the order of machines in the chain Namely by spending p coins you can take any machine of kind a i and move it to any place in the chain without changing the order of other machines Also by spending m coins you can take any machine of kind a i and move it to any place in the chain What is the maximum value of the resulting product that can be achieved if the total cost of movements that are made should not exceed b coins ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 4E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b, p, m;\n    std::cin >> n >> b >> p >> m;\n    \n    std::vector<int> x;\n    int total = 0;\n    \n    std::vector<std::vector<int>> a;\n    std::vector<int> mul;\n    for (int i = 0; i < n; i++) {\n        char t;\n        int y;\n        std::cin >> t >> y;\n        \n        if (t == \'+\') {\n            x.push_back(y);\n            total++;\n        } else if (y > 1) {\n            a.push_back(std::move(x));\n            mul.push_back(y);\n        }\n    }\n    \n    a.push_back(std::move(x));\n    \n    int cntm = mul.size();\n    \n    for (int i = 0; i <= cntm; i++) {\n        std::sort(a[i].begin(), a[i].end());\n    }\n    \n    std::vector<std::vector<i64>> suf(cntm + 1);\n    for (int i = 0; i <= cntm; i++) {\n        suf[i].resize(a[i].size() + 1);\n        for (int j = int(a[i].size()) - 1; j >= 0; j--) {\n            suf[i][j] = suf[i][j + 1] + a[i][j];\n        }\n    }\n    \n    i64 ans = 0;\n    \n    std::map<int, std::vector<int>> mpos;\n    for (int i = 0; i < cntm; i++) {\n        mpos[mul[i]].push_back(i);\n    }\n    \n    std::vector<bool> move(cntm);\n    auto dfs = [&](auto self, auto it) {\n        if (it == mpos.end()) {\n            std::vector<i64> val(cntm + 1, 1);\n            i64 cost = 0;\n            for (int i = 0; i < cntm; i++) {\n                if (move[i]) {\n                    val[cntm] *= mul[i];\n                    cost += m;\n                } else {\n                    val[i] *= mul[i];\n                }\n            }\n            for (int i = cntm - 1; i >= 0; i--) {\n                val[i] *= val[i + 1];\n            }\n            if (cost > b) {\n                return;\n            }\n            const int rest = std::min((b - cost) / p, 1LL * total);\n            i64 cur = val[0];\n            for (int i = 0; i <= cntm; i++) {\n                cur += val[i] * suf[i][0];\n            }\n            \n            auto get = [&](auto x) {\n                int cnt = 0;\n                i64 sum = 0;\n                for (int i = 0; i <= cntm; i++) {\n                    if (val[i] == val[0]) {\n                        continue;\n                    }\n                    i64 y = x / (val[0] - val[i]);\n                    auto it = std::upper_bound(a[i].begin(), a[i].end(), y);\n                    int k = it - a[i].begin();\n                    cnt += a[i].size() - k;\n                    sum += suf[i][k] * (val[0] - val[i]);\n                }\n                return std::pair(cnt, sum);\n            };\n            \n            i64 lo = 0, hi = inf;\n            while (lo < hi) {\n                i64 x = (lo + hi) / 2;\n                if (get(x).first > rest) {\n                    lo = x + 1;\n                } else {\n                    hi = x;\n                }\n            }\n            auto [c, s] = get(lo);\n            cur += s + 1LL * (rest - c) * lo;\n            ans = std::max(ans, cur);\n            return;\n        }\n        self(self, std::next(it));\n        for (int i = 0; i < int(it->second.size()); i++) {\n            move[it->second[i]] = true;\n            self(self, std::next(it));\n        }\n        for (auto i : it->second) {\n            move[i] = false;\n        }\n    };\n    dfs(dfs, mpos.begin());\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}\n']","['binary search', 'brute force', 'greedy']",3300
https://codeforces.com//contest/1607/problem/D,D. Blue-Red Permutation,You are given an array of integers a of length n The elements of the array can be either different or the same Each element of the array is colored either blue or red There are no unpainted elements in the array One of the two operations described below can be applied to an array in a single step either you can select any blue element and decrease its value by 1 or you can select any red element and increase its value by 1 Situations in which there are no elements of some color at all are also possible For example if the whole array is colored blue or red one of the operations becomes unavailable Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n In other words check whether there exists a sequence of steps possibly empty such that after applying it the array a contains in some order all numbers from 1 to n inclusive each exactly once ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector <int> v;\nint a[1000005];\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin >> a[i];\n\t\tstring s;\n\t\tv.clear();\n\t\tcin >> s;\n\t\ts=\' \'+s;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'B\') v.push_back(a[i]);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint flag=1;\n\t\tfor(int i=0;i<v.size();i++)\n\t\t\tif(v[i]<=i) flag=0;\n\t\tv.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'R\') v.push_back(a[i]);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint now=n;\n\t\tfor(int i=(int)v.size()-1;i>=0;i--)\n\t\t{\n\t\t\tif(v[i]>now) flag=0;\n\t\t\t--now;\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tcout << ""YES\\n"";\n\t\t}\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","['greedy', 'math', 'sortings']",1300
https://codeforces.com//contest/569/problem/A,A. Music,Little Lesha loves listening to music via his smartphone But the smartphone doesn t have much memory so Lesha listens to his favorite songs in a well known social network InTalk Unfortunately internet is not that fast in the city of Ekaterinozavodsk and the song takes a lot of time to download But Lesha is quite impatient The song s duration is seconds Lesha downloads the first seconds of the song and plays it When the playback reaches the point that has not yet been downloaded Lesha immediately plays the song from the start the loaded part of the song stays in his phone and the download is continued from the same place and it happens until the song is downloaded completely and Lesha listens to it to the end For seconds of real time the Internet allows you to download seconds of the track Tell Lesha for how many times he will start the song including the very first start ,"['/* In the name of Allah */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n    int s,t,q;\n    cin >> t>> s>> q;\n    int ans=1;\n    int time=0;\n    int ctr=0;\n    while(time!= t)\n    {\n        time++; ctr++;\n        if(ctr>1) s++;\n        if(ctr==q) ctr=0;\n        if(time>s) { ans++;time =1;}\n    }\n    cout<< ans;\n}\n']","['implementation', 'math']",1500
https://codeforces.com//contest/1895/problem/F,F. Fancy Arrays,Let s call an array a of n non negative integers if the following conditions hold at least one from the numbers x x 1 x k 1 appears in the array consecutive elements of the array differ by at most k i e a i a i 1 le k for each i in 2 n You are given n x and k Your task is to calculate the number of arrays of length n Since the answer can be large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=1e9+7;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\nll jyo(ll x,ll y,ll z){\n  ll H=y; //ここから\n       ll a=1,b=(x%z+z)%z,c=1;\n       while(H>0){\n         a*=2;\n         if(H%a!=0){\n           H-=a/2;\n           c*=b;\n           c%=z;\n         }\n        b*=b;\n         b%=z;\n      } //ここまで\n return c;\n}\n\n\n\ntemplate<class T>\nusing square_matrix=std::vector<std::vector<T>>;\ntemplate<class T,T (*add_op)(T,T),T(*add_e)(),T (*mul_op)(T,T),T(*mul_e)()>\nsquare_matrix<T> mul_matrix(square_matrix<T> l,square_matrix<T> r){\n    int n=l.size();\n    assert((int)l[0].size()==n&&(int)r.size()==n&&(int)r[0].size()==n);\n    square_matrix<T> val(n,std::vector<T>(n,add_e()));\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++){\n        val[i][k]=add_op(val[i][k],mul_op(l[i][j],r[j][k]));\n    }\n    return val;\n}\ntemplate<class T,T (*add_op)(T,T),T(*add_e)(),T (*mul_op)(T,T),T(*mul_e)()>\nsquare_matrix<T> pow_matrix(square_matrix<T> l,long long times){\n    int n=l.size();\n    square_matrix<T> val(n,std::vector<T>(n,add_e()));\n    square_matrix<T> tmp(n,std::vector<T>(n,add_e()));\n    for(int i=0;i<n;i++) val[i][i]=mul_e();\n    while(times){\n        if(times&1){\n            for(int i=0;i<n;i++) for(int j=0;j<n;j++){\n                tmp[i][j]=add_e();\n            }\n            for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++){\n                tmp[i][k]=add_op(tmp[i][k],mul_op(val[i][j],l[j][k]));\n            }\n            swap(tmp,val);\n        }\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++) tmp[i][j]=add_e();\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++){\n            tmp[i][k]=add_op(tmp[i][k],mul_op(l[i][j],l[j][k]));\n        }\n        swap(tmp,l);\n        times>>=1;\n    }\n    return val;\n}\n\nusing mat_F=ll;\nmat_F add_op(mat_F a,mat_F b){\n    return (a+b)%mod;\n}\nmat_F add_e(){\n    return 0;\n}\nmat_F mul_op(mat_F a,mat_F b){\n    return (a*b)%mod;\n}\nmat_F mul_e(){\n    return 1;\n}\n#define calc mat_F,add_op,add_e,mul_op,mul_e\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    ll N,K,X;\n    cin>>N>>X>>K;\n    ll ans=jyo(2*K+1,N-1,mod)*K%mod;\n    if(X==0){\n        cout<<ans<<""\\n"";\n        return;\n    }\n    ans=jyo(2*K+1,N-1,mod)*(X+K)%mod;\n    vector p(X,vector<ll>(X));\n    rep(i,0,X) rep(j,0,X){\n        if(abs(i-j)<=K) p[i][j]=1;\n    }\n    p=pow_matrix<calc>(p,N-1);\n    for(auto x:p) for(auto y:x) ans=(ans-y)%mod;\n    cout<<(ans%mod+mod)%mod<<""\\n"";\n}']","['combinatorics', 'dp', 'math', 'matrices']",2600
https://codeforces.com//contest/1324/problem/F,F. Maximum White Subtree,You are given a tree consisting of n vertices A tree is a connected undirected graph with n 1 edges Each vertex v of this tree has a color assigned to it a v 1 if the vertex v is white and 0 if the vertex v is black You have to solve the following problem for each vertex v what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that the vertex v The subtree of the tree is the connected subgraph of the given tree More formally if you choose the subtree that contains cnt w white vertices and cnt b black vertices you have to maximize cnt w cnt b ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<vector<int>> e;\nvector<int> subtree;\nvector<int> c;\nvector<int> q; \nvector<bool> used;\nvector<int> d;\n\nmap<pll, int> suptree;\n\nvoid DFS(int v, int dd) {\n\td[v] = dd;\n\tused[v] = true;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (!used[nb])\n\t\t\tDFS(nb, dd + 1);\n\t}\n\tq.push_back(v);\n}\n\nvoid count(int v) {\n\tif (c[v])\n\t\tsubtree[v]++;\n\telse\n\t\tsubtree[v]--;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] > d[v]) \n\t\t\tif (subtree[nb] > 0)\n\t\t\t\tsubtree[v] += subtree[nb];\n\t}\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] > d[v]) {\n\t\t\tint wo = subtree[v];\n\t\t\tif (subtree[nb] > 0)\n\t\t\t\two -= subtree[nb];\n\t\t\tsuptree[{v, nb}] = wo;\n\t\t}\n\t}\n}\n\nvoid count_2(int v) {\n\tint par = -1;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] < d[v])\n\t\t\tpar = nb;\n\t}\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] > d[v]) {\n\t\t\tint add = 0;\n\t\t\tadd = max(add, suptree[{v, nb}]);\n\t\t\tfor (int j = 0; j < e[nb].size(); j++) {\n\t\t\t\tint nbnb = e[nb][j];\n\t\t\t\tif (d[nbnb] > d[nb]) {\n\t\t\t\t\tsuptree[{nb, nbnb}] += add;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (par == -1)\n\t\treturn;\n\tif (suptree[{par, v}] > 0)\n\t\tsubtree[v] += suptree[{par, v}];\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    c.resize(n);\n    for (int i = 0; i < n; i++)\n    \tcin >> c[i];\n    e.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n    \tint a, b;\n    \tcin >> a >> b;\n    \te[a - 1].push_back(b - 1);\n    \te[b - 1].push_back(a - 1);\n    }\n    used.resize(n, false);\n   \td.resize(n);\n    DFS(0, 0);\n\n   \tsubtree.resize(n, 0);\n    for (auto v : q)\n    \tcount(v);\n/*\n    for (int i = 0; i < n; i++)\n    \tcout << subtree[i] << \' \';\n    cout << endl;\n    for (auto p : suptree) {\n    \tcout << p.F.F << \' \' << p.F.S << "": "" << p.S << endl;\n    }\n*/\n\n\n    reverse(q.begin(), q.end());\n    for (auto v : q)\n    \tcount_2(v);\n\n    for (int i = 0; i < n; i++)\n    \tcout << subtree[i] << \' \';\n    cout << endl;\n/*\n    for (auto p : suptree) {\n    \tcout << p.F.F << \' \' << p.F.S << "": "" << p.S << endl;\n    }\n*/\n\n\n    return 0;\n}']","['dfs and similar', 'dp', 'graphs', 'trees']",1800
https://codeforces.com//contest/1095/problem/B,B. Array Stabilization,You are given an array a consisting of n integer numbers Let of the array be the following value max limits i 1 n a i min limits i 1 n a i You have to remove element from this array to minimize of the resulting n 1 elements array Your task is to calculate the minimum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint main(){\n\tfast_io;\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n);\n\tint ans=1e6;\n\tif(n==2){\n\t\tpret(0);\n\t}\n\tans=min(ans,a[n-1]-a[1]);\n\tans=min(ans,a[n-2]-a[0]);\n\tshow(ans);\n\treturn 0;\n}']",['implementation'],900
https://codeforces.com//contest/336/problem/C,C. Vasily the Bear and Sequence,Vasily the bear has got a sequence of positive integers Vasily the Bear wants to write out several numbers on a piece of paper so that the beauty of the numbers he wrote out was maximum The of the written out numbers is such maximum non negative integer that number is divisible by number without a remainder If such number doesn t exist that is for any non negative integer number is divisible by without a remainder the beauty of the written out numbers equals 1 Tell the bear which numbers he should write out so that the beauty of the written out numbers is maximum If there are multiple ways to write out the numbers you need to choose the one where the bear writes out as many numbers as possible Here expression means applying the bitwise AND operation to numbers and In programming languages C and Java this operation is represented by in Pascal by and ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, a[100005], Max, i, j, Now, full;\nint list[100005], tot;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]), Max = max(Max, a[i]);\n\tfor (i = 1; i <= Max; (i <<= 1));\n\tfull = i - 1;\n\ti >>= 1;\n\tfor (; i >= 1; (i >>= 1))\n\t{\n\t\tNow = full;\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tif ((a[j] & i) > 0)\n\t\t\t\tNow &= a[j];\n\t\tif (Now % i == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (i == 0)\n\t{\n\t\tprintf(""%d\\n"", n);\n\t\tfor (i = 1; i <= n; i++)\n\t\t\tif (i == n)\n\t\t\t\tprintf(""%d\\n"", a[i]);\n\t\t\telse\n\t\t\t\tprintf(""%d "", a[i]);\n\t}\n\t\n\telse\n\t{\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tif ((a[j] & i) > 0)\n\t\t\t\tlist[++tot] = a[j];\n\t\tprintf(""%d\\n"", tot);\n\t\tfor (j = 1; j <= tot; j++)\n\t\t\tif (j == tot)\n\t\t\t\tprintf(""%d\\n"", list[j]);\n\t\t\telse\n\t\t\t\tprintf(""%d "", list[j]);\n\t}\n\t\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation', 'number theory']",1800
https://codeforces.com//contest/936/problem/B,B. Sleepy Game,Petya and Vasya arranged a game The game runs by the following rules Players have a directed graph consisting of vertices and edges One of the vertices contains a chip Initially the chip is located at vertex Players take turns moving the chip along some edge of the graph Petya goes first Player who can t move the chip loses If the game lasts for turns the draw is announced Vasya was performing big laboratory work in Spelling and parts of speech at night before the game so he fell asleep at the very beginning of the game Petya decided to take the advantage of this situation and make both Petya s and Vasya s moves Your task is to help Petya find out if he can win the game or at least draw a tie ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nint N, M, S;\nvector<int> Adj[MaxN];\n\nbool Reachable[MaxN][2];\nint PrevVert[MaxN][2];\n\nvoid dfs(int v, int x) {\n  Reachable[v][x] = true;\n  for (int s : Adj[v])\n    if (!Reachable[s][x ^ 1]) {\n      PrevVert[s][x ^ 1] = v;\n      dfs(s, x ^ 1);\n    }\n}\n\nint Vis[MaxN];\n\nbool dfsCycle(int v) {\n  Vis[v] = 1;\n  for (int s : Adj[v]) {\n    if (Vis[s] == 1) { return true; }\n    if (Vis[s] == 0 && dfsCycle(s))\n      return true;\n  }\n\n  Vis[v] = 2;\n  return false;\n}\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> M;\n  for (int i = 1; i <= N; ++i) {\n    int c; cin >> c;\n    for (int j = 0; j < c; ++j) {\n      int v;\n      cin >> v;\n      Adj[i].PB(v);\n    }\n  }\n\n  cin >> S;\n  dfs(S, 0);\n\n  for (int i = 1; i <= N; ++i) {\n    if (SZ(Adj[i]) == 0 && Reachable[i][1]) {\n      cout << ""Win\\n"";\n      vector<int> Res;\n      int v = i, x = 1;\n      Res.push_back(v);\n      while (v != S || x != 0) {\n        v = PrevVert[v][x];\n        x ^= 1;\n        Res.push_back(v);\n      }\n\n      reverse(ALL(Res));\n      for (int s : Res) { cout << s << "" ""; }\n      cout << ""\\n"";\n      return 0;\n    }\n  }\n\n  if (dfsCycle(S))\n    cout << ""Draw\\n"";\n  else\n    cout << ""Lose\\n"";\n}\n\n']","['dfs and similar', 'dp', 'games', 'graphs']",2100
https://codeforces.com//contest/1152/problem/B,B. Neko Performs Cat Furrier Transform,Cat Furrier Transform is a popular algorithm among cat programmers to create longcats As one of the greatest cat programmers ever exist Neko wants to utilize this algorithm to create the perfect longcat Assume that we have a cat with a number x A perfect longcat is a cat with a number equal 2 m 1 for some non negative integer m For example the numbers 0 1 3 7 15 and so on are suitable for the perfect longcats In the Cat Furrier Transform the following operations can be performed on x Operation A you select any non negative integer n and replace x with x oplus 2 n 1 with oplus being a bitwise XOR operator Operation B replace x with x 1 The first applied operation must be of type A the second of type B the third of type A again and so on Formally if we number operations from one in the order they are executed then odd numbered operations must be of type A and the even numbered operations must be of type B Neko wants to produce perfect longcats at industrial scale thus for each cat Neko only wants to perform at most 40 operations Can you help Neko writing a transformation plan Note that it is to minimize the number of operations You just need to use no more than 40 operations ,"['#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000003 \n#define N 100005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nbool ok(int x) {\n\n\twhile(x) {\n\n\t\tif(x%2==0) return 0;\n\n\t\tx>>=1;\n\n\t}\n\n\treturn 1;\n\n}\n\nint main() {\n\n\tint n;\n\tint cnt=0;\n\n\tscanf(""%d"",&n);\n\n\tvector<int> op;\n\n\tfor(int i=20;i>0;i--) {\n\n\t\tif(n&pw(i-1)) continue ;\n\n\t\top.pb(i);\n\n\t\tn^=(pw(i)-1);\n\n\t\t++cnt;\n\n\t\tif(ok(n)) break ;\n\n\t\tn++;\n\n\t\t++cnt;\n\n\t}\n\n\tprintf(""%d\\n"",cnt);\n\n\tfor(int i:op) printf(""%d "",i);\n\n}']","['bitmasks', 'constructive algorithms', 'dfs and similar', 'math']",1300
https://codeforces.com//contest/1868/problem/E,E. Min-Sum-Max,Tom is waiting for his results of Zhongkao examination To ease the tense atmosphere his friend Daniel decided to play a game with him This game is called The game is about the array a consisting of n integers Denote l r as the subsegment consisting of integers a l a l 1 ldots a r Tom will divide the array into contiguous subsegments l 1 r 1 l 2 r 2 ldots l m r m such that each integer is in exactly one subsegment More formally For all 1 le i le m 1 le l i le r i le n l 1 1 r m n For all 1 i le m l i r i 1 1 Denote s i sum k l i r i a k that is s i is the sum of integers in the i th subsegment For all 1 le i le j le m the following condition must hold min i le k le j s k le sum k i j s k le max i le k le j s k Tom believes that the more subsegments the array a is divided into the better results he will get So he asks Daniel to find the number of subsegments among all possible ways to divide the array a You have to help him find it ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã\x81§æ\x95°å\x88\x97ã\x82\x92ç®¡ç\x90\x86ã\x81\x99ã\x82\x8bã\x81¨ã\x81\x8dã\x81«ä½¿ã\x81\x86 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ã\x81\x97ã\x81¦ã\x81ªã\x81\x84ã\x82\x84\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã\x82½ã\x83¼ã\x83\x88ã\x81\x97ã\x81¦ i ç\x95ªç\x9b®ã\x81\x8c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾\x8bã\x81\x88ã\x81° sortidx ã\x81§å¾\x97ã\x81\x9f idx ã\x82\x92ä½¿ã\x81\x88ã\x81°å\x8d\x98ã\x81«ã\x82½ã\x83¼ã\x83\x88å\x88\x97ã\x81«ã\x81ªã\x81£ã\x81¦è¿\x94ã\x81£ã\x81¦ã\x81\x8fã\x82\x8b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tvc<ll> s=presum(a);\n\tint m;\n\t{\n\t\tvc<ll> vs=s;mkuni(vs);\n\t\trep(i,n+1)s[i]=lwb(vs,s[i]);\n\t\tm=si(vs);\n\t}\n\tvvc<int> dp[2];\n\trep(k,2){\n\t\tdp[k].resize(n+1,vi(n+1,-inf));\n\t\trep(i,n+1)dp[k][i][i]=0;\n\t}\n\tvi left[2],right[2];\n\trep(k,2){\n\t\tleft[k].resize(n+1,-inf);\n\t\tleft[k][0]=0;\n\t}\n\trep(k,2){\n\t\tright[k].resize(n+1,-inf);\n\t\tright[k][n]=0;\n\t}\n\tvvc<int> pos(m);\n\tvi look(n+1,-1);\n\trep(v,m)rep(i,n+1)if(s[i]==v){\n\t\tlook[i]=si(pos[v]);\n\t\tpos[v].pb(i);\n\t}\n\tfor(auto idx:pos){\n\t\trep(i,si(idx))rng(j,i+1,si(idx))rep(k,2)chmax(dp[k][idx[i]][idx[j]],j-i);\n\t}\n\tvc<pi> ls[2];\n\tvc<tuple<int,int,int>> buf;\n\tint ans=dp[0][0][n];\n\tper(vlw,m)rng(vup,vlw+1,m){\n\t\trep(k,2)ls[k].clear();\n\t\tbuf.clear();\n\t\t{\n\t\t\tint pre=-1;\n\t\t\trep(i,n+1){\n\t\t\t\tif(s[i]==vlw){\n\t\t\t\t\tif(pre!=-1&&s[pre]==vup){\n\t\t\t\t\t\tbuf.eb(1,pre,i);\n\t\t\t\t\t}\n\t\t\t\t\tpre=i;\n\t\t\t\t}else if(s[i]==vup){\n\t\t\t\t\tif(pre!=-1&&s[pre]==vlw){\n\t\t\t\t\t\tbuf.eb(0,pre,i);\n\t\t\t\t\t}\n\t\t\t\t\tpre=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto [k,l,r]:buf){\n\t\t\tfor(auto [x,y]:ls[k^1]){\n\t\t\t\tint v=s[x];\n\t\t\t\tassert(v==s[r]);\n\t\t\t\tif(chmax(dp[k^1][x][r],dp[k][y][l]+2)){\n\t\t\t\t\t//dmp2(x,y,l,r,dp[k^1][x][r]);\n\t\t\t\t\trep(i,look[x]+1)rng(j,look[r],si(pos[v])){\n\t\t\t\t\t\tint p=pos[v][i],q=pos[v][j];\n\t\t\t\t\t\tassert(s[p]==v&&s[q]==v);\n\t\t\t\t\t\tchmax(dp[k^1][p][q],dp[k^1][p][x]+dp[k^1][x][r]+dp[k^1][r][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tls[k].eb(l,r);\n\t\t}\n\t\tfor(auto [k,l,r]:buf){\n\t\t\trep(i,l+1)chmax(left[k^1][r],left[k][i]+dp[k][i][l]+1);\n\t\t}\n\t\tfor(auto [k,l,r]:revv(buf)){\n\t\t\trng(i,r,n+1)chmax(right[k][l],dp[k^1][r][i]+right[k^1][i]+1);\n\t\t}\n\t\tfor(auto [k,l,r]:buf){\n\t\t\tint L=-inf,R=-inf;\n\t\t\trep(i,l+1)chmax(L,left[k][i]+dp[k][i][l]);\n\t\t\trng(i,r,n+1)chmax(R,dp[k^1][r][i]+right[k^1][i]);\n\t\t\tchmax(ans,L+R+1);\n\t\t}\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['constructive algorithms', 'dp', 'greedy']",3500
https://codeforces.com//contest/1324/problem/A,A. Yet Another Tetris Problem,You are given some Tetris field consisting of n columns The initial height of the i th column of the field is a i blocks On top of these columns you can place figures of size 2 times 1 i e the height of this figure is 2 blocks and the width of this figure is 1 block Note that you rotate these figures Your task is to say if you can clear the whole field by placing such figures More formally the problem can be described like this The following process occurs while You place one figure 2 times 1 choose some i from 1 to n and replace a i with a i 2 then while all a i are greater than zero replace each a i with a i 1 And your task is to determine if it is possible to clear the whole field i e finish the described process choosing the places for new figures properly You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<ll> m;\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n    \tint k;\n    \tcin >> k;\n    \tvector<int> a;\n    \ta.resize(k);\n    \tfor (int j = 0; j < k; j++)\n    \t\tcin >> a[j];\n    \tbool good = true;\n    \tfor (int j = 1; j < k; j++)\n    \t\tif (abs(a[j] - a[0]) % 2)\n    \t\t\tgood = false;\n    \tif (good)\n    \t\tcout << ""YES"" << endl;\n    \telse\n    \t\tcout << ""NO"" << endl;\n    }\n\n\n\n\n    return 0;\n}']","['implementation', 'number theory']",900
https://codeforces.com//contest/1353/problem/C,C. Board Moves,You are given a board of size n times n where n is not divisible by 2 Initially each cell of the board contains one figure In one move you can select presented in some cell and move it to one of the cells i e from the cell i j you can move the figure to cells i 1 j 1 i 1 j i 1 j 1 i j 1 i j 1 i 1 j 1 i 1 j i 1 j 1 Of course you move figures to cells out of the board It is allowed that after a move there will be several figures in one cell Your task is to find the minimum number of moves needed to get into cell i e n 2 1 cells should contain 0 figures and one cell should contain n 2 figures You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a;\n           cin>>a;\n           int ans=0;\n           for (int i=1;i<=a/2;i++) {\n               int qq=2*i+1; \n               qq=qq*qq; \n               qq-=(2*i-1)*(2*i-1); ans+=i*qq; \n           } \n           cout<<ans<<""\\n""; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']",['math'],1000
https://codeforces.com//contest/351/problem/D,D. Jeff and Removing Periods,Cosider a sequence consisting of integers Jeff can perform the following operation on sequence take three integers such that remove elements from the sequence the remaining elements should be reindexed permute in some order the remaining elements of sequence A beauty of a sequence is the minimum number of operations that is needed to delete all elements from sequence Jeff s written down a sequence of integers Now he wants to ask questions Each question can be described with two integers The answer to the question is the beauty of sequence You are given the sequence and all questions Help Jeff answer all his questions ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define T (1<<17)\nint tree[T];\n\nvoid add(int pos, int val){\n    for(int i=pos;i<T;i=((i)|(i+1))) tree[i] += val;\n}\n\nint sum(int pos){\n    int ans = 0;\n    for(int i=pos;i>0;i=((i)&(i-1))) ans += tree[i-1];\n    return ans;\n}\n\nint tree2[T];\n\nvoid add2(int pos, int val){\n    for(int i=pos;i<T;i=((i)|(i+1))) tree2[i] += val;\n}\n\nint sum2(int pos){\n    int ans = 0;\n    for(int i=pos;i>0;i=((i)&(i-1))) ans += tree2[i-1];\n    return ans;\n}\n\nint N;\nint a[100010],index[100010];\nint next[100010];\nvector <pair <int, int> > query[100010]; // l -> r, id\nint ans[100010];\n\nint bound[100010];\n\nvoid pre(void){\n    int i;\n    \n    for(i=N-1;i>=0;i--){\n        if(next[i] == N){\n            bound[i] = N;\n        } else {\n            int x = i, y = next[i], z = next[y];\n            if(z == N || z - y == y - x){\n                bound[x] = bound[y];\n            } else {\n                bound[x] = z;\n            }\n        }\n    }\n}\n\nbool old[100010];\n\nvoid main2(void){\n    int i,j;\n    \n    for(i=N-1;i>=0;i--){\n        add(i, 1);\n        if(next[i] != N) add(next[i], -1);\n        \n        REP(j,query[i].size()){\n            int L = i, R = query[i][j].first, id = query[i][j].second;\n            ans[id] = sum(R) - sum(L);\n        }\n        \n        // add 1 to i+1 .. bound[i]\n        add2(i+1, 1);\n        add2(bound[i]+1, -1);\n        if(next[i] != N){\n            j = next[i];\n            add2(j+1, -1);\n            add2(bound[j]+1, 1);\n        }\n        \n        REP(j,query[i].size()){\n            int L = i, R = query[i][j].first, id = query[i][j].second;\n            if(sum2(R+1) == 0) ans[id]++;\n        }\n    }\n}\n\nint main(void){\n    int Q,i;\n    \n    cin >> N;\n    REP(i,N) scanf(""%d"", &a[i]);\n    \n    REP(i,100010) index[i] = N;\n    for(i=N-1;i>=0;i--){\n        next[i] = index[a[i]];\n        index[a[i]] = i;\n    }\n    \n//  REP(i,N) cout << next[i] << \' \';\n//  cout << endl;\n    \n    pre();\n    \n    cin >> Q;\n    REP(i,Q){\n        int l,r;\n        scanf(""%d%d"", &l, &r);\n        l--;\n        query[l].push_back(make_pair(r, i));\n    }\n    \n    main2();\n    \n    REP(i,Q) printf(""%d\\n"", ans[i]);\n    \n    return 0;\n}\n']",['data structures'],2700
https://codeforces.com//contest/1874/problem/F,F. Jellyfish and OEIS,Jellyfish always uses OEIS to solve math problems but now she finds a problem that cannot be solved by OEIS Count the number of permutations p of 1 2 dots n such that for all l r such that l leq r leq m l the subarray p l p l 1 dots p r is not a permutation of l l 1 dots r Since the answer may be large you only need to find the answer modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 207, mod = 1e9 + 7;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) (mod - mod / i) * inv[mod % i] % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n} \nint C(int x, int y) {\n\treturn x < y || y < 0 ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint n, dp[N][N], mg[N][N], m[N];\n// dp : [l,r] is good, but not splitable \n// mg : any answer, maybe splitable \n\nint ans;\nint f[N]; \n\nint hm[N][N];\nint perm[N];\nint g[N];\nint p[N];\n\nint H[N][N];\nint dr[N];\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> m[i];\n\t}\n\tinit(n + 1);\n\tL(i, 1, n) {\n\t\tg[i] = fac[i];\n\t\tL(j, 1, i - 1) {\n\t\t\t(g[i] += mod - (ll) g[j] * fac[i - j] % mod) %= mod;\n\t\t}\n\t}\n\t\n\tf[0] = 1;\n\thm[1][1] = 1;\n\tL(i, 1, n) {\n\t\tf[i] = g[i];\n\t\tL(j, 0, i - 1) {\n\t\t\tL(k, 0, i - j) {\n\t\t\t\t(hm[i][k + 1] += (ll) hm[i - j - 1][k] * fac[j] % mod) %= mod;\n\t\t\t}\n\t\t}\n\t\tL(j, 1, i - 1) {\n\t\t\t(f[i] += mod - (ll) hm[i][j] * f[j] % mod) %= mod;\n\t\t}\n\t} \n\t\n\t/*\n\tL(i, 1, n) {\n\t\tcout << f[i] << \' \';\n\t}\n\tcout << endl;\n\tL(k, 1, n) {\n\t\tL(i, 1, k) p[i] = i;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\tint win = 1;\n\t\t\tL(l, 1, k) {\n\t\t\t\tL(r, l, k) {\n\t\t\t\t\tif(l == 1 && r == k) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tL(j, l, r) {\n\t\t\t\t\t\tok &= l <= p[j] && p[j] <= r;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\twin = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(win) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t} while(next_permutation(p + 1, p + k + 1));\n\t\tcout << cnt << \' \';\n\t}\n\tcout << endl;\n\t*/\n\t\n\tL(l, 1, n + 1) \n\t\tmg[l][l - 1] = 1;\n\tR(l, n, 1) {\n\t\tme(H, 0);\n\t\tH[l][1] = 1;\n\t\tL(r, l, n) {\n\t\t\tL(p, l, r) {\n\t\t\t\tL(k, 0, p - l) {\n\t\t\t\t\t(H[r][k + 1] += (ll) H[p - 1][k] * mg[p][r - 1] % mod) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[l][r] = 0;\n\t\t\tL(p, 1, r - l + 1) {\n\t\t\t\t(dp[l][r] += (ll) H[r][p] * f[p] % mod) %= mod;\n\t\t\t}\n\t\t\tif(r <= m[l]) {\n\t\t\t\tdp[l][r] = 0;\n\t\t\t}\n\t\t\tL(j, l - 1, r) {\n\t\t\t\tdr[j] = 0;\n\t\t\t}\n\t\t\tdr[l - 1] = 1;\n\t\t\tL(p, l, r) \n\t\t\t\tif(m[p] < r && dr[p - 1]) {\n\t\t\t\t\tL(i, p, r) \n\t\t\t\t\t\t(dr[i] += (ll) dr[p - 1] * dp[p][i] % mod) %= mod;\n\t\t\t\t}\n\t\t\tmg[l][r] = dr[r];\n//\t\t\tcout << l << \' \' << r << "" : "" << dp[l][r] << \' \' << mg[l][r] << endl; \n\t\t}\n\t}\n\tcout << mg[1][n] << \'\\n\';\n\treturn 0;\n}\n']",['dp'],3500
https://codeforces.com//contest/1560/problem/E,E. Polycarp and String Transformation,Polycarp has a string s Polycarp performs the following actions until the string s is empty t is initially an empty string he adds to the right to the string t the string s i e he does t t s where t s is a concatenation of the strings t and s he selects an arbitrary letter of s and removes from s all its occurrences Polycarp performs this sequence of actions in this order Note that after Polycarp finishes the actions the string s will be empty and the string t will be equal to some value that is undefined and depends on the order of removing E g consider s so the actions may be performed as follows t the letter is selected then s t the letter is selected then s t the letter is selected then s the empty string You need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s ,"['/*#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n\n#include <bits/stdc++.h>\n\n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n\n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n\n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n#define fi first\n#define se second\n#define pb push_back\n#define endof cout << -1 << ""\\n""; goto dumb;\n\nusing namespace std;\n\nstring s;\nint n, m;\n\nint ls[27];\nint rs[27];\n\nsigned main() {\n    // freopen("".inp"", ""r"", stdin);\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(""cf.inp"", ""r"", stdin);\n    // freopen(""cf.out"", ""w"", stdout);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        cin >> s;\n        vector<char> v1;\n        memset(ls, 1, sizeof(ls));\n        memset(rs, 0, sizeof(rs));\n        n = s.size(); s = ""?"" + s;\n        map<char, int> mp;\n        map<int, char> rev;\n        for1(i, 1, n){\n             mp[s[i]] = i;\n        }\n        for(auto cc : mp){\n            rev[cc.se] = cc.fi;\n        }\n        m = mp.size();\n        vector<char> stk;\n        vector<char> inher;\n        for(auto cc : rev) stk.pb(cc.se);\n        inher = stk;\n        while(!stk.empty()){\n            int bulkk;\n            char mn = stk.back();\n            int rang = stk.size(); stk.pop_back();\n            vector<int> f2;\n            for1(i, 1, n){\n                if(s[i] == mn) f2.pb(i);\n            }\n            if((int)f2.size() % rang){\n                endof;\n            }\n            bulkk = (int)f2.size() / rang;\n            for1(i, 1, rang){\n                ls[i] = min(ls[i], f2[i * bulkk - bulkk]);\n                rs[i] = max(rs[i], f2[i * bulkk - 1]);\n            }\n        }\n        for1(i, 2, m){\n            if(ls[i] != rs[i - 1] + 1){\n                endof;\n            }\n        }\n        if(ls[1] != 1 || rs[m] != n){\n            endof;\n        }\n        for1(i, ls[1], rs[1]) v1.pb(s[i]);\n        for1(i, 2, m){\n            char c = inher[i - 2];\n            vector<char> v2;\n            for(char du : v1){\n                if(du != c) v2.pb(du);\n            }\n            v1 = v2;\n            for1(j, 0, v1.size() - 1){\n                if(v1[j] != s[j + ls[i]]){\n                    endof;\n                }\n            }\n        }\n        for1(i, 1, rs[1]) cout << s[i];\n        cout << "" "";\n        for(char c : inher) cout << c;\n        cout << ""\\n"";\n        dumb:;\n    }\n\n}\n']","['binary search', 'implementation', 'sortings', 'strings']",1800
https://codeforces.com//contest/799/problem/D,D. Field expansion,In one of the games Arkady is fond of the game process happens on a rectangular field In the game process Arkady can buy extensions for his field each extension enlarges one of the field sizes in a particular number of times Formally there are extensions the th of them multiplies the width or the length by Arkady s choice by Each extension can t be used more than once the extensions can be used in any order Now Arkady s field has size He wants to enlarge it so that it is possible to place a rectangle of size on it along the width or along the length with sides parallel to the field sides Find the minimum number of extensions needed to reach Arkady s goal ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = (int) 1e9;\n\nconst int N = 1234567;\n\nint x, y;\nint z[N];\n\nbool check(int pos, long long cx, long long cy, int last, int type) {\n  if (pos == -1) {\n    if (cx >= x && cy >= y) {\n      return true;\n    }\n    return false;\n  }\n  if (z[pos] != last || type != 1) {\n    if (check(pos - 1, min(cx * z[pos], x * 1LL), cy, z[pos], 0)) {\n      return true;\n    }\n  }\n  return check(pos - 1, cx, min(cy * z[pos], y * 1LL), z[pos], 1);\n}\n\nint main() {\n  int a, b, h, w, n;\n  scanf(""%d %d %d %d %d"", &a, &b, &h, &w, &n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", z + i);\n  }\n  sort(z, z + n);\n  reverse(z, z + n);\n  int ans = inf;\n  for (int rot = 0; rot < 2; rot++) {\n    x = (a + h - 1) / h;\n    y = (b + w - 1) / w;\n    if (x == 1 && y == 1) {\n      ans = 0;\n      break;\n    }\n    long long prod = 1;\n    bool flag = false;\n    for (int i = 0; i < n; i++) {\n      prod *= z[i];\n      if (prod >= x * y) {\n        flag = true;\n      }\n      if (flag) {\n        if (check(i, 1, 1, -1, -1)) {\n          ans = min(ans, i + 1);\n          break;\n        }\n      }\n    }\n    swap(h, w);\n  }\n  printf(""%d\\n"", ans == inf ? -1 : ans);\n  return 0;\n}\n']","['brute force', 'dp', 'meet-in-the-middle']",2100
https://codeforces.com//contest/1601/problem/F,F. Two Sorts,Integers from 1 to n inclusive were sorted lexicographically considering integers as strings As a result array a 1 a 2 dots a n was obtained Calculate value of sum i 1 n i a i mod 998244353 mod 10 9 7 x mod y here means the remainder after division x by y This remainder is always non negative and doesn t exceed y 1 For example 5 mod 3 2 1 mod 6 5 ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int P = 998244353;\nconst int MOD = 1e9 + 7;\nconst int B = 1000000; \n\nint xmod(LL d)\n{\n\tint ret = d % P;\n\treturn ret < 0 ? ret + P : ret;\n}\nLL n, cnt;\nint ans;\nvector<int> hv[7];\nLL sum[7];\nvoid dfs0(int dep, LL val)\n{\n\tcnt ++;\n\thv[dep].push_back(xmod(cnt - val));\n\tif(dep == 6) return;\n\trep(i, 10) dfs0(dep + 1, val * 10 + i);\n}\nint calc(int id, int coef)\n{\n\tint pos = lower_bound(hv[id].begin(), hv[id].end(), P - coef) - hv[id].begin();\n\treturn (1LL * coef * (int)hv[id].size() + sum[id] - 1LL * P * ((int)hv[id].size() - pos)) % MOD;\n}\nvoid dfs1(int dep, LL val)\n{\n\tif(val > n) return;\n\tif(dep >= 1) {\n\t\tif(val * B > n / 10 && val * B + B - 1 <= n) {\n\t\t\tint tmp = 1;\n\t\t\trep(i, 7) {\n\t\t\t\tans = (ans + calc(i, xmod(cnt - val * tmp))) % MOD; tmp *= 10;\n\t\t\t}\n\t\t\trep(i, 7) cnt += hv[i].size();\n\t\t\treturn;\n\t\t}\n\t\tcnt ++; ans = (ans + xmod(cnt - val)) % MOD;\n\t}\n\tfor(int i = !dep; i < 10; i ++) dfs1(dep + 1, val * 10 + i);\n}\n\nint main()\n{\n\tscanf(""%lld"", &n);\n\tdfs0(0, 0);\n\trep(i, 7) {\n\t\tsort(hv[i].begin(), hv[i].end());\n\t\trep(j, hv[i].size()) sum[i] += hv[i][j];\n\t}\n\tcnt = 0;\n\tdfs1(0, 0);\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']","['binary search', 'dfs and similar', 'math', 'meet-in-the-middle']",3400
https://codeforces.com//contest/914/problem/A,A. Perfect Squares,Given an array of integers find the largest number in the array that is not a perfect square A number is said to be a perfect square if there exists an integer such that ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nbool is(int x){\n\trep(i,0,1000)if(i*i==x)return 1;\n\treturn 0;\n}\nint main(){\n\tint n;scanf(""%d"",&n);\n\tint d=-10000000;\n\twhile(n--){\n\t\tint x;scanf(""%d"",&x);\n\t\tif(!is(x))d=max(d,x);\n\t}\t\t\n\tcout<<d<<endl;\n\treturn 0;\n}\n\n\n\n\n\n']","['brute force', 'implementation', 'math']",900
https://codeforces.com//contest/1406/problem/E,E. Deleting Numbers,There is an unknown integer x 1 le x le n You want to find x At first you have a set of integers 1 2 ldots n You can perform the following operations no more than 10000 times a find how many numbers are multiples of a in the current set a find how many numbers are multiples of a in this set and then delete all multiples of a but x will never be deleted even if it is a multiple of a In this operation a must be greater than 1 a it means that you know that x a This operation can be only performed once Remember that in the operation of type a 1 must hold Write a program that will find the value of x ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl \'\\n\'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\nconst int N = 100100;\nvi primes;\nbool mark[N];\n  int n;\nvoid crivo(){\n\n  for(int i=2;i<=n;i++){\n    if(!mark[i]){\n      if(i<=n)primes.pb(i);\n      for(int j=2*i;j<=n;j+=i)mark[j]=1;\n    }\n  }\n\n}\n\nbool saiu[N];\n\nint askB(int p){\n  if(p > n)return 0;\n  cout <<\'B\' << "" ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\nint askA(int p){\n  if(p > n)return 0;\n  cout << ""A ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\n\nint get(int p){\n  int res=0;\n  for(int i=p;i<=n;i+=p){\n    if(saiu[i])continue;\n    res++;\n    saiu[i] = 1;\n  }\n  return res;\n}\nll getlog(ll x,ll mx){\n  ll r = 1;\n  ll p = x;\n  while(p * x<=mx){\n    p*=x;\n    r++;\n  }\n  return r;\n}\nint elevate(int p,int pwr){\n  int r = 1;\n  for(int i=0;i<pwr;i++)r*=p;\n  return r;\n}\n\nconst int sq = 100;\n\nint P=1;\n#define DB 0\nvoid solve(vi cur){\n  //if(DB)cout <<""ENTREI""<<endl;\n  for(int p : cur){\n    int x = askB(p);\n    if(x!=0){\n\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid=(l+r)/2;\n        int per = askA(P * elevate(p,mid));\n        if(per!=0){\n          res = mid,l = mid + 1;\n        }else r = mid - 1;\n      }\n\n      P*=elevate(p,res);\n    }\n  }\n  \n}\n\nint32_t main(){\n  FASTIO;\n  cin>>n;\n  crivo();\n  \n  vi cur;\n  int fora = 0;\n  int i=0;\n  for(i=0;i<=sz(primes);i++){\n    if(i == sz(primes)){\n      \n    //  if(DB)cout<<""AQUI\\n"";\n\n      solve(cur);\n      break;\n    }\n    cur.pb(primes[i]);\n    int x = askB(primes[i]);\n    int s = get(primes[i]);\n    fora+=x;\n    if(s!=x){\n      solve(cur);\n      break;\n    }\n    if(sz(cur) == sq){\n      \n     // if(DB)cout <<""Aqui ... ""<<sz(cur)<<"" ""<<sq<<endl;\n\n      int A = askA(1);\n      if(A != n-fora){\n        solve(cur);\n        break;\n      }\n      cur.clear();\n    }\n  }\n  if(P == 1){\n    cout <<""C ""<<1<<endl;cout.flush();\n    return 0;\n  }\n  i++;\n  for(;i<sz(primes);i++){\n    int p = primes[i];\n    if(p<=1 || p > n)continue;\n    int per = askA(primes[i] * P);\n    if(per!=0){\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid = (l+r)/2;\n        per = askA(elevate(p,mid) * P);\n        if(per!=0){\n          l = mid + 1;\n          res = mid;\n        }else r = mid - 1;\n      }\n\n\n      P *= elevate(p,res);\n    }\n  }\n\n  cout <<""C ""<<P<<endl;\n  cout.flush();\n  return 0;\n\n}']","['interactive', 'math', 'number theory']",2600
https://codeforces.com//contest/805/problem/A,A. Fake NP,Tavak and Seyyed are good friends Seyyed is very funny and he told Tavak to solve the following problem instead of You are given and For all integers from to inclusive we wrote down all of their integer divisors except Find the integer that we wrote down the maximum number of times Solve the problem to show that it s not a problem ,"['#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <bitset>\n#define fi first\n#define se second\n#define mkp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define per(i,b,a) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,a,b) for (int i=(a);i<=(b);i++)\n#define PER(i,b,a) for (int i=(b);i>=(a);i--)\nusing namespace std;\ntypedef long long LL;\n\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 1000005; // 1e6;\nint l,r;\nint main()\n{\n        scanf(""%d%d"",&l,&r);\n        if (r==l) cout<<l<<endl;\n        else cout<<2<<endl;\n}\n']","['greedy', 'math']",1000
https://codeforces.com//contest/1276/problem/A,A. As Simple as One and Two,You are given a non empty string s s 1s 2 dots s n which consists only of lowercase Latin letters Polycarp does not like a string if it contains at least one string or at least one string or both at the same time as a In other words Polycarp does not like the string s if there is an integer j 1 le j le n 2 that s j s j 1 s j 2 or s j s j 1 s j 2 For example Polycarp does not like strings and they all have at least one substring or Polycarp likes strings and they have no substrings and Polycarp wants to select a certain set of indices positions and remove all letters on these positions All removals are made at the same time For example if the string looks like s then if Polycarp selects two indices 3 and 6 then will be selected and the result is What is the minimum number of indices positions that Polycarp needs to select to make the string liked What should these positions be ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar p[160000];\nint D[160000][6][6], Path[160000][6][6];\nint n, w[160000];\nvoid Solve() {\n\tint i, j, k;\n\tscanf(""%s"", p + 1);\n\tfor (i = 1; p[i]; i++);\n\tn = i - 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (p[i] == \'o\') {\n\t\t\tw[i] = 1;\n\t\t}\n\t\telse if (p[i] == \'n\') {\n\t\t\tw[i] = 2;\n\t\t}\n\t\telse if (p[i] == \'e\') {\n\t\t\tw[i] = 3;\n\t\t}\n\t\telse if (p[i] == \'t\') {\n\t\t\tw[i] = 4;\n\t\t}\n\t\telse if (p[i] == \'w\') {\n\t\t\tw[i] = 5;\n\t\t}\n\t\telse {\n\t\t\tw[i] = 0;\n\t\t}\n\t}\n\tfor (i = 0; i <= n; i++)for (j = 0; j < 6; j++)for (k = 0; k < 6; k++)D[i][j][k] = 1e9;\n\tD[0][0][0] = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tfor (k = 0; k < 6; k++) {\n\t\t\t\tif (D[i-1][j][k] > 8e8)continue;\n\t\t\t\tif (D[i][j][k] > D[i - 1][j][k] + 1){\n\t\t\t\t\tD[i][j][k] = D[i - 1][j][k] + 1;\n\t\t\t\t\tPath[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t\tif (j == 1 && k == 2 && w[i] == 3)continue;\n\t\t\t\tif (j == 4 && k == 5 && w[i] == 1)continue;\n\t\t\t\tif (D[i][k][w[i]] > D[i - 1][j][k]) {\n\t\t\t\t\tD[i][k][w[i]] = D[i - 1][j][k];\n\t\t\t\t\tPath[i][k][w[i]] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Mn = 1e9, x, y;\n\tfor (i = 0; i < 6; i++) {\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tif (Mn > D[n][i][j]) {\n\t\t\t\tx = i, y = j;\n\t\t\t\tMn = D[n][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>Ans;\n\tfor (i = n; i >= 1; i--) {\n\t\tif (Path[i][x][y] == -1) {\n\t\t\tAns.push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t\tint t = Path[i][x][y];\n\t\ty = x;\n\t\tx = t;\n\t}\n\tprintf(""%d\\n"", Ans.size());\n\tif (!Ans.empty()) {\n\t\treverse(Ans.begin(), Ans.end());\n\t\tfor (auto &t : Ans)printf(""%d "", t);\n\t}\n\tputs("""");\n}\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin);\n\tint TC;\n\tscanf(""%d"", &TC);\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}']","['dp', 'greedy']",1400
https://codeforces.com//contest/779/problem/C,C. Dishonest Sellers,Igor found out discounts in a shop and decided to buy items Discounts at the store will last for a week and Igor knows about each item that its price now is and after a week of discounts its price will be Not all of sellers are honest so now some products could be more expensive than after a week of discounts Igor decided that buy of items now but wait with the rest of the week in order to save money as much as possible Your task is to determine the minimum money that Igor can spend to buy all items ,"['#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <stack>\n#define sz size()\n#define pb push_back\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll exp(ll t,ll x){if(x==0) return 1;if(x==1) return t;if(x%2==1) return (t*exp((t*t)%mod,x/2))%mod;if(x%2==0) return exp((t*t)%mod,x/2);} \nll gcd(ll x,ll y){return x%y==0?y:gcd(y,x%y);}\nll lcm(ll x,ll y){return x*(y/gcd(x,y));}\nll bsum(ll u,ll b){return u<b?u:bsum(u/b,b)+u%b;}\nll prival(ll u,ll p){int cn=0;while(u%p==0){cn++;u=u/p;}return cn;}\nbool isprime(ll x){for(ll i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\nvoid YAY(void){cout<<""YES""<<endl;}\nvoid NAY(void){cout<<""NO""<<endl;}\nll a[222222];\nll b[222222];\npair<ll, int> stuf[222222]; // a-b, index\nint n, k, epo;\nll ans;\n\nint main(void)\n{\n\tint i, j;\n\tcin>>n>>k;\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tscanf(""%lld"",&a[i]);\n\t}\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tscanf(""%lld"",&b[i]);\n\t}\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tstuf[i].first=a[i]-b[i];\n\t\tstuf[i].second=i;\n\t}\n\tsort(stuf+1,stuf+n+1);\n\tfor(i=k ; i<=n ; i++)\n\t{\n\t\tif(i==n || stuf[i+1].first>=0)\n\t\t{\n\t\t\tbreak; // ~i use \n\t\t}\n\t}\n\tepo=i;\n\tfor(i=1 ; i<=epo ; i++)\n\t{\n\t\tans+=a[stuf[i].second];\n\t}\n\tfor(i=epo+1 ; i<=n ; i++)\n\t{\n\t\tans+=b[stuf[i].second];\n\t}\n\tcout<<ans;\n\t\n}\n']","['constructive algorithms', 'greedy', 'sortings']",1200
https://codeforces.com//contest/1864/problem/F,F. Exotic Queries,AquaMoon gives RiverHamster a sequence of integers a 1 a 2 dots a n and RiverHamster gives you q queries Each query is expressed by two integers l and r For each query independently you can take any continuous segment of the sequence and subtract an identical non negative value from all the numbers of this segment You can do so multiple possibly zero times However you may not choose two intersecting segments which are not included in one another Your goal is to convert to 0 all numbers whose initial was within the range l r You must do so in the minimum number of operations Please note that the queries are independent the numbers in the array are restored to their initial values between the queries Formally for each query you are to find the smallest m such that there exists a sequence x j y j z j j 1 m satisfying the following conditions for any 1 le j leq m z j ge 0 and 1 le x j le y j leq n here x j y j correspond to the segment of the sequence for any 1 le j k le m it is true that x j y j subseteq x k y k or x k y k subseteq x j y j or x j y j cap x k y k varnothing for any 1 le i le n such that l le a i leq r it is true that large a i sum limits substack 1 le j le m x j le i le y j z j ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int n1=(1<<20);\n\nint n, q;\nint tab[nax];\n\nint drz[2*n1];\n\nvector<pii> kar;\n\npii zap[nax];\nint wyn[nax];\n\nvi wrzuc[nax];\nvi zapy[nax];\n\nvoid pisz(int v, int w)\n{\n\tv+=n1-1;\n\tdrz[v]=w;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=max(drz[2*v], drz[2*v+1]);\n\t\tv>>=1;\n\t}\n}\n\nint czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\treturn drz[v];\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn 0;\n\t}\n\treturn max(\n\t\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\t\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\n\t);\n}\n\nint fen[nax];\n\nvoid pisz2(int v)\n{\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tfen[i]++;\n}\n\nint czyt2(int v)\n{\n\tint ret=0;\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\t{\n\t\tpii ost={0, 0};\n\t\tvector<pii> wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({tab[i], i});\n\t\tsort(wek.begin(), wek.end());\n\t\tfor (pii i : wek)\n\t\t{\n\t\t\tif (ost.first==i.first)\n\t\t\t{\n\t\t\t\tint x=czyt(1, 1, n1, ost.second+1, i.second-1);\n\t\t\t\tif (x)\n\t\t\t\t\tkar.push_back({x, i.first});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkar.push_back({i.first, i.first});\n\t\t\t}\n\t\t\tost=i;\n\t\t\tpisz(i.second, i.first);\n\t\t}\n\t}\n\t//~ debug() << kar;\n\tfor (pii i : kar)\n\t\twrzuc[i.second].push_back(i.first);\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tzap[i]={a, b};\n\t\tzapy[b].push_back(i);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j : wrzuc[i])\n\t\t\tpisz2(j);\n\t\tfor (int j : zapy[i])\n\t\t\twyn[j]=czyt2(zap[j].first);\n\t}\n\t\n\tfor (int i=1; i<=q; i++)\n\t\tprintf(""%d\\n"", wyn[i]);\n\treturn 0;\n}\n']","['data structures', 'implementation', 'sortings']",2300
https://codeforces.com//contest/685/problem/A,A. Robbers  watch,Robbers who attacked the Gerda s cab are very successful in covering from the kingdom police To make the goal of catching them even harder they use their own watches First as they know that kingdom police is bad at math robbers use the positional numeral system Second they divide one day in hours and each hour in minutes Personal watches of each robber are divided in two parts first of them has the smallest possible number of places that is necessary to display any integer from to while the second has the smallest possible number of places that is necessary to display any integer from to Finally if some value of hours or minutes can be displayed using less number of places in base than this watches have the required number of zeroes is added at the beginning of notation Note that to display number section of the watches is required to have at least one place Little robber wants to know the number of moments of time particular values of hours and minutes such that all digits displayed on the watches are Help her calculate this number ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(""%d\\n"",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(""%d\\n"",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define lld ""%I64d""\n#else\n    #define lld ""%lld""\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');c==\'-\'?(sg=-1,x=0):(x=c-\'0\');\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gn(long double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gs(char *s){scanf(""%s"",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n,m;\nint la,lb;\n\nint len(int n){\n\tn--;\n\tif(n==0)return 1;\n\tint su=0;\n\twhile(n){\n\t\tsu++;\n\t\tn/=7;\n\t}\n\treturn su;\n}\n\nint arr[20];\nint bo[20];\n\nint ret=0;\nvoid dfs(int i){\n\tif(i==la+lb+1){\n\t\tint su=0;\n\t\trep(j,1,la+1)su=su*7+arr[j];\n\t\tif(su>=n)return;\n\t\tsu=0;\n\t\trep(j,la+1,la+1+lb)su=su*7+arr[j];\n\t\tif(su>=m)return;\n\n\t\tret++;\n\n\n\n\t}else{\n\t\trep(j,0,7)if(!bo[j]){\n\t\t\tbo[j]=1;\n\t\t\tarr[i]=j;\n\t\t\tdfs(i+1);\n\t\t\tbo[j]=0;\n\t\t}\n\t}\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(m);\n\tla=len(n);\n\tlb=len(m);\n\tif(la+lb>7){\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tdfs(1);\n\tprintf(""%d\\n"",ret);\n\n\t\n#ifdef JCVB\n\tdebug(""time: %d\\n"",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n']","['brute force', 'combinatorics', 'dp', 'math']",1700
https://codeforces.com//contest/946/problem/D,D. Timetable,Ivan is a student at Berland State University BSU There are days in Berland week and each of these days Ivan might have some classes at the university There are working hours during each Berland day and each lesson at the university lasts exactly one hour If at some day Ivan s first lesson is during th hour and last lesson is during th hour then he spends hours in the university during this day If there are no lessons during some day then Ivan stays at home and therefore spends hours in the university Ivan doesn t like to spend a lot of time in the university so he has decided to skip some lessons He cannot skip more than lessons during the week After deciding which lessons he should skip and which he should attend every day Ivan will enter the university right before the start of the first lesson he does not skip and leave it after the end of the last lesson he decides to attend If Ivan skips all lessons during some day he doesn t go to the university that day at all Given and Ivan s timetable can you determine the minimum number of hours he has to spend in the university during one week if he cannot skip more than lessons ,"['// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored ""-Wunused-result""\n#pragma GCC diagnostic ignored ""-Wunused-function""\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(""%d"", &x); }\nvoid _R(int64_t &x) { scanf(""%"" SCNd64, &x); }\nvoid _R(double &x) { scanf(""%lf"", &x); }\nvoid _R(char &x) { scanf("" %c"", &x); }\nvoid _R(char *x) { scanf(""%s"", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(""%d"", x); }\nvoid _W(const int64_t &x) { printf(""%"" PRId64, x); }\nvoid _W(const double &x) { printf(""%.16f"", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(""%s"", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(\' \'); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? \' \' : \'\\n\'); W(tail...); }\n\n#ifdef SHIK\n#include ""dump.hpp""\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=510;\nint n,m,t,a[N][N],b[N][N],dp[N][N];\nvoid main() {\n    R(n,m,t);\n    REP1(i,1,n) REP1(j,1,m) scanf(""%1d"",a[i]+j);\n    REP1(i,1,n) {\n        int tot=0;\n        REP1(j,1,m) tot+=a[i][j];\n        b[i][0]=tot;\n        REP1(j,1,m) b[i][j]=INT_MAX;\n        REP1(j,1,m) {\n            int s=0;\n            REP1(k,j,m) {\n                s+=a[i][k];\n                chkmin(b[i][k-j+1],tot-s);\n            }\n        }\n    }\n    REP1(i,1,n+1) REP1(j,0,t) dp[i][j]=INT_MAX;\n    dp[1][t]=0;\n    REP1(i,1,n) REP1(j,0,t) {\n        int me=dp[i][j];\n        if ( me==INT_MAX ) continue;\n        REP1(k,0,m) if ( b[i][k]<=j ) chkmin(dp[i+1][j-b[i][k]],me+k);\n    }\n    int ans=INT_MAX;\n    REP1(i,0,t) chkmin(ans,dp[n+1][i]);\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n']",['dp'],1800
https://codeforces.com//contest/621/problem/C,C. Wet Shark and Flowers,There are sharks who grow flowers for Wet Shark They are all sitting around the table such that sharks and are neighbours for all from to Sharks and are neighbours too Each shark will grow some number of flowers For th shark value is random integer equiprobably chosen in range from to Wet Shark has it s favourite prime number and he really likes it If for any pair of sharks and the product is divisible by then Wet Shark becomes happy and gives dollars to each of these sharks At the end of the day sharks sum all the money Wet Shark granted to them Find the expectation of this value ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int((x).size()))\n#define bit(x) (1 << (x))\n#define cnt1(x) (__builtin_popcount(x))\n\ntemplate<class T, class U>\ninline void chkmax(T& x, U y) {\n\tif (x < y) x = y;\n}\n\ntemplate<class T, class U>\ninline void chkmin(T& x, U y) {\n\tif (y < x) x = y;\n}\n\ntypedef long long LL;\ntypedef long double DB;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\nconst int MX = 100005;\nint n, p;\nDB a[MX];\n\nint main() {\n//\tfreopen(""in.txt"", ""r"", stdin);\n//\tfreopen(""out.txt"", ""w"", stdout);\n\t\n\tint i, st, en;\n\tDB tot;\n\t\n\tscanf(""%d%d"", &n, &p);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(""%d%d"", &st, &en);\n\t\ta[i] = 1.0L * (en / p - (st - 1) / p) / (en - st + 1);\n\t}\n\ta[n] = a[0];\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\ttot += a[i] + a[i + 1] - a[i] * a[i + 1];\n\t}\n\ttot *= 2000;\n\tprintf(""%.15lf\\n"", double(tot));\n\treturn 0;\n}']","['combinatorics', 'math', 'number theory', 'probabilities']",1700
https://codeforces.com//contest/1886/problem/B,B. Fear of the Dark,Monocarp tries to get home from work He is currently at the point O 0 0 of a two dimensional plane his house is at the point P P x P y Unfortunately it is late in the evening so it is very dark Monocarp is afraid of the darkness He would like to go home along a path illuminated by something Thankfully there are two lanterns located in the points A A x A y and B B x B y You can choose any non negative number w and set the power of lanterns to w If a lantern s power is set to w it illuminates a circle of radius w centered at the lantern location including the borders of the circle You have to choose the minimum non negative value w for the power of the lanterns in such a way that You may assume that the lanterns don t interfere with Monocarp s movement ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Point {\n    int x = 0;\n    int y = 0;\n};\n\ndouble dist(const Point &a, const Point &b) {\n    return std::hypot(a.x - b.x, a.y - b.y);\n}\n\nvoid solve() {\n    Point O, P, A, B;\n    std::cin >> P.x >> P.y >> A.x >> A.y >> B.x >> B.y;\n    \n    double ans = std::min({\n        std::max(dist(O, A), dist(A, P)),\n        std::max(dist(O, B), dist(B, P)),\n        std::max({dist(O, A), dist(A, B) / 2, dist(B, P)}),\n        std::max({dist(O, B), dist(B, A) / 2, dist(A, P)}),\n    });\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::cout << std::fixed << std::setprecision(10);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['binary search', 'geometry', 'math']",1200
https://codeforces.com//contest/825/problem/C,C. Multi-judge Solving,Makes solves problems on Decoforces and lots of other different online judges Each problem is denoted by its difficulty a positive integer number Difficulties are measured the same across all the judges the problem with difficulty on Decoforces is as hard as the problem with difficulty on any other judge Makes has chosen problems to solve on Decoforces with difficulties He can solve these problems in arbitrary order Though he can solve problem with difficulty only if he had already solved some problem with difficulty no matter on what online judge was it With given conditions it s easy to see that Makes sometimes can t solve all the chosen problems no matter what order he chooses So he wants to solve some problems on other judges to finish solving problems from his list Makes can solve problems on any judge at any time it isn t necessary to do problems from the chosen list one right after another Makes doesn t have too much free time so he asked you to calculate the minimum number of problems he should solve on other judges in order to solve all the chosen problems from Decoforces ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n    int n; uint32_t k;\n    in >> n >> k;\n    std::vector<uint32_t> as(n);\n    for (int i = 0; i < n; i++) {\n        in >> as[i];\n    }\n    std::sort(as.begin(), as.end());\n    uint32_t cur = 2 * k;\n    int res = 0;\n    for (uint32_t v : as) {\n        while (v > cur) {\n            res++;\n            cur = cur * 2;\n        }\n        cur = std::max(cur, 2 * v);\n    }\n    out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","['greedy', 'implementation']",1600
https://codeforces.com//contest/1898/problem/B,B. Milena and Admirer,Milena has received an array of integers a 1 a 2 ldots a n of length n from a secret admirer She thinks that making it non decreasing should help her identify the secret admirer She can use the following operation to make this array non decreasing Select an element a i of array a and an integer x such that 1 le x a i Then replace a i by two elements x and a i x in array a New elements x and a i x are placed in the array a in this order instead of a i More formally let a 1 a 2 ldots a i ldots a k be an array a before the operation After the operation it becomes equal to a 1 a 2 ldots a i 1 x a i x a i 1 ldots a k Note that the length of a increases by 1 on each operation Milena can perform this operation multiple times possibly zero She wants you to determine the minimum number of times she should perform this operation to make array a non decreasing An array x 1 x 2 ldots x k of length k is called non decreasing if x i le x i 1 for all 1 le i k ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    long long ans = 0;\n    int c = 1;\n    for (int i = n - 2; i >= 0; --i) {\n        int x = a[i + 1] / c;\n        c = (a[i] + x - 1) / x;\n        c = max(c, 1);\n        ans += c - 1;\n    }\n    cout << ans << ""\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","['greedy', 'math']",1500
https://codeforces.com//contest/749/problem/C,C. Voting,There are employees in Alternative Cake Manufacturing ACM They are now voting on some very important question and the leading world media are trying to predict the outcome of the vote Each of the employees belongs to one of two fractions depublicans or remocrats and these two fractions have opposite opinions on what should be the outcome of the vote The voting procedure is rather complicated Each of employees makes a statement They make statements one by one starting from employees and finishing with employee If at the moment when it s time for the th employee to make a statement he no longer has the right to vote he just skips his turn and no longer takes part in this voting When employee makes a statement he can do nothing or declare that one of the other employees no longer has a right to vote It s allowed to deny from voting people who already made the statement or people who are only waiting to do so If someone is denied from voting he no longer participates in the voting till the very end When all employees are done with their statements the procedure repeats again each employees starting from and finishing with who are still eligible to vote make their statements The process repeats until there is only one employee eligible to vote remaining and he determines the outcome of the whole voting Of course he votes for the decision suitable for his fraction You know the order employees are going to vote and that they behave optimal and they also know the order and who belongs to which fraction Predict the outcome of the vote ,"['#include <bits/stdc++.h>\n#include <iostream>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nll n,a,b;\nchar s[222222];\nset<ll>x,y;\nint main()\n{\n\tcin>>n;\n\tscanf(""%s"",s);\n\tfor(ll i=0;i<n;i++)\n\t\tif(s[i]==\'D\')\n\t\t\tx.insert(i+1);\n\t\telse\n\t\t\ty.insert(i+1);\n\tfor(;!x.empty()&&!y.empty();)\n\t{\n\t\ta=*x.begin();\n\t\tb=*y.begin();\n\t\tx.erase(x.begin());\n\t\ty.erase(y.begin());\n\t\tif(a<b)\n\t\t\tx.insert(a+n);\n\t\telse\n\t\t\ty.insert(b+n);\n\t}\n\tif(!x.empty())\n\t\tcout<<""D"";\n\telse\n\t\tcout<<""R"";\n}']","['greedy', 'implementation', 'two pointers']",1500
https://codeforces.com//contest/1838/problem/D,D. Bracket Walk,There is a string s of length n consisting of the characters and You are walking on this string You start by standing on top of the first character of s and you want to make a sequence of moves such that you end on the n th character In one step you can move one space to the left if you are not standing on the first character or one space to the right if you are not standing on the last character You may not stay in the same place however you may visit any character including the first and last character number of times At each point in time you write down the character you are currently standing on We say the string is if there exists some sequence of moves that take you from the first character to the last character such that the string you write down is a regular bracket sequence A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not You are given q queries Each query flips the value of a character from to or vice versa After each query determine whether the string is walkable Queries are so the effects of each query carry on to future queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n,q; cin>>n>>q;\n    set<int> bl;\n    for (int i = 0; i < n; ++i) {\n        char c; cin>>c;\n        bool b = c == \'(\';\n        if (b ^ (i % 2 == 0)) {\n            bl.insert(i);\n        }\n    }\n    for (int qi = 0; qi < q; ++qi) {\n        int i; cin>>i; --i;\n        if (n % 2 == 1) {\n            cout << ""NO\\n"";\n            continue;\n        }\n        if (bl.count(i)) {\n            bl.erase(i);\n        } else {\n            bl.insert(i);\n        }\n        if (bl.empty() || (*bl.begin() % 2 == 1 && *bl.rbegin() % 2 == 0)) {\n            cout << ""YES\\n"";\n        } else {\n            cout << ""NO\\n"";\n        }\n    }\n}\n']","['data structures', 'greedy', 'strings']",2100
https://codeforces.com//contest/1717/problem/C,C. Madoka and Formal Statement,Given an array of integer a 1 a 2 ldots a n In one operation you can make a i a i 1 if i n and a i leq a i 1 or i n and a i leq a 1 You need to check whether the array a 1 a 2 ldots a n can become equal to the array b 1 b 2 ldots b n in some number of operations possibly zero Two arrays a and b of length n are called equal if a i b i for all integers i from 1 to n ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nint n, a[N], b[N];\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        cin >> b[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (b[i] < a[i]) {\n            cout << ""NO\\n"";\n            return;\n        }\n        if (b[i] > a[i]) {\n            int j = i == n ? 1 : (i + 1);\n            if (b[j] < b[i] - 1) {\n                cout << ""NO\\n"";\n                return;\n            }\n        }\n    }\n    cout << ""YES\\n"";\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}']",['greedy'],1300
https://codeforces.com//contest/152/problem/B,B. Steps,One day Vasya went out for a walk in the yard but there weren t any of his friends outside and he had no one to play touch and run But the boy didn t lose the high spirits and decided to play touch and run with himself You may ask How did he do that The answer is simple Vasya noticed that the yard is a rectangular field The squares have coordinates where is the index of the row and is the index of the column Initially Vasya stands in the square with coordinates To play he has got a list of vectors of non zero length The game goes like this The boy considers all vectors in the order from to and consecutively chooses each vector as the current one After the boy has chosen a current vector he makes the maximally possible number of valid steps in the vector s direction it is possible that he makes zero steps A is defined as one movement from the square where the boy is standing now in the direction of the current vector That is if Vasya is positioned in square and the current vector is one step moves Vasya to square A step is considered if the boy does not go out of the yard if he performs the step Vasya stepped on and on on and on until he ran out of vectors in his list Ha had been stepping for so long that he completely forgot how many steps he had made Help the boy and count how many steps he had made ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\nstring s[110];\nconst int mod=1000000007;\n\nint n, m;\n\nLL get(int cx, int cy, int dx, int dy){\n\tLL left=0, right=1LL<<35;\n\twhile( left+1<right ){\n\t\tLL mid=(left+right)/2;\n\t\tLL tx=cx+dx*mid;\n\t\tLL ty=cy+dy*mid;\n\t\tif( tx<1 || tx>n || ty<1 || ty>m ) right=mid;\n\t\telse left=mid;\n\t}\n\treturn left;\n}\nint main(){\n\t\n\twhile( scanf(""%d %d"", &n, &m)!=EOF ){\n\t\tint cx, cy;\n\t\tscanf(""%d %d"", &cx, &cy);\n\t\tLL ans=0;\n\t\tint k; scanf(""%d"",&k);\n\t\twhile( k-- ){\n\t\t\tint dx, dy; scanf(""%d %d"", &dx, &dy);\n\t\t\tLL step=get(cx, cy, dx, dy);\n\t\t\tans+=step;\n\t\t\tcx+=dx*step;\n\t\t\tcy+=dy*step;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}']","['binary search', 'implementation']",1300
https://codeforces.com//contest/1733/problem/D1,D1. Zero-One  Easy Version ,You are given two binary strings a and b both of length n You can do the following operation any number of times possibly zero Select two indices l and r l r Change a l to 1 a l and a r to 1 a r If l 1 r the cost of the operation is x Otherwise the cost is y You have to find the minimum cost needed to make a equal to b or say there is no way to do so ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint T;\n\nint n,m;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tstring s,t;\n\t\tvector<int>v;\n\t\tcin>>s>>t;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(s[i]!=t[i])\n\t\t\t\tv.push_back(i);\n\t\tif(v.size()&1)\n\t\t{\n\t\t\tcout<<""-1\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tlong long ans=0;\n\t\tif(v.size()>2||v.size()==0||(v[0]+1!=v[1]))\n\t\t{\n\t\t\tans=v.size()/2*y;\n\t\t\tcout<<ans<<""\\n"";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans=min(2*y,x);\n\t\t\tcout<<ans<<""\\n"";\n\t\t}\n\t}\n}']","['constructive algorithms', 'greedy', 'math']",1400
https://codeforces.com//contest/1807/problem/B,B. Grab the Candies,Mihai and Bianca are playing with bags of candies They have a row a of n bags of candies The i th bag has a i candies The bags are given to the players in the order from the first bag to the n th bag If a bag has an even number of candies Mihai grabs the bag Otherwise Bianca grabs the bag Once a bag is grabbed the number of candies in it gets added to the total number of candies of the player that took it Mihai wants to show off so he wants to reorder the array so that at any moment except at the start when they both have no candies Mihai will have candies than Bianca Help Mihai find out if such a reordering exists ,"['#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++)\n    {\n        int n, sm1 = 0, sm2 = 0;\n        cin >> n;\n        for (int j = 0; j < n; j++)\n        {\n            int a;\n            cin >> a;\n            if (a % 2 == 0) sm1 += a;\n            else sm2 += a;\n        }\n        if (sm1 > sm2) cout << ""YES\\n"";\n        else cout << ""NO\\n"";\n    }\n}\n']",['greedy'],800
https://codeforces.com//contest/444/problem/C,C. DZY Loves Colors,On a colorful day DZY gets a colorful ribbon which consists of units they are numbered from to from left to right The color of the th unit of the ribbon is at first It is colorful enough but we still consider that the colorfulness of each unit is at first DZY loves painting we know He takes up a paintbrush with color and uses it to draw a line on the ribbon In such a case some contiguous units are painted Imagine that the color of unit currently is When it is painted by this paintbrush the color of the unit becomes and the colorfulness of the unit increases by DZY wants to perform operations each operation can be one of the following Paint all the units with numbers between and both inclusive with color Ask the sum of colorfulness of the units between and both inclusive Can you help DZY ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define M 1000000007\n#define N 411111\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m;\nlong long sum[N], add[N];\nset<pair<pt, int> > W;\nset<pair<pt, int> > :: iterator it;\n\nvoid mod(int pos, int l, int r, int ll, int rr, long long v) {\n\tll = max(ll, l);\n\trr = min(rr, r);\n\tif (ll > rr) return;\n\tif (l == ll && r == rr) {\n\t\tsum[pos] += (r - l + 1) * v;\n\t\tadd[pos] += v;\n\t\treturn;\n\t}\n\tif (add[pos] != 0) {\n\t\tmod(pos + pos, l, (l + r) / 2, l, r, add[pos]);\n\t\tmod(pos + pos + 1, (l + r) / 2 + 1, r, l, r, add[pos]);\n\t\tadd[pos] = 0;\n\t}\n\tmod(pos + pos, l, (l + r) / 2, ll, rr, v);\n\tmod(pos + pos + 1, (l + r) / 2 + 1, r, ll, rr, v);\n\tsum[pos] = sum[pos + pos] + sum[pos + pos + 1];\n}\n\nlong long fin(int pos, int l, int r, int ll, int rr) {\n\tll = max(ll, l);\n\trr = min(rr, r);\n\tif (ll > rr) return 0;\n\tif (l == ll && r == rr) return sum[pos];\n\tif (add[pos] != 0) {\n\t\tmod(pos + pos, l, (l + r) / 2, l, r, add[pos]);\n\t\tmod(pos + pos + 1, (l + r) / 2 + 1, r, l, r, add[pos]);\n\t\tadd[pos] = 0;\n\t}\n\tlong long q1 = fin(pos + pos, l, (l + r) / 2, ll, rr);\n\tlong long q2 = fin(pos + pos + 1, (l + r) / 2 + 1, r, ll, rr);\n\treturn q1 + q2;\n}\n\nvoid di(int x) {\n\tit = W.lower_bound(mp(mp(x + 1, x), 0));\n\tif (it == W.begin()) return;\n\tit--;\n\tint ll = (*it).F.F;\n\tint rr = (*it).F.S;\n\tint col = (*it).S;\n\tif (x >= ll && x < rr) {\n\t\tW.erase(it);\n\t\tW.insert(mp(mp(ll, x), col));\n\t\tW.insert(mp(mp(x + 1, rr), col));\t\t\n\t}\n}\n\nint main(){\n//\tfreopen(""1.in"",""r"",stdin);\t\n//\tfreopen(""1.out"",""w"",stdout);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) W.insert(mp(mp(i, i), i));\n\twhile (m--) {\n\t\tint type;\n\t\tscanf(""%d"", &type);\n\t\tif (type == 1) {\n\t\t\tint l, r, x;\n\t\t\tscanf(""%d%d%d"", &l, &r, &x);\n\t\t\tl--;\n\t\t\tr--;\n\t\t\tx--;\n\t\t\tdi(l - 1);\n\t\t\tdi(r);\n\t\t\tfor(;;) {\n\n\t\t\t\tit = W.lower_bound(mp(mp(l, l), 0));\n\t\t\t\tif (it == W.end() || (*it).F.F > r) break;\n\n\t\t\t\tint dif = abs(x - (*it).S);\n\t\t\t\tmod(1, 0, n - 1, (*it).F.F, (*it).F.S, dif);\n\t\t\t\tW.erase(it);\n\t\t\t}\n\t\t\tW.insert(mp(mp(l, r), x));\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tscanf(""%d%d"", &l, &r);\n\t\t\tl--;\n\t\t\tr--;\n\t\t\tprintf(""%I64d\\n"", fin(1, 0, n - 1, l, r)); \n\t\t}\n\t}\n\treturn 0;\n}']",['data structures'],2400
https://codeforces.com//contest/1296/problem/B,B. Food Buying,Mishka wants to buy some food in the nearby shop Initially he has s burles on his card Mishka can perform the following operation any number of times possibly zero choose some 1 le x le s buy food that costs exactly x burles and obtain lfloor frac x 10 rfloor burles as a cashback in other words Mishka spends x burles and obtains lfloor frac x 10 rfloor back The operation lfloor frac a b rfloor means a divided by b rounded down It is guaranteed that you can always buy some food that costs x for any possible value of x Your task is to say the maximum number of burles Mishka can spend if he buys food optimally For example if Mishka has s 19 burles then the maximum number of burles he can spend is 21 Firstly he can spend x 10 burles obtain 1 burle as a cashback Now he has s 10 burles so can spend x 10 burles obtain 1 burle as a cashback and spend it too You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        scanf(""%d"",&n);\n        LL ans=0;\n        while(n>=10){\n            ans+=n/10*10;\n            n=n%10+n/10;\n        }\n        ans+=n;\n        printf(""%lld\\n"",ans);\n\n    }\n    return 0;\n}\n/*\n*/\n']",['math'],900
https://codeforces.com//contest/920/problem/E,E. Connected Components ,You are given an undirected graph consisting of vertices and edges Instead of giving you the edges that exist in the graph we give you unordered pairs such that there is no edge between and and if some pair of vertices is not listed in the input then there is an edge between these vertices You have to find the number of connected components in the graph and the size of each component A connected component is a set of vertices such that for every two vertices from this set there exists at least one path in the graph connecting these vertices but adding any other vertex to violates this rule ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nset <pii> Sx;\nvector <int> conn[200050];\n\nbool pchk[200050];\n\nint lc = 1;\nvector <int> Vl[200050];\n\nint r[200050];\nint sz[200050];\nint root(int x) {\n\treturn (x == r[x]) ? x : (r[x] = root(r[x]));\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2;\n\t\tscanf(""%d %d"", &t1, &t2);\n\t\tSx.emplace(t1, t2);\n\t\tSx.emplace(t2, t1);\n\t\tconn[t1].push_back(t2);\n\t\tconn[t2].push_back(t1);\n\t}\n\n\tint p = 1;\n\tfor (i = 2; i <= N; i++) if (conn[i].size() < conn[p].size()) p = i;\n\tfor (auto it : conn[p]) pchk[it] = true;\n\tfor (i = 1; i <= N; i++) if (!pchk[i]) Vl[1].push_back(i);\n\tfor (i = 1; i <= N; i++) {\n\t\tif (!pchk[i]) continue;\n\t\tlc++;\n\t\tVl[lc].push_back(i);\n\t}\n\n\tfor (i = 1; i <= lc; i++) r[i] = i;\n\tfor (i = 1; i <= lc; i++) {\n\t\tfor (j = i + 1; j <= lc; j++) {\n\t\t\tbool chk = false;\n\t\t\tfor (auto it1 : Vl[i]) {\n\t\t\t\tfor (auto it2 : Vl[j]) {\n\t\t\t\t\tif (Sx.count(pii(it1, it2))) continue;\n\t\t\t\t\tchk = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chk) r[root(i)] = root(j);\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (i = 1; i <= lc; i++) sz[root(i)] += Vl[i].size();\n\n\tvector <int> Va;\n\tfor (i = 1; i <= lc; i++) if (r[i] == i) Va.push_back(sz[i]);\n\tsort(all(Va));\n\n\tprintf(""%d\\n"", (int)Va.size());\n\tfor (auto it : Va) printf(""%d "", it);\n\treturn !printf(""\\n"");\n}\n//*/']","['data structures', 'dfs and similar', 'dsu', 'graphs']",2100
https://codeforces.com//contest/804/problem/A,A. Find Amir,A few years ago Sajjad left his school and register to another one due to security reasons Now he wishes to find Amir one of his schoolmates and good friends There are schools numerated from to One can travel between each pair of them to do so he needs to buy a ticket The ticker between schools and costs and can be used multiple times Help Sajjad to find the minimum cost he needs to pay for tickets to visit all schools He can start and finish in any school ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + "" in line "" + std::to_string(__LINE__) + "" in "" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it\'s reference type is not a reference.\n*\n* It doesn\'t return reference because\n* 1. Anyway it\'ll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It\'ll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it\'s seems to work at least on my implementation.\n*\n* It\'s not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\nusing namespace std;\n\nclass TaskA {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n;\n\t\tin >> n;\n\t\tint l = 1;\n\t\tint r = n;\n\t\tvector<int> v;\n\t\twhile (l <= r) {\n\t\t\tv.push_back(l++);\n\t\t\tif (l <= r) {\n\t\t\t\tv.push_back(r--);\n\t\t\t}\n\t\t}\n\t\tint64_t ans = 0;\n\t\tfor (int i: range(1, n)) {\n\t\t\tans += (v[i] + v[i - 1]) % (n + 1);\n\t\t}\n\t\tout << ans << ""\\n"";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'math']",1000
https://codeforces.com//contest/1744/problem/B,B. Even-Odd Increments ,You are given n of integers a 1 a 2 ldots a n Process q queries of two types query of the form add the value x j to all even elements of the array a query of the form add the value x j to all odd elements of the array a Note that when processing the query we look specifically at the odd even value of a i not its index After processing each query print the sum of the elements of the array a Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint t,n,type,x,q;\nint a[100007];\nlong long sum;\nlong long cnt[2];\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>t;\n    for(int i=1;i<=t;i++){\n        cin>>n>>q;\n        cnt[0]=cnt[1]=sum=0;\n        for(int f=0;f<n;f++){\n            cin>>a[f];\n            cnt[a[f]%2]++;\n            sum+=a[f];\n        }\n        \n        for(int f=0;f<q;f++){\n            cin>>type>>x;\n            if(type==0){\n                if(x%2==0){\n                    sum+=cnt[0]*x;\n                }else{\n                    sum+=cnt[0]*x;\n                    cnt[1]+=cnt[0]; cnt[0]=0;\n                }\n            }else{\n                if(x%2==0){\n                    sum+=cnt[1]*x;\n                }else{\n                    sum+=cnt[1]*x;\n                    cnt[0]+=cnt[1]; cnt[1]=0;\n                }\n            }\n            cout<<sum<<""\\n"";\n        }\n    }\n\n    return 0;\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/1446/problem/B,B. Catching Cheaters,You are given two strings A and B representing essays of two students who are suspected cheaters For any two strings C D we define their similarity score S C D as 4 cdot LCS C D C D where LCS C D denotes the length of the Longest Common of strings C and D You believe that only some part of the essays could have been copied therefore you re interested in their Calculate the maximal similarity score over all pairs of substrings More formally output maximal S C D over all pairs C D where C is some substring of A and D is some substring of B If X is a string X denotes its length A string a is a of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end A string a is a of a string b if a can be obtained from b by deletion of several possibly zero or all characters Pay attention to the difference between the and as they both appear in the problem statement You may wish to read the Wikipedia page about the Longest Common Subsequence problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 5050;\nint n, m;\nint dp[N][N];\nchar a[N], b[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\tscanf(""%s %s"", a, b);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j] - 1);\n\t\t\tdp[i][j + 1] = max(dp[i][j + 1], dp[i][j] - 1);\n\t\t\tif (a[i] == b[j])\n\t\t\t\tdp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 2);\n\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= m; j++)\n\t\t\tans = max(ans, dp[i][j]);\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","['dp', 'strings']",1800
https://codeforces.com//contest/1100/problem/F,F. Ivan and Burgers,Ivan loves burgers and spending money There are n burger joints on the street where Ivan lives Ivan has q friends and the i th friend suggested to meet at the joint l i and walk to the joint r i l i leq r i While strolling with the i th friend Ivan can visit all joints x which satisfy l i leq x leq r i For each joint Ivan knows the cost of the most expensive burger in it it costs c i burles Ivan wants to visit some subset of joints on his way in each of them he will buy the most expensive burger and spend the most money But there is a small issue his card broke and instead of charging him for purchases the amount of money on it changes as follows If Ivan had d burles before the purchase and he spent c burles at the joint then after the purchase he would have d oplus c burles where oplus denotes the bitwise XOR operation Currently Ivan has 2 2 100 1 burles and he wants to go out for a walk Help him to determine the maximal amount of burles he can spend if he goes for a walk with the friend i The amount of burles he spends is defined as the difference between the initial amount on his account and the final account ,"['#include<bits/stdc++.h>\n#define MAXN 500005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,q,a[MAXN],ans[MAXN],bas[40],pos[40];\nvector<P> eve[MAXN];\nint main()\n{\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n    scanf(""%d"",&q);\n    for(int i=0;i<q;i++)\n    {\n        int l,r;scanf(""%d%d"",&l,&r);\n        eve[r].push_back(P(l,i));\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int x=a[i],p=i;\n        for(int j=20;j>=0;j--)\n        {\n            if(x&(1<<j))\n            {\n                if(!bas[j])\n                {\n                    bas[j]=x;pos[j]=p;\n                    break;\n                }\n                if(pos[j]<p) swap(bas[j],x),swap(pos[j],p);\n                x^=bas[j];\n            }\n        }\n        for(auto p:eve[i])\n            for(int j=20;j>=0;j--)\n                if(pos[j]>=p.F) ans[p.S]=max(ans[p.S],ans[p.S]^bas[j]);\n    }\n    for(int i=0;i<q;i++) printf(""%d\\n"",ans[i]);\n    return 0;\n}\n']","['data structures', 'divide and conquer', 'greedy', 'math']",2500
https://codeforces.com//contest/1203/problem/F1,F1. Complete the Projects  easy version , Polycarp is a very famous freelancer His current rating is r units Some very rich customers asked him to complete some projects for their companies To complete the i th project Polycarp needs to have at least a i units of rating after he completes this project his rating will change by b i his rating will increase or decrease by b i b i can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Is it possible to complete all the projects Formally write a program to check if such an order of the projects exists that Polycarp has enough rating before starting each project and he has non negative rating after completing each project In other words you have to check that there exists such an order of projects in which Polycarp will complete them so he has enough rating before starting each project and has non negative rating after completing each project ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Project {\n\tint a, b;\n};\n\nvoid maximize(int &a, int b) {\n\tif (a < b) a = b;\n}\n\nint main() {\n\tint n, r;\n\tcin >> n >> r;\n\t\n\tvector<Project> pos, neg;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (b >= 0) {\n\t\t\tpos.push_back({a, b});\n\t\t} else {\n\t\t\tneg.push_back({a, -b});\n\t\t}\n\t}\n\n\tsort(begin(pos), end(pos), [](const Project &x, const Project &y) { return x.a < y.a; });\n\tint res = 0;\n\tfor (auto it : pos) {\n\t\tif (r >= it.a) {\n\t\t\tr += it.b;\n\t\t\t++res;\n\t\t}\n\t}\n\n\tsort(begin(neg), end(neg), [](const Project &x, const Project &y) { return x.a - x.b > y.a - y.b; });\n\tvector< vector<int> > dp(neg.size() + 1, vector<int>(r + 1, -1));\n\tdp[0][r] = 0;\n\tfor (int i = 0; i < neg.size(); ++i) {\n\t\tfor (int j = 0; j <= r; ++j) if (dp[i][j] >= 0) {\n\t\t\tif (j >= max(neg[i].a, neg[i].b)) {\n\t\t\t\tmaximize(dp[i + 1][j - neg[i].b], dp[i][j] + 1);\n\t\t\t}\n\t\t\tmaximize(dp[i + 1][j], dp[i][j]);\n\t\t}\n\t}\n\tres += *max_element(begin(dp[neg.size()]), end(dp[neg.size()]));\n\tcout << (res == n ? ""YES"" : ""NO"") << endl;\n}']",['greedy'],2100
https://codeforces.com//contest/839/problem/C,C. Journey,There are cities and roads in the Seven Kingdoms each road connects two cities and we can reach any city from any other by the roads Theon and Yara Greyjoy are on a horse in the first city they are starting traveling through the roads But the weather is foggy so they can t see where the horse brings them When the horse reaches a city including the first one it goes to one of the cities connected to the current city But it is a strange horse it only goes to cities in which they weren t before In each such city the horse goes with equal probabilities and it stops when there are no such cities Let the length of each road be The journey starts in the city What is the expected length expected value of length of their journey You can read about expected average value by the link https en wikipedia org wiki Expected value ,"['#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=1000*1007;\n\nint n;\n\nvector <int> graf[N];\n\ndouble dfs(int v, int par)\n{\n    double res=0.0;\n    int cou=0;\n    for (int i : graf[v])\n    {\n        if (i==par)\n            continue;\n        cou++;\n        res+=dfs(i, v);\n    }\n    if (!cou)\n        return 0.0;\n    return (res/cou)+1.0;\n}\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i=1; i<n; i++)\n    {\n        int a, b;\n        scanf(""%d%d"", &a, &b);\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n    printf(""%.9lf\\n"", dfs(1, 0));\n    return 0;\n}\n']","['dfs and similar', 'dp', 'graphs', 'probabilities', 'trees']",1500
https://codeforces.com//contest/144/problem/E,E. Competition,The secondary diagonal of a square matrix is a diagonal going from the top right to the bottom left corner Let s define an degree as a square matrix containing no squares above the secondary diagonal the picture below shows a 5 degree staircase The squares of the degree staircase contain sportsmen A sportsman needs one second to move to a side neighboring square of the staircase Before the beginning of the competition each sportsman must choose one of the shortest ways to the secondary diagonal After the starting whistle the competition begins and all sportsmen start moving along the chosen paths When a sportsman reaches a cell of the secondary diagonal he stops and moves no more The competition ends when all sportsmen reach the secondary diagonal The competition is considered successful if during it no two sportsmen were present in the same square simultaneously Any square belonging to the secondary diagonal also cannot contain more than one sportsman If a sportsman at the given moment of time leaves a square and another sportsman comes to it then they are not considered to occupy the same square simultaneously Note that other extreme cases for example two sportsmen moving towards each other are impossible as the chosen ways are the shortest ones You are given positions of sportsmen on the staircase Your task is to choose among them the maximum number of sportsmen for who the competition can be successful that is so that there existed such choice of shortest ways for the sportsmen at which no two sportsmen find themselves in the same square simultaneously All other sportsmen that are not chosen will be removed from the staircase before the competition starts ,"['#include <string>\n#include <algorithm>\n#include <utility>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <utility>\n#include <time.h>\n#include <string.h>\nusing namespace std;\n\n\nint main( void )\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector< pair<pair<int,int>,int> > R(m);\n\tfor( int i = 0; i < m; i ++ ){\n\t\tint r, c;\n\t\tcin >> r >> c;\n\t\tR.push_back(pair<pair<int,int>,int>(pair<int,int>(n-r+1, c), i));\n\t}\n\tsort( R.begin(), R.end() );\n\tpriority_queue<pair<int,int> > wl;\n\tint ans = 0;\n\tvector<int> ANS;\n\tfor( int pos = 1, j = 0; pos <= n; pos ++ ){\n\t\twhile( j < R.size() && R[j].first.first <= pos ){\n\t\t\twl.push( pair<int,int>(-R[j].first.second, R[j].second) ); j ++;\n\t\t}\n\t\twhile( !wl.empty() && (-wl.top().first) < pos )\n\t\t\twl.pop();\n\t\tif( !wl.empty() ){\n\t\t\tANS.push_back(wl.top().second);\n\t\t\twl.pop();\n\t\t\t++ ans;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tfor( int i = 0; i < ANS.size(); i ++ ){\n\t\tif( i > 0 )\n\t\t\tcout << "" "";\n\t\tcout << (ANS[i]+1);\n\t}\n\tcout << endl;\n}\n']","['data structures', 'greedy']",2200
https://codeforces.com//contest/786/problem/B,B. Legacy,Rick and his co workers have made a new radioactive formula and a lot of bad guys are after them So Rick wants to give his legacy to Morty before bad guys catch them There are planets in their universe numbered from to Rick is in planet number the earth and he doesn t know where Morty is As we all know Rick owns a portal gun With this gun he can open one way portal from a planet he is in to any other planet including that planet But there are limits on this gun because he s still using its free trial By default he can not open any portal by this gun There are plans in the website that sells these guns Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more Plans on the website have three types With a plan of this type you can open a portal from planet to planet With a plan of this type you can open a portal from planet to any planet with index in range With a plan of this type you can open a portal from any planet with index in range to planet Rick doesn t known where Morty is but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately So for each planet including earth itself he wants to know the minimum amount of money he needs to get from earth to that planet ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=901000;\nvector<PII> e[N];\nVI ve;\nll dis[N];\nint vis[N],tot;\nset<pair<ll,int> > hs;\nint nd[2][N],n,q,s,ty,u,v,w,l,r;\nvoid add(int u,int v,int w) {\n\te[u].pb(mp(v,w));\n//\tprintf(""%d %d %d\\n"",u,v,w);\n}\nvoid dijkstra(int S,int n) {\n\trep(i,1,n+1) dis[i]=1ll<<60,vis[i]=0;\n\tdis[S]=0;\n\trep(i,1,n+1) hs.insert(mp(dis[i],i));\n\trep(i,1,n+1) {\n\t\tint u=hs.begin()->se; hs.erase(hs.begin());\n\t\tvis[u]=1;\n\t\trep(j,0,SZ(e[u])) {\n\t\t\tint v=e[u][j].fi;\n\t\t\tif (dis[v]>dis[u]+e[u][j].se) {\n\t\t\t\ths.erase(mp(dis[v],v));\n\t\t\t\tdis[v]=dis[u]+e[u][j].se;\n\t\t\t\ths.insert(mp(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid build(int p,int l,int r,int ty) {\n\tnd[ty][p]=++tot;\n\tif (l==r) {\n\t\tif (ty==0) add(nd[0][p],l,0);\n\t\tif (ty==1) add(l,nd[1][p],0);\n\t\treturn;\n\t}\n\tint md=(l+r)>>1;\n\tbuild(p+p,l,md,ty);\n\tbuild(p+p+1,md+1,r,ty);\n\tif (ty==0) {\n\t\tadd(nd[0][p],nd[0][p+p],0);\n\t\tadd(nd[0][p],nd[0][p+p+1],0);\n\t} else {\n\t\tadd(nd[1][p+p],nd[1][p],0);\n\t\tadd(nd[1][p+p+1],nd[1][p],0);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,int ty) {\n\tif (tl==l&&tr==r) ve.pb(nd[ty][p]);\n\telse {\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,ty);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,ty);\n\t\telse modify(p+p,l,md,tl,md,ty),modify(p+p+1,md+1,r,md+1,tr,ty);\n\t}\n}\nint main() {\n\tscanf(""%d%d%d"",&n,&q,&s);\n\ttot=n+1;\n\tbuild(1,1,n,0);\n\tbuild(1,1,n,1);\n\trep(i,1,q+1) {\n\t\tscanf(""%d%d"",&ty,&v);\n\t\tif (ty==1) {\n\t\t\tscanf(""%d%d"",&u,&w);\n\t\t\tadd(v,u,w);\n\t\t} else {\n\t\t\tscanf(""%d%d%d"",&l,&r,&w);\n\t\t\tve.clear();\n\t\t\tmodify(1,1,n,l,r,ty-2);\n\t\t\tif (ty==2) {\n\t\t\t\tfor (auto u:ve) add(v,u,w);\n\t\t\t} else {\n\t\t\t\tfor (auto u:ve) add(u,v,w);\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(s,tot-1);\n\trep(i,1,n+1) {\n\t\tif (dis[i]>=(1ll<<50)) dis[i]=-1;\n\t\tprintf(""%lld "",dis[i]);\n\t}\n\tputs("""");\n}\n']","['data structures', 'graphs', 'shortest paths']",2300
https://codeforces.com//contest/311/problem/B,B. Cats Transport,Zxr960115 is owner of a large farm He feeds cute cats and employs feeders There s a straight road across the farm and hills along the road numbered from 1 to from left to right The distance between hill and is meters The feeders live in hill 1 One day the cats went out to play Cat went on a trip to hill finished its trip at time and then waited at hill for a feeder The feeders must take all the cats Each feeder goes straightly from hill 1 to without waiting at a hill and takes all the cats at each hill away Feeders walk at a speed of 1 meter per unit time and are strong enough to take as many cats as they want For example suppose we have two hills and one cat that finished its trip at time 3 at hill 2 Then if the feeder leaves hill 1 at time 2 or at time 3 he can take this cat but if he leaves hill 1 at time 1 he can t take it If the feeder leaves hill 1 at time 2 the cat waits him for 0 time units if the feeder leaves hill 1 at time 3 the cat waits him for 1 time units Your task is to schedule the time leaving from hill 1 for each feeder so that the sum of the waiting time of all cats is minimized ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,p,x,h,t,now,last,d[100010],ti[100010],q[100010];\nlong long f[100010][2],sum[100010];\nint main(){\n    scanf(""%d%d%d"",&n,&m,&p);\n    for(int i=2;i<=n;++i){\n        scanf(""%d"",&d[i]);\n        d[i]+=d[i-1];\n    }\n    for(int i=1;i<=m;++i){\n        scanf(""%d%d"",&x,&ti[i]);\n        ti[i]-=d[x];\n        sum[i]=sum[i-1]+ti[i];\n    }\n    sort(ti+1,ti+m+1);\n    memset(f,63,sizeof(f));\n    f[0][0]=0;\n    for(int e=1;e<=p;++e){\n        last=now;now^=1;\n        h=t=0;q[t]=0; \n        for(int i=1;i<=m;++i){\n            while(h<t&&f[q[h+1]][last]+sum[q[h+1]]-f[q[h]][last]-sum[q[h]]<=(long long)ti[i]*(q[h+1]-q[h]))++h;\n            f[i][now]=f[q[h]][last]+(long long)ti[i]*(i-q[h])-(sum[i]-sum[q[h]]);\n            while(h<t&&(f[q[t]][last]+sum[q[t]]-f[q[t-1]][last]-sum[q[t-1]])/(double)(q[t]-q[t-1]) > (f[i][last]+sum[i]-f[q[t]][last]-sum[q[t]])/(double)(i-q[t]) )--t;\n            q[++t]=i;\n        }\n    }\n    printf(""%I64d\\n"",f[m][now]);\n    return 0;\n} \n']","['data structures', 'dp']",2400
https://codeforces.com//contest/1868/problem/B1,B1. Candy Party  Easy Version ,After Zhongkao examination Daniel and his friends are going to have a party Everyone will come with some candies There will be n people at the party Initially the i th person has a i candies During the party they will swap their candies To do this they will line up and everyone will do the following Choose an integer p 1 le p le n and a integer x then give his 2 x candies to the p th person Note that one give more candies than currently he has he might receive candies from someone else before and he give candies to himself Daniel likes fairness so he will be happy if and only if everyone receives candies from Meanwhile his friend Tom likes average so he will be happy if and only if all the people have the same number of candies after all swaps Determine whether there exists a way to swap candies so that both Daniel and Tom will be happy after the swaps ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã\x81§æ\x95°å\x88\x97ã\x82\x92ç®¡ç\x90\x86ã\x81\x99ã\x82\x8bã\x81¨ã\x81\x8dã\x81«ä½¿ã\x81\x86 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ã\x81\x97ã\x81¦ã\x81ªã\x81\x84ã\x82\x84\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã\x82½ã\x83¼ã\x83\x88ã\x81\x97ã\x81¦ i ç\x95ªç\x9b®ã\x81\x8c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾\x8bã\x81\x88ã\x81° sortidx ã\x81§å¾\x97ã\x81\x9f idx ã\x82\x92ä½¿ã\x81\x88ã\x81°å\x8d\x98ã\x81«ã\x82½ã\x83¼ã\x83\x88å\x88\x97ã\x81«ã\x81ªã\x81£ã\x81¦è¿\x94ã\x81£ã\x81¦ã\x81\x8fã\x82\x8b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\npi calc(int d){\n\tint a=botbit(d);\n\td+=1<<a;\n\tif(ispow2(d))return pi(botbit(d),a);\n\telse return pi(-1,-1);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tint s=SUM(a);\n\tif(s%n){\n\t\treturn No(0);\n\t}\n\tint tar=s/n;\n\t\n\tconst int L=35;\n\tvi ls[L][2];\n\tvi arb;\n\trep(i,n){\n\t\tif(a[i]<tar){\n\t\t\tauto [x,y]=calc(tar-a[i]);\n\t\t\tif(x==-1)return No(0);\n\t\t\tls[x][0].pb(i);\n\t\t\tls[y][1].pb(i);\n\t\t}else if(a[i]>tar){\n\t\t\tauto [x,y]=calc(a[i]-tar);\n\t\t\tif(x==-1)return No(0);\n\t\t\tls[y][0].pb(i);\n\t\t\tls[x][1].pb(i);\n\t\t}else{\n\t\t\tarb.pb(i);\n\t\t}\n\t}\n\t\n\trep(k,L)if(si(ls[k][0])!=si(ls[k][1]))return No(0);\n\t\n\tYes(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['bitmasks', 'constructive algorithms', 'graphs', 'greedy', 'implementation', 'math']",1700
https://codeforces.com//contest/1334/problem/A,A. Level Statistics,Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online Now players from all over the world can try his level All levels in this game have two stats to them the number of plays and the number of clears So when a player attempts the level the number of plays increases by 1 If he manages to finish the level successfully then the number of clears increases by 1 as well so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears Polycarp is very excited about his level so he keeps peeking at the stats to know how hard his level turns out to be So he peeked at the stats n times and wrote down n pairs of integers p 1 c 1 p 2 c 2 dots p n c n where p i is the number of plays at the i th moment of time and c i is the number of clears at the same moment of time i e the order of given pairs is exactly the same as Polycarp has written down Between two consecutive moments of time Polycarp peeked at the stats many players but possibly zero could attempt the level Finally Polycarp wonders if he hasn t messed up any records and all the pairs are correct If there could exist such a sequence of plays and clears respectively that the stats were exactly as Polycarp has written down then he considers his records correct Help him to check the correctness of his records For your convenience you have to answer multiple independent test cases ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint _,n,p[N],c[N];\nbool check() {\n\tint pp=0,cc=0;\n\trep(i,0,n) {\n\t\tif (p[i]<pp) return 0;\n\t\tint x=c[i]-cc;\n\t\tif (x<0||x>p[i]-pp) return 0;\n\t\tcc=c[i]; pp=p[i];\n\t}\n\treturn 1;\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d"",&n);\n\t\trep(i,0,n) {\n\t\t\tscanf(""%d%d"",p+i,c+i);\n\t\t}\n\t\tputs(check()?""YES"":""NO"");\n\t}\n}\n']","['implementation', 'math']",1200
https://codeforces.com//contest/815/problem/A,A. Karen and Game,On the way to school Karen became fixated on the puzzle game on her phone The game is played as follows In each level you have a grid with rows and columns Each cell originally contains the number One move consists of choosing one row or column and adding to all of the cells in that row or column To win the level after all the moves the number in the cell at the th row and th column should be equal to Karen is stuck on one level and wants to know a way to beat this level using the minimum number of moves Please help her with this task ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=107;\nconst int inf=1e6;\n\nint n, m;\n\nint tab[nax][nax];\n\nvector < pair <int,int> > wek;\n\nvoid check()\n{\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tif (tab[i][j])\n\t\t\t{\n\t\t\t\tprintf(""-1\\n"");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tscanf(""%d"", &tab[i][j]);\n\t\t\t\n\tint naj=inf;\n\tfor (int i=1; i<=m; i++)\n\t\tnaj=min(naj, tab[1][i]);\n\t\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\twhile(tab[1][i]!=naj)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\ttab[j][i]--;\n\t\t\twek.push_back({0, i});\n\t\t}\n\t}\n\tnaj=inf;\n\tfor (int i=1; i<=n; i++)\n\t\tnaj=min(naj, tab[i][1]);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twhile(tab[i][1]!=naj)\n\t\t{\n\t\t\tfor (int j=1; j<=m; j++)\n\t\t\t\ttab[i][j]--;\n\t\t\twek.push_back({1, i});\n\t\t}\n\t}\n\t\n\tnaj=tab[1][1];\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\ttab[i][j]-=naj;\n\t\n\tif (n<m)\n\t{\n\t\tfor (int i=1; i<=n; i++)\t\n\t\t\tfor (int j=1; j<=naj; j++)\n\t\t\t\twek.push_back({1, i});\n\t}\n\telse\n\t{\n\t\tfor (int i=1; i<=m; i++)\t\n\t\t\tfor (int j=1; j<=naj; j++)\n\t\t\t\twek.push_back({0, i});\n\t}\n\t\n\tcheck();\n\tprintf(""%d\\n"", (int)wek.size());\n\tfor (auto i : wek)\n\t{\n\t\tif (i.first)\n\t\t\tprintf(""row "");\n\t\telse\n\t\t\tprintf(""col "");\n\t\tprintf(""%d\\n"", i.second);\n\t}\n\t\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation']",1700
https://codeforces.com//contest/1517/problem/C,C. Fillomino 2,Fillomino is a classic logic puzzle You do not need to know Fillomino in order to solve this problem In one classroom in Yunqi town some volunteers are playing a board game variant of it Consider an n by n chessboard Its rows are numbered from 1 to n from the top to the bottom Its columns are numbered from 1 to n from the left to the right A cell on an intersection of x th row and y th column is denoted x y The main diagonal of the chessboard is cells x x for all 1 le x le n A permutation of 1 2 3 dots n is written on the main diagonal of the chessboard There is exactly one number written on each of the cells The problem is to partition the cells under and on the main diagonal there are exactly 1 2 ldots n such cells into n connected regions satisfying the following constraints Every region should be connected That means that we can move from any cell of a region to any other cell of the same region visiting only cells of the same region and moving from a cell to an adjacent cell The x th region should contain cell on the main diagonal with number x for all 1 le x le n The number of cells that belong to the x th region should be equal to x for all 1 le x le n Each cell under and on the main diagonal should belong to exactly one region ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint main() {\n\tsetIO();\n\tints(N);\n\tvi P(N); re(P);\n\tV<vi> ans(N,vi(N));\n\tF0R(i,N) ans[i][i] = P[i];\n\tdbg(""HA"",ans);\n\tF0R(diag,N-1) {\n\t\tpi nex{diag+1,0};\n\t\tF0R(i,N-diag) {\n\t\t\tif (ans[diag+i][i] == 1) continue;\n\t\t\t// dbg(""WUT"",nex,mp(i,diag+i));\n\t\t\tans[nex.f][nex.s] = ans[diag+i][i]-1;\n\t\t\t++nex.f,++nex.s;\n\t\t}\n\t}\n\tF0R(i,N) {\n\t\tF0R(j,i+1) {\n\t\t\tpr(ans[i][j]+i-j,\' \');\n\t\t}\n\t\tps();\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['constructive algorithms', 'dfs and similar', 'greedy', 'implementation']",1400
https://codeforces.com//contest/1517/problem/A,A. Sum of 2050,A number is called if it is 2050 20500 2050 cdot 10 k for integer k ge 0 Given a number n you are asked to represent n as the sum of some not necessarily distinct 2050 numbers Compute the minimum number of 2050 numbers required for that ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tll N; re(N);\n\tif (N%2050 != 0) {\n\t\tps(-1);\n\t\treturn;\n\t}\n\tN /= 2050;\n\tll ans = 0;\n\twhile (N) {\n\t\tans += N%10;\n\t\tN /= 10;\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['greedy', 'math']",800
https://codeforces.com//contest/1715/problem/D,D. 2+ doors,The Narrator has an integer array a of length n but he will only tell you the size n and q statements each of them being three integers i j x which means that a i mid a j x where denotes the bitwise OR operation Find the lexicographically smallest array a that satisfies all the statements An array a is lexicographically smaller than an array b of the same length if and only if the following holds in the first position where a and b differ the array a has a smaller element than the corresponding element in b ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(""%d"",&x);\n\treturn x;\n}\nconst int N=2e5+5;\nint n,q;\nint lst[N],to[N],nxt[N],len[N],ec;\ninline void ae(int x,int y,int z){\n\tto[++ec]=y,nxt[ec]=lst[x],len[ec]=z,lst[x]=ec;\t\n}\nint mark[N];\nint ans[N];\nvoid solve(int k){\n\tfill(mark+1,mark+n+1,-1);\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\tint y=to[i];\n\t\t\tif((len[i]&1<<k)==0)mark[x]=mark[y]=0;\t\n\t\t}\n\t}\n\tfor(int x=1;x<=n;x++){\n\t\tif(mark[x]==1)continue;\n\t\tbool flag=1;\n\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\tif((len[i]&1<<k)==0)continue;\n\t\t\tint y=to[i];\n\t\t\tif(mark[y]==0)flag=0;\n\t\t}\n\t\tif(!flag)mark[x]=1;\n\t\telse{\n\t\t\tmark[x]=0;\n\t\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\t\tif((len[i]&1<<k)==0)continue;\n\t\t\t\tint y=to[i];\n\t\t\t\tmark[y]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)if(mark[i])ans[i]|=1<<k;\n}\nint main(){\n\tn=in(),q=in();\n\twhile(q--){\n\t\tint x=in(),y=in(),z=in();\n\t\tif(x>y)swap(x,y);\n\t\tae(x,y,z);\t\n\t}\n\tfor(int i=0;i<30;i++)solve(i);\n\tfor(int i=1;i<=n;i++)printf(""%d "",ans[i]);\n\treturn 0;\n}\n']","['2-sat', 'bitmasks', 'graphs', 'greedy']",1900
https://codeforces.com//contest/66/problem/E,E. Petya and Post,Little Vasya s uncle is a postman The post offices are located on one circular road Besides each post office has its own gas station located next to it Petya s uncle works as follows in the morning he should leave the house and go to some post office In the office he receives a portion of letters and a car Then he must drive in the given car exactly one round along the circular road and return to the starting post office the uncle can drive along the circle in any direction counterclockwise or clockwise Besides since the car belongs to the city post it should also be fuelled with gasoline only at the Post Office stations The total number of stations equals to One can fuel the car at the th station with no more than liters of gasoline Besides one can fuel the car no more than once at each station Also the distance between the st and the nd station is kilometers the distance between the nd and the rd one is kilometers between the th and the th ones the distance is kilometers and between the th and the st one the distance is kilometers Petya s uncle s high tech car uses only one liter of gasoline per kilometer It is known that the stations are located so that the sum of all is equal to the sum of all The th gas station and th post office are very close so the distance between them is kilometers Thus it becomes clear that if we start from some post offices then it is not always possible to drive one round along a circular road The uncle faces the following problem to what stations can he go in the morning to be able to ride exactly one circle along the circular road and visit all the post offices that are on it Petya who used to attend programming classes has volunteered to help his uncle but his knowledge turned out to be not enough so he asks you to help him write the program that will solve the posed problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""e""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nint N, a[100005], b[100005], good[100005];\n\nlong long s[200005];\n\nset <pair <long long, int> > st;\n\nvoid Load ()\n{\n    scanf (""%d"", &N);\n\n    for (int i = 0;i < N;i++)\n        scanf (""%d"", &a[i]);\n    for (int i = 0;i < N;i++)\n        scanf (""%d"", &b[i]);\n}\n\nvoid go (bool rev)\n{\n    st.clear();\n    s[0] = a[0] - b[0];\n    for (int i = 1;i < 2 * N;i++)\n        s[i] = s[i - 1] + a[i%N] - b[i%N];\n\n    for (int i = 0;i < N;i++)\n        st.insert (make_pair (s[i], i));\n\n    for (int i = 0;i < N;i++)\n    {\n        int cur = (*st.begin()).second;\n        if (s[cur] - (i > 0 ? s[i - 1] : 0) >= 0)\n            good[rev ? N - (i % N) - 1 : (i % N)] = 1;\n\n        st.erase (make_pair (s[i], i));\n        st.insert (make_pair (s[i + N], i + N));\n    }\n}\n\nvoid Solve ()\n{\n    go (0);\n    reverse (a, a + N);\n    reverse (b, b + N);\n    int t = b[0];\n    for (int i = 0;i < N - 1;i++)\n        b[i] = b[i + 1];\n    b[N - 1] = t;\n    go (1);\n\n    int ans = 0;\n    for (int i = 0;i < N;i++)\n        if (good[i]) ans++;\n    cout << ans << endl;\n\n    for (int i = 0;i < N;i++)\n        if (good[i]) printf (""%d "", i + 1);\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","['data structures', 'dp']",2000
https://codeforces.com//contest/467/problem/C,C. George and Job,The new ITone 6 has been released recently and George got really keen to buy it Unfortunately he didn t have enough money so George was going to work as a programmer Now he faced the following problem at the work Given a sequence of integers You are to choose pairs of integers in such a way that the value of sum is maximal possible Help George to cope with the task ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define Rep(i, a, b) for (int i(a); i <= (b); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 1000000000000000000;\n\nint N, M, K, P[5033];\nLL dp[5033][5033], sum[5033];\n\nvoid solve() {\n\tscanf(""%d %d %d"", &N, &M, &K);\n\tRep(i, 1, N) scanf(""%d"", P + i);\n\n\tsum[0] = 0;\n\tRep(i, 1, N) sum[i] = sum[i - 1] + P[i];\n\n\tRep(i, 0, N) Rep(j, 0, K) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tRep(i, 1, N) Rep(j, 0, K) {\n\t\tLL &res = dp[i][j] = dp[i - 1][j];\n\t\tif (i >= M && j >= 1)\n\t\t\tres = max(res, dp[i - M][j - 1] + sum[i] - sum[i - M]);\n\t\tif (res < 0) res = -INF;\n\t}\n\tcout << dp[N][K] << endl;\n}\n\nint main() {\n\tsolve();\n\treturn 0;\n}\n']","['dp', 'implementation']",1700
https://codeforces.com//contest/489/problem/E,E. Hiking,A traveler is planning a water hike along the river He noted the suitable rest points for the night and wrote out their distances from the starting point Each of these locations is further characterized by its so for the th rest point the distance from the start equals and its equals The traveler will move down the river in one direction we can assume that he will start from point on the coordinate axis and rest points are points with coordinates Every day the traveler wants to cover the distance In practice it turns out that this is not always possible because he needs to end each day at one of the resting points In addition the traveler is choosing between two desires cover distance every day and visit the most picturesque places Let s assume that if the traveler covers distance in a day then he feels frustration and his total frustration over the hike is calculated as the total frustration on all days Help him plan the route so as to minimize the the total frustration divided by the total picturesqueness of all the rest points he used The traveler s path must end in the farthest rest point ,"['#include<cstdio>\n#include<utility>\n#include<cstring>\n#include<stack>\n#include<cmath>\nusing namespace std;\nconst int MAX = 1000 + 10;\nconst double INF = 200000000.0;\nlong long x[MAX], y[MAX], l;\ndouble dp[MAX];\nint last[MAX];\nint n;\nbool check(double t){\n\tmemset(last, -1, sizeof(last));\n\tdp[0] = 0.0;\n\tfor(int i = 1 ; i <= n ; i++) dp[i] = INF;\n\tfor(int j = 1 ; j <= n ; j++)\n\t\tfor(int i = 0 ; i < j ; i++){\n\t\t\tdouble tmp = dp[i] + sqrt(double(abs(x[j]-x[i]-l)))-y[j]*t;\n\t\t\tif(tmp < dp[j]) dp[j] = tmp, last[j] = i;\n\t\t}\n\treturn dp[n] <= 0.0;\n}\nint main(){\n\tscanf(""%d %I64d"", &n, &l);\n\tfor(int i = 1 ; i <= n ; i++){\n\t\tscanf(""%I64d %I64d"", &x[i], &y[i]);\n\t}\n\tdouble l = 0, r = INF;\n\tint cnt = 50;\n\twhile(cnt--){\n\t\tdouble mid = (l+r)/2;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\tcheck((l+r)/2);\n\tstack<int> s;\n\tint now = n;\n\twhile(now!=-1){\n\t\ts.push(now);\n\t\tnow = last[now];\n\t}\n\tif(s.top() == 0) s.pop();\n\tbool flag = false;\n\twhile(!s.empty()){\n\t\tif(flag) putchar(\' \');\n\t\telse flag = true;\n\t\tprintf(""%d"", s.top());\n\t\ts.pop();\n\t}\n\tputs("""");\n\treturn 0;\n}\n']","['binary search', 'dp']",2300
https://codeforces.com//contest/1851/problem/F,F. Lisa and the Martians,Lisa was kidnapped by martians It okay because she has watched a lot of TV shows about aliens so she knows what awaits her Let s call integer if it is and 2 k for example when k 12 the numbers 51 1960 0 are and the numbers pi 1 frac 21 8 4096 are not The aliens will give Lisa n numbers a 1 a 2 ldots a n Then they will ask her to name any number x After that Lisa will select a pair of numbers a i a j i neq j in the given sequence and count a i oplus x a j oplus x The operation oplus means Bitwise exclusive OR the operation means Bitwise And For example 5 oplus 17 23 oplus 17 00101 2 oplus 10001 2 10111 2 oplus 10001 2 10100 2 00110 2 00100 2 4 Lisa is sure that the higher the calculated value the higher her chances of returning home Help the girl choose such i j x that maximize the calculated value ,"['#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(""Ofast"",""inline"",""-ffast-math"")\n#pragma GCC target(""avx,sse2,sse3,sse4,mmx"")\n\n#define int long long\n\nconst int MOD=998244353;\nint n,k;pair<int,int> answer,pt;\npair<int,int> a[200001];\nint get_(int x,int y) {\n   for(int i=0;i<k;++i)\n      if((x>>i)%2==0&&(y>>i)%2==0)\n         x+=(1<<i);\n      else if((x>>i)%2==1&&(y>>i)%2==1) x-=(1<<i);\n   return x;\n}\nvoid Delta() {\n   cin >> n >> k;\n   for(int i=1;i<=n;++i) {\n      cin >> a[i].first;\n      a[i].second=i;\n   }\n   sort(a+1,a+1+n);\n   int mn=2147483647;\n   for(int i=1,v;i<n;++i) {\n      v=a[i].first^a[i+1].first;\n      if(v<mn) {\n         answer={a[i].second,a[i+1].second};\n         pt={a[i].first,a[i+1].first};\n         mn=v;\n      }\n   }\n   cout << answer.first << \' \' << answer.second << \' \' << get_(pt.first,pt.second) << endl;\n}\nsigned main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);cout.tie(0);\n   int T;cin >> T;\n   while(T--) Delta();\n}']","['bitmasks', 'greedy', 'math', 'strings', 'trees']",1800
https://codeforces.com//contest/1186/problem/C,C. Vus the Cossack and Strings,Vus the Cossack has two binary strings that is strings that consist only of and We call these strings a and b It is known that b leq a that is the length of b is at most the length of a The Cossack considers every substring of length b in string a Let s call this substring c He matches the corresponding characters in b and c after which he counts the number of positions where the two strings are different We call this function f b c For example let b 00110 and c 11000 In these strings the first second third and fourth positions are different Vus the Cossack counts the number of such substrings c such that f b c is For example let a 01100010 and b 00110 a has four substrings of the length b 01100 11000 10001 00010 f 00110 01100 2 f 00110 11000 4 f 00110 10001 4 f 00110 00010 1 Since in three substrings f b c is even the answer is 3 Vus can not find the answer for big strings That is why he is asking you to help him ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=1000005;\n\nint n,m;\nchar a[MAXN],b[MAXN];\nint sa[MAXN],sb[MAXN];\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    //freopen(""code.in"",""r"",stdin);\n    //freopen(""code.out"",""w"",stdout);\n    #endif\n    scanf(""%s%s"",a+1,b+1);\n    n=strlen(a+1);m=strlen(b+1);\n    for(int i=1;i<=n;i++)sa[i]=(a[i]-\'0\')^sa[i-1];\n    for(int i=1;i<=m;i++)sb[i]=(b[i]-\'0\')^sb[i-1];\n    int ans=0;\n    for(int i=m;i<=n;i++)\n    \tif(!(sb[m]^sa[i]^sa[i-m]))++ans;\n    cout<<ans<<endl;\n    return 0;\n}\n']","['implementation', 'math']",1800
https://codeforces.com//contest/1444/problem/D,D. Rectangular Polyline,One drew a closed polyline on a plane that consisted only of vertical and horizontal segments parallel to the coordinate axes The segments alternated between horizontal and vertical ones a horizontal segment was always followed by a vertical one and vice versa The polyline did not contain strict self intersections which means that in case any two segments shared a common point that point was an endpoint for both of them please consult the examples in the notes section Unfortunately the polyline was erased and you only know the lengths of the horizonal and vertical segments Please construct any polyline matching the description with such segments or determine that it does not exist ,"['#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << ""("" << a.first << "", "" << a.second << "")""; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << "" ""; cerr << endl; }\ntemplate <class T> bool chmin(T &t, const T &f) { if (t > f) { t = f; return true; } return false; }\ntemplate <class T> bool chmax(T &t, const T &f) { if (t < f) { t = f; return true; } return false; }\n\nconstexpr int MAX_N = 1010;\nconstexpr int MAX_M = 1000 * 1000 / 2 / 2 + 10;\n\nint N[2];\nint A[2][MAX_N];\n\nbitset<MAX_M> dp[MAX_N];\nvector<pair<int, int>> ans;\n\nbool solve() {\n  if (N[0] != N[1]) {\n    return false;\n  }\n  \n  int ls[2] = {};\n  vector<int> bsss[2][2];\n  for (int h = 0; h < 2; ++h) {\n    for (int i = 0; i < N[h]; ++i) {\n      ls[h] += A[h][i];\n    }\n    if (ls[h] % 2 != 0) {\n      return false;\n    }\n    ls[h] /= 2;\n    for (int i = 0; i <= N[h]; ++i) {\n      dp[i].reset();\n    }\n    dp[0][0] = true;\n    for (int i = 0; i < N[h]; ++i) {\n      dp[i + 1] = dp[i] | dp[i] << A[h][i];\n    }\n    if (!dp[N[h]][ls[h]]) {\n      return false;\n    }\n    int l = ls[h];\n    for (int i = N[h]; i--; ) {\n      if (dp[i][l]) {\n        bsss[h][0].push_back(A[h][i]);\n      } else {\n        bsss[h][1].push_back(A[h][i]);\n        l -= A[h][i];\n        assert(dp[i][l]);\n      }\n    }\n    assert(l == 0);\n// for(int s=0;s<2;++s){cerr<<h<<"" ""<<s<<"": "";pv(bsss[h][s].begin(),bsss[h][s].end());}\n  }\n  \n  \n  if (bsss[0][0].size() > bsss[0][1].size()) {\n    swap(bsss[0][0], bsss[0][1]);\n  }\n  if (bsss[1][0].size() < bsss[1][1].size()) {\n    swap(bsss[1][0], bsss[1][1]);\n  }\n  assert(bsss[0][0].size() <= bsss[1][0].size());\n  assert(bsss[0][1].size() >= bsss[1][1].size());\n  for (int s = 0; s < 2; ++s) {\n    sort(bsss[0][s].begin(), bsss[0][s].end(), greater<int>());\n    sort(bsss[1][s].begin(), bsss[1][s].end());\n  }\n  ans.clear();\n  int xs[2] = {};\n  for (int j = 0; j < N[0]; ++j) {\n    for (int h = 0; h < 2; ++h) {\n      ans.emplace_back(xs[0], xs[1]);\n      if (j < (int)bsss[h][0].size()) {\n        xs[h] += bsss[h][0][j];\n      } else {\n        xs[h] -= bsss[h][1][j - (int)bsss[h][0].size()];\n      }\n    }\n  }\n  assert(xs[0] == 0);\n  assert(xs[1] == 0);\n// cerr<<""ans = "";pv(ans.begin(),ans.end());\n  \n  /*\n  set<pair<int, int>> ss;\n  for (const auto &p : ans) {\n    if (!ss.insert(p).second) {\n      return false;\n    }\n  }\n  */\n  return true;\n}\n\nint main() {\n  int numCases;\n  for (; ~scanf(""%d"", &numCases); ) {\n    for (int caseId = 0; caseId < numCases; ++caseId) {\n      for (int h = 0; h < 2; ++h) {\n        scanf(""%d"", &N[h]);\n        for (int i = 0; i < N[h]; ++i) {\n          scanf(""%d"", &A[h][i]);\n        }\n      }\n      \n      const bool res = solve();\n      if (res) {\n        puts(""Yes"");\n        for (const auto &p : ans) {\n          printf(""%d %d\\n"", p.first, p.second);\n        }\n      } else {\n        puts(""No"");\n      }\n    }\n  }\n  return 0;\n}\n']","['constructive algorithms', 'dp', 'geometry']",2900
https://codeforces.com//contest/166/problem/A,A. Rank List,Another programming contest is over You got hold of the contest s final results table The table has the following data For each team we are shown two numbers the number of problems and the total penalty time However for no team we are shown its final place You know the rules of comparing the results of two given teams very well Let s say that team solved problems with total penalty time and team solved problems with total penalty time Team gets a higher place than team in the end if it either solved more problems on the contest or solved the same number of problems but in less total time In other words team gets a higher place than team in the final results table if either or and It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places More formally let s say there is a group of teams that solved the same number of problems with the same penalty time Let s also say that teams performed better than the teams from this group In this case all teams from the group share places The teams that performed worse than the teams from this group get their places in the results table starting from the th place Your task is to count what number of teams from the given list shared the th place ,"['#pragma comment(linker, ""/stack:64000000"")\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <utility>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <memory.h>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <deque>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <map>\n#include <deque>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define for1(i, n) for (int i = 1; i <= int(n); i++)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb push_back\n#define pii pair <int, int>\n#define vi vector <int>\n#define mp make_pair\n\ntemplate <typename X> inline X abs (const X &a) {return a < 0? -a: a;}\ntemplate <typename X> inline X sqr (const X &a) {return a * a;}\n\nconst int INF = INT_MAX / 2;\nconst ll INF64 = LLONG_MAX / 2LL;\nconst ld EPS = 1E-9, PI = 3.1415926535897932384626433832795;\n\nconst int N = 50 + 13;\n\ninline bool cmp (const pii &a, const pii &b)\n{\n    if (a.first != b.first)\n        return a.first > b.first;\n\n    return a.second < b.second;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n\n    int n, m;\n    pii a[N];\n    \n    cin >> n >> m;\n\n    forn (i, n)\n        scanf (""%d%d"", &a[i].first, &a[i].second);\n\n    sort (a, a + n, cmp);\n    m--;\n\n    int cnt = 0;\n\n    forn (i, n)\n        if (a[i] == a[m])\n            cnt++;\n\n    cout << cnt << endl;\n\n    return 0;\n}']","['binary search', 'implementation', 'sortings']",1100
https://codeforces.com//contest/742/problem/B,B. Arpa’s obvious problem and Mehrdad’s terrible solution,Once Arpa came up with an obvious problem Given an array and a number count the number of pairs of indices such that where is bitwise operation see notes for explanation Immediately Mehrdad discovered a terrible solution that nobody trusted Now Arpa needs your help to implement the solution to that problem ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\nconst int MAX = 1e6 + 10;\nconst int MOD = 1e9 + 7;\n\n//#define acm_local\nint ar[MAX];\nint main()\n{\n\n\n#ifdef acm_local\n    freopen(""data.in"", ""r"", stdin);\n    return 0;\n#else\n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n\n    int n; cin >> n;\n    int x; cin >> x;\n    unordered_map<int, int> M;\n    for(int i = 0; i < n; i++){\n        cin >> ar[i];\n        M[ar[i]]++;\n    }\n    i64 ans = 0;\n    for(int i = 0; i < n; i++){\n        int a = x ^ ar[i];\n        if(a == ar[i])ans += M[ar[i]] - 1;\n        else ans += M[a];\n    }\n    cout << ans / 2 << endl;\n\n\n\n\n\n}\n\n\n']","['brute force', 'math', 'number theory']",1500
https://codeforces.com//contest/1006/problem/C,C. Three Parts of the Array,You are given an array d 1 d 2 dots d n consisting of n integer numbers Your task is to split this array into three parts some of which may be empty in such a way that each element of the array belongs to exactly one of the three parts and each of the parts forms a consecutive contiguous subsegment possibly empty of the original array Let the sum of elements of the first part be sum 1 the sum of elements of the second part be sum 2 and the sum of elements of the third part be sum 3 Among all possible ways to split the array you have to choose a way such that sum 1 sum 3 and sum 1 is maximum possible More formally if the first part of the array contains a elements the second part of the array contains b elements and the third part contains c elements then sum 1 sum limits 1 le i le a d i sum 2 sum limits a 1 le i le a b d i sum 3 sum limits a b 1 le i le a b c d i The sum of an empty array is 0 Your task is to find a way to split the array such that sum 1 sum 3 and sum 1 is maximum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5;\n\nint n;\nint a[MAX_N + 1];\nlong long pref[MAX_N + 1], suff[MAX_N + 1];\n\nint main() {\n\t//freopen(""input.inp"", ""r"", stdin);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t\tpref[i] = pref[i - 1] + a[i];\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tsuff[i] = suff[i + 1] + a[i];\n\t}\n\tlong long ans = 0;\n\t//for (int i = 1; i <= n; ++i) {\n\t//\tfor (int j = i + 1; j <= n; ++j) {\n\t//\t\tif (suff[j] == pref[i]) {\n\t//\t\t\tans = max(ans, pref[i]);\n\t//\t\t\tbreak;\n\t//\t\t}\n\t//\t}\n\t//}\n\tmap<long long, int> hs;\n\tfor (int i = n; i >= 1; --i) {\n\t\tif (hs.count(pref[i])) {\n\t\t\tans = pref[i];\n\t\t\tbreak;\n\t\t}\n\t\ths[suff[i]]++;\n\t}\n\tcout << ans;\n\treturn 0;\n}']","['binary search', 'data structures', 'two pointers']",1200
https://codeforces.com//contest/901/problem/B,B. GCD of Polynomials,Suppose you have two polynomials and Then polynomial can be uniquely represented in the following way This can be done using long division Here denotes the degree of polynomial is called the remainder of division of polynomial by polynomial it is also denoted as Since there is a way to divide polynomials with remainder we can define Euclid s algorithm of finding the greatest common divisor of two polynomials The algorithm takes two polynomials If the polynomial is zero the result is otherwise the result is the value the algorithm returns for pair On each step the degree of the second argument decreases so the algorithm works in finite number of steps But how large that number could be You are to answer this question You are given an integer You have to build two polynomials with degrees not greater than such that their coefficients are integers not exceeding by their absolute value the leading coefficients ones with the greatest power of are equal to one and the described Euclid s algorithm performs exactly steps finding their greatest common divisor Moreover the degree of the first polynomial should be greater than the degree of the second By a step of the algorithm we mean the transition from pair to pair ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <int> Vl[155];\nint main() {\n\tVl[0].push_back(1);\n\tVl[1].push_back(0);\n\tVl[1].push_back(1);\n\n\tint i, j;\n\tfor (i = 2; i <= 150; i++) {\n\t\tVl[i].push_back(0);\n\t\tfor (auto it : Vl[i - 1]) Vl[i].push_back(it);\n\n\t\tfor (j = 0; j < Vl[i - 2].size(); j++) Vl[i][j] += Vl[i - 2][j];\n\t\tfor (j = 0; j < Vl[i].size(); j++) if (abs(Vl[i][j]) >= 2) break;\n\t\tif (j >= Vl[i].size()) continue;\n\t\tfor (j = 0; j < Vl[i - 2].size(); j++) Vl[i][j] -= 2 * Vl[i - 2][j];\n\t\tfor (j = 0; j < Vl[i].size(); j++) if (abs(Vl[i][j]) >= 2) break;\n\t\tif (j >= Vl[i].size()) continue;\n\t}\n\n\tint N;\n\tscanf(""%d"", &N);\n\tprintf(""%d\\n"", Vl[N].size()-1);\n\tfor (auto it : Vl[N]) printf(""%d "", it);\n\tprintf(""\\n"");\n\tprintf(""%d\\n"", Vl[N - 1].size()-1);\n\tfor (auto it : Vl[N - 1]) printf(""%d "", it);\n\tprintf(""\\n"");\n\treturn 0;\n}']","['constructive algorithms', 'math']",2200
https://codeforces.com//contest/406/problem/E,E. Hamming Triples,Little Chris is having a nightmare Even in dreams all he thinks about is math Chris dreams about binary strings of length indexed with numbers from 1 to The most horrifying part is that the bits of each string are ordered in either ascending or descending order For example Chris could be dreaming about the following 4 strings of length 5 The between two strings and of length is the number of positions at which the corresponding symbols are different hris thinks that each three strings with different indices constitute a single triple Chris s delusion is that he will wake up only if he counts the number of such string triples that the sum is maximal among all the string triples constructed from the dreamed strings Help Chris wake up from this nightmare ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA ""sequence""\n\nlng doit(const vector<lng> &A,const vector<lng> &B){\n\tvector<lng> v;\n\tv.pb(0);\n\tforv(i,A){\n\t\tv.pb(v.back()+(upper_bound(all(B),A[i])-B.begin()));\n\t}\n\tlng res=0;\n\tforv(i,B){\n\t\tres+=v[upper_bound(all(A),B[i])-A.begin()];\n\t\tif(!i || B[i-1]!=B[i]){\n\t\t\tlng a=upper_bound(all(A),B[i])-lower_bound(all(A),B[i]);\n\t\t\tlng b=upper_bound(all(B),B[i])-B.begin()-i;\n\t\t\tres-=a*b*b;\n\t\t\tres+=b*(b-1)/2*a;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n\t//freopen(TASKA"".in"", ""r"", stdin); freopen(TASKA"".out"", ""w"", stdout);\n#endif\n\t\n\tlng L;\n\tint n;\n\tcin>>L>>n;\n\tvector<lng> A,B;\n\tforn(i,n){\n\t\tint s,x;\n\t\tscanf(""%d%d"",&s,&x);\n\t\tif(s)\n\t\t\tB.pb(x);\n\t\telse\n\t\t\tA.pb(x);\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\t\n\tif(!sz(A))\n\t\tswap(A,B);\n\tif(!sz(B)){\n\t\tif(A[0]==A.back()){\n\t\t\tcout<<1LL*sz(A)*(sz(A)-1)*(sz(A)-2)/6;\n\t\t\treturn 0;\n\t\t}\n\t\tlng c1=A.end()-lower_bound(all(A),A.back());\n\t\tlng c2=upper_bound(all(A),A.front())-A.begin();\n\t\tlng res=c1*c2*(sz(A)-c1-c2);\n\t\tres+=c1*(c1-1)/2*c2;\n\t\tres+=c2*(c2-1)/2*c1;\n\t\tcout<<res;\n\t\treturn 0;\n\t}\n\t\n\tif(A[0]>B[0])\n\t\tswap(A,B);\n\t\n\tif(A.back()<B.front()){\n\t\tlng c1=A.end()-lower_bound(all(A),A.back());\n\t\tlng c2=upper_bound(all(B),B.front())-B.begin();\n\t\tlng res =c1*(c2*(c2-1)/2+c2*(sz(B)-c2));\n\t\t    res+=c2*(c1*(c1-1)/2+c1*(sz(A)-c1));\n\t\tcout<<res;\n\t\treturn 0;\n\t}\n\t\n\tcout<<doit(A,B)+doit(B,A);\n\t\n\treturn 0;\n}\n']","['implementation', 'math', 'two pointers']",2800
https://codeforces.com//contest/1749/problem/B,B. Death's Blessing,You are playing a computer game To pass the current level you have to kill a big horde of monsters In this horde there are n monsters standing in the row numbered from 1 to n The i th monster has a i health and a special Death s Blessing spell of strength b i attached to it You are going to kill all of them It takes exactly h seconds to kill a monster with health h When the i th monster dies it casts its spell that increases the health of its by b i the neighbors of the j th monster in the row are the monsters on places j 1 and j 1 The first and the last monsters have only one neighbor each After each monster is killed the row shrinks so its former neighbors become adjacent to each other so if one of them dies the other one is affected by its spell For example imagine a situation with 4 monsters with health a 2 6 7 3 and spells b 3 6 0 5 One of the ways to get rid of the monsters is shown below 2673 xrightarrow 6 s 8133 xrightarrow 13 s 83 xrightarrow 8 s 6 xrightarrow 6 s 3605305355 As a result we can kill all monsters in 6 13 8 6 33 seconds Note that it s only an example and may not be the fastest way to get rid of the monsters What is the minimum time required to kill all monsters in the row ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll t;cin>>t;\n  while(t--){\n    ll n;cin>>n;\n    vector<ll>a(n),b(n);\n    rep(i,0,n)cin>>a[i];\n    rep(i,0,n)cin>>b[i];\n    cout<<acc(b)+acc(a)-max(b)<<endl;\n\n  }\n  return 0;\n}']",['greedy'],900
https://codeforces.com//contest/1846/problem/F,F. Rudolph and Mimic,Rudolph is a scientist who studies alien life forms There is a room in front of Rudolph with n different objects scattered around Among the objects there is amazing creature a mimic that can turn into any object He has already disguised himself in this room and Rudolph needs to find him by experiment The experiment takes place in several stages At each stage the following happens Rudolf looks at all the objects in the room and writes down their types The type of each object is indicated by a number there can be several objects of the same type After inspecting Rudolph can point to an object that he thinks is a mimic After that the experiment ends Rudolph only has one try so if he is unsure of the mimic s position he does the next step instead Rudolf can remove any number of objects from the room possibly zero Then Rudolf leaves the room and at this time all objects including the mimic with each other their order is changed and the into any other object even one that is not in the room After this Rudolf returns to the room and repeats the stage The but it can not remain a same object for more than two stages in a row Rudolf s task is to detect mimic in no more than stages ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid solve()\n{\n\n    int n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int &i: a) \n    cin >> i;\n\tmap<int, int> mpa, mpb;\n\tfor (int i: a)\n\t mpa[i]++;\n\tcout << ""- 0"" << ""\\n"";\n\tfflush(stdout);\n\tvector<int> b(n), c;\n\tfor (int &i: b) \n\tcin >> i;\n\tc = b;\n\tfor (int i: b) \n\tmpb[i]++;\n\tif (mpa == mpb) \n\t{\n\t\tcout << ""- 0"" << ""\\n"";\n\t\tfflush(stdout);\n\t\tfor (int &i: b) \n\t\tcin >> i;\n\t\tc = b;\n\t\tmpb.clear();\n\t\tfor (int i: b) \n\t\tmpb[i]++;\n\t}\n\tint t = -1;\n\tfor (auto &pr: mpb) \n\t{\n\t\tif (pr.second > mpa[pr.first]) \n\t\t{\n\t\t    t = pr.first;\n    break;\n    }\n\t}\n\tvector<int> rem;\n\ta = c;\n\tfor (int i=0;i<n;    ++i)\n        {\n\t\tif (a[i] != t) \n\t\t{\n\t\t\trem.push_back(i + 1);\n\t\t}\n\t}\n\tcout << ""- "" << rem.size();\n\tfor (int i: rem) \n\tcout << "" "" << i;\n\tcout << ""\\n"";\n\tfflush(stdout);\n\tb = vector<int>(n - (int)rem.size());\n\tfor (int &i: b) \n\tcin >> i;\n\tfor (int i=0;     i<b.size();      ++i)\n\t{\n\t\tif (b[i] != t) \n\t\t{\n\t\t\tcout << ""! "" << i + 1 << ""\\n"";\n\t\t\tfflush(stdout);\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << ""- 0"" << ""\\n"";\n\tfflush(stdout);\n\tfor (int &i: b) cin >> i;\n\tfor (int i=0;i<b.size();++i) {\n\t\tif (b[i] != t) {\n\t\t\tcout << ""! "" << i + 1 << ""\\n"";\n\t\t\tfflush(stdout);\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << ""- 0"" << ""\\n"";\n\tfflush(stdout);\n\tfor (int &i: b) \n\tcin >> i;\n\tfor (int i=0; i<b.size(); ++i) {\n\t\tif (b[i] != t) {\n\t\t\tcout << ""! "" << i + 1 << ""\\n"";\n\t\t\tfflush(stdout);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n']","['constructive algorithms', 'implementation', 'interactive']",1800
https://codeforces.com//contest/1899/problem/C,C. Yarik and Array,A is a continuous part of array Yarik recently found an array a of n elements and became very interested in finding the maximum sum of a subarray However Yarik doesn t like consecutive integers with the same parity so the subarray he chooses must have alternating parities for adjacent elements For example 1 2 3 is acceptable but 1 2 4 is not as 2 and 4 are both even and adjacent You need to help Yarik by finding the maximum sum of such a subarray ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int t;\n        cin >> t;\n        while (t--) {\n                int n;\n                cin >> n;\n                vector<int> a(n);\n                for (int i = 0; i < n; i++) cin >> a[i];\n                vector<int64_t> f(n);\n                f[0] = a[0];\n                for (int i = 1; i < n; i++) {\n                        if ((a[i] + a[i - 1]) & 1) {\n                                f[i] = max<int64_t>(a[i], f[i - 1] + a[i]);\n                        } else {\n                                f[i] = a[i];\n                        }\n                }\n                cout << *max_element(f.begin(), f.end()) << '\\n';\n        }\n}""]","['dp', 'greedy', 'two pointers']",1100
https://codeforces.com//contest/1622/problem/A,A. Construct a Rectangle,There are three sticks with integer lengths l 1 l 2 and l 3 You are asked to break exactly one of them into two pieces in such a way that both pieces have positive strictly greater than 0 length the total length of the pieces is equal to the original length of the stick it s possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides A square is also considered a rectangle Determine if it s possible to do that ,"['/**\n *    author:  tourist\n *    created: 27.12.2021 17:34:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (a == b + c || b == c + a || c == a + b) {\n      cout << ""YES"" << \'\\n\';\n    } else {\n      if ((a == b && c % 2 == 0) || (a == c && b % 2 == 0) || (b == c && a % 2 == 0)) {\n        cout << ""YES"" << \'\\n\';\n      } else {\n        cout << ""NO"" << \'\\n\';\n      }\n    }\n  }\n  return 0;\n}\n']","['geometry', 'math']",800
https://codeforces.com//contest/204/problem/E,E. Little Elephant and Strings,The Little Elephant loves strings very much He has an array from strings consisting of lowercase English letters Let s number the elements of the array from 1 to then let s denote the element number as For each string the Little Elephant wants to find the number of pairs of integers and such that substring is a substring to at least strings from array including the th string Help the Little Elephant solve this problem If you are not familiar with the basic notation in string problems you can find the corresponding definitions in the notes ,"['#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <iterator>\n#include <functional>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\n\n// SA from http://www.prefield.com/algorithm/string/suffix_array.html\n\nstruct SaComp {\n\tconst int sp, *sr, srlen;\n\tSaComp(int sp, const vector<int>& sr) : sp(sp), sr(&sr[0]), srlen(sr.size()) {}\n\tbool operator()(int a, int b) const\n\t  { return make_pair(sr[a], a+sp<srlen?sr[a+sp]:0x7fffffff)\n\t         < make_pair(sr[b], b+sp<srlen?sr[b+sp]:0x7fffffff); }\n};\n\ntemplate<typename RanIt>\nvector<int> compute_suffix_array(RanIt beg, RanIt end)\n{\n\tconst int N = end - beg;\n\n\tvector<int> sa(N);\n\tvector<int> sort_rank(beg, end);\n\tfor(int i=0; i<N; ++i)\n\t\tsa[i] = i;\n\n\tsort(sa.begin(), sa.end(), SaComp(0, sort_rank));\n\tfor(int sorted_prefix=1; sorted_prefix<N; sorted_prefix*=2)\n\t{\n\t\tSaComp cmp(sorted_prefix, sort_rank);\n\t\tsort(sa.begin(), sa.end(), cmp);\n\n\t\tvector<int> block_id(N);\n\t\tfor(int i=1; i<N; ++i)\n\t\t\tblock_id[i] = block_id[i-1] + (cmp(sa[i-1], sa[i]) ? 1 : 0);\n\t\tfor(int i=0; i<N; ++i)\n\t\t\tsort_rank[sa[i]] = block_id[i];\n\t}\n\treturn sa;\n}\n\nvector<int> inv_sa(const vector<int>& sa)\n{\n\tvector<int> isa(sa.size());\n\tfor(int i=0; i<sa.size(); ++i)\n\t\tisa[sa[i]] = i;\n\treturn isa;\n}\n\ntemplate<typename RanIte>\nvector<int> longest_common_prefix(RanIte beg, RanIte end, const vector<int>& sa)\n{\n\tconst int N = sa.size();\n\tvector<int> lcp(N);\n\tvector<int> inv = inv_sa(sa);\n\n\tint len = 0;\n\tfor(int i=0; i<N; ++i) {\n\t\tint sa_idx = inv[i];\n\t\tif( sa_idx == 0 )\n\t\t\tlcp[sa_idx] = -1;\n\t\telse {\n\t\t\tfor(int k=sa[sa_idx-1]; i+len<N && k+len<N && *(beg+i+len)==*(beg+k+len);)\n\t\t\t\t++len;\n\t\t\tlcp[sa_idx] = len;\n\t\t}\n\t\tif(len) --len;\n\t}\n\treturn lcp;\n}\n\ntemplate<typename T>\nstruct RMQ\n{\n\tvector< vector<int> > rm;\n\tvector<T> d;\n\n\tRMQ( const vector<T>& d ) : d(d) {\n\t\tint n = d.size();\n\n\t\t// rm[k][x] = i s.t. d[i] is the minimum in [x, x+2^k)\n\t\trm.push_back( vector<int>(n) );\n\t\tfor(int x=0; x<n; ++x)\n\t\t\trm[0][x] = x;\n\t\tfor(int k=1; (1<<k)<=n; ++k) {\n\t\t\trm.push_back( rm[k-1] );\n\t\t\tfor(int x=0; x+(1<<k-1)<n; ++x)\n\t\t\t\tif( d[rm[k][x]] > d[rm[k-1][x + (1<<k-1)]] )\n\t\t\t\t\trm[k][x] = rm[k-1][x + (1<<k-1)];\n\t\t}\n\t}\n\n\t// min {i in [L,R] | d[i] is minumum among d[L..R]}\n\tint operator()(int L, int R) const {\n\t\tint k=0;\n\t\tfor(; L+(1<<k) < R-(1<<k)+1; ++k) {}\n\t\tint i = rm[k][L];\n\t\tint j = rm[k][R-(1<<k)+1];\n\t\treturn (d[i]<=d[j] ? i : j);\n\t}\n\n\t// {i in [L,R] | d[i] is minumum among d[L..R]}\n\tvector<int> all(int L, int R) const {\n\t\tvector<int> ans;\n\t\tint minValue = d[(*this)(L, R)];\n\t\twhile( L <= R ) {\n\t\t\tint C = (*this)(L, R);\n\t\t\tif( minValue < d[C] )\n\t\t\t\tbreak;\n\t\t\tans.push_back(C);\n\t\t\tL = C+1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// max {i in [L,R] | d[i]<X}, or -1\n\tint rightmost_less_than_X(int L, int R, T X) const {\n\t\tif(L>R) return -1;\n\n\t\tint k=0;\n\t\tfor(; L+(1<<k) < R-(1<<k)+1; ++k) {}\n\n\t\tint i = rm[k][L];\n\t\tint j = rm[k][R-(1<<k)+1];\n\t\tif( !(d[i]<X || d[j]<X) )\n\t\t\treturn -1;\n\t\tif( d[j] < X )\n\t\t\tL = R-(1<<k)+1;\n\n\t\tfor(; k; --k) { // Answer is in [L, L+(1<<k))\n\t\t\ti = rm[k-1][L];\n\t\t\tj = rm[k-1][L+(1<<k-1)];\n\t\t\tif( d[j] < X )\n\t\t\t\tL += 1<<k-1;\n\t\t}\n\t\treturn L;\n\t}\n\n\t// min {i in [L,R] | d[i]<X}, or -1\n\tint leftmost_less_than_X(int L, int R, T X) const {\n\t\tif(L>R) return -1;\n\n\t\tint k=0;\n\t\tfor(; L+(1<<k) < R-(1<<k)+1; ++k) {}\n\n\t\tint i = rm[k][L];\n\t\tint j = rm[k][R-(1<<k)+1];\n\t\tif( !(d[i]<X || d[j]<X) )\n\t\t\treturn -1;\n\t\tif( !(d[i] < X) )\n\t\t\tL = R-(1<<k)+1;\n\n\t\tfor(; k; --k) { // Answer is in [L, L+(1<<k))\n\t\t\ti = rm[k-1][L];\n\t\t\tj = rm[k-1][L+(1<<k-1)];\n\t\t\tif( !(d[i] < X) )\n\t\t\t\tL += 1<<k-1;\n\t\t}\n\t\treturn L;\n\t}\n};\n\nvoid solve(const vector<string>& SS, int K)\n{\n\tstring S;\n\tvector<int> sep;\n\tfor(int i=0; i<SS.size(); ++i) {\n\t\tif(i) S += \'$\';\n\t\tS += SS[i];\n\t\tsep.push_back(S.size());\n\t}\n\n\tint sa_end = S.size();\n\tvector<int> sa = compute_suffix_array(S.begin(), S.end());\n\tvector<int> lcp = longest_common_prefix(S.begin(), S.end(), sa);\n\tint sa_start = 0;\n\twhile(S[sa[sa_start]]<\'A\')\n\t\t++sa_start;\n\n\tvector<int> blk_of(sa_end, -1);\n\tfor(int i=sa_start; i<sa_end; ++i) {\n\t\tint blk = lower_bound(sep.begin(), sep.end(), sa[i]) - sep.begin();\n\t\tblk_of[i] = blk;\n\t}\n\n\tvector<int> first_index_of_K_diff_blocks(sa_end, 0x7fffffff);\n\tmap<int,int> blk_set;\n\tfor(int i=sa_start,k=sa_start; i<sa_end; ++i) {\n\t\tfor(; blk_set.size()<K && k<sa_end; ++k)\n\t\t\tblk_set[blk_of[k]]++;\n\t\tif( blk_set.size() == K )\n\t\t\tfirst_index_of_K_diff_blocks[i] = k-1;\n\t\tif( --blk_set[blk_of[i]] == 0 )\n\t\t\tblk_set.erase(blk_of[i]);\n\t}\n\n\n\n\tRMQ<int> rmq( vector<int>(lcp.begin(), lcp.end()) );\n\n\tvector<LL> total(SS.size());\n\tfor(int s=sa_start; s<sa_end; ++s)\n\t{\n\t\tint len_L=1, len_R=sep[blk_of[s]] - sa[s];\n\t\tint possible_len = 0;\n\t\twhile( len_L <= len_R )\n\t\t{\n\t\t\tint len_C = (len_L+len_R) / 2;\n\n\t\t\tint l = rmq.rightmost_less_than_X(sa_start, s, len_C);\n\t\t\tif(l==-1) l=sa_start;\n\t\t\tint r = rmq.leftmost_less_than_X(s+1, sa_end-1, len_C);\n\t\t\tif(r==-1) r=sa_end-1; else r--;\n\n\t\t\t// [l,r] has same prefix of length >= len_C as s\n\t\t\tif( first_index_of_K_diff_blocks[l] <= r ) {\n\t\t\t\tpossible_len = len_C;\n\t\t\t\tlen_L = len_C + 1;\n\t\t\t} else\n\t\t\t\tlen_R = len_C - 1;\n\t\t}\n\t\ttotal[blk_of[s]] += possible_len;\n\t}\n\n\tfor(int i=0; i<total.size(); ++i)\n\t\tcout << (i?"" "":"""") << total[i];\n\tcout<<endl;\n}\n\nint main()\n{\n\tfor(int N,K; cin>>N>>K; )\n\t{\n\t\tvector<string> SS(N);\n\t\tfor(int i=0; i<SS.size(); ++i)\n\t\t\tcin >> SS[i];\n\t\tsolve(SS, K);\n\t}\n}\n']","['data structures', 'implementation', 'string suffix structures', 'two pointers']",2800
https://codeforces.com//contest/337/problem/B,B. Routine Problem,Manao has a monitor The screen of the monitor has horizontal to vertical length ratio Now he is going to watch a movie The movie s frame has horizontal to vertical length ratio Manao adjusts the view in such a way that the movie preserves the original frame ratio but also occupies as much space on the screen as possible and fits within it completely Thus he may have to zoom the movie in or out but Manao will always change the frame proportionally in both dimensions Calculate the ratio of empty screen the part of the screen not occupied by the movie to the total screen size Print the answer as an irreducible fraction ,"['#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define db double\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m,a,b,c,d,A,B;\nint main() {\n    scanf(""%d%d%d%d"",&a,&b,&c,&d);\n    if (b*c<=d*a) A=a*d-b*c,B=a*c,A*=c,B*=d;\n    else A=b*c-a*d,B=b*d,A*=d,B*=c;\n    if (!A) printf(""0/1\\n"");\n    else k=__gcd(A,B),printf(""%d/%d\\n"",A/k,B/k);\n    return 0;\n}']","['greedy', 'math', 'number theory']",1400
https://codeforces.com//contest/377/problem/D,D. Developing Game,Pavel is going to make a game of his dream However he knows that he can t make it on his own so he founded a development company and hired workers of staff Now he wants to pick workers from the staff who will be directly responsible for developing a game Each worker has a certain skill level Besides each worker doesn t want to work with the one whose skill is very different In other words the th worker won t work with those whose skill is less than and with those whose skill is more than Pavel understands that the game of his dream isn t too hard to develop so the worker with any skill will be equally useful That s why he wants to pick a team of the maximum possible size Help him pick such team ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nconst int co = 300000;\nconst int TREE = 10 * co + 10;\n\nint max[TREE], add[TREE], index[TREE];\n\nvoid build(int x, int l, int r) {\n  max[x] = add[x] = 0;\n  index[x] = l;\n  if (l < r) {\n    int y = (l + r) >> 1;\n    build(x + x, l, y);\n    build(x + x + 1, y + 1, r);\n  }\n}\n\nvoid modify(int x, int l, int r, int ll, int rr, int v) {\n  if (r < ll || rr < l) return;\n  if (l >= ll && r <= rr) {\n    add[x] += v;\n    return;\n  }\n  int y = (l + r) >> 1;\n  modify(x + x, l, y, ll, rr, v);\n  modify(x + x + 1, y + 1, r, ll, rr, v);\n  int wl = max[x + x] + add[x + x];\n  int wr = max[x + x + 1] + add[x + x + 1];\n  if (wl > wr) {\n    max[x] = wl;\n    index[x] = index[x + x];\n  } else {\n    max[x] = wr;\n    index[x] = index[x + x + 1];\n  }\n}\n\nconst int N = 100010;\n\nint low[N], v[N], high[N];\nint r[N];\n\nstd::vector <int> left[co + 10], skill[co + 10];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 1; i <= n; i++) scanf(""%d %d %d"", low + i, v + i, high + i);\n  for (int i = 1; i <= co; i++) {\n    left[i].clear();\n    skill[i].clear();\n  }\n  for (int i = 1; i <= n; i++) {\n    left[low[i]].push_back(i);\n    skill[v[i]].push_back(i);\n  }\n  build(1, 1, co);\n  int ans = 0, a_from = 0, a_to = 0;\n  for (int from = 1; from <= co; from++) {\n    {\n      int sz = left[from].size();\n      for (int j = 0; j < sz; j++) {\n        int id = left[from][j];\n        modify(1, 1, co, v[id], high[id], 1);\n      }\n    }\n    int cur = max[1] + add[1];\n    if (cur > ans) {\n      ans = cur;\n      a_from = from;\n      a_to = index[1];\n    }\n    {\n      int sz = skill[from].size();\n      for (int j = 0; j < sz; j++) {\n        int id = skill[from][j];\n        modify(1, 1, co, v[id], high[id], -1);\n      }\n    }\n  }\n  int kr = 0;\n  for (int i = 1; i <= n; i++)\n    if (low[i] <= a_from && a_from <= v[i] && v[i] <= a_to && a_to <= high[i]) {\n      r[++kr] = i;\n    }\n  printf(""%d\\n"", kr);\n  for (int i = 1; i < kr; i++) printf(""%d "", r[i]);\n  printf(""%d\\n"", r[kr]);\n  return 0;\n}\n']",['data structures'],2400
https://codeforces.com//contest/1656/problem/C,C. Make Equal With Mod,You are given an array of n non negative integers a 1 a 2 ldots a n You can make the following operation choose an integer x geq 2 and replace each number of the array by the remainder when dividing that number by x that is for all 1 leq i leq n set a i to a i bmod x Determine if it is possible to make all the elements of the array equal by applying the operation zero or more times ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::sort(a.begin(), a.end());\n    bool bad = false;\n    for (int i = 0; i < n - 1; i++) {\n        if (a[i] + 1 == a[i + 1]) {\n            bad = true;\n        }\n    }\n    \n    if (std::count(a.begin(), a.end(), 1) && bad) {\n        std::cout << ""NO\\n"";\n    } else {\n        std::cout << ""YES\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'math', 'number theory', 'sortings']",1200
https://codeforces.com//contest/1851/problem/G,G. Vlad and the Mountains,Vlad decided to go on a trip to the mountains He plans to move between n mountains some of which are connected by roads The i th mountain has a height of h i If there is a road between mountains i and j Vlad can move from mountain i to mountain j by spending h j h i units of energy If his energy drops below zero during the transition he will not be able to move from mountain i to mountain j Note that h j h i can be negative and then the energy will be restored Vlad wants to consider different route options so he asks you to answer the following queries is it possible to construct some route starting at mountain a and ending at mountain b given that he initially has e units of energy ,"['#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(""Ofast"",""inline"",""-ffast-math"")\n#pragma GCC target(""avx,sse2,sse3,sse4,mmx"")\n\n#define int long long\n\nconst int MOD=998244353;\nvector<int> Q[200001];\nint n,m,q,a[200001],fa[200001],ans[200001];\nint getfa(int x){if(fa[x]==x) return x;return fa[x]=getfa(fa[x]);}\nvoid merge(int x,int y){fa[getfa(x)]=getfa(y);}\nvoid Delta() {\n   cin >> n >> m;\n   for(int i=1;i<=n;++i) {\n      cin >> a[i];\n      fa[i]=i;Q[i].clear();\n   }\n   for(int i=1,u,v;i<=m;++i) {\n      cin >> u >> v;\n      Q[u].push_back(v);\n      Q[v].push_back(u);\n   }\n   vector<array<int,4>> P;cin >> q;\n   for(int i=1,u,v,e;i<=q;++i) {\n      cin >> u >> v >> e;\n      P.push_back({a[u]+e,u,v,i});\n   }\n   for(int i=1;i<=n;++i)\n      P.push_back({a[i],-2147483648,i,-1});\n   sort(P.begin(),P.end());\n   for(array<int,4> i:P) {\n      if(i[3]==-1)\n         for(int j:Q[i[2]]) {\n            if(a[j]<=a[i[2]])\n               merge(i[2],j);\n         }\n      else\n         ans[i[3]]=getfa(i[1])==getfa(i[2]);\n   }\n   for(int i=1;i<=q;++i)\n      if(ans[i]) cout << ""YES\\n"";\n      else cout << ""NO\\n"";\n   cout << ""\\n"";\n}\nsigned main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);cout.tie(0);\n   int T;cin >> T;\n   while(T--) Delta();\n}']","['binary search', 'data structures', 'dsu', 'graphs', 'implementation', 'sortings', 'trees', 'two pointers']",2000
https://codeforces.com//contest/1166/problem/B,B. All the Vowels Please,Tom loves vowels and he likes long words with many vowels His favorite words are vowelly words We say a word of length k is vowelly if there are positive integers n and m such that n cdot m k and when the word is written by using n rows and m columns the first row is filled first then the second and so on with each row filled from left to right every vowel of the English alphabet appears at least once in every row and every column You are given an integer k and you must either print a vowelly word of length k or print 1 if no such word exists In this problem the vowels of the English alphabet are ,"['#pragma GCC optimize(""Ofast"")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define y0 holdtheflower\n#define y1 enjoythecolorandscent\n#define yn walkthroughthesoulgarden\n#define j1 feelthewarmbreathofkindnessandsalvation\n\n#define endl \'\\n\'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint k;\nstring vowel = ""aeiou"";\n\nvoid Input() {\n\tcin >> k;\n}\n\nvoid Solve() {\n\tfor (int i=5; i<=sqrt(k); i++) {\n\t\tif (k % i != 0) continue;\n\t\tint j = k / i;\n\t\tvector<vector<char>> Mat(i, vector<char>(j, \'t\'));\n\t\tfor (int x=0; x<i; x++) {\n\t\t\tfor (int y=0; y<j; y++) {\n\t\t\t\tMat[(x+y) % i][y] = vowel[x % 5];\n\t\t\t}\n\t\t}\n\t\tfor (int x=0; x<i; x++) {\n\t\t\tfor (int y=0; y<j; y++) {\n\t\t\t\tcout << Mat[x][y];\n\t\t\t}\n\t\t}\n\t\tcout << endl; return;\n\t}\n\tcout << ""-1\\n"";\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}\n\n/******************************************\\\n *  Thuy-Trang Tran, #Team4T\'s Leader     *\n *  #Team4T Primary Flagship - Salvation  *\n\\******************************************/']","['constructive algorithms', 'math', 'number theory']",1100
https://codeforces.com//contest/1868/problem/D,D. Flower-like Pseudotree,A is a connected graph which has cycle and self loops Note that a pseudotree It can be shown that a pseudotree with n vertices always contains n edges After deleting all edges on the cycle in the pseudotree a forest dagger will be formed It can be shown that each tree in the forest will contain exactly one vertex which is on cycle before removing the edges If all trees in the forest have the same depth ddagger when picking the vertex on cycle as root we call the original pseudotree Our friend sszcdjr had a flower like pseudotree with n vertices and n edges However he forgot all the edges in the pseudotree Fortunately he still remembers the degrees of vertices Specifically the degree of the i th vertex is d i You have to help sszcdjr construct a possible flower like pseudotree with n vertices where the degree of the i th vertex is d i or tell him that it is impossible dagger A forest is a graph in which all connectivity components are trees A connected graph without cycles and self loops is called a tree ddagger The depth of a tree with a root is the maximum distance from the root to the vertex of this tree ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã\x81§æ\x95°å\x88\x97ã\x82\x92ç®¡ç\x90\x86ã\x81\x99ã\x82\x8bã\x81¨ã\x81\x8dã\x81«ä½¿ã\x81\x86 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ã\x81\x97ã\x81¦ã\x81ªã\x81\x84ã\x82\x84\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã\x82½ã\x83¼ã\x83\x88ã\x81\x97ã\x81¦ i ç\x95ªç\x9b®ã\x81\x8c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾\x8bã\x81\x88ã\x81° sortidx ã\x81§å¾\x97ã\x81\x9f idx ã\x82\x92ä½¿ã\x81\x88ã\x81°å\x8d\x98ã\x81«ã\x82½ã\x83¼ã\x83\x88å\x88\x97ã\x81«ã\x81ªã\x81£ã\x81¦è¿\x94ã\x81£ã\x81¦ã\x81\x8fã\x82\x8b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;\n\tif(dbg){\n\t\tn=10;\n\t}else{\n\t\tcin>>n;\n\t}\n\tvi d;\n\tif(dbg){\n\t\td=vi(n,1);\n\t\trep(_,n){\n\t\t\td[rand_int(n)]++;\n\t\t}\n\t}else{\n\t\td=readvi(n);\n\t}\n\tif(SUM(d)!=2*n||MAX(d)>n)return No(0);\n\tvi idx=sortidx(d);\n\tif(count(all(d),2)==n){\n\t\tYes(0);\n\t\trep(i,n){\n\t\t\tprint(i+1,(i+1)%n+1);\n\t\t}\n\t}else{\n\t\tint leaves=count(all(d),1);\n\t\tint head=0;\n\t\tvi q;\n\t\trep(i,leaves)q.pb(0);\n\t\trng(cut,leaves,n-1){\n\t\t\tint inner=cut-leaves;\n\t\t\tint len=inner/(n-cut);\n\t\t\tif(d[idx[cut]]>=3&&q.back()<=len){\n\t\t\t\t//dmp(cut);\n\t\t\t\tvc<pi> ans;\n\t\t\t\tauto ae=[&](int i,int j){\n\t\t\t\t\t//dmp2(i,j);\n\t\t\t\t\tassert(d[i]>0);\n\t\t\t\t\tassert(d[j]>0);\n\t\t\t\t\tans.eb(i,j);\n\t\t\t\t\td[i]--;\n\t\t\t\t\td[j]--;\n\t\t\t\t};\n\t\t\t\trng(i,cut,n){\n\t\t\t\t\tint j=i+1;\n\t\t\t\t\tif(j==n)j=cut;\n\t\t\t\t\tae(idx[i],idx[j]);\n\t\t\t\t}\n\t\t\t\tint s=0;\n\t\t\t\thead=0;\n\t\t\t\tvi root(n,-1),dep(n,-1),tail(n,-1),mx(n,-1),avail;\n\t\t\t\trng(i,cut,n){\n\t\t\t\t\tint v=idx[i];\n\t\t\t\t\troot[v]=v;\n\t\t\t\t\tdep[v]=0;\n\t\t\t\t\ttail[v]=v;\n\t\t\t\t\tmx[v]=0;\n\t\t\t\t\trep(_,d[v])avail.eb(v);\n\t\t\t\t}\n\t\t\t\tgnr(i,leaves,cut+1){\n\t\t\t\t\tif(s+(i-leaves)==len*(n-cut)){\n\t\t\t\t\t\t//dmp(i);\n\t\t\t\t\t\t//dmp(d);\n\t\t\t\t\t\t//dmp(mx);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint k=i;\n\t\t\t\t\t\t\trng(j,cut,n){\n\t\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\t\tint tar=len-mx[v];\n\t\t\t\t\t\t\t\tv=tail[v];\n\t\t\t\t\t\t\t\trep(_,tar){\n\t\t\t\t\t\t\t\t\tassert(d[v]>=1);\n\t\t\t\t\t\t\t\t\tint u=idx[--k];\n\t\t\t\t\t\t\t\t\tae(u,v);\n\t\t\t\t\t\t\t\t\tv=u;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tavail.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(j,leaves,n){\n\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\trep(_,d[v])avail.pb(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(j,leaves){\n\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\tassert(si(avail));\n\t\t\t\t\t\t\tae(v,gpp(avail));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(avail.empty());\n\t\t\t\t\t\tassert(si(ans)==n);\n\t\t\t\t\t\tYes(0);\n\t\t\t\t\t\tfor(auto [a,b]:ans){\n\t\t\t\t\t\t\tprint(a+1,b+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tassert(i>leaves);\n\t\t\t\t\tint v=idx[i-1];\n\t\t\t\t\tint u=avail[head++];\n\t\t\t\t\tae(u,v);\n\t\t\t\t\troot[v]=root[u];\n\t\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\t\ttail[root[v]]=v;\n\t\t\t\t\tassert(inc(0,dep[v]-mx[root[v]],1));\n\t\t\t\t\tif(chmax(mx[root[v]],dep[v])){\n\t\t\t\t\t\ts++;\n\t\t\t\t\t}\n\t\t\t\t\trep(_,d[v])avail.pb(v);\n\t\t\t\t}\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tint v=d[idx[cut]]-1;\n\t\t\thead+=v;\n\t\t\tassert(head<=si(q));\n\t\t\tq.pb(q[head-1]+1);\n\t\t}\n\t\tNo(0);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['constructive algorithms', 'graphs', 'greedy', 'implementation', 'trees']",3000
https://codeforces.com//contest/1846/problem/C,C. Rudolf and the Another Competition,Rudolf has registered for a programming competition that will follow the rules of ICPC The rules imply that for each solved problem a participant gets 1 point and also incurs a penalty equal to the number of minutes passed from the beginning of the competition to the moment of solving the problem In the final table the participant with the most points is ranked higher and in case of a tie in points the participant with the lower penalty is ranked higher In total n participants have registered for the competition Rudolf is a participant with index 1 It is known that m problems will be proposed And the competition will last h minutes A powerful artificial intelligence has predicted the values t i j which represent the number of minutes it will take for the i th participant to solve the j th problem Rudolf realized that the order of solving problems will affect the final result For example if h 120 and the times to solve problems are 20 15 110 then if Rudolf solves the problems in the order 3 1 2 then he will only solve the third problem and get 1 point and 110 penalty 1 2 3 then he will solve the first problem after 20 minutes from the start the second one after 20 15 35 minutes and he will not have time to solve the third one Thus he will get 2 points and 20 35 55 penalty 2 1 3 then he will solve the second problem after 15 minutes from the start the first one after 15 20 35 minutes and he will not have time to solve the third one Thus he will get 2 points and 15 35 50 penalty Rudolf became interested in what place he will take in the competition if each participant solves problems in the optimal order based on the predictions of the artificial intelligence It will be assumed that in case of a tie in points and penalty Rudolf will take the best place ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nvoid solve()\n{\n   int n, m, h;\n\tcin >> n >> m >> h;\n\tvector<long long> p(n), pen(n);\n\tint position = 1;\n\tfor (int i=0;i<n;++i) {\n\t\tvector<int> t(m);\n\t\tfor (int &j: t)\n            cin >> j;\n\t\tsort(t.begin(), t.end());\n\t\tint s = 0;\n\t\tfor (int j: t) {\n\t\t\tif (s + j > h) \n\t\t\tbreak;\n\t\t\ts += j;\n\t\t\tp[i]++;\n\t\t\tpen[i] += s;\n\t\t}\n\t\tif (p[i] > p[0] || (p[i] == p[0] && pen[i] < pen[0])) \n            position++;\n\t}\n\tcout << position << ""\\n"";\n\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n']","['constructive algorithms', 'data structures', 'dp', 'greedy', 'sortings']",1200
https://codeforces.com//contest/385/problem/D,D. Bear and Floodlight,One day a bear lived on the axis He was afraid of the dark so he couldn t move at night along the plane points that aren t lit One day the bear wanted to have a night walk from his house at point to his friend s house at point along the segment of length Of course if he wants to make this walk he needs each point of the segment to be lit That s why the bear called his friend and yes in the middle of the night asking for a very delicate favor The axis contains floodlights Floodlight is at point and can light any angle of the plane as large as degree with vertex at point The bear asked his friend to turn the floodlights so that he the bear could go as far away from his house as possible during the walking along the segment His kind friend agreed to fulfill his request And while he is at it the bear wonders what is the furthest he can go away from his house Hep him and find this distance Consider that the plane has no obstacles and no other light sources besides the floodlights The bear s friend cannot turn the floodlights during the bear s walk Assume that after all the floodlights are turned in the correct direction the bear goes for a walk and his friend goes to bed ,"['#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxN = 20;\nconst double kPi = acos(-1.0);\nconst double kEps = 1E-8;\ndouble f[1 << kMaxN];\ndouble agl[kMaxN];\nint n, l, r;\n\ninline int sgn(double x) {\n    if (fabs(x) < kEps) return 0;\n    if (x > 0) return 1;\n    return -1;\n}\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x_, double y_) : x(x_), y(y_) {}\n} p[kMaxN];\n\ntypedef Point Vector;\n\nVector operator-(const Vector &a, const Vector &b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nVector rotate(const Vector &v, double agl) {\n    return Vector(v.x * cos(agl) - v.y * sin(agl),\n            v.x * sin(agl) + v.y * cos(agl));\n}\n\ndouble calcMaxDist(double from, const Point &p, double agl) {\n    if (sgn(p.y) == 0) {\n        if (sgn(from - p.x) < 0) return p.x;\n        else return 1E100;\n    }\n    else {\n        Vector a = Point(from, 0) - p;\n        if (sgn(p.y) > 0) a = rotate(a, agl);\n        else a = rotate(a, 2.0 * kPi - agl);\n        if (sgn(a.y) == 0) return 1E100;\n        if (sgn(p.y) > 0 && sgn(a.y) > 0) return 1E100;\n        if (sgn(p.y) < 0 && sgn(a.y) < 0) return 1E100;\n        if (sgn(a.x) == 0) return p.x;\n        else {\n            double k = a.y / a.x;\n            double b = p.y - p.x * k;\n            return (-b) / k;\n        }\n    }\n}\n\nint main() {\n    scanf(""%d%d%d"", &n, &l, &r);\n    for (int i = 0; i < (1 << n); ++ i) f[i] = l;\n    for (int i = 0, a; i < n; ++ i) {\n        scanf(""%lf%lf%d"", &p[i].x, &p[i].y, &a);\n        agl[i] = a / 180.0 * kPi;\n    }\n    int upper = 1 << n;\n    for (int msk = 0; msk < upper; ++ msk) {\n        int can = upper - 1 - msk;\n        while (can) {\n            double current = f[msk];\n            int q = can & -can;\n            can ^= q;\n            q = __builtin_ctz(q);\n            current = max(current, calcMaxDist(current, p[q], agl[q]));\n            current = min(current, (double)r);\n            f[msk ^ (1 << q)] = max(f[msk ^ (1 << q)], current);\n        }\n    }\n    printf(""%.8lf\\n"", f[upper - 1] - l);\n    return 0;\n}\n']","['bitmasks', 'dp', 'geometry']",2200
https://codeforces.com//contest/1660/problem/F1,F1. Promising String  easy version ,We will call a non empty string if it contains the same number of plus and minus signs For example strings and are balanced and strings and are not balanced We will call a string if the string can be made balanced by several possibly zero uses of the following operation replace two minus signs with one plus sign In particular every balanced string is promising However the converse is not true not every promising string is balanced For example the string is promising because you can replace two adjacent minuses with plus and get a balanced string or get another balanced string How many non empty substrings of the given string s are promising Each non empty promising substring must be counted in the answer as many times as it occurs in string s Recall that a substring is a sequence of consecutive characters of the string For example for string its substring are the string is a substring of itself and some others But the following strings are not its substring ,"[""#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<\n    pair<int, int>,\n    null_type,\n    less<pair<int, int>>,\n    rb_tree_tag,\n    tree_order_statistics_node_update>\n    ordered_set;\n\nint f(vector<int> a) {\n  reverse(all(a));\n  int s = 0;\n  ordered_set kek;\n  for (int i = 0; i < (int) a.size(); i++) {\n    int x = a[i];\n    s += kek.order_of_key({x + 1, -1});\n    kek.insert({x, i});\n  }\n  return s;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector<int> p = {0};\n  for (auto c : s) {\n    if (c == '-') {\n      p.pb(p.back() - 1);\n    } else {\n      p.pb(p.back() + 1);\n    }\n  }\n  vector<vector<int>> ps(3);\n  for (auto x : p) {\n    ps[(3 * n - x) % 3].pb(x);\n  }\n  int ans = 0;\n  for (int i = 0; i < 3; i++) {\n    ans += f(ps[i]);\n  }\n  cout << ans << '\\n';\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}""]","['brute force', 'implementation', 'math', 'strings']",1700
https://codeforces.com//contest/1391/problem/B,B. Fix You,Consider a conveyor belt represented using a grid consisting of n rows and m columns The cell in the i th row from the top and the j th column from the left is labelled i j Every cell except n m has a direction Right or Down assigned to it If the cell i j is assigned direction any luggage kept on that will move to the cell i j 1 Similarly if the cell i j is assigned direction any luggage kept on that will move to the cell i 1 j If at any moment the luggage moves out of the grid it is considered to be lost There is a counter at the cell n m from where all luggage is picked A conveyor belt is called if and only if any luggage reaches the counter regardless of which cell it is placed in initially More formally for every cell i j any luggage placed in this cell should eventually end up in the cell n m This may not hold initially you are however allowed to the directions of some cells to make the conveyor belt functional Please determine the minimum amount of cells you have to change Please note that it is always possible to make any conveyor belt functional by changing the directions of some set of cells ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int k_N = 100 + 3;\n\nstring s[k_N];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n\n        for(int i = 0; i < n; ++i)\n            cin >> s[i];\n    \n        int ans = 0;\n        for(int i = 0; i < n - 1; ++i)\n            ans += s[i][m - 1] != \'D\';\n\n        for(int i = 0; i < m - 1; ++i)\n            ans += s[n - 1][i] != \'R\';\n\n        cout << ans << ""\\n"";\n    }\n}']","['brute force', 'greedy', 'implementation']",800
https://codeforces.com//contest/1197/problem/D,D. Yet Another Subarray Problem,You are given an array a 1 a 2 dots a n and two integers m and k You can choose some subarray a l a l 1 dots a r 1 a r The cost of subarray a l a l 1 dots a r 1 a r is equal to sum limits i l r a i k lceil frac r l 1 m rceil where lceil x rceil is the least integer greater than or equal to x For example if m 3 k 10 and a 2 4 15 3 4 8 3 then the cost of some subarrays are a 3 dots a 3 15 k lceil frac 1 3 rceil 15 10 5 a 3 dots a 4 15 3 k lceil frac 2 3 rceil 12 10 2 a 3 dots a 5 15 3 4 k lceil frac 3 3 rceil 16 10 6 a 3 dots a 6 15 3 4 8 k lceil frac 4 3 rceil 24 20 4 a 3 dots a 7 15 3 4 8 3 k lceil frac 5 3 rceil 27 20 7 Your task is to find the maximum cost of some subarray possibly empty of array a ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)1e18;\nconst int N = 300300;\nconst int M = 10;\nll ans = 0;\nint n, m;\nll k;\nll b[M];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%lld"", &n, &m, &k);\n\tfor (int i = 0; i < m; i++)\n\t\tb[i] = INF;\n\tb[0] = 0;\n\tll bal = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tll x;\n\t\tscanf(""%lld"", &x);\n\t\tbal += x;\n\t\tb[i % m] = min(b[i % m], bal - (i / m) * k);\n\t\tfor (int r = 0; r < m; r++) {\n\t\t\tll z = bal - (i / m) * k;\n\t\t\tif (i % m > r) z -= k;\n\t\t\tans = max(ans, z - b[r]);\n\t\t}\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['dp', 'greedy', 'math']",1900
https://codeforces.com//contest/1095/problem/A,A. Repeating Cipher,Polycarp loves ciphers He has invented his own cipher called Repeating cipher is used for strings To encrypt the string s s 1 s 2 dots s m 1 le m le 10 Polycarp uses the following algorithm he writes down s 1 ones he writes down s 2 twice he writes down s 3 three times he writes down s m m times For example if s the process is to to So the encrypted s is Given string t the result of encryption of some string s Your task is to decrypt it i e find the string s ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint main(){\n\tfast_io;\n\tstring s;\n\tint n;\n\tcin>>n>>s;\n\tint curr=1;\n\tint i=0;\n\twhile(i<n){\n\t\tcout<<s[i];\n\t\ti+=curr;\n\t\tcurr++;\n\t}\t\n\tcout<<endl;\n\treturn 0;\n}']",['implementation'],800
https://codeforces.com//contest/828/problem/A,A. Restaurant Tables,In a small restaurant there are tables for one person and tables for two persons It it known that groups of people come today each consisting of one or two people If a group consist of one person it is seated at a vacant one seater table If there are none of them it is seated at a vacant two seater table If there are none of them it is seated at a two seater table occupied by single person If there are still none of them the restaurant denies service to this group If a group consist of two people it is seated at a vacant two seater table If there are none of them the restaurant denies service to this group You are given a chronological order of groups coming You are to determine the total number of people the restaurant denies service to ,"['#include<bits/stdc++.h>\nint n,a,b,c=0,ans=0;\nint main(){\n\tscanf(""%d%d%d"",&n,&a,&b);\n\tfor(int i=0,x;i<n;++i){\n\t\tscanf(""%d"",&x);\n\t\tif(x==1){\n\t\t\tif(a)--a;\n\t\t\telse if(b)--b,++c;\n\t\t\telse if(c)--c;\n\t\t\telse ++ans;\n\t\t}else{\n\t\t\tif(b)--b;\n\t\t\telse ans+=2;\n\t\t}\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']",['implementation'],1200
https://codeforces.com//contest/1594/problem/C,C. Make Them Equal,Theofanis has a string s 1 s 2 dots s n and a character c He wants to make all characters of the string equal to c using the minimum number of operations In one operation he can choose a number x 1 le x le n and where i is divisible by x replace s i with c Find the minimum number of operations required to make all the characters equal to c and the x s that he should use in his operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nint n,fla[400400]; \nchar s[300300]; \nvoid solve() {\n    scanf(""%d"",&n);\n    char c;\n    cin>>c;\n    scanf(""%s"",s+1); \n    int ok=1;  \n    for (int i=1;i<=n;i++) {\n        if (s[i]!=c) {\n            ok=0; break ; \n        }\n    }\n    if (ok) {\n        puts(""0"");\n        return ; \n    }\n    if (s[n]==c) {\n        puts(""1"");\n        printf(""%d\\n"",n);\n        return ; \n    }\n    ok=1; \n    for (int i=1;i<=n;i++) fla[i]=0; \n    for (int i=1;i<=n;i++) {\n        if (s[i]!=c) {\n            for (int j=1;j*j<=i;j++) {\n                if (i%j==0) \n                fla[j]=1,fla[i/j]=1;  \n            }\n        }\n    }\n    for (int i=1;i<=n;i++) {\n        if (!fla[i]) {\n            puts(""1"");\n            printf(""%d\\n"",i); \n            return ; \n        }\n    }\n    puts(""2"");\n    printf(""%d "",n);\n    for (int i=1;i<=n;i++) {\n        if (n%i!=0) {\n            printf(""%d\\n"",i);\n            return ; \n        }\n    }\n}\nint main() {\n    int T;\n    scanf(""%d"",&T);\n    while (T--) {\n        solve(); \n    }\n    return 0; \n}']","['brute force', 'greedy', 'math', 'strings']",1200
https://codeforces.com//contest/1497/problem/B,B. M-arrays,You are given an array a 1 a 2 ldots a n consisting of n positive integers and a positive integer m You should divide elements of this array into some arrays You can order the elements in the new arrays as you want Let s call an array m divisible if for each two adjacent numbers in the array two numbers on the positions i and i 1 are called adjacent for each i their sum is divisible by m An array of one element is m divisible Find the smallest number of m divisible arrays that a 1 a 2 ldots a n is possible to divide into ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n, m;\n        cin >> n >> m;\n        vector<ll> a(n);\n        map<ll, ll> q;\n        ll ans = 0;\n        bool k = 0;\n        for (int i = 0; i < n; ++i) {\n            ll x;\n            cin >> x;\n            x %= m;\n            if (!x) {\n                k = 1;\n                continue;\n            }\n            ++q[x];\n            ++q[m - x];\n            --q[m - x];\n        }\n        if (k) ++ans;\n        for (auto &elem : q) {\n            ll c = m - elem.fi;\n            if (elem.fi <= c) {\n                if (elem.fi == c) ans += 1;\n                else ans += max(1ll, (max(elem.se, q[c]) - min(elem.se, q[c])));\n            }\n        }\n        cout << ans << \'\\n\';\n    }\n}\n']","['constructive algorithms', 'greedy', 'math']",1200
https://codeforces.com//contest/1071/problem/B,B. Minimum path,You are given a matrix of size n times n filled with lowercase English letters You can change no more than k letters in this matrix Consider all paths from the upper left corner to the lower right corner that move from a cell to its neighboring cell to the right or down Each path is associated with the string that is formed by all the letters in the cells the path visits Thus the length of each string is 2n 1 Find the lexicographically smallest string that can be associated with a path after changing letters in at most k cells of the matrix A string a is lexicographically smaller than a string b if the first different letter in a and b is smaller in a ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=2007;\nconst int inf=1e9;\n\nint n, k;\n\nchar tab[nax][nax];\n\nint dp[nax][nax];\nvector <pii> war[nax*2];\n\nvoid zbi(int &a, int b)\n{\n\ta=min(a, b);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%s"", tab[i]+1);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tdp[i][j]=inf;\n\tdp[1][1]=0;\n\tif (k && tab[1][1]!=\'a\')\n\t{\n\t\tk--;\n\t\ttab[1][1]=\'a\';\n\t}\n\tprintf(""%c"", tab[1][1]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\twar[i+j].push_back({i, j});\n\tfor (int i=2; i<2*n; i++)\n\t{\n\t\tchar mini=\'z\';\n\t\tfor (pii j : war[i])\n\t\t{\n\t\t\tint a=j.first;\n\t\t\tint b=j.second;\n\t\t\tif (dp[a][b]<=k)\n\t\t\t{\n\t\t\t\tif (a<n)\n\t\t\t\t\tmini=min(mini, tab[a+1][b]);\n\t\t\t\tif (b<n)\n\t\t\t\t\tmini=min(mini, tab[a][b+1]);\n\t\t\t}\n\t\t\tif (dp[a][b]<k)\n\t\t\t{\n\t\t\t\tmini=\'a\';\n\t\t\t}\n\t\t}\n\t\tprintf(""%c"", mini);\n\t\tfor (pii j : war[i])\n\t\t{\n\t\t\tint a=j.first;\n\t\t\tint b=j.second;\n\t\t\tif (dp[a][b]<=k)\n\t\t\t{\n\t\t\t\tif (a<n)\n\t\t\t\t\tzbi(dp[a+1][b], dp[a][b]+(tab[a+1][b]!=mini));\n\t\t\t\tif (b<n)\n\t\t\t\t\tzbi(dp[a][b+1], dp[a][b]+(tab[a][b+1]!=mini));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","['dfs and similar', 'dp', 'greedy', 'hashing']",1900
https://codeforces.com//contest/1806/problem/A,A. Walking Master,YunQian is standing on an infinite plane with the Cartesian coordinate system on it In one move she can move to the diagonally adjacent point on the top right or the adjacent point on the left That is if she is standing on point x y she can either move to point x 1 y 1 or point x 1 y YunQian initially stands at point a b and wants to move to point c d Find the minimum number of moves she needs to make or declare that it is impossible ,"['// Problem: A. Walking Master\n// Contest: Codeforces - Codeforces Round 858 (Div. 2)\n// URL: https://codeforces.com/contest/1806/problem/A\n// Memory Limit: 1024 MB\n// Time Limit: 1000 ms\n\n#include<bits/stdc++.h>\n#define poly vector<int>\n#define IOS ios::sync_with_stdio(false)\n#define ll long long\n#define mp make_pair\n#define mt make_tuple\n#define pa pair < int,int >\n#define fi first\n#define se second\n#define inf 1e18\n#define mod 998244353\n#define int ll\n// #define N \nusing namespace std;\nvoid BellaKira()\n{\n\tint a,b,c,d;\n\tcin>>a>>b>>c>>d;\n\tint ans=0;\n\tif (c>a)\n\t{\n\t\tans+=(c-a);\n\t\tb+=(c-a);\n\t\ta=c;\n\t}\n\tif (d>b)\n\t{\n\t\tans+=(d-b);\n\t\ta+=d-b;\n\t\tb=d;\n\t}\n\tif (c<a&&d==b)\n\t{\n\t\tans+=a-c;\n\t\ta=c;\n\t}\n\tif (a!=c||b!=d) cout<<""-1\\n"";\n\telse cout<<ans<<\'\\n\';\n}\nsigned main()\n{\n\tIOS;cin.tie(0); \n\tint T=1;\n\tcin>>T;\n\twhile (T--)\n\t{\n\t\tBellaKira();\n\t}\n}\n']","['geometry', 'greedy', 'math']",800
https://codeforces.com//contest/437/problem/B,B. The Child and Set,At the children s day the child came to Picks s house and messed his house up Picks was angry at him A lot of important things were lost in particular the favorite set of Picks Fortunately Picks remembers something about his set its elements were distinct integers from to the value of was equal to here equals where is the position of the first one in the binary representation of For example binary representation Can you help Picks and find any set that satisfies all the above conditions ,"['#include <cstdio>\n#include <string>\n#include <cstdlib>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#define rep(i, a, b) for (int i = a; i < b; ++i)\n#define dep(i, a, b) for (int i = a; i > b; --i)\n#define N 200005\nusing namespace std;\n\nint init[N], cnt[N];\nint n, m, ans;\n\nint lowbit(int x)\n{\n\treturn x & -x;\n}\nbool find(int p)  {\n\tif (cnt[p])\n\t{\n\t\tcnt[p]--;\n\t\t++ans;\n\t\treturn 1;\n\t}\n\tif (p == 1) return 0;\n\tif (find(p >> 1) == 0) return 0;\n\tif (find(p >> 1) == 0) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(""%d %d"", &n, &m);\n\trep(i, 0, m)\n\t{\n\t\tint val = lowbit(i+1);\n\t\tinit[val]++;\n\t\tcnt[val]++;\n\t}\n\tfor (int i = 20; i >= 0; --i)\n\t\tif ((n >> i) & 1)\n\t\t{\n\t\t\tif (find(1 << i) == 0)\n\t\t\t{\n\t\t\t\tprintf(""-1"");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\tprintf(""%d\\n"", ans);\n\trep(i, 0, m)\n\t{\n\t\tint val = lowbit(i+1);\n\t\tif (cnt[val] != init[val])\n\t\t{\n\t\t\tprintf(""%d "", i+1);\n\t\t\tcnt[val]++;\n\t\t}\n\t}\n}\n']","['bitmasks', 'greedy', 'implementation', 'sortings']",1500
https://codeforces.com//contest/917/problem/D,D. Stranger Trees,Will shares a psychic connection with the Upside Down Monster so everything the monster knows Will knows Suddenly he started drawing page after page non stop Joyce his mom and Chief Hopper put the drawings together and they realized it s a labeled tree A tree is a connected acyclic graph Will s tree has vertices Joyce and Hopper don t know what that means so they re investigating this tree and similar trees For each such that they re going to investigate all labeled trees with vertices that share exactly edges with Will s tree Two labeled trees are different if and only if there s a pair of vertices such that there s an edge between and in one tree and not in the other one Hopper and Joyce want to know how much work they have to do so they asked you to tell them the number of labeled trees with vertices that share exactly edges with Will s tree for each The answer could be very large so they only asked you to tell them the answers modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nint n,u,v,gg[N][N];\nll f[N][N],ff[N];\nll det() {\n\tll ans=1;\n\trep(i,1,n) {\n\t\tbool fg=0;\n\t\trep(j,i,n) if (f[j][i]!=0) {\n\t\t\trep(k,i,n) swap(f[i][k],f[j][k]);\n\t\t\tif (j!=i) ans=-ans;\n\t\t\tfg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) return 0;\n\t\trep(j,i+1,n) {\n\t\t\tll tmp=-f[j][i]*powmod(f[i][i],mod-2)%mod;\n\t\t\trep(k,i,n) f[j][k]=(f[j][k]+tmp*f[i][k])%mod;\n\t\t}\n\t\t\n\t}\n\trep(i,1,n) ans=ans*f[i][i]%mod;\n\tif (ans<0) ans+=mod;\n\treturn ans;\n}\n\nll inv[N],g[N],c[N],w[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\t--u; --v;\n\t\tgg[u][v]=gg[v][u]=1;\n\t}\n\trep(x,0,n+1) {\n\t\trep(i,0,n) f[i][i]=0;\n\t\trep(i,0,n) rep(j,0,n) if (i!=j) {\n\t\t\tf[i][j]=-(gg[i][j]?x:1);\n\t\t\tf[i][i]-=f[i][j];\n\t\t}\n\t\tff[x]=det();\n\t}\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++) inv[i]=mod-(inv[mod%i]*(mod/i))%mod;\n\tg[0]=g[1]=1;\n\tfor (int i=2;i<=n;i++) g[i]=g[i-1]*inv[i]%mod;\n\tfor (int i=0;i<=n;i++) w[i]=powmod(i,n);\n\tfor (int i=n;i>=0;i--) {\n\t\tfor (int j=0;j<=i;j++) {\n\t\t\tif (j&1) {\n\t\t\t\tc[i]-=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]<0) c[i]+=mod;\n\t\t\t} else {\n\t\t\t\tc[i]+=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]>=mod) c[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tff[j]-=c[i]*w[j]%mod;\n\t\t\tif (ff[j]<0) ff[j]+=mod;\n\t\t\tw[j]=w[j]*inv[j]%mod;\n\t\t}\n\t}\n\trep(i,0,n) printf(""%lld "",c[i]); puts("""");\n}\n']","['dp', 'math', 'matrices', 'trees']",2600
https://codeforces.com//contest/1758/problem/F,F. Decent Division,A binary string is a string where every character is texttt 0 or texttt 1 Call a binary string if it has an equal number of texttt 0 s and texttt 1 s Initially you have an infinite binary string t whose characters are all texttt 0 s You are given a sequence a of n updates where a i indicates that the character at index a i will be flipped texttt 0 leftrightarrow texttt 1 You need to keep and modify after each update a set S of ranges such that for each range l r the substring t l dots t r is a decent binary string and for all indices i such that t i texttt 1 there exists l r in S such that l leq i leq r You only need to output the ranges that are added to or removed from S after each update You can only add or remove ranges from S at most mathbf 10 6 times More formally let S i be the set of ranges after the i th update where S 0 varnothing the empty set Define X i to be the set of ranges removed after update i and Y i to be the set of ranges added after update i Then for 1 leq i leq n S i S i 1 setminus X i cup Y i The following should hold for all 1 leq i leq n forall a b in S i a neq b rightarrow a cap b varnothing X i subseteq S i 1 S i 1 setminus X i cap Y i varnothing displaystyle sum i 1 n X i Y i leq 10 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc getchar()\n// #define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=1e6+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint n,m=N-1;\n#define P pair<int,int>\nset<P>mp;\nV input(){\n\tn = getint();\n}\nset<int>one,zero,alen;\nV init(){\n\tFOR(i,1,m)zero.insert(i);\n\tFOR(i,1,m)alen.insert(i);\n}\nstruct node{ // 维护历史最小值\n\tint minn, sum;\n\tnode operator+(const node&o)const{\n\t\tnode out;\n\t\tout.minn = min(minn,sum+o.minn);\n\t\tout.sum = sum+o.sum;\n\t\treturn out;\n\t}\n}t1[N<<2],t2[N<<2];\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,m\n#define lson lc,L,mid\n#define rson rc,mid+1,R\nV build(int p,int L,int R){\n\tt1[p].minn = t2[p].minn = -(R-L+1);\n\tt1[p].sum = t2[p].sum = -(R-L+1);\n\tif(L==R)return;\n\tint mid=L+R>>1;\n\tbuild(lson),build(rson);\n}\nV upd(int p){\n\tt1[p]=t1[lc]+t1[rc];\n\tt2[p]=t2[rc]+t2[lc];\n}\nV change(int p,int L,int R,int x,int w){\n\tif(L==R){\n\t\tif(w){\n\t\t\tt1[p].minn = t2[p].minn = 1;\n\t\t\tt1[p].sum = t2[p].sum = 1;\n\t\t}\n\t\telse{\n\t\t\tt1[p].minn = t2[p].minn = -1;\n\t\t\tt1[p].sum = t2[p].sum = -1;\n\t\t}\n\t\treturn;\n\t}\n\tint mid=L+R>>1;\n\tif(x<=mid)change(lson,x,w);\n\telse change(rson,x,w);\n\tupd(p);\n}\nnode ask1(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t1[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask1(rson,l,r);\n\tif(r<=mid)return ask1(lson,l,r);\n\treturn ask1(lson,l,mid)+ask1(rson,mid+1,r);\n}\nnode ask2(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t2[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask2(rson,l,r);\n\tif(r<=mid)return ask2(lson,l,r);\n\treturn ask2(rson,mid+1,r)+ask2(lson,l,mid);\n}\nV work(){\n\tint x, l, r;\n\tbuild(1,1,m);\n\twhile(n--){\n\t\tx = getint();\n\t\tif(zero.find(x)!=zero.end()){\n\t\t\tl = x, r = *alen.upper_bound(x); // 找一个不被管辖的 0\n\t\t\t// alen.erase(x);\n\t\t\tif(alen.find(x)!=alen.end())\n\t\t\t\talen.erase(x);\n\t\t\telse{\n\t\t\t\talen.erase(r);\n\t\t\t\tr = *alen.upper_bound(x);\n\t\t\t}\n\t\t\talen.erase(r);\n\t\t\tauto it = mp.upper_bound(P(x+1,0));\n\t\t\tif(it != mp.begin()){\n\t\t\t\tauto tmp = it;\n\t\t\t\ttmp --;\n\t\t\t\tif(tmp->first<=x && tmp->second >=x)\n\t\t\t\t\tit --;\n\t\t\t}\n\t\t\tif(it != mp.end()) cmin(l,it->first);\n\t\t\tauto itl = it;\n\t\t\tint cnt = 0;\n\t\t\twhile(it != mp.end() && it->second<=r){\n\t\t\t\tcmax(r, it->second);\n\t\t\t\tit ++, cnt ++;\n\t\t\t}\n\t\t\tauto itr = it;\n\t\t\tcout<<cnt<<\'\\n\';\n\t\t\tfor(it = itl;it!=itr;it++){\n\t\t\t\tcout<<it->first<<\' \'<<it->second<<\'\\n\';\n\t\t\t}\n\t\t\tmp.erase(itl, itr);\n\t\t\tmp.insert(P(l,r));\n\t\t\tcout<<1<<\'\\n\';\n\t\t\tcout<<l<<\' \'<<r<<\'\\n\';\n\t\t\t// auto v = *--mp.lower_bound()\n\t\t\tzero.erase(x);\n\t\t\tone.insert(x);\n\t\t\tchange(root,x,1);\n\t\t}\n\t\telse{\n\t\t\tauto it = --mp.upper_bound(P(x+1,0));\n\t\t\tchange(root,x,0);\n\t\t\tcout<<1<<\'\\n\';\n\t\t\tint l = it->first,r = it->second;\n\t\t\tcout<<l<<\' \'<<r<<\'\\n\';\n\t\t\tmp.erase(it);\n\t\t\tint L, R, mid1, mid2;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid1=L+R>>1,L^R)\n\t\t\t\tif(ask1(root,l,mid1).minn <= -1) R=mid1;\n\t\t\t\telse L=mid1+1;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid2=L+R>>1, L^R)\n\t\t\t\tif(ask2(root,mid2+1,r).minn<=-1)\n\t\t\t\t\tL=mid2+1;\n\t\t\t\telse R= mid2;\n\t\t\t// if(l == x || ask1(root,l,x-1).sum == 0){\n\t\t\t// \tL = x+1, R=r;\n\t\t\t// \twhile(mid=L+R>>1, L^R)\n\t\t\t// \t\tif(ask2(root,mid+1,r).minn<=-1)\n\t\t\t// \t\t\tL=mid+1;\n\t\t\t// \t\telse R= mid;\n\t\t\t// }\n\t\t\t// else{\n\t\t\t// \tL = l, R = x-1;\n\t\t\t// \twhile(mid=L+R>>1,L^R)\n\t\t\t// \t\tif(ask1(root,l,mid).minn <= -1) R=mid;\n\t\t\t// \t\telse L=mid+1;\n\t\t\t// }\n\t\t\tint cnt = (l<=mid1-1) + (mid1+1<=mid2-1)+(mid2+1<=r);\n\t\t\tcout<<cnt<<\'\\n\';\n\t\t\tif(l<=mid1-1){\n\t\t\t\tmp.insert(P(l,mid1-1));\n\t\t\t\tcout<<l<<\' \'<<mid1-1<<\'\\n\';\n\t\t\t}\n\t\t\tif(mid1+1<=mid2-1){\n\t\t\t\tmp.insert(P(mid1+1,mid2-1));\n\t\t\t\tcout<<mid1+1<<\' \'<<mid2-1<<\'\\n\';\n\t\t\t}\n\t\t\tif(mid2+1<=r){\n\t\t\t\tmp.insert(P(mid2+1,r));\n\t\t\t\tcout<<mid2+1<<\' \'<<r<<\'\\n\';\n\t\t\t}\n\t\t\tone.erase(x);\n\t\t\tzero.insert(x);\n\t\t\talen.insert(mid1);\n\t\t\talen.insert(mid2);\n\t\t}\n\t\t// cerr<<""===========================\\n"";\n\t}\n}\nint main(){\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\t// for(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t// }\n\treturn 0;\n}\n\n']","['constructive algorithms', 'data structures']",3000
https://codeforces.com//contest/1740/problem/I,I. Arranging Crystal Balls,In the world of Compfestnesia Pak Chanek discovers a secret underground dungeon Inside it there is a treasure chest that is surrounded by n statues that are arranged in a circular manner The statues are numbered from 0 to n 1 with statue i being to the left of statue i 1 and statue n 1 being to the left of statue 0 Pak Chanek observes that each statue is holding a crystal ball with an integer between 0 and m 1 inclusive Let s say the integer in the crystal ball of statue i is a i The dungeon provides instructions that every integer in the crystal balls must be 0 in order to open the treasure chest To achieve that Pak Chanek is given an integer k and he can do zero or more operations In a single operation Pak Chanek does the following Choose exactly k consecutive statues In other words choose the statues p p 1 bmod n p 2 bmod n p 3 bmod n ldots p k 1 bmod n for some chosen index p Do one of the following For all chosen statues change their values of a i into a i 1 bmod m For all chosen statues change their values of a i into a i 1 bmod m Help Pak Chanek find the minimum possible number of operations to open the treasure chest ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class t,class u>\nvoid print_offset(const pair<t,u>&p,ll off,int suc=1){\n\tprint(p.a+off,2);\n\tprint(p.b+off,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//f(a,b) が true なら a を削除する\n//less をわたすと slide max が取れる\ntemplate<class t,class u>\nstruct slide{\n\tvc<t> x;\n\tvi y;\n\tu f;\n\tint b,e,c,d;\n\tslide(u ff=u()):f(ff){init();}\n\tvoid init(){b=e=c=d=0;}\n\tvoid push(t a){\n\t\twhile(b<e&&f(x[e-1],a))e--;\n\t\tif(e==(int)x.size()){\n\t\t\tx.eb();\n\t\t\ty.eb();\n\t\t}\n\t\tx[e]=a;\n\t\ty[e++]=c++;\n\t}\n\tvoid pop(){if(y[b]==d)b++;d++;}\n\tt get(){return x[b];}\n\tbool has(){return b<e;}\n};\n\nvoid muri(){\n\tcout<<-1<<endl;\n\texit(0);\n}\n\nvoid slv(){\n\tint n,m,k;cin>>n>>m>>k;\n\tvi rw=readvi(n);\n\tint g=gcd(k,n);\n\tvvc<int> ls(g,vi(n/g));\n\tvi dif(n);\n\trep(i,n)dif[i]=(rw[i]-rw[(i+n-1)%n]+m)%m;\n\tvi sum(n);\n\tauto sub=[&](int l,int r,int v){\n\t\tl%=n;r%=n;\n\t\tsum[l]=(sum[l]+m-v)%m;\n\t\tsum[r]=(sum[r]+v)%m;\n\t\tif(r<l)sum[0]=(sum[0]+m-v)%m;\n\t};\n\trep(ini,g){\n\t\tint s=0;\n\t\trep(i,n/g){\n\t\t\tint pos=(ini+i*k)%n;\n\t\t\ts=(s+dif[pos])%m;\n\t\t\tsub(pos,pos+k,s);\n\t\t\tls[ini][i]=s;\n\t\t}\n\t\tif(s){\n\t\t\tmuri();\n\t\t}\n\t}\n\trep(i,n-1)sum[i+1]=(sum[i+1]+sum[i])%m;\n\trep(i,n)rw[i]=(rw[i]+sum[i])%m;\n\tassert(rw==vi(n,rw[0]));\n\t\n\tvi dp(m,inf);\n\tdp[0]=0;\n\t\n\tslide<int,greater<int>> z;\n\t\n\trep(ini,g){\n\t\tvi pos{0,m};\n\t\tvc<tuple<int,int,int,int>> qs;\n\t\tauto add=[&](int l,int r,int a,int b){\n\t\t\tb-=a*l;\n\t\t\tqs.eb(l,r,a,b);\n\t\t\tpos.pb(l);\n\t\t\tpos.pb(r);\n\t\t};\n\t\tfor(auto j:ls[ini]){\n\t\t\tint cur=0;\n\t\t\twhile(cur<m){\n\t\t\t\tif(j<m-j){\n\t\t\t\t\tint w=m/2+1;\n\t\t\t\t\tint nx=min(cur+w-j,m);\n\t\t\t\t\tadd(cur,nx,1,j);\n\t\t\t\t\tj=w%m;\n\t\t\t\t\tcur=nx;\n\t\t\t\t}else{\n\t\t\t\t\tint w=m+1;\n\t\t\t\t\tint nx=min(cur+w-j,m);\n\t\t\t\t\tadd(cur,nx,-1,m-j);\n\t\t\t\t\tj=w%m;\n\t\t\t\t\tcur=nx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmkuni(pos);\n\t\tint s=si(pos)-1;\n\t\tvi as(s+1),bs(s+1);\n\t\tfor(auto [l,r,a,b]:qs){\n\t\t\tl=lwb(pos,l);\n\t\t\tr=lwb(pos,r);\n\t\t\tas[l]+=a;as[r]-=a;\n\t\t\tbs[l]+=b;bs[r]-=b;\n\t\t}\n\t\trep(i,s)as[i+1]+=as[i];\n\t\trep(i,s)bs[i+1]+=bs[i];\n\t\tvi nx(m,inf);\n\t\trep(i,s){\n\t\t\tint l=pos[i],r=pos[i+1],a=as[i],b=bs[i];\n\t\t\tz.init();\n\t\t\trng(j,l-r,0)z.push(dp[j+m]-j*a);\n\t\t\trep(j,m){\n\t\t\t\tz.pop();\n\t\t\t\tz.push(dp[j]-j*a);\n\t\t\t\tint tar=(j+l);\n\t\t\t\tint val=a*tar+b+z.get();\n\t\t\t\tchmin(nx[tar%m],val);\n\t\t\t}\n\t\t}\n\t\tdp.swap(nx);\n\t}\n\tint ans=inf;\n\trep(i,m)if((i*k/g)%m==rw[0])chmin(ans,dp[i]);\n\tif(ans>inf/2)ans=-1;\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'divide and conquer', 'divide and conquer', 'dp', 'geometry', 'graphs', 'number theory']",3500
https://codeforces.com//contest/1190/problem/C,C. Tokitsukaze and Duel, Duel Betting on the lovely princess Claris the duel between Tokitsukaze and Quailty has started There are n cards in a row Each card has two sides one of which has color At first some of these cards are with color sides facing up and others are with color sides facing down Then they take turns flipping cards in which Tokitsukaze moves first In each move one should choose exactly k consecutive cards and flip them to the same side which means to make their color sides all face up or all face down If all the color sides of these n cards face the same direction after one s move the one who takes this move will win Princess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won t make mistakes ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nchar s[N];\nint n, k;\nvector<int> a[2];\n\nvoid printAns(int x) {\n\tif (x == 0) {\n\t\tprintf(""tokitsukaze\\n"");\n\t} else if (x == 1) {\n\t\tprintf(""quailty\\n"");\n\t} else {\n\t\tprintf(""once again\\n"");\n\t}\n}\n\npii get(int id, int l, int r) {\n\tpii res = mp(-1, -1);\n\tif (a[id].empty()) return res;\n\tif (l <= a[id][0] && a[id].back() < r) return res;\n\tif (l <= a[id][0]) {\n\t\tint pos = lower_bound(a[id].begin(), a[id].end(), r) - a[id].begin();\n\t\tif (pos >= (int)a[id].size()) throw;\n\t\tres.first = a[id][pos];\n\t} else {\n\t\tres.first = a[id][0];\n\t}\n\tif (a[id].back() < r) {\n\t\tint pos = lower_bound(a[id].begin(), a[id].end(), l) - a[id].begin();\n\t\tpos--;\n\t\tif (pos < 0) throw;\n\t\tres.second = a[id][pos];\n\t} else {\n\t\tres.second = a[id].back();\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &k);\n\tscanf(""%s"", s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[(int)(s[i] - \'0\')].push_back(i);\n\tfor (int i = 0; i + k <= n; i++) {\n\t\tfor (int x = 0; x < 2; x++) {\n\t\t\tpii t = get(x, i, i + k);\n\t\t\tif (t.first == -1) {\n\t\t\t\tprintAns(0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i + k <= n; i++) {\n\t\tfor (int x = 0; x < 2; x++) {\n\t\t\tpii t = get(x, i, i + k);\n\t\t\tif (t.first + k <= t.second) {\n\t\t\t\tprintAns(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintAns(1);\n\n\treturn 0;\n}\n']","['brute force', 'games', 'greedy']",2300
https://codeforces.com//contest/1742/problem/C,C. Stripes,On an 8 times 8 grid some horizontal rows have been painted red and some vertical columns have been painted blue in some order The stripes are drawn sequentially one after the other When the stripe is drawn it repaints all the cells through which it passes Determine which color was used last ,"[""#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\n\nvoid solve()\n{\n\tvector<vector<char>> v(8,vector<char>(8));\n\n\tfor(int i=0;i<8;i++)\n\t{\n\t\t string s;\n\t\t cin>>s;\n\n\t\t for(int j=0;j<8;j++)\n\t\t {\n\t\t \t v[i][j]=s[j];\n\t\t }\n\t}\n\n\tchar ans='R';\n\n\tfor(int i=0;i<8;i++)\n\t{\n\t\t int f=0;\n\t\t for(int j=0;j<8;j++)\n\t\t {\n\t\t \t if(v[i][j]=='R')\n\t\t \t {\n\t\t \t \t f++;\n\t\t \t }\n\t\t }\n\n\t\t if(f==8)\n\t\t \tans='R';\n\t}\n\n\tfor(int j=0;j<8;j++)\n\t{\n\t\t int f=0;\n\t\t for(int i=0;i<8;i++)\n\t\t {\n\t\t \t if(v[i][j]=='B')\n\t\t \t {\n\t\t \t \t f++;\n\t\t \t }\n\t\t }\n\n\t\t if(f==8)\n\t\t \t ans='B';\n\t}\n\n\tcout<<ans<<endl;\n}\n\nint32_t main()\n{\n\t int t=1;\n\n\t cin>>t;\n\n\t while(t--)\n\t {\n\t \t solve();\n\t }\n\t return 0;\n}                                    ""]",['implementation'],900
https://codeforces.com//contest/811/problem/B,B. Vladik and Complicated Book,Vladik had started reading a complicated book about algorithms containing pages To improve understanding of what is written his friends advised him to read pages in some order given by permutation where denotes the number of page that should be read th in turn Sometimes Vladik s mom sorted some subsegment of permutation from position to position inclusive because she loves the order For every of such sorting Vladik knows number what index of page in permutation he should read He is wondered if the page which he will read after sorting has changed In other words has changed After every sorting Vladik return permutation to initial state so you can assume that each sorting is independent from each other ,"['#include<bits/stdc++.h>\n#define rep(i,j,k) for((i)=(j);(i)<=(k);++i)\n#define per(i,j,k) for((i)=(j);(i)>=(k);--i)\nusing namespace std;\ntypedef long long ll;\ninline void cmin(int &x,int y){if(y<x)x=y;}\ninline void cmax(int &x,int y){if(y>x)x=y;}\nint a[100006];\nint inline read(){\n\tchar ch=getchar();int z=0,f=1;\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){z=z*10+ch-\'0\';ch=getchar();}\n\treturn z*f;\n}\nint main(){\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint n,m,i,l,r,x;\n\tn=read();m=read();\n\trep(i,1,n) a[i]=read();\n\twhile(m--){\n\t\tl=read();r=read();x=read();\n\t\tint tot = 0;\n\t\trep(i,l,r){if(a[i] < a[x]) ++tot;}\n\t\tif(tot == x - l) puts(""Yes""); else puts(""No"");\n\t}\n\treturn 0;\n}\n']","['implementation', 'sortings']",1200
https://codeforces.com//contest/1497/problem/E2,E2. Square-Free Division  hard version ,There is an array a 1 a 2 ldots a n of n positive integers You should divide it into a minimal number of continuous segments such that in each segment there are no two numbers on different positions whose product is a perfect square Moreover it is allowed to do at most k such operations before the division choose a number in the array and change its value to any positive integer What is the minimum number of continuous segments you should use if you will make changes optimally ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    vector<int> h(1e7 + 5);\n    vector<int> e(1e7 + 5, 1);\n    vector<int> minD(1e7 + 5, -1);\n    minD[1] = 1;\n    for (ll i = 2; i < 1e7 + 5; ++i) {\n        if (e[i]) {\n            minD[i] = i;\n            for (ll j = i; j * i < 1e7 + 5; ++j) {\n                e[i * j] = 0;\n                if (minD[i * j] == -1) {\n                    minD[i * j] = i;\n                } else {\n                    minD[i * j] = min(minD[i * j], (int)i);\n                }\n\n            }\n        }\n    }\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            int ans = 1;\n            map<int, int> cnt;\n            while (minD[a[i]] != 1) {\n                ++cnt[minD[a[i]]];\n                a[i] /= minD[a[i]];\n            }\n            for (auto &elem : cnt) {\n                if (elem.se % 2) {\n                    ans *= elem.fi;\n                }\n            }\n            a[i] = ans;\n        }\n        vector<vector<int>> sameSegment(k + 1, vector<int>(n));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) h[a[j]] = 0;\n            int l = 0, cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                ++h[a[j]];\n                if (h[a[j]] > 1) {\n                    ++cnt;\n                }\n                while (cnt > i) {\n                    if (h[a[l]] > 1) {\n                        --cnt;\n                    }\n                    --h[a[l]];\n                    ++l;\n                }\n                sameSegment[i][j] = l;\n            }\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(n, 1e9));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int z = 0; z <= i; ++z) {\n                    int ans = 1;\n                    if (sameSegment[i - z][j] - 1 != -1) {\n                        ans += dp[z][sameSegment[i - z][j] - 1];\n                    }\n                    dp[i][j] = min(dp[i][j], ans);\n                }\n            }\n        }\n        int res = 1e9;\n        for (int j = 0; j <= k; ++j) {\n            res = min(res, dp[j][n - 1]);\n        }\n        cout << res << \'\\n\';\n    }\n}\n/*\n*/\n']","['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",2500
https://codeforces.com//contest/899/problem/B,B. Months and Years,Everybody in Russia uses Gregorian calendar In this calendar there are days in January or days in February depending on whether the year is leap or not days in March days in April days in May in June in July in August in September in October in November in December A year is leap in one of two cases either its number is divisible by but not divisible by or is divisible by For example the following years are leap but years and are not leap In this problem you are given integers and you have to check if these integers could be durations in days of consecutive months according to Gregorian calendar Note that these months could belong to several consecutive years In other words check if there is a month in some year such that its duration is days duration of the next month is days and so on ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define biubiu {puts(""YES"");exit(0);}\nusing namespace std;\nint pingping[]={31,28,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31};\nint pingrun[]={31,28,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31,31,29,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31};\nint runping[]={31,28,31,30,31,30,31,31,30,31,30,31,31,29,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31};\nint n,a[25];\nbool checkpingping(){\n\tfor(int i=0;i<12;i++){\n\t\tbool f=true;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(pingping[i+j]!=a[j])\n\t\t\t\tf=false;\n\t\tif(f)return true;\n\t}\n\treturn false;\n}\nbool checkpingrun(){\n\tfor(int i=0;i<24;i++){\n\t\tbool f=true;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(pingrun[i+j]!=a[j])\n\t\t\t\tf=false;\n\t\tif(f)return true;\n\t}\n\treturn false;\n}\nbool checkrunping(){\n\tfor(int i=0;i<24;i++){\n\t\tbool f=true;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(runping[i+j]!=a[j])\n\t\t\t\tf=false;\n\t\tif(f)return true;\n\t}\n\treturn false;\n}\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i=0;i<n;i++)scanf(""%d"",&a[i]);\n\tif(checkpingping())biubiu\n\tif(checkpingrun())biubiu\n\tif(checkrunping())biubiu\n\tputs(""NO"");\n\treturn 0;\n}\n']",['implementation'],1200
https://codeforces.com//contest/543/problem/A,A. Writing Code,Programmers working on a large project have just received a task to write exactly lines of code There are programmers working on a project the th of them makes exactly bugs in every line of code that he writes Let s call a sequence of non negative integers a if The programmers follow the plan like that in the beginning the first programmer writes the first lines of the given task then the second programmer writes more lines of the given task and so on In the end the last programmer writes the remaining lines of the code Let s call a plan if all the written lines of the task contain at most bugs in total Your task is to determine how many distinct plans are there As the number of plans can be large print the remainder of this number modulo given positive integer ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(""rdtsc"" : ""=A""(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME ""text""\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nint MOD;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= MOD) {\n    x -= MOD;\n  }\n}\n\nint n, m, b;\n\nconst int maxn = 500 + 10;\nint a[maxn];\n\nbool read() {\n  if (scanf(""%d%d%d%d"", &n, &m, &b, &MOD) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(""%d"", &a[i]);\n  }\n  return 1;\n}\n\nint d[maxn][maxn];\n\nvoid solve() {\n  for (int sv = 0; sv <= m; ++sv) {\n    for (int sva = 0; sva <= b; ++sva) {\n      d[sv][sva] = 0;\n    }\n  }\n  d[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int sv = 0; sv < m; ++sv) {\n      for (int sva = 0; sva <= b; ++sva) {\n        int nsv = sv + 1;\n        int nsva = sva + a[i];\n        if (nsva > b) {\n          break;\n        }\n        add(d[nsv][nsva], d[sv][sva]);\n      }\n    }\n  }\n  int res = 0;\n  for (int sva = 0; sva <= b; ++sva) {\n    add(res, d[m][sva]);\n  }\n  printf(""%d\\n"", res);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME"".out"", ""w"", stdout);\n  assert(freopen(TASKNAME"".in"", ""r"", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""%.18lf\\n"", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']",['dp'],1800
https://codeforces.com//contest/1876/problem/G,G. Clubstep,There is an extremely hard video game that is one of Chaneka s favourite video games One of the hardest levels in the game is called Clubstep Clubstep consists of n parts numbered from 1 to n Chaneka has practised the level a good amount so currently her familiarity value with each part i is a i After this Chaneka can do several possibly zero attempts on Clubstep In each attempt she dies on one of the n parts If an attempt dies on part p that means it only successfully passes through every part k for all 1 leq k leq p 1 and it does not reach any part k for all p 1 leq k leq n An attempt that dies on part p takes p seconds It is known that Chaneka improves much more on the part she dies on than anything else It is also known that during an attempt Chaneka does not get to practise that much on the parts she does not reach So the effect of an attempt that dies on part p is as follows Chaneka s familiarity value with part p increases by 2 Chaneka s familiarity value with each part k for all 1 leq k leq p 1 increases by 1 There will be q questions For the j th question you are given three integers l j r j and x j Then you are asked to find out the in seconds for Chaneka to make it such that the familiarity value for every part p l j leq p leq r j is at least x j Note that each question is independent so the attempt Chaneka does on a question does not affect the familiarity values of any other questions ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    std::vector<int> f(2 * q);\n    std::vector<i64> val(2 * q);\n    int tot = q;\n    std::iota(f.begin(), f.end(), 0);\n    \n    std::vector<i64> ans(q);\n    std::vector<std::vector<std::pair<int, int>>> add(n);\n    std::vector<std::vector<int>> del(n);\n    for (int i = 0; i < q; i++) {\n        int l, r, x;\n        std::cin >> l >> r >> x;\n        l--, r--;\n        add[r].emplace_back(x, i);\n        del[l].push_back(i);\n    }\n    \n    auto find = [&](auto self, int x) -> int {\n        if (f[x] == f[f[x]]) {\n            return f[x];\n        }\n        auto y = self(self, f[x]);\n        val[x] += val[f[x]];\n        f[x] = y;\n        return f[x];\n    };\n    \n    auto get = [&](i64 x) {\n        find(find, x);\n        i64 ans = val[x];\n        if (x != f[x]) {\n            ans += val[f[x]];\n        }\n        return ans;\n    };\n    \n    auto merge = [&](int &x, int y) {\n        int z = tot++;\n        f[x] = z;\n        f[y] = z;\n        x = z;\n    };\n    \n    std::map<int, int> mp;\n    for (int i = n - 1; i >= 0; i--) {\n        for (auto [x, j] : add[i]) {\n            if (mp.contains(x)) {\n                merge(mp[x], j);\n            } else {\n                mp[x] = j;\n            }\n        }\n        for (auto it = mp.upper_bound(a[i]); it != mp.end(); it = mp.erase(it)) {\n            auto [x, j] = *it;\n            int y = (x + a[i]) / 2;\n            val[j] += 1LL * (i + 1) * (x - y);\n            if (mp.contains(y)) {\n                merge(mp[y], j);\n            } else {\n                mp[y] = j;\n            }\n        }\n        for (auto j : del[i]) {\n            ans[j] = get(j);\n        }\n    }\n    \n    for (int i = 0; i < q; i++) {\n        std::cout << ans[i] << ""\\n"";\n    }\n    \n    return 0;\n}\n']","['binary search', 'brute force', 'data structures', 'greedy', 'trees']",3500
https://codeforces.com//contest/1734/problem/D,D. Slime Escape,You are playing a game called The game takes place on a number line Initially there are n slimes For all positive integers i where 1 le i le n the i th slime is located at position i and has health a i You are controlling the slime at position k There are two escapes located at positions 0 and n 1 Your goal is to reach of the two escapes by performing any number of game moves In one game move you move your slime to the left or right by one position However if there is another slime in the new position you must absorb it When absorbing a slime the health of your slime would be increased by the health of the absorbed slime then the absorbed slime would be removed from the game Note that some slimes might have negative health so your health would decrease when absorbing such slimes You lose the game immediately if your slime has negative health at any moment during the game Can you reach one of two escapes by performing any number of game moves without ever losing the game ,"['// Problem: D. Slime Escape\n// Contest: Codeforces Round #822 (Div. 2)\n// URL: https://codeforces.com/contest/1734/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//author: wuge with noi2022 cu\n//https://www.luogu.com.cn/team/48234\n#include<bits/stdc++.h>\nusing namespace std;\n#define M998 const int mod=998244353\n#define M197 const int mod=1e9+7\n#define int long long\n#define genshin getchar\n#define impact isdigit\ninline int read()\n{\n     int shaya=0,wugecu=1;//5 spaces\n  char cirno_9=genshin();//2 spaces\n        while(!impact(cirno_9))//8 spaces\n  {if(cirno_9==\'-\')wugecu=-1;cirno_9=genshin();}//2 spaces\n  while(impact(cirno_9)) shaya=shaya*10+cirno_9-\'0\',cirno_9=genshin();//2 spaces\n return shaya*wugecu;//1 space\n}\nint n,k;\nint a[1000003];\nbool chk()\n{\n\tvector<pair<int,int>> b;\n#define fi first\n#define se second\n\tint val=a[k];\n\tfor(int i=k+1; i<=n;)\n\t{\n\t\tint sum=0,mn=0;\n\t\twhile(i<=n&&sum<=0)\n\t\t{\n\t\t\tsum+=a[i++];\n\t\t\tmn=min(sum,mn);\n\t\t}\n\t\tif(sum>0)\n\t\t{\n\t\t\tb.push_back(make_pair(sum,mn));\n\t\t}\n\t}\n\tauto it=b.begin();\n\tfor(int i=k-1; i>=1; --i)\n\t{\n\t\twhile(it!=b.end()&&val+(it->se)>=0)\n\t\t{\n\t\t\tval+=it->fi,++it;\n\t\t}\n\t\tif(val+a[i]<0) return 0;\n\t\tval+=a[i];\n\t}\n\treturn 1;\n}\nvoid Meyi()\n{\n\tn=read(),k=read();\n\tfor(int i=1; i<=n; ++i) a[i]=read();\n\t//to left\n\tif(chk()) \n\t{\n\t\tputs(""YES"");\n\t\treturn ;\n\t}\n\treverse(a+1,a+n+1);k=n+1-k;\n\tif(chk()) \n\t{\n\t\tputs(""YES"");\n\t\treturn ;\n\t}\n\tputs(""NO"");\n\treturn ;\t\n}\nsigned main()\n{\n\tint miHoYo=read();\n\twhile(miHoYo--) Meyi();\n\treturn 0;\n}']","['data structures', 'dp', 'greedy', 'two pointers']",1800
https://codeforces.com//contest/739/problem/E,E. Gosha is hunting,Gosha is hunting His goal is to catch as many Pokemons as possible Gosha has Poke Balls and Ultra Balls There are Pokemons They are numbered through Gosha knows that if he throws a Poke Ball at the th Pokemon he catches it with probability If he throws an Ultra Ball at the th Pokemon he catches it with probability He can throw at most one Ball of each type at any Pokemon The hunting proceeds as follows at first Gosha chooses no more than Pokemons at which he will throw Poke Balls and no more than Pokemons at which he will throw Ultra Balls After that he throws the chosen Balls at the chosen Pokemons If he throws both Ultra Ball and Poke Ball at some Pokemon he is caught if and only if he is caught by any of these Balls The outcome of a throw doesn t depend on the other throws Gosha would like to know what is the expected number of the Pokemons he catches if he acts in an optimal way In other words he would like to know the maximum possible expected number of Pokemons can catch ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=2010;\nint n,a,b,cnt[N][N];\ndouble p[N],u[N],f[N],dp[N][N];\nint main() {\n\tscanf(""%d%d%d"",&n,&a,&b);\n\trep(i,0,n) scanf(""%lf"",p+i);\n\trep(i,0,n) scanf(""%lf"",u+i),f[i]=p[i]+u[i]-p[i]*u[i];\n\tdouble l=-5e4,r=5e4;\n\twhile (clock()<=4*CLOCKS_PER_SEC) {\n\t\tdouble md=(l+r)*0.5;\n\t\trep(i,0,n+1) rep(j,0,i+1) dp[i][j]=-1e10,cnt[i][j]=0;\n\t\tdp[0][0]=0;\n\t\trep(i,1,n+1) rep(j,0,i+1) {\n\t\t\tif (j<i&&dp[i-1][j]>dp[i][j]) dp[i][j]=dp[i-1][j],cnt[i][j]=cnt[i-1][j];\n\t\t\tif (j>0&&dp[i-1][j-1]+p[i-1]>dp[i][j]) dp[i][j]=dp[i-1][j-1]+p[i-1],cnt[i][j]=cnt[i-1][j-1];\n\t\t\tif (j<i&&dp[i-1][j]+u[i-1]+md>dp[i][j]) dp[i][j]=dp[i-1][j]+u[i-1]+md,cnt[i][j]=cnt[i-1][j]+1;\n\t\t\tif (j>0&&dp[i-1][j-1]+f[i-1]+md>dp[i][j]) dp[i][j]=dp[i-1][j-1]+f[i-1]+md,cnt[i][j]=cnt[i-1][j-1]+1;\n\t\t}\n\t\tif (cnt[n][a]<b) l=md; else r=md;\n\t}\n\tprintf(""%.10f\\n"",dp[n][a]-b*0.5*(l+r));\n}\n']","['brute force', 'data structures', 'dp', 'flows', 'math', 'probabilities', 'sortings']",3000
https://codeforces.com//contest/1027/problem/A,A. Palindromic Twist,You are given a string s consisting of n lowercase Latin letters n is even For each position i 1 le i le n in string s you are required to change the letter on this position either to the previous letter in alphabetic order or to the next one letters and have only one of these options Letter in every position must be changed For example letter should be changed either to or to letter should be changed to and letter should be changed to That way string for example can be changed to rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow String s is called a palindrome if it reads the same from left to right and from right to left For example strings and are palindromes and strings and are not Your goal is to check if it s possible to make string s a palindrome by applying the aforementioned changes to every position Print if string s can be transformed to a palindrome and otherwise Each testcase contains several strings for each of them you are required to solve the problem separately ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 11111;\nint n;\nchar s[N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tscanf(""%s"", s);\n//\tn = strlen(s);\n\tfor (int i = 0; 2 * i < n; i++) {\n\t\tint x = (int)(s[i] - \'a\'), y = (int)(s[n - 1 - i] - \'a\');\n\t\tbool ok = false;\n\t\tfor (int mask = 0; !ok && mask < 4; mask++) {\n\t\t\tint xx = x, yy = y;\n\t\t\tif (mask & 1)\n\t\t\t\txx++;\n\t\t\telse\n\t\t\t\txx--;\n\t\t\tif (mask & 2)\n\t\t\t\tyy++;\n\t\t\telse\n\t\t\t\tyy--;\n\t\t\tif (xx >= 0 && xx < 26 && xx == yy) {\n\t\t\t\tok = true;\n\t\t\t\ts[i] = \'a\' + xx;\n\t\t\t\ts[n - 1 - i] = \'a\' + yy;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['implementation', 'strings']",1000
https://codeforces.com//contest/1881/problem/E,E. Block Sequence,Given a sequence of integers a of length n A sequence is called if it has the form of a series of blocks each starting with its length i e first comes the length of the block and then its elements For example the sequences color red 3 color red 3 color red 4 color red 5 color green 2 color green 6 color green 1 and color red 1 color red 8 color green 4 color green 5 color green 2 color green 6 color green 1 are different blocks are colored differently while 1 1 4 3 3 2 1 are not In one operation you can remove any element from the sequence What is the minimum number of operations required to make the given sequence ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,a[N];\nll d[N],dp[N];\nll cnt;\nvoid prep(){\n\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) cin>>a[i];\n    rep(i,1,n+1) dp[i]=n+1;\n    dp[0]=0;\n    rep(i,0,n-1){\n        dp[i+1]=min(dp[i+1],dp[i]+1);\n        if (a[i+1]+i+1<=n) dp[a[i+1]+i+1]=min(dp[a[i+1]+i+1],dp[i]);\n    }\n    cout<<dp[n];\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']",['dp'],1500
https://codeforces.com//contest/362/problem/C,C. Insertion Sort,Petya is a beginner programmer He has already mastered the basics of the C language and moved on to learning algorithms The first algorithm he encountered was insertion sort Petya has already written the code that implements this algorithm and sorts the given integer zero indexed array of size in the non decreasing order for int i 1 i n i i 1 int j i while j 0 a j a j 1 swap a j a j 1 swap elements a j and a j 1 j j 1 Petya uses this algorithm only for sorting of arrays that are permutations of numbers from to He has already chosen the permutation he wants to sort but he first decided to swap some two of its elements Petya wants to choose these elements in such a way that the number of times the sorting executes function was minimum Help Petya find out the number of ways in which he can make the swap and fulfill this requirement It is guaranteed that it s always possible to swap two elements of the input permutation in such a way that the number of function calls decreases ,"['#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <sstream>\n#include <assert.h>\n#include <complex>\n\n#include <time.h>\n#pragma comment(linker, ""/STACK:20000000"")\n\n#define fr(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define fd(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nusing namespace std;\n\nint ri(){int x;scanf(""%d"",&x);return x;}\nll rll(){ll x;scanf(""%lld"",&x);return x;}\n\nint check(vector<int> a)\n{\n\tint res = 0;\n\tfor (int i = 0; i < a.size(); i = i + 1)\n\t{\n\t   int j = i; \n\t   while (j > 0 && a[j] < a[j - 1])\n\t   {\n\t\t  swap(a[j], a[j - 1]); // поменять местами элементы a[j] и a[j - 1]\n\t\t  j = j - 1;\n\t\t  res++;\n\t   }\n\t}\n\treturn res;\n}\n\nint dp[5050];\n\nvoid insert(int i)\n{\n\twhile(i < 5050)\n\t\tdp[i]++,i += i & (-i);\n}\n\nint get(int i)\n{\n\tint res = 0;\n\twhile(i)\n\t\tres += dp[i],i-=i &(-i);\n\treturn res;\n}\n\nvoid solve()\n{\n\tint n = ri();\n\tvector<int> mas;\n\tfr(i,1,n)\n\t\tmas.pb(ri() + 1);\n\t//swap(mas[0],mas[3]);\n\tint mx =  check(mas);\n\tint res = 2e9,cnt = 0;\n\tfr(i,0,n-1)\n\t{\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint x = mas[i];\n\t\tinsert(x);\n\t\tfr(j,i + 1,n - 1)\n\t\t{\n\t\t\tint y = mas[j];\n\t\t\tinsert(y);\n\t\t\tint a = get(x - 1);\n\t\t\tint d = j - i;\n\t\t\tint b = get(y - 1);\n\t\t\tint temp = mx - a + (d - a) + b - (d - b) + 1;\n\t\t\tif (temp < res)\n\t\t\t\tres = temp,cnt = 1;\n\t\t\telse\n\t\t\tif (temp == res)\n\t\t\t\tcnt++;\n\t\t}\n\n\t}\n\tcout << res << \' \' << cnt << endl;\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/input.txt"",""rt"",stdin);\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/output.txt"",""wt"",stdout);\n\t#else\n\t\t//freopen(""cubroot.in"",""rt"",stdin);\n\t\t//freopen(""cubroot.out"",""wt"",stdout);\n\t#endif\n\t//fd(i,5000,1)\n\t//\tcout << i << \' \';\n\tsolve();\n\n\t#ifndef ONLINE_JUDGE\n\t\tprintf(""\\n\\ntime-%.3lf"",clock()*1e-3);\n\t#endif\n\n\treturn 0;\n}']","['data structures', 'dp', 'implementation', 'math']",1900
https://codeforces.com//contest/1795/problem/E,E. Explosions ,You are playing yet another game where you kill monsters using magic spells There are n cells in the row numbered from 1 to n Initially the i th cell contains the i th monster with h i health You have a basic spell that costs 1 MP and deals 1 damage to the monster you choose You can cast it any number of times Also you have a special scroll with Explosion spell you can use only once You want to finish killing monsters with explosion that s why you firstly cast the basic spell several times possibly zero and then after that you cast one Explosion How does Explosion spell work Firstly you choose the power of the spell if you pour x MP into it Explosion will deal x damage Secondly you choose some monster i which will be targeted by the spell That s what happens next if its health h i x then he stays alive with health decreased by x if h i le x the i th monster dies with an explosion that deals h i 1 damage to monsters in the neighboring cells i 1 and i 1 if these cells exist and monsters inside are still alive if the damage dealt by the explosion is enough to kill the monster i 1 or i 1 i e the current h i 1 le h i 1 or h i 1 le h i 1 then that monster also dies creating a secondary explosion of power h i 1 1 or h i 1 1 that may deals damage to their neighbors and so on until the explosions end Your goal is to kill all the remaining monsters with those chaining explosions that s why you need a basic spell to decrease h i of some monsters or even kill them beforehand monsters die when their current health h i becomes less or equal to zero Note that monsters don t move between cells so for example monsters i and i 2 will never become neighbors What is the minimum total MP you need to kill all monsters in the way you want The total MP is counted as the sum of the number of basic spells you cast and the power x of explosion scroll you ve chosen ,"['/**\n *    author:  tourist\n *    created: 16.02.2023 18:54:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n      cin >> h[i];\n    }\n    vector<long long> L(n);\n    vector<long long> R(n);\n    for (int rot = 0; rot < 2; rot++) {\n      vector<pair<long long, long long>> st;\n      long long sum = 0;\n      for (int i = 0; i < n; i++) {\n        long long cnt = 1;\n        while (!st.empty() && h[i] - cnt < st.back().first) {\n          long long diff = st.back().first - (h[i] - cnt);\n          sum += diff * st.back().second;\n          cnt += st.back().second;\n          st.pop_back();\n        }\n        if (cnt - 1 > h[i]) {\n          long long extra = cnt - 1 - h[i];\n          sum -= extra * (extra + 1) / 2;\n          cnt = h[i];\n        }\n        L[i] = sum;\n        st.emplace_back(h[i], cnt);\n      }\n      reverse(L.begin(), L.end());\n      reverse(R.begin(), R.end());\n      reverse(h.begin(), h.end());\n      swap(L, R);\n    }\n    long long ans = (long long) 1e18;\n    for (int i = 0; i < n; i++) {\n      ans = min(ans, L[i] + R[i] + h[i]);\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","['binary search', 'data structures', 'dp', 'greedy', 'math']",2200
https://codeforces.com//contest/909/problem/C,C. Python Indentation,In Python code blocks don t have explicit begin end or curly braces to mark beginning and end of the block Instead code blocks are defined by indentation We will consider an extremely simplified subset of Python with only two types of statements are written in a single line one per line An example of a simple statement is assignment are compound statements they contain one or several other statements For statement consists of a header written in a separate line which starts with for prefix and loop body Loop body is a block of statements indented one level further than the header of the loop Loop body can contain both types of statements Loop body can t be empty You are given a sequence of statements without indentation Find the number of ways in which the statements can be indented to form a valid Python program ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\n\nint n,dp[2][5005],now,ans;\nchar c;\nbool lsf;\n\nint main()\n{\n\tscanf(""%d"",&n),dp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdo c=getchar();while(!isalpha(c));\n\t\tnow=i&1;\n\t\tmemset(dp[now],0,n<<2);\n\t\tif(lsf)for(int j=1;j<n;j++)dp[now][j]=dp[now^1][j-1];\n\t\telse\n\t\t{\n\t\t\tdp[now][n-1]=dp[now^1][n-1];\n\t\t\tfor(int j=n-2;~j;j--)dp[now][j]=(dp[now][j+1]+dp[now^1][j])%mod;\n\t\t}\n\t\tlsf=(c==\'f\');\n\t}\n\tfor(int i=0;i<n;i++)ans=(ans+dp[n&1][i])%mod;\n\tprintf(""%d"",ans);\n\treturn 0;\n}']",['dp'],1800
https://codeforces.com//contest/1373/problem/E,E. Sum of Digits,Let f x be the sum of digits of a decimal number x Find the smallest non negative integer x such that f x f x 1 dots f x k n ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\nstring lower(string A, string B) {\n    if (A == """") return B;\n    if (B == """") return A;\n    if (sz(A) < sz(B)) return A;\n    if (sz(B) < sz(A)) return B;\n    if (A < B) return A;\n    return B;\n}\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N, K; cin >> N >> K;\n        string ans = """";\n\n        F0R(u, 10) {\n            F0R(nn, 20) {\n                string res; res += u + \'0\';\n                F0R(i, nn) res += \'9\';\n                int rem = N;\n                int C = 0;\n                F0R(k, K+1) {\n                    rem -= (u+k)%10;\n                    if (u+k >= 10) C++;\n                }\n\n                int reg = K+1 - C;\n                rem -= 9 * reg * nn;\n                rem -= C;\n\n                if (rem < 0) continue;\n                if (rem % (K+1) != 0) continue;\n                rem /= K+1;\n                if (rem > 8) {\n                    res += \'8\'; rem -= 8;\n                } \n\n                while (rem > 0) {\n                    res += \'0\' + min(rem, 9);\n                    rem -= 9;\n                }\n\n                reverse(all(res));\n                ans = lower(ans, res);\n                \n            }\n        }\n\n        if (ans == """") {\n            cout << -1 << nl;\n        } else cout << ans << nl;\n\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['brute force', 'constructive algorithms', 'dp', 'greedy']",2200
https://codeforces.com//contest/1539/problem/D,D. PriceFixed,Lena is the most economical girl in Moscow So when her dad asks her to buy some food for a trip to the country she goes to the best store PriceFixed Here are some rules of that store The store has an infinite number of items of every product All products have the same price 2 rubles per item For every product i there is a discount for experienced buyers if you buy b i items of products not necessarily type i then for all future purchases of the i th product there is a 50 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> pll;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\nconst int MAXN=100005;\n\nint n;\npll a[MAXN];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\treadint(n);\n\tfor(int i=1;i<=n;++i)readint(a[i].y),readint(a[i].x);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)swap(a[i].x,a[i].y);\n\tll cur=0,sum=0;\n\tint l,r;\n\tfor(r=n,l=1;;)\n\t{\n\t\twhile(l<=n && !a[l].x)++l;\n\t\twhile(r && !a[r].x)--r;\n\t\tif(l>r)break;\n\t\tif(cur>=a[l].y)sum+=a[l].x,cur+=a[l].x,a[l].x=0;\n\t\telse\n\t\t{\n\t\t\tll t=min(a[r].x,a[l].y-cur);\n\t\t\tsum+=2*t,cur+=t,a[r].x-=t;\n\t\t}\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}\n']","['binary search', 'greedy', 'implementation', 'sortings', 'two pointers']",1600
https://codeforces.com//contest/1651/problem/A,A. Playoff,Consider a playoff tournament where 2 n athletes compete The athletes are numbered from 1 to 2 n The tournament is held in n stages In each stage the athletes are split into pairs in such a way that each athlete belongs exactly to one pair In each pair the athletes compete against each other and exactly one of them wins The winner of each pair advances to the next stage the athlete who was defeated gets eliminated from the tournament The pairs are formed as follows in the first stage athlete 1 competes against athlete 2 3 competes against 4 5 competes against 6 and so on in the second stage the winner of the match 1 2 competes against the winner of the match 3 4 the winner of the match 5 6 competes against the winner of the match 7 8 and so on the next stages are held according to the same rules When athletes x and y compete the winner is decided as follows if x y is odd the athlete with the lower index wins i e if x y then x wins otherwise y wins if x y is even the athlete with the higher index wins The following picture describes the way the tournament with n 3 goes Your task is the following one given the integer n determine the index of the athlete who wins the tournament ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    cout << (1ll << N) - 1 << nl;\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']",['implementation'],800
https://codeforces.com//contest/1366/problem/C,C. Palindromic Paths,You are given a matrix with n rows numbered from 1 to n and m columns numbered from 1 to m A number a i j is written in the cell belonging to the i th row and the j th column each number is either 0 or 1 A chip is initially in the cell 1 1 and it will be moved to the cell n m During each move it either moves to the next cell in the current row or in the current column if the current cell is x y then after the move it can be either x 1 y or x y 1 The chip cannot leave the matrix Consider each path of the chip from 1 1 to n m A path is called if the number in the first cell is equal to the number in the last cell the number in the second cell is equal to the number in the second to last cell and so on Your goal is to change the values in the minimum number of cells so that path is ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tint s = n-1 + m-1;\n\tvector<vector<int> > freqs(n + m, vector<int>(2, 0));\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(i + j == (s - i - j)) continue;\n\t\t\tint r = min(i + j, s - i - j);\n\t\t\tfreqs[r][a]++;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(vector<int> z : freqs){\n\t\tans += min(z[0], z[1]);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['greedy', 'math']",1500
https://codeforces.com//contest/1650/problem/E,E. Rescheduling the Exam,Now Dmitry has a session and he has to pass n exams The session starts on day 1 and lasts d days The ith exam will take place on the day of a i 1 le a i le d all a i are different For the session schedule Dmitry considers a special value mu the smallest of the rest times before the exam for all exams For example for the image above mu 1 In other words for the schedule he counts exactly n numbers how many days he rests between the exam i 1 and i for i 0 between the start of the session and the exam i Then it finds mu the minimum among these n numbers Dmitry believes that he can improve the schedule of the session He may ask to change the date of one exam change one arbitrary value of a i Help him change the date so that all a i remain different and the value of mu is as large as possible For example for the schedule above it is most advantageous for Dmitry to move the second exam to the very end of the session The new schedule will take the form Dmitry can leave the proposed schedule unchanged if there is no way to move one exam so that it will lead to an improvement in the situation ,"[""#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector<ll> V;\nint n,d;\nint arr[200005];\nvoid solve(){\n\tcin>>n>>d;\n\tfor(int i=1; i<=n; i++) cin>>arr[i];\n\tsort(arr+1,arr+n+1);\n\tarr[n+1] = d+1;\n\tmultiset<int>st;\n\tfor(int i=1; i<=n; i++) st.insert(arr[i]-1-arr[i-1]);\n\tint ans = *st.begin();\n\tfor(int i=1; i<n; i++){\n\t\tint a = arr[i]-1-arr[i-1];\n\t\tint b = arr[i+1]-1-arr[i];\n\t\tst.erase(st.find(a));\n\t\tst.erase(st.find(b));\n\t\tst.insert(arr[i+1]-1-arr[i-1]);\n\t\t\n\t\tint mx = *st.rbegin();\n\t\tint half = mx/2; if(mx%2==0) half--;\n\t\tst.erase(st.find(mx)); st.insert(half);\n\t\tans = max(ans,*st.begin());\n\t\t\n\t\tst.erase(st.find(half)); st.insert(mx);\n\t\tif(d-arr[n]){\n\t\t\tst.insert(d-1-arr[n]);\n\t\t\tans = max(ans,*st.begin());\n\t\t\tst.erase(st.find(d-1-arr[n]));\n\t\t}\n\t\tst.erase(st.find(arr[i+1]-1-arr[i-1]));\n\t\tst.insert(a); st.insert(b);\n\t}\n\tint diff = arr[n]-1-arr[n-1];\n\tst.erase(st.find(diff));\n\tst.insert(d-1-arr[n-1]); \n\tans = max(ans,*st.begin()); st.erase(st.find(d-1-arr[n-1]));\n\t\n\tint mx = *st.rbegin();\n\tint half = mx/2; if(mx%2==0) half--;\n\tst.erase(st.find(mx)); st.insert(half);\n\tans = max(ans,*st.begin());\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}""]","['binary search', 'data structures', 'greedy', 'implementation', 'math', 'sortings']",1900
https://codeforces.com//contest/1858/problem/B,B. The Walkway,There are n benches near the Main Walkway in Summer Infomatics School These benches are numbered by integers from 1 to n in order they follow Also there are m cookie sellers near the Walkway The i th 1 le i le m cookie sellers is located near the s i th bench Petya is standing in the beginning of the Walkway He will pass near all benches starting from the 1 st bench and ending with the n th bench Petya passes the distance between two consecutive benches in 1 minute He has a knapsack with an infinite amount of cookies Petya is going to eat cookies from his knapsack and buy them from cookie sellers during the walk Petya eats cookies only near the benches according to the following rule he will eat the cookie near the i th 1 le i le n bench if and only if of the following conditions holds There is a cookie seller near the i th bench Then Petya will buy a cookie from cookie seller and eat it immediately Petya has not yet eaten a cookie Then Petya will take a cookie from his knapsack and eat it immediately At least d minutes passed since Petya ate the previous cookie In other words Petya has not eaten a cookie near the benches i 1 i 2 ldots max i d 1 1 Then Petya will take a cookie from his knapsack and eat it immediately You may assume that Petya eats cookies instantly Petya will not eat two or more cookies near the same bench You want to the number of cookies Petya will eat during his walk In order to do this you will ask the administration of the Summer Informatics School to remove cookie seller from the Walkway before Petya starts his walk Please determine the minimum possible number of cookies Petya can eat after removing exactly one cookie seller Also determine the number of cookie sellers such that if you remove one of them Petya will eat the minimum possible number of cookies ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""debug.h""\n#else\n#define debug(...)\n#endif\n\nint n, m, d;\n\nint get(int l, int r) {\n  int sz = r - l - 1;\n  return sz >= 0 ? sz / d : 0;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> m >> d;\n    vector<int> s(m);\n    for (int i = 0; i < m; i++) {\n      cin >> s[i];\n    }\n    pair<int, int> ans = {INT_MAX, -1};\n    auto upd = [&](int x) {\n      if (x < ans.first) {\n        ans.first = x;\n        ans.second = 1;\n      } else if (x == ans.first) {\n        ans.second++;\n      }\n    };\n    int all = 1 + get(1, s[0]);\n    for (int i = 0; i < m - 1; i++) all += get(s[i], s[i + 1]);\n    all += get(s.back(), n + 1);\n    all += m;\n    all -= s[0] == 1;\n    debug(all);\n    upd(all - get(1, s[0]) - get(s[0], s[1]) - (s[0] != 1) + get(1, s[1]));\n    upd(all - get(s[m - 2], s[m - 1]) - get(s[m - 1], n + 1) +\n        get(s[m - 2], n + 1) - 1);\n    for (int i = 1; i < m - 1; i++)\n      upd(all - get(s[i - 1], s[i]) - get(s[i], s[i + 1]) +\n          get(s[i - 1], s[i + 1]) - 1);\n    cout << ans.first << "" "" << ans.second << ""\\n"";\n  }\n}']","['brute force', 'dp', 'greedy', 'math', 'number theory']",1500
https://codeforces.com//contest/1782/problem/C,C. Equal Frequencies,Let s call a string if all characters that are present in it appear the same number of times For example and are balanced while and are not You are given a string s of length n consisting of lowercase English letters Find a balanced string t of the same length n consisting of lowercase English letters that is different from the string s in as few positions as possible In other words the number of indices i such that s i ne t i should be as small as possible ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, a[N];\nstring s;\nint ord[N], cnt[27], aim[27];\nvoid Main() {\n\tcin >> n;\n\tme(cnt, 0);\n\tcin >> s;\n\tL(i, 0, n - 1) \n\t\tcnt[s[i] - 'a'] += 1;\n\tL(i, 0, 25) ord[i] = i;\n\tsort(ord, ord + 26, [&] (int x, int y) {\n\t\treturn cnt[x] > cnt[y];\n\t});\n\tint ns = 1e9, pos = 0;\n\tL(d, 1, 26) if(n % d == 0) {\n\t\tint w = n / d, val = 0;\n\t\tL(i, 0, d - 1) \n\t\t\tif(cnt[ord[i]] < w) \n\t\t\t\tval += w - cnt[ord[i]];\n\t\tif(val < ns) ns = val, pos = d;\n\t}\n\tint d = pos;\n\tme(aim, 0);\n\tL(i, 0, d - 1) \n\t\taim[ord[i]] = n / d;\n\tfor(auto &u : s) {\n\t\tif(cnt[u - 'a'] > aim[u - 'a']) {\n\t\t\tL(i, 0, 25) \n\t\t\t\tif(cnt[i] < aim[i]) {\n\t\t\t\t\t--cnt[u - 'a'];\n\t\t\t\t\tu = i + 'a';\n\t\t\t\t\t++cnt[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\tcout << ns << '\\n' << s << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ""]","['brute force', 'constructive algorithms', 'greedy', 'implementation', 'sortings', 'strings']",1600
https://codeforces.com//contest/6/problem/D,D. Lizards and Basements 2,Polycarp likes to play computer role playing game Lizards and Basements At the moment he is playing it as a magician At one of the last levels he has to fight the line of archers The only spell with which he can damage them is a fire ball If Polycarp hits the th archer with his fire ball they are numbered from left to right the archer loses health points At the same time the spell damages the archers adjacent to the th if any they lose health points each As the extreme archers i e archers numbered 1 and are very far the fire ball cannot reach them Polycarp can hit any other archer with his fire ball The amount of health points for each archer is known An archer will be killed when this amount is less than 0 What is the minimum amount of spells Polycarp can use to kill all the enemies Polycarp can throw his fire ball into an archer if the latter is already killed ,"['#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<sstream>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<cstring>\n#include<climits>\n#include<list>\n#include<complex>\n#ifdef _MSC_VER\n#include <hash_set>\n#include <hash_map>\nusing namespace stdext;\n#else\n#if __GNUC__ > 2\n#include <ext/hash_set>\n#include <ext/hash_map>\nusing namespace __gnu_cxx;\n#else\n#include <hash_set>\n#include <hash_map>\n#endif\n#endif\n\nusing namespace std;\n\n#define eps 1e-12\n#define oo (int)1e9\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin() ; i != (c).end() ; i++)\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint dp[11][20][20][20];\nint n, a, b;\nint archer[11];\n\nint calc(int ind, int left, int mid, int right) {\n    if (ind == n - 1)\n        return max((left + a - 1) / a, (mid + b - 1) / b);\n\n    int& x = dp[ind][left][mid][right];\n\n    if (x != -1)\n        return x;\n\n    x = 1000000;\n\n    int cnt = (left + b - 1) / b;\n\n    for (int xx = cnt; xx <= 16; xx++) {\n        int nleft = max(0, mid - xx * a);\n        int nmid = max(0, right - xx * b);\n        int nright = archer[ind + 2];\n        x = min(calc(ind + 1, nleft, nmid, nright) + xx, x);\n    }\n\n    return x;\n}\n\nvector<int> v;\n\nvoid build(int ind, int left, int mid, int right) {\n    int c;\n\n    if (ind == n - 1) {\n        c = max((left + a - 1) / a, (mid + b - 1) / b);\n\n        for (int i = 0; i < c; i++)\n            v.push_back(ind);\n\n        return;\n    }\n\n    int cnt = (left + b - 1) / b;\n\n    for (int xx = cnt; xx <= 16; xx++) {\n        int nleft = max(0, mid - xx * a);\n        int nmid = max(0, right - xx * b);\n        int nright = archer[ind + 2];\n\n        if (calc(ind + 1, nleft, nmid, nright) + xx == calc(ind, left, mid, right)) {\n            for (int i = 0; i < xx; i++)\n                v.push_back(ind + 1);\n\n            build(ind + 1, nleft, nmid, nright);\n            return;\n        }\n    }\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""in.in"", ""rt"", stdin);\n#endif\n\n    while (scanf(""%d%d%d"", &n, &a, &b) != EOF) {\n        for (int i = 0; i < n; i++) {\n            scanf(""%d"", archer + i);\n            archer[i]++;\n        }\n\n        memset(dp, -1, sizeof(dp));\n        v.clear();\n        build(1, archer[0], archer[1], archer[2]);\n\n        printf(""%d\\n"", v.size());\n\n        for (int i = 0; i < v.size(); i++) {\n            if (i)\n                printf("" "");\n\n            printf(""%d"", v[i]);\n        }\n\n        printf(""\\n"");\n    }\n\n    return 0;\n}\n']","['brute force', 'dp']",2600
https://codeforces.com//contest/558/problem/B,B. Amr and The Large Array,Amr has got a large array of size Amr doesn t like large arrays so he intends to make it smaller Amr doesn t care about anything in the array except the beauty of it The beauty of the array is defined to be the maximum number of times that some number occurs in this array He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array Help Amr by choosing the smallest subsegment possible ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\nint i, j, k, n, m, x, cnt[N], l[N], r[N], ans, le, ri, aaa = inf;;\n\nint main(){\n\t\n\tscanf(""%d"",&n);\n\n\tmemset(l, 12, sizeof l);\n\n\tFOR(i,1,n) {\n\t\t\n\t\tscanf(""%d"",&x);\n\n\t\tl[x] = min(l[x], i);\n\t\tr[x] = max(r[x], i);\n\t\tcnt[x]++;\n\t\tans = max(cnt[x], ans);\n\n\t}\n\n\tFOR(i,1,N-1)\n\t\tif(cnt[i] == ans && r[i]-l[i]+1 < aaa) {\n\t\t\taaa = r[i] - l[i] + 1;\n\t\t\tle = l[i]; \n\t\t\tri = r[i];\n\t\t}\n\t\n\tcout << le << \' \' << ri << endl;\n\n    return 0;\n}\n']",['implementation'],1300
https://codeforces.com//contest/1796/problem/A,A. Typical Interview Problem,The FB string is formed as follows Initially it is empty We go through all positive integers starting from 1 in ascending order and do the following for each integer if the current integer is divisible by 3 append to the end of the FB string if the current integer is divisible by 5 append to the end of the FB string Note that if an integer is divisible by both 3 and 5 we append and then not in the opposite order The first 10 characters of the FB string are the first comes from the integer 3 the next character comes from 5 the next comes from the integer 6 and so on It s easy to see that this string is infinitely long Let f i be the i th character of FB string so f 1 is f 2 is f 3 is f 4 is and so on You are given a string s consisting of characters and or You have to determine whether it is a substring contiguous subsequence of the FB string In other words determine if it is possible to choose two integers l and r 1 le l le r so that the string f l f l 1 f l 2 dots f r is exactly s For example is a substring of the FB string if we pick l 3 and r 5 the string f 3 f 4 f 5 is exactly is a substring of the FB string if we pick l 2 and r 9 the string f 2 f 3 f 4 dots f 9 is exactly is not a substring of the FB string ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nint n,a[2000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\t\t\tstring t;\n\t\t\tfor(int j=1;j<=3000;j++)\n\t\t\t{\n\t\t\t\tif(j%3==0) t+=\'F\';\n\t\t\t\tif(j%5==0) t+=\'B\';\n\t\t\t}\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint flag=0;\n\t\tfor(int i=0;i<=100;i++)\n\t\t{\n\t\t\tif(t.substr(i,s.size())==s)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << ""YES\\n"";\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","['brute force', 'implementation', 'strings']",800
https://codeforces.com//contest/677/problem/B,B. Vanya and Food Processor,Vanya smashes potato in a vertical food processor At each moment of time the height of the potato in the processor doesn t exceed and the processor smashes centimeters of potato each second If there are less than centimeters remaining than during this second processor smashes all the remaining potato Vanya has pieces of potato the height of the th piece is equal to He puts them in the food processor one by one starting from the piece number and finishing with piece number Formally each second the following happens If there is at least one piece of potato remaining Vanya puts them in the processor one by one until there is not enough space for the next piece Processor smashes centimeters of potato or just everything that is inside Provided the information about the parameter of the food processor and the size of each potato in a row compute how long will it take for all the potato to become smashed ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,h,k;\nlong long ans;\nlong long a[1000000];\n\nvoid make(long long &x,long long y)\n{\n    long long kek=y/k;\n    if(y%k)\n        ++kek;\n    ans+=kek;\n    x-=k*kek;\n    if(x<0)\n        x=0;\n}\n\nint main()\n{\n    cin>>n>>h>>k;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    long long cur=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(cur+a[i]<=h)\n        {\n            cur+=a[i];\n            continue;\n        }\n        long long dif=cur+a[i]-h;\n        make(cur,dif);\n        cur+=a[i];\n    }\n    make(cur,cur);\n    cout<<ans<<""\\n"";\n}\n']","['implementation', 'math']",1400
https://codeforces.com//contest/571/problem/C,C. CNF 2, In Boolean logic a formula is in conjunctive normal form CNF or clausal normal form if it is a conjunction of clauses where a clause is a disjunction of literals cited from https en wikipedia org wiki Conjunctive normal form In the other words CNF is a formula of type where represents a logical AND conjunction represents a logical OR disjunction and are some boolean variables or their negations Each statement in brackets is called a and are called You are given a CNF containing variables and their negations We know that each variable occurs in at most two clauses with negation and without negation in total Your task is to determine whether this CNF is that is whether there are such values of variables where the CNF value is true If CNF is satisfiable then you also need to determine the values of the variables at which the CNF is true It is guaranteed that each variable occurs at most once in each clause ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 322000\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, k;\nvector<int> pe[N];\nvector<pair<int, int> > vs[N];\n\nvector<pair<int, int> > v[N];\n\nint ok[N], ans[N], take[N];\n\nint used[N];\n\nint match(int x) {\n\tok[x] = 1;\n\tint r = 0;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tif (used[v[x][i].S]) continue;\n\t\tused[v[x][i].S] = 1;\n\n\n\t\tint to = v[x][i].F;\n\t\tif (ok[to]) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\n\t\tint t = match(to);\n\t\tif (t == 1) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\t\ttake[v[x][i].S] = to;\n\t}\n\treturn r;\n}\n\nint main(){\n//\tfreopen(TASK"".in"",""r"",stdin);\t\n//\tfreopen(TASK"".out"",""w"",stdout);\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tint kk;\n\t\tscanf(""%d"", &kk);\n\t\tpe[i].resize(kk);\n\t\tfor (int j = 0; j < kk; j++) {\n\t\t\tscanf(""%d"", &pe[i][j]);\n\n\t\t\tvs[abs(pe[i][j])].pb(mp(i, pe[i][j] / abs(pe[i][j])));\n\t\t}\t\t\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (vs[i].size() == 0) continue;\n\n\t\tif (vs[i].size() == 1) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (vs[i][0].S == vs[i][1].S) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tok[abs(vs[i][1].F)] = 1;\n\t\t} else {\n\t\t\tint x = abs(vs[i][0].F);\n\t\t\tint y = abs(vs[i][1].F);\n\n\t\t\tv[x].pb(mp(y, i));\n\t\t\tv[y].pb(mp(x, i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= k; i++) take[i] = -1;\n\tfor (int i = 0; i < n; i++) if (!ok[i]) {\n\t\tint h = match(i);\n\t\tif (h == 0) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""YES"");\n\tfor (int i = 1; i <= k; i++) if (take[i] != -1) {\n\t\tfor (int j = 0; j < vs[i].size(); j++) if (vs[i][j].F == take[i]) {\n\t\t\tans[i] = vs[i][j].S;\n\t\t}\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (ans[i] == -1) ans[i] = 0;\n\t\tprintf(""%d"", ans[i]);\n\t}\n\tputs("""");\n\treturn 0;\n}\n\n\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']",2500
https://codeforces.com//contest/1137/problem/B,B. Camp Schedule,The new camp by widely known over the country Spring Programming Camp is going to start soon Hence all the team of friendly curators and teachers started composing the camp s schedule After some continuous discussion they came up with a schedule s which can be represented as a binary string in which the i th symbol is if students will write the contest in the i th day and if they will have a day off At the last moment Gleb said that the camp will be the most productive if it runs with the schedule t which can be described in the same format as schedule s Since the number of days in the current may be different from number of days in schedule t Gleb required that the camp s schedule must be altered so that the number of occurrences of t in it as a substring is maximum possible At the same time only their order may change Could you rearrange the schedule in the best possible way ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nvector<int> kmp(const T &a) {\n  int n = a.size();\n  vector<int> fail(n);\n  fail[0] = -1;\n  for (int i = 1; i < n; ++i) {\n    fail[i] = fail[i - 1];\n    while (~fail[i] && a[fail[i] + 1] != a[i]) {\n      fail[i] = fail[fail[i]];\n    }\n    if (a[fail[i] + 1] == a[i]) {\n      ++fail[i];\n    }\n  }\n  return fail;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  string s, t;\n  cin >> s >> t;\n  int zero = 0, one = 0;\n  for (auto c : s) {\n    if (c == \'0\') {\n      ++zero;\n    } else {\n      ++one;\n    }\n  }\n  vector<int> fail = kmp(t);\n  int cur = 0;\n  while (zero || one) {\n    if (!zero) {\n      cout << 1;\n      --one;\n    } else if (!one) {\n      cout << 0;\n      --zero;\n    } else {\n      cout << t[cur];\n      if (t[cur] == \'0\') {\n        --zero;\n      } else {\n        --one;\n      }\n      ++cur;\n      if (cur == (int) t.size()) {\n        cur = fail.back() + 1;\n      }\n    }\n  }\n  cout << ""\\n"";\n  return 0;\n}\n']","['greedy', 'hashing', 'strings']",1600
https://codeforces.com//contest/1896/problem/G,G. Pepe Racing,There are n 2 pepes labeled 1 2 ldots n 2 with speeds You would like to set up some races to find out the relative speed of these pepes In one race you can choose exactly n distinct pepes and make them race against each other After each race you will only know the pepe of these n pepes Can you order the n 2 n 1 fastest pepes in 2n 2 2n 1 races Note that the slowest n 1 pepes are indistinguishable from each other Note that the interactor is That is the relative speeds of the pepes are not fixed in the beginning and may depend on your queries But it is guaranteed that at any moment there is at least one initial configuration of pepes such that all the answers to the queries are consistent ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint pyt(vi wek)\n{\n\tprintf(""?"");\n\tfor (int i : wek)\n\t\tprintf("" %d"", i);\n\tprintf(""\\n"");\n\tff();\n\tint ret;\n\tscanf(""%d"", &ret);\n\treturn ret;\n}\n\nvoid ans(vi wek)\n{\n\tprintf(""!"");\n\tfor (int i : wek)\n\t\tprintf("" %d"", i);\n\tprintf(""\\n"");\n\tff();\n}\n\nvi stos[nax];\n\nvoid usun(vi &wek, int v)\n{\n\tfor (int &i : wek)\n\t{\n\t\tif (i==v)\n\t\t{\n\t\t\tswap(i, wek.back());\n\t\t\twek.pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(0);\n}\n\nvoid cionk(vi &wek, int v)\n{\n\tfor (int &i : wek)\n\t{\n\t\tif (i==v)\n\t\t{\n\t\t\tswap(i, wek.back());\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(0);\n}\n\nbool mniej(vi a, vi b)\n{\n\treturn a.size()>b.size();\n}\n\nvoid popraw(vi &wek)\n{\n\tint x=pyt(wek);\n\tcionk(wek, x);\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tstos[i].clear();\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tstos[i].push_back((i-1)*n+j);\n\tvi res;\n\tfor (int i=1; i<=n; i++)\n\t\tpopraw(stos[i]);\n\t//~ while((int)res.size()<n*n-n+1)\n\twhile((int)res.size()<n*n-2*n)\n\t{\n\t\tvi ter;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tter.push_back(stos[i].back());\n\t\tint x=pyt(ter);\n\t\tres.push_back(x);\n\t\t{\n\t\t\tint g=1;\n\t\t\twhile((int)stos[g].back()!=x)\n\t\t\t\tg++;\n\t\t\tswap(stos[g], stos[1]);\n\t\t}\n\t\tsort(stos+2, stos+n+1, mniej);\n\t\t\n\t\tstos[1].pop_back();\n\t\tfor (int i=2; i<=n; i++)\n\t\t{\n\t\t\twhile((int)stos[1].size()<n && (int)stos[i].size()>2)\n\t\t\t{\n\t\t\t\tint y=stos[i][0];\n\t\t\t\tstos[i].erase(stos[i].begin());\n\t\t\t\tstos[1].push_back(y);\n\t\t\t}\n\t\t}\n\t\tif ((int)stos[1].size()==n)\n\t\t{\n\t\t\tpopraw(stos[1]);\n\t\t\tcontinue;\n\t\t}\n\t\tvi tu=stos[1];\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tif ((int)tu.size()<n)\n\t\t\t\ttu.push_back(stos[i][0]);\n\t\tint wez=pyt(tu);\n\t\tint g=2;\n\t\twhile(g<=n && stos[g][0]!=wez)\n\t\t\tg++;\n\t\tif (g>n)\n\t\t{\n\t\t\tcionk(stos[1], wez);\n\t\t\tcontinue;\n\t\t}\n\t\tswap(stos[1].back(), stos[g][0]);\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tassert((int)stos[i].size()==2);\n\t\n\twhile((int)res.size()<n*n-n)\n\t{\n\t\tvi ter;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tter.push_back(stos[i].back());\n\t\tint x=pyt(ter);\n\t\tres.push_back(x);\n\t\tint g=1;\n\t\twhile(stos[g].back()!=x)\n\t\t\tg++;\n\t\tstos[g].pop_back();\n\t\tif (stos[g].empty())\n\t\t{\n\t\t\tint d=1;\n\t\t\twhile((int)stos[d].size()!=2)\n\t\t\t\td++;\n\t\t\tstos[g].push_back(stos[d].back());\n\t\t\tstos[d].pop_back();\n\t\t}\n\t}\n\t{\n\t\tvi ter;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tter.push_back(stos[i].back());\n\t\tint x=pyt(ter);\n\t\tres.push_back(x);\n\t}\n\tans(res);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation', 'interactive', 'sortings']",3200
https://codeforces.com//contest/488/problem/B,B. Candy Boxes,There is an old tradition of keeping boxes of candies in the house in Cyberland The numbers of candies are if their their and their are all equal By definition for a set is is and is It is well known that if those three numbers are same boxes will create a debugging field and codes in the field will have no bugs For example is the example of numbers meeting the condition because their mean median and range are all equal to Jeff has special boxes of candies However something bad has happened Some of the boxes could have been lost and now there are only boxes remaining The th remaining box contains candies Now Jeff wants to know is there a possible way to find the number of candies of the missing boxes meeting the condition above the mean median and range are equal ,"['#define _CRT_SECURE_NO_WARNINGS\n#if 1\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst LD eps = 1e-9;\nconst LD pi = acos(-1.0);\nconst LL inf = 1e+9;\n\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n\n#define dbg(x) { cerr << #x << "" = "" << x << endl; }\n\n// extended template\n#pragma comment(linker, ""/STACK:36777216"")\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\ntemplate<typename T> istream & operator >> (istream &, vector<T> &);\ntemplate<typename T> ostream & operator << (ostream &, const vector<T> &);\n\n#define START clock_t _clock = clock();\n#define END cerr << endl << ""time: "" << (clock() - _clock) / LD(CLOCKS_PER_SEC) << endl;\n\n#define NAME ""problem""\n\nvoid d(int i){\n    if (i == 4){\n\n    }\n}\n\nbool check(int a, int b, int c, int d){\n    return (d == 3 * a && b + c == a + d);\n}\n\nvoid solve(){\n    int n, a[4];\n    cin >> n;\n    memset(a, 0, sizeof(a));\n    forn(i, n) cin >> a[i];\n\n    if (n == 0){\n        cout << ""YES"" << endl;\n        cout << 1 << endl << 1 << endl << 3 << endl << 3 << endl;\n        return;\n    }\n\n    if (n == 1){\n        cout << ""YES"" << endl;\n        cout << a[0] << endl << 3 * a[0] << endl << 3 * a[0] << endl;\n        return;\n    }\n\n    sort(a, a + n);\n    int u = a[0];\n    int v = a[n - 1];\n\n    if (v > 3 * u){\n        cout << ""NO"" << endl;\n        return;\n    }\n\n    if (n == 2){\n        if (v == 3 * u){\n            cout << ""YES"" << endl;\n            cout << a[0] << endl << 3 * a[0] << endl;\n            return;\n        }\n\n        cout << ""YES"" << endl;\n        cout << 4 * a[0] - a[1] << endl << 3 * a[0] << endl;\n        return;\n    }\n\n    if (n == 3){\n        int res;\n        \n        if (a[2] % 3 == 0){\n            res = a[2] / 3;\n            if (check(res, a[0], a[1], a[2])){\n                cout << ""YES"" << endl << res << endl;\n                return;\n            }\n        }\n\n        if (a[2] == 3 * a[0]){\n            if (check(a[0], a[1], a[2] + a[0] - a[1], a[2])){\n                cout << ""YES"" << endl << a[2] + a[0] - a[1] << endl;\n                return;\n            }\n        }\n\n        res = 3 * a[0];\n        if (check(a[0], a[1], a[2], res)){\n            cout << ""YES"" << endl << res << endl;\n            return;\n        }\n\n        cout << ""NO"" << endl;\n        return;\n    }\n\n    if (n == 4){\n        if (check(a[0], a[1], a[2], a[3])) cout << ""YES"" << endl;\n        else cout << ""NO"" << endl;\n        return;\n    }\n    cout << ""NO"" << endl;\n}\n\nint main()\n{\n    // freopen(NAME "".in"", ""r"", stdin); freopen(NAME "".out"", ""w"", stdout);\n    // freopen(""input.txt"", ""r"", stdin); // freopen(""output.txt"", ""w"", stdout);\n\n    solve();\n\n    return 0;\n}\n/*******************************************\n*******************************************/\n\ntemplate<typename T> istream & operator >> (istream &is, vector<T> &v)\n{\n    forn(i, v.size())\n        is >> v[i];\n    return is;\n}\ntemplate<typename T> ostream & operator << (ostream &os, const vector<T> &v)\n{\n    forn(i, v.size())\n        os << v[i] << "" "";\n    return os;\n}\n#endif']","['brute force', 'constructive algorithms', 'math']",1900
https://codeforces.com//contest/466/problem/B,B. Wonder Room,The start of the new academic year brought about the problem of accommodation students into dormitories One of such dormitories has a square meter wonder room The caretaker wants to accommodate exactly students there But the law says that there must be at least 6 square meters per student in a room that is the room for students must have the area of at least square meters The caretaker can enlarge any possibly both side of the room by an arbitrary positive integer of meters Help him change the room so as all students could live in it and the total area of the room was as small as possible ,"['#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MAXN 100005\n#define INF 0x7fffffffffffffffLL\nusing namespace std ;\ntypedef long long LL ;\n\nLL A, B, N, sq ;\nLL ta, tb, ba, bb, ans = INF ;\n\nint main()\n{\n\tint i, j ;\n\tscanf(""%I64d %I64d %I64d"", &N, &A, &B) ;\n\tN *= 6,\tsq = sqrt(N)+3 ;\n\tfor(ta = A; ta <= max(A, sq); ta ++)\n\t{\n\t\ttb = max(B, N/ta+(N%ta!=0)) ;\n\t\tif(ta*tb < ans) ans = ta*tb, ba = ta, bb = tb ;\n\t}\n\tfor(tb = B; tb <= max(B, sq); tb ++)\n\t{\n\t\tta = max(A, N/tb+(N%tb!=0)) ;\n\t\tif(ta*tb < ans) ans = ta*tb, ba = ta, bb = tb ;\n\t}\n\tprintf(""%I64d\\n%I64d %I64d\\n"", ans, ba, bb) ;\n\t//system(""pause"") ;\n\treturn 0 ;\n}\n']","['brute force', 'math']",2000
https://codeforces.com//contest/215/problem/A,A. Bicycle Chain,Vasya s bicycle chain drive consists of two parts stars are attached to the pedal axle stars are attached to the rear wheel axle The chain helps to rotate the rear wheel by transmitting the pedal rotation We know that the th star on the pedal axle has teeth and the th star on the rear wheel axle has teeth Any pair is called a and sets the indexes of stars to which the chain is currently attached Gear has a gear ratio equal to the value Since Vasya likes integers he wants to find such gears that their ratios are integers On the other hand Vasya likes fast driving so among all integer gears he wants to choose a gear with the maximum ratio Help him to find the number of such gears In the problem fraction denotes division in real numbers that is no rounding is performed ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,a[100],b[100];\nint main()\n{\n    while(~scanf(""%d"",&n))\n    {\n        for(int i=1;i<=n;i++)\n        scanf(""%d"",&a[i]);\n        scanf(""%d"",&m);\n        for(int i=1;i<=m;i++)\n        scanf(""%d"",&b[i]);\n        int ma=0;\n        for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        if(b[j]%a[i]==0)\n        {\n            ma=max(ma,b[j]/a[i]);\n        }\n        int ans=0;\n        for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        if(b[j]%a[i]==0&&b[j]/a[i]==ma)ans++;\n        printf(""%d\\n"",ans);\n    }\n}\n']","['brute force', 'implementation']",900
https://codeforces.com//contest/1436/problem/B,B. Prime Square,Sasha likes investigating different math objects for example magic squares But Sasha understands that magic squares have already been studied by hundreds of people so he sees no sense of studying them further Instead he invented his own type of square a prime square A square of size n times n is called prime if the following three conditions are held simultaneously all numbers on the square are non negative integers not exceeding 10 5 there are no prime numbers in the square sums of integers in each row and each column are prime numbers Sasha has an integer n He asks you to find any prime square of size n times n Sasha is absolutely sure such squares exist so just help him ,"['//#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\n#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include ""debug-template.hpp""\n#endif\n\nusing namespace std;\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint ncase;\n\tfor (cin >> ncase; ncase--; ) {\n\t\tint n; cin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (j == i || (j + 1) % n == i) {\n\t\t\t\t\tcout << 1 << \' \';\n\t\t\t\t} else {\n\t\t\t\t\tcout << 0 << \' \';\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'math']",900
https://codeforces.com//contest/571/problem/D,D. Campus,Oscolcovo city has a campus consisting of student dormitories universities and military offices Initially the th dormitory belongs to the th university and is assigned to the th military office Life goes on and the campus is continuously going through some changes The changes can be of four types University merges with university After that all the dormitories that belonged to university are assigned to to university and university disappears Military office merges with military office After that all the dormitories that were assigned to military office are assigned to military office and military office disappears Students of university move in dormitories Lets is the number of dormitories that belong to this university at the time when the students move in Then the number of students in each dormitory of university increases by note that the more dormitories belong to the university the more students move in each dormitory of the university Military office number conducts raids on all the dormitories assigned to it and takes all students from there Thus at each moment of time each dormitory is assigned to exactly one university and one military office Initially all the dormitory are empty Your task is to process the changes that take place in the campus and answer the queries how many people currently live in dormitory ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 1511111\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m, V1, V2;\n\nchar type[N];\nint x[N], y[N];\n\nint in1[N], in2[N], out1[N], out2[N];\n\nint n1[N], n2[N];\n\nint par1[N], par2[N];\n\npair<int, int> chi1[N], chi2[N];\n\nlong long su[N], ans[N];\n\nvector<int> po[N];\n\nint T;\n\nint tz[N];\n\n\nvoid add(int x, int v) {\n\twhile (x < n) {\n\t\tsu[x] += v;\n\t\tx |= (x + 1);\t\t\n\t}\n}\n\nlong long fin(int x) {\n\tlong long r = 0;\n\twhile (x >= 0) {\n\t\tr += su[x];\n\t\tx = (x & (x + 1)) - 1;\n\t}\n\treturn r;\n}\n\n\n\nvoid go1(int x) {\n\tin1[x] = T;\n\tif (x < n) T++; else {\n\n\t\tgo1(chi1[x].F);\n\t\tgo1(chi1[x].S);\n\t}\t\t\n\n\tout1[x] = T - 1;\n}\n\nvoid go2(int x) {\n\tin2[x] = T;\n\tif (x < n) T++; else {\n\n\t\tgo2(chi2[x].F);       \n\t\tgo2(chi2[x].S);\n\t}\t\t\n\n\tout2[x] = T - 1;\n}\n\n\nint main(){\n//\tfreopen(TASK"".in"",""r"",stdin);\t\n//\tfreopen(TASK"".out"",""w"",stdout);\n\tscanf(""%d%d\\n"", &n, &m);\n\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%c"", &type[i]);\n\t\tif (type[i] == \'A\' || type[i] == \'Z\' || type[i] == \'Q\') {\n\t\t\tscanf(""%d\\n"", &x[i]);\n\t\t\tx[i]--;\n\t\t} else {\n\t\t\tscanf(""%d%d\\n"", &x[i], &y[i]);\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t}\n\t}\n\tV1 = V2 = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tn1[i] = n2[i] = i;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (type[i] == \'U\') {\n\t\t\tchi1[V1] = mp(n1[x[i]], n1[y[i]]);\n\n\t\t\tpar1[n1[x[i]]] = V1;\n\t\t\tpar1[n1[y[i]]] = V1;\n\t\t\tn1[x[i]] = V1;\n\t\t\tn1[y[i]] = V1;\n\t\t\tV1++;\n\t\t}\n\t\tif (type[i] == \'M\') {\n\t\t\tchi2[V2] = mp(n2[x[i]], n2[y[i]]);\n\n\t\t\tpar2[n2[x[i]]] = V2;\n\t\t\tpar2[n2[y[i]]] = V2;\n\t\t\tn2[x[i]] = V2;\n\t\t\tn2[y[i]] = V2;\n\t\t\tV2++;\n\t\t}\n\t}\n\tT = 0;\n\tfor (int i = 0; i < V1; i++) if (par1[i] == 0) go1(i);\n\tT = 0;\n\tfor (int i = 0; i < V2; i++) if (par2[i] == 0) go2(i);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tn2[i] = i;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (type[i] == \'M\') {\n\t\t\tn2[x[i]] = par2[n2[x[i]]];\n\t\t\tn2[y[i]] = par2[n2[y[i]]];\n\t\t}\n\t\tif (type[i] == \'Z\') {\n\t\t\ttz[i] = n2[x[i]];\n\t\t}\n\t}\n\tset<pair<int, int> > Q;\n\tset<pair<int, int> >::iterator it, it2;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (type[i] == \'Q\') {\n\t\t\tQ.insert(mp(in2[x[i]], i));\n\t\t}\n\t\tif (type[i] == \'Z\') {\n\t\t\tint A = in2[tz[i]];\n\t\t\tint B = out2[tz[i]];\n\t\t\tit = Q.lower_bound(mp(A, 0));\n\t\t\twhile (it != Q.end() && (it -> F) <= B) {\n\t\t\t\tpo[i].pb(it -> S);\n\t\t\t\tit2 = it;\n\t\t\t\tit++;\n\t\t\t\tQ.erase(it2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tn1[i] = i;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (type[i] == \'U\') {\n\t\t\tn1[x[i]] = par1[n1[x[i]]];\n\t\t\tn1[y[i]] = par1[n1[y[i]]];\t\t\t\n\t\t}\n\t\tif (type[i] == \'A\') {\n\t\t\tint sz = out1[n1[x[i]]] - in1[n1[x[i]]] + 1;\n\t\t\tadd(in1[n1[x[i]]], sz);\n\t\t\tadd(out1[n1[x[i]]] + 1, -sz);\n\t\t}\n\t\tfor (int j = 0; j < po[i].size(); j++) {\n\t\t\tint v = in1[x[po[i][j]]];\n\t\t\tans[po[i][j]] -= fin(v);\n\t\t}\n\t\tif (type[i] == \'Q\') {\n\t\t\tint v = in1[x[i]];\n\t\t\tans[i] += fin(v);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) if (type[i] == \'Q\') printf(""%I64d\\n"", ans[i]);\n\n\treturn 0;\n}\n\n\n\n\n\n\n']","['binary search', 'data structures', 'dsu', 'trees']",3100
https://codeforces.com//contest/1592/problem/C,C. Bakry and Partitioning,Bakry faced a problem but since he s lazy to solve it he asks for your help You are given a tree of n nodes the i th node has value a i assigned to it for each i from 1 to n As a reminder a tree on n nodes is a connected graph with n 1 edges You want to delete from the tree so that the following condition would hold For every connected component calculate the bitwise XOR of the values of the nodes in it Then these values have to be the same for all connected components Is it possible to achieve this condition ,"['#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,l,a[100005],f[100005],ban,s;\nint hd[100005],nxt[200005],to[200005],tot;\nvoid add(int x,int y)\n{\n\ttot++;nxt[tot]=hd[x];to[tot]=y;hd[x]=tot;\n}\nint dfs(int x,int fa)\n{\n\tf[x]=a[x];\n\tint i;\n\tfor(i=hd[x];i;i=nxt[i])if(to[i]!=fa&&to[i]!=ban)\n\t{\n\t\tint t=dfs(to[i],x);\n\t\tif(t)return t;\n\t\tf[x]^=f[to[i]];\n\t}\n\tif(f[x]==s)return x;\n\treturn 0;\n}\nvoid solve()\n{\n\tcin>>n>>l;\n\trep(i,n) hd[i]=0;\n\ts=0;\n\trep(i,n)\n\t{\n\t\tcin>>a[i];\n\t\ts^=a[i];\n\t}\n\ttot=0;\n\trep(i,n-1)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tif(s==0)\n\t{\n\t\tputs(""YES"");\n\t\treturn;\n\t}\n\tif(l==2)\n\t{\n\t\tputs(""NO"");\n\t\treturn;\n\t}\n\tban=0;\n\tif(!(ban=dfs(1,0))||ban==1)\n\t{\n\t\tputs(""NO"");\n\t\treturn;\n\t}\n\tif(dfs(1,0)<=1)\n\t{\n\t\tputs(""NO"");\n\t\treturn;\n\t}\n\tputs(""YES"");\n}\nint main()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}']","['bitmasks', 'constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'trees']",1700
https://codeforces.com//contest/1181/problem/C,C. Flag,Innokenty works at a flea market and sells some rare items Recently he found an old rectangular blanket It turned out that the blanket is split in n cdot m colored pieces that form a rectangle with n rows and m columns The colored pieces attracted Innokenty s attention so he immediately came up with the following business plan If he cuts out a subrectangle consisting of three colored stripes he can sell it as a flag of some country Innokenty decided that a subrectangle is similar enough to a flag of some country if it consists of three stripes of heights placed one above another where each stripe consists of cells of equal color Of course the color of the top stripe must be different from the color of the middle stripe and the color of the middle stripe must be different from the color of the bottom stripe Innokenty has not yet decided what part he will cut out but he is sure that the flag s boundaries should go along grid lines Also Innokenty won t rotate the blanket Please help Innokenty and count the number of different subrectangles Innokenty can cut out and sell as a flag Two subrectangles located in different places but forming the same flag are still considered different ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=1e3;\nint n, m, nxt[mxN][mxN];\nstring g[mxN];\n\nstruct fd {\n\tint l;\n\tchar c[3];\n\tbool operator==(const fd &o) const {\n\t\treturn l==o.l&&c[0]==o.c[0]&&c[1]==o.c[1]&&c[2]==o.c[2];\n\t}\n} ff[mxN];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> g[i];\n\tfor(int j=0; j<m; ++j)\n\t\tnxt[n-1][j]=n;\n\tfor(int i=n-2; ~i; --i)\n\t\tfor(int j=0; j<m; ++j)\n\t\t\tnxt[i][j]=g[i][j]==g[i+1][j]?nxt[i+1][j]:i+1;\n\tint ans=0;\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<m; ++j) {\n\t\t\tint i2=nxt[i][j], i3=i2<n?nxt[i2][j]:n, i4=i3<n?nxt[i3][j]:n;\n\t\t\tff[j].l=nxt[i][j]-i;\n\t\t\tif(i3-i2!=ff[j].l||i4-i3<ff[j].l)\n\t\t\t\tff[j].l=-1;\n\t\t\tff[j].c[0]=g[i][j];\n\t\t\tif(i2<n)\n\t\t\t\tff[j].c[1]=g[i2][j];\n\t\t\tif(i3<n)\n\t\t\t\tff[j].c[2]=g[i3][j];\n\t\t}\n\t\tfor(int j=0, k=0; j<m; j=k) {\n\t\t\tfor(; k<m&&ff[k]==ff[j]; ++k);\n\t\t\tif(~ff[j].l)\n\t\t\t\tans+=(k-j)*(k-j+1)/2;\n\t\t}\n\t}\n\tcout << ans;\n}']","['brute force', 'combinatorics', 'dp', 'implementation']",1900
https://codeforces.com//contest/121/problem/E,E. Lucky Array,Petya has an array consisting of numbers He wants to perform operations of two types add an integer to all elements whose indexes belong to the interval from to inclusive find and print on the screen how many lucky numbers there are among elements with indexes that belong to the interval from to inclusive Each lucky number should be counted as many times as it appears in the interval Petya has a list of all operations The operations are such that after all additions the array won t have numbers that would exceed Help Petya write a program that would perform these operations ,"['#include <algorithm>\n#include <iostream>\n#include <assert.h>\n#include <sstream>\n#include <complex>\n#include <numeric>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define all(a)                  (a).begin(), (a).end()\n#define sz(a)                   int((a).size())\n#define FOR(i, a, b)    for (int i(a); i < b; ++i)\n#define REP(i, n)               FOR(i, 0, n)\n#define UN(v)                   sort(all(v)), (v).erase(unique((v).begin(), (v).end()), (v).end())\n#define CL(a, b)                memset(a, b, sizeof a)\n#define pb                              push_back\n#define X                               first\n#define Y                               second\n\ntypedef long long ll;\ntypedef vector <int> vi;\ntypedef pair <int, int> pii;\n\nbool lucky[10000];\n\nint a[100500];\nint n, m;\n\nint f[200500];\n\nvoid put(int i, int d) {\n        d -= f[i += n];\n        if (d) {\n                for (; i; i /= 2) {\n                        f[i] += d;\n                }\n        }\n}\n\nint sum(int i, int j) {\n        int res = 0;\n        for (i += n, j += n; i <= j; i = (i + 1) / 2, j = (j - 1) / 2) {\n                if (i & 1) res += f[i];\n                if (~j & 1) res += f[j];\n        }\n        return res;\n}\n\nint main() {\n        lucky[0] = true;\n        FOR (i, 1, 10000) {\n                lucky[i] = (i % 10 == 4 || i % 10 == 7) && lucky[i / 10];\n        }\n        scanf(""%d%d"", &n, &m);\n        REP (i, n) {\n                scanf(""%d"", a + i);\n                put(i, lucky[a[i]]);\n        }\n        for (; m --> 0; ) {\n                char q[8];\n                int x, y;\n                scanf(""%s%d%d"", q, &x, &y);\n                --x;\n                --y;\n                if (q[0] == \'c\') {\n                        printf(""%d\\n"", sum(x, y));\n                } else {\n                        int d;\n                        scanf(""%d"", &d);\n                        for (; x <= y; ++x) {\n                                put(x, lucky[a[x] += d]);\n                        }\n                }\n        }\n        return 0;\n}']",['data structures'],2400
https://codeforces.com//contest/1557/problem/D,D. Ezzat and Grid,Moamen was drawing a grid of n rows and 10 9 columns containing only digits 0 and 1 Ezzat noticed what Moamen was drawing and became interested in the minimum number of rows one needs to remove to make the grid beautiful A grid is beautiful if and only if for every two consecutive rows there is at least one column containing 1 in these two rows Ezzat will give you the number of rows n and m segments of the grid that contain digits 1 Every segment is represented with three integers i l and r where i represents the row number and l and r represent the first and the last column of the segment in that row For example if n 3 m 6 and the segments are 1 1 1 1 7 8 2 7 7 2 15 15 3 1 1 3 15 15 then the grid is Your task is to tell Ezzat the minimum number of rows that should be removed to make the grid beautiful ,"['#include<bits/stdc++.h>\n#include <algorithm>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int,int> pr;\n#define mp make_pair\npr op(pr x,pr y){\n\treturn max(x,y);\n}\npr e(){\n\treturn mp(0,0);\n}\nlazy_segtree<pr,op,e,pr,op,op,e> tr(600005);\nint n,m,b[600005],is[600005];\npr f[600005],ans;\nvector<pr> seg[600005];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1,x,l,r;i<=m;i++){\n\t\tscanf(""%d%d%d"",&x,&l,&r),b[++b[0]]=l,b[++b[0]]=r,seg[x].push_back(mp(l,r));\n\t}\n\tsort(b+1,b+b[0]+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(auto &j:seg[i])j.first=lower_bound(b+1,b+b[0]+1,j.first)-b,j.second=lower_bound(b+1,b+b[0]+1,j.second)-b;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=mp(1,0);\n\t\tfor(auto j:seg[i]){\n\t\t\tpr tmp=tr.prod(j.first,j.second+1);\n\t\t\tf[i]=max(f[i],mp(tmp.first+1,tmp.second));\n\t\t}\n\t\tans=max(ans,mp(f[i].first,i));\n\t\tfor(auto j:seg[i])tr.apply(j.first,j.second+1,mp(f[i].first,i));\n\t\t//cout<<i<<\' \'<<f[i].first<<\'\\n\';\n\t}\n\tcout<<n-ans.first<<\'\\n\';\n\tint p=ans.second;\n\twhile(p)is[p]=1,p=f[p].second;\n\tfor(int i=1;i<=n;i++)if(!is[i])cout<<i<<\' \';\n}']","['data structures', 'dp', 'greedy']",2200
https://codeforces.com//contest/1622/problem/B,B. Berland Music,Berland Music is a music streaming service built specifically to support Berland local artist Its developers are currently working on a song recommendation module So imagine Monocarp got recommended n songs numbered from 1 to n The i th song had its predicted rating equal to p i where 1 le p i le n and every integer from 1 to n appears exactly once In other words p is a permutation After listening to each of them Monocarp pressed either a like or a dislike button Let his vote sequence be represented with a string s such that s i 0 means that he disliked the i th song and s i 1 means that he liked it Now the service has to re evaluate the song ratings in such a way that the new ratings q 1 q 2 dots q n still form a permutation 1 le q i le n each integer from 1 to n appears exactly once every song that Monocarp liked should have a greater rating than every song that Monocarp disliked formally for all i j such that s i 1 and s j 0 q i q j should hold Among all valid permutations q find the one that has the smallest value of sum limits i 1 n p i q i where x is an absolute value of x Print the permutation q 1 q 2 dots q n If there are multiple answers you can print any of them ,"['/**\n *    author:  tourist\n *    created: 27.12.2021 17:36:35       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n    }\n    string s;\n    cin >> s;\n    vector<int> res(n, -1);\n    int ptr = 0;\n    for (int r = 0; r <= 1; r++) {\n      vector<pair<int, int>> a;\n      for (int i = 0; i < n; i++) {\n        if ((int) (s[i] - \'0\') == r) {\n          a.emplace_back(p[i], i);\n        }\n      }\n      sort(a.begin(), a.end());\n      for (auto& p : a) {\n        res[p.second] = ++ptr;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (i > 0) {\n        cout << "" "";\n      }\n      cout << res[i];\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']","['data structures', 'greedy', 'math', 'sortings']",1000
https://codeforces.com//contest/1142/problem/A,A. The Beatles,Recently a Golden Circle of Beetlovers was found in Byteland It is a circle route going through n cdot k cities The cities are numerated from 1 to n cdot k the distance between the neighboring cities is exactly 1 km Sergey does not like beetles he loves burgers Fortunately for him there are n fast food restaurants on the circle they are located in the 1 st the k 1 st the 2k 1 st and so on the n 1 k 1 st cities i e the distance between the neighboring cities with fast food restaurants is k km Sergey began his journey at some city s and traveled along the circle making stops at cities each l km l 0 until he stopped in s once again Sergey then forgot numbers s and l but he remembers that the distance from the city s to the nearest fast food restaurant was a km and the distance from the city he stopped at after traveling the first l km from s to the nearest fast food restaurant was b km Sergey always traveled in the same direction along the circle but when he calculated distances to the restaurants he considered both directions Now Sergey is interested in two integers The first integer x is the minimum number of stops excluding the first Sergey could have done before returning to s The second integer y is the maximum number of stops excluding the first Sergey could have done before returning to s ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tll n, k, a, b;\n\tcin >> n >> k >> a >> b;\n\tll ans1 = n * k + 1, ans2 = 0;\n\n\tfor (int f = 0; f < 2; f++)\n\t\tfor (int g = 0; g < 2; g++) {\n\t\t\tll x = a, y = b;\n\t\t\tif (f == 1) x = (k - a) % k;\n\t\t\tif (g == 1) y = (k - b) % k;\n\t\t\tx -= y;\n\t\t\tif (x < 0) x += k;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ty = x + i * k;\t\n\t\t\t\ty = gcd(y, n * k);\n\t\t\t\ty = (n * k) / y;\n\t\t\t\tans1 = min(ans1, y);\n\t\t\t\tans2 = max(ans2, y);\n\t\t\t}\n\t\t}\n\tcout << ans1 << "" "" << ans2 << endl;\n\n\treturn 0;\n}\n']","['brute force', 'math']",1700
https://codeforces.com//contest/453/problem/B,B. Little Pony and Harmony Chest,Princess Twilight went to Celestia and Luna s old castle to research the chest from the Elements of Harmony A sequence of positive integers is harmony if and only if for every two elements of the sequence their greatest common divisor equals 1 According to an ancient book the key of the chest is a harmony sequence which minimizes the following expression You are given sequence help Princess Twilight to find the key ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXV 62\n#define INF 0x3FFFFFFF\n\nint N;\nint A[110];\nint M[MAXV];\nint low;\nvector<int> P;\n\nint memo[110][1 << 10][10];\n\nint solve(int x, int m) {\n  if(__builtin_popcount((m >> low) + 1) != 1) return INF;\n  if(x == N) return 0;\n\n  int& ref = memo[x][m & ((1 << low) - 1)][__builtin_popcount(m >> low)];\n  if(ref != -1) return ref;\n\n  ref = INF;\n  for(int i = 1; i < MAXV; i++) {\n    if((M[i] & m) == 0) {\n      ref = min(ref, abs(A[x] - i) + solve(x + 1, m | M[i]));\n    }\n  }\n  return ref;\n}\n\nvoid recover(int x, int m) {\n  if(x == N) return;\n\n  int val = solve(x, m);\n  for(int i = 1; i < MAXV; i++) {\n    if((M[i] & m) == 0) {\n      if(abs(A[x] - i) + solve(x + 1, m | M[i]) == val) {\n        if(x) cout << ' ';\n        cout << i;\n        recover(x + 1, m | M[i]);\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  for(int p = 2; p < MAXV; p++) {\n    bool isp = true;\n    for(int i = 2; i < p && isp; i++) {\n      isp = p % i != 0;\n    }\n    if(isp) {\n      P.push_back(p);\n      if(p <= 30) low++;\n    }\n  }\n\n  for(int i = 1; i < MAXV; i++) {\n    M[i] = 0;\n    for(int j = 0; j < P.size(); j++) {\n      if(i % P[j] == 0) {\n        M[i] |= 1 << j;\n      }\n    }\n  }\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n  }\n\n  memset(memo, -1, sizeof(memo));\n  recover(0, 0);\n  cout << endl;\n  return 0;\n}\n""]","['bitmasks', 'brute force', 'dp']",2000
https://codeforces.com//contest/1113/problem/A,A. Sasha and His Trip,Sasha is a very happy guy that s why he is always on the move There are n cities in the country where Sasha lives They are all located on one straight line and for convenience they are numbered from 1 to n in increasing order The distance between any two adjacent cities is equal to 1 kilometer Since all roads in the country are directed it s possible to reach the city y from the city x only if x y Once Sasha decided to go on a trip around the country and to visit all n cities He will move with the help of his car The tank capacity of this model is v liters and it spends exactly 1 liter of fuel for 1 kilometer of the way At the beginning of the journey the tank is empty Sasha is located in the city with the number 1 and wants to get to the city with the number n There is a gas station in each city In the i th city the price of 1 liter of fuel is i dollars It is obvious that at any moment of time the tank can contain at most v liters of fuel Sasha doesn t like to waste money that s why he wants to know what is the minimum amount of money is needed to finish the trip if he can buy fuel in any city he wants Help him to figure it out ,"['#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, v;\n    cin >> n >> v;\n    int act = 0, sol = 0;\n    for (int i = 1; i <= n; i++) {\n        while(act < n-i && act < v) {\n            act++; sol += i;\n        }\n        act--;\n    }\n    cout << sol << endl;\n    ios_base::sync_with_stdio(false);\n    return 0;\n}\n']","['dp', 'greedy', 'math']",900
https://codeforces.com//contest/1336/problem/B,B. Xenia and Colorful Gems,Xenia is a girl being born a noble Due to the inflexibility and harshness of her family Xenia has to find some ways to amuse herself Recently Xenia has bought n r red gems n g green gems and n b blue gems Each of the gems has a weight Now she is going to pick three gems Xenia loves colorful things so she will pick exactly one gem of each color Xenia loves balance so she will try to pick gems with little difference in weight Specifically supposing the weights of the picked gems are x y and z Xenia wants to find the minimum value of x y 2 y z 2 z x 2 As her dear friend can you help her ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 112345;\nvector<int> p[3];\nvoid solve()\n{\n\tint a, b, c;\n\tscanf(""%d%d%d"", &a, &b, &c);\n\tfor (int i = 0; i < 3; i++)\n\t\tp[i].clear();\n\tfor (int i = 0; i < a; i++)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tp[0].push_back(x);\n\t}\n\tfor (int i = 0; i < b; i++)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tp[1].push_back(x);\n\t}\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tp[2].push_back(x);\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t\tsort(p[i].begin(), p[i].end());\n\ti64 ans = 1ll << 62;\n\tfor (int x = 0; x < 3; x++)\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int z = 0; z < 3; z++)\n\t\t\t\tif (x != y && y != z && x != z)\n\t\t\t\t{\n\t\t\t\t\tfor (auto u : p[x])\n\t\t\t\t\t{\n\t\t\t\t\t\tauto itv = lower_bound(p[y].begin(), p[y].end(), u);\n\t\t\t\t\t\tif (itv == p[y].end())\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tauto itw = lower_bound(p[z].begin(), p[z].end(), (*itv + u + 1) / 2);\n\t\t\t\t\t\tauto sqr = [&](i64 x) { return x * x; };\n\t\t\t\t\t\tif (itw != p[z].end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans = min(ans, sqr(u - *itv) + sqr(u - *itw) + sqr(*itv - *itw));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (itw != p[z].begin())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t--itw;\n\t\t\t\t\t\t\tans = min(ans, sqr(u - *itv) + sqr(u - *itw) + sqr(*itv - *itw));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(""%lld\\n"", ans);\n}\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\tfor (int tc = 0; tc < t; tc++)\n\t{\n\t\tsolve();\n\t}\n}\n']","['binary search', 'greedy', 'math', 'sortings', 'two pointers']",1700
https://codeforces.com//contest/891/problem/B,B. Gluttony,You are given an array with distinct integers Construct an array by permuting such that for every non empty subset of indices the sums of elements on that positions in and are different i e ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=30;\nint n,a[N],b[N];\nPII p[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d"",a+i),p[i]=mp(a[i],i);\n\tsort(p,p+n);\n\trep(i,0,n) b[p[(i+1)%n].se]=p[i].fi;\n\trep(i,0,n) {\n\t\tprintf(""%d "",b[i]);\n\t}\n\tputs("""");\n}\n']","['constructive algorithms', 'greedy']",2000
https://codeforces.com//contest/1324/problem/C,C. Frog Jumps,There is a frog staying to the left of the string s s 1 s 2 ldots s n consisting of n characters to be more precise the frog initially stays at the cell 0 Each character of s is either or It means that if the frog is staying at the i th cell and the i th character is the frog can jump only to the left If the frog is staying at the i th cell and the i th character is the frog can jump only to the right The frog wants to reach the n 1 th cell The frog chooses some value d and cannot change it later and jumps by no more than d cells at once I e if the i th character is then the frog can jump to any cell in a range max 0 i d i 1 and if the i th character is then the frog can jump to any cell in a range i 1 min n 1 i d The frog doesn t want to jump far so your task is to find the minimum possible value of d such that the frog can reach the cell n 1 from the cell 0 if it can jump by no more than d cells at once You have to answer t independent test cases ,"[""#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<ll> m;\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n    \tstring s;\n    \tcin >> s;\n    \tvector<int> bad;\n    \tbad.resize(s.size() + 1, 0);\n    \tfor (int j = 0; j < s.size(); j++)\n    \t\tif (s[j] == 'L')\n    \t\t\tbad[j + 1] = bad[j] + 1;\n    \tint ans = 0;\n    \tfor (int j = 0; j < bad.size(); j++)\n    \t\tans = max(ans, bad[j] + 1);\n    \tcout << ans << endl;\n    }\n\n\n\n\n    return 0;\n}""]","['binary search', 'data structures', 'dfs and similar', 'greedy', 'implementation']",1100
https://codeforces.com//contest/1606/problem/F,F. Tree Queries,You are given a tree consisting of n vertices Recall that a tree is an undirected connected acyclic graph The given tree is rooted at the vertex 1 You have to process q queries In each query you are given a vertex of the tree v and an integer k To process a query you may delete any vertices from the tree in any order except for the root and the vertex v When a vertex is deleted its children become the children of its parent You have to process a query in such a way that maximizes the value of c v m cdot k where c v is the resulting number of children of the vertex v and m is the number of vertices you have deleted Print the maximum possible value you can obtain The queries are independent the changes you make to the tree while processing a query don t affect the tree in other queries ,"['#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\ntemplate<typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\n\nstruct node{\n\tint x,y;\n\tnode(int x=0,int y=0):x(x),y(y){}\n\tbool operator<(const node c)const{return 1ll*y*c.x<1ll*x*c.y;}\n\tbool operator>(const node c)const{return c<*this;}\n\tnode operator+(const node c)const{return node(x+c.x,y+c.y);}\n}val[200005],sum[200005];\n\nmt19937 mrand(1);\nint n,q,tot,ncnt;\nint ch[200005][2],siz[200005],v[400005],nxt[400005],h[200005],son[200005],sz[200005],rt[200005],ans[200005];\nvector<pii> qry[200005];\n\nvoid addedge(int x,int y){\n\tv[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\n\tv[++tot]=x; nxt[tot]=h[y]; h[y]=tot;\n}\n\nvoid dfs1(int u,int fa){\n\tsz[u]=1;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==fa) continue;\n\t\tdfs1(v[p],u);\n\t\tsz[u]+=sz[v[p]];\n\t\tif(sz[v[p]]>sz[son[u]]) son[u]=v[p];\n\t}\n}\n\nvoid update(int u){\n\tsiz[u]=1+siz[ch[u][0]]+siz[ch[u][1]];\n\tsum[u]=val[u]+sum[ch[u][0]]+sum[ch[u][1]];\n}\n\nvoid split(int u,node k,int &x,int &y){\n\tif(!u) return (void)(x=y=0);\n\tif(!(val[u]<k)) x=u,split(ch[u][1],k,ch[x][1],y);\n\telse y=u,split(ch[u][0],k,x,ch[y][0]);\n\tupdate(u);\n}\n\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tif(mrand()%(siz[x]+siz[y])<siz[x]){\n\t\tch[x][1]=merge(ch[x][1],y); update(x);\n\t\treturn x;\n\t}\n\telse{\n\t\tch[y][0]=merge(x,ch[y][0]); update(y);\n\t\treturn y;\n\t}\n}\n\nvoid dfs3(int u,int t){\n\tif(!u) return;\n\tdfs3(ch[u][0],t);\n\tdfs3(ch[u][1],t);\n\tch[u][0]=ch[u][1]=0;\n\tupdate(u);\n\tint a,b;\n\tsplit(rt[t],val[u],a,b);\n\trt[t]=merge(merge(a,u),b);\n}\n\nint getlf(int u){\n\twhile(ch[u][0]) u=ch[u][0];\n\treturn u;\n}\n\nvoid trav(int u){\n\tif(!u) return;\n\ttrav(ch[u][0]);\n\tcout<<""test ""<<val[u].x<<\' \'<<val[u].y<<endl;\n\ttrav(ch[u][1]);\n}\n\nvoid dfs2(int u,int fa){\n\tfor(int p=h[u];p;p=nxt[p]) if(v[p]!=fa&&v[p]!=son[u]) dfs2(v[p],u);\n\tint num=-1;\n\tif(son[u]) dfs2(son[u],u),rt[u]=rt[son[u]],num++;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==fa||v[p]==son[u]) continue;\n\t\tdfs3(rt[v[p]],u);\n\t\tnum++;\n\t}\n//\tcout<<""#################### ""<<u<<\' \'<<th.x<<\' \'<<th.y<<endl;\n//\ttrav(rt[u]);\n\tint a,b;\n\tfor(auto r:qry[u]){\n\t\tnode tmp(1,r.fi);\n\t\tsplit(rt[u],tmp,a,b);\n\t\tans[r.se]=sum[a].y-1ll*r.fi*sum[a].x+num+1;\n\t\trt[u]=merge(a,b);\n\t}\n\tnode th(1,num);\n\twhile(siz[rt[u]]>=1){\n\t\tint tmp=getlf(rt[u]);\n\t\tif(th>val[tmp]) break;\n\t\tsplit(rt[u],val[tmp],a,b);\n\t\tth=th+val[a];\n\t\trt[u]=merge(merge(ch[a][0],ch[a][1]),b);\n\t}\n\tncnt++;\n\tval[ncnt]=sum[ncnt]=th,siz[ncnt]=1;\n\trt[u]=merge(ncnt,rt[u]);\n}\n\nint main(){\n\tn=readint();\n\tfor(int i=1;i<n;i++) addedge(readint(),readint());\n\tq=readint();\n\tfor(int i=1;i<=q;i++){\n\t\tint x=readint(),y=readint();\n\t\tqry[x].pb(mp(y,i));\n\t}\n\tdfs1(1,-1);\n\tdfs2(1,-1);\n\tfor(int i=1;i<=q;i++) printf(""%d\\n"",ans[i]);\n\treturn 0;\n}']","['brute force', 'dp', 'trees']",2800
https://codeforces.com//contest/1905/problem/C,C. Largest Subsequence,Given is a string s of length n In one operation you can select the lexicographically largest dagger subsequence of string s and cyclic shift it to the right ddagger Your task is to calculate the minimum number of operations it would take for s to become sorted or report that it never reaches a sorted state daggerA string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b In the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ddaggerBy cyclic shifting the string t 1t 2 ldots t m to the right we get the string t mt 1 ldots t m 1 ,"['// Problem: C. Largest Subsequence\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n// #pragma GCC optimize(""Ofast,inline,unroll-loops"")\n// #define _GLIBCXX_DEBUG //交题前记得注释掉不然容易T。\n#include<bits/stdc++.h>\n#define File(s) freopen(#s"".in"",""r"",stdin),freopen(#s"".out"",""w"",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<""@""<<__LINE__<<""=""<<(x)<<\'\\n\')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=-2023,M=1000000007;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\n\nsigned main(){\n\t//std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tint n=g90;\n\t\tstatic char s[200200];\n\t\tg90.rstr(s);\n\t\tvi st;\n\t\tfor(int i=0;i<n;++i){\n\t\t\twhile(!st.empty()&&s[st.back()]<s[i])st.pop_back();\n\t\t\tst.eb(i);\n\t\t}\n\t\tvi tmp;\n\t\tfor(auto&&i:st)tmp.eb(s[i]);\n\t\tstd::sort(all(tmp));\n\t\tfor(int i=0;i<int(st.size());++i)s[st[i]]=tmp[i];\n\t\tif(std::is_sorted(s,s+n)){\n\t\t\tauto x=tmp.back();\n\t\t\twhile(!tmp.empty()&&tmp.back()==x)tmp.pop_back();\n\t\t\tprintf(""%zu\\n"",tmp.size());\n\t\t}else puts(""-1"");\n\t}();\n}//main()']","['greedy', 'strings']",1400
https://codeforces.com//contest/950/problem/A,"A. Left-handers, Right-handers and Ambidexters",You are at a water bowling training There are people who play with their left hand people who play with their right hand and ambidexters who can play with left or right hand The coach decided to form a team of even number of players exactly half of the players should play with their right hand and exactly half of the players should play with their left hand One player should use only on of his hands Ambidexters play as well with their right hand as with their left hand In the team an ambidexter can play with their left hand or with their right hand Please find the maximum possible size of the team where equal number of players use their left and right hands respectively ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\tif(a>b)swap(a,b);\n\tif(a+c<=b)cout<<(a+c)*2;\n\telse cout<<(a+b+c)/2*2;\n\treturn 0;\n}\n\n']","['implementation', 'math']",800
https://codeforces.com//contest/1503/problem/C,C. Travelling Salesman Problem,There are n cities numbered from 1 to n and city i has beauty a i A salesman wants to start at city 1 visit every city exactly once and return to city 1 For all i ne j a flight from city i to city j costs max c i a j a i dollars where c i is the price floor enforced by city i Note that there is no absolute value Find the minimum total cost for the salesman to complete his trip ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tusing ll = long long;\n\tint n;\n\tcin >> n;\n\tvector<pair<ll, ll>> z;\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, c;\n\t\tcin >> a >> c;\n\t\tz.push_back({a, a+c});\n\t\tans += c;\n\t}\n\tsort(z.begin(), z.end());\n\tll maxc = z.front().second;\n\tfor(int i = 1; i < n; i++){\n\t\tans += max(0ll, z[i].first - maxc);\n\t\tmaxc = max(maxc, z[i].second);\n\t}\n\tcout << ans << '\\n';\n}""]","['binary search', 'data structures', 'dp', 'greedy', 'shortest paths', 'sortings', 'two pointers']",2200
https://codeforces.com//contest/69/problem/A,A. Young Physicist,A guy named Vasya attends the final grade of a high school One day Vasya decided to watch a match of his favorite hockey team And as the boy loves hockey very much even more than physics he forgot to do the homework Specifically he forgot to complete his physics tasks Next day the teacher got very angry at Vasya and decided to teach him a lesson He gave the lazy student a seemingly easy task You are given an idle body in space and the forces that affect it The body can be considered as a material point with coordinates 0 0 0 Vasya had only to answer whether it is in equilibrium Piece of cake thought Vasya we need only to check if the sum of all vectors is equal to 0 So Vasya began to solve the problem But later it turned out that there can be lots and lots of these forces and Vasya can not cope without your help Help him Write a program that determines whether a body is idle or is moving by the given vectors of forces ,"['#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n , sx = 0 , sy = 0 , sz = 0 ;\n\tcin >> n ;\n\tfor ( int i = 0 ; i < n ; i ++ ) {\n\t\tint x , y , z ;\n\t\tcin >> x >> y >> z ;\n\t\tsx += x ;\n\t\tsy += y ;\n\t\tsz += z ;\n\t}\n\tif ( sx == 0 && sy == 0 && sz == 0 ) {\n\t\tcout << ""YES"" << endl ;\n\t} else {\n\t\tcout << ""NO"" << endl ;\n\t}\n\treturn 0 ;\n}\n']","['implementation', 'math']",1000
https://codeforces.com//contest/319/problem/C,C. Kalila and Dimna in the Logging Industry,Kalila and Dimna are two jackals living in a huge jungle One day they decided to join a logging factory in order to make money The manager of logging factory wants them to go to the jungle and cut trees with heights They bought a chain saw from a shop Each time they use the chain saw on the tree number they can decrease the height of this tree by one unit Each time that Kalila and Dimna use the chain saw they need to recharge it Cost of charging depends on the id of the trees which have been cut completely a tree is cut completely if its height equal to 0 If the maximum id of a tree which has been cut completely is the tree that have height in the beginning then the cost of charging the chain saw would be If no tree is cut completely Kalila and Dimna cannot charge the chain saw The chainsaw is charged in the beginning We know that for each and and also and Kalila and Dimna want to cut all the trees completely with minimum cost They want you to help them Will you ,"['#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\nconst double pi = acos(-1.0);\n\nconst int size = 200 * 1000;\n\nlong long a[size], b[size];\n\nlong long comp(pair <long long, long long> a, pair <long long, long long> b) {\n\tlong long d = b.fs - a.fs;\n\tlong long z = a.sc - b.sc;\n\treturn (d + z - 1) / z;\n}\n\nlong long ans[size];\n\nint main() {\n\tint n;\n\n\t//freopen(""problem_c.in"", ""r"", stdin);\n\t//freopen(""problem_c.out"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%I64d"", &a[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%I64d"", &b[i]);\n\tans[0] = b[0];\n\tvector <pair <long long, long long> > st;\n\tst.pb(mp(0, 0));\n\tfor (int i = 1; i < n; i++) {\n\t\tint lb = 0;\n\t\tint rb = int(st.size()) - 1;\n\t\tint mid;\n\t\twhile (lb < rb) {\n\t\t\tmid = (lb + rb + 1) / 2;\n\t\t\tif (st[mid].fs > a[i])\n\t\t\t\trb = mid - 1;\n\t\t\telse\n\t\t\t\tlb = mid;\n\t\t}\n\t\tans[i] = ans[st[lb].sc] + b[st[lb].sc] * (a[i] - 1) + b[i];\n\t\twhile (!st.empty() && comp(mp(ans[st.back().sc], b[st.back().sc]), mp(ans[i], b[i])) <= st.back().fs)\n\t\t\tst.pop_back();\n\t\tif (st.empty())\n\t\t\tst.pb(mp(0, i));\n\t\telse\n\t\t\tst.pb(mp(comp(mp(ans[st.back().sc], b[st.back().sc]), mp(ans[i], b[i])), i));\n\t}\n\n\tcout << ans[n - 1] << endl;\n\n\treturn 0;\n}']","['dp', 'geometry']",2100
https://codeforces.com//contest/131/problem/C,C. The World is a Theatre,There are boys and girls attending a theatre club To set a play The Big Bang Theory they need to choose a group containing exactly actors containing no less than 4 boys and no less than one girl How many ways are there to choose a group Of course the variants that only differ in the composition of the troupe are considered different Perform all calculations in the 64 bit type for for Delphi and for Java ,"['#include <cstdio>\ntypedef long long ll;\nint c[40][40];\nint main()\n{\n    for (int i=0;i<=30;i++)\n    {\n        c[i][0]=c[i][i]=1;\n        for (int j=1;j<i;j++)\n            c[i][j]=c[i-1][j-1]+c[i-1][j];\n    }\n    int n,m,t;\n    scanf(""%d%d%d"",&n,&m,&t);\n    ll ans=0;\n    for (int i=4;i<=n;i++)\n    {\n        int p=t-i;\n        if (p<1)\n            break;\n        if (p>m)\n            continue;\n        ans+=ll(c[n][i])*c[m][p];\n    }\n    printf(""%I64d\\n"",ans);\n    return(0);\n}\n']","['combinatorics', 'math']",1400
https://codeforces.com//contest/1477/problem/A,A. Nezzar and Board,n integers x 1 x 2 ldots x n are written on the board Nezzar can perform the following operation multiple times Select two integers x y not necessarily distinct on the board and write down 2x y Note that you don t remove selected numbers Now Nezzar wonders if it is possible to have his favorite number k on the board after applying above operation multiple times ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint waf(int x,int m){return ((x%m)+m)%m;}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi x=readvi(n);\n\tint g=0;\n\trep(i,n-1)g=gcd(g,abs(x[i]-x[i+1]));\n\tif(waf(x[0],g)==waf(k,g))yes(0);\n\telse no(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['constructive algorithms', 'math', 'number theory']",1800
https://codeforces.com//contest/902/problem/B,B. Coloring a Tree,You are given a rooted tree with vertices The vertices are numbered from to the root is the vertex number Each vertex has a color let s denote the color of vertex by Initially You have to color the tree into the given colors using the smallest possible number of steps On each step you can choose a vertex and a color and then color all vectices in the subtree of including itself in color In other words for every vertex such that the path from root to passes through set It is guaranteed that you have to color each vertex in a color different from You can learn what a rooted tree is using the link https en wikipedia org wiki Tree graph theory ,"['#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\n\n\n\ntemplate <class T>\nvoid upd(T&a,T b) {\n    a = max(a,b);\n}\n\nvector<int>son[100010];\nint n,c[100010];\nint ans = 0;\nvoid dfs(int cur,int color = 0){\n    if(c[cur]!=color){\n        ans++;\n        color = c[cur];\n    }\n    for(auto i:son[cur]){\n        dfs(i,color);\n    }\n}\nint main(){\n    in(n);\n    REP(i,2,n+1){\n        int p;in(p);\n        son[p].PB(i);\n    }\n    REP(i,1,n+1){\n        in(c[i]);\n    }\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n']","['dfs and similar', 'dsu', 'greedy']",1200
https://codeforces.com//contest/1217/problem/E,E. Sum Queries ,Let s define a multiset the following way Write down the sum of all elements of the multiset in its decimal representation For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same If that holds for every position then the multiset is Otherwise it s For example multiset 20 300 10001 is and multiset 20 310 10001 is The red digits mark the elements and the positions for which these elements have the same digit as the sum The sum of the first multiset is 10321 every position has the digit required The sum of the second multiset is 10331 and the second to last digit doesn t appear in any number thus making the multiset You are given an array a 1 a 2 dots a n consisting of n integers You are asked to perform some queries on it The queries can be of two types 1 i x replace a i with the value x 2 l r find the subset of the multiset of the numbers a l a l 1 dots a r with the minimum sum or report that no subset exists Note that the empty multiset is For each query of the second type print the lowest sum of the subset Print if no subset exists ,"['#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/06, 00:05:55\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst int inf = 1e9 + 5;\n\npii operator+(pii a, pii b) {\n    if (a.fs > b.fs) a.se = a.fs, a.fs = b.fs;\n    else if (a.se > b.fs) a.se = b.fs;\n    if (a.fs > b.se) a.se = a.fs, a.fs = b.se;\n    else if (a.se > b.se) a.se = b.se;\n    return a;\n}\n\nconst int sz = 1 << 18;\nstruct segtree {\n    pii seg[sz << 1];\n    segtree() {\n        for (int i = 0; i < (sz << 1); ++i) seg[i] = pii(inf, inf);\n    }\n    void init() {\n        for (int i = sz; --i; ) seg[i] = seg[i << 1] + seg[i << 1 | 1];\n    }\n    void update(int x, int v) {\n        x += sz;\n        seg[x] = pii(v, inf);\n        while (x >>= 1)\n            seg[x] = seg[x << 1] + seg[x << 1 | 1];\n    }\n    pii query(int x, int y) {\n        x += sz;\n        y += sz;\n        pii ret = pii(inf, inf);\n        while (x <= y) {\n            if ((x & 1) == 1) ret = ret + seg[x++];\n            if ((y & 1) == 0) ret = ret + seg[y--];\n            x >>= 1;\n            y >>= 1;\n        }\n        return ret;\n    }\n} seg[10];\n\nvoid update(int i, int x) {\n    for (int j = 0, k = x; j < 10; ++j, k /= 10) {\n        if (k % 10 > 0) seg[j].update(i, x);\n        else seg[j].update(i, inf);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        int x;\n        cin >> x;\n        for (int j = 0, k = x; j < 10; ++j, k /= 10) {\n            if (k % 10 > 0) seg[j].seg[i + sz] = pii(x, inf);\n            else seg[j].seg[i + sz] = pii(inf, inf);\n        }\n    }\n    for (int i = 0; i < 10; ++i) seg[i].init();\n    while (q--) {\n        int t, x, y;\n        cin >> t >> x >> y;\n        if (t == 1) update(x, y);\n        else {\n            int ans = inf + inf;\n            for (int i = 0; i < 10; ++i) {\n                pii ret = seg[i].query(x, y);\n                if (ret.se == inf) continue;\n                ans = min(ans, ret.fs + ret.se);\n            }\n            printf(""%d\\n"", ans < inf + inf ? ans : -1);\n        }\n    }\n    return 0;\n}\n']","['data structures', 'greedy', 'implementation', 'math']",2300
https://codeforces.com//contest/299/problem/B,B. Ksusha the Squirrel,Ksusha the Squirrel is standing at the beginning of a straight road divided into sectors The sectors are numbered 1 to from left to right Initially Ksusha stands in sector 1 Ksusha wants to walk to the end of the road that is get to sector Unfortunately there are some rocks on the road We know that Ksusha hates rocks so she doesn t want to stand in sectors that have rocks Ksusha the squirrel keeps fit She can jump from sector to any of the sectors Help Ksusha Given the road description say if she can reach the end of the road note she cannot stand on a rock ,"['//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define fi first\n#define se second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,1,-1};\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << "" = "" << (x) << endl;\n#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;\n\nint n, k;\nstring s;\nvector<int> inv;\n\nint main(){\n    cin >> n >> k >> s;\n    int crt = 0;\n    rep(i, n){\n\tif(s[i] == \'.\'){\n\t    if(crt) inv.pb(crt);\n\t    crt = 0;\n\t}else{\n\t    crt++;\n\t}\n    }\n    if(crt) inv.pb(crt);\n    rep(i, inv.size()){\n\tif(inv[i] >= k){\n\t    cout << ""NO"" << endl;\n\t    return 0;\n\t}\n    }\n    cout << ""YES"" << endl;\n    return 0;\n}\n']","['brute force', 'implementation']",900
https://codeforces.com//contest/1074/problem/E,E. Grid Sort,You are given an n times m grid Each grid cell is filled with a unique integer from 1 to nm so that each integer appears exactly once In one operation you can choose an arbitrary cycle of the grid and move all integers along that cycle one space over Here a cycle is any sequence that satisfies the following conditions There are at least four squares Each square appears at most once Every pair of adjacent squares and also the first and last squares share an edge For example if we had the following grid We can choose an arbitrary cycle like this one To get the following grid In this particular case the chosen cycle can be represented as the sequence 1 2 3 6 5 8 7 4 the numbers are in the direction that we want to rotate them in Find any sequence of operations to sort the grid so that the array created by concatenating the rows from the highest to the lowest is sorted look at the first picture above Note you do not need to minimize number of operations or sum of cycle lengths The only constraint is that the sum of all cycles lengths must not be greater than 10 5 We can show that an answer always exists under the given constraints Output any valid sequence of moves that will sort the grid ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=107;\n\nint n, m;\n\nint tab[nax][nax];\nint musz[nax][nax];\n\nvector <vi> wyn;\n\npii fast[nax*nax];\n\ninline pii gdz(const int &v)\n{\n\treturn fast[v];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (tab[i][j]==v)\n\t\t\t\treturn {i, j};\n\tassert(0);\n}\n\ninline int &war(const pii &v)\n{\n\treturn tab[v.first][v.second];\n}\n\nvoid zrob(const vi &wek)\n{\n\tvector <pii> poz(wek.size());\n\t//~ for (int i : wek)\n\t\t//~ poz.push_back(gdz(i));\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t\tpoz[i]=gdz(wek[i]);\n\t//~ debug() << poz;\n\tfor (int i=(int)poz.size()-1; i>0; i--)\n\t{\n\t\tpii a=poz[i];\n\t\tpii b=poz[i-1];\n\t\tswap(tab[a.first][a.second], tab[b.first][b.second]);\n\t\tswap(fast[tab[a.first][a.second]], fast[tab[b.first][b.second]]);\n\t\t\n\t\t//~ swap(war(poz[i]), war(poz[i-1]));\n\t\t//~ swap(fast[war(poz[i])], fast[war(poz[i-1])]);\n\t}\n\twyn.push_back(wek);\n}\n\nvoid cofnij()\n{\n\tassert(!wyn.empty());\n\tvi wez=wyn.back();\n\treverse(wez.begin(), wez.end());\n\tzrob(wez);\n\twyn.pop_back();\n\twyn.pop_back();\n}\n\nvi daj_kwa(pii v)\n{\n\tvi ret;\n\tret.push_back(tab[v.first][v.second]);\n\tret.push_back(tab[v.first][v.second+1]);\n\tret.push_back(tab[v.first+1][v.second+1]);\n\tret.push_back(tab[v.first+1][v.second]);\n\treturn ret;\n}\n\nvi daj_kwa2(pii v)\n{\n\tvi ret=daj_kwa(v);\n\treverse(ret.begin(), ret.end());\n\treturn ret;\n}\n\nint chce[nax*nax];\n\nvi los(int a, int b)\n{\n\t//~ if (rand()&1)\n\t//~ {\n\t\tif (rand()&1)\n\t\t\treturn daj_kwa({a+(rand()&1), b+(rand()&1)});\n\t\telse\n\t\t\treturn daj_kwa2({a+(rand()&1), b+(rand()&1)});\n\t//~ }\n}\n\nvoid solve(int a, int b, int lim)\n{\n\twhile(1)\n\t{\n\t\tfor (int h=0; h<lim/4; h++)\n\t\t{\n\t\t\tint czy=1;\n\t\t\tfor (int i=0; i<3 && czy; i++)\n\t\t\t\tfor (int j=0; j<3 && czy; j++)\n\t\t\t\t\tif (chce[musz[a+i][b+j]] && musz[a+i][b+j]!=tab[a+i][b+j])\n\t\t\t\t\t\tczy=0;\n\t\t\tif (czy)\n\t\t\t\treturn;\n\t\t\tzrob(los(a, b));\n\t\t}\n\t\t\n\t\t\n\t\tfor (int i=0; i<lim/4; i++)\n\t\t\tcofnij();\n\t}\n}\n\nint przelicz()\n{\n\tint ret=0;\n\tfor (vi i : wyn)\n\t\tret+=i.size();\n\treturn ret;\n}\n\nbool mniej(pii a, pii b)\n{\n\treturn a.second>b.second;\n}\n\nconst int magic=1200;\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tmusz[i][j]=m*(i-1)+j;\n\t\t\tscanf(""%d"", &tab[i][j]);\n\t\t\tfast[tab[i][j]]={i, j};\n\t\t}\n\t}\n\tint pn=n;\n\twhile(pn>3)\n\t{\n\t\t//~ debug() << ""a"";\n\t\tfor (int i=m; i>1; i--)\n\t\t{\n\t\t\tint tutaj=musz[pn][i];\n\t\t\twhile(gdz(tutaj)!=make_pair(pn, i))\n\t\t\t{\n\t\t\t\tpii x=gdz(tutaj);\n\t\t\t\tif (x.second!=i)\n\t\t\t\t{\n\t\t\t\t\tif (x.second<i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (x.first<pn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa(x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa2({x.first-1, x.second}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (x.first<pn-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa2({x.first, x.second-1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa({x.first-1, x.second-1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzrob(daj_kwa({x.first, x.second-1}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint tutaj=musz[pn][1];\n\t\twhile(gdz(tutaj).first<pn-1)\n\t\t{\n\t\t\tpii x=gdz(tutaj);\n\t\t\tif (x.second>1)\n\t\t\t{\n\t\t\t\tzrob(daj_kwa({x.first, x.second-1}));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzrob(daj_kwa2(x));\n\t\t\t}\n\t\t}\n\t\twhile(gdz(tutaj).second>3)\n\t\t{\n\t\t\tpii x=gdz(tutaj);\n\t\t\tzrob(daj_kwa({x.first-1, x.second-1}));\n\t\t}\n\t\t\n\t\tchce[musz[pn][1]]=chce[musz[pn][2]]=chce[musz[pn][3]]=1;\n\t\tsolve(pn-2, 1, magic);\n\t\tpn--;\n\t}\n\t\n\tint pm=m;\n\twhile(pm>3)\n\t{\n\t\tvector <pii> poz;\n\t\tfor (int i=1; i<=3; i++)\n\t\t\tpoz.push_back(gdz(musz[i][pm]));\n\t\tsort(poz.begin(), poz.end(), mniej);\n\t\tint czy=0;\n\t\tfor (int i=0; i<3; i++)\n\t\t{\n\t\t\tif (poz[i].second>=pm-i)\n\t\t\t\tcontinue;\n\t\t\tczy=1;\n\t\t\tpii x=poz[i];\n\t\t\tif (x.first==1)\n\t\t\t\tzrob(daj_kwa(x));\n\t\t\telse\n\t\t\t\tzrob(daj_kwa2({x.first-1, x.second}));\n\t\t\tbreak;\n\t\t}\n\t\tif (czy)\n\t\t\tcontinue;\n\t\t\n\t\tchce[musz[1][pm]]=chce[musz[2][pm]]=chce[musz[3][pm]]=1;\n\t\tsolve(1, pm-2, magic);\n\t\tpm--;\n\t}\n\tint resz=99*1000-przelicz();\n\tfor (int i=1; i<=3; i++)\n\t\tfor (int j=1; j<=3; j++)\n\t\t\tchce[musz[i][j]]=1;\n\tsolve(1, 1, resz);\n\t\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ debug() << range(tab[i]+1, tab[i]+1+m);\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tassert(musz[i][j]==tab[i][j]);\n\tdebug() << imie(przelicz());\n\t\n\t//~ return 0;\n\tprintf(""%d\\n"", (int)wyn.size());\n\tfor (vi i : wyn)\n\t{\n\t\tprintf(""%d"", (int)i.size());\n\t\tfor (int j : i)\n\t\t\tprintf("" %d"", j);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","['brute force', 'implementation']",3100
https://codeforces.com//contest/1271/problem/E,E. Common Number,At first let s define function f x as follows begin matrix f x left begin matrix frac x 2 mbox if x text is even x 1 mbox otherwise end matrix right end matrix We can see that if we choose some value v and will apply function f to it then apply f to f v and so on we ll eventually get 1 Let s write down all values we get in this process in a list and denote this list as path v For example path 1 1 path 15 15 14 7 6 3 2 1 path 32 32 16 8 4 2 1 Let s write all lists path x for every x from 1 to n The question is next what is the maximum value y such that y is contained in at least k different lists path x Formally speaking you need to find maximum y such that left x 1 le x le n y in path x right ge k ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nll n, k, ans;\n\nll get(ll x, ll dex) {\n\treturn max(0LL, min(1LL << dex, n - (x << dex) + 1));\n}\nll cnt(ll x) {\n\tll res = 0;\n\tfor (int i = 0; (x << i) <= n; i++) {\n\t\tres += get(x, i);\n\t\tif (x % 2 == 0)\n\t\t\tres += get(x + 1, i);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> k;\n\tfor (int i = 60; ~i; i--)\n\t\tif (cnt(ans | (1LL << i)) >= k)\n\t\t\tans |= (1LL << i);\n\tcout << ans;\n}\n']","['binary search', 'combinatorics', 'dp', 'math']",2100
https://codeforces.com//contest/919/problem/D,D. Substring,You are given a graph with n nodes and m edges One lowercase letter is assigned to each node We define a path s value as the number of the most frequently occurring letter For example if letters on a path are then the value of that path is 3 Your task is find a path whose value is the largest ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX=300005;\nint f[MX][27];\nvector<int>G[MX];\nint n,m;\nchar s[MX];\nchar vis[MX];\nbool dfs(int k){\n\tif(vis[k]==2)return false;\n\tif(vis[k]==1)return true;\n\tvis[k]=1;\n\tfor(auto i:G[k])if(dfs(i))return true;\n\tvis[k]=2;\n\treturn false;\n}\nint F(int k,int c){\n\tif(f[k][c]!=-1)return f[k][c];\n\tint r=(s[k]=='a'+c?1:0),a=0;\n\tfor(auto i:G[k])a=max(a,F(i,c));\n\treturn f[k][c]=r+a;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;cin>>(s+1);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;cin>>u>>v;\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i]&&dfs(i))return cout<<-1<<endl,0;\n\tint ans=0;\n\tmemset(f,-1,sizeof(f));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<26;j++)\n\t\t\tans=max(ans,F(i,j));\n\tcout<<ans<<endl;\n\treturn 0;\n}""]","['dfs and similar', 'dp', 'graphs']",1700
https://codeforces.com//contest/208/problem/B,B. Solitaire,A boy named Vasya wants to play an old Russian solitaire called Accordion In this solitaire the player must observe the following rules A deck of cards is carefully shuffled then all cards are put on the table in a line from left to right Before each move the table has several piles of cards lying in a line initially there are piles each pile has one card Let s number the piles from left to right from 1 to During one move a player can take the whole pile with the maximum number that is the rightmost of remaining and put it on the top of pile if it exists or on the top of pile if it exists The player can put one pile on top of another one only if the piles top cards have the same suits or values Please note that if pile goes on top of pile then the top card of pile becomes the top card of the resulting pile Also note that each move decreases the total number of piles by 1 The solitaire is considered completed if all cards are in the same pile Vasya has already shuffled the cards and put them on the table help him understand whether completing this solitaire is possible or not ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<cstring>\n#include<iostream>\n#include<ctype.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<iomanip>\n#include<complex>\n#include<utility>\n\n#define X first\n#define Y second\n#define REP_0(i,n) for(int i=0;i<(n);++i)\n#define REP_1(i,n) for(int i=1;i<=(n);++i)\n#define REP_2(i,a,b) for(int i=(a);i<(b);++i)\n#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))\n#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)\n#define DOW_1(i,n) for(int i=(n);0<i;--i)\n#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)\n#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)\n#define FOREACH(a,b) for(typeof(b.begin()) a=(b).begin();a!=(b).end();++a)\n#define RFOREACH(a,b) for(typeof(b.rbegin()) a=(b).rbegin();a!=b.rend();++a)\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define IS insert\n#define ES erase\n#define IT iterator\n#define RI reserve_iterator\n#define PQ priority_queue\n#define LB lower_bound\n#define UB upper_bound\n\n#define PI 3.1415926535897932384626433832795\n#define EXP 2.7182818284590452353602874713527\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef double DB;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef pair<int,PII> PIII;\ntypedef pair<LD,int> PLDI;\ntypedef vector<PII> VII;\n\ntemplate<class T>\nT By(T x,T y,T P){\n\tT F1=0;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1+=x;\n\t\t\tif(F1<0||F1>=P)F1-=P;\n\t\t}\n\t\tx<<=1;\n\t\tif(x<0||x>=P)x-=P;\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Mul(T x,T y,T P){\n\tT F1=1;x%=P;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1=By(F1,x,P);\n\t\t}\n\t\tx=By(x,x,P);\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Gcd(T x,T y){\n\tif(y==0)return x;\n\tT z;\n\twhile(z=x%y){\n\t\tx=y,y=z;\n\t}\n\treturn y;\n}\n\nstruct EDGE{\n\tint T;EDGE *Nxt;\n};\n\ntemplate<class T>\nvoid UpdataMin(T &x,T y){\n\tif(y<x)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nvoid UpdataMax(T &x,T y){\n\tif(x<y)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nT Sqr(const T x){\n\treturn x*x;\n}\n\n#define MaxBuffer 20000000\nclass ReadBuffer{\n\tchar buff[MaxBuffer];\n\tchar *buf;\n\tvoid init(int size=MaxBuffer)\n\t{\n\t\tfread(buff,1,size,stdin);\n\t}\n\ttemplate<class T>\n\tbool readInterger(T &x)\n\t{\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag;\n\t\tflag=0;\n\t\tif(*buf==\'-\') flag=true;\n\t\telse x=*buf-\'0\';\n\t\twhile(isdigit(*++buf)) x=x*10+*buf-\'0\';\n\t\tif(flag) x=-x;\n\t\treturn true;\n\t}\n\ttemplate<class T>\n\tbool readFloat(T &x)\n\t{\n\t\tlong double nowpos=0.1;\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag,decimal;\n\t\tdecimal=flag=0;\n\t\tif(*buf==\'-\') flag=true,++buf;\n\t\telse if(*buf==\'.\') decimal=true;\n\t\twhile(isdigit(*buf)||*buf==\'.\')\n\t\t{\n\t\t\tif(*buf==\'.\') decimal=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(decimal)\n\t\t\t\t{\n\t\t\t\t\tx+=nowpos*(*buf-\'0\');\n\t\t\t\t\tnowpos*=0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx=x*10+*buf-\'0\';\n\t\t\t\t}\n\t\t\t}\n\t\t\t++buf;\n\t\t}\n\t\treturn true;\n\t}\n\tbool readChar(char c)\n\t{\n\t\tif(*buf==0) return 0;\n\t\treturn c=*buf++,1;\n\t}\n\tbool readString(char *s)\n\t{\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(!*buf) return false;\n\t\twhile(!isspace(*buf)) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn true;\n\t}\n\tint countSpacetonext(){\n\t\tint total=0;\n\t\twhile(*buf&&*buf==\' \') ++total,++buf;\n\t\treturn total;\n\t}\n\tbool splitBycharactor(char *s,char Split=\'\\n\'){\n\t\twhile(*buf&&*buf!=Split) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn *buf!=0;\n\t}\n};\n\nbool dp[55][55][55][55];\n\nchar card[55][5];\nint n;\n\nbool check(int i,int j){\n\treturn card[i][0]==card[j][0]||card[i][1]==card[j][1];\n}\nbool check3(){\n\tREP_1(i,n) if(!check(i,n)) return false;\n\treturn true;\n}\nbool checkall(){\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tif(dp[1][i][j][k]&&check(i,k)&&check(j,k))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n//\tfreopen(""a.out"",""w"",stdout);\n\tscanf(""%d"",&n);\n\tREP_1(i,n)\n\t{\n\t\tscanf(""%s"",card[i]);\n\t}\n\tif(n<=3)\n\t{\n\t\tprintf(""%s\\n"",check3()?""YES"":""NO"");\n\t}\n\telse\n\t{\n\t\tdp[n-2][n-2][n-1][n]=1;\n\t\tfor(int i=n-2;i>1;--i)\n\t\t{\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=1;l<=n;++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(dp[i][j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(check(i-1,l)) dp[i-1][l][j][k]=1;\n\t\t\t\t\t\t\tif(check(k,l)) dp[i-1][i-1][j][l]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(""%s\\n"",checkall()?""YES"":""NO"");\n\t}\n\tcin>>card[0];\n\treturn 0;\n}\n']","['dfs and similar', 'dp']",1900
https://codeforces.com//contest/1251/problem/E1,E1. Voting  Easy Version ,Now elections are held in Berland and you want to win them More precisely you want everyone to vote for you There are n voters and two ways to convince each of them to vote for you The first way to convince the i th voter is to pay him p i coins The second way is to make m i other voters vote for you and the i th voter will vote for free Moreover the process of such voting takes place in several steps For example if there are five voters with m 1 1 m 2 2 m 3 2 m 4 4 m 5 5 then you can buy the vote of the fifth voter and eventually everyone will vote for you Set of people voting for you will change as follows 5 rightarrow 1 5 rightarrow 1 2 3 5 rightarrow 1 2 3 4 5 Calculate the minimum number of coins you have to spend so that everyone votes for you ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e9 + 5;\nconst long long LL_INF = (long long) 2e18 + 5;\n\nstruct voter {\n    int M, P;\n\n    bool operator<(const voter &other) const {\n        return M < other.M;\n    }\n};\n\nint N;\nvector<voter> voters;\n\nlong long evaluate(int buy) {\n    int index = 0;\n    priority_queue<int> pq;\n\n    for (int position = buy; position < N; position++) {\n        while (index < N && voters[index].M <= position)\n            pq.push(voters[index++].P);\n\n        if (pq.empty())\n            return LL_INF - buy;\n\n        pq.pop();\n    }\n\n    while (index < N)\n        pq.push(voters[index++].P);\n\n    long long sum = 0;\n\n    while (!pq.empty()) {\n        sum += pq.top();\n        pq.pop();\n    }\n\n    return sum;\n}\n\nvoid solve_case() {\n    cin >> N;\n    voters.resize(N);\n\n    for (voter &v : voters)\n        cin >> v.M >> v.P;\n\n    sort(voters.begin(), voters.end());\n    int low = 0, high = N;\n\n    while (low < high) {\n        int mid = (low + high) / 2;\n\n        if (evaluate(mid) < evaluate(mid + 1))\n            high = mid;\n        else\n            low = mid + 1;\n    }\n\n    cout << evaluate(low) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0)\n        solve_case();\n}\n""]","['data structures', 'dp', 'greedy']",2300
https://codeforces.com//contest/1826/problem/B,B. Lunatic Never Content,You have an array a of n non negative integers Let s define f a x a 1 bmod x a 2 bmod x dots a n bmod x for some positive integer x Find the biggest x such that f a x is a palindrome Here a bmod x is the remainder of the integer division of a by x An array is a palindrome if it reads the same backward as forward More formally an array a of length n is a palindrome if for every i 1 leq i leq n a i a n i 1 ,"['#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint a[N];\nint n;\n\nvoid solve(){\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    int g = 0;\n    for(int i=1;i<=n;i++){\n        int id1 = i;\n        int id2 = n + 1 - i;\n        if(id2 <= id1) break;\n        if(a[id1] == a[id2]) continue;\n        int dif = abs(a[id1] - a[id2]);\n        g = __gcd(g, dif);\n    }\n    cout << g << ""\\n"";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n']","['math', 'number theory']",1100
https://codeforces.com//contest/1078/problem/B,B. The Unbearable Lightness of Weights,You have a set of n weights You know that their masses are a 1 a 2 a n grams but you don t know which of them has which mass You can t distinguish the weights However your friend does know the mass of each weight You can ask your friend to give you exactly k weights with the total mass m both parameters k and m are chosen by you and your friend will point to any valid subset of weights if it is possible You are allowed to make this query only once Find the maximum possible number of weights you can reveal after this query ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1001000027;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<int> freq(101, 0);\n\tvector<vector<LL> > knap(101, vector<LL>(11000, 0));\n\tknap[0][0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tfreq[a[i]]++;\n\t\tvector<vector<LL> > s(101, vector<LL>(11000, 0));\n\t\tfor(int b = 0; b <= 100; b++){\n\t\t\tfor(int f = 0; f <= 10000; f++){\n\t\t\t\tif(knap[b][f] == 0) continue;\n\t\t\t\ts[b][f] += knap[b][f];\n\t\t\t\ts[b][f] %= MOD;\n\t\t\t\ts[b+1][f+a[i]] += knap[b][f];\n\t\t\t\ts[b+1][f+a[i]] %= MOD;\n\t\t\t}\n\t\t}\n\t\tknap = s;\n\t}\n\tLL ncr[110][110];\n\tfor(LL n = 0; n <= 100; n++){\n\t\tfor(LL k = 0; k <= 100; k++){\n\t\t\tif(k > n){\n\t\t\t\tncr[n][k] = 0;\n\t\t\t} else if(k == 0 || k == n){\n\t\t\t\tncr[n][k] = 1;\n\t\t\t} else {\n\t\t\t\tncr[n][k] = (ncr[n-1][k] + ncr[n-1][k-1]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tint best = 0;\n\tint types = 0;\n\tfor(int d = 1; d <= 100; d++){\n\t\tif(freq[d] > 0) types++;\n\t}\n\tfor(int d = 1; d <= 100; d++){\n\t\tfor(int num = 1; num <= freq[d]; num++){\n\t\t\tif(knap[num][d*num] == ncr[freq[d]][num]){\n\t\t\t\tbest = max(best, num);\n\t\t\t\tif(num == freq[d] && types <= 2){\n\t\t\t\t\tbest = n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << best << '\\n';\n}""]","['dp', 'math']",2100
https://codeforces.com//contest/607/problem/D,D. Power Tree,Genos and Saitama went shopping for Christmas trees However a different type of tree caught their attention the exalted Power Tree A Power Tree starts out as a single root vertex indexed A Power Tree grows through a magical phenomenon known as an update In an a single vertex is added to the tree as a child of some other vertex Every vertex in the tree the root and all the added vertices has some value associated with it The of a vertex is defined as the strength of the multiset composed of the value associated with this vertex and the of its direct children The of a multiset is defined as the sum of all elements in the multiplied by the number of elements in it Or in other words for some Saitama knows the that will be performed on the tree so he decided to test Genos by asking him queries about the tree during its growth cycle An update is of the form and adds a new vertex with value as a child of vertex A query is of the form and asks for the power of vertex Please help Genos respond to these queries modulo ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\ninline int fpm(LL b, int e, int m)\n{\n\tb %= m;\n\tLL t = 1;\n\tfor ( ; e; e >>= 1, (b *= b) %= m)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nconst int Mod = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 200000;\n\nint n;\n\nstruct node;\n \nnode *newnode();\n \nstruct node\n{\n\tnode *c[2];\n\n\tint sum;\n\tint label;\n \n\tnode(): sum(0), label(1) { memset(c, 0, sizeof c); }\n \n\tvoid update()\n\t{\n\t\tsum = 0;\n\t\tREP(i, 0, 2) if (c[i]) (sum += c[i]->sum) %= Mod;\n\t}\n\n\tvoid flag_label(int _label)\n\t{\n\t\tlabel = (LL)label * _label % Mod;\n\t\tsum = (LL)sum * _label % Mod;\n\t}\n\n\tvoid push_down()\n\t{\n\t\tif (label)\n\t\t{\n\t\t\tREP(i, 0, 2) c[i]->flag_label(label);\n\t\t\tlabel = 1;\n\t\t}\n\t}\n \n};\n\nconst int max0 = 100000;\n \nnode *nd_pool;\nint nd_res = 0;\n \nnode *newnode()\n{\n\tif (!nd_res) nd_pool = new node[max0], nd_res = max0;\n\treturn nd_pool + (--nd_res);\n}\n \nnode *rt;\n \nint seg_x, seg_y, seg_z;\n \nvoid add(node *&rt, int l, int r)\n{\n\tif (seg_x <= l && r <= seg_y)\n\t{\n\t\trt->flag_label(seg_z);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\trt->push_down();\n\tif (seg_x < mid) add(rt->c[0], l, mid);\n\tif (seg_y > mid) add(rt->c[1], mid, r);\n\trt->update();\n}\n\ninline bool seg_add(int x, int y, int z)\n{\n\tif (x >= y) return 0;\n\tseg_x = x, seg_y = y, seg_z = z;\n\tadd(rt, 0, n);\n\treturn 1;\n}\n\ninline void query(node *rt, int l, int r)\n{\n\tif (seg_x <= l && r <= seg_y)\n\t{\n\t\t(seg_z += rt->sum) %= Mod;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\trt->push_down();\n\tif (seg_x < mid) query(rt->c[0], l, mid);\n\tif (seg_y > mid) query(rt->c[1], mid, r);\n}\n\ninline int seg_query(int x, int y)\n{\n\tif (x >= y) return 0;\n\tseg_x = x, seg_y = y, seg_z = 0;\n\tquery(rt, 0, n);\n\treturn seg_z;\n}\n\nint pos[maxn + 5];\nint v[maxn + 5];\n\ninline void build(node *&rt, int l, int r)\n{\n\trt = newnode();\n\tif (r - l <= 1) \n\t{\n\t\trt->sum = v[pos[l]];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(rt->c[0], l, mid);\n\tbuild(rt->c[1], mid, r);\n\trt->update();\n}\n\nstruct edge\n{\n\tint id, nxt;\n\n\tedge() { }\n\tedge(int _id, int _nxt): id(_id), nxt(_nxt) { }\n\n};\n\nedge e[maxn + 5];\nint st[maxn + 5], en = 0;\n\ninline void add_edge(int x, int y)\n{\n\te[en] = edge(y, st[x]), st[x] = en++;\n}\n\nint dfn[maxn + 5], End[maxn + 5];\nint tot = 0;\nint w[maxn + 5];\n\nint seq[maxn + 5], deg[maxn + 5];\nint fa[maxn + 5];\n\nvoid dfs(int x, int now)\n{\n\tpos[dfn[x] = tot++] = x;\n\tv[x] = (LL)w[x] * now % Mod;\n\tfor (int i = st[x]; i != -1; i = e[i].nxt)\n\t{\n\t\tint y = e[i].id;\n\t\tdfs(y, (LL)now * deg[y] % Mod);\n\t}\n\tEnd[x] = tot;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tmemset(st, -1, sizeof st), en = 0;\n\tint m;\n\tscanf(""%d%d"", w, &m);\n\tn = 1;\n\tREP(i, 0, m)\n\t{\n\t\tint ty, p, v;\n\t\tscanf(""%d"", &ty);\n\t\tif (ty == 1) scanf(""%d%d"", &p, &v), --p, fa[n] = p, ++deg[p], add_edge(p, n), seq[i] = n << 1, w[n++] = v;\n\t\telse scanf(""%d"", &p), --p, seq[i] = p << 1 | 1;\n\t}\n\tREP(i, 0, n) ++deg[i];\n\tdfs(0, deg[0]);\n\tbuild(rt, 0, n);\n\tvector<int> ans;\n\tfor (int i = m - 1; i >= 0; --i)\n\t{\n\t\tint x = seq[i] >> 1;\n\t\tif (seq[i] & 1)\n\t\t{\n\t\t\tint tmp = seg_query(dfn[x], dfn[x] + 1);\n\t\t\tint tmp0 = seg_query(dfn[x], End[x]);\n\t\t\ttmp = (LL)tmp * fpm(w[x], Mod - 2, Mod) % Mod * fpm(deg[x], Mod - 2, Mod) % Mod;\n\t\t\tans.pb((LL)tmp0 * fpm(tmp, Mod - 2, Mod) % Mod);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tseg_add(dfn[x], dfn[x] + 1, 0);\n\t\t\tx = fa[x];\n\t\t\tint lyc = (LL)(deg[x] - 1) * fpm(deg[x], Mod - 2, Mod) % Mod;\n\t\t\t--deg[x];\n\t\t\tseg_add(dfn[x], End[x], lyc);\n\t\t}\n\t}\n\treverse(ALL(ans));\n\tfor (auto it : ans) printf(""%d\\n"", it);\n\treturn 0;\n}\n']","['data structures', 'trees']",2600
https://codeforces.com//contest/1025/problem/C,C. Plasticine zebra,Is there anything better than going to the zoo after a tiresome week at work No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras Inspired by this adventure and an accidentally found plasticine pack represented as a sequence of black and white stripes Grisha now wants to select several consequent contiguous pieces of alternating colors to create a zebra Let s call the number of selected pieces the length of the zebra Before assembling the zebra Grisha can make the following operation 0 or more times He splits the sequence in some place into two parts then reverses each of them and sticks them together again For example if Grisha has pieces in the order here denotes a black strip and denotes a white strip then he can split the sequence as here the vertical bar represents the cut reverse both parts and obtain Determine the maximum possible length of the zebra that Grisha can produce ,"['#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<""=""<<h<<""\\n""; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != \',\')cerr<<*sdbg++; cerr<<""=""<<h<<"",""; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<"" = ""; FORE(itt, (x)) cerr <<*itt <<"", ""; cerr <<""\\n""; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << ""("" << pair.first << "", "" << pair.second << "")"";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << ""("" << t.st << "", "" << t.nd << "", "" << t.rd << "")""; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\n\n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  string s;\n  cin>>s;\n  int n = SZ(s);\n  s = s + s;\n  int cur = 1;\n  int best = 1;\n  RE (i, SZ(s) - 1) {\n    if (s[i] != s[i - 1]) {\n      cur++;\n      maxi(best, cur);\n    } else {\n      cur = 1;\n    }\n  }\n  cout<<min(best, n)<<endl;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n']","['constructive algorithms', 'implementation']",1600
https://codeforces.com//contest/621/problem/E,E. Wet Shark and Blocks,There are blocks of digits Each one consisting of the same digits which are given to you in the input Wet Shark must choose digit from each block and concatenate all of those digits together to form one large integer For example if he chooses digit from the first block and digit from the second block he gets the integer Wet Shark then takes this number modulo Please tell him how many ways he can choose one digit from each block so that he gets exactly as the final result As this number may be too large print it modulo Note that the number of ways to choose some digit in the block is equal to the number of it s occurrences For example there are ways to choose digit from block ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int((x).size()))\n#define bit(x) (1 << (x))\n#define cnt1(x) (__builtin_popcount(x))\n\ntemplate<class T, class U>\ninline void chkmax(T& x, U y) {\n\tif (x < y) x = y;\n}\n\ntemplate<class T, class U>\ninline void chkmin(T& x, U y) {\n\tif (y < x) x = y;\n}\n\ntypedef long long LL;\ntypedef double DB;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\nconst int MX = 105;\nconst int M = 1000000007;\nint x;\nint r[MX][MX], a[MX][MX];\nint tp[MX][MX];\nint c[10];\n\ninline void add(int& x, int y) {\n\tx += y;\n\tif (x >= M) x -= M;\n}\n\nvoid mul(int a[MX][MX], int b[MX][MX]) {\n\tint i, j, k, val;\n\t\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < x; j++) {\n\t\t\tval = 0;\n\t\t\tfor (k = 0; k < x; k++) add(val, LL(a[i][k]) * b[k][j] % M);\n\t\t\ttp[i][j] = val;\n\t\t}\n\t}\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < x; j++) a[i][j] = tp[i][j];\n\t}\n}\n\nint main() {\n//\tfreopen(""in.txt"", ""r"", stdin);\n//\tfreopen(""out.txt"", ""w"", stdout);\n\t\n\tint n, b, k, i, t;\n\t\n\tscanf(""%d%d%d%d"", &n, &b, &k, &x);\n\twhile (n--) {\n\t\tscanf(""%d"", &t);\n\t\tc[t]++;\n\t}\n\tfor (i = 0; i < x; i++) {\n\t\tfor (t = 0; t < 10; t++) {\n\t\t\tadd(a[i][(i * 10 + t) % x], c[t]);\n\t\t}\n\t}\n\tfor (i = 0; i < x; i++) r[i][i]++;\n\tfor (; b; b /= 2) {\n\t\tif (b & 1) mul(r, a);\n\t\tmul(a, a);\n\t}\n\tprintf(""%d\\n"", r[0][k]);\n\treturn 0;\n}']","['dp', 'matrices']",2000
https://codeforces.com//contest/1644/problem/A,A. Doors and Keys,The knight is standing in front of a long and narrow hallway A princess is waiting at the end of it In a hallway there are three doors a red door a green door and a blue door The doors are placed one after another however possibly in a different order To proceed to the next door the knight must first open the door before Each door can be only opened with a key of the corresponding color So three keys a red key a green key and a blue key are also placed somewhere in the hallway To open the door the knight should first pick up the key of its color The knight has a map of the hallway It can be transcribed as a string consisting of six characters denoting red green and blue doors respectively denoting red green and blue keys respectively Each of these six characters appears in the string exactly once The knight is standing at the beginning of the hallway on the left on the map Given a map of the hallway determine if the knight can open all doors and meet the princess at the end of the hallway ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (""avx2"")\n#pragma GCC optimization (""O3"")\n#pragma GCC optimization (""unroll-loops"")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  1e9 + 7;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    string s; cin>>s;\n    set<int> have;\n    for (auto c: s)\n    {\n        if (\'a\'<=c && c<=\'z\') have.insert(c-\'a\');\n        else\n        {\n            if (!have.count(c-\'A\')) {cout<<""NO""<<endl; return;}\n        }\n    }\n    cout<<""YES""<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n']",['implementation'],800
https://codeforces.com//contest/1352/problem/E,E. Special Elements,The array a a 1 a 2 ldots a n 1 le a i le n is given Its element a i is called special if there exists a pair of indices l and r 1 le l r le n such that a i a l a l 1 ldots a r In other words an element is called special if it can be represented as the sum of of an array no matter if they are special or not Print the number of special elements of the given array a For example if n 9 and a 3 1 4 1 5 9 2 6 5 then the answer is 5 a 3 4 is a special element since a 3 4 a 1 a 2 3 1 a 5 5 is a special element since a 5 5 a 2 a 3 1 4 a 6 9 is a special element since a 6 9 a 1 a 2 a 3 a 4 3 1 4 1 a 8 6 is a special element since a 8 6 a 2 a 3 a 4 1 4 1 a 9 5 is a special element since a 9 5 a 2 a 3 1 4 Please note that some of the elements of the array a may be equal if several elements are equal and special then all of them should be counted in the answer ,"['#include <bits/stdc++.h>\n \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n    void solve () {\n       \n       \n         /* --------- */\n       \n    int a;\n    cin>>a;\n    int m[a];\n    for (int i=0;i<a;i++) cin>>m[i];\n    \n    int pref[a];\n    vector <bool> kek(a+1);\n    for (int i=0;i<a;i++) {\n        if (i==0) pref[i]=0; else pref[i]=pref[i-1];\n        pref[i]+=m[i];\n    }\n    for (int i=0;i<a;i++) {\n        for (int j=i+1;j<a;j++) {\n           int lol=pref[j]-(i?pref[i-1]:0); if (lol<=a) kek[lol]=true;  \n        }\n    }\n    int ans=0;\n    for (int i=0;i<a;i++) if (kek[m[i]]) ans++; \n    cout<<ans<<""\\n""; \n        /* --------- */   \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(false);\n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n       \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }\n']","['brute force', 'implementation', 'two pointers']",1500
https://codeforces.com//contest/955/problem/F,F. Heaps,You re given a tree with vertices rooted at We say that there s a ary heap of depth located at if the following holds For itself is a ary heap of depth For vertex is a ary heap of depth if of its children are ary heaps of depth Denote as maximum depth of ary heap in the subtree of including Your goal is to compute ,"['#include<bits/stdc++.h>\n#define RAN(v)v.begin(),v.end()\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\nusing namespace std;\ntemplate<class T1,class T2>\ninline void upd1(T1&a,T2 b){a>b?a=b:0;}\ntemplate<class T1,class T2>\ninline void upd2(T1&a,T2 b){a<b?a=b:0;}\ntypedef long long ll;\nstruct ano{\n\toperator ll(){\n\t\tll x=0,y=0,c=getchar();\n\t\twhile(c<48)\n\t\t\ty=c==45,c=getchar();\n\t\twhile(c>47)\n\t\t\tx=x*10+c-48,c=getchar();\n\t\treturn y?-x:x;\n\t}\n}buf;\nconst int N=3e5+5;\nvector<int>t[N];\nll s=0;\nint n,f[20][N],g[20][N];\nint dfs(int u,int p){\n\tint l=1;\n\tfor(int v:t[u])\n\t\tif(v!=p)\n\t\t\tupd2(l,dfs(v,u)+1);\n\ts+=l;\n\tf[1][u]=n;\n\tg[1][u]=n;\n\tfor(int i=2;;++i){\n\t\tvector<int>a;\n\t\tfor(int v:t[u])\n\t\t\tif(v!=p)\n\t\t\t\ta.pb(-f[i-1][v]);\n\t\tsort(RAN(a));\n\t\tf[i][u]=1;\n\t\tfor(int k=a.size();k>1;--k)\n\t\t\tif(-a[k-1]>=k){\n\t\t\t\tf[i][u]=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(f[i][u]==1)\n\t\t\tbreak;\n\t}\n\tfor(int i=2;;++i){\n\t\tfor(int v:t[u])\n\t\t\tif(v!=p)\n\t\t\t\tupd2(g[i][u],g[i][v]);\n\t\tupd2(g[i][u],f[i][u]);\n\t\ts+=(i-1)*(g[i-1][u]-g[i][u]);\n\t\tif(g[i][u]==1)\n\t\t\tbreak;\n\t}\n\treturn l;\n}\nint main(){\n\tn=buf;\n\tfor(int i=2;i<=n;++i){\n\t\tint u=buf,v=buf;\n\t\tt[u].pb(v);\n\t\tt[v].pb(u);\n\t}\n\tdfs(1,0);\n\tprintf(""%lld\\n"",s);\n}\n']","['dp', 'trees']",2600
https://codeforces.com//contest/403/problem/D,D. Beautiful Pairs of Numbers,The sequence of integer pairs is if the following statements are fulfilled where is a given positive integer all numbers are distinct For the given number find the number of beautiful sequences of length As the answer can be rather large print the remainder after dividing it by ,"['#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<"" = ""<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define MD 1000000007\n#define maxn 1010\n\nint C[maxn][maxn], fact[maxn], dp[maxn][maxn];\n\nvoid su(int &a, int b)\n{\n\ta+=b; if (a>=MD) a-=MD;\n}\n\nvoid lemon()\n{\n\tC[0][0]=1;\n\trep(i,1,1000)\n\t{\n\t\tC[i][0]=1; C[i][i]=1;\n\t\trep(j,1,i-1)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%MD;\n\t}\n\t\n\tfact[0]=1;\n\trep(i,1,1000) fact[i]=LL(fact[i-1])*i%MD;\n\t\n\t//dp[s][k]=sum(dp[s-k*i+1][k-1]) i>=1\n\trep(s,0,1000)\n\t{\n\t\tdp[s][1]=1;\n\t\trep(k,2,1000)\n\t\t\trep(i,1,(s+1)/k)\n\t\t\t\tsu(dp[s][k],dp[s-i*k+1][k-1]);\n\t}\n\t\n\trep(s,0,1000)\n\t\trep(k,0,1000)\n\t\t\tdp[s][k]=LL(dp[s][k])*fact[k]%MD;\n\t\t\t\n\tint tcase; scanf(""%d"",&tcase);\n\twhile (tcase--)\n\t{\n\t\tint n,k; scanf(""%d%d"",&n,&k);\n\t\tint final=0;\n\t\trep(s,0,n)\n\t\t\tsu(final,LL(C[n-s][k])*dp[s][k]%MD);\n\t\tprintf(""%d\\n"",final);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""D.in"",""r"",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n']","['combinatorics', 'dp']",2300
https://codeforces.com//contest/1658/problem/C,C. Shinju and the Lost Permutation,Shinju loves permutations very much Today she has borrowed a permutation p from Juju to play with The i th cyclic shift of a permutation p is a transformation on the permutation such that p p 1 p 2 ldots p n will now become p p n i 1 ldots p n p 1 p 2 ldots p n i Let s define the of permutation p as the number of distinct elements in the prefix maximums array b of the permutation The prefix maximums array b is the array of length n such that b i max p 1 p 2 ldots p i For example the power of 1 2 5 4 6 3 is 4 since b 1 2 5 5 6 6 and there are 4 distinct elements in b Unfortunately Shinju has lost the permutation p The only information she remembers is an array c where c i is the of the i 1 th cyclic shift of the permutation p She s also not confident that she remembers it correctly so she wants to know if her memory is good enough Given the array c determine if there exists a permutation p that is consistent with c You do have to construct the permutation p A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint a[1000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin >> a[i];\n\t\ta[n+1]=a[1];\n\t\tint cnt1=0,flag=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i+1]>a[i]+1) flag=0;\n\t\t\tif(a[i]==1) ++cnt1;\n\t\t}\n\t\tif(cnt1==1&&flag) cout << ""YES\\n"";\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'math']",1700
https://codeforces.com//contest/362/problem/A,A. Two Semiknights Meet,A boy Petya loves chess very much He even came up with a chess piece of his own a semiknight The semiknight can move in any of these four directions squares forward and squares to the right squares forward and squares to the left squares backward and to the right and squares backward and to the left Naturally the semiknight cannot move beyond the limits of the chessboard Petya put two semiknights on a standard chessboard Petya simultaneously moves with both semiknights The squares are rather large so after some move the semiknights can meet that is they can end up in the same square After the meeting the semiknights can move on so it is possible that they meet again Petya wonders if there is such sequence of moves when the semiknights meet Petya considers some squares bad That is they do not suit for the meeting The semiknights can move through these squares but their meetings in these squares don t count Petya prepared multiple chess boards Help Petya find out whether the semiknights can meet on some good square for each board Please see the test case analysis ,"['#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <sstream>\n#include <assert.h>\n#include <complex>\n\n#include <time.h>\n#pragma comment(linker, ""/STACK:20000000"")\n\n#define fr(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define fd(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nusing namespace std;\n\nint ri(){int x;scanf(""%d"",&x);return x;}\nll rll(){ll x;scanf(""%lld"",&x);return x;}\n\nint dx[] = {2,2,-2,-2};\nint dy[] = {2,-2,2,-2};\n\nint used[3][10][10];\n\nvoid solve()\n{\n\tint test = ri();\n\tfr(testin,1,test)\n\t{\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<string> mas;\n\t\tfr(i,0,7)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tmas.pb(s);\n\t\t}\n\t\tint cnt = 0;\n\t\tvector<pair<int,int> > omg;\n\t\tfr(i,0,7)\n\t\t{\n\t\t\tfr(j,0,7)\n\t\t\t\tif (mas[i][j] == \'K\')\n\t\t\t\t{\n\t\t\t\t\tomg.pb(mp(i,j));\n\t\t\t\t\t\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[cnt][i][j] = 1;\n\t\t\t\t\tqueue<pair<int,int> > st;\n\t\t\t\t\tst.push(mp(i,j));\n\t\t\t\t\twhile(!st.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint x = st.front().first;\n\t\t\t\t\t\tint y = st.front().second;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tfr(k,0,3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint xx = x + dx[k],yy = y + dy[k];\n\t\t\t\t\t\t\tif (xx >= 0 && xx < 8 && yy >= 0 && yy < 8 && !used[cnt][xx][yy])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tused[cnt][xx][yy] = used[cnt][x][y] + 1;\n\t\t\t\t\t\t\t\tst.push(mp(xx,yy));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t}\n\t\tbool yes = false;\n\t\tfr(i,0,7)\n\t\t\tfr(j,0,7)\n\t\t\tif (used[1][i][j] && used[2][i][j] && ((used[1][i][j] % 2) == (used[2][i][j]%2)) &&  mas[i][j] !=\'#\')\n\t\t\t\t{\n\t\t\t\t\tyes = true;\n\t\t\t\t}\n\t\t//int cnt = abs(omg[0].first - omg[1].first) + abs(omg[1].second - omg[0].second);\n\t\tif (yes)\n\t\t\tcout << ""YES"" << endl;\n\t\telse\n\t\t\tcout << ""NO"" << endl;\n\t}\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/input.txt"",""rt"",stdin);\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/output.txt"",""wt"",stdout);\n\t#else\n\t\t//freopen(""cubroot.in"",""rt"",stdin);\n\t\t//freopen(""cubroot.out"",""wt"",stdout);\n\t#endif\n\n\tsolve();\n\n\t#ifndef ONLINE_JUDGE\n\t\tprintf(""\\n\\ntime-%.3lf"",clock()*1e-3);\n\t#endif\n\n\treturn 0;\n}']","['greedy', 'math']",1500
https://codeforces.com//contest/1490/problem/E,E. Accidental Victory,A championship is held in Berland in which n players participate The player with the number i has a i a i ge 1 tokens The championship consists of n 1 games which are played according to the following rules in each game two random players with non zero tokens are selected the player with more tokens is considered the winner of the game in case of a tie the winner is chosen randomly the winning player takes all of the loser s tokens The last player with non zero tokens is the winner of the championship All random decisions that are made during the championship are made equally probable and independently For example if n 4 a 1 2 4 3 then one of the options for the game there could be other options is during the first game the first and fourth players were selected The fourth player has more tokens so he takes the first player s tokens Now a 0 2 4 4 during the second game the fourth and third players were selected They have the same number of tokens but in a random way the third player is the winner Now a 0 2 8 0 during the third game the second and third players were selected The third player has more tokens so he takes the second player s tokens Now a 0 0 10 0 the third player is declared the winner of the championship Championship winners will receive personalized prizes Therefore the judges want to know in advance which players have a chance of winning i e have a non zero probability of winning the championship You have been asked to find all such players ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nvector<pair<int, int>> v;\nvector<int> ans;\n\nint main()\n{\n\tint t;\n\tint n;\n\tint x;\n\tint i;\n\tint s;\n\tlong long sum;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tv.clear();\n\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x;\n\t\t\tv.push_back(make_pair(x, i + 1));\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tif (v[0].first == v[n - 1].first)\n\t\t{\n\t\t\tcout << n << '\\n';\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tcout << i << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tans.clear();\n\t\tsum = 0;\n\t\ts = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (sum < v[i].first)\n\t\t\t{\n\t\t\t\ts = i;\n\t\t\t}\n\n\t\t\tsum += v[i].first;\n\t\t}\n\n\t\tfor (i = s; i < n; i++)\n\t\t{\n\t\t\tans.push_back(v[i].second);\n\t\t}\n\n\t\tsort(ans.begin(), ans.end());\n\n\t\tcout << ans.size() << '\\n';\n\t\tfor (i = 0; i < ans.size(); i++)\n\t\t{\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]","['binary search', 'data structures', 'greedy']",1400
https://codeforces.com//contest/1929/problem/E,E. Sasha and the Happy Tree Cutting,Sasha was given a tree dagger with n vertices as a prize for winning yet another competition However upon returning home after celebrating his victory he noticed that some parts of the tree were missing Sasha remembers that he colored some of the edges of this tree He is certain that for any of the k pairs of vertices a 1 b 1 ldots a k b k he colored at least one edge on the simple path ddagger between vertices a i and b i Sasha does not remember how many edges he exactly colored so he asks you to tell him the minimum number of edges he could have colored to satisfy the above condition dagger A tree is an undirected connected graph without cycles ddagger A simple path is a path that passes through each vertex at most once ,"['#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nvector<int>v[300005];\nint sy[45],cnt;\nint bu[25],bv[25],blc[25];\nint bz[300005][20];\nint dep[300005];\nint dfn[300005],siz[300005],tmp;\nint dp[1049576];\nvoid dfs(int x,int f)\n{\n\tdfn[x]=++tmp;\n\tsiz[x]=1;\n\tdep[x]=dep[f]+1;\n\tbz[x][0]=f;\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tbz[x][i]=bz[bz[x][i-1]][i-1];\t\n\t}\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==f)continue;\n\t\tdfs(v[x][i],x);\n\t\tsiz[x]+=siz[v[x][i]];\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dep[bz[x][i]]>=dep[y])x=bz[x][i];\n\t}\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(bz[x][i]!=bz[y][i])\n\t\t{\n\t\t\tx=bz[x][i];\n\t\t\ty=bz[y][i];\n\t\t}\n\t}\n\treturn bz[x][0];\n} \nint findzx(int x,int k)\n{\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(k>=(1<<i))\n\t\t{\n\t\t\tk-=(1<<i);\n\t\t\tx=bz[x][i];\n\t\t}\n\t}\n\treturn x;\n}\nint pd(int x,int y,int z)\n{\n\tint ans=0;\n\tif(dfn[x]>=dfn[z]&&dfn[x]<=dfn[z]+siz[z]-1)ans++;\n\tif(dfn[y]>=dfn[z]&&dfn[y]<=dfn[z]+siz[z]-1)ans++;\n\tif(ans==1)return true;\n\treturn false;\n}\nsigned main()\n{\n\tint t,n,k,x,y;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t\tcnt=0;\n\t\ttmp=0;\n\t\tdfs(1,0);\n\t\tk=read();\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tbu[i]=read();\n\t\t\tbv[i]=read();\n\t\t\tblc[i]=lca(bu[i],bv[i]);\t\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tif(bu[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bu[i],dep[bu[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0;\n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bv[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bv[i],dep[bv[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0; \n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(""%d\\n"",cnt);\n\t\t//for(int i=1;i<=cnt;i++)printf(""%d "",sy[i]);\n\t//\tprintf(""\\n"");\n\t\tfor(int i=0;i<(1<<k);i++)dp[i]=1000000000;\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<k);i++)\n\t\t{\n\t\t\tif(dp[i]==1000000000)continue;\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tdp[i|sy[j]]=min(dp[i|sy[j]],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",dp[(1<<k)-1]);\n\t}\n}\n']","['bitmasks', 'brute force', 'dfs and similar', 'dp', 'graphs', 'greedy', 'math', 'trees']",2300
https://codeforces.com//contest/1303/problem/D,D. Fill The Bag,You have a bag of size n Also you have m boxes The size of i th box is a i where each a i is an integer non negative power of two You can divide boxes into two parts of equal size Your goal is to fill the bag completely For example if n 10 and a 1 1 32 then you have to divide the box of size 32 into two parts of size 16 and then divide the box of size 16 So you can fill the bag with boxes of size 1 1 and 8 Calculate the minimum number of divisions required to fill the bag of size n ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nll n;\nll m, c[61];\n\nvoid solve() {\n\tcin >> n >> m;\n\tmemset(c, 0, sizeof(c));\n\tll s=0;\n\tfor(int i=0, a; i<m; ++i) {\n\t\tcin >> a;\n\t\ts+=a;\n\t\t++c[31-__builtin_clz(a)];\n\t}\n\tif(s<n) {\n\t\tcout << ""-1\\n"";\n\t\treturn;\n\t}\n\tint ans=0;\n\tfor(int i=0; i<60; ++i) {\n\t\tif(n>>i&1) {\n\t\t\tif(!c[i]) {\n\t\t\t\tint j=i+1;\n\t\t\t\twhile(!c[j])\n\t\t\t\t\t++j;\n\t\t\t\t--c[j];\n\t\t\t\twhile(--j>=i) {\n\t\t\t\t\t++c[j];\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t\t++c[i];\n\t\t\t}\n\t\t\t--c[i];\n\t\t}\n\t\tc[i+1]+=c[i]/2;\n\t}\n\tcout << ans << ""\\n"";\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n}']","['bitmasks', 'greedy']",1900
https://codeforces.com//contest/254/problem/B,B. Jury Size,In 2013 the writers of Berland State University should prepare problems for Olympiads We will assume that the Olympiads are numbered with consecutive integers from 1 to For each Olympiad we know how many members of the jury must be involved in its preparation as well as the time required to prepare the problems for her Namely the Olympiad number should be prepared by people for days the preparation for the Olympiad should be a continuous period of time and end exactly one day before the Olympiad On the day of the Olympiad the juries who have prepared it already do not work on it For example if the Olympiad is held on December 9th and the preparation takes 7 people and 6 days all seven members of the jury will work on the problems of the Olympiad from December 3rd to December 8th the jury members won t be working on the problems of this Olympiad on December 9th that is some of them can start preparing problems for some other Olympiad And if the Olympiad is held on November 3rd and requires 5 days of training the members of the jury will work from October 29th to November 2nd In order not to overload the jury the following rule was introduced one member of the jury can not work on the same day on the tasks for different Olympiads Write a program that determines what the minimum number of people must be part of the jury so that all Olympiads could be prepared in time ,"['#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[1000];\nint mon[13];\nconst int dt = 366;\nint main()\n{\n\tint n;\n\tfreopen( ""input.txt"", ""r"", stdin);\n\tfreopen( ""output.txt"", ""w"", stdout);\n\tmon[0] = 0;\n\tmon[1] = 31;\n\tmon[2] = 31 + 28;\n\tmon[3] = mon[2] + 31;\n\tmon[4] = mon[3] + 30;\n\tmon[5] = mon[4] + 31;\n\tmon[6] = mon[5] + 30;\n\tmon[7] = mon[6] + 31;\n\tmon[8] = mon[7] + 31;\n\tmon[9] = mon[8] + 30;\n\tmon[10] = mon[9] + 31;\n\tmon[11] = mon[10] + 30;\n\tmon[12] = mon[11] + 31;\n\tscanf( ""%d"", &n );\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tint m,d,r,t,l;\n\t\tscanf( ""%d%d%d%d"", &m, &d, &r, &t );\n\t\t\tl = mon[m - 1] + d - t;\n\t\t\tfor ( int j = 0; j < t; j++ )\n\t\t\t{\n\t\t\t\ta[l+dt+j]+=r;\n//\t\t\t\tprintf( ""%d\\n"", l+dt+j );\n\t\t\t}\n\t}\n\tint m = 0;\n\tfor ( int i = 0; i < 800; i++ )\n\tif ( a[i] > m ) m = a[i];\n\tprintf( ""%d\\n"", m );\n\treturn 0;\n}']","['brute force', 'implementation']",1500
https://codeforces.com//contest/1823/problem/C,C. Strongly Composite,A number is an integer greater than 1 which has exactly two divisors For example 7 is a prime since it has two divisors 1 7 A number is an integer greater than 1 which has more than two different divisors Note that the integer 1 is neither prime nor composite Let s look at some composite number v It has several divisors some divisors are prime others are composite themselves If the number of prime divisors of v is to the number of composite divisors let s name v as For example number 12 has 6 divisors 1 2 3 4 6 12 two divisors 2 and 3 are prime while three divisors 4 6 and 12 are composite So 12 is strongly composite Other examples of strongly composite numbers are 4 8 9 16 and so on On the other side divisors of 15 are 1 3 5 15 3 and 5 are prime 15 is composite So 15 is not a strongly composite Other examples are 2 3 5 6 7 10 and so on You are given n integers a 1 a 2 dots a n a i 1 You have to build an array b 1 b 2 dots b k such that following conditions are satisfied Product of all elements of array a is equal to product of all elements of array b a 1 cdot a 2 cdot ldots cdot a n b 1 cdot b 2 cdot ldots cdot b k All elements of array b are integers greater than 1 and The size k of array b is the maximum possible Find the size k of array b or report that there is no array b satisfying the conditions ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,M=10000005;\n\nvector<int> pr;\nint lpd[M];\nvoid sieve(){\n    pr.clear();\n    for(int i=0; i<M; ++i) lpd[i]=-1;\n    for(int i=2; i<M; ++i){\n        if(lpd[i]==-1) lpd[i]=i,pr.pb(i);\n        for(auto p: pr){\n            if(p*i>=M) break;\n            lpd[p*i]=p;\n            if(i%p==0) break;\n        }\n    }\n}\nvector<int> factors(int x){\n    vector<int> res;\n    while(x>1) res.pb(lpd[x]),x/=lpd[x];\n    return res;\n}\n\nint n,a[N];\n\nvoid ldc(){\n    cin >> n;\n    map<int,int> mm;\n    for(int i=0; i<n; ++i){\n        int x; cin >> x;\n        vector<int> vec=factors(x);\n        for(auto j: vec) mm[j]++;\n    }\n    vector<int> vec;\n    for(auto [x,y]: mm) vec.pb(y);\n    sort(all(vec));\n    if(vec.back()==1&&sz(vec)<=2){\n        cout << ""0\\n"";\n        return;\n    }\n    int cnt1=0,cnt2=0;\n    for(auto i: vec) cnt1+=i>>1,cnt2+=i&1;\n    cout << cnt1+cnt2/3 << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    sieve();\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']","['greedy', 'math', 'number theory']",1300
https://codeforces.com//contest/1265/problem/A,A. Beautiful String,A string is called beautiful if no two consecutive characters are equal For example and are beautiful strings while and are not Ahcl wants to construct a beautiful string He has a string s consisting of only characters and Ahcl needs to replace each character with one of the three characters or such that the resulting string is beautiful Please help him More formally after replacing all characters the condition s i neq s i 1 should be satisfied for all 1 leq i leq s 1 where s is the length of the string s ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=1e5+5;\nchar s[maxn];\nint n;\nint main(){\n\tint cas=read();\n\twhile(cas--){\n\t\tscanf(""%s"",s+1);\n\t\tn=strlen(s+1);\n\t\tint ok=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]==\'?\'){\n\t\t\t\tif(s[i-1]!=\'a\'&&s[i+1]!=\'a\')s[i]=\'a\';\n\t\t\t\telse if(s[i-1]!=\'b\'&&s[i+1]!=\'b\')s[i]=\'b\';\n\t\t\t\telse if(s[i-1]!=\'c\'&&s[i+1]!=\'c\')s[i]=\'c\';\n\t\t\t}else{\n\t\t\t\tif(s[i]==s[i-1]){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(""-1"");\n\t\telse{\n\t\t\tfor(int i=1;i<=n;i++)cout<<s[i];cout<<\'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n\n']","['constructive algorithms', 'greedy']",1000
https://codeforces.com//contest/284/problem/A,A. Cows and Primitive Roots,The cows have just learned what a primitive root is Given a prime a primitive root is an integer such that none of integers are divisible by but is Unfortunately computing primitive roots can be time consuming so the cows need your help Given a prime help the cows find the number of primitive roots ,"['#include <cstdio>\nconst   int maxn = 2100;\nint p, ans, twp, flag;\nint main()\n{\n    scanf(""%d"", &p);\n    if (p == 2) {printf(""1\\n""); return 0;}\n    ans = 0;\n    for (int i=1; i<p; i++)\n    {\n        twp = i;\n        flag = 1;\n        for (int j=1; j<p-1; j++)\n        {\n            if (!((twp + p - 1) % p)) {flag = 0; break;}\n            twp = (twp * i) % p;\n        }\n        if (flag && (!((twp + p - 1) % p))) ans++;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}']","['implementation', 'math', 'number theory']",1400
https://codeforces.com//contest/1104/problem/D,D. Game with modulo,Vasya and Petya are going to play the following game Petya has some positive integer number a After that Vasya should guess this number using the following questions He can say a pair of non negative integer numbers x y Petya will answer him if x bmod a geq y bmod a if x bmod a y bmod a We define x bmod a as a remainder of division x by a Vasya should guess the number a using Petya has a number that satisfies the inequality 1 leq a leq 10 9 Help Vasya playing this game and write a program that will guess the number a ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef __LOCAL_DEBUG__\n# define _debug(fmt, ...) fprintf(stderr, ""\\033[94m%s: "" fmt ""\\n\\033[0m"", \\\n    __func__, ##__VA_ARGS__)\n#else \n# define _debug(...) ((void) 0)\n#endif\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define Rep(i, n) for (int i=1; i<=(n); i++)\n#define range(x) begin(x), end(x)\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#ifdef __LOCAL_DEBUG__\nconst int a = 1000000000 - 1;\n\nbool ask(int x, int y) {\n    static int cnt = 0;\n    _debug(""ask #%d: %d, %d"", cnt++, x, y);\n    return x % a >= y % a;\n}\n\n#else\nbool ask(int x, int y) {\n    printf(""? %d %d\\n"", x, y);\n    fflush(stdout);\n    char buf[4]; scanf(""%s"", buf);\n    assert(buf[0] != \'e\');\n    return buf[0] == \'x\';\n}\n#endif\n\nint work() {\n    if (ask(0, 1)) return 1;\n    int l = 1, r;\n    while (ask(l * 2, l)) l *= 2;\n    r = l * 2 + 1; l++; r = min(r, 1000000000);\n    while (r > l) {\n        int mid = (l + r) / 2;\n        if (ask(mid, (mid + 1) / 2)) l = mid + 1;\n        else r = mid;\n    }\n    return l;\n}\n\nint main() {\n    char cmd[32];\n    while (true) {\n        scanf(""%s"", cmd);\n        if (strcmp(cmd, ""start"") == 0) {\n            printf(""! %d\\n"", work());\n            fflush(stdout);\n        } else break;\n    }\n    return 0;\n}\n']","['binary search', 'interactive', 'math']",2000
https://codeforces.com//contest/938/problem/E,E. Max History,You are given an array of length We define the following way Initially for every if then we set and then set Calculate the sum of over all permutations of the array modulo Note two elements are considered different if their indices differ so for every array there are exactly permutations ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll F[1000050];\nint in[1000050];\nmap <int, int> Mx;\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in[i]);\n\tsort(in + 1, in + N + 1);\n\n\tfor (i = 1; i <= N; i++) Mx[in[i]]++;\n\n\tF[0] = 1;\n\tfor (i = 1; i <= N; i++) F[i] = F[i - 1] * i % MOD;\n\n\tll s = 0;\n\tll ans = 0;\n\tfor (auto it : Mx) {\n\t\tll vu = F[N] * mul_inv(N-s) % MOD;\n\t\tvu = (vu * it.first) % MOD;\n\t\tvu = (vu * it.second) % MOD;\n\t\tans = (ans + vu) % MOD;\n\t\ts += it.second;\n\t}\n\tans -= in[N] * F[N] % MOD;\n\tans = (ans + MOD) % MOD;\n\treturn !printf(""%lld\\n"", ans);\n}']","['combinatorics', 'math']",2300
https://codeforces.com//contest/1475/problem/E,E. Advertising Agency,Masha works in an advertising agency In order to promote the new brand she wants to conclude contracts with some bloggers In total Masha has connections of n different bloggers Blogger numbered i has a i followers Since Masha has a limited budget she can only sign a contract with k different bloggers Of course Masha wants her ad to be seen by as many people as possible Therefore she must hire bloggers with the maximum total number of followers Help her find the number of ways to select k bloggers so that the total number of their followers is maximum possible Two ways are considered different if there is at least one blogger in the first way which is not in the second way Masha believes that all bloggers have different followers that is there is no follower who would follow two different bloggers For example if n 4 k 3 a 1 3 1 2 then Masha has two ways to select 3 bloggers with the maximum total number of followers conclude contracts with bloggers with numbers 1 2 and 4 In this case the number of followers will be equal to a 1 a 2 a 4 6 conclude contracts with bloggers with numbers 2 3 and 4 In this case the number of followers will be equal to a 2 a 3 a 4 6 Since the answer can be quite large ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int N = 1005;\nmi fact[N];\nmi ifact[N];\nmi C(int x, int y) {\n    if (x<y) return 0;\n    return fact[x] * ifact[y] * ifact[x-y];\n}\nint main() {\n    setIO("""");\n    fact[0] = ifact[0] = 1;\n    f1r(i, 1, N) {\n        fact[i] = fact[i-1] * i;\n        ifact[i] = ifact[i-1] / i;\n    }\n    int tt; re(tt);\n    while (tt--) {\n        int n, k; re(n, k);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        sort(all(a));\n        reverse(all(a));\n        map<int, int> need;\n        map<int, int> exist;\n        f0r(i, n) need[a[i]] = 0, exist[a[i]]++;\n        f0r(i, k) {\n            need[a[i]]++;\n        }\n        mi ans = 1;\n        trav(t, need) {\n            int have = exist[t.f];\n            int go = t.s;\n            ans *= C(have, go);\n        }\n        ps(ans);\n\n    }\n    return 0;\n}']","['combinatorics', 'math', 'sortings']",1600
https://codeforces.com//contest/741/problem/A,A. Arpa s loud Owf and Mehrdad s evil plan,People in Arpa s land are numbered from to Everyone has exactly one crush th person s crush is person with the number Someday Arpa shouted loudly from the top of the palace and a funny game started in Arpa s land The rules are as follows The game consists of rounds Assume person wants to start a round he calls and says the letter is repeated times and cuts off the phone immediately If then calls and says the letter is repeated times and cuts off the phone immediately The round continues until some person receives an This person is called the of the round There can t be two rounds at the same time Mehrdad has an evil plan to make the game more funny he wants to find smallest such that for each person if starts some round and becomes the Joon Joon of the round then by starting from would become the Joon Joon of the round Find such for Mehrdad if it s possible Some strange fact in Arpa s land is that someone can be himself s crush i e ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,c[110];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",c+i);\n\tll ret=1;\n\trep(i,1,n+1) {\n\t\tint p=0,k=i;\n\t\tfor (int j=1;j<=1000;j++) {\n\t\t\tk=c[k];\n\t\t\tif (k==i) { p=j; break;}\n\t\t}\n\t\tif (p==0) {\n\t\t\tputs(""-1"");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (p%2==0) p/=2;\n\t\t\tret=ret/__gcd((ll)p,ret)*p;\n\t\t}\n\t}\n\tprintf(""%lld\\n"",ret);\n}\n']","['dfs and similar', 'math']",1600
https://codeforces.com//contest/1207/problem/C,C. Gas Pipeline,You are responsible for installing a gas pipeline along a road Let s consider the road for simplicity as a segment 0 n on OX axis The road can have several crossroads but for simplicity we ll denote each crossroad as an interval x x 1 with integer x So we can represent the road as a binary string consisting of n characters where character means that current interval doesn t contain a crossroad and means that there is a crossroad Usually we can install the pipeline along the road on height of 1 unit with supporting pillars in each integer point so if we are responsible for 0 n road we must install n 1 pillars But on crossroads we should lift the pipeline up to the height 2 so the pipeline won t obstruct the way for cars We can do so inserting several zig zag like lines Each zig zag can be represented as a segment x x 1 with integer x consisting of three parts 0 5 units of horizontal pipe 1 unit of vertical pipe 0 5 of horizontal Note that if pipeline is currently on height 2 the pillars that support it should also have length equal to 2 units Each unit of gas pipeline costs us a bourles and each unit of pillar b bourles So it s not always optimal to make the whole pipeline on the height 2 Find the shape of the pipeline with minimum possible cost and calculate that cost Note that you start and finish the pipeline on height 1 and also it s guaranteed that the first and last characters of the input string are equal to ,"['#include <bits/stdc++.h>\nusing namespace std;\nchar s[200010];\ntypedef long long ll;\nint a, b, n;\nll dp[200010][2];\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    while(t--) {\n        scanf(""%d%d%d"", &n, &a, &b);\n        scanf(""%s"", s);\n        dp[0][0] = b, dp[0][1] = 1e15;\n        for(int i = 0; i < n; i++) {\n            if(s[i] == \'0\') {\n                dp[i + 1][0] = min(dp[i][0] + a, dp[i][1] + a + a) + b;\n                dp[i + 1][1] = min(dp[i][1] + a, dp[i][0] + a + a) + b + b;\n            }\n            else {\n                dp[i + 1][0] = 1e15;\n                dp[i + 1][1] = dp[i][1] + b + b + a;\n            }\n        }\n        printf(""%I64d\\n"", dp[n][0]);\n    }\n}']","['dp', 'greedy']",1500
https://codeforces.com//contest/1921/problem/E,E. Eat the Chip,Alice and Bob are playing a game on a checkered board The board has h rows numbered from top to bottom and w columns numbered from left to right Both players have a chip each Initially Alice s chip is located at the cell with coordinates x a y a row x a column y a and Bob s chip is located at x b y b It is guaranteed that the initial positions of the chips do not coincide Players take turns making moves with Alice starting On her turn Alice can move her chip one cell down or one cell down right or down left diagonally Bob on the other hand moves his chip one cell up up right or up left It is not allowed to make moves that go beyond the board boundaries More formally if at the beginning of Alice s turn she is in the cell with coordinates x a y a then she can move her chip to one of the cells x a 1 y a x a 1 y a 1 or x a 1 y a 1 Bob on his turn from the cell x b y b can move to x b 1 y b x b 1 y b 1 or x b 1 y b 1 The new chip coordinates x y must satisfy the conditions 1 le x le h and 1 le y le w Example game state Alice plays with the white chip Bob with the black one Arrows indicate possible moves A player immediately wins if they place their chip in a cell occupied by the other player s chip If either player cannot make a move Alice if she is in the last row i e x a h Bob if he is in the first row i e x b 1 the game immediately ends in a draw What will be the outcome of the game if both opponents play optimally ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll h,w,x1,y1,x2,y2;\n    cin>>h>>w>>x1>>y1>>x2>>y2;\n    if(abs(y1-y2)>x2-x1) cout<<""Draw"";\n    else if((x2-x1)%2==1){\n        ll s=(x2-x1)/2;\n        if(max(1ll,y2-s)<max(1ll,y1-s-1) || min(w,y2+s)>min(w,y1+s+1)) cout<<""Draw"";\n        else cout<<""Alice"";\n    }else{\n        ll s=(x2-x1)/2;\n        if(max(1ll,y1-s)<max(1ll,y2-s) || min(w,y1+s)>min(w,y2+s)) cout<<""Draw"";\n        else cout<<""Bob"";\n    }\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","['brute force', 'games', 'greedy', 'math']",1600
https://codeforces.com//contest/1820/problem/A,A. Yura s New Name,After holding one team contest boy Yura got very tired and wanted to change his life and move to Japan In honor of such a change Yura changed his name to something nice Fascinated by this idea he already thought up a name s consisting only of characters and But there s a problem Yura likes smiley faces and Therefore any character of the name must be a part of at least one such smiley Note that only the characters of the name can be a smiley face More formally consider all occurrences of the strings and in the string s Then all such occurrences must cover the whole string s possibly with intersections For example in the string the characters at positions 3 4 9 10 and 11 are not contained inside any smileys and the other characters at positions 1 2 5 6 7 and 8 are contained inside smileys In one operation Jura can insert one of the characters and into his name s you can insert it at any position in the string He asks you to tell him the minimum number of operations you need to do to make the name fit Yura s criteria ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FORI(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n \nmt19937 rnd(time(0));\n\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define endl \'\\n\'\n\n#define mp(m, n) make_pair((m), (n))\n \ntemplate<typename T>\nvoid read(vector<T> &t) {FOR(i, t.size()) {cin >> t[i];}}\ntemplate<typename T> string tostring(T a) { istringstream sin; sin >> a; return sin.str(); }\n \n// #define DEBUG\n \n#ifdef DEBUG\ntemplate<typename T>\nvoid _debug(string s, T x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, unordered_map<T, K> x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << it->first << "":"" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, map<T, K> x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << it->first << "":"" << it->second;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, set<T, K> x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, vector<pair<T, K> > x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << it->first << "","" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, pair<T, K> x) {\n    cerr << s << "": "" << x.first << "","" << x.second << endl;\n}\n \nvoid _debug(string s, int x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, long long x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, double x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, string x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, char x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, size_t x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, bool x) {\n    cerr << s << "": "" << x << endl;\n}\n \n#define debug(x) _debug(#x, (x))\n#else\n#define debug(x)\n#endif\n \n#define db debug\n\ntemplate <class T>\nvoid print(vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        cout << v[i];\n        if (i == v.size() - 1) {\n            cout << endl;\n        } else {\n            cout << "" "";\n        }\n    }\n}\n\nvoid solve();\n \nvoid pre_init();\n\nint main() {\n    ios_base::sync_with_stdio(false); std::cin.tie(0);\n    pre_init();\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}\n \nvoid pre_init() {}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    string s1;\n    int ans = 0;\n    if (s[0] == \'_\') {\n        s1 = ""^"";\n        ans++;\n    }\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == \'_\' && s1.back() == \'_\') {\n            s1 += \'^\';\n        }\n        s1 += s[i];\n    }\n    if (s1.size() == 1) s1 += \'^\';\n    if (s1.back() == \'_\') s1 += \'^\';\n    debug(s1);\n    cout << s1.size() - s.size() << endl;\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/374/problem/E,E. Inna and Babies,Inna Dima and Sereja are in one room together It s cold outside so Sereja suggested to play a board game called Babies The babies playing board is an infinite plane containing blue babies and red ones Each baby is a segment that grows in time At time moment the blue baby is a blue segment with ends at points Similarly at time the red baby is a red segment with ends at points of the plane Initially at time all babies are points on the plane The goal of the game is to find the first integer moment of time when the plane contains a rectangle of a non zero area which sides are fully covered by some babies A side may be covered by multiple babies More formally each point of each side of the rectangle should be covered by at least one baby of any color At that you must assume that the babies are closed segments that is they contain their endpoints You are given the positions of all babies help Inna and Dima to find the required moment of time ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 2005;\nint n, m;\nstruct pt {\n\tint x, y;\n\tinline void read() {\n\t\tscanf(""%d%d"", &x, &y);\n\t}\n} a[N], b[N];\nstruct line {\n\tint x1, x2, y1, y2;\n\tline() {}\n\tline(int X1, int Y1, int X2, int Y2) {\n\t\tif (X1 < X2)\t\n\t\t\tx1 = X1, x2 = X2, y1 = Y1, y2 = Y2; else\n\t\t\tx1 = X2, x2 = X1, y1 = Y2, Y2 = y1;\n\t}\n\tinline int k() const {\n\t\treturn x1==x2 ? 1 : (y2-y1) / (x2-x1);\n\t}\n\tinline int at(int x) const {\n\t\treturn y1 + (x-x1) * k();\n\t}\n} l1[N], l2[N];\nint n1, n2, l[N];\ninline bool conj(const line &A, const line &B) {\n\tconst line &a = A.x1 > B.x1 ? B : A, &b = A.x1 > B.x1 ? A : B;\n\tif (a.x2 < b.x1) return 0;\n\treturn a.at(b.x1) == b.y1;\n}\ninline bool inter(const line &a, const line &b) {\n\tint x = -2 * (b.at(0) - a.at(0)) / (b.k() - a.k());\n\treturn a.x1*2<=x && a.x2*2>=x && b.x1*2<=x && b.x2*2>=x;\n}\nline merge(const line &A, const line &B) {\n\tconst line &a = A.x1 > B.x1 ? B : A, &b = A.x1 > B.x1 ? A : B;\n\treturn line(a.x1, a.y1, b.x2, b.y2);\n}\nbool vis[N][N];\nbool check(int t) {\n\tline cur;\n\tbool flag;\n\tn1 = 0;\n\tfor (int i=1; i<=n; ++i) {\n\t\tcur = line(a[i].x-t, a[i].y+t, a[i].x+t, a[i].y-t);\n\t\tflag = 0;\n\t\tfor (int j=1; !flag && j<=n1; ++j) {\n\t\t\tif (conj(l1[j], cur))\n\t\t\t\tl1[j] = merge(l1[j], cur), flag = 1;\n\t\t}\n\t\tif (!flag) l1[++n1] = cur;\n\t}\n\t\n\tn2 = 0;\n\tfor (int i=1; i<=m; ++i) {\n\t\tcur = line(b[i].x-t, b[i].y-t, b[i].x+t, b[i].y+t);\n\t\tflag = 0;\n\t\tfor (int j=1; !flag && j<=n2; ++j) {\n\t\t\tif (conj(l2[j], cur))\n\t\t\t\tl2[j] = merge(l2[j], cur), flag = 1;\n\t\t}\n\t\tif (!flag) l2[++n2] = cur;\n\t}\n\t\n\tint ln;\n\tfor (int i=1; i<=n2; ++i)\n\t\tfor (int j=1; j<=n2; ++j)\n\t\t\tvis[i][j] = 0;\n\tfor (int i=1; i<=n1; ++i) {\n\t\tln = 0;\n\t\tfor (int j=1; j<=n2; ++j)\n\t\t\tif (inter(l1[i], l2[j]))\n\t\t\t\tl[++ln] = j;\n\t\tfor (int j=1; j<=ln; ++j)\n\t\t\tfor (int k=j+1; k<=ln; ++k)\n\t\t\t\tif (vis[l[j]][l[k]])\n\t\t\t\t\treturn 1; else\n\t\t\t\t\tvis[l[j]][l[k]] = 1;\n\t}\n\treturn 0;\n}\ninline bool cmp(pt x, pt y) {\n\treturn x.x < y.x;\n}\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; ++i) a[i].read();\n\tfor (int j=1; j<=m; ++j) b[j].read();\n\tsort(a+1, a+n+1, cmp);\n\tsort(b+1, b+m+1, cmp);\n\tint l = 1, r = 2000005, mid;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid))\n\t\t\tr = mid; else\n\t\t\tl = mid + 1;\n\t}\n\tif (l > 2000000)\n\t\tputs(""Poor Sereja!""); else\n\t\tprintf(""%d\\n"", l);\n\treturn 0;\n}']","['binary search', 'data structures', 'dsu', 'geometry', 'implementation']",2600
https://codeforces.com//contest/455/problem/D,D. Serega and Fun,Serega loves fun However everyone has fun in the unique manner Serega has fun by solving query problems One day Fedor came up with such a problem You are given an array consisting of positive integers and queries to it The queries can be of two types Make a unit cyclic shift to the right on the segment from to both borders inclusive That is rearrange elements of the array in the following manner Count how many numbers equal to are on the segment from to both borders inclusive Fedor hurried to see Serega enjoy the problem and Serega solved it really quickly Let s see can you solve it ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 200010;\nconst int MAGIC = 474;\n\nint len;\nint a[N];\n\nint cnt, from[N], to[N];\nvector <int> where[N];\n\nvoid init() {\n  cnt = 1;\n  from[0] = 1;\n  to[0] = len;\n  for (int i = 1; i <= len; i++) {\n    where[i].clear();\n  }\n  for (int i = 1; i <= len; i++) {\n    where[a[i]].push_back(i);\n  }\n}\n\nint get_count(int k, int from, int to) {\n  int sz = where[k].size();\n  if (sz == 0) {\n    return 0;\n  }\n  int low = 0, high = sz;\n  while (low < high) {\n    int mid = (low + high) >> 1;\n    if (where[k][mid] < from) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  int X = low;\n  low = -1, high = sz - 1;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (where[k][mid] > to) {\n      high = mid - 1;\n    } else {\n      low = mid;\n    }\n  }\n  int Y = low;\n  return (Y - X + 1);\n}\n\nint new_from[N], new_to[N];\n\nint bounds[4], bound_id;\n\nvoid cut(int b0, int b1, int b2) {\n  bounds[0] = b0;\n  bounds[1] = b1;\n  bounds[2] = b2;\n  bounds[3] = 123456789;\n  bound_id = 0;\n  int new_cnt = 0;\n  int sum = 0;\n  for (int i = 0; i < cnt; i++) {\n    int new_sum = sum + (to[i] - from[i] + 1);\n    if (new_sum <= bounds[bound_id]) {\n      if (new_sum == bounds[bound_id]) {\n        bound_id++;\n      }\n      new_from[new_cnt] = from[i];\n      new_to[new_cnt] = to[i];\n      new_cnt++;\n      sum = new_sum;\n      continue;\n    }\n    int get = bounds[bound_id] - sum;\n    new_from[new_cnt] = from[i];\n    new_to[new_cnt] = from[i] + get - 1;\n    new_cnt++;\n    from[i] += get;\n    sum += get;\n    bound_id++;\n    i--;\n  }\n  cnt = new_cnt;\n  for (int i = 0; i < cnt; i++) {\n    from[i] = new_from[i];\n    to[i] = new_to[i];\n  }\n}\n\nint new_a[N];\n\nint main() {\n  scanf(""%d"", &len);\n  for (int i = 1; i <= len; i++) {\n    scanf(""%d"", a + i);\n  }\n  init();\n  int tt;\n  scanf(""%d"", &tt);\n  int lastans = 0;\n  for (int qq = 1; qq <= tt; qq++) {\n    int com;\n    scanf(""%d"", &com);\n    if (com == 2) {\n      int ll, rr, kk;\n      scanf(""%d %d %d"", &ll, &rr, &kk);\n      ll = ((ll + lastans - 1) % len) + 1;\n      rr = ((rr + lastans - 1) % len) + 1;\n      kk = ((kk + lastans - 1) % len) + 1;\n      if (ll > rr) {\n        swap(ll, rr);\n      }\n      int ans = 0;\n      int sum = 0;\n      for (int i = 0; i < cnt; i++) {\n        int x = from[i], y = to[i];\n        int begin = sum + 1, end = sum + (y - x + 1);\n        if (ll > begin) {\n          x += ll - begin;\n        }\n        if (rr < end) {\n          y -= end - rr;\n        }\n        if (x <= y) {\n          ans += get_count(kk, x, y);\n        }\n        sum = end;\n      }\n      lastans = ans;\n      printf(""%d\\n"", ans);\n    } else {\n      int ll, rr;\n      scanf(""%d %d"", &ll, &rr);\n      ll = ((ll + lastans - 1) % len) + 1;\n      rr = ((rr + lastans - 1) % len) + 1;\n      if (ll > rr) {\n        swap(ll, rr);\n      }\n      if (ll == rr) {\n        continue;\n      }\n      cut(ll - 1, rr - 1, rr);\n      int first = -1;\n      int sum = 0;\n      for (int i = 0; i < cnt; i++) {\n        if (sum == ll - 1) {\n          first = i;\n        }\n        sum += to[i] - from[i] + 1;\n        if (sum == rr) {\n          int p = from[i];\n          for (int j = i; j > first; j--) {\n            from[j] = from[j - 1];\n            to[j] = to[j - 1];\n          }\n          from[first] = to[first] = p;\n          break;\n        }\n      }\n    }\n    if (cnt > MAGIC) {\n      int pos = 0;\n      for (int i = 0; i < cnt; i++) {\n        for (int j = from[i]; j <= to[i]; j++) {\n          new_a[++pos] = a[j];\n        }\n      }\n      for (int i = 1; i <= len; i++) {\n        a[i] = new_a[i];\n      }\n      init();\n    }\n  }\n  return 0;\n}\n']",['data structures'],2700
https://codeforces.com//contest/268/problem/B,B. Buttons,Manao is trying to open a rather challenging lock The lock has buttons on it and to open it you should press the buttons in a certain order to open the lock When you push some button it either stays pressed into the lock that means that you ve guessed correctly and pushed the button that goes next in the sequence or all pressed buttons return to the initial position When all buttons are pressed into the lock at once the lock opens Consider an example with three buttons Let s say that the opening sequence is 2 3 1 If you first press buttons 1 or 3 the buttons unpress immediately If you first press button 2 it stays pressed If you press 1 after 2 all buttons unpress If you press 3 after 2 buttons 3 and 2 stay pressed As soon as you ve got two pressed buttons you only need to press button 1 to open the lock Manao doesn t know the opening sequence But he is really smart and he is going to act in the optimal way Calculate the number of times he s got to push a button in order to open the lock in the worst case scenario ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint main()\n{\n  int i,j,n,ans;\n  scanf(""%d"",&n);\n  ans=0;\n  for (i=0;i<n;i++)\n  {\n    ans+=(n-1-i)*(i+1);\n    ans++;\n  }\n  printf(""%d\\n"",ans);\n}\n']","['implementation', 'math']",1000
https://codeforces.com//contest/548/problem/B,B. Mike and Fun,Mike and some bears are playing a game just for fun Mike is the judge All bears except Mike are standing in an grid there s exactly one bear in each cell We denote the bear standing in column number of row number by Mike s hands are on his ears since he s the judge and each bear standing in the grid has hands either on his mouth or his eyes They play for rounds In each round Mike chooses a bear and tells him to change his state i e if his hands are on his mouth then he ll put his hands on his eyes or he ll put his hands on his mouth otherwise After that Mike wants to know the score of the bears Score of the bears is the maximum over all rows of number of consecutive bears with hands on their eyes in that row Since bears are lazy Mike asked you for help For each round tell him the score of these bears after changing the state of a bear selected in that round ,"['#include <bits/stdc++.h>\n#include <ext/algorithm>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define ALL(c) c.begin(), c.end()\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define DB(a) cerr << #a << "" = "" << (a) << endl;\n#define OUT( a , n ) for( int J = 0; J < (n); J++ )cout<< (a)[J] << "" \\n""[J == (n) - 1 ]\n#define WAIT cout << flush , system(""PAUSE"");\n#define lowbit(x) ((x) & (-x))\n#define CONTAINS(a, x) ((a).find(x) != (a).end())\n#define endl \'\\n\'\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 600;\n\nint n , m , q;\nint s[MAXN][MAXN];\n\nint row[MAXN];\n\n\nint find( int r )\n{\n    int maxi = 0;\n    for(int i = 1; i <= m; i++ )\n    {\n        if(s[r][i] == 1)\n        {\n            int j = i;\n            while(j <= m && s[r][j] == 1)\n                j++;            \n            \n            maxi = max(maxi , j - i);\n            j = j - 1;\n        }\n    }\n    \n    return maxi;\n}\n\nint main()\n{\n    ios::sync_with_stdio( 0 );\n    cin.tie( 0 );   \n\n    cin >> n>> m >> q;\n    for( int i = 1; i <= n; i++ )\n    {\n        for( int j = 1; j <= m; j++ )\n            cin >> s[i][j];\n        int val = find(i);\n        row[i] = val;\n    }\n    \n    int x ,y;\n    for(; q; q-- )\n    {\n        cin >> x >> y;\n        s[x][y] = 1 - s[x][y];\n        \n        row[x] = find(x);\n        \n        int sol = 0;\n        for( int i = 1; i <= n; i++ )\n            sol = max(row[i] , sol);\n        cout << sol << endl;\n    }\n    \n\n    return 0;\n}\n\n//g++ -g -O2 -std=c++11 -static a.cpp -o\n']","['brute force', 'dp', 'greedy', 'implementation']",1400
https://codeforces.com//contest/1063/problem/F,F. String Journey,We call a sequence of strings a of length if for each is a substring of and length of is strictly less than length of For example is a journey but and are not Define a as journey such that all its parts can be nested inside in such a way that there exists a sequence of strings each of these strings can be empty and As an example is a journey on string but not on because the journey strings should appear from the left to the right The of a journey on a string is the number of strings in it Determine the maximum possible length of a journey on the given string ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n// #define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct SA {\n  vector<pair<PII, int>> x;\n  VI suf; // <- numery kolejnych sufiksow w porzadku leksykograficznym\n  VI rank; // <- odwrotnosc tablicy sufiksowej (suf)\n  VI lcp; // lcp[i] == lcp(suf[i-1],suf[i])\n  string z;\n  int n;\n  SA(string z_, int n_) : z(z_), n(n_) {\n    z[n] = -1; // straznik zaklada ze -1 nie wystepuje w z\n    //ostroznie coby nic nie nadpisac    \n    suf.resize(n); rank.resize(n); x.resize(n);\n    R(i, n) { x[i] = {{z[i], 0}, i}; }\n    mapuj();\n    int krok = 1;\n    while (krok < n) {\n      R (i, n) { x[i] = {{rank[i], i + krok < n ? rank[i + krok] : -1}, i}; }\n      mapuj();\n      krok *= 2;\n    }\n    R(i, n) { suf[rank[i]] = i; }\n    \n    //LCP - opcjonalnie\n    lcp.resize(n);\n    int k = 0;\n    R(i, n) {\n      int ak = rank[i];\n      if(ak) { while (z[suf[ak] + k] == z[suf[ak - 1] + k]) k++; }\n      lcp[rank[i]] = k;\n      if(k) { k--; }\n    }\n    //koniec LCP\n  };\n  void mapuj() {\n    sort(ALL(x));\n    int id = 0;\n    R (i, n) {\n      if (i && x[i - 1].st != x[i].st) id++;\n      rank[x[i].nd] = id;\n    }\n  }\n};\n/*\n                              // 13 1 2 1 1 2 1 2 1 1 2 1 1 2\nint z[(int)1e6], n;           //   -> 10 7 2 11 8 5 0 3 12 9 6 1 4\nint32_t main(){               //   -> 3 4 1 2 5 6 3 0 1 4 5 2\n  scanf(""%lld"",&n);\n  R(i,n)scanf(""%lld"",&z[i]);\n  SA sa(z,n);\n  R(i,n)printf(""%lld "",sa.suf[i]);\n  puts("""");\n  for(int i = 1; i < n; i++) printf(""%lld "",sa.lcp[i]);\n  puts("""");\n} */\n\nint N;\nstring s;\n\nconst int MaxCh = 26;\nconst int MaxN = 5e5 + 100;\n\nbool is_of_length[MaxN];\nbool next_is_of_length[MaxN];\nint total_infos = 0;\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> s;\n  SA sa(s, N);\n  fill_n(is_of_length, N, true);\n  int length = 1;\n\n  debug(sa.suf, sa.lcp);\n\n  while (count(is_of_length, is_of_length + N, true)) {\n#ifdef LOCAL\n    debug(length);\n    for (int i = 0; i < N; ++i)\n      cerr << is_of_length[i];\n    cerr << ""\\n"";\n#endif\n    fill_n(next_is_of_length, N, false);\n\n\n    int intv_end = N - 1;\n    while (intv_end >= 0) {\n      int intv_start = intv_end;\n      int last_good = -1;\n      while (intv_start && sa.lcp[intv_start] >= length)\n        --intv_start;\n      debug(intv_start, intv_end);\n      for (int i = intv_start; i <= intv_end; ++i)\n        if (is_of_length[sa.suf[i]])\n          maxi(last_good, sa.suf[i]);\n      for (int i = intv_start; i <= intv_end; ++i) {\n        const int pos = sa.suf[i];\n        if (pos && last_good >= pos + length)\n          next_is_of_length[pos - 1] = true;\n        if (last_good > pos + length)\n          next_is_of_length[pos] = true;\n      }\n\n      intv_end = intv_start - 1;\n    }\n\n    copy(next_is_of_length, next_is_of_length + N, is_of_length);\n    ++length;\n  }\n\n  cout << length - 1 << ""\\n"";\n\n}\n\n']","['data structures', 'dp', 'string suffix structures']",3300
https://codeforces.com//contest/193/problem/D,D. Two Segments,Nick has some permutation consisting of integers from to A segment is a set of elements satisfying Nick calls a pair of segments and good if all their elements when sorted in ascending order form an arithmetic progression with a difference of That is when they sorted in ascending order the elements are in the form for some and Your task is to find the number of distinct pairs of good segments in the given permutation Two pairs of segments are considered distinct if the sets of elements contained in these pairs of segments are distinct For example any segment can be represented as a pair of segments as and As all these pairs consist of the same set of elements they are considered identical See the notes accompanying the sample tests for clarification ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nclass Solver {\n  struct Data {\n    pii vals[3];\n\n    Data() { for (int i = 0; i < 3; i++) vals[i] = mp(INF, 0); }\n    Data(int x) { for (int i = 1; i < 3; i++) vals[i] = mp(INF, 0); vals[0] = mp(x, 1); }\n    void operator+=(const Data &d2) {\n      int p1 = 0, p2 = 0;\n      pii vals2[3];\n\n      for (int p3 = 0; p3 < 3; p3++) {\n        assert(p1 < 3 && p2 < 3);\n        int cmp = vals[p1].first - d2.vals[p2].first;\n        if (cmp < 0) vals2[p3] = vals[p1++];\n        else if (cmp > 0) vals2[p3] = d2.vals[p2++];\n        else {\n          vals2[p3] = mp(vals[p1].first, vals[p1].second + d2.vals[p2].second);\n          p1++; p2++;\n        }\n      }\n      for (int i = 0; i < 3; i++) vals[i] = vals2[i];\n    }\n  };\n\n  vector<Data> tr;\n  vi tradd;\n  int off;\n\n  void norm(int v) {\n    if (!tradd[v]) return;\n    if (v < off) {\n      tradd[2 * v] += tradd[v];\n      tradd[2 * v + 1] += tradd[v];\n    }\n    for (int i = 0; i < 3; i++) tr[v].vals[i].first += tradd[v];\n    tradd[v] = 0;\n  }\n\n  int lr, rr, vr;\n  void _add(int v, int lt, int rt) {\n    if (rt < lr || rr < lt) return;\n    if (lr <= lt && rt <= rr) {\n      tradd[v] += vr;\n      return;\n    }\n    norm(v);\n    int mt = (lt + rt) / 2;\n    _add(2 * v, lt, mt); norm(2 * v);\n    _add(2 * v + 1, mt + 1, rt); norm(2 * v + 1);\n    tr[v] = tr[2 * v];\n    tr[v] += tr[2 * v + 1];\n  }\n\n  public:\n  Solver(int n) {\n    off = 1; while (off < n) off <<= 1;\n    tr = vector<Data>(2 * off);\n    tradd = vi(2 * off, 0);\n\n    for (int i = 0; i < n; i++) {\n      tr[off + i] = 0;\n    }\n    for (int i = off - 1; i >= 1; i--) {\n      tr[i] = tr[2 * i];\n      tr[i] += tr[2 * i + 1];\n    }\n  }\n  int calc() {\n    norm(1);\n    int ans = 0;\n    for (int i = 0; i < 3; i++) {\n      assert(tr[1].vals[i].first >= 0);\n      assert(tr[1].vals[i].second >= 0);\n      if (tr[1].vals[i].first <= 2)\n        ans += tr[1].vals[i].second;\n    }\n    return ans;\n  }\n  void add(int l, int r, int v) {\n    lr = l; rr = r; vr = v;\n    return _add(1, 0, off - 1);\n  }\n};\n\nconst int MAXN = 3e5 + 1e3;\nint n;\nint as[MAXN], pos[MAXN];\n\ninline int calcNeigh(int x, int l) {\n  int cp = pos[x];\n  int ans = 0;\n  if (cp > 0) ans += as[cp - 1] >= l && as[cp - 1] < as[cp];\n  if (cp + 1 < n) ans += as[cp + 1] >= l && as[cp + 1] < as[cp];\n  return ans;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(""std.in"", ""r"", stdin);\n  freopen(""std.out"", ""w"", stdout);\n  #endif\n\n  while (scanf(""%d"", &n) >= 1) {\n    for (int i = 0; i < n; i++)\n      scanf(""%d"", &as[i]), pos[--as[i]] = i;\n\n    ll ans = 0;\n    Solver s(n);\n    {\n      for (int r = 0; r < n; r++)\n        s.add(r, n - 1, -calcNeigh(r, 0) + 1);\n    }\n    for (int l = 0; l < n; l++) {\n      ans += s.calc() - 1 - l;\n      s.add(l, n - 1, calcNeigh(l, l) - 1);\n\n      for (int x = max(0, pos[l] - 1); x < n && x <= pos[l] + 1; x++) if (as[x] != l) {\n        int r = as[x];\n        int oval = -calcNeigh(r, l) + 1;\n        int nval = -calcNeigh(r, l + 1) + 1;\n        s.add(r, n - 1, nval - oval);\n      }\n    }\n    printf(""%I64d\\n"", ans);\n  }\n  return 0;\n}\n']",['data structures'],2900
https://codeforces.com//contest/828/problem/B,B. Black Square,Polycarp has a checkered sheet of paper of size Polycarp painted some of cells with black the others remained white Inspired by Malevich s Black Square Polycarp wants to paint minimum possible number of white cells with black so that all black cells form a square You are to determine the minimum possible number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting s sides All the cells that do not belong to the square should be white The square s side should have positive length ,"['#include<bits/stdc++.h>\nint n,m;\nchar s[107];\nvoid mins(int&a,int b){if(a>b)a=b;}\nvoid maxs(int&a,int b){if(a<b)a=b;}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tint xl=10000,xr=0,yl=10000,yr=0,cb=0;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(""%s"",s+1);\n\t\tfor(int j=1;j<=m;++j)if(s[j]==\'B\'){\n\t\t\tmaxs(yr,j);mins(yl,j);\n\t\t\tmaxs(xr,i);mins(xl,i);\n\t\t\t++cb;\n\t\t}\n\t}\n\tif(xl>xr)return puts(""1""),0;\n\tint xd=xr-xl+1,yd=yr-yl+1;\n\tmaxs(xd,yd);\n\tprintf(""%d\\n"",xd<=n&&xd<=m?xd*xd-cb:-1);\n\treturn 0;\n}\n']",['implementation'],1300
https://codeforces.com//contest/1240/problem/E,E. Wooden Raft,Suppose you are stuck on a desert island The only way to save yourself is to craft a wooden raft and go to the sea Fortunately you have a hand made saw and a forest nearby Moreover you ve already cut several trees and prepared it to the point that now you have n logs and the i th log has length a i The wooden raft you d like to build has the following structure 2 logs of length x and x logs of length y Such raft would have the area equal to x cdot y Both since it s the only way you can measure the lengths while being on a desert island And both since the raft that is one log wide is unstable You can cut logs in pieces but you can t merge two logs in one What is the maximum area of the raft you can craft ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int M=500000;\nconst int N=501000;\n\nll dp[10],pd[10],s;\nint cnt[N],ord[N],x,cnt0[10],cnt1[10],n;\n\nbool check(ll x,int y) {\n\tVI z; z.pb(0); z.pb(y); z.pb(x%y); z.pb(2*x%y);\n\tsort(all(z)); z.erase(unique(all(z)),z.end());\n\tll cs=0;\n\trep(i,0,SZ(z)-1) cnt0[i]=cnt1[i]=0;\n\tfor (int val=0;val<=M;val+=y) {\n\t\tcs+=(ll)(cnt[min(val+y,M+1)]-cnt[val])*(val/y);\n\t\trep(i,0,SZ(z)-1) {\n\t\t\t// val+z[i], val+z[i+1]-1\n\t\t\tint pl=val+z[i],pr=val+z[i+1]-1;\n\t\t\tint zz=cnt[min(pr+1,M+1)]-cnt[min(pl,M+1)];\n\t\t\tif (pl>=x) {\n\t\t\t\tcnt0[i]+=zz;\n\t\t\t}\n\t\t\tif (pl>=2*x) {\n\t\t\t\tcnt1[i]+=zz;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0]=0; dp[1]=dp[2]=1ll<<60;\n\trep(i,0,SZ(z)-1) {\n\t\tint pl=z[i],pr=z[i+1]-1;\n\t\tll rg=(1ll<<40)*y+pl;\n\t\tll rd1=(rg/y)-(rg-x)/y;\n\t\tll rd2=(rg/y)-(rg-2*x)/y;\n\t\tcnt0[i]=min(cnt0[i],2);\n\t\tcnt1[i]=min(cnt1[i],1);\n\t\trep(j,1,3) pd[j]=dp[j];\n\t\trep(j,1,cnt0[i]+1) rep(k,j,3) dp[k]=min(dp[k],pd[k-j]+j*rd1);\n\t\trep(j,1,3) pd[j]=dp[j];\n\t\trep(j,1,cnt1[i]+1) rep(k,2*j,3) dp[k]=min(dp[k],pd[k-2*j]+j*rd2);\n\t}\n\treturn cs-dp[2]>=x;\n}\n\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",&x),cnt[x+1]++,s+=x;\n\trep(i,1,M+2) cnt[i]+=cnt[i-1];\n\tll ans=0;\n\trep(i,1,M+1) ord[i]=i;\n\trandom_shuffle(ord+1,ord+M+1,rnd);\n\trep(i,1,M+1) {\n\t\tint y=ord[i];\n\t\tif (y==1) continue;\n\t\tll px=max((ans+y-1)/y,2ll);\n\t\tif (!check(px,y)) continue;\n\t\tll l=px,r=s/y+1;\n\t\twhile (l+1<r) {\n\t\t\tll md=(l+r)>>1;\n\t\t\tif (check(md,y)) l=md; else r=md;\n\t\t}\n\t\tans=max(ans,l*y);\n\t}\n\tprintf(""%lld\\n"",ans);\n}\n']","['math', 'number theory']",3200
https://codeforces.com//contest/1941/problem/E,E. Rudolf and k Bridges,Bernard loves visiting Rudolf but he is always running late The problem is that Bernard has to cross the river on a ferry Rudolf decided to help his friend solve this problem The river is a grid of n rows and m columns The intersection of the i th row and the j th column contains the number a i j the depth in the corresponding cell All cells in the and columns correspond to the river banks so the depth for them is 0 Rudolf can choose the row i 1 i 2 ldots i m and build a bridge over it In each cell of the row he can install a support for the bridge The cost of installing a support in the cell i j is a i j 1 Supports must be installed so that the following conditions are met A support must be installed in cell i 1 A support must be installed in cell i m The distance between any pair of adjacent supports must be d The distance between supports i j 1 and i j 2 is j 1 j 2 1 Building just one bridge is boring Therefore Rudolf decided to build k bridges on rows of the river that is to choose some i 1 le i le n k 1 and independently build a bridge on each of the rows i i 1 ldots i k 1 Help Rudolf the total cost of installing supports ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\nint dp[ 2015 ] , nx_dp[ 1015 ] ;\n\nint pp[ N ] ; \nvector < int > ans ;\nmultiset < int > se ;  \nvoid solve(){\n    int n , m , k , d ;\n    cin >> n >> m >> k >> d ;\n    ans.clear() ; se.clear() ;\n    int pas = inf , sm = 0 , l = 0 ; \n    FOR( i , n ){\n    \tse.clear() ;\n    \tint lst = 0 ;\n    \tFOR( j , m ){\n    \t\tint x ; cin >> x ;\n    \t\tif( j == 0 ){\n    \t\t\tse.insert( 1 ) ;\n    \t\t\tpp[ 0 ] = 1 ; \n    \t\t\tcontinue ;\n\t\t\t}\n\t\t\tint bf = *se.begin() ;\n\t\t\tx = x + bf + 1 ;\n\t\t\tse.insert( x ) ;\n\t\t\tpp[ j ] = x ; \n\t\t\tif( j - d - 1 >= 0 ){\n\t\t\t\tse.erase( se.find( { pp[ j - d - 1 ] } ) ) ;\n\t\t\t}\n\t\t}\n\t\tans.pb( pp[ m - 1 ] ) ;\n\t\tsm += pp[ m - 1 ] ; \n\t\tif( ans.size() > k ){\n\t\t\tsm = sm - ans[ l ] ;\n\t\t\tl ++ ;  \n\t\t}\n\t\tif( ans.size() >= k )\n\t\tpas = min( pas , sm ) ;\n\t}\n    cout << pas << ""\\n""; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']","['binary search', 'data structures', 'dp', 'two pointers']",1600
https://codeforces.com//contest/1419/problem/D2,D2. Sage s Birthday  hard version ,Today is Sage s birthday and she will go shopping to buy ice spheres All n ice spheres are placed in a row and they are numbered from 1 to n from left to right Each ice sphere has a positive integer price In this version some prices can be equal An ice sphere is cheap if it costs strictly less than two neighboring ice spheres the nearest to the left and the nearest to the right The leftmost and the rightmost ice spheres are not cheap Sage will choose all cheap ice spheres and then buy only them You can visit the shop before Sage and reorder the ice spheres as you wish Find out the maximum number of ice spheres that Sage can buy and show how the ice spheres should be reordered ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint n, a[MAXN], v, ans[MAXN];\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    cin >> n;\n\tFor(i, 1, n) scanf(""%d"", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tFor(i, 1, n / 2)\n\t\tans[i * 2] = a[i];\n\tFor(i, n / 2 + 1, n)\n\t\tans[(i - n / 2) * 2 - 1] = a[i];\n\tint res = 0;\n\tFor(i, 2, n - 1) {\n\t\tres += (ans[i] < ans[i-1]) * (ans[i] < ans[i+1]);\n\t}\n\tcout << res << endl;\n\tFor(i, 1, n) {\n\t\tprintf(""%d "", ans[i]);\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']","['binary search', 'brute force', 'constructive algorithms', 'greedy', 'sortings', 'two pointers']",1500
https://codeforces.com//contest/1060/problem/D,D. Social Circles,You invited n guests to dinner You plan to arrange one or more circles of chairs Each chair is going to be either occupied by one guest or be empty You can make any number of circles Your guests happen to be a little bit shy so the i th guest wants to have a least l i free chairs to the left of his chair and at least r i free chairs to the right The left and right directions are chosen assuming all guests are going to be seated towards the center of the circle Note that when a guest is the only one in his circle the l i chairs to his left and r i chairs to his right may overlap What is smallest total number of chairs you have to use ,"['#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100100;\n\nint N;\nint l[MAXN], r[MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> l[i] >> r[i];\n    sort (l, l + N);\n    sort (r, r + N);\n\n    ll ans = N;\n    for (int i = 0; i < N; i++)\n        ans += max (l[i], r[i]);\n    cout << ans << ""\\n"";\n}']","['greedy', 'math']",1900
https://codeforces.com//contest/1498/problem/B,B. Box Fitting,You are given n rectangles each of height 1 Each rectangle s width is a power of 2 i e it can be represented as 2 x for some non negative integer x You are also given a two dimensional box of width W Note that W may or may not be a power of 2 Moreover W is at least as large as the width of the largest rectangle You have to find the smallest height of this box such that it is able to fit all the given rectangles It is allowed to have some empty space left in this box after fitting all the rectangles You cannot rotate the given rectangles to make them fit into the box Moreover any two distinct rectangles must not overlap i e any two distinct rectangles must have zero intersection area See notes for visual explanation of sample input ,"['#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\ninline int gcd(re int x,re int y){return y?gcd(y,x%y):x;}\ninline bool check(re int x){\n\tre int y=x,s=0;\n\twhile(x)s+=x%10,x/=10;\n\tif(gcd(y,s)>1)return 1;\n\treturn 0;\n}\nsigned main(){\n\tt=read();a[0]=-1;\n\tfor(re int i=1;i<=1000000;++i)a[i]=a[i>>1]+1;\n\twhile(t--){\n\t\tn=read(),ans=0,m=read();\n\t\tfor(re int i=0;i<=20;++i)b[i]=0;\n\t\tfor(re int i=1;i<=n;++i)++b[a[read()]];\n\t\twhile(n){\n\t\t\tre int s=m;\n\t\t\tfor(re int i=20;~i;--i){\n\t\t\t\twhile(s>=(1<<i)&&b[i])s-=(1<<i),--b[i],--n;\n\t\t\t}\n\t\t\t++ans;\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t}\n}\n']","['binary search', 'bitmasks', 'data structures', 'greedy']",1300
https://codeforces.com//contest/1921/problem/G,G. Mischievous Shooter,Once the mischievous and wayward shooter named Shel found himself on a rectangular field of size n times m divided into unit squares Each cell either contains a target or not Shel only had a lucky shotgun with him with which he can shoot in one of the four directions right down left down left up or right up When fired the shotgun hits all targets in the chosen direction the Manhattan distance to which does not exceed a fixed constant k The Manhattan distance between two points x 1 y 1 and x 2 y 2 is equal to x 1 x 2 y 1 y 2 Shel s goal is to hit as many targets as possible Please help him find this value ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,m,k,ans=0;\n    cin>>n>>m>>k;\n    char c[n+1][m+1];\n    ll s[n+1][m+1];\n    for(ll i=0;i<=n;i++) s[i][0]=0;\n    for(ll i=1;i<=m;i++) s[0][i]=0;\n    for(ll i=1;i<=n;i++){\n        for(ll j=1;j<=m;j++){\n            cin>>c[i][j];\n            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n            if(c[i][j]==\'#\') s[i][j]++;\n        }\n    }\n    for(ll i=1;i<=n;i++){\n        for(ll j=1;j<=m;j++){\n            ll x=0;\n            if(n-i<=m-j){\n                for(ll kk=0;kk<=k&&i+kk<=n;kk++){\n                    ll i1=i+kk-1, j1=j-1, i2=i+kk, j2=min(j+k-kk,m);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j+kk<=m;kk++){\n                    ll j1=j+kk-1, i1=i-1, j2=j+kk, i2=min(i+k-kk,n);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n            x=0;\n            if(n-i+1<=j){\n                for(ll kk=0;kk<=k&&i+kk<=n;kk++){\n                    ll i1=i+kk-1, j1=max(j-k+kk-1,0ll), i2=i+kk, j2=j;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j-kk>=1;kk++){\n                    ll j1=j-kk-1, i1=i-1, j2=j-kk, i2=min(i+k-kk,n);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n            x=0;\n            if(i<=m-j+1){\n                for(ll kk=0;kk<=k&&i-kk>=1;kk++){\n                    ll i1=i-kk-1, j1=j-1, i2=i-kk, j2=min(j+k-kk,m);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j+kk<=m;kk++){\n                    ll j1=j+kk-1, i1=max(i-k+kk-1,0ll), j2=j+kk, i2=i;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n            x=0;\n            if(i<=j){\n                for(ll kk=0;kk<=k&&i-kk>=1;kk++){\n                    ll i1=i-kk-1, j1=max(j-k+kk-1,0ll), i2=i-kk, j2=j;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j-kk>=1;kk++){\n                    ll j1=j-kk-1, i1=max(i-k+kk-1,0ll), j2=j-kk, i2=i;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n        }\n    }\n    cout<<ans;\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","['brute force', 'data structures', 'divide and conquer', 'dp', 'implementation']",2200
https://codeforces.com//contest/1279/problem/F,F. New Year and Handle Change,New Year is getting near So it s time to change handles on codeforces Mishka wants to change his handle but in such a way that people would not forget who he is To make it work he only allowed to change letters case More formally during handle change he can choose any segment of his handle i i l 1 and apply or to all letters of his handle on this segment more fomally replace all uppercase letters with corresponding lowercase or vice versa The length l is fixed for all changes Because it is not allowed to change codeforces handle too often Mishka can perform at most k such operations What is the value of min lower upper where lower is the number of lowercase letters and upper is the number of uppercase letters can be obtained after optimal sequence of changes ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n \nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, l;\n  cin >> n >> k >> l;\n  string s;\n  cin >> s;\n  vector <int> ret;\n  for (auto c : s) {\n    if (\'a\' <= c && c <= \'z\') ret.push_back(0);\n    else ret.push_back(1);\n  }\n  const ll inf = (ll) (1e18) + 7;\n  ll ans = n;\n  for (int t = 0; t < 2; t++) {\n    auto f = [&] (int m) {\n      vector <pair <ll, int> > dp(n, make_pair(inf, 0));\n      for (int i = 0; i < n; i++) {\n        {\n          auto go = (i >= l ? dp[i - l] : make_pair(0ll, 0));\n          go.first += m;\n          go.second++;\n          dp[i] = min(dp[i], go);\n        }\n        {\n          auto go = (i > 0 ? dp[i - 1] : make_pair(0ll, 0));\n          go.first += ret[i];\n          dp[i] = min(dp[i], go);\n        }\n      }\n      return dp[n - 1];\n    };\n    if (f(0).second <= k) {\n      ans = min(ans, f(0).first);\n    } else {\n      int l = 0, r = n + 228;\n      while (l < r - 1) {\n        int mid = (l + r) / 2;\n        if (f(mid).second <= k) {\n          r = mid;\n        } else {\n          l = mid;\n        }\n      }\n      auto go = f(r);\n      ans = min(ans, go.first - r * (ll) k);\n    }\n    for (int &x : ret) {\n      x ^= 1;\n    }\n  }\n  cout << ans << \'\\n\';\n}']","['binary search', 'dp']",2800
https://codeforces.com//contest/1183/problem/C,C. Computer Game,Vova is playing a computer game There are in total n turns in the game and Vova really wants to play all of them The initial charge of his laptop battery i e the charge before the start of the game is k During each turn Vova can choose what to do If the current charge of his laptop battery is strictly greater than a Vova can and then the charge of his laptop battery will decrease by a if the current charge of his laptop battery is strictly greater than b b a Vova can his laptop and then the charge of his laptop battery will decrease by b if the current charge of his laptop battery is less than or equal to a and b at the same time then Vova cannot do anything and loses the game Vova wants to complete the game Vova can complete the game if after each of n turns the charge of the laptop battery is Vova has to play Among all possible ways to complete the game Vova wants to choose the one where the number of turns when he is the possible It is possible that Vova cannot complete the game at all Your task is to find out the possible number of turns Vova can make the or report that Vova cannot complete the game You have to answer q independent queries ,"['#include <stdio.h>\n\n#define lli long long int\n\nint main() {\n\tlli q, k, n, a, b, mini, sisa, delta, ans;\n\tscanf(""%lld"", &q);\n\twhile (q--) {\n\t\tscanf(""%lld %lld %lld %lld"", &k, &n, &a, &b);\n\t\tmini = n * b;\n\t\tans = -1;\n\t\tif (k > mini) {\n\t\t\tsisa = k - mini - 1;\n\t\t\tdelta = a - b;\n\t\t\tans = sisa / delta;\n\t\t\tif (n < ans)\n\t\t\t\tans = n;\n\t\t}\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\treturn 0;\n}']","['binary search', 'math']",1400
https://codeforces.com//contest/1792/problem/A,A. GamingForces,Monocarp is playing a computer game He s going to kill n monsters the i th of them has h i health Monocarp s character has two spells either of which he can cast an arbitrary number of times possibly zero and in an arbitrary order choose exactly two alive monsters and decrease their health by 1 choose a single monster and kill it When a monster s health becomes 0 it dies What s the minimum number of spell casts Monocarp should perform in order to kill all monsters ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005];\nsigned main()\n{\n\tint t,n,sl;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tsl=0;\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),sl+=(a[i]==1);\n\t\tprintf(""%d\\n"",n-sl/2);\n\t}\n\treturn 0;\n}']","['greedy', 'sortings']",800
https://codeforces.com//contest/1452/problem/G,G. Game On Tree,Alice and Bob are playing a game They have a tree consisting of n vertices Initially Bob has k chips the i th chip is located in the vertex a i all these vertices are unique Before the game starts Alice will place a chip into one of the vertices of the tree The game consists of turns Each turn the following events happen sequentially exactly in the following order Alice either moves her chip to an adjacent vertex or doesn t move it for each Bob s chip he either moves it to an adjacent vertex or doesn t move it Note that this choice is done independently for each chip The game ends when Alice s chip shares the same vertex with one or multiple of Bob s chips Note that Bob s chips may share the same vertex even though they are in different vertices at the beginning of the game Alice wants to maximize the number of turns Bob wants to minimize it If the game ends in the middle of some turn Alice moves her chip to a vertex that contains one or multiple Bob s chips this turn is counted For each vertex calculate the number of turns the game will last if Alice places her chip in that vertex ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\nstruct tree{\n\tint n;\n\tvector<vector<int>> G;\n\ttree(){}\n\ttree(int n_){\n\t\tn=n_;\n\t\tG=vector<vector<int>>(n);\n\t}\n\t\n\tvoid add_edge(int a,int b){\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tvoid input(int ind){\n\t\tscanf(""%d"",&n);\n\t\tG=vector<vector<int>>(n);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint a,b;\n\t\t\tscanf(""%d%d"",&a,&b);\n\t\t\ta-=ind; b-=ind;\n\t\t\tadd_edge(a,b);\n\t\t}\n\t}\n\t\n\tvoid dfs_dist(int v,int p,int d,vector<int> &dist){\n\t\tdist[v]=d;\n\t\tfor(int u: G[v]){\n\t\t\tif(u==p)continue;\n\t\t\tdfs_dist(u,v,d+1,dist);\n\t\t}\n\t}\n\t\n\t//centroids\n\tint cent;\n\tvector<tree*> subtree;\n\tvector<pair<int,int>> id;\n\tint dfs_sz(int v,int p,vector<int> &par,vector<int> &sz){\n\t\tpar[v]=p;\n\t\tsz[v]=1;\n\t\tfor(int u: G[v]){\n\t\t\tif(u==p)continue;\n\t\t\tsz[v]+=dfs_sz(u,v,par,sz);\n\t\t}\n\t\treturn sz[v];\n\t}\n\tint dfs_id(int v,int p,pair<int,int> id_){\n\t\tid[v]=id_; id_.sc++;\n\t\tfor(int u: G[v]){\n\t\t\tif(u==p)continue;\n\t\t\tid_.sc=dfs_id(u,v,id_);\n\t\t\tsubtree[id_.fr]->add_edge(id[v].sc,id[u].sc);\n\t\t}\n\t\treturn id_.sc;\n\t}\n\tvoid cent_div(){\n\t\tvector<int> sz(n),par(n);\n\t\tdfs_sz(0,-1,par,sz);\n\t\tcent=0;\n\t\twhile(1){\n\t\t\tif(sz[cent]<=n/2){\n\t\t\t\tcent=par[cent];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool upd=false;\n\t\t\tfor(int u: G[cent]){\n\t\t\t\tif(u==par[cent])continue;\n\t\t\t\tif(sz[u]>n/2){\n\t\t\t\t\tcent=u;\n\t\t\t\t\tupd=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!upd)break;\n\t\t}\n\t\tid=vector<pair<int,int>>(n);\n\t\tfor(int u: G[cent]){\n\t\t\tsubtree.push_back(new tree(u==par[cent]?(n-sz[cent]):sz[u]));\n\t\t\tdfs_id(u,cent,mp(subtree.size()-1,0));\n\t\t}\n\t\tfor(auto t: subtree)t->cent_div();\n\t}\n\t\n\tvector<int> dist;\n\tvector<int> val;\n\tvoid f(vector<int> &d){\n\t\tdist=vector<int>(n);\n\t\tdfs_dist(cent,-1,0,dist);\n\t\tval=vector<int>(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tval[dist[i]]=max(val[dist[i]],d[i]);\n\t\t}\n\t\tfor(int i=0;i+1<n;i++){\n\t\t\tval[i+1]=max(val[i+1],val[i]);\n\t\t}\n\t\tvector<vector<int>> d_(subtree.size());\n\t\tfor(int i=0;i<subtree.size();i++)d_[i]=vector<int>(subtree[i]->n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==cent)continue;\n\t\t\td_[id[i].fr][id[i].sc]=d[i];\n\t\t}\n\t\tfor(int i=0;i<subtree.size();i++){\n\t\t\tsubtree[i]->f(d_[i]);\n\t\t}\n\t}\n\tbool solve(int v,int d){\n\t\tif(d-1-dist[v]>=0&&val[min(n-1,d-1-dist[v])]>=d)return true;\n\t\tif(v==cent)return false;\n\t\treturn subtree[id[v].fr]->solve(id[v].sc,d);\n\t}\n\t\n\t//debug\n\tvoid output(){\n\t\tcerr<<n<<endl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcerr<<i<<""-"";\n\t\t\tfor(int j: G[i]){\n\t\t\t\tcerr<<j<<"","";\n\t\t\t}\n\t\t\tcerr<<endl;\n\t\t}\n\t}\n\tvoid debug_centroids(){\n\t\toutput();\n\t\tfor(auto t: subtree)t->debug_centroids();\n\t}\n};\n\ntree T;\nint k;\nint a[200010];\n\nint main(){\n\tT.input(1);\n\tscanf(""%d"",&k);\n\tfor(int i=0;i<k;i++){\n\t\tscanf(""%d"",&a[i]);\n\t\ta[i]--;\n\t}\n\t\n\tT.cent_div();\n\t\n\tif(1){\n\t\tvector<int> d(T.n,INF);\n\t\tqueue<int> que;\n\t\tfor(int i=0;i<k;i++){\n\t\t\td[a[i]]=0;\n\t\t\tque.push(a[i]);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front(); que.pop();\n\t\t\tfor(int u: T.G[v]){\n\t\t\t\tif(d[u]>d[v]+1){\n\t\t\t\t\td[u]=d[v]+1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tT.f(d);\n\t}\n\tfor(int i=0;i<T.n;i++){\n\t\tint l=0,r=T.n-1;\n\t\twhile(l<r){\n\t\t\tint mid=(l+r+1)/2;\n\t\t\tif(T.solve(i,mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(""%d%c"",l,(i+1==T.n)?\'\\n\':\' \');\n\t}\n}']","['data structures', 'dfs and similar', 'greedy', 'trees']",2700
https://codeforces.com//contest/1845/problem/A,A. Forbidden Integer,You are given an integer n which you want to obtain You have an unlimited supply of every integer from 1 to k except integer x there are no integer x at all You are allowed to take an arbitrary amount of each of these integers possibly zero Can you make the sum of taken integers equal to n If there are multiple answers print any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int t;cin>>t;\n    while(t--)\n    {\n        int n,k,x;cin>>n>>k>>x;\n        if(x!=1)\n        {\n            cout<<""YES""<<\'\\n\';\n            cout<<n<<\'\\n\';\n            for(int i=0;i<n;++i) cout<<1<<\' \'; cout<<\'\\n\';\n        }\n        else\n        {\n            if(k>=2 && n%2==0)\n            {\n                cout<<""YES""<<\'\\n\';\n                cout<<n/2<<\'\\n\';\n                for(int i=0;i<n/2;++i) cout<<2<<\' \'; cout<<\'\\n\';\n            }\n            else if(k>=3)\n            {\n                cout<<""YES""<<\'\\n\';\n                cout<<n/2<<\'\\n\';\n                cout<<3<<\' \';\n                for(int i=1;i<n/2;++i) cout<<2<<\' \'; cout<<\'\\n\';\n            }\n            else\n            {\n                cout<<""NO""<<\'\\n\';\n            }\n        }\n    }\n    return 0;\n}\n']","['constructive algorithms', 'implementation', 'math', 'number theory']",800
https://codeforces.com//contest/1545/problem/E1,E1. AquaMoon and Time Stop  easy version ,AquaMoon knew through foresight that some ghosts wanted to curse tourists on a pedestrian street But unfortunately this time these ghosts were hiding in a barrier and she couldn t enter this barrier in a short time and destroy them Therefore all that can be done is to save any unfortunate person on the street from the ghosts The pedestrian street can be represented as a one dimensional coordinate system There is one person hanging out on the pedestrian street At the time 0 he is at coordinate x moving with a speed of 1 unit per second In particular at time i the person will be at coordinate x i The ghosts are going to cast n curses on the street The i th curse will last from time tl i 1 10 18 to time tr i 1 10 18 exclusively and will kill people with coordinates from l i 1 10 18 to r i 1 10 18 exclusively Formally that means that the person whose coordinate is between l i 1 10 18 r i 1 10 18 in the time range tl i 1 10 18 tr i 1 10 18 will die To save the person on the street AquaMoon can stop time at any moment t and then move the person from his current coordinate x to any coordinate y t x and y are not necessarily integers The movement costs AquaMoon x y energy The movement is continuous so if there exists some cursed area between points x and y at time t the person will AquaMoon wants to know what is the minimum amount of energy she needs to spend in order to save the person on the street from all n curses But she is not good at programming As her friend can you help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nusing dpl = deque<pl>; // OK\n\nint N,X; // OK\nmap<pl,dpl> ranges;\nint cur_time;\n\nvoid attempt_add_left(pair<pl,dpl>& p, ll best_left) {\n\tll L = p.f.f;\n\tif (!sz(p.s) || p.s.ft.s+(p.s.ft.f+cur_time)-L > best_left) \n\t\tp.s.push_front({L-cur_time,best_left});\n}\n\nvoid attempt_add_right(pair<pl,dpl>& p, ll best_right) {\n\tll R = p.f.s;\n\tif (!sz(p.s) || p.s.bk.s+R-(p.s.bk.f+cur_time) > best_right) \n\t\tp.s.pb({R-cur_time,best_right});\n}\n\nvoid cleanup(pair<pl,dpl>& p) {\n\tll best_right = INF;\n\tll R = p.f.s;\n\twhile (sz(p.s)) {\n\t\tll dif = (p.s.bk.f+cur_time)-R;\n\t\tif (dif <= 0) break;\n\t\tbest_right = p.s.bk.s+dif;\n\t\tp.s.pop_back();\n\t}\n\tattempt_add_right(p,best_right);\n}\n\nmap<int,int> start_cnt, end_cnt;\n\nvoid ban(int L, int R) {\n\tdbg(""BAN"",L,R);\n\t++start_cnt[L], ++end_cnt[R];\n\tauto it = ranges.ub({L,INF});\n\tif (it != begin(ranges) && prev(it)->f.s > L) --it;\n\twhile (it != end(ranges) && it->f.f < R) {\n\t\tpair<pl,dpl> t = *(it++); cleanup(t);\n\t\tranges.erase(prev(it));\n\t\tif (t.f.f <= L) {\n\t\t\tpair<pl,dpl> nt; nt.f = {t.f.f,L};\n\t\t\teach(u,t.s) {\n\t\t\t\tif (u.f+cur_time <= L) nt.s.pb(u);\n\t\t\t\telse {\n\t\t\t\t\tattempt_add_right(nt,u.s+(u.f+cur_time)-L);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tranges[nt.f] = nt.s;\n\t\t}\n\t\tif (R <= t.f.s) {\n\t\t\tpair<pl,dpl> nt; nt.f = {R,t.f.s};\n\t\t\tll min_lef = INF;\n\t\t\teach(u,t.s) {\n\t\t\t\tif (u.f+cur_time < R) {\n\t\t\t\t\tmin_lef = u.s+R-(u.f+cur_time);\n\t\t\t\t} else nt.s.pb(u);\n\t\t\t}\n\t\t\tattempt_add_left(nt,min_lef);\n\t\t\tranges[nt.f] = nt.s;\n\t\t}\n\t}\n}\n\nvoid subtract(map<int,int>& m, int x) {\n\t--m[x];\n\tassert(m[x] >= 0);\n\tif (m[x] == 0) m.erase(x);\n}\n\nint get_next_start(int L) {\n\tauto it = start_cnt.lb(L);\n\tif (it == end(start_cnt)) return MOD;\n\treturn it->f;\n}\n\nint get_prev_end(int R) {\n\tauto it = end_cnt.ub(R);\n\tif (it == begin(end_cnt)) return -MOD;\n\treturn prev(it)->f;\n}\n\ndpl merge_deques(dpl l, dpl r) {\n\twhile (sz(l) && sz(r)) {\n\t\tassert(l.bk.f < r.ft.f);\n\t\tll dif = r.ft.f-l.bk.f;\n\t\tif (l.bk.s >= r.ft.s+dif) {\n\t\t\tl.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (r.ft.s >= l.bk.s+dif) {\n\t\t\tr.pop_front();\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tl.ins(end(l),all(r));\n\treturn l;\n}\n\nvoid revert(int L, int R) {\n\t// dbg(""REVERT"",L,R);\n\tsubtract(start_cnt,L), subtract(end_cnt,R);\n\tint LL = get_next_start(L), RR = get_prev_end(R);\n\t// dbg(""GOT"",L,R,LL,RR);\n\tauto it = ranges.ub({L,INF});\n\tbool flag = 0;\n\tif (it != begin(ranges) && prev(it)->f.s == L) {\n\t\tpair<pl,dpl> t = *prev(it); ranges.erase(prev(it));\n\t\tcleanup(t);\n\t\tt.f.s = LL; ranges[t.f] = t.s;\n\t\tflag = (LL >= R);\n\t}\n\tif (it != end(ranges) && it->f.f == R) {\n\t\tpair<pl,dpl> t = *it; cleanup(t);\n\t\tif (flag) {\n\t\t\tassert(it != begin(ranges));\n\t\t\tranges.erase(it--);\n\t\t\tassert(RR <= L);\n\t\t\tassert(it->f.s == t.f.s);\n\t\t\tassert(RR == it->f.f);\n\t\t\tit->s = merge_deques(it->s,t.s);\n\t\t} else {\n\t\t\tranges.erase(it);\n\t\t\tt.f.f = RR;\n\t\t\tranges[t.f] = t.s;\n\t\t}\n\t}\n}\n\nint main() {\n\tsetIO();\n\tre(N,X);\n\tranges[{-MOD,MOD}] = {{X,0}}; // OK\n\tV<tuple<int,int,int,int>> mod;\n\trep(N) {\n\t\tints(TL,TR,L,R);\n\t\t--TL, ++TR, --L, ++R;\n\t\tmod.pb({TL,1,L,R});\n\t\tmod.pb({TR,-1,L,R});\n\t}\n\tsor(mod);\n\teach(t,mod) {\n\t\tauto [_time, ad, L, R] = t;\n\t\tcur_time = _time;\n\t\tif (ad == 1) ban(L,R);\n\t\telse revert(L,R);\n\t}\n\tassert(sz(start_cnt) == 0 && sz(end_cnt) == 0);\n\tassert(sz(ranges) == 1);\n\tV<pair<pl,dpl>> franges(all(ranges));\n\teach(t,franges) cleanup(t);\n\tll ans = INF;\n\teach(t,franges[0].s) ckmin(ans,t.s);\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['data structures', 'dp']",3500
https://codeforces.com//contest/16/problem/B,B. Burglar and Matches,A burglar got into a matches warehouse and wants to steal as many matches as possible In the warehouse there are containers in the th container there are matchboxes and each matchbox contains matches All the matchboxes are of the same size The burglar s rucksack can hold matchboxes exactly Your task is to find out the maximum amount of matches that a burglar can carry away He has no time to rearrange matches in the matchboxes that s why he just chooses not more than matchboxes so that the total amount of matches in them is maximal ,"['#include <algorithm> \n#include <iostream> \n#include <sstream> \n#include <string> \n#include <vector> \n#include <queue> \n#include <set> \n#include <map> \n#include <cstdio> \n#include <cstdlib> \n#include <cctype> \n#include <cmath> \n#include <list> \nusing namespace std; \n\n#define PB push_back \n#define MP make_pair \n#define SZ(v) ((int)(v).size()) \n#define FOR(i,a,b) for(int i=(a);i<(b);++i) \n#define REP(i,n) FOR(i,0,n) \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i) \n#define REPE(i,n) FORE(i,0,n) \n#define FORSZ(i,a,v) FOR(i,a,SZ(v)) \n#define REPSZ(i,v) REP(i,SZ(v)) \ntypedef long long ll; \n\nvoid run() {\n\tint can,n; scanf(""%d%d"",&can,&n);\n\tvector<pair<int,int> > have;\n\tREP(i,n) { int nr,each; scanf(""%d%d"",&nr,&each); have.PB(MP(each,nr)); }\n\tsort(have.rbegin(),have.rend());\n\tint left=can;\n\tint ret=0;\n\tfor(int i=0;i<SZ(have)&&left>0;++i) {\n\t\tint cur=min(left,have[i].second);\n\t\tret+=cur*have[i].first;\n\t\tleft-=cur;\n\t}\n\tprintf(""%d\\n"",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n']","['greedy', 'implementation', 'sortings']",900
https://codeforces.com//contest/1623/problem/A,A. Robot Cleaner,A robot cleaner is placed on the floor of a rectangle room surrounded by walls The floor consists of n rows and m columns The rows of the floor are numbered from 1 to n from top to bottom and columns of the floor are numbered from 1 to m from left to right The cell on the intersection of the r th row and the c th column is denoted as r c The initial position of the robot is r b c b In one second the robot moves by dr rows and dc columns that is after one second the robot moves from the cell r c to r dr c dc Initially dr 1 dc 1 If there is a vertical wall the left or the right walls in the movement direction dc is before the movement so the new value of dc is dc And if there is a horizontal wall the upper or lower walls dr is before the movement so the new value of dr is dr Each second including the moment before the robot starts moving the robot cleans every cell lying in the same row the same column as its position There is only one dirty cell at r d c d The job of the robot is to clean that dirty cell Given the floor size n and m the robot s initial position r b c b and the dirty cell s position r d c d find the time for the robot to do its job ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, m, x, y, a, b;\n\t\tcin >> n >> m >> x >> y >> a >> b;\n\t\tint dx = 1, dy = 1, cnt = 0;\n\t\twhile (1) {\n\t\t\tif (x == a || y == b) break;\n\t\t\t++cnt;\n\t\t\tif (x + dx < 1 || x + dx > n) dx = -dx;\n\t\t\tif (y + dy < 1 || y + dy > m) dy = -dy;\n\t\t\tx += dx; y += dy;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}']","['brute force', 'implementation', 'math']",800
https://codeforces.com//contest/483/problem/A,A. Counterexample ,Your friend has recently learned about coprime numbers A pair of numbers is called if the maximum number that divides both and is equal to one Your friend often comes up with different statements He has recently supposed that if the pair is coprime and the pair is coprime then the pair is coprime You want to find a counterexample for your friend s statement Therefore your task is to find three distinct numbers for which the statement is false and the numbers meet the condition More specifically you need to find three numbers such that pairs and are coprime and pair is not coprime ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    long long l, r; cin >> l >> r;\n    for(long long i = l; i <= r; ++i)\n    for(long long j = i + 1; j <= r; ++j)\n    for(long long k = j + 1; k <= r; ++k) {\n        if(__gcd(i, j) == 1 && __gcd(j, k) == 1 && __gcd(i, k) != 1) {\n            cout << i << \' \' << j << \' \' << k << endl;\n            return 0;\n        }\n    }\n    puts(""-1"");\n    return 0;\n}']","['brute force', 'implementation', 'math', 'number theory']",1100
https://codeforces.com//contest/14/problem/D,D. Two Paths,As you know Bob s brother lives in Flatland In Flatland there are cities connected by two way roads The cities are numbered from 1 to You can get from one city to another moving along the roads The Two Paths company where Bob s brother works has won a tender to repair two paths in Flatland A path is a sequence of different cities connected sequentially by roads The company is allowed to choose by itself the paths to repair The only condition they have to meet is that the two paths shouldn t cross i e shouldn t have common cities It is known that the profit the Two Paths company will get equals the product of the lengths of the two paths Let s consider the length of each road equals 1 and the length of a path equals the amount of roads in it Find the maximum possible profit for the company ,"['#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint n , ans;\nint a[201] , b[201];\nvector <int> sons[201];\nint far , farloc;\n\nvoid dfs(int cur , int from , int dist)\n{\n    if(dist > far)\n        far = dist , farloc = cur;\n    for(int i = 0 ; i < sons[cur].size() ; i++)\n        if(sons[cur][i] != from)\n            dfs(sons[cur][i] , cur , dist + 1);\n    \n    \n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(cin>>n)\n    {\n        ans = 0;\n        for(int i = 1 ; i < n ; i++)\n            cin>>a[i]>>b[i];\n        for(int i = 1 ; i < n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n                sons[j].clear();\n            for(int j = 1 ; j < n ; j++)\n                if(j != i)\n                {\n                    sons[a[j]].push_back(b[j]);\n                    sons[b[j]].push_back(a[j]);\n                }\n            far = -1;\n            dfs(a[i] , -1 , 0);\n            dfs(farloc , -1 , 0);\n            int tem = far;\n            far = -1;\n            dfs(b[i] , -1 , 0);\n            dfs(farloc , -1 , 0);\n            ans = max(far * tem , ans);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n']","['dfs and similar', 'dp', 'graphs', 'shortest paths', 'trees', 'two pointers']",1900
https://codeforces.com//contest/1029/problem/B,B. Creating the Contest,You are given a problemset consisting of n problems The difficulty of the i th problem is a i It is guaranteed that all difficulties are distinct and are given in the increasing order You have to assemble the contest which consists of some problems of the given problemset In other words There is only one condition that should be satisfied for each problem but the hardest one the problem with the maximum difficulty there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem In other words let a i 1 a i 2 dots a i p be the difficulties of the selected problems in increasing order Then for each j from 1 to p 1 a i j 1 le a i j cdot 2 should hold Among all contests satisfying the condition above you have to assemble one with the maximum number of problems Your task is to find this number of problems ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n\nint n,a[200005],mx,cur;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    mx=cur=1;\n    for(int i=2;i<=n;i++){\n        if(a[i]>2*a[i-1]) cur=1;\n        else cur++;\n        mx=max(mx,cur);\n    }\n    cout << mx;\n}\n']","['dp', 'greedy', 'math']",1200
https://codeforces.com//contest/966/problem/C,C. Big Secret,Vitya has learned that the answer for The Ultimate Question of Life the Universe and Everything is not the integer 42 but an increasing integer sequence a 1 ldots a n In order to not reveal the secret earlier than needed Vitya encrypted the answer and obtained the sequence b 1 ldots b n using the following rules b 1 a 1 b i a i oplus a i 1 for all i from 2 to n where x oplus y is the bitwise XOR of x and y It is easy to see that the original sequence can be obtained using the rule a i b 1 oplus ldots oplus b i However some time later Vitya discovered that the integers b i in the cypher got shuffled and it can happen that when decrypted using the rule mentioned above it can produce a sequence that is not increasing In order to save his reputation in the scientific community Vasya decided to find some permutation of integers b i so that the sequence a i b 1 oplus ldots oplus b i is strictly increasing Help him find such a permutation or determine that it is impossible ,"['#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nusing namespace std;\nint n,u[100];\nL a[100010],p;\nvector<L> x[100],f;\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j;\n\tscanf(""%d"",&n);\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(""%lld"",&a[i]);\n\t   for(j=60;!(a[i]&(1ll<<j));j--);\n\t   x[j].pb(a[i]);\n      }\n    do\n      {\n       for(i=0;i<=60;i++)\n         if(!(p&(1ll<<i)) && u[i]<x[i].size())\n           {\n            p^=x[i][u[i]];\n            f.pb(x[i][u[i]]);\n            u[i]++;\n            break;\n           }\n      }\n    while(i<=60);\n    if(f.size()==n)\n      {\n       printf(""Yes\\n"");\n       for(i=0;i<n;i++)\n         printf(""%lld "",f[i]);\n      }\n    else\n      printf(""No\\n"");\n\treturn 0;\n}\n']","['constructive algorithms', 'data structures', 'greedy', 'math']",2200
https://codeforces.com//contest/818/problem/C,C. Sofa Thief,Yet another round on DecoForces is coming Grandpa Maks wanted to participate in it but someone has stolen his precious sofa And how can one perform well with such a major loss Fortunately the thief had left a note for Grandpa Maks This note got Maks to the sofa storehouse Still he had no idea which sofa belongs to him as they all looked the same The storehouse is represented as matrix Every sofa takes two neighbouring by some side cells No cell is covered by more than one sofa There can be empty cells Sofa is standing to the left of sofa if there exist two such cells and that is covered by and is covered by Sofa is standing to the top of sofa if there exist two such cells and that is covered by and is covered by Right and bottom conditions are declared the same way Also some sofa can be both to the top of another sofa and to the bottom of it The same is for left and right conditions The note also stated that there are sofas to the left of Grandpa Maks s sofa to the right to the top and to the bottom Grandpa Maks asks you to help him to identify his sofa It is guaranteed that there is no more than one sofa of given conditions Output the number of Grandpa Maks s sofa If there is no such sofa that all the conditions are met for it then output ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\n#define x1 fjkljklx1\n#define y1 fjkljkly1\n#define x2 fjkljklx2\n#define y2 fjkljkly2\nint d , n , m;\nint x1[ N ] , x2[ N ] , y1[ N ] , y2[ N ];\nint cntl , cntr , cntt , cntb;\nvoid init(){\n  cin >> d >> n >> m;\n  for( int i = 0 ; i < d ; i ++ )\n    cin >> x1[ i ] >> y1[ i ] >> x2[ i ] >> y2[ i ];\n  cin >> cntl;\n  cin >> cntr;\n  cin >> cntt;\n  cin >> cntb;\n}\nint cl[ N ] , cr[ N ] , ct[ N ] , cb[ N ];\nvoid solve(){\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { x1[ i ] , i } );\n      v.push_back( { x2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // left xa < xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cl[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cl[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cr[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cr[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { y1[ i ] , i } );\n      v.push_back( { y2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // top ya < yb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          ct[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            ct[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cb[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cb[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  for( int i = 0 ; i < d ; i ++ )\n    if( cl[ i ] == cntl and\n        cr[ i ] == cntr and\n        ct[ i ] == cntt and\n        cb[ i ] == cntb ){\n      cout << i + 1 << endl;\n      return;\n    }\n  cout << -1 << endl;\n}\nint main(){\n  init();\n  solve();\n}\n']","['brute force', 'implementation']",2000
https://codeforces.com//contest/817/problem/B,B. Makes And The Product,After returning from the army Makes received a gift an array consisting of positive integer numbers He hadn t been solving problems for a long time so he became interested to answer a particular question how many triples of indices such that is minimum possible are there in the array Help him with it ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nconst int maxn = 1e5 + 5;\nint n;\nint a[maxn];\n\nvoid solve() {\n    cin >> n;\n    FOR(i, 0, n) cin >> a[i];\n    sort(a, a + n);\n    int tot = 0;\n    FOR(i, 0, n) if (a[i] == a[2]) tot++;\n    int k = 1 + (a[2] == a[1]) + (a[2] == a[0]);\n    long long ans = 1;\n    FOR(i, 0, k) {\n        ans *= tot - i;\n    }\n    FOR(i, 0, k) {\n        ans /= i + 1;\n    }\n    cout << ans << ""\\n"";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","['combinatorics', 'implementation', 'math', 'sortings']",1500
https://codeforces.com//contest/1706/problem/C,C. Qpwoeirut And The City,Qpwoeirut s city can be described as a row of n buildings the i th 1 le i le n of which is h i floors high You can assume that the height of every floor in this problem is equal Therefore building i is taller than the building j if and only if the number of floors h i in building i is larger than the number of floors h j in building j Building i is if it is taller than both building i 1 and building i 1 and both of them exist Note that neither the 1 st nor the n th building can be cool To remodel the city Qpwoeirut needs to maximize the number of cool buildings To do this Qpwoeirut can build additional floors on top of any of the buildings to make them taller Note that he cannot remove already existing floors Since building new floors is expensive Qpwoeirut wants to minimize the number of floors he builds Find the minimum number of floors Qpwoeirut needs to build in order to maximize the number of cool buildings ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1e5 + 5;\n\nint a[N], val[N];\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\trep(i, 1, n) a[i] = read();\n\t\trep(i, 2, n - 1) val[i] = max(0, max(a[i - 1], a[i + 1]) - a[i] + 1);\n\t\tif (n % 2 == 1) {\n\t\t\tlong long ans = 0;\n\t\t\tfor (int i = 2; i <= n - 1; i += 2) {\n\t\t\t\tans += val[i];\n\t\t\t}\n\t\t\tprintf(""%lld\\n"", ans);\n\t\t} else {\n\t\t\tlong long ans = 1e18, sum = 0;\n\t\t\tfor (int i = 3; i <= n - 1; i += 2) {\n\t\t\t\tsum += val[i];\n\t\t\t}\n\t\t\tans = sum;\n\t\t\tfor (int i = 2; i <= n - 2; i += 2) {\n\t\t\t\tsum += val[i];\n\t\t\t\tsum -= val[i + 1];\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\tprintf(""%lld\\n"", ans);\n\t\t}\n\t}\n}']","['dp', 'flows', 'greedy', 'implementation']",1400
https://codeforces.com//contest/1868/problem/C,C. Travel Plan,During the summer vacation after Zhongkao examination Tom and Daniel are planning to go traveling There are n cities in their country numbered from 1 to n And the traffic system in the country is very special For each city i 1 le i le n there is a road between city i and 2i if 2i le n a road between city i and 2i 1 if 2i 1 le n Making a travel plan Daniel chooses some integer value between 1 and m for each city for the i th city we denote it by a i Let s i j be the maximum value of cities in the simple dagger path between cities i and j The of the travel plan is sum i 1 n sum j i n s i j Tom wants to know the sum of scores of all possible travel plans Daniel asks you to help him find it You just need to tell him the answer modulo 998 244 353 dagger A simple path between cities x and y is a path between them that passes through each city at most once ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã\x81§æ\x95°å\x88\x97ã\x82\x92ç®¡ç\x90\x86ã\x81\x99ã\x82\x8bã\x81¨ã\x81\x8dã\x81«ä½¿ã\x81\x86 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ã\x81\x97ã\x81¦ã\x81ªã\x81\x84ã\x82\x84\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã\x82½ã\x83¼ã\x83\x88ã\x81\x97ã\x81¦ i ç\x95ªç\x9b®ã\x81\x8c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾\x8bã\x81\x88ã\x81° sortidx ã\x81§å¾\x97ã\x81\x9f idx ã\x82\x92ä½¿ã\x81\x88ã\x81°å\x8d\x98ã\x81«ã\x82½ã\x83¼ã\x83\x88å\x88\x97ã\x81«ã\x81ªã\x81£ã\x81¦è¿\x94ã\x81£ã\x81¦ã\x81\x8fã\x82\x8b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\n//mint107 ã\x81¯ verify ã\x81\x97ã\x81¦ã\x81\xadã\x81\x88\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 æ\x9cªæº\x80ã\x81®æ\x9c\x80å¤§ã\x81®å®\x89å\x85¨ç´\xa0æ\x95°\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//å¯¾è§\x92ç·\x9aã\x82\x92è¶\x85ã\x81\x88ã\x81\x9a (x,y) ã\x81«è\x87³ã\x82\x8bæ\x96¹æ³\x95ã\x81®æ\x95°\nmint catalan(int x,int y){\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nconst int L=62;\n\nmint getnum(int n,int len){\n\tint lw=1ll<<len,up=lw*2;\n\tchmin(up,n+1);\n\treturn max(up-lw,0ll);\n}\n\npi getxy(int n){\n\tint t=topbit(n+1)-1;\n\tint x=mask(t),y=mask(t);\n\tint rem=n-1-x-y;\n\tint u=min(rem,1ll<<t);\n\tx+=u;\n\ty+=rem-u;\n\treturn pi(x,y);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvc<mint> buf(L*2);\n\tbuf[1]+=n;\n\tmap<int,int> cnt;\n\tcnt[n]=1;\n\twhile(si(cnt)){\n\t\tauto itr=prev(cnt.ed);\n\t\tauto [key,val]=*itr;\n\t\tcnt.erase(itr);\n\t\tint t=topbit(key);\n\t\tauto [x,y]=getxy(key);\n\t\tfor(auto z:{x,y}){\n\t\t\trep(i,t){\n\t\t\t\tmint a=getnum(z,i);\n\t\t\t\tif(i+2==3)dmp2(key,val,a);\n\t\t\t\tbuf[i+2]+=a*val;\n\t\t\t}\n\t\t}\n\t\trep(i,t){\n\t\t\tmint a=getnum(x,i);\n\t\t\trep(j,t){\n\t\t\t\tmint b=getnum(y,j);\n\t\t\t\tif(i+j+3==3)dmp2(key,val,a,b);\n\t\t\t\tbuf[i+j+3]+=a*b*val;\n\t\t\t}\n\t\t}\n\t\tif(x)cnt[x]+=val;\n\t\tif(y)cnt[y]+=val;\n\t}\n\t\n\tdmp(vc<mint>(buf.bg,buf.bg+5));\n\t\n\tvc<mint> wei(L*2);\n\trep(k,L*2)wei[k]=mint(m).pow(k+1);\n\trep(v,m){\n\t\tmint w=1;\n\t\trep(k,L*2){\n\t\t\twei[k]-=w;\n\t\t\tw*=v;\n\t\t}\n\t}\n\trep(k,L*2)wei[k]*=mint(m).pow(n-k);\n\t\n\tmint ans=0;\n\trep(k,L*2)ans+=buf[k]*wei[k];\n\t\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['combinatorics', 'dp', 'implementation', 'math', 'trees']",2400
https://codeforces.com//contest/613/problem/E,E. Puzzle Lover,Oleg Petrov loves crossword puzzles and every Thursday he buys his favorite magazine with crosswords and other word puzzles In the last magazine Oleg found a curious puzzle and the magazine promised a valuable prize for it s solution We give a formal description of the problem below The puzzle field consists of two rows each row contains cells Each cell contains exactly one small English letter You also are given a word which consists of small English letters A of the puzzle is a sequence of field cells such that For all from to the letter written in the cell matches the letter All the cells in the sequence are pairwise distinct For all from to cells and have a common side Oleg Petrov quickly found a solution for the puzzle Now he wonders how many distinct solutions are there for this puzzle Oleg Petrov doesn t like too large numbers so calculate the answer modulo Two solutions and are considered distinct if the sequences of cells do not match in at least one position that is there is such in range from to such that ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\n\nconst int maxn = 2000, maxm = 2000;\n\nint n, m;\nchar a[maxn + 5], b[maxn + 5], c[maxn + 5];\n\nint g[2][maxn + 5];\nint w[maxn + 5];\n\nbool ok_left[2][maxn + 5][maxm + 5];\nbool ok_right[2][maxn + 5][maxm + 5];\n\nint Max[2][maxn + 5][maxm + 5];\n\nint dp[2][maxn + 5][maxn + 5];\n\nint ans = 0;\n\ninline void update(int i, int j, int k, int val)\n{\n\tif (k == m || ok_right[i][j][k]) (ans += val) %= Mod;\n}\n\ninline void solve(bool ty)\n{\n\tmemset(ok_left, 0, sizeof ok_left);\n\tmemset(ok_right, 0, sizeof ok_right);\n\tmemset(Max, 0, sizeof Max);\n\tREP(i, 0, 2)\n\t{\n\t\tfor (int j = n - 1; j >= 0; --j) for (int k = m - 1; k >= 0; --k)\n\t\t\tif (g[i][j] == w[k]) Max[i][j][k] = Max[i][j + 1][k + 1] + 1;\n\t}\n\tREP(i, 0, 2)\n\t{\n\t\tREP(j, 0, n)\n\t\t{\n\t\t\tint k = j;\n\t\t\tint cur = 0;\n\t\t\twhile (k >= 0)\n\t\t\t{\n\t\t\t\tif (g[i][k] != w[cur++] || (cur << 1) > m) break;\n\t\t\t\tif (k != j) ok_left[!i][j + 1][cur << 1] = k + Max[!i][k][cur] > j;\n\t\t\t\t--k;\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j)\n\t\t{\n\t\t\tint k = j;\n\t\t\tint cur = m;\n\t\t\twhile (k < n)\n\t\t\t{\n\t\t\t\tif (g[i][k] != w[--cur] || (cur << 1) < m) break;\n\t\t\t\tif (j != k) ok_right[!i][j][(cur << 1) - m] = j + Max[!i][j][(cur << 1) - m] > k;\n\t\t\t\t++k;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 0, sizeof dp);\n\tREP(j, 0, n + 1)\n\t{\n\t\tREP(i, 0, 2)\n\t\t\tREP(k, 0, m + 1)\n\t\t\t{\n\t\t\t\tif (!k || ok_left[i][j][k]) (++dp[i][j][k]) %= Mod;\n\t\t\t\tif (ty && k && k < m) update(i, j, k, dp[i][j][k]);\n\t\t\t\tif (dp[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tif (j < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k < m && g[i][j] == w[k]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(dp[i][j + 1][k + 1] += dp[i][j][k]) %= Mod;\n\t\t\t\t\t\t\tif (ty && k && k + 1 == m) update(i, j + 1, k + 1, dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k + 1 < m && g[i][j] == w[k] && g[!i][j] == w[k + 1]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(dp[!i][j + 1][k + 2] += dp[i][j][k]) %= Mod;\n\t\t\t\t\t\t\tif (ty && k && k + 2 == m) update(!i, j + 1, k + 2, dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ty) update(i, j, k, dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tscanf(""%s%s%s"", a, b, c);\n\tn = strlen(a), m = strlen(c);\n\tREP(i, 0, n) g[0][i] = a[i] - \'a\', g[1][i] = b[i] - \'a\';\n\tREP(i, 0, m) w[i] = c[i] - \'a\';\n\tans = 0;\n\tsolve(0);\n\treverse(w, w + m);\n\tsolve(1);\n\t(ans += Mod) %= Mod;\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n\n']","['dp', 'hashing', 'strings']",3200
https://codeforces.com//contest/603/problem/A,A. Alternative Thinking,Kevin has just recevied his disappointing results on the USA Identification of Cows Olympiad USAICO in the form of a binary string of length Each character of Kevin s string represents Kevin s score on one of the questions of the olympiad for a correctly identified cow and otherwise However all is not lost Kevin is a big proponent of alternative thinking and believes that his score instead of being the sum of his points should be the length of the longest alternating subsequence of his string Here we define an of a string as a subsequence where no two consecutive elements are equal For example and are alternating sequences while and are not Kevin being the sneaky little puffball that he is is willing to hack into the USAICO databases to improve his score In order to be subtle he decides that he will flip exactly one substring that is take a non empty substring of his score and change all s in that substring to s and vice versa After such an operation Kevin wants to know the length of the longest possible alternating subsequence that his string could have ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 211111\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n;\nchar s[N];\n\nint dp[N][3][2];\n\nint main(){\n//\tfreopen(TASK"".in"",""r"",stdin);\t\n//\tfreopen(TASK"".out"",""w"",stdout);\n\tscanf(""%d\\n"", &n);\n\tgets(s);\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= 2; j++) for (int k = 0; k < 2; k++) dp[i][j][k] = -1e9 -1;\n\tdp[0][0][0] = 0;\n\tdp[0][0][1] = 0;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j <= 2; j++) for (int k = 0; k < 2; k++) if (dp[i][j][k] >= 0) {\n\n\t\tint cur = s[i] - \'0\';\n\t\tif (j == 1) cur ^= 1;\n\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]);\n\n\t\tif (cur == k) dp[i + 1][j][k ^ 1] = max(dp[i + 1][j][k ^ 1], dp[i][j][k] + 1);\n\n\t\tif (j <= 1) dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]);\n\t}\n\tint ans = 0;\n\tfor (int j = 0; j <= 2; j++) for (int k = 0; k < 2; k++) ans = max(ans, dp[n][j][k]);\n\tcout << ans << endl;\n\treturn 0;\n}']","['dp', 'greedy', 'math']",1600
https://codeforces.com//contest/416/problem/D,D. Population Size,Polycarpus develops an interesting theory about the interrelation of arithmetic progressions with just everything in the world His current idea is that the population of the capital of Berland changes over time like an arithmetic progression Well or like multiple arithmetic progressions Polycarpus believes that if he writes out the population of the capital for several consecutive years in the sequence then it is convenient to consider the array as several arithmetic progressions written one after the other For example sequence can be considered as a sequence of three arithmetic progressions and which are written one after another Unfortunately Polycarpus may not have all the data for the consecutive years a census of the population doesn t occur every year after all For this reason some values of may be unknown Such values are represented by number For a given sequence which consists of positive integers and values find the minimum number of arithmetic progressions Polycarpus needs to get To get the progressions need to be written down one after the other Values may correspond to an arbitrary positive integer and the values must be equal to the corresponding elements of sought consecutive record of the progressions Let us remind you that a finite sequence is called an arithmetic progression if the difference of any two consecutive elements in it is constant By definition any sequence of length 1 is an arithmetic progression ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 200000 + 10;\n\nint n;\nlong long a[N];\n\nint getNext(int st)\n{\n    long long tmp = st;\n    vector<pair<long long, int> > vec;\n    for( ; tmp < n && vec.size() < 2; tmp ++) {\n        if (a[tmp] > 0) {\n            vec.push_back(make_pair(a[tmp], tmp));\n        }\n    }\n    if (vec.size() != 2) return n;\n\n    long long v1 = vec[0].first, t1 = vec[0].second;\n    long long v2 = vec[1].first, t2 = vec[1].second;\n    if ((v2 - v1) % (t2 - t1) == 0) {\n        long long d = (v2 - v1) / (t2 - t1);\n        tmp = v1;\n        int flag = true;\n        for(int i = t1 - 1; i >= st; -- i) {\n            tmp -= d;\n            if (tmp <= 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            st = t2;\n            tmp = v2;\n            for( ; st < n && tmp > 0; ) {\n                if (a[st] > 0 && a[st] != tmp) break;\n                ++ st;\n                tmp += d;\n            }\n            return st;\n        }\n    }\n    return t2;\n}\n\nvoid solve()\n{\n    cin >> n;\n    for(int i = 0; i < n; ++ i) {\n        scanf(""%I64d"", a + i);\n    }\n    int ret = 0;\n    int tmp = 0;\n    for( ; tmp != n; ) {\n        ++ ret;\n        tmp = getNext(tmp);\n    }\n    cout << ret << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n']","['greedy', 'implementation', 'math']",2400
https://codeforces.com//contest/887/problem/D,D. Ratings and Reality Shows,There are two main kinds of events in the life of top model fashion shows and photo shoots Participating in any of these events affects the rating of appropriate top model After each photo shoot model s rating increases by and after each fashion show decreases by designers do too many experiments nowadays Moreover sometimes top models participates in talk shows After participating in talk show model becomes more popular and increasing of her rating after photo shoots become and decreasing of her rating after fashion show becomes Izabella wants to participate in a talk show but she wants to do it in such a way that her rating will never become negative Help her to find a suitable moment for participating in the talk show Let s assume that model s career begins in moment 0 At that moment Izabella s rating was equal to If talk show happens in moment if will affect all events in model s life in interval of time including and not including where is duration of influence Izabella wants to participate in a talk show but she wants to do it in such a way that her rating will not become become negative before talk show or during period of influence of talk show Help her to find a suitable moment for participating in the talk show ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, splus, sminus, dplus, dminus, start, len;\nint *t, *q;\n\n__int64 *s;\n__int64 *ds;\n__int64 *ts, *tds;\n\n\nvoid build(__int64 *a, __int64 *t, int v, int tl, int tr) {\n\tif (tl == tr)\n\t\tt[v] = a[tl];\n\telse {\n\t\tint tm = (tl + tr) / 2;\n\t\tbuild(a, t, v * 2, tl, tm);\n\t\tbuild(a, t, v * 2 + 1, tm + 1, tr);\n\t\tt[v] = min(t[v * 2], t[v * 2 + 1]);\n\t}\n}\n\n__int64 minsum(__int64 *a, __int64 *t, int v, int tl, int tr, int l, int r) {\n\tif (l > r)\n\t\treturn 9223372036854775807i64;\n\tif (l == tl && r == tr)\n\t\treturn t[v];\n\tint tm = (tl + tr) / 2;\n\treturn min(minsum(a, t, v * 2, tl, tm, l, min(r, tm)),\n\t\tminsum(a, t, v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n}\n\nint getLeft(int time, int *a, int l, int r)\n{\n\tif (a[l] >= time)\n\t{\n\t\treturn l;\n\t}\n\tif (a[r] < time)\n\t{\n\t\treturn -1;\n\t}\n\twhile (r - l > 1)\n\t{\n\t\tint middle = (r + l) / 2;\n\t\tif (a[middle] >= time)\n\t\t{\n\t\t\tr = middle;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl = middle;\n\t\t}\n\t}\n\treturn r;\n}\n\nint getRight(int time, int *a, int l, int r)\n{\n\tif (a[l] > time)\n\t{\n\t\treturn -1;\n\t}\n\tif (a[r] <= time)\n\t{\n\t\treturn r;\n\t}\n\twhile (r - l > 1)\n\t{\n\t\tint middle = (r + l) / 2;\n\t\tif (a[middle] <= time)\n\t\t{\n\t\t\tl = middle;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = middle;\n\t\t}\n\t}\n\treturn l;\n}\n\nbool check(int time)\n{\n\tint l = getLeft(time, t, 0, n - 1);\n\tint r = getRight(time + len - 1, t, 0, n - 1);\n\n\tif (l == -1 || r == -1)\n\t{\n\t\treturn minsum(s, ts, 1, 0, n - 1, 0, n - 1) + start >= 0;\n\t}\n\n\t__int64 rate = start;\n\n\tif (l != 0)\n\t{\n\t\tint left = 0;\n\t\tint right = l - 1;\n\n\t\t__int64 diff = minsum(s, ts, 1, 0, n - 1, left, right);\n\n\t\tif (rate + diff < 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\trate += s[right];\n\t}\n\n\t{\n\t\tint left = l;\n\t\tint right = r;\n\n\t\t__int64 diff = minsum(ds, tds, 1, 0, n - 1, left, right);\n\t\t\n\t\tif (left != 0)\n\t\t{\n\t\t\tdiff = diff - ds[left - 1];\n\t\t}\n\n\t\tif (rate + diff < 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\trate += diff;\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\t//freopen(""input.txt"", ""r"", stdin);\n\t//freopen(""output.txt"", ""w"", stdout);\n\n\tcin >> n >> splus >> sminus >> dplus >> dminus >> start >> len;\n\n\tsminus *= -1;\n\tdminus *= -1;\n\n\tt = new int[n];\n\tq = new int[n];\n\ts = new __int64[n];\n\tds = new __int64[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> t[i] >> q[i];\n\t}\n\n\ts[0] = q[0] == 1 ? splus : sminus;\n\tds[0] = q[0] == 1 ? dplus : dminus;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\ts[i] = s[i - 1] + (q[i] == 1 ? splus : sminus);\n\t\tds[i] = ds[i - 1] + (q[i] == 1 ? dplus : dminus);\n\t}\n\n\tts = new __int64[(n + 1) * 4];\n\ttds = new __int64[(n + 1) * 4];\n\n\tbuild(s, ts, 1, 0, n - 1);\n\tbuild(ds, tds, 1, 0, n - 1);\n\t\n\tvector<int> times;\n\n\ttimes.push_back(0);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ttimes.push_back(t[i] + 1);\n\t\ttimes.push_back(t[i] + 1 - len);\n\t}\n\n\tsort(times.begin(), times.end());\n\n\tfor (int i = 0; i < times.size(); ++i)\n\t{\n\t\tif (times[i] < 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (check(times[i]))\n\t\t{\n\t\t\tcout << times[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << -1;\n\n\treturn 0;\n}']","['data structures', 'two pointers']",2400
https://codeforces.com//contest/1754/problem/A,A. Technical Support,You work in the quality control department of technical support for a large company Your job is to make sure all client issues have been resolved Today you need to check a copy of a dialog between a client and a technical support manager According to the rules of work each message of the client must be followed by messages which are the answer of a support manager However sometimes clients ask questions so quickly that some of the manager s answers to old questions appear after the client has asked some new questions Due to the privacy policy the full text of messages is not available to you only the order of messages is visible as well as the type of each message a customer question or a response from the technical support manager You have to determine if this dialog may correspond to the rules of work described above or the rules are certainly breached ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ln cout<<\'\\n\'\n#define ll long long\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(""%.10f\\n"",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n)cout<<(i?"" "":"""")<<a[i];ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,1,0,-1,-1,1,1,-1};\ntypedef pair<ll,ll> P;\n\nvoid Main() {\n  ll T;\n  R T;\n  while(T--) {\n    ll n;\n    string s;\n    cin >> n >> s;\n    ll x=0,f=1;\n    rrep(i,n) {\n      if(s[i]==\'Q\') x--;\n      else x++;\n      if(x<0) f=0;\n    }\n    if(f) pr(""Yes"");\n    else pr(""No"");\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n']",['greedy'],800
https://codeforces.com//contest/803/problem/D,D. Magazine Ad,The main city magazine offers its readers an opportunity to publish their ads The format of the ad should be like this There are space separated non empty words of lowercase and uppercase Latin letters There are hyphen characters in some words their positions set word wrapping points Word can include more than one hyphen It is guaranteed that there are no adjacent spaces and no adjacent hyphens No hyphen is adjacent to space There are no spaces and no hyphens before the first word and after the last word When the word is wrapped the part of the word before hyphen and the hyphen itself stay on current line and the next part of the word is put on the next line You can also put line break between two words in that case the space stays on current line Check notes for better understanding The ad can occupy no more that lines and should have minimal width The width of the ad is the maximal length of string letters spaces and hyphens are counted in it You should write a program that will find minimal width of the ad ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9;\nint k;\nstring s;\nint n;\n\nint solve(int w)\n{\n    int ans = 0;\n    int l = 0;\n    while(l < n)\n    {\n        ans++;\n        int r = l + w;\n        if (r >= n) break;\n        while(r > l && s[r - 1] != \' \' && s[r - 1] != \'-\') r--;\n        if (r == l) return INF;\n        l = r;\n    }\n    return ans;\n}\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    cin >> k;\n    getline(cin, s);\n    getline(cin, s);\n\n    n = s.length();\n    int l = 0, r = n;\n    while(r - l > 1)\n    {\n        int m = (l + r) / 2;\n        if (solve(m) <= k)\n            r = m;\n        else\n            l = m;\n    }\n    cout << r << endl;\n\n    return 0;\n}\n']","['binary search', 'greedy']",1900
https://codeforces.com//contest/1617/problem/D2,D2. Too Many Impostors  hard version ,There are n players labelled from 1 to n Among them there are k impostors and n k crewmates The number of impostors k is not given to you In each question you can choose three distinct integers a b c 1 le a b c le n and ask Among the players labelled a b and c are there more impostors or more crewmates You will be given the integer 0 if there are more impostors than crewmates and 1 otherwise Find the number of impostors k and the indices of players that are impostors after asking at most n 6 questions The jury is which means the indices of impostors may not be fixed beforehand and can depend on your questions It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint query(int a, int b, int c) {\n\tcout << ""? "" << a << "" "" << b << "" "" << c << endl;\n\tint res;\n\tcin >> res;\n\treturn res;\n}\nvoid answer(vector<int>& v) {\n\tcout << ""! "" << v.size();\n\tfor (int x : v) cout << "" "" << x;\n\tcout << endl;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> v(n + 1);\n\t\tint x1 = -1, x2 = -1, x3 = -1;\n\t\tint y1 = -1, y2 = -1, y3 = -1;\n\t\tfor (int i = 1; i <= n; i += 3)  {\n\t\t\tv[i] = query(i, i + 1, i + 2);\n\t\t\tif (v[i] == 0)\n\t\t\t\tx1 = i, x2 = i + 1, x3 = i + 2;\n\t\t\tif (v[i] == 1)\n\t\t\t\ty1 = i, y2 = i + 1, y3 = i + 2;\n\t\t}\n\t\tassert(x1 != -1 and y1 != -1);\n\t\tvector<int> w[2];\n\t\tint a = query(x1, x2, y1) or query(x1, x2, y2);\n\t\tint b = query(x2, x3, y1) or query(x2, x3, y2);\n\t\tw[a == 1 and b == 0].push_back(x1);\n\t\tw[a == 1 and b == 1].push_back(x2);\n\t\tw[a == 0 and b == 1].push_back(x3);\n\t\tauto find = [&](int x, int y, int ic) {\n\t\t\tint a = query(y, y + 1, x), b = query(y + 1, y + 2, x);\n\t\t\tw[(a != ic and b == ic) ^ ic].push_back(y);\n\t\t\tw[(a != ic and b != ic) ^ ic].push_back(y + 1);\n\t\t\tw[(a == ic and b != ic) ^ ic].push_back(y + 2);\n\t\t};\n\t\tfind(w[0][0], y1, 1);\n\t\tfor (int i = 1; i <= n; i += 3) if (i != x1 and i != y1)\n\t\t\tfind(w[v[i] ^ 1][0], i, v[i]);\n\t\tanswer(w[0]);\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation', 'interactive', 'math']",2400
https://codeforces.com//contest/1808/problem/A,A. Lucky Numbers,Olympus City recently launched the production of personal starships Now everyone on Mars can buy one and fly to other planets inexpensively Each starship has a number some positive integer x Let s define the of a number x as the difference between the largest and smallest digits of that number For example 142857 has 8 as its largest digit and 1 as its smallest digit so its luckiness is 8 1 7 And the number 111 has all digits equal to 1 so its luckiness is zero Hateehc is a famous Martian blogger who often flies to different corners of the solar system To release interesting videos even faster he decided to buy himself a starship When he came to the store he saw starships with numbers from l to r inclusively While in the store Hateehc wanted to find a starship with the luckiest number Since there are a lot of starships in the store and Hateehc can t program you have to help the blogger and write a program that answers his question ,"[""#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\n\nint L, R;\nint ans = 0;\nint check(int x) {\n  vector<int> e;\n  while (x) {\n    e.push_back(x % 10);\n    x /= 10;\n  }\n  int minn = 10, maxx = 0;\n  for (int i = 0; i < e.size(); i++) minn = min(minn, e[i]), maxx = max(maxx, e[i]);\n  return maxx - minn;\n}\n\nvoid work() {\n  ans = 0;\n  L = read();\n  R = read();\n  int pos = L;\n  for (int i = L; i <= R; i++) {\n    int v = check(i);\n    if (v > ans) ans = v, pos = i;\n    if (ans == 9) break;\n  }\n  cout << pos << endl;\n}\n\nsigned main() {\n  int Tt = read();\n  while (Tt--) work();\n  return 0;\n}\n""]","['brute force', 'implementation']",900
https://codeforces.com//contest/89/problem/B,B. Widget Library,Vasya writes his own library for building graphical user interface Vasya called his creation One of the interesting aspects of this library is that widgets are packed in each other A widget is some element of graphical interface Each widget has width and height and occupies some rectangle on the screen Any widget in Vasya s library is of type For simplicity we will identify the widget and its type Types and are derivatives of type so they also are types Widgets and are special They can store other widgets Both those widgets can use the method to pack directly in itself some other widget Widgets of types and can store several other widgets even several equal widgets they will simply appear several times As a result of using the method only the link to the packed widget is saved that is when the packed widget is changed its image in the widget into which it is packed will also change We shall assume that the widget is packed in the widget if there exists a chain of widgets for which is packed directly to for any In Vasya s library the situation when the widget is packed in the widget that is in itself is not allowed If you try to pack the widgets into each other in this manner immediately results in an error Also the widgets and have parameters and which are determined by the methods and respectively By default both of these options equal The picture above shows how the widgets are packed into and At that and automatically change their size depending on the size of packed widgets As for and they only differ in that in the widgets are packed horizontally and in vertically The parameter sets the distance between adjacent widgets and a frame around all packed widgets of the desired width Packed widgets are placed exactly in the order in which the method was called for them If within or there are no packed widgets their sizes are equal to regardless of the options and The construction of all the widgets is performed using a scripting language The description of the language can be found in the input data For the final verification of the code Vasya asks you to write a program that calculates the sizes of all the widgets on the source code in the language of ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\nchar in[10000],fir[10000],sec[10000];\nstruct widget{\n    long long x,y;\n    long long sp,bo;\n    int kind; //widget=0, hbox=1, vbox=2\n    widget(){x=-1;y=-1;sp=bo=0;}\n    vector<widget*> pack;\n    inline void calc(){\n\tif(x!=-1)return;\n\tif(pack.size()==0){\n\t    x=0;y=0;return;\n\t}\n\tif(kind==1){\n\t    long long maxy=0;\n\t    long long sumx=-sp;\n\t    for(int i=0;i<pack.size();i++){\n\t\tpack[i]->calc();\n\t\tmaxy=max(maxy,pack[i]->y);\n\t\tsumx+=pack[i]->x+sp;\n\t    }\n\t    x=sumx+2ll*bo;\n\t    y=maxy+2ll*bo;\n\t}else{\n\t    long long maxx=0;\n\t    long long sumy=-sp;\n\t    for(int i=0;i<pack.size();i++){\n\t\tpack[i]->calc();\n\t\tmaxx=max(maxx,pack[i]->x);\n\t\tsumy+=pack[i]->y+sp;\n\t    }\n\t    y=sumy+2ll*bo;\n\t    x=maxx+2ll*bo;\n\t}\n    }\n};\nmap<string,widget*> XD;\nint main(){\n    int q,i;\n    gets(in);\n    q=atoi(in);\n    while(q--){\n\tgets(in);\n\tint l=strlen(in);\n\tfor(i=0;i<l;i++)if(in[i]==\' \')break;\n\tif(i<l){\n\t    sscanf(in,""%s%s"",fir,sec);\n\t    widget* w=new widget;\n\t    if(strcmp(fir,""Widget"")==0){\n\t\tstring ss=sec;\n\t\tstring na=ss.substr(0,ss.find(""(""));\n\t\tint x=atoi(ss.substr(ss.find(""("")+1).c_str());\n\t\tint y=atoi(ss.substr(ss.find("","")+1).c_str());\n\t\tw->x=x;\n\t\tw->y=y;\n\t\tw->kind=0;\n\t\tXD[na]=w;\n\t    }else if(strcmp(fir,""HBox"")==0){\n\t\tw->kind=1;\n\t\tXD[sec]=w;\n\t    }else{\n\t\tw->kind=2;\n\t\tXD[sec]=w;\n\t\t\n\t    }\n\t}else{\n\t    string ss=in;\n\t    string na=ss.substr(0,ss.find("".""));\n\t    string cmd=ss.substr(ss.find(""."")+1,ss.find(""("")-ss.find(""."")-1);\n\t    string tar=ss.substr(ss.find(""("")+1,ss.find("")"")-ss.find(""("")-1);\n\t    if(cmd==""pack""){\n\t\t(XD[na]->pack).push_back(XD[tar]);\n\t    }else if(cmd==""set_border""){\n\t\tXD[na]->bo=atoi(tar.c_str());\n\t    }else{\n\t\tXD[na]->sp=atoi(tar.c_str());\n\t    }\n\t}\n    }\n    for(map<string,widget*>::iterator it=XD.begin();it!=XD.end();it++){\n\tit->second->calc();\n\tprintf(""%s %I64d %I64d\\n"",(it->first).c_str(),it->second->x,it->second->y);\n    }\n}\n']","['dp', 'expression parsing', 'graphs', 'implementation']",2300
https://codeforces.com//contest/1205/problem/F,F. Beauty of a Permutation,Define the beauty of a permutation of numbers from 1 to n p 1 p 2 dots p n as number of pairs L R such that 1 le L le R le n and numbers p L p L 1 dots p R are consecutive R L 1 numbers in some order For example the beauty of the permutation 1 2 5 3 4 equals 9 and segments corresponding to pairs are 1 2 5 4 3 1 2 3 4 5 3 4 1 2 5 3 4 Answer q independent queries In each query you will be given integers n and k Determine if there exists a permutation of numbers from 1 to n with beauty equal to k and if there exists output one of them ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\npii h[105][105*107/2];\nint q,N[SZ],K[SZ];\nvector<int> aa[SZ];\nvector<int> qry[105][105*107/2];\nvector<int> ch[SZ];\nint an=0,ty[SZ];\nvector<int> op;\nvoid dfs(int w,int d=0)\n{\n//\tcerr<<w<<""!""<<ty[w]<<"":"";\n//\tfor(auto c:ch[w]) cout<<c<<"","";\n//\tcout<<""\\n"";\n\tif(!ch[w].size())\n\t{\n\t\top.pb(w);\n\t\treturn;\n\t}\n\tif(ty[w]==1)\n\t{\n\t\tvector<int> sb;\n\t\tint s=ch[w].size();\n\t\tfor(int t=1;t<s;t+=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tsb.pb(ch[w][0]);\n\t\tfor(int t=(s-1)-((s-1)&1);t>0;t-=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n\telse\n\t{\n\t\tvector<int> sb;\n\t\tfor(auto r:ch[w]) sb.pb(r);\n\t\tif(d) reverse(sb.begin(),sb.end());\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n}\nvector<int> cons(int n,int p)\n{\n//\tcerr<<n<<"",""<<p<<""\\n"";\n\tan=n;\n\tvector<int> st;\n\tfor(int i=1;i<=n;++i) ty[i]=0,ch[i].clear(),st.pb(i);\n\tint X=1,Y=p;\n\twhile(X!=n)\n\t{\n\t\tpii g=h[X][Y];\n\t\tassert(g.fi!=-1);\n\t\tint y=g.se%2; g.se/=2;\n\t\tint c=g.fi-X+1;\n\t\ttie(X,Y)=g;\n\t\t++an; ty[an]=y; ch[an].clear();\n\t\tfor(int j=1;j<=c;++j)\n\t\t\tch[an].pb(st.back()),st.pop_back();\n\t\treverse(ch[an].begin(),ch[an].end());\n\t\tst.pb(an);\n\t}\n\tassert(Y==n&&st.size()==1);\n\top.clear();\n\tdfs(an);\n\t#ifdef LOCAL\n\t#warning ""LOCAL ON""\n\tassert(op.size()==n);\n\tint sb=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tvector<int> g;\n\t\tfor(int j=i;j<n;++j)\n\t\t{\n\t\t\tg.pb(op[j]);\n\t\t\tsort(g.begin(),g.end());\n\t\t\tbool ok=1;\n\t\t\tfor(int w=0;w<g.size();++w)\n\t\t\t\tok&=g[w]==g[0]+w;\n\t\t\tif(ok) ++sb;\n\t\t}\n\t}\n//\tcerr<<sb<<""?\\n"";\n\tassert(sb==p);\n\t#endif\n\treturn op;\n}\nint main()\n{\n\tscanf(""%d"",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(""%d%d"",N+i,K+i),\n\t\tqry[N[i]][K[i]].pb(i);\n\tfor(int n=1;n<=100;++n)\n\t{\n\tmemset(h,-1,sizeof h);\n\th[n][n]=pii(0,0);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tfor(int j=n*(n+1)/2;j>=0;--j) if(~h[i][j].fi)\n\t\t{\n\t\t\tfor(int c=2;c<=i;++c)\n\t\t\t{\n\t\t\t\th[i-c+1][j+c*(c-1)/2]=pii(i,j*2);\n\t\t\t\tif(c>=4) h[i-c+1][j+1]=pii(i,j*2+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=n*(n+1)/2;j>=0;--j)\n\t\tif(h[1][j].fi!=-1&&qry[n][j].size())\n\t\t{\n\t\t\tauto u=cons(n,j);\n\t\t\tfor(auto r:qry[n][j]) aa[r]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tif(aa[i].size())\n\t\t{\n\t\t\tputs(""YES"");\n\t\t\tfor(auto x:aa[i])\n\t\t\t\tprintf(""%d "",x);\n\t\t\tputs("""");\n\t\t}\n\t\telse\n\t\t\tputs(""NO"");\n}\n']","['constructive algorithms', 'math']",3400
https://codeforces.com//contest/630/problem/L,L. Cracking the Code,The protection of a popular program developed by one of IT City companies is organized the following way After installation it outputs a random five digit number which should be sent in SMS to a particular phone number In response an SMS activation code arrives A young hacker Vasya disassembled the program and found the algorithm that transforms the shown number into the activation code The found algorithm looks the following way At first the digits of the number are shuffled in the following order first digit third digit fifth digit fourth digit second digit For example the shuffle of should lead to On the second stage the number is raised to the fifth power The result of the shuffle and exponentiation of the number is The answer is the last digits of this result For the number the answer should be Vasya is going to write a keygen program implementing this algorithm Can you do the same ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <stack>\n#include <queue>\ntypedef long long LL;\nusing namespace std;\nconst int N = 105;\nint main() {\n    int n;\n    cin >> n;\n    int a[5] = {};\n    for (int i = 0 ; i < 5 ; ++ i)\n        a[i] = n % 10 , n /= 10;\n    int m = a[4] * 10000 + a[2] * 1000 + a[0] * 100 + a[1] * 10 + a[3];\n    int res = 1;\n    for (int i = 0 ; i < 5 ; ++ i)\n        res = (LL)res * m % 100000;\n    printf(""%05d\\n"" , res);\n    return 0;\n}\n']","['implementation', 'math']",1400
https://codeforces.com//contest/1802/problem/B,B. Settlement of Guinea Pigs,Dasha loves guinea pigs very much In this regard she decided to settle as many guinea pigs at home as possible and developed a plan for the next n days Every day she will either buy a new guinea pig or call a doctor to examine all her pets Unfortunately the store where she was going to buy guinea pigs does not understand them Therefore it cannot determine their gender Dasha can t do it either The only one who can help is a doctor To keep guinea pigs aviaries are needed Dasha plans to buy them in the same store Unfortunately only one species is sold there a double aviary No more than two guinea pigs can live in it Since Dasha does not want to cause moral injury to her pets she will not settle two guinea pigs of different genders in one aviary Help Dasha calculate how many aviaries in the worst case you need to buy so that you can be sure that at no moment of time do two guinea pigs of different genders live in the same aviary ,"[""#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tint sum=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){sum=sum*10+ch-48;ch=getchar();}\n\treturn sum*f;\n}\nint b[100005];\nint main()\n{\n\tint T;\n\tT=read();\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tn=read();\n\t\tint left=0,used=0,ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tx=read();\n\t\t\tif(x==1)left++;\n\t\t\tif(x==2)\n\t\t\t{\n\t\t\t\tif(!left)continue;\n\t\t\t\tif(left&1) used+=left/2,left=1;\n\t\t\t\telse used+=(left-2)/2,left=2;\n\t\t\t}\n\t\t\tans=max(ans,used+left);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n""]","['greedy', 'implementation', 'math']",1000
https://codeforces.com//contest/1142/problem/B,B. Lynyrd Skynyrd,Recently Lynyrd and Skynyrd went to a shop where Lynyrd bought a permutation p of length n and Skynyrd bought an array a of length m consisting of integers from 1 to n Lynyrd and Skynyrd became bored so they asked you q queries each of which has the following form does the subsegment of a from the l th to the r th positions inclusive have a subsequence that is a cyclic shift of p Please answer the queries A of length n is a sequence of n integers such that each integer from 1 to n appears exactly once in it A of a permutation p 1 p 2 ldots p n is a permutation p i p i 1 ldots p n p 1 p 2 ldots p i 1 for some i from 1 to n For example a permutation 2 1 3 has three distinct cyclic shifts 2 1 3 1 3 2 3 2 1 A of a subsegment of array a from the l th to the r th positions inclusive is a sequence a i 1 a i 2 ldots a i k for some i 1 i 2 ldots i k such that l leq i 1 i 2 ldots i k leq r ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nconst int LOG = 18;\nint a[N];\nint p[N];\nint nxt[N];\nint b[N][LOG];\nint sparse[LOG][N];\nint p2[N];\nint n, m, q;\n\nint getMin(int l, int r) {\n\tint k = p2[r - l];\n\treturn min(sparse[k][l], sparse[k][r - (1 << k)]);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &m, &n, &q);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tp[x] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\ta[i] = p[x];\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""%d "", a[i]);\n\teprintf(""\\n"");\n\t*/\n\tfor (int i = 0; i < m; i++)\n\t\tnxt[i] = n;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tb[i][k] = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint x = a[i];\n\t\tint y = x + 1;\n\t\tif (y == m) y = 0;\n\t\tb[i][0] = nxt[y];\n\t\tnxt[x] = i;\n\t}\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint w = b[i][k];\n\t\t\tb[i][k + 1] = b[w][k];\n\t\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = i;\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tif (((m - 1) >> k) & 1)\n\t\t\t\tx = b[x][k];\n\t\tsparse[0][i] = x;\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""%d "", sparse[0][i]);\n\teprintf(""\\n"");\n\t*/\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i + (1 << (k + 1)) <= n; i++)\n\t\t\tsparse[k + 1][i] = min(sparse[k][i], sparse[k][i + (1 << k)]);\n\n\tfor (int i = 2; i < N; i++)\n\t\tp2[i] = p2[i / 2] + 1;\n\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tl--;\n\t\tif (getMin(l, r) < r)\n\t\t\tprintf(""1"");\n\t\telse\n\t\t\tprintf(""0"");\n\t}\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']","['data structures', 'dfs and similar', 'dp', 'math', 'trees']",2000
https://codeforces.com//contest/280/problem/D,D. k-Maximum Subsequence Sum,Consider integer sequence You should run queries of two types The query format is In reply to this query you should make the following assignment The query format is In reply to this query you should print the maximum sum of at most non intersecting subsegments of sequence Formally you should choose at most pairs of integers such that the sum is as large as possible Note that you should choose at most subsegments Particularly you can choose 0 subsegments In this case the described sum considered equal to zero ,"['/*\nAuthor: elfness@UESTC\n*/\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAX = 105000;\n\n/**\n * Segment tree\n */\nstruct Seg\n{\n        int l, r;\n        int maxLeftValue, maxRightValue, minLeftValue, minRightValue, maxSum,\n                minSum, sum;\n        int maxLeftBound, maxRightBound, minLeftBound, minRightBound,\n                maxSumLeft, maxSumRight, minSumLeft, minSumRight;\n} seg[MAX << 2];\nint a[MAX];\n\nvoid update(int k)\n{\n    seg[k].sum = seg[k << 1].sum + seg[k << 1 | 1].sum;\n    if (seg[k << 1].maxLeftValue >= seg[k << 1].sum\n            + seg[k << 1 | 1].maxLeftValue)\n    {\n        seg[k].maxLeftValue = seg[k << 1].maxLeftValue;\n        seg[k].maxRightBound = seg[k << 1].maxRightBound;\n    }\n    else\n    {\n        seg[k].maxLeftValue = seg[k << 1].sum + seg[k << 1 | 1].maxLeftValue;\n        seg[k].maxRightBound = seg[k << 1 | 1].maxRightBound;\n    }\n    if (seg[k << 1 | 1].maxRightValue >= seg[k << 1 | 1].sum\n            + seg[k << 1].maxRightValue)\n    {\n        seg[k].maxRightValue = seg[k << 1 | 1].maxRightValue;\n        seg[k].maxLeftBound = seg[k << 1 | 1].maxLeftBound;\n    }\n    else\n    {\n        seg[k].maxRightValue = seg[k << 1 | 1].sum + seg[k << 1].maxRightValue;\n        seg[k].maxLeftBound = seg[k << 1].maxLeftBound;\n    }\n    if (seg[k << 1].minLeftValue <= seg[k << 1].sum\n            + seg[k << 1 | 1].minLeftValue)\n    {\n        seg[k].minLeftValue = seg[k << 1].minLeftValue;\n        seg[k].minRightBound = seg[k << 1].minRightBound;\n    }\n    else\n    {\n        seg[k].minLeftValue = seg[k << 1].sum + seg[k << 1 | 1].minLeftValue;\n        seg[k].minRightBound = seg[k << 1 | 1].minRightBound;\n    }\n    if (seg[k << 1 | 1].minRightValue <= seg[k << 1 | 1].sum\n            + seg[k << 1].minRightValue)\n    {\n        seg[k].minRightValue = seg[k << 1 | 1].minRightValue;\n        seg[k].minLeftBound = seg[k << 1 | 1].minLeftBound;\n    }\n    else\n    {\n        seg[k].minRightValue = seg[k << 1 | 1].sum + seg[k << 1].minRightValue;\n        seg[k].minLeftBound = seg[k << 1].minLeftBound;\n    }\n    if (seg[k << 1].maxSum >= seg[k << 1 | 1].maxSum)\n    {\n        seg[k].maxSum = seg[k << 1].maxSum;\n        seg[k].maxSumLeft = seg[k << 1].maxSumLeft;\n        seg[k].maxSumRight = seg[k << 1].maxSumRight;\n    }\n    else\n    {\n        seg[k].maxSum = seg[k << 1 | 1].maxSum;\n        seg[k].maxSumLeft = seg[k << 1 | 1].maxSumLeft;\n        seg[k].maxSumRight = seg[k << 1 | 1].maxSumRight;\n    }\n    if (seg[k].maxSum < seg[k << 1].maxRightValue\n            + seg[k << 1 | 1].maxLeftValue)\n    {\n        seg[k].maxSum = seg[k << 1].maxRightValue\n                + seg[k << 1 | 1].maxLeftValue;\n        seg[k].maxSumLeft = seg[k << 1].maxLeftBound;\n        seg[k].maxSumRight = seg[k << 1 | 1].maxRightBound;\n    }\n\n    if (seg[k << 1].minSum <= seg[k << 1 | 1].minSum)\n    {\n        seg[k].minSum = seg[k << 1].minSum;\n        seg[k].minSumLeft = seg[k << 1].minSumLeft;\n        seg[k].minSumRight = seg[k << 1].minSumRight;\n    }\n    else\n    {\n        seg[k].minSum = seg[k << 1 | 1].minSum;\n        seg[k].minSumLeft = seg[k << 1 | 1].minSumLeft;\n        seg[k].minSumRight = seg[k << 1 | 1].minSumRight;\n    }\n    if (seg[k].minSum > seg[k << 1].minRightValue\n            + seg[k << 1 | 1].minLeftValue)\n    {\n        seg[k].minSum = seg[k << 1].minRightValue\n                + seg[k << 1 | 1].minLeftValue;\n        seg[k].minSumLeft = seg[k << 1].minLeftBound;\n        seg[k].minSumRight = seg[k << 1 | 1].minRightBound;\n    }\n}\n\nvoid init(int k, int l, int r)\n{\n    seg[k].l = l;\n    seg[k].r = r;\n    if (l == r)\n    {\n        seg[k].sum = seg[k].maxLeftValue = seg[k].maxRightValue\n                = seg[k].minLeftValue = seg[k].minRightValue = seg[k].maxSum\n                        = seg[k].minSum = a[l];\n        seg[k].maxLeftBound = seg[k].minLeftBound = l;\n        seg[k].maxRightBound = seg[k].minRightBound = r;\n        seg[k].maxSumLeft = seg[k].maxSumRight = r;\n        seg[k].minSumLeft = seg[k].minSumRight = r;\n        return;\n    }\n    int mid = l + r >> 1;\n    init(k << 1, l, mid);\n    init(k << 1 | 1, mid + 1, r);\n    update(k);\n}\n\nvoid Up(int k,int pos,int v)\n{\n    if(seg[k].l==pos&&seg[k].r==pos)\n    {\n        seg[k].sum = seg[k].maxLeftValue = seg[k].maxRightValue\n                = seg[k].minLeftValue = seg[k].minRightValue = seg[k].maxSum\n                        = seg[k].minSum = v;\n        return;\n    }\n    int mid=(seg[k].l+seg[k].r)/2;\n    if(pos<=mid)Up(k << 1, pos, v);\n    else Up(k << 1 | 1, pos, v);\n    update(k);\n}\nint findMaxRight(int k, int l, int r, int& ll)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].maxLeftBound;\n        return seg[k].maxRightValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (l > mid)\n    {\n        return findMaxRight(k << 1 | 1, l, r, ll);\n    }\n    else\n    {\n        int l1, l2;\n        int retRight = findMaxRight(k << 1 | 1, mid + 1, r, l1);\n        int retLeft = findMaxRight(k << 1, l, mid, l2) + seg[k << 1 | 1].sum;\n        if (retRight >= retLeft)\n        {\n            ll = l1;\n            return retRight;\n        }\n        else\n        {\n            ll = l2;\n            return retLeft;\n        }\n    }\n}\n\nint findMaxLeft(int k, int l, int r, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        rr = seg[k].maxRightBound;\n        return seg[k].maxLeftValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMaxLeft(k << 1, l, r, rr);\n    }\n    else\n    {\n        int r1, r2;\n        int retLeft = findMaxLeft(k << 1, l, mid, r1);\n        int retRight = seg[k << 1].sum\n                + findMaxLeft(k << 1 | 1, mid + 1, r, r2);\n        if (retLeft >= retRight)\n        {\n            rr = r1;\n            return retLeft;\n        }\n        else\n        {\n            rr = r2;\n            return retRight;\n        }\n    }\n}\n\nint findMax(int k, int l, int r, int& ll, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].maxSumLeft;\n        rr = seg[k].maxSumRight;\n        return seg[k].maxSum;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMax(k << 1, l, r, ll, rr);\n    }\n    else if (l > mid)\n    {\n        return findMax(k << 1 | 1, l, r, ll, rr);\n    }\n    else\n    {\n        int l1, r1, l2, r2, l3, r3, ret;\n        int retLeft = findMax(k << 1, l, mid, l1, r1);\n        int retRight = findMax(k << 1 | 1, mid + 1, r, l2, r2);\n        int retMiddle = findMaxRight(k << 1, l, mid, l3)\n                + findMaxLeft(k << 1 | 1, mid + 1, r, r3);\n        if (retLeft >= retRight)\n        {\n            ll = l1;\n            rr = r1;\n            ret = retLeft;\n        }\n        else\n        {\n            ll = l2;\n            rr = r2;\n            ret = retRight;\n        }\n        if (ret < retMiddle)\n        {\n            ll = l3;\n            rr = r3;\n            ret = retMiddle;\n        }\n        return ret;\n    }\n}\n\nint findMinRight(int k, int l, int r, int& ll)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].minLeftBound;\n        return seg[k].minRightValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (l > mid)\n    {\n        return findMinRight(k << 1 | 1, l, r, ll);\n    }\n    else\n    {\n        int l1, l2;\n        int retRight = findMinRight(k << 1 | 1, mid + 1, r, l1);\n        int retLeft = findMinRight(k << 1, l, mid, l2) + seg[k << 1 | 1].sum;\n        if (retRight <= retLeft)\n        {\n            ll = l1;\n            return retRight;\n        }\n        else\n        {\n            ll = l2;\n            return retLeft;\n        }\n    }\n}\n\nint findMinLeft(int k, int l, int r, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        rr = seg[k].minRightBound;\n        return seg[k].minLeftValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMinLeft(k << 1, l, r, rr);\n    }\n    else\n    {\n        int r1, r2;\n        int retLeft = findMinLeft(k << 1, l, mid, r1);\n        int retRight = seg[k << 1].sum\n                + findMinLeft(k << 1 | 1, mid + 1, r, r2);\n        if (retLeft <= retRight)\n        {\n            rr = r1;\n            return retLeft;\n        }\n        else\n        {\n            rr = r2;\n            return retRight;\n        }\n    }\n}\n\nint findMin(int k, int l, int r, int& ll, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].minSumLeft;\n        rr = seg[k].minSumRight;\n        return seg[k].minSum;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMin(k << 1, l, r, ll, rr);\n    }\n    else if (l > mid)\n    {\n        return findMin(k << 1 | 1, l, r, ll, rr);\n    }\n    else\n    {\n        int l1, r1, l2, r2, l3, r3, ret;\n        int retLeft = findMin(k << 1, l, mid, l1, r1);\n        int retRight = findMin(k << 1 | 1, mid + 1, r, l2, r2);\n        int retMiddle = findMinRight(k << 1, l, mid, l3)\n                + findMinLeft(k << 1 | 1, mid + 1, r, r3);\n        if (retLeft <= retRight)\n        {\n            ll = l1;\n            rr = r1;\n            ret = retLeft;\n        }\n        else\n        {\n            ll = l2;\n            rr = r2;\n            ret = retRight;\n        }\n        if (ret > retMiddle)\n        {\n            ll = l3;\n            rr = r3;\n            ret = retMiddle;\n        }\n        return ret;\n    }\n}\n\n/**\n * heap\n */\n\nstruct Node\n{\n        bool flag;\n        int v, l, r, ll, rr;\n        Node()\n        {\n        }\n        Node(bool flag, int v, int l, int r, int ll, int rr) :\n            flag(flag), v(v), l(l), r(r), ll(ll), rr(rr)\n        {\n        }\n} h[MAX];\nint K;\n\nvoid sink(int k)\n{\n    while ((k << 1) <= K)\n    {\n        int maxv = max(h[k].v, h[k << 1].v);\n        if ((k << 1 | 1) <= K)\n        {\n            maxv = max(maxv, h[k << 1 | 1].v);\n        }\n        if (maxv == h[k].v)\n            break;\n        else if (maxv == h[k << 1].v)\n        {\n            swap(h[k], h[k << 1]);\n            k = k << 1;\n        }\n        else\n        {\n            swap(h[k], h[k << 1 | 1]);\n            k = k << 1 | 1;\n        }\n    }\n}\n\nvoid flow(int k)\n{\n    while (k > 1)\n    {\n        int p = k >> 1;\n        if (h[p].v < h[k].v)\n        {\n            swap(h[p], h[k]);\n            k >>= 1;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n\nNode getMax()\n{\n    swap(h[1], h[K]);\n    K--;\n    sink(1);\n    return h[K + 1];\n}\n\nvoid add(const Node& node)\n{\n    h[++K] = node;\n    flow(K);\n}\n\nint main()\n{\n    int n, m, Q, t;\n    int l, r, L, R;\n    int ret;\n\n\n    while (~scanf(""%d"", &n) )\n    {\n        for (int i = 0; i < n; i++)\n        {\n            scanf(""%d"", &a[i]);\n        }\n        init(1, 0, n - 1);\n        scanf(""%d"",&Q);\n        while(Q--)\n        {\n            int op;\n            scanf(""%d"",&op);\n            if(op==0)\n            {\n                scanf(""%d%d"",&l,&r);l--;\n                Up(1,l,r);\n            }\n            else\n            {\n                scanf(""%d%d%d"",&L,&R,&m);L--;R--;\n                K = 0;\n                ret = 0;\n                t = findMax(1, L, R, l, r);\n                add(\n                    Node(true, t, L, R, l,\n                         r));\n                while (m--)\n                {\n                    Node u = getMax();\n                    if (u.v <= 0)\n                    {\n                        break;\n                    }\n                    ret += u.v;\n                    if (!u.flag)\n                    {\n                        if (u.l != u.ll)\n                        {\n                            t = findMin(1, u.l, u.ll - 1, l, r);\n                            add(Node(false, -t, u.l, u.ll - 1, l, r));\n                        }\n                        if (u.r != u.rr)\n                        {\n                            t = findMin(1, u.rr + 1, u.r, l, r);\n                            add(Node(false, -t, u.rr + 1, u.r, l, r));\n                        }\n                        t = findMax(1, u.ll, u.rr, l, r);\n                        add(Node(true, t, u.ll, u.rr, l, r));\n                    }\n                    else\n                    {\n                        if (u.l != u.ll)\n                        {\n                            t = findMax(1, u.l, u.ll - 1, l, r);\n                            add(Node(true, t, u.l, u.ll - 1, l, r));\n                        }\n                        if (u.r != u.rr)\n                        {\n                            t = findMax(1, u.rr + 1, u.r, l, r);\n                            add(Node(true, t, u.rr + 1, u.r, l, r));\n                        }\n                        t = findMin(1, u.ll, u.rr, l, r);\n                        add(Node(false, -t, u.ll, u.rr, l, r));\n                    }\n                }\n                printf(""%d\\n"", ret);\n            }\n        }\n    }\n\n    return 0;\n}\n']","['data structures', 'flows', 'graphs', 'implementation']",2800
https://codeforces.com//contest/1394/problem/A,A. Boboniu Chats with Du,Have you ever used the chat application QQ Well in a chat group of QQ administrators can muzzle a user for days In Boboniu s chat group there s a person called Du Yi who likes to make fun of Boboniu every day Du will chat in the group for n days On the i th day If Du can speak he ll make fun of Boboniu with fun factor a i But after that he may be muzzled depending on Boboniu s mood Otherwise Du won t do anything Boboniu s mood is a constant m On the i th day If Du can speak and a i m then Boboniu will be angry and muzzle him for d days which means that Du won t be able to speak on the i 1 i 2 cdots min i d n th days Otherwise Boboniu won t do anything The total fun factor is the sum of the fun factors on the days when Du can speak Du asked you to find the maximum total fun factor among all possible permutations of a ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nll n,d,m;\nvi a;\nvl cum;\n\nint main() {\n\tsetIO(); re(n,d,m); d ++;\n\ta.rsz(n); re(a); sort(rall(a));\n\tvi x, y;\n\ttrav(t,a) {\n\t\tif (t > m) x.pb(t);\n\t\telse y.pb(t);\n\t}\n\tcum.rsz(sz(y)+1);\n\tF0R(i,sz(y)) cum[i+1] = cum[i]+y[i];\n\tll sum = 0, ans = 0;\n\tif (!sz(x)) {\n\t\tps(cum[sz(y)]);\n\t\texit(0);\n\t}\n\tFOR(i,1,sz(x)+1) {\n\t\tsum += x[i-1];\n\t\tll lo = d*(i-1)+1, hi = d*i;\n\t\tckmin(hi,n);\n\t\ttie(lo,hi) = mp(n-hi,n-lo);\n\t\tif (lo > sz(y) || hi < 0) continue;\n\t\tckmax(ans,sum+cum[min((int)hi,sz(y))]);\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","['dp', 'greedy', 'sortings', 'two pointers']",1800
https://codeforces.com//contest/830/problem/D,D. Singer House,It is known that passages in Singer house are complex and intertwined Let s define a Singer house as a graph built by the following process take complete binary tree of height and add edges from each vertex to all its successors if they are not yet present Count the number of non empty paths in Singer house which do not pass the same vertex twice Two paths are distinct if the sets or the orders of visited vertices are different Since the answer can be large output it modulo ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mo=1e9+7;\nint f[500][500],C[500][500],I[500],nI[500];\nlong long A[500];\nint n;\nint quick(int k1,int k2){\n\tint k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3=1ll*k3*k1%mo; k2>>=1; k1=1ll*k1*k1%mo;\n\t}\n\treturn k3;\n}\nint main(){\n\tscanf(""%d"",&n);\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tI[0]=1; for (int i=1;i<=n;i++) I[i]=1ll*I[i-1]*i%mo;\n\tfor (int i=0;i<=n;i++) nI[i]=quick(I[i],mo-2);\n\tfor (int i=1;i<=n;i++){\n\t\tf[i][0]=1; memset(A,0x00,sizeof A); A[0]=1;\n\t\tfor (int j=n;j;j--)\n\t\t\tfor (int k=0;k<=j;k++)\n\t\t\t\tif (A[j]<0) A[j]+=1ll*f[i-1][k]*f[i-1][j-k];\n\t\t\t\telse A[j]+=1ll*(f[i-1][k]-mo)*f[i-1][j-k]; \n\t\tfor (int j=1;j<=n;j++) A[j]=1ll*(A[j]%mo+mo)*I[j]%mo;\n\t\tfor (int j=n;j;j--)\n\t\t\tf[i][j]=(1ll*(2*j+1)*A[j]+1ll*j*A[j+1]+1ll*j*A[j-1])%mo*nI[j]%mo;\n\t}\n\tprintf(""%d\\n"",f[n][1]);\n\treturn 0;\n}\n\t\t\t']","['combinatorics', 'dp', 'graphs', 'trees']",2800
https://codeforces.com//contest/240/problem/A,A. Cinema,Overall there are actors in Berland Each actor has a personal identifier an integer from to distinct actors have distinct identifiers Vasya likes to watch Berland movies with Berland actors and he has favorite actors He watched the movie trailers for the next month and wrote the following information for every movie the movie title the number of actors who starred in it and the identifiers of these actors Besides he managed to copy the movie titles and how many actors starred there but he didn t manage to write down the identifiers of some actors Vasya looks at his records and wonders which movies may be his favourite and which ones may not be Once Vasya learns the exact cast of all movies his favorite movies will be determined as follows a movie becomes favorite movie if no other movie from Vasya s list has more favorite actors Help the boy to determine the following for each movie whether it surely will be his favourite movie whether it surely won t be his favourite movie can either be favourite or not ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint m, k;\nbool favo[1000] = { };\nint mi[101], mx[101];\n\nint main() {\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tcin >> m >> k;\n\tfor (int i = 0; i < k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tfavo[x] = true;\n\t}\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint d;\n\t\tcin >> d;\n\t\tint unKnown = 0;\n\t\tint f = 0, nf = 0;\n\t\tfor (int j = 0; j < d; ++j) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif (t == 0) {\n\t\t\t\t++unKnown;\n\t\t\t} else {\n\t\t\t\tif (favo[t])\n\t\t\t\t\t++f;\n\t\t\t\telse\n\t\t\t\t\t++nf;\n\t\t\t}\n\t\t}\n\t\tint rf = k - f, rnf = m - k - nf;\n\t\t//min\n\t\tif (unKnown <= rnf)\n\t\t\tmi[i] = f;\n\t\telse\n\t\t\tmi[i] = unKnown - rnf + f;\n\t\t//max\n\t\tif (unKnown <= rf)\n\t\t\tmx[i] = f + unKnown;\n\t\telse\n\t\t\tmx[i] = f + rf;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\t//check 0\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tif (j != i) {\n\t\t\t\tif (mx[j] > mi[i]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif (ok) {\n\t\t\tputs(""0"");\n\t\t\tcontinue;\n\t\t}\n\t\tok = false;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j != i) {\n\t\t\t\tif (mx[i] < mi[j]) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tputs(""1"");\n\t\t\tcontinue;\n\t\t}\n\t\tputs(""2"");\n\t}\n\treturn 0;\n}\n']",['implementation'],1600
https://codeforces.com//contest/106/problem/C,C. Buns,Lavrenty a baker is going to make several buns with stuffings and sell them Lavrenty has grams of dough as well as different stuffing types The stuffing types are numerated from 1 to Lavrenty knows that he has grams left of the th stuffing It takes exactly grams of stuffing and grams of dough to cook a bun with the th stuffing Such bun can be sold for tugriks Also he can make buns Each of such buns requires grams of dough and it can be sold for tugriks So Lavrenty can cook any number of buns with different stuffings or without it unless he runs out of dough and the stuffings Lavrenty throws away all excess material left after baking Find the maximum number of tugriks Lavrenty can earn ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\nusing namespace std;\n\nconst int MAX=1005, MAXM=13;\n\nint main(){\n    int N,M,a[MAXM],b[MAXM],c[MAXM],d[MAXM], e[MAXM]; \n    a[0]=1,b[0]=0;\n    cin >> N >> M >> c[0] >> d[0];\n    e[0]=MAX;\n    for(int i=1; i<=M; i++){\n\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\te[i]=(int)(a[i]/b[i]);\n    }\n    int dp[MAX];\n    for(int i=0; i<=N; i++) dp[i]=0;\n    dp[0]=0;\n    for(int i=0; i<=M; i++){\n\tfor(int j=N; j>=0; j--){\n\t    for(int k=1; k<=e[i]; k++){\n\t\tif(j-k*c[i]<0) break;\n\t\tdp[j]=max(dp[j],d[i]*k+dp[j-k*c[i]]);\n\t    }\n\t}\n    }\n    int ans=0;\n    for(int i=0; i<=N; i++){\n\tans=max(ans,dp[i]);\n    }\n    cout << ans << endl;\n}\n']",['dp'],1700
https://codeforces.com//contest/909/problem/D,D. Colorful Points,You are given a set of points on a straight line Each point has a color assigned to it For point its neighbors are the points which don t have any other points between them and Each point has at most two neighbors one from the left and one from the right You perform a sequence of operations on this set of points In one operation you delete all points which have a neighbor point of a different color than the point itself Points are deleted simultaneously i e first you decide which points have to be deleted and then delete them After that you can perform the next operation etc If an operation would not delete any points you can t perform it How many operations will you need to perform until the next operation does not have any points to delete ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+5;\n\nint l[maxn],r[maxn],n,ans;\nchar s[maxn];\nvector<int> q,q2;\nbool vis[maxn];\n\ninline bool chk(int i){return (l[i]&&s[l[i]]!=s[i])||(r[i]<=n&&s[r[i]]!=s[i]);}\ninline void clr(int i){r[l[i]]=r[i],l[r[i]]=l[i];}\n\nint main()\n{\n\tscanf(""%s"",s+1),n=strlen(s+1);\n\tr[0]=1,l[n+1]=n,vis[0]=vis[n+1]=1;\n\tfor(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;\n\tfor(int i=1;i<=n;i++)if(chk(i))\n\t\tq.push_back(i),vis[i]=1;\n\twhile(!q.empty())\n\t{\n\t\t++ans;\n\t\tfor(auto i:q)q2.push_back(l[i]),q2.push_back(r[i]),clr(i);\n\t\tq.clear();\n\t\tfor(auto i:q2)if(i&&i<=n&&!vis[i]&&chk(i))\n\t\t\tvis[i]=1,q.push_back(i);\n\t\tq2.clear();\n\t}\n\treturn printf(""%d"",ans),0;\n}']","['data structures', 'greedy', 'implementation']",2100
https://codeforces.com//contest/1717/problem/D,D. Madoka and The Corruption Scheme,Madoka decided to entrust the organization of a major computer game tournament In this tournament matches are held according to the Olympic system In other words there are 2 n participants in the tournament numbered with integers from 1 to 2 n There are n rounds in total in the tournament In the i th round there are 2 n i matches between two players one of whom is right the other is left after which the winners go further along the tournament grid and the losing participants are eliminated from the tournament Herewith the relative order in the next round does not change And the winner of the tournament is the last remaining participant But the smaller the participant s number the more he will pay Madoka if he wins so Madoka wants the participant with the lowest number to win To do this she can arrange the participants in the first round as she likes and also determine for each match who will win the participant on the left or right But Madoka knows that tournament sponsors can change the winner in matches no more than k times That is if the participant on the left won before the change then the participant on the right will win after the change and if the participant on the right won then the participant on the left will win after the change Print the minimum possible number of the winner in the tournament which Madoka can get regardless of changes in sponsors But since the answer can be very large output it modulo 10 9 7 Note that we need to minimize the answer and only then take it modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst int P = 1e9 + 7;\ntemplate<class T>\ninline T power(T a, i64 b) {\n\tT res = 1;\n\tfor (; b; b >>= 1, a *= a)\n\t\tif (b & 1) res *= a;\n\treturn res;\n}\ninline int norm(int x) {\n\tif (x < 0) x += P;\n\tif (x >= P) x -= P;\n\treturn x;\n}\nstruct Z {\n\tint x;\n\tZ(int _x = 0) : x(norm(_x)) {}\n\tinline Z operator-() const {\n\t\tif (!x) return 0;\n\t\treturn Z(P - x);\n\t}\n\tinline Z &operator+=(const Z &rhs) {\n\t\tx += rhs.x;\n\t\tif (x >= P) x -= P;\n\t\treturn *this;\n\t}\n\tinline Z &operator-=(const Z &rhs) {\n\t\tx -= rhs.x;\n\t\tif (x < 0) x += P;\n\t\treturn *this;\n\t}\n\tinline Z &operator*=(const Z &rhs) {\n\t\tx = 1ull * x * rhs.x % P;\n\t\treturn *this;\n\t}\n\tinline Z inv() const {\n\t\treturn power(*this, P - 2);\n\t}\n\tinline Z &operator/=(const Z &rhs) {\n\t\t*this *= rhs.inv();\n\t\treturn *this;\n\t}\n\tinline friend Z operator+(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res += rhs, res;\n\t}\n\tinline friend Z operator-(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res -= rhs, res;\n\t}\n\tinline friend Z operator*(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res *= rhs, res;\n\t}\n\tinline friend Z operator/(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res /= rhs, res;\n\t}\n};\nconst int N = 100005;\nZ fac[N], ifac[N], pw[N];\nvoid init(int n) {\n\tfac[0] = pw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tpw[i] = pw[i - 1] * 2;\n\t}\n\tifac[n] = fac[n].inv();\n\tfor (int i = n; i; --i) {\n\t\tifac[i - 1] = ifac[i] * i;\n\t}\n}\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tinit(n);\n\tif (k >= n) {\n\t\tcout << pw[n].x << ""\\n"";\n\t\treturn 0;\n\t}\n\tZ ans = 0;\n\tfor (int i = 0; i <= k; ++i) {\n\t\tans += fac[n] * ifac[i] * ifac[n - i];\n\t}\n\tcout << ans.x << ""\\n"";\n    return 0;\n}']","['combinatorics', 'constructive algorithms', 'greedy', 'math']",1900
https://codeforces.com//contest/1867/problem/F,F. Most Different Tree,Given a tree with n vertices rooted at vertex 1 denote it as G Also denote P G as the multiset of subtrees of all vertices in tree G You need to find a tree G of size n rooted at vertex 1 such that the number of subtrees in P G that are isomorphic to any subtree in P G is minimized A subtree of vertex v is a graph that contains all vertices for which vertex v lies on the path from the root of the tree to itself as well as all edges between these vertices Two rooted trees are considered isomorphic if it is possible to relabel the vertices of one of them so that it becomes equal to the other with the root of the first tree receiving the number of the root of the second tree ,"[""#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define pb push_back\nusing namespace std;\nusing pii=pair <int,int>;\nusing tii=pair <pii,int>;\nint h(int n){\n    return n*n*n*1234567+412269;\n}\nint f(int n){\n    return h(n&((1ll<<31LL)-1))+h(n>>31LL);\n}\nint N;\nvector <int> g[1000010];\nint hsh[1000010],sz[1000010];\nvoid dfs(int cur,int prv){\n    sz[cur]=1;\n    hsh[cur]=1;\n    for (int i:g[cur]){\n        if (i==prv) continue;\n        dfs(i,cur);\n        sz[cur]+=sz[i];\n        hsh[cur]+=f(h(hsh[i]));\n    }\n}\nvector <int> bruh[1000010];\nint bruh_hsh[1000010];\nvoid dfs2(int cur){\n    bruh_hsh[cur]=1;\n    for (int i:bruh[cur]){\n        dfs2(i);\n        bruh_hsh[cur]+=f(h(bruh_hsh[i]));\n    }\n}\nunordered_map <int,int> mp[1000010];\nvoid exhaust(int cur,int sz,int prv_pa){\n    if (cur>sz){\n        //try bruh it\n        dfs2(1);\n        if (mp[sz].count(bruh_hsh[1])) return;\n        for (int j=2; j<=N-sz+1; j++) cout<<j-1<<' '<<j<<'\\n';\n        for (int j=1; j<=sz; j++){\n            for (int k:bruh[j]) cout<<j+N-sz<<' '<<k+N-sz<<'\\n';\n        }\n        exit(0);\n    }\n    for (int i=prv_pa; i<cur; i++){\n        bruh[i].pb(cur);\n        exhaust(cur+1,sz,i);\n        bruh[i].pop_back();\n    }\n}\nvoid solve(){\n    int n;\n    cin>>n;\n    N=n;\n    for (int i=1; i<n; i++){\n        int u,v; cin>>u>>v;\n        g[u].pb(v); g[v].pb(u);\n    }\n    int fac[20];\n    fac[0]=1;\n    for (int i=1; i<20; i++) fac[i]=fac[i-1]*i;\n    dfs(1,0);\n    for (int i=1; i<=n; i++) mp[sz[i]][hsh[i]]=1;\n    int cnt=0;\n    for (int i=2; ; i++){\n        exhaust(2,i,1);\n        if (i==n){\n            for (int j=1; j<n; j++) cout<<j<<' '<<j+1<<'\\n';\n            return;\n        }\n    }\n}\nsigned main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint t=1;\n\t//cin>>t;\n\twhile (t--) solve();\n}""]","['brute force', 'constructive algorithms', 'dfs and similar', 'greedy', 'hashing']",2700
https://codeforces.com//contest/1873/problem/A,A. Short Sort,There are three cards with letters texttt a texttt b texttt c placed in a row in some order You can do the following operation Pick two cards and swap them Is it possible that the row becomes texttt abc after the operation Output if it is possible and otherwise ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\n\nvoid solve(){\n    str s; cin >> s;\n    int ne = 0;\n    for(int i = 0; i < len(s); ++i)\n        ne += (s[i] - \'a\') != i;\n    fa(ne == 2 or ne == 0);\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']","['brute force', 'implementation']",800
https://codeforces.com//contest/1851/problem/B,B. Parity Sort,You have an array of integers a of length n You can apply the following operation to the given array Swap two elements a i and a j such that i neq j a i and a j are either even or odd Determine whether it is possible to sort the array in non decreasing order by performing the operation any number of times possibly zero For example let a 7 10 1 3 2 Then we can perform 3 operations to sort the array Swap a 3 1 and a 1 7 since 1 and 7 are odd We get a 1 10 7 3 2 Swap a 2 10 and a 5 2 since 10 and 2 are even We get a 1 2 7 3 10 Swap a 4 3 and a 3 7 since 3 and 7 are odd We get a 1 2 3 7 10 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(""Ofast"",""inline"",""-ffast-math"")\n#pragma GCC target(""avx,sse2,sse3,sse4,mmx"")\n\n#define int long long\nint n,a[200001];\nconst int MOD=998244353;\nvoid Delta() {\n   vector<int> oddi,eveni,odd,even;\n   cin >> n;\n   for(int i=1;i<=n;++i) {\n      cin >> a[i];\n      if(a[i]%2==0) {\n         oddi.push_back(i);\n         odd.push_back(a[i]);\n      } else {\n         eveni.push_back(i);\n         even.push_back(a[i]);\n      }\n   }\n   sort(odd.begin(),odd.end());\n   sort(even.begin(),even.end());\n   for(int i=0;i<(int)oddi.size();++i)\n      a[oddi[i]]=odd[i];\n   for(int i=0;i<(int)eveni.size();++i)\n      a[eveni[i]]=even[i];\n   cout << (is_sorted(a+1,a+1+n)?""YES"":""NO"") << endl;\n}\nsigned main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);cout.tie(0);\n   int T;cin >> T;\n   while(T--) Delta();\n}']","['greedy', 'sortings', 'two pointers']",800
https://codeforces.com//contest/1283/problem/B,B. Candies Division,Santa has n candies and he wants to gift them to k kids He wants to divide as many candies as possible between all k kids Santa can t divide one candy into parts but he is allowed to not use some candies at all Suppose the kid who recieves the minimum number of candies has a candies and the kid who recieves the maximum number of candies has b candies Then Santa will be if the both conditions are met at the same time b a le 1 it means b a or b a 1 the number of kids who has a 1 candies does not exceed lfloor frac k 2 rfloor less than or equal to lfloor frac k 2 rfloor lfloor frac k 2 rfloor is k divided by 2 and rounded to the nearest integer For example if k 5 then lfloor frac k 2 rfloor lfloor frac 5 2 rfloor 2 Your task is to find the maximum number of candies Santa can give to kids so that he will be You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nint t, n, k;\n\nint main()\n{\n\tscanf(""%d"",&t);\n\n\tfor(int p = 0 ; p < t ; p++)\n\t{\n\t\tscanf(""%d %d"",&n,&k);\n\n\t\tint ans = (n/k)*k;\n\n\t\tint remain = n - ans;\n\t\tremain = min( remain , k/2 );\n\n\t\tprintf(""%d\\n"",ans + remain);\n\t}\n}']",['math'],900
https://codeforces.com//contest/676/problem/B,B. Pyramid of Glasses,Mary has just graduated from one well known University and is now attending celebration party Students like to dream of a beautiful life so they used champagne glasses to construct a small pyramid The height of the pyramid is The top level consists of only glass that stands on glasses on the second level counting from the top then glasses on the third level and so on The bottom level consists of glasses Vlad has seen in the movies many times how the champagne beautifully flows from top levels to bottom ones filling all the glasses simultaneously So he took a bottle and started to pour it in the glass located at the top of the pyramid Each second Vlad pours to the top glass the amount of champagne equal to the size of exactly one glass If the glass is already full but there is some champagne flowing in it then it pours over the edge of the glass and is equally distributed over two glasses standing under If the overflowed glass is at the bottom level then the champagne pours on the table For the purpose of this problem we consider that champagne is distributed among pyramid glasses immediately Vlad is interested in the number of completely full glasses if he stops pouring champagne in seconds Pictures below illustrate the pyramid consisting of three levels ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ndouble M[15][15];\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,t;\n\tcin>>n>>t;\n\tdouble x;\n\n\twhile(t--) {\n\t\tM[1][1] += 1;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=i;++j) {\n\t\t\t\tif(M[i][j] > 1) {\n\t\t\t\t\tx = M[i][j] - 1;\n\t\t\t\t\tM[i][j] = 1;\n\t\t\t\t\tM[i+1][j] += x/2;\n\t\t\t\t\tM[i+1][j+1] += x/2;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tx = 0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tif(M[i][j] == 1)\n\t\t\t\t++x;\n\n\tcout<<x<<""\\n"";\n\n\treturn 0;\n}\n']","['implementation', 'math', 'math']",1500
https://codeforces.com//contest/624/problem/B,B. Making a String,You are given an alphabet consisting of letters your task is to make a string of the maximum possible length so that the following conditions are satisfied the th letter occurs in the string no more than times the number of occurrences of each letter in the string must be for all the letters that occurred in the string at least once ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\n\nint n, a[30];\nint main()  {\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++)scanf(""%d"",&a[i]);\n\tsort(a+1,a+1+n);\n\tlong long ans=a[n];\n\tfor (int i=n-1;i>0;i --){\n\t\twhile (a[i] != 0 && a[i] >= a[i + 1]) {\n\t\t\ta[i] --;\n\t\t}\n\t\tans+=a[i];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}']","['greedy', 'sortings']",1100
https://codeforces.com//contest/1551/problem/C,C. Interesting Story,Stephen Queen wants to write a story He is a very unusual writer he uses only letters and To compose a story Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet He wants to select the number of to make an story Let a story be a sequence of words that are not necessarily different A story is called if there exists a letter which occurs among all words of the story more times than all other letters together For example the story consisting of three words is interesting the letter occurs 5 times all other letters occur 4 times in total But the story consisting of two words is not no such letter that it occurs more than all other letters in total You are given a sequence of n words consisting of letters and Your task is to choose the maximum number of them to make an interesting story If there s no way to make a non empty story output 0 ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n;\n    cin >> n;\n    int ans = 0;\n    vector<string> a(n);\n    vector<vector<int>> cnt(n,vector<int>(5,0));\n    for(int i=0;i<n;++i)\n    {\n        cin >> a[i];\n        for(auto &j:a[i])\n            ++cnt[i][j - \'a\'];\n    }\n    for(int i=0;i<5;++i)\n    {\n        vector<ll> x;\n        for(int j=0;j<n;++j)\n            x.push_back(cnt[j][i] - (sz(a[j]) - cnt[j][i]));\n        sort(all(x),greater<ll>());\n        ll cur = 0;\n        for(int j=0;j<n;++j)\n        {\n            cur += x[j];\n            if(cur > 0)\n                amax(ans,j+1);\n        }\n    }\n    cout << ans << ""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","['greedy', 'sortings', 'strings']",1500
https://codeforces.com//contest/1924/problem/A,A. Did We Get Everything Covered ,You are given two integers n and k along with a string s Your task is to check whether all possible strings of length n that can be formed using the first k lowercase English alphabets occur as a subsequence of s If the answer is you also need to print a string of length n that can be formed using the first k lowercase English alphabets which does not occur as a subsequence of s If there are multiple answers you may print any of them A string a is called a subsequence of another string b if a can be obtained by deleting some possibly zero characters from b without changing the order of the remaining characters ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k, m;\n    std::cin >> n >> k >> m;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::string t;\n    int j = 0;\n    bool ok = true;\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        std::vector<int> occ(k);\n        while (cnt < k && j < m) {\n            cnt += !occ[s[j] - \'a\'];\n            occ[s[j] - \'a\'] = 1;\n            j += 1;\n        }\n        if (cnt < k) {\n            ok = false;\n            for (int x = 0; x < k; x++) {\n                if (!occ[x]) {\n                    t += \'a\' + x;\n                    break;\n                }\n            }\n        } else {\n            t += s[j - 1];\n        }\n    }\n    \n    if (ok) {\n        std::cout << ""YES\\n"";\n    } else {\n        std::cout << ""NO\\n"";\n        std::cout << t << ""\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'dp', 'greedy', 'shortest paths', 'strings']",1500
https://codeforces.com//contest/864/problem/D,D. Make a Permutation ,Ivan has an array consisting of elements Each of the elements is an integer from to Recently Ivan learned about permutations and their lexicographical order Now he wants to change replace number of elements in his array in such a way that his array becomes a i e each of the integers from to was encountered in his array exactly once If there are multiple ways to do it he wants to find the permutation among them Thus minimizing the number of changes has the first priority lexicographical minimizing has the second priority In order to determine which of the two permutations is lexicographically smaller we compare their first elements If they are equal compare the second and so on If we have two permutations and then is lexicographically smaller if where is the first index in which the permutations and differ Determine the array Ivan will obtain after performing all the changes ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint n;\nint a[200010];\nint b[200010];\nint c[200010];\nint d[200010];\nint e[200010];\nint ans[200010];\nint main()\n{\n\tmemset(c,0,sizeof c);\n\tmemset(e,0,sizeof e);\n\tscanf(""%d"",&n);\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d"",&a[i]);\n\t\tb[i]=a[i];\n\t\tc[a[i]]++;\n\t}\n\tsort(b+1,b+n+1);\n\tint m=unique(b+1,b+n+1)-b-1;\n\tprintf(""%d\\n"",n-m);\n\tint j=1;\n\tint k=0;\n\tfor(i=1;i<=n;i++)\n\t\tif(!c[i])\n\t\t\td[++k]=i;\n\tfor(i=1;i<=n;i++)\n\t\tif(!e[a[i]])\n\t\t{\n\t\t\tif(c[a[i]]==1)\n\t\t\t{\n\t\t\t\tc[a[i]]--;\n\t\t\t\te[a[i]]=1;\n\t\t\t\tans[i]=a[i];\n\t\t\t}\n\t\t\telse if(d[j]<a[i])\n\t\t\t{\n\t\t\t\tans[i]=d[j++];\n\t\t\t\tc[a[i]]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\te[a[i]]=1;\n\t\t\t\tans[i]=a[i];\n\t\t\t\tc[a[i]]--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i]=d[j++];\n\t\t\tc[a[i]]--;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tprintf(""%d "",ans[i]);\n\treturn 0;\n}']","['greedy', 'implementation', 'math']",1500
https://codeforces.com//contest/1873/problem/B,B. Good Kid,Slavic is preparing a present for a friend s birthday He has an array a of n digits and the present will be the product of all these digits Because Slavic is a good kid who wants to make the biggest product possible he wants to add 1 to exactly one of his digits What is the maximum product Slavic can make ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\n\nvoid solve(){\n    int n; cin >> n;\n    vi a(n); read(a);\n    int mn = *min_element(all(a));\n    for(auto &i: a){\n        if(i == mn){\n            i++;\n            break;\n        }\n    }\n    int ans = 1;\n    for(auto &i: a)ans *= i;\n    cout << ans << ""\\n"";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']","['brute force', 'greedy', 'math']",800
https://codeforces.com//contest/1705/problem/E,E. Mark and Professor Koro,After watching a certain anime before going to sleep Mark dreams of standing in an old classroom with a blackboard that has a sequence of n positive integers a 1 a 2 dots a n on it Then professor Koro comes in He can perform the following operation select an integer x that appears at least 2 times on the board erase those 2 appearances and write x 1 on the board Professor Koro then asks Mark the question what is the maximum possible number that could appear on the board after some operations Mark quickly solves this question but he is still slower than professor Koro Thus professor Koro decides to give Mark additional challenges He will update the initial sequence of integers q times Each time he will choose positive integers k and l then change a k to l After each update he will ask Mark the same question again Help Mark answer these questions faster than Professor Koro Note that the updates are persistent Changes made to the sequence a will apply when processing future updates ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define N 220020\ntypedef long long ll;\nint n,Q,a[N];\nclass Segment_Tree{\n\tint Len;\n\tstruct node{\n\t\tint sum,cov,len;\n\t\tnode(){cov=-1;}\n\t\tvoid Cover(int d){\n\t\t\tcov=d;\n\t\t\tsum=len*d;\n\t\t}\n\t}t[N<<2];\n\t#define ls u<<1\n\t#define rs u<<1|1\n\tinline void update(int u){\n\t\tt[u].sum=t[ls].sum+t[rs].sum;\n\t}\n\tinline void pushdown(int u){\n\t\tif(~t[u].cov){\n\t\t\tt[ls].Cover(t[u].cov);\n\t\t\tt[rs].Cover(t[u].cov);\n\t\t\tt[u].cov=-1;\n\t\t}\n\t}\n\tvoid build(int u,int L,int R){\n\t\tt[u].len=R-L+1;\n\t\tif(L==R)return;\n\t\tint mid=(L+R)>>1;\n\t\tbuild(ls,L,mid);\n\t\tbuild(rs,mid+1,R);\n\t}\n\tvoid _cover(int u,int L,int R,int l,int r,int d){\n\t\tif(L>=l&&R<=r){\n\t\t\tt[u].Cover(d);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(l<=mid)_cover(ls,L,mid,l,r,d);\n\t\tif(r>mid)_cover(rs,mid+1,R,l,r,d);\n\t\tupdate(u);\n\t}\n\tvector<tuple<int,int,int> > a;\n\tvoid _get(int u,int L,int R,int l,int r){\n\t\tif(L>=l&&R<=r){\n\t\t\ta.emplace_back(u,L,R);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(l<=mid)_get(ls,L,mid,l,r);\n\t\tif(r>mid)_get(rs,mid+1,R,l,r);\n\t}\n\tint _find_0(int u,int L,int R){\n\t\tif(t[u].sum==t[u].len)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(t[ls].len!=t[ls].sum)return _find_0(ls,L,mid);\n\t\treturn _find_0(rs,mid+1,R);\n\t}\n\tint _find_1(int u,int L,int R){\n\t\tif(0==t[u].sum)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(0!=t[ls].sum)return _find_1(ls,L,mid);\n\t\treturn _find_1(rs,mid+1,R);\n\t}\n\tint _gg(int u,int L,int R){\n\t\tif(0==t[u].len)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(0!=t[rs].sum)return _gg(rs,mid+1,R);\n\t\treturn _gg(ls,L,mid);\n\t}\npublic:\n\tvoid init(int _n){\n\t\tLen=_n;\n\t\tbuild(1,1,Len);\n\t}\n\tint Find_0(int lim){\n\t\ta.clear();\n\t\t_get(1,1,Len,lim,Len);\n\t\tfor(auto [u,L,R]:a){\n\t\t\tint z=_find_0(u,L,R);\n\t\t\tif(~z)return z;\n\t\t}\n\t\tassert(false);\n\t}\n\tint Find_1(int lim){\n\t\ta.clear();\n\t\t_get(1,1,Len,lim,Len);\n\t\tfor(auto [u,L,R]:a){\n\t\t\tint z=_find_1(u,L,R);\n\t\t\tif(~z)return z;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid Add(int x){\n\t\tint y=Find_0(x);\n\t\tif(y>x)_cover(1,1,Len,x,y-1,0);\n\t\t_cover(1,1,Len,y,y,1);\n\t}\n\tvoid Del(int x){\n\t\tint y=Find_1(x);\n\t\tif(y>x)_cover(1,1,Len,x,y-1,1);\n\t\t_cover(1,1,Len,y,y,0);\n\t}\n\tint get_ans(){\n\t\treturn _gg(1,1,Len);\n\t}\n}T;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tT.init(200200);\n\tcin>>n>>Q;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tT.Add(a[i]);\n\t}\n\twhile(Q--){\n\t\tint x;\n\t\tcin>>x;\n\t\tT.Del(a[x]);\n\t\tcin>>a[x];\n\t\tT.Add(a[x]);\n\t\tcout<<T.get_ans()<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n""]","['binary search', 'bitmasks', 'brute force', 'combinatorics', 'data structures', 'greedy']",2300
https://codeforces.com//contest/66/problem/D,D. Petya and His Friends,Little Petya has a birthday soon Due this wonderful event Petya s friends decided to give him sweets The total number of Petya s friends equals to Let us remind you the definition of the greatest common divisor where represents such a maximal positive number that each is evenly divisible by At that we assume that all s are greater than zero Knowing that Petya is keen on programming his friends has agreed beforehand that the st friend gives sweets the nd one gives sweets the th one gives sweets At the same time for any and they want the not to be equal to However they also want the following condition to be satisfied One more all the should be distinct Help the friends to choose the suitable numbers ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""d""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nconst int BASE = 10000;\n\nstruct Long\n{\n    int size, x[1005];\n};\n\nint N;\n\nvoid Load ()\n{           \n    cin >> N;\n}\n\nvoid Mul (Long &a, int b)\n{\n    int cur = 0;\n\n    for (int i = 0;i < a.size;i++)\n    {\n        a.x[i] = a.x[i] * b + cur;\n        cur = a.x[i] / BASE;\n        a.x[i] %= BASE;\n    }\n    if (cur > 0)\n        a.x[a.size++] = cur;\n}\n\nvoid print (Long &a)\n{\n    printf (""%d"", a.x[a.size-1]);\n\n    for (int i = a.size - 2;i >= 0;i--)\n        printf (""%04d"", a.x[i]);\n    printf (""\\n"");\n}\n\nLong a;\n\nvoid Solve ()\n{\n    if (N == 2)\n    {\n        cout << ""-1"";\n        return;\n    }\n    cout << ""10\\n"";\n\n    a.x[0] = 6;\n    a.size = 1;\n    for (int i = 1;i < N - 1;i++)\n    {\n        print (a);\n        Mul (a, 2);\n    }\n    cout << ""15\\n"";\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","['constructive algorithms', 'math', 'number theory']",1700
https://codeforces.com//contest/1909/problem/H,H. Parallel Swaps Sort,You are given a permutation p 1 p 2 dots p n of 1 2 dots n You can perform the following operation some possibly 0 times choose a subarray l r of even length swap a l a l 1 swap a l 2 a l 3 if l 3 leq r dots swap a r 1 a r Sort the permutation in at most 10 6 operations You do not need to minimize the number of operations ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\npair<vc<pi>,vc<pi>> getswaps(vi p){\n\tint n=si(p);\n\tvc<pi> x,y;\n\tvc<bool> used(n);\n\trep(root,n)if(!used[root]){\n\t\tvi ls;\n\t\tfor(int i=root;!used[i];i=p[i]){\n\t\t\tused[i]=true;\n\t\t\tls.pb(i);\n\t\t}\n\t\tint s=si(ls);\n\t\trep(i,s/2){\n\t\t\tx.eb(ls[i],ls[s-1-i]);\n\t\t}\n\t\trep(i,(s-1)/2){\n\t\t\ty.eb(ls[i+1],ls[s-1-i]);\n\t\t}\n\t}\n\treturn mp(x,y);\n}\n\nvc<pi> fast(vi p,bool chk){\n\tint n=si(p);\n\t\n\tvc<pi> ans;\n\tauto work=[&](int l,int r){\n\t\tassert((r-l)%2==0);\n\t\tif(l==r)return;\n\t\tans.eb(l,r);\n\t\tif(chk){\n\t\t\tfor(int i=l;i<r;i+=2){\n\t\t\t\tswap(p[i],p[i+1]);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvc<pi> flip;\n\tif(n%2==0){\n\t\trep(i,n){\n\t\t\tif(i%2==0){\n\t\t\t\tflip.eb(0,n);\n\t\t\t}else{\n\t\t\t\tflip.eb(1,n-1);\n\t\t\t}\n\t\t}\n\t}else{\n\t\trep(i,n){\n\t\t\tif(i%2==0){\n\t\t\t\tflip.eb(0,n-1);\n\t\t\t}else{\n\t\t\t\tflip.eb(1,n);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto adv=[&](int&a,int d){\n\t\tif(a%2==0){\n\t\t\ta+=d;\n\t\t\tif(a>=n){\n\t\t\t\ta=n-1-(a-n);\n\t\t\t}\n\t\t}else{\n\t\t\ta-=d;\n\t\t\tif(a<0){\n\t\t\t\ta=-1-a;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tauto getadj=[&](int a,int b)->pi{\n\t\tassert(a!=b);\n\t\tif(a>b)swap(a,b);\n\t\t//dmp2(a,b);\n\t\tint need=0;\n\t\tif(a%2==1)chmax(need,a+1);\n\t\tif(b%2==0)chmax(need,n-b);\n\t\t//dmp(need);\n\t\tadv(a,need);\n\t\tadv(b,need);\n\t\t//dmp2(a,b);\n\t\tassert((a+need)%2==0);\n\t\tassert((b+need)%2==1);\n\t\tint d=(b-a)/2;\n\t\tassert(a+d+1==b-d);\n\t\treturn pi(need+d,a+d);\n\t};\n\t\n\tauto [x,y]=getswaps(p);\n\t//dmp(p);\n\t//dmp(x);\n\t//dmp(y);\n\tvvc<pi> buf(2*n);\n\t\n\tfor(auto [a,b]:x){\n\t\tauto [t,i]=getadj(a,b);\n\t\tdmp2(t,i,i+2);\n\t\tbuf[t].eb(i,i+2);\n\t}\n\tfor(auto [a,b]:y){\n\t\tauto [t,i]=getadj(n-1-a,n-1-b);\n\t\tbuf[n+t].eb(i,i+2);\n\t}\n\t\n\trep(i,2*n){\n\t\tfor(auto [l,r]:buf[i])work(l,r);\n\t\tauto [l,r]=flip[i%n];\n\t\twork(l,r);\n\t}\n\t\n\tif(chk){\n\t\tassert(p==vid(n));\n\t}\n\t\n\treturn ans;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\t\n\tvi p=readvi(n,-1);\n\t\n\tauto ans=fast(p,false);\n\t\n\tprint(si(ans));\n\tfor(auto [l,r]:ans){\n\t\tprint(l+1,r);\n\t}\n}\n\ntemplate<class F> void permrep(int n,F f){\n\tvi p(n);iota(all(p),0);\n\tdo{\n\t\tf(p);\n\t}while(next_permutation(all(p)));\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(0){\n\t\trng(n,2,8+1){\n\t\t\tpermrep(n,[&](vi p){\n\t\t\t\tfast(p,true);\n\t\t\t});\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['constructive algorithms', 'data structures']",3500
https://codeforces.com//contest/314/problem/A,A. Sereja and Contest,During the last Sereja s Codesecrof round the server crashed many times so the round was decided to be made unrated for some participants Let s assume that people took part in the contest Let s assume that the participant who got the first place has rating the second place participant has rating the th place participant has rating Then changing the rating on the Codesecrof site is calculated by the formula After the round was over the Codesecrof management published the participants results table They decided that if for a participant then the round can be considered unrated for him But imagine the management s surprise when they found out that the participants rating table is dynamic In other words when some participant is removed from the rating he is removed from the results table and the rating is recalculated according to the new table And of course all applications for exclusion from the rating are considered in view of the current table We know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank the rank with the minimum number for who We also know that the applications for exclusion from rating were submitted by all participants Now Sereja wonders what is the number of participants to be excluded from the contest rating and the numbers of the participants in the original table in the order of their exclusion from the rating Pay attention to the analysis of the first test case for a better understanding of the statement ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<int, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\n#define pow10 asdpow10\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nuint gcd(uint a,uint b){return a?gcd(b%a,a):b;}\n\n\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\t\n\tios_base::sync_with_stdio(false);\n\t\n\tint n;\n\tlng k;\n\tcin>>n>>k;\n\tint j=1;\n\tlng s=0;\n\tint m=n;\n\tforn(i,n){\n\t\tlng a;\n\t\tcin>>a;\n\t\tlng d=s-(m-j)*a*(j-1);\n\t\t//cerr<<j<<\' \'<<d<<\' \'<<s<<endl;\n\t\tif(d<k){\n\t\t\tcout<<i+1<<\'\\n\';\n\t\t\t--m;\n\t\t}else{\n\t\t\ts+=a*(j-1);\n\t\t\t++j;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n']",['implementation'],1600
https://codeforces.com//contest/1864/problem/C,C. Divisor Chain,You are given an integer x Your task is to reduce x to 1 To do that you can do the following operation select a divisor d of x then change x to x d i e reduce x by d We say that d is a divisor of x if d is an positive integer and there exists an integer q such that x d cdot q There is an additional constraint you select the same value of d For example for x 5 the following scheme is because 1 is selected more than twice 5 xrightarrow 1 4 xrightarrow 1 3 xrightarrow 1 2 xrightarrow 1 1 The following scheme is however a valid one 5 xrightarrow 1 4 xrightarrow 2 2 xrightarrow 1 1 Output any scheme which reduces x to 1 with at most 1000 operations It can be proved that such a scheme always exists ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvi pom;\nvi wyn;\n\nvoid solve(int n, int x)\n{\n\tif (n==1)\n\t\treturn;\n\t//~ debug() << n << "" "" << x;\n\tif (n&1)\n\t\tpom.push_back(x);\n\twyn.push_back(x);\n\tsolve(n/2, x*2);\n}\n\nvoid test()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\twyn.clear();\n\tpom.clear();\n\t\n\tsolve(n, 1);\n\t\n\t//~ reverse(pom.begin(), pom.end());\n\treverse(wyn.begin(), wyn.end());\n\tfor (int i : wyn)\n\t\tpom.push_back(i);\n\twyn=pom;\n\t//~ debug() << imie(wyn);\n\t\n\tprintf(""%d\\n"", (int)wyn.size()+1);\n\tprintf(""%d"", n);\n\tfor (int i : wyn)\n\t{\n\t\tn-=i;\n\t\tprintf("" %d"", n);\n\t}\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['bitmasks', 'constructive algorithms', 'math', 'number theory']",1300
https://codeforces.com//contest/193/problem/E,E. Fibonacci Number,John Doe has a list of all Fibonacci numbers modulo This list is infinite it starts with numbers and Each number in the list apart from the first two is a sum of previous two modulo That is John s list is made from the Fibonacci numbers list by replacing each number there by the remainder when divided by John got interested in number and now wants to find its first occurrence in the list given above Help John and find the number of the first occurence of number in the list or otherwise state that number does not occur in the list The numeration in John s list starts from zero There the th position is the number the st position is the number the nd position is the number the rd position is the number the th position is the number and so on Thus the beginning of the list looks like this ,"['#include <iostream>\n\nusing namespace std;\n\nconst long long M = 10000000000000LL;\nconst int md = 100000000;\nconst int per = md*3/2;\nconst int nd = 30000000;\n\nlong long f[nd+10];\nlong long xa[500010], xb[500010], xc[500010];\nlong long x, ans;\nint q, a, b, it, c, i, itt;\n\ninline long long mul(long long a, long long b) {\n  long long a1 = a/10000000, a2 = a-a1*10000000;\n  long long b1 = b/10000000, b2 = b-b1*10000000;\n  long long res = a2*b2;\n  res += (a1*b2+b1*a2) % 1000000 * 10000000;\n  return res % M;\n}\n\nvoid check(long long z) {\n  if (ans != -1 && z >= ans) return;\n  long long q = z/nd, w = z % nd, res;\n  if (w == 0) res = xb[q];\n  else res = (mul(xb[q],f[w-1])+mul(xc[q],f[w])) % M;\n  if (res == x) ans = z;\n}\n\nlong long aa, bb, cc;\n\nvoid check2(long long z) {\n//  if (ans != -1 && z >= ans) return;\n  long long a = 1, b = 0, c = 1, na, nb, u;\n  long long step = 1LL << 50;\n  while (step > z) step >>= 1;\n  while (step) {\n    u = mul(b,b);\n    na = mul(a,a)+u;\n    if (na >= M) na -= M;\n    b = mul(b,a+c);\n    c = u+mul(c,c);\n    if (c >= M) c -= M;\n    a = na;\n    if (step & z) {\n      na = b;\n      nb = a+b;\n      if (nb >= M) nb -= M;\n      c = b+c;\n      if (c >= M) c -= M;\n      a = na; b = nb;\n    }\n    step >>= 1;\n  }\n  aa = a; bb = b; cc = c;\n}\n\nint main() {\n  f[0] = 0; f[1] = 1;\n  for (i=2;i<nd;i++) {\n    f[i] = f[i-1]+f[i-2];\n    if (f[i] >= M) f[i] -= M;\n  }\n  check2(nd);\n  xa[0] = 1; xb[0] = 0; xc[0] = 1;\n  xa[1] = aa; xb[1] = bb; xc[1] = cc;\n  for (i=2;i<(M*3/2)/nd;i++) {\n    xa[i] = mul(xa[i-1],xa[1])+mul(xb[i-1],xb[1]);\n    if (xa[i] >= M) xa[i] -= M;\n    xb[i] = mul(xa[i-1],xb[1])+mul(xb[i-1],xc[1]);\n    if (xb[i] >= M) xb[i] -= M;\n    xc[i] = mul(xb[i-1],xb[1])+mul(xc[i-1],xc[1]);\n    if (xc[i] >= M) xc[i] -= M;\n  }\n  cin >> x;\n  q = x % md;\n  a = 0; b = 1; it = 0;\n  ans = -1;\n  do {\n    if (a == q)\n      for (i=0;i<100000;i++) check((long long)i*per+it);\n    c = a+b;\n    if (c >= md) c -= md;\n    a = b; b = c;\n    it++;\n  } while (a != 0 || b != 1);\n  cout << ans << endl;\n  return 0;\n}\n']","['brute force', 'math', 'matrices']",2900
https://codeforces.com//contest/1553/problem/D,D. Backspace,You are given two strings s and t both consisting of lowercase English letters You are going to type the string s character by character from the first character to the last one When typing a character instead of pressing the button corresponding to it you can press the Backspace button It deletes the last character you have typed among those that aren t deleted yet or does nothing if there are no characters in the current string For example if s is and you press Backspace instead of typing the first and the fourth characters you will get the string the first press of Backspace deletes no character and the second press deletes the character Another example if s is and you press Backspace instead of the last two letters then the resulting text is Your task is to determine whether you can obtain the string t if you type the string s and press Backspace instead of typing several maybe zero characters of s ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tstr S, T; re(S, T);\n\tauto ok = [&]() {\n\t\tint i = 0;\n\t\tfor (char c: T) {\n\t\t\twhile (i < sz(S) && S.at(i) != c) i += 2;\n\t\t\tif (i >= sz(S)) return false;\n\t\t\t++i;\n\t\t}\n\t\treturn (sz(S)-i)%2 == 0;\n\t};\n\tif (ok()) {\n\t\tps(""YES"");\n\t\treturn;\n\t}\n\tS.erase(begin(S));\n\tif (ok()) {\n\t\tps(""YES"");\n\t\treturn;\n\t}\n\tps(""NO"");\n\t// ababa\n\t// xxxxxxt_0 xx t_1 xxxx t_n xx xx\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['dp', 'greedy', 'strings', 'two pointers']",1500
https://codeforces.com//contest/454/problem/B,B. Little Pony and Sort by Shift,One day Twilight Sparkle is interested in how to sort a sequence of integers in non decreasing order Being a young unicorn the only operation she can perform is a unit shift That is she can move the last element of the sequence to its beginning Help Twilight Sparkle to calculate what is the minimum number of operations that she needs to sort the sequence ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n\n#define inf 0x3f3f3f3f\n#define Inf 0x3FFFFFFFFFFFFFFFLL\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define Rep(i, n) for (int i = 1; i <= (n); ++i)\n#define clr(x, a) memset(x, (a), sizeof x)\nusing namespace std;\ntypedef long long ll;\nint a[200200];\nint b[200200];\nint s[200200];\nint main() {\n\tint n; scanf(""%d"", &n);\n\trep(i, n) {\n\t\tscanf(""%d"", &a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\tRep(i, n + n) {\n\t\tb[i] = a[i] >= a[i - 1];\n\t\ts[i] = s[i - 1] + b[i];\t\n\t}\n\t//Rep(i, n + n) cout << b[i] << """";cout<<endl;\n\tint ret = -1;\n\trep(i, n + 1) {\n\t\tif (s[i + n - 1] - s[i] == n - 1) {\n\t\t\tret = n - i;\n\t\t}\n\t}\n\tprintf(""%d\\n"", ret);\n\treturn 0;\n}\n']",['implementation'],1200
https://codeforces.com//contest/1292/problem/A,A. NEKO s Maze Game,NEKO has just got a new maze game on her PC The game s main puzzle is a maze in the forms of a 2 times n rectangle grid NEKO s task is to lead a Nekomimi girl from cell 1 1 to the gate at 2 n and escape the maze The girl can only move between cells sharing a common side However at some moments during the game some cells may change their state either from normal ground to lava which forbids movement into that cell or vice versa which makes that cell passable again Initially all cells are of the ground type After hours of streaming NEKO finally figured out there are only q such moments the i th moment toggles the state of cell r i c i either from ground to lava or vice versa Knowing this NEKO wonders after each of the q moments whether it is still possible to move from cell 1 1 to cell 2 n without going through any lava cells Although NEKO is a great streamer and gamer she still can t get through quizzes and problems requiring large amount of Brain Power Can you help her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nint a[2][N];\nint n, q;\nint cnt;\n\nvoid change(int x, int y) {\n\tfor (int z = y - 1; z <= y + 1; z++) {\n\t\tif (z < 0 || z >= n) continue;\n\t\tcnt -= a[x][y] & a[x ^ 1][z];\n\t}\n\ta[x][y] ^= 1;\n\tfor (int z = y - 1; z <= y + 1; z++) {\n\t\tif (z < 0 || z >= n) continue;\n\t\tcnt += a[x][y] & a[x ^ 1][z];\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &q);\n\twhile(q--) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;y--;\n\t\tchange(x, y);\n\t\tif (cnt == 0)\n\t\t\tprintf(""Yes\\n"");\n\t\telse\n\t\t\tprintf(""No\\n"");\n\t}\n\n\treturn 0;\n}\n']","['data structures', 'dsu', 'implementation']",1400
https://codeforces.com//contest/938/problem/B,B. Run For Your Prize,You and your friend are participating in a TV show Run For Your Prize At the start of the show prizes are located on a straight line th prize is located at position Positions of all prizes are distinct You start at position your friend at position and there is no prize in any of these two positions You have to work as a team and collect all prizes in minimum possible time in any order You know that it takes exactly second to move from position to position or both for you and your friend You also have trained enough to instantly pick up any prize if its position is equal to your current position and the same is true for your friend Carrying prizes does not affect your speed or your friend s speed at all Now you may discuss your strategy with your friend and decide who will pick up each prize Remember that every prize must be picked up either by you or by your friend What is the minimum number of seconds it will take to pick up all the prizes ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\t\n\tint ans = 0;\n\twhile (N--) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tans = max(ans, min(t - 1, 1000000 - t));\n\t}\n\treturn !printf(""%d\\n"", ans);\n}']","['brute force', 'greedy']",1100
https://codeforces.com//contest/1695/problem/D1,D1. Tree Queries  Easy Version ,You are given an unrooted tree with n vertices There is some hidden vertex x in that tree that you are trying to find To do this you may ask k queries v 1 v 2 ldots v k where the v i are vertices in the tree After you are finished asking all of the queries you are given k numbers d 1 d 2 ldots d k where d i is the number of edges on the shortest path between v i and x Note that you know which distance corresponds to which query What is the minimum k such that there exists some queries v 1 v 2 ldots v k that let you always uniquely identify x no matter what x is Note that you don t actually need to output these queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5, INF = 1e9;\n\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int fa) {\n    int cnt = 0, cnt2 = 0;\n    for (auto v : adj[u]) {\n        if (v == fa) continue;\n        cnt += dfs(v, u);\n        ++cnt2;\n    }\n    if (cnt != cnt2 && adj[u].size() >= 3) --ans;\n    return (cnt > 0) | (adj[u].size() >= 3);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n;\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        \n        if (n == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        for (int i = 0; i < n; i++) adj[i].clear();\n\n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        ans = 0;\n        for (int i = 0; i < n; i++) ans += (adj[i].size() == 1);\n\n        int id = -1;\n        for (int i = 0; i < n; i++) {\n            if (adj[i].size() >= 3) {\n                id = i;\n                break;\n            }\n        }\n        if (id == -1) {\n            cout << 1 << endl;\n            continue;\n        }\n        dfs(id, id);\n        cout << ans << endl;\n    }\n    return 0;\n}']","['brute force', 'constructive algorithms', 'dfs and similar', 'dp', 'greedy', 'trees']",2200
https://codeforces.com//contest/1362/problem/A,A. Johnny and Ancient Computer,Johnny has recently found an ancient broken computer The machine has only one register which allows one to put in there one variable Then in one operation you can shift its bits left or right by at most three positions The right shift is forbidden if it So in fact in one operation you can multiply or divide your number by 2 4 or 8 and division is only allowed if the number is divisible by the chosen divisor Formally if the register contains a positive integer x in one operation it can be replaced by one of the following x cdot 2 x cdot 4 x cdot 8 x 2 if x is divisible by 2 x 4 if x is divisible by 4 x 8 if x is divisible by 8 For example if x 6 in one operation it can be replaced by 12 24 48 or 3 Value 6 isn t divisible by 4 or 8 so there re only four variants of replacement Now Johnny wonders how many operations he needs to perform if he puts a in the register and wants to get b at the end ,"[""#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint t; cin >> t;\n\n\twhile (t--) {\n\t\tll a, b; cin >> a >> b;\n\t\tint op = 0;\n\t\tif (a > b) {\n\t\t\twhile (a > b) { \n\t\t\t\tif (a % 8 == 0 && a / 8 >= b) { a /= 8; op++; }\n\t\t\t\telse if (a % 4 == 0 && a / 4 >= b) { a /= 4; op++; }\n\t\t\t\telse if (a % 2 == 0 && a / 2 >= b) { a /= 2; op++; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (a < b) {\n\t\t\t\tif (a * 8 <= b) { a *= 8; op++; }\n\t\t\t\telse if (a * 4 <= b) { a *= 4; op++; }\n\t\t\t\telse if (a * 2 <= b) { a *= 2; op++; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t}\n\n\t\tcout << (a == b ? op : -1) << '\\n';\n\t}\n}""]",['implementation'],1000
https://codeforces.com//contest/711/problem/E,E. ZS and The Birthday Paradox,ZS the Coder has recently found an interesting concept called the Birthday Paradox It states that given a random set of people there is around chance that some two of them share the same birthday ZS the Coder finds this very interesting and decides to test this with the inhabitants of Udayland In Udayland there are days in a year ZS the Coder wants to interview people from Udayland each of them has birthday in one of days each day with equal probability He is interested in the probability of at least two of them have the birthday at the same day ZS the Coder knows that the answer can be written as an irreducible fraction He wants to find the values of and he does not like to deal with floating point numbers Can you help him ,"['#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int maxn = (int)1e6;\nconst int inf = (int)1e9;\nconst int mod = (int)1e6 + 3;\nconst ll INF = (ll)1e18;\nconst double eps = 1e-9;\n\nll n, k;\n\nll binpow(ll a, ll k) {\n\tif (k == 0) return 1;\n\tll ans = binpow(a, k / 2);\n\tans = 1ll * ans * ans % mod;\n\tif (k % 2) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\n\nll g(ll n, ll k) {\n\tif (k < mod) {\n\t\tll t = binpow(2, n);\n\t\tll ans = 1;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tans *= (t - (2ll * i + 1));\n\t\t\tans %= mod;\n\t\t\tif (ans < 0) ans += mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tll t = binpow(2, n);\n\tll cur = 1;\n\tfor (int i = 0; i < mod; i++) {\n\t\tcur *= (t - (2ll * i + 1));\n\t\tcur %= mod;\n\t\tif (cur < 0) cur += mod;\n\t}\n\tll s = k / mod;\n\tll ans = binpow(cur, s) * g(n, k % mod) % mod;\n\treturn ans;\n}\n\nll f(ll n, ll k) {\n\tif (k == 0) return 1;\n\tll t = (k - 1) / 2;\n\tll ans = g(n, t);\n\treturn ans * 1ll * f(n - 1, k / 2) % mod;\n}\n\nll get(ll n, ll k) {\n\tif (k == 0) return 0;\n\tll t = k / 2;\n\treturn t + get(n, t);\n}\n\nint main()\n{\n\n\tcin >> n >> k;\n\t\n\tif (n <= 60) {\n\t\tll mx = 1;\n\t\tfor (int i = 0; i < n; i++) mx *= 2;\n\t\tif (mx < k) {\n\t\t\tcout << 1 << "" "" << 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tll alpha = get(n, k - 1);\n\tll P = f(n, k - 1);\n\tll t = n % (mod - 1) * 1ll * ((k - 1) % (mod - 1)) % (mod - 1);\n\tt -= alpha;\n\tt %= mod - 1;\n\tt += mod - 1;\n\tt %= mod - 1;\n\tll Q = binpow(2, t);\n\t\n\tP = Q - P;\n\tP %= mod; P += mod; P %= mod;\n\t\n\tcout << P << "" "" << Q << endl;\n\t\n\treturn 0;\n}\n']","['math', 'number theory', 'probabilities']",2300
https://codeforces.com//contest/685/problem/C,C. Optimal Point,When the river brought Gerda to the house of the Old Lady who Knew Magic this lady decided to make Gerda her daughter She wants Gerda to forget about Kay so she puts all the roses from the garden underground Mole who lives in this garden now can watch the roses without going up to the surface Typical mole is blind but this mole was granted as special vision by the Old Lady He can watch any underground objects on any distance even through the obstacles and other objects However the quality of the picture depends on the Manhattan distance to object being observed Mole wants to find an point to watch roses that is such point with that the maximum Manhattan distance to the rose is minimum possible As usual he asks you to help between points and is defined as ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(""%d\\n"",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(""%d\\n"",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define lld ""%I64d""\n#else\n    #define lld ""%lld""\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');c==\'-\'?(sg=-1,x=0):(x=c-\'0\');\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gn(long double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gs(char *s){scanf(""%s"",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n;\nll x[111111],y[111111],z[111111];\n\nint out=0;\nbool check(ll d,int par){\n\tll lz,rz;\n\tlz=-7e18,rz=7e18;\n\n\tll l10,r10,l20,r20;\n\tll l1,r1,l2,r2;\n\n\tl1=l2=-7e18;\n\tr1=r2=7e18;\n\trep(i,1,n+1){\n\t\tupmax(l1,x[i]+y[i]+z[i]-d);\n\t\tupmin(r1,x[i]+y[i]+z[i]+d);\n\t\tupmax(l2,x[i]+y[i]-z[i]-d);\n\t\tupmin(r2,x[i]+y[i]-z[i]+d);\n\t}\n\tif((l1&1)!=par)l1++;\n\tif((l2&1)!=par)l2++;\n\tif((r1&1)!=par)r1--;\n\tif((r2&1)!=par)r2--;\n\t\n\tif(l1>r1 || l2>r2)return 0;\n\n\tupmin(rz,(r1-l2)/2ll);\n\tupmax(lz,(l1-r2)/2ll);\n\n\tl10=l1;\n\tr10=r1;\n\tl20=l2;\n\tr20=r2;\n\n\tl1=l2=-7e18;\n\tr1=r2=7e18;\n\trep(i,1,n+1){\n\t\tupmax(l1,x[i]-y[i]+z[i]-d);\n\t\tupmin(r1,x[i]-y[i]+z[i]+d);\n\t\tupmax(l2,x[i]-y[i]-z[i]-d);\n\t\tupmin(r2,x[i]-y[i]-z[i]+d);\n\t}\n\tif((l1&1)!=par)l1++;\n\tif((l2&1)!=par)l2++;\n\tif((r1&1)!=par)r1--;\n\tif((r2&1)!=par)r2--;\n\t\n\tif(l1>r1 || l2>r2)return 0;\n\n\tupmin(rz,(r1-l2)/2ll);\n\tupmax(lz,(l1-r2)/2ll);\n\n\tif(lz>rz)return 0;\n\n\tll z=lz;\n\n\tll lplu=max(l10-z,l20+z);\n\tll rplu=min(r10-z,r20+z);\n\tll lmin=max(l1-z,l2+z);\n\tll rmin=min(r1-z,r2+z);\n\n\tll x=(lplu+lmin)/2,y=(lplu-lmin)/2;\n\n\tif(out){\n\t\tout=0;\n\t\tprintf(""%I64d %I64d %I64d\\n"",x,y,z);\n\t}\n\treturn 1;\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tint _time_jc=clock();\n#endif\n\tint te;gn(te);\n\twhile(te--){\n\t\tgn(n);\n\t\trep(i,1,n+1){\n\t\t\tgn(x[i]);\n\t\t\tgn(y[i]);\n\t\t\tgn(z[i]);\n\t\t}\n\t\tll l=0,r=3.1e18;\n\t\twhile(l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif(check(mid,0) || check(mid,1))r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tout=1;\n\t\tcheck(l,0);\n\t\tcheck(l,1);\n\t}\n\t\n#ifdef JCVB\n\tdebug(""time: %d\\n"",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n']","['binary search', 'math']",2900
https://codeforces.com//contest/1434/problem/C,C. Solo mid Oracle,Meka Naruto plays a computer game His character has the following ability given an enemy hero deal a instant damage to him and then heal that enemy b health points at the end of every second for exactly c seconds starting one second after the ability is used That means that if the ability is used at time t the enemy s health decreases by a at time t and then increases by b at time points t 1 t 2 t c due to this ability The ability has a cooldown of d seconds i e if Meka Naruto uses it at time moment t next time he can use it is the time t d Please note that he can only use the ability at integer points in time so all changes to the enemy s health also occur at integer times only The effects from different uses of the ability may stack with each other that is the enemy which is currently under k spells gets k cdot b amount of heal this time Also if several health changes occur at the same moment they are all counted at once Now Meka Naruto wonders if he can kill the enemy by just using the ability each time he can that is every d seconds The enemy is killed if their health points become 0 or less Assume that the enemy s health is not affected in any way other than by Meka Naruto s character ability What is the maximal number of health points the enemy can have so that Meka Naruto is able to kill them ,"[""/**\n *    author:  tourist\n *    created: 25.10.2020 14:23:37       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a - b * c > 0) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    long long step = b * d;\n    long long last = a % step;\n    long long first = a;\n    long long cnt = (first - last) / step + 1;\n    long long ans = (last + first) * cnt / 2;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]","['binary search', 'greedy', 'math', 'ternary search']",2100
https://codeforces.com//contest/1474/problem/E,E. What Is It ,Lunar rover finally reached planet After landing he met an obstacle that contains permutation p of length n Scientists found out that to overcome an obstacle the robot should make p an identity permutation make p i i for all i Unfortunately scientists can t control the robot Thus the only way to make p an identity permutation is applying the following operation to p multiple times Select two indices i and j i neq j such that p j i and swap the values of p i and p j It takes robot j i 2 seconds to do this operation Positions i and j are selected by the robot scientists can t control it He will apply this operation while p isn t an identity permutation We can show that the robot will make no more than n operations regardless of the choice of i and j on each operation Scientists asked you to find out the maximum possible time it will take the robot to finish making p an identity permutation i e worst case scenario so they can decide whether they should construct a new lunar rover or just rest and wait They won t believe you without proof so you should build an example of p and robot s operations that maximizes the answer For a better understanding of the statement read the sample description ,"[""#include<bits/stdc++.h>\nusing namespace std;\nstruct item{\n\tlong long a,b;\n};\nvoid solve(){\n\tlong long n,i;\n\tcin>>n;\n\tlong long result=(n-1)*(n-1),c=1,v=n-2,last=n;\n\tlong long p[n+1];\n\tfor(i=0;i<=n;i++){\n\t\tp[i]=1;\n\t}\n\tvector<item> bucket;\n\tfor(;c+1<n;){\n\t\tif(c<n-2){\n\t\t\tresult+=2*v*v;\n\t\t\tc=c+2;\n\t\t\tv--;\n\t\t}\n\t\telse{\n\t\t\tresult+=v*v;\n\t\t\tc++;\n\t\t}\n\t}\n\tcout<<result<<endl;\n\tresult=(n+1)/2;\n\tfor(i=0;i<(n-1)/2;i++){\n\t\tp[last]=result;\n\t\titem it;\n\t\tit.a=result,it.b=n;\n\t\tbucket.emplace_back(it);\n\t\tlast=result;result--;\n\t}\n\tlast=1;result=(n+1)/2+1;\n\tfor(i=0;i<n/2;i++){\n\t\tp[last]=result;\n\t\titem it;\n\t\tit.a=result;it.b=1;\n\t\tbucket.emplace_back(it);\n\t\tlast=result;result++;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tcout<<p[i]<<' ';\n\t}\n\tcout<<endl<<n-1<<endl;\n\tfor(item it:bucket){\n\t\tcout<<it.a<<' '<<it.b<<endl;\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlong long t=1;\n\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}""]","['constructive algorithms', 'greedy']",2500
https://codeforces.com//contest/598/problem/B,B. Queries on a String,You are given a string and should process queries Each query is described by two 1 based indices and integer It means that you should cyclically shift the substring times The queries should be processed one after another in the order they are given One operation of a cyclic shift rotation is equivalent to moving the last character to the position of the first character and shifting all other characters one position to the right For example if the string is and the query is then the answer is If after that we would process the query then we would get the string ,"[""//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 100*1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\n\n\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    string s; cin >> s;\n    int q; cin >> q;\n    rep(i,0,q)\n    {\n\tint l, r, k; cin >> l >> r >> k; l --;\n\tint len = r - l; k %= len;\n\trotate(s.begin() + l, s.begin() + r - k , s.begin() + r);\n    }\n    cout << s << endl;\n    return 0;    \n}\n""]","['implementation', 'strings']",1300
https://codeforces.com//contest/872/problem/A,A. Search for Pretty Integers,You are given two lists of non zero digits Let s call an integer pretty if its base representation has at least one digit from the first list and at least one digit from the second list What is the smallest positive pretty integer ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint a[100],b[100];\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tint A;\n\t\tcin>>A;\n\t\ta[A]=1;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint A;\n\t\tcin>>A;\n\t\tb[A]=1;\n\t}\n\tfor(int i=1;i<100;i++){\n\t\tif((a[i%10]||(i>=10&&a[i/10]))&&(b[i%10]||(i>=10&&b[i/10]))){\n\t\t\tprintf(""%d\\n"",i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}']",['implementation'],900
https://codeforces.com//contest/786/problem/D,D. Rap God,Rick is in love with Unity But Mr Meeseeks also love Unity so Rick and Mr Meeseeks are love rivals Unity loves rap so it decided that they have to compete in a rap game battle in order to choose the best Rick is too nerds so instead he s gonna make his verse with running his original algorithm on lyrics Rap God song His algorithm is a little bit complicated He s made a tree with vertices numbered from to and there s a lowercase english letter written on each edge He denotes to be the string made by writing characters on edges on the shortest path from to one by one a string of length equal to distance of to Note that is reverse of and is empty In order to make the best verse he can he needs to answer some queries but he s not a computer scientist and is not able to answer those queries so he asked you to help him Each query is characterized by two vertices and Answer to this query is the number of vertices like such that and is lexicographically larger than String is lexicographically larger than string if either and or exists such number that and Characters are compared like their ASCII codes or alphabetic order Help Rick get the girl or whatever gender Unity has ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=40100;\nint T,p[N],c[N],dep[N],ch[N],vis[N],st[N],q,ret[N],cp[N];\nint n,u,v;\nchar s[10];\n\nvector<PII> e[N],Q[N];\nvoid dfs(int u,int f) {\n\tfor (auto v:e[u]) if (v.fi!=f) {\n\t\tdfs(v.fi,u); p[v.fi]=u; c[v.fi]=v.se;\n\t}\n}\nint gao(int u,int v) {\n\tT++;\n\tint r=v,tot=0; dep[v]=n;\n\tint ret=-1;\n\twhile (r!=u) {\n\t\tch[dep[r]]=c[r];\n\t\tvis[r]=T;\n\t\tcp[r]=1;\n\t\tdep[p[r]]=dep[r]-1;\n\t\tr=p[r];\n\t\tret++;\n\t}\n\tvis[u]=T; cp[u]=1;\n\trep(j,1,n+1) if (vis[j]!=T) {\n\t\tint top=0,r=j;\n\t\twhile (vis[r]!=T) st[top++]=r,r=p[r];\n\t\tper(i,0,top) {\n\t\t\tint r=st[i];\n\t\t\tdep[r]=dep[p[r]]+1;\n\t\t\tvis[r]=T;\n\t\t\tif (cp[p[r]]!=1) cp[r]=cp[p[r]];\n\t\t\telse if (ch[dep[r]]>c[r]) cp[r]=0;\n\t\t\telse if (ch[dep[r]]==c[r]) cp[r]=1; else cp[r]=2;\n\t\t\tret+=(cp[r]==0)||(cp[r]==1&&dep[r]<dep[v]);\n\t\t}\n\t}\n\treturn ret;\n}\nvoid solve(int u,int f) {\n\tfor (auto v:Q[u]) ret[v.se]=gao(u,v.fi);\n\tint pr=c[u];\n\tfor (auto v:e[u]) if (v.fi!=f) {\n\t\tp[u]=v.fi; c[u]=v.se;\n\t\tsolve(v.fi,u);\n\t}\n\tc[u]=pr; p[u]=f;\n}\nint main() {\n\tscanf(""%d%d"",&n,&q);\n\trep(i,1,n) {\n\t\tscanf(""%d%d%s"",&u,&v,s);\n\t\te[u].pb(mp(v,s[0])); e[v].pb(mp(u,s[0]));\n\t}\n\tdfs(1,0);\n\trep(i,0,q) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\tQ[u].pb(mp(v,i));\n\t}\n\tsolve(1,0);\n\trep(i,0,q) printf(""%d\\n"",ret[i]);\n}\n']","['data structures', 'dfs and similar', 'hashing', 'strings', 'trees']",3400
https://codeforces.com//contest/1545/problem/F,F. AquaMoon and Potatoes,AquaMoon has three integer arrays a b c of length n where 1 leq a i b i c i leq n for all i In order to accelerate her potato farming she organizes her farm in a manner based on these three arrays She is now going to complete m operations to count how many potatoes she can get Each operation will have one of the two types AquaMoon reorganizes their farm and makes the k th element of the array a equal to x In other words perform the assignment a k x Given a positive integer r AquaMoon receives a potato for each triplet i j k such that 1 le i j k le r and b a i a j c a k Count the number of such triplets As AquaMoon is busy finding the library help her complete all of their operations ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint N,M;\nV<AR<int,3>> val;\nint BLOCK = 1;\n\nvoid sub(vi& v) { each(t,v) --t; }\n\nstruct RangeQuery {\n\tstatic constexpr int SZ = 450;\n\tll block_sum[SZ];\n\tll sing[SZ*SZ];\n\tll get_sum(int r) {\n\t\tll ans = 0; while (r%BLOCK != 0) ans += sing[--r];\n\t\tfor (r /= BLOCK;r;) ans += block_sum[--r];\n\t\treturn ans;\n\t}\n\tvoid increment(int x, ll v) {\n\t\tblock_sum[x/BLOCK] += v;\n\t\tsing[x] += v;\n\t}\n};\n\nRangeQuery RQ;\n\nvpi cur[MX];\n\n#ifdef LOCAL\nconst int THRESH = 0;\n#else\nconst int THRESH = 1500;\n#endif\n\nvi oc;\nvoid contrib(int v, int sgn) {\n\tif (oc[v] > THRESH) return;\n\tint one = 0; ll two = 0;\n\teach(t,cur[v]) {\n\t\tif (t.s == 0) {\n\t\t\t++one;\n\t\t} else if (t.s == -1) {\n\t\t\ttwo += one;\n\t\t} else if (t.s == -2) {\n\t\t\tRQ.increment(t.f,sgn*two);\n\t\t}\n\t}\n}\n\nvoid upd(int pos, int j, int sgn) {\n\tint v = val[pos][j];\n\tif (oc[v] > THRESH) return;\n\tcontrib(v,-1);\n\tpi p{pos,-j};\n\tif (sgn == -1) {\n\t\tauto it = find(all(cur[v]),p); assert(it != end(cur[v]));\n\t\tcur[v].erase(it);\n\t} else {\n\t\tauto it = lb(all(cur[v]),p); cur[v].ins(it,p);\n\t}\n\tcontrib(v,1);\n}\n\nvi A, B, C;\nvoid add_oc(int x) { ++oc[B[x]], ++oc[x], ++oc[C[x]]; }\n\nvl ans;\nV<tuple<int,int,int>> queries;\n\nvoid deal_small() {\n\tF0R(i,N) {\n\t\tval[i] = {B[A[i]],A[i],C[A[i]]};\n\t\tR0F(j,3) cur[val[i][j]].pb({i,-j});\n\t}\n\tF0R(i,N) contrib(i,1);\n\teach(t,queries) {;\n\t\tauto [type,_a,_b] = t;\n\t\tif (type == 1) {\n\t\t\tauto [_,i,x] = t; \n\t\t\tF0R(j,3) upd(i,j,-1);\n\t\t\tval[i] = {B[x],x,C[x]};\n\t\t\tF0R(j,3) upd(i,j,1);\n\t\t} else {\n\t\t\tauto [_a,r,_b] = t;\n\t\t\tans.pb(RQ.get_sum(r));\n\t\t}\n\t}\n}\n\nconstexpr AR<AR<int,4>,4> zz{{\n\t{-1,0,1,2},\n\t{-1,-1,3,4},\n\t{-1,-1,-1,5},\n\t{-1,-1,-1,-1}\n}};\n\nAR<ll,3> calc_nex(const AR<ll,3>& pref, const AR<ll,6>& block) {\n\treturn {pref[0]+block[zz[0][1]],\n\t\t\tpref[0]*block[zz[1][2]]+pref[1]+block[zz[0][2]],\n\t\t\tpref[0]*block[zz[1][3]]+pref[1]*block[zz[2][3]]+pref[2]+block[zz[0][3]]};\n}\n\nvpi relevant[450];\nAR<ll,3> pref[450];\nAR<ll,6> blocks[450];\n\nvoid deal_large() {\n\tF0R(v,N) if (oc[v] > THRESH) {\n\t\tauto recalc_prefixes = [&]() {\n\t\t\tF0R(i,BLOCK-1) pref[i+1] = calc_nex(pref[i],blocks[i]);\n\t\t};\n\t\tauto recalc_block = [&](int x) {\n\t\t\tassert(0 <= x && x < BLOCK);\n\t\t\trelevant[x].clear();\n\t\t\tAR<ll,6>& stor = blocks[x]; stor = {};\n\t\t\tFOR(i,x*BLOCK,min((x+1)*BLOCK,N)) {\n\t\t\t\tif (val[i][2] == v) {\n\t\t\t\t\trelevant[x].pb({i,-2});\n\t\t\t\t\t++stor[zz[2][3]];\n\t\t\t\t\tstor[zz[1][3]] += stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][3]] += stor[zz[0][2]];\n\t\t\t\t}\n\t\t\t\tif (val[i][1] == v) {\n\t\t\t\t\trelevant[x].pb({i,-1});\n\t\t\t\t\t++stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][2]] += stor[zz[0][1]];\n\t\t\t\t}\n\t\t\t\tif (val[i][0] == v) {\n\t\t\t\t\trelevant[x].pb({i,0});\n\t\t\t\t\t++stor[zz[0][1]];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tauto recalc_block_2 = [&](int x) {\n\t\t\tAR<ll,6>& stor = blocks[x]; stor = {};\n\t\t\tfor (const pi& p: relevant[x]) {\n\t\t\t\tif (p.s == -2) {\n\t\t\t\t\t++stor[zz[2][3]];\n\t\t\t\t\tstor[zz[1][3]] += stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][3]] += stor[zz[0][2]];\n\t\t\t\t} else if (p.s == -1) {\n\t\t\t\t\t++stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][2]] += stor[zz[0][1]];\n\t\t\t\t} else {\n\t\t\t\t\t++stor[zz[0][1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(i,x,BLOCK-1) pref[i+1] = calc_nex(pref[i],blocks[i]);\n\t\t};\n\t\t\n\t\n\t\tF0R(i,N) val[i] = {B[A[i]],A[i],C[A[i]]};\n\t\tF0R(x,BLOCK) recalc_block(x);\n\t\trecalc_prefixes();\n\t\tint ans_cnt = 0;\n\t\teach(t,queries) {\n\t\t\tauto [type,_a,_b] = t;\n\t\t\tif (type == 1) {\n\t\t\t\tauto [_,i,x] = t; \n\t\t\t\tbool flag = 0;\n\t\t\t\tint label = i/BLOCK;\n\t\t\t\tF0R(j,3) if (val[i][j] == v) relevant[label].erase(lb(all(relevant[label]),mp(i,-j))), flag = 1;\n\t\t\t\tval[i] = {B[x],x,C[x]};\n\t\t\t\tF0R(j,3) if (val[i][j] == v) relevant[label].ins(lb(all(relevant[label]),mp(i,-j)),mp(i,-j)), flag = 1;\n\t\t\t\tif (flag) recalc_block_2(label);\n\t\t\t} else {\n\t\t\t\tauto [_a,r,_b] = t;\n\t\t\t\tAR<ll,3> a = pref[r/BLOCK];\n\t\t\t\tfor (const auto& p: relevant[r/BLOCK]) {\n\t\t\t\t\tif (p.f >= r) break;\n\t\t\t\t\tif (p.s == 0) ++a[0];\n\t\t\t\t\telse if (p.s == -1) a[1] += a[0];\n\t\t\t\t\telse if (p.s == -2) a[2] += a[1];\n\t\t\t\t}\n\t\t\t\tans[ans_cnt++] += a[2];\n\t\t\t}\n\t\t}\n\t\tassert(ans_cnt == sz(ans));\n\t}\n}\n\nint main() {\n\tdbg(THRESH);\n\tsetIO(); re(N,M);\n\twhile (BLOCK*BLOCK <= N) ++BLOCK;\n\tA.rsz(N), B.rsz(N), C.rsz(N); re(A,B,C);\n\tsub(A), sub(B), sub(C);\n\tval.rsz(N);\n\toc = vi(N);\n\n\tF0R(i,N) add_oc(A[i]);\n\n\trep(M) {\n\t\tints(type);\n\t\tif (type == 1) {\n\t\t\tints(i,x); --i, --x;\n\t\t\tqueries.pb({type,i,x});\n\t\t\tadd_oc(x);\n\t\t} else {\n\t\t\tints(r);\n\t\t\tqueries.pb({type,r,-1});\n\t\t}\n\t}\n\t// dbg(oc);\n\n\t// if nothing occurs very frequently\n\tdeal_small();\n\tdeal_large();\n\teach(t,ans) ps(t);\n\t// 3*(250000)/2500\n\n\t// if something occurs very frequently, deal w/ it separately\n\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['brute force', 'data structures', 'dp']",3500
https://codeforces.com//contest/1100/problem/B,B. Build a Contest,Arkady coordinates rounds on some not really famous competitive programming platform Each round features n problems of distinct difficulty the difficulties are numbered from 1 to n To hold a round Arkady needs n new not used previously problems one for each difficulty As for now Arkady creates all the problems himself but unfortunately he can t just create a problem of a desired difficulty Instead when he creates a problem he evaluates its difficulty from 1 to n and puts it into the problems pool At each moment when Arkady can choose a set of n new problems of distinct difficulties from the pool he holds a round with these problems and removes them from the pool Arkady always creates one problem at a time so if he can hold a round after creating a problem he immediately does it You are given a sequence of problems difficulties in the order Arkady created them For each problem determine whether Arkady held the round right after creating this problem or not Initially the problems pool is empty ,"['#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,x,a[MAXN],ans[MAXN];\nmultiset<int> s;\nint main()\n{\n    scanf(""%d%d"",&n,&m);\n    memset(a,0,sizeof(a));\n    for(int i=1;i<=n;i++) s.insert(0);\n    int cnt=0;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(""%d"",&x);\n        s.erase(s.find(a[x]));\n        a[x]++;\n        s.insert(a[x]);\n        if(*s.begin()>cnt)\n        {\n            cnt++;\n            ans[i]=1;\n        }\n        else ans[i]=0;\n    }\n    for(int i=1;i<=m;i++) printf(""%d"",ans[i]);\n    puts("""");\n    return 0;\n}\n\n']","['data structures', 'implementation']",1300
https://codeforces.com//contest/463/problem/A,A. Caisa and Sugar,Caisa is going to have a party and he needs to buy the ingredients for a big chocolate cake For that he is going to the biggest supermarket in town Unfortunately he has just dollars for sugar But that s not a reason to be sad because there are types of sugar in the supermarket maybe he able to buy one But that s not all The supermarket has very unusual exchange politics instead of cents the sellers give sweets to a buyer as a change Of course the number of given sweets always doesn t exceed because each seller maximizes the number of dollars in the change cents can be replaced with a dollar Caisa wants to buy only one type of sugar also he wants to maximize the number of sweets in the change What is the maximum number of sweets he can get Note that Caisa doesn t want to minimize the cost of the sugar he only wants to get maximum number of sweets as change ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <functional>\n\ntypedef long long lld;\n\nconst int N = 100 + 5;\n\nint n,s,A[N],B[N];\n\nint main() {\n    scanf(""%d%d"",&n,&s);\n    int answer = -1;\n    for (int i = 0; i < n; ++ i) {\n        scanf(""%d%d"",A+i,B+i);\n        int need = A[i] + (B[i]>0);\n        if (s < need) continue;\n        if (B[i]==0) {\n            answer = std::max(answer,0);\n        } else {\n            int value = 100 - B[i];\n            answer = std::max(answer,value);\n        }\n    }\n    printf(""%d\\n"",answer);\n    return 0;\n}']","['brute force', 'implementation']",1200
https://codeforces.com//contest/990/problem/E,E. Post Lamps,Adilbek s house is located on a street which can be represented as the OX axis This street is really dark so Adilbek wants to install some post lamps to illuminate it Street has n positions to install lamps they correspond to the integer numbers from 0 to n 1 on the OX axis However some positions are blocked and no post lamp can be placed there There are post lamps of different types which differ only by their power When placed in position x post lamp of power l illuminates the segment x x l The power of each post lamp is always a positive integer number The post lamp shop provides an infinite amount of lamps of each type from power 1 to power k Though each customer is only allowed to order post lamps of type Post lamps of power l cost a l each What is the minimal total cost of the post lamps of type Adilbek can buy to illuminate the entire segment 0 n of the street If some lamps illuminate any other segment of the street Adilbek does not care so for example he may place a lamp of power 3 in position n 1 even though its illumination zone doesn t completely belong to segment 0 n ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxm = 1000005;\nconst ll Inf = 9000000000000000000ll;\n\nint n, m, k;\nbool block[Maxm];\nint cnt[Maxm];\nint a[Maxm];\nll res = Inf;\n\nint main()\n{\n\tscanf(""%d %d %d"", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a; scanf(""%d"", &a);\n\t\tblock[a] = true;\n\t}\n\tint mx = 0;\n\tfor (int i = 0; i < Maxm; i++)\n\t\tif (block[i]) {\n\t\t\tcnt[i] = 1;\n\t\t\tif (i) cnt[i] += cnt[i - 1];\n\t\t\tmx = max(mx, cnt[i]);\n\t\t}\n\tif (block[0]) { printf(""-1\\n""); return 0; }\n\tfor (int i = 1; i <= k; i++)\n\t\tscanf(""%d"", &a[i]);\n\tfor (int i = mx + 1; i <= k; i++) {\n\t\tint cur = 0;\n\t\tll cand = 0;\n\t\twhile (cur < n)\n\t\t\tif (block[cur]) cur -= cnt[cur];\n\t\t\telse { cand += a[i]; cur += i; }\n\t\tres = min(res, cand);\n\t}\n\tif (res >= Inf) printf(""-1\\n"");\n\telse cout << res << endl;\n\treturn 0;\n}']","['brute force', 'greedy']",2100
https://codeforces.com//contest/844/problem/B,B. Rectangles,You are given table Each cell of the table is colored white or black Find the number of non empty sets of cells such that All cells in a set have the same color Every two cells in a set share row or column ,"['#include<cstdio>\nint n,m, a[50][50];\nlong long pow(int x) {\n    long long p = 1;\n    for (int i = 0; i < x; i++) p *= 2;\n    return p - 1;\n}\nint main() {\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) scanf(""%d"", a[i] + j);\n    long long res = 0;\n    for (int i = 0; i < n; i++){\n        int u = 0, v = 0;\n        for (int j = 0; j < m; j++) a[i][j] ? u++ : v++;\n        res += pow(u) + pow(v);\n    }\n    for (int i = 0; i < m; i++) {\n        int u = 0, v = 0;\n        for (int j = 0; j < n; j++) a[j][i] ? u++ : v++;\n        res += pow(u) + pow(v);\n    }\n    printf(""%lld"", res - n*m);\n    return 0;\n}']","['combinatorics', 'math']",1300
https://codeforces.com//contest/83/problem/D,D. Numbers,Valera s home task has only one problem which though formulated in a very simple way has not a trivial solution Its statement looks as follows if we consider all positive integers in the interval then it is required to count the amount of such numbers in this interval that their will be a certain integer In other words you should count the amount of such numbers from the interval that are not divisible by any number between and and yet are divisible by ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint a, b, k;\nvector <int> P;\n\nbool prime (int x) {\n\tfor (int i = 2; i * i <= x; i ++)\n\t\tif (x % i == 0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint calc (int b, int n) {\n\tif (n < 0)\n\t\treturn 0;\n\tif (b < P[n])\n\t\treturn 0;\n\tb /= P[n];\n\tint64 res = b;\n\tforn (i, n)\n\t\tres -= calc (b, i);\n\treturn res;\n}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tcin >> a >> b >> k;\n\tif (!prime (k)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif (((int64)k) * ((int64)k) > b) {\n\t\tif (a <= k && k <= b)\n\t\t\tcout << 1 << endl;\n\t\telse\n\t\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tP.clear ();\n\tfor (int i = 2; i < k; i ++)\n\t\tif (prime (i))\n\t\t\tP.pb (i);\n\tP.pb (k);\n\tcout << calc (b, P.size() - 1) - calc (a-1, P.size() - 1) << endl;\n\treturn 0;\n}\n']","['dp', 'math', 'number theory']",2400
https://codeforces.com//contest/845/problem/F,F. Guards In The Storehouse,Polycarp owns a shop in the capital of Berland Recently the criminal activity in the capital increased so Polycarp is thinking about establishing some better security in the storehouse of his shop The storehouse can be represented as a matrix with rows and columns Each element of the matrix is either an empty space or a wall Polycarp wants to hire some guards possibly zero to watch for the storehouse Each guard will be in some cell of matrix and will protect every cell to the right of his own cell and every cell to the bottom of his own cell until the nearest wall More formally if the guard is standing in the cell then he protects cell if all these conditions are met is an empty cell either and or and there are no walls between cells and Guards can be placed only in empty cells and can protect only empty cells The of placing the guards is some set of cells where guards will be placed of course two plans are different if there exists at least one cell that is included in the first plan but not included in the second plan or vice versa Polycarp calls a plan if there is empty cell that is not protected Polycarp wants to know the number of suitable plans Since it can be very large you have to output it modulo ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\ninline void add(int &x,int y)\n{\n    x+=y;\n    x=(x>=Mod ? x-Mod : x);\n}\nchar s[255][255],t[255][255];\nint dp[2][(1<<15)+5][2][2];\nint main()\n{\n    int n,m;\n    scanf(""%d%d"",&n,&m);\n    for(int i=0;i<n;i++)\n        scanf(""%s"",s[i]);\n    if(n<m)\n    {\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                t[j][i]=s[i][j];\n        memcpy(s,t,sizeof(t));\n        swap(n,m);\n    }\n    int now=0,la=1;\n    dp[now][0][0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        {\n            swap(now,la);\n            memset(dp[now],0,(1<<m)*sizeof(dp[now][0]));\n            for(int mask=0;mask<(1<<m);mask++)\n                for(int k=0;k<2;k++)\n                    for(int l=0;l<2;l++)\n                    {\n                        if(s[i][j]==\'x\')\n                            add(dp[now][mask&(~0^(1<<j))][0][l],dp[la][mask][k][l]);\n                        else\n                        {\n                            int gg=(~mask>>j&1) && (k==0 || j==0);\n                            if(gg+l<2)add(dp[now][mask][k&(j>0)][gg+l],dp[la][mask][k][l]);\n                            add(dp[now][mask|(1<<j)][1][l],dp[la][mask][k][l]);\n                        }\n                    }\n        }\n    int res=0;\n    for(int mask=0;mask<(1<<m);mask++)\n        for(int k=0;k<2;k++)\n            for(int l=0;l<2;l++)\n                add(res,dp[now][mask][k][l]);\n    return 0*printf(""%d\\n"",res);\n}\n']","['bitmasks', 'dp']",2500
https://codeforces.com//contest/1487/problem/E,E. Cheap Dinner,Ivan wants to have a good dinner A good dinner should consist of a first course a second course a drink and a dessert There are n 1 different types of first courses Ivan can buy the i th of them costs a i coins n 2 different types of second courses the i th of them costs b i coins n 3 different types of drinks the i th of them costs c i coins and n 4 different types of desserts the i th of them costs d i coins Some dishes don t go well with each other There are m 1 pairs of first courses and second courses that don t go well with each other m 2 pairs of second courses and drinks and m 3 pairs of drinks and desserts that don t go well with each other Ivan wants to buy exactly one first course one second course one drink and one dessert so that they go well with each other and the total cost of the dinner is the minimum possible Help him to find the cheapest dinner option ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 150001; //check the limits, dummy\n\nvoid solve() {\n\n    int N[4]; F0R(i, 4) cin >> N[i];\n    ll A[4][MX]; F0R(i, 4) F0R(j, N[i]) cin >> A[i][j];\n    vector<set<int>> graph[3];\n    F0R(i, 3) {\n        graph[i] = vector<set<int>>(N[i+1]);\n        int M; cin >> M;\n        F0R(j, M) {\n            int X, Y; cin >> X >> Y; X--; Y--; graph[i][Y].ins(X);\n        }\n    }\n\n    set<pl> cost[4];\n    F0R(i, N[0]) cost[0].ins({A[0][i], i});\n    FOR(i, 1, 4) {\n        F0R(j, N[i]) {\n            auto it = cost[i-1].begin();\n            while (it != cost[i-1].end() && graph[i-1][j].count(it->s)) {\n                it++;\n            }\n            if (it != cost[i-1].end()) {\n                cost[i].ins({it->f + A[i][j], j});\n            }\n        }\n    }\n    if (sz(cost[3]) == 0) {\n        cout << -1 << nl;\n    } else {\n        cout << cost[3].begin()->f << nl;\n    }\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['brute force', 'data structures', 'graphs', 'greedy', 'implementation', 'sortings', 'two pointers']",2000
https://codeforces.com//contest/560/problem/D,D. Equivalent Strings,Today on a lecture about strings Gerald learned a new definition of string equivalency Two strings and of equal length are called in one of the two cases They are equal If we split string into two halves of the same size and and string into two halves of the same size and then one of the following is correct is equivalent to and is equivalent to is equivalent to and is equivalent to As a home task the teacher gave two strings to his students and asked to determine if they are equivalent Gerald has already completed this home task Now it s your turn ,"['#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nchar A[200010];\nchar B[200010];\n\nvoid fun(char C[], int N) {\n    if(N % 2 == 0) {\n        int nN = N/2;\n        fun(C,nN);\n        fun(C+nN,nN);\n        if(strncmp(C,C+nN,nN) > 0) for(int i=0;i<nN;i++) swap(C[i],C[nN+i]);\n    }\n}\n\nint main() {\n    cin >> A >> B;\n    int N = strlen(A);\n    fun(A,N);\n    fun(B,N);\n    if(strncmp(A,B,N) == 0) cout << ""YES"" << endl;\n    else cout << ""NO"" << endl;\n    return 0;\n}\n']","['hashing', 'implementation', 'strings']",1700
https://codeforces.com//contest/1680/problem/E,E. Moving Chips,You are given a board of size 2 times n 2 rows n columns Some cells of the board contain chips The chip is represented as and an empty space is represented as It is guaranteed that there is at least one chip on the board In one move you can choose chip and move it to any adjacent by side cell of the board if this cell is inside the board It means that if the chip is in the first row you can move it left right or down but it shouldn t leave the board Same if the chip is in the second row you can move it left right or up If the chip moves to the cell with another chip the chip in the destination cell disappears i e our chip captures it Your task is to calculate the number of moves required to leave one chip on the board You have to answer t independent test cases ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<string> s(2);\n\tfor(string& x : s) cin >> x;\n\tvector<int> dp(4, 1e9);\n\tdp[3] = 0;\n\t// e1, e2, conn\n\tint last_cell = 0;\n\tint first_cell = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[0][i] == '*' || s[1][i] == '*'){\n\t\t\tlast_cell = i;\n\t\t\tif(first_cell == -1) first_cell = i;\n\t\t}\n\t}\n\tfor(int i = first_cell; i <= last_cell; i++){\n\t\tvector<int> ndp(4, 1e9);\n\t\tfor(int g = 0; g < 4; g++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tif((g & a) == 0) continue;\n\t\t\t\tif(!(a & 1) && s[0][i] == '*') continue;\n\t\t\t\tif(!(a & 2) && s[1][i] == '*') continue;\n\t\t\t\tndp[a] = min(ndp[a], dp[g] + __builtin_popcount(a));\n\t\t\t}\n\t\t}\n\t\tdp = ndp;\n\t}\n\tint ans = 1e9;\n\tfor(int x : dp){\n\t\tans = min(ans, x);\n\t}\n\tcout << (ans - 1) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['bitmasks', 'dp', 'greedy']",2000
https://codeforces.com//contest/1591/problem/F,F. Non-equal Neighbours,You are given an array of n positive integers a 1 a 2 ldots a n Your task is to calculate the number of arrays of n positive integers b 1 b 2 ldots b n such that 1 le b i le a i for every i 1 le i le n and b i neq b i 1 for every i 1 le i le n 1 The number of such arrays can be very large so print it modulo 998 244 353 ,"['// Author: wlzhouzhuan\n#pragma GCC optimize(""Ofast"")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\n#define SZ(a) ((int)(a.size()))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - \'0\', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + \'0\');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\n\nconst int N = 500005;\nconst int mod = 998244353;\n\nint stk[N], top, f[N];\nll sum[N], dp[N], ans;\nint a[N], n;\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  dp[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    ll t = 0;\n    while (top && a[stk[top]] > a[i]) {\n      t += sum[top], t %= mod; \n      ans -= 1ll * (sum[top] % mod) * (a[stk[top]] % mod) % mod;\n      ans %= mod;\n      if (ans < 0) ans += mod;\n      top--;\n    }\n    t += dp[i - 1], t %= mod;\n    stk[++top] = i, sum[top] = t;\n    ans += sum[top] * (a[i] % mod) % mod, ans %= mod;\n    dp[i] = mod - ans;\n//    printf(""dp[%d] = %lld\\n"", i, dp[i]);\n  }\n  dp[n] = (dp[n] % mod + mod) % mod;\n  printf(""%lld\\n"", (n & 1 ? (mod - dp[n]) % mod: dp[n]));\n  return 0;\n}']","['combinatorics', 'data structures', 'dp', 'math']",2400
https://codeforces.com//contest/1800/problem/E1,E1. Unforgivable Curse  easy version ,The chief wizard of the Wizengamot once caught the evil wizard Drahyrt but the evil wizard has returned and wants revenge on the chief wizard So he stole s from his student Harry The is a n length string of lowercase Latin letters Drahyrt wants to replace with an unforgivable curse string t Drahyrt using ancient magic can swap letters at a distance k or k 1 in as many times as he wants In other words Drahyrt can change letters in positions i and j in s if i j 3 or i j 4 For example if s and t Drahyrt can act as follows swap the letters at positions 1 and 4 to get swap the letters at positions 2 and 6 to get You are given s and t Can Drahyrt change s to t ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lo; \ntypedef pair< lo,lo > PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define endl ""\\n""\n#define pb push_back\n#define fio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define FOR for(int i=1;i<=n;i++)\n#define mid ((start+end)/2)\n#define ort ((bas+son)/2)\n\nconst lo inf = 1000000000000000000;\nconst lo KOK = 100000;\nconst lo LOG = 30;\nconst lo li = 200002;\nconst lo mod = 1000000007;\n\nint n,m,k,flag,t,mpp[26][li],git[26][li];\nint cev;\nchar s[li],ss[li];\n\ninline int in(){\n    int x;\n    scanf(""%d"",&x);\n    return x;\n}\n\nint main(void){\n    t=in();\n    while(t--){\n        n=in();\n        k=in();\n        scanf(""%s %s"",(s+1),(ss+1));\n        for(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tmpp[i][j]=0;\n\t\t\t\tgit[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tflag=0;\n        FOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[s[i]-\'a\'][i%k]++;\n\t\t}\n\t\tFOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[ss[i]-\'a\'][i%k]--;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tmpp[i][j]+=git[i][j];\n\t\t\t\tif(j!=k-1 && n!=k+1){\n\t\t\t\t\tgit[i][j+1]+=mpp[i][j];\n\t\t\t\t\tmpp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(mpp[i][j]){flag=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(flag){printf(""NO\\n"");}\n\t\telse printf(""YES\\n"");\n    }\n    return 0;\n}\n']","['brute force', 'constructive algorithms', 'dsu', 'graphs', 'greedy', 'strings']",1400
https://codeforces.com//contest/1513/problem/A,A. Array and Peaks,A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once Given two integers n and k construct a permutation a of numbers from 1 to n which has k peaks An index i of an array a of size n is said to be a peak if 1 i n and a i gt a i 1 and a i gt a i 1 If such permutation is not possible then print 1 ,"['#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\nconst int N = 110;\nint ans[N];\nvoid solve() {\n    int n, k;\n    scanf(""%d%d"", &n, &k);\n    for (int i = 0; i < n; ++i) ans[i] = 0;\n    if (k > (n - 1) / 2) {\n        puts(""-1"");\n        return;\n    }\n    int cnt = 1;\n    for (int i = 0; i < 2 * k + 1; i += 2) ans[i] = cnt++;\n    for (int i = 0; i < n; ++i) if (!ans[i]) ans[i] = cnt++;\n    for (int i = 0; i < n; ++i) {\n        printf(""%d "", ans[i]);\n    }\n    printf(""\\n"");\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    int t;\n    scanf(""%d"", &t);\n    for (int i = 0; i < t; ++i) solve();\n    return 0;\n}\n']","['constructive algorithms', 'implementation']",800
https://codeforces.com//contest/251/problem/B,B. Playing with Permutations,Little Petya likes permutations a lot Recently his mom has presented him permutation of length A of length is a sequence of integers all integers there are distinct There is only one thing Petya likes more than permutations playing with little Masha As it turns out Masha also has a permutation of length Petya decided to get the same permutation whatever the cost may be For that he devised a game with the following rules Before the beginning of the game Petya writes permutation on the blackboard After that Petya makes exactly moves which are described below During a move Petya tosses a coin If the coin shows heads he performs point 1 if the coin shows tails he performs point 2 Let s assume that the board contains permutation at the given moment Then Petya removes the written permutation from the board and writes another one instead In other words Petya applies permutation which he has got from his mother to permutation All actions are similar to point 1 except that Petya writes permutation on the board such that for all from 1 to In other words Petya applies a permutation that is inverse to to permutation We know that after the th move the board contained Masha s permutation Besides we know that throughout the game process Masha s permutation before the th move Note that the game has exactly moves that is throughout the game the coin was tossed exactly times Your task is to determine whether the described situation is possible or else state that Petya was mistaken somewhere See samples and notes to them for a better understanding ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nconst int N = 11111;\n\nint n, k, i, z;\nint a[N], q[N], v[N], b[N], s[N];\n\nint main() {\n//  freopen(""in"", ""r"", stdin);\n//  freopen(""out"", ""w"", stdout);\n  scanf(""%d %d"", &n, &k);\n  for (i=1;i<=n;i++) scanf(""%d"", q+i);\n  for (i=1;i<=n;i++) v[q[i]] = i;\n  for (i=1;i<=n;i++) scanf(""%d"", s+i);\n  int left = -k-1, right = k+1;\n  for (i=1;i<=n;i++) a[i] = i;\n  for (z=0;z<=k;z++) {\n    int ok = 1;\n    for (i=1;i<=n;i++)\n      if (a[i] != s[i]) ok = 0;\n    if (ok) {\n      right = z;\n      break;\n    }\n    for (i=1;i<=n;i++) b[i] = a[q[i]];\n    for (i=1;i<=n;i++) a[i] = b[i];\n  }\n  for (i=1;i<=n;i++) a[i] = i;\n  for (z=0;z>=-k;z--) {\n    int ok = 1;\n    for (i=1;i<=n;i++)\n      if (a[i] != s[i]) ok = 0;\n    if (ok) {\n      left = z;\n      break;\n    }\n    for (i=1;i<=n;i++) b[i] = a[v[i]];\n    for (i=1;i<=n;i++) a[i] = b[i];\n  }\n  if (left == 0 && right == 0) puts(""NO""); else\n  if (k == 1 && (left == -1 || right == 1)) puts(""YES""); else\n  if (left == -1 && right == 1) puts(""NO""); else\n  if ((k+left) % 2 == 0 || (k-right) % 2 == 0) puts(""YES"");\n  else puts(""NO"");\n  return 0;\n}\n']","['implementation', 'math']",1800
https://codeforces.com//contest/1236/problem/E,E. Alice and the Unfair Game,Alice is playing a game with her good friend Marisa There are n boxes arranged in a line numbered with integers from 1 to n from left to right Marisa will hide a doll in one of the boxes Then Alice will have m chances to guess where the doll is If Alice will correctly guess the number of box where doll is now she will win the game otherwise her friend will win the game In order to win Marisa will use some unfair tricks After each time Alice guesses a box she can move the doll to the neighboring box or just keep it at its place Boxes i and i 1 are neighboring for all 1 leq i leq n 1 She can also use this trick once before the game starts So the game happens in this order the game starts Marisa makes the trick Alice makes the first guess Marisa makes the trick Alice makes the second guess Marisa makes the trick ldots Alice makes m th guess Marisa makes the trick the game ends Alice has come up with a sequence a 1 a 2 ldots a m In the i th guess she will ask if the doll is in the box a i She wants to know the number of scenarios x y for all 1 leq x y leq n such that Marisa can win the game if she will put the doll at the x th box at the beginning and at the end of the game the doll will be at the y th box Help her and calculate this number ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl \'\\n\'\ntypedef long long ll;\n\n\n\n\n\nconst int N = 2e5+10;\nset<int> posDiagToJ[N], negDiagToJ[N];\nmap<int, int> memoPos[N], memoNeg[N];\n\nint n, m;\n\nint solvePos(int i, int j) {\n    if(j == m+1) return i;\n    if(memoPos[i].count(j)) return memoPos[i][j];\n    auto it = posDiagToJ[i+j].upper_bound(j);\n    int res = -1;\n    if(it == posDiagToJ[i+j].end()) {\n        int temp = (m+1) - j;\n        res = max(0LL, i - temp);\n    } else {\n        int blockedJ = *it;\n        int temp = blockedJ - j;\n        res = solvePos(i-temp+1, j+temp);\n    }\n    return memoPos[i][j] = res;\n}\n\nint solveNeg(int i, int j) {\n    if(j == m+1) return i;\n    if(memoNeg[i].count(j)) return memoNeg[i][j];\n    auto it = negDiagToJ[j-i+n].upper_bound(j);\n    int res = -1;\n    if(it == negDiagToJ[j-i+n].end()) {\n        int temp = (m+1) - j;\n        res = min(n-1, i+temp);\n    } else {\n        int temp = *it - j;\n        res = solveNeg(i+temp-1, j+temp);\n    }\n    return memoNeg[i][j] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    if(n == 1) {\n        cout << 0;\n        return 0;\n    }\n\n    for(int j = 1; j <= m; ++j) {\n        int box;\n        cin >> box;\n        --box;\n        //cout << ""diag: "" << j+box << endl;\n        posDiagToJ[j+box].insert(j);\n        negDiagToJ[j-box+n].insert(j);\n    }\n    vector<int> lows(n);\n    vector<int> highs(n);\n    for(int i = 0; i < n; ++i) {\n        lows[i] = solvePos(i,0);\n        highs[i] = solveNeg(i,0);\n    }\n    /*\n    cout << ""lows:\\n"";\n    for(int i = 0; i < n; ++i) {\n        cout << lows[i] << \' \';\n    }\n    cout << ""highs:\\n"";\n    for(int i = 0; i < n; ++i) {\n        cout << highs[i] << \' \';\n    }\n    */\n    int ans = 0;\n    for(int i = 0; i < n; ++i) {\n        ans += highs[i]-lows[i] + 1;\n    }\n    cout << ans << endl;\n}\n']","['binary search', 'data structures', 'dp', 'dsu']",2500
https://codeforces.com//contest/1187/problem/F,F. Expected Square Beauty,Let x be an array of integers x x 1 x 2 dots x n Let s define B x as a minimal size of a partition of x into subsegments such that all elements in each subsegment are equal For example B 3 3 6 1 6 6 6 4 using next partition 3 3 6 1 6 6 6 Now you don t have any exact values of x but you know that x i can be any integer value from l i r i l i le r i uniformly at random All x i are independent Calculate expected value of B x 2 or E B x 2 It s guaranteed that the expected value can be represented as rational fraction frac P Q where P Q 1 so print the value P cdot Q 1 mod 10 9 7 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\n\nll l[nax];\nll r[nax];\n\nll zm2, zm;\n\nll tu[nax];\n\nll dlu[nax];\n\nll dziel(ll a, ll b)\n{\n\t//~ debug() << a << "" "" << b;\n\ta%=mod;\n\tb%=mod;\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &l[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &r[i]);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tll wsz=(r[i]-l[i]+1)*(r[i+1]-l[i+1]+1)%mod;\n\t\tll dob=0;\n\t\tll a=max(l[i], l[i+1]);\n\t\tll b=min(r[i], r[i+1]);\n\t\tif (a<=b)\n\t\t\tdob=b-a+1;\n\t\tdlu[i]=dob;\n\t\tll x=dziel(mod+wsz-dob, wsz);\n\t\tzm=(zm+x)%mod;\n\t\ttu[i]=x;\n\t}\n\tll s=0;\n\t//~ debug() << range(tu+1, tu+1+n);\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tzm2=(zm2+tu[i]*s)%mod;\n\t\ts=(s+tu[i-1])%mod;\n\t}\n\tfor (int i=1; i+2<=n; i++)\n\t{\n\t\tll wsz=(r[i]-l[i]+1)*(r[i+1]-l[i+1]+1)%mod*(r[i+2]-l[i+2]+1)%mod;\n\t\tll a=max(l[i], l[i+1]);\n\t\tll b=min(r[i], r[i+1]);\n\t\ta=max(a, l[i+2]);\n\t\tb=min(b, r[i+2]);\n\t\t//~ debug() << imie(wsz);\n\t\t//~ debug() << imie(dlu[i]*(r[i+2]-l[i+2]+1));\n\t\t//~ debug() << imie(dlu[i+1]*(r[i]-l[i]+1));\n\t\t//~ debug() << imie(max(0LL, b-a+1));\n\t\tzm2+=dziel(wsz-dlu[i]*(r[i+2]-l[i+2]+1)-dlu[i+1]*(r[i]-l[i]+1)+max(0LL, b-a+1), wsz);\n\t\tzm2%=mod;\n\t\tzm2+=mod;\n\t\tzm2%=mod;\n\t}\n\t\n\tdebug() << imie(zm);\n\tdebug() << imie(zm2);\n\t\n\tzm2=(zm2*2+zm)%mod;\n\t\n\tprintf(""%lld\\n"", (zm2+2*zm+1)%mod);\n\treturn 0;\n}\n']","['dp', 'math', 'probabilities']",2500
https://codeforces.com//contest/1520/problem/B,B. Ordinary Numbers,Let s call a positive integer n ordinary if in the decimal notation all its digits are the same For example 1 2 and 99 are ordinary numbers but 719 and 2021 are not ordinary numbers For a given number n find the number of ordinary numbers among the numbers from 1 to n ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl ""\\n""\n\n#define sz(x) int((x).size())\n\nvector<int> ans;\n\nvoid pcomp() {\n\tfor(int i = 1; i < 10; i++) {\n\t\tstring s;\n\t\tfor(int j = 0; j < 9; j++) {\n\t\t\ts += to_string(i);\n\t\t\tans.push_back(stoi(s));\n\t\t}\n\t}\n\tsort(begin(ans), end(ans));\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tcout << upper_bound(begin(ans), end(ans), n) - ans.begin() << endl;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tpcomp();\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']","['brute force', 'math', 'number theory']",800
https://codeforces.com//contest/1580/problem/D,D. Subsequence,Alice has an integer sequence a of length n and She will choose a subsequence of a of length m and defines the value of a subsequence a b 1 a b 2 ldots a b m as sum i 1 m m cdot a b i sum i 1 m sum j 1 m f min b i b j max b i b j where f i j denotes min a i a i 1 ldots a j Alice wants you to help her to maximize the value of the subsequence she choose A sequence s is a subsequence of a sequence t if s can be obtained from t by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nint n, m, a[4005], cnt;\nLL dp[4005][4005];\n\nint solve(int l, int r, int id)\n{\n\tint mid = l;\n\tfor(int i = l + 1; i <= r; i ++) if(a[i] < a[mid]) mid = i;\n\tint siz;\n\tif(l == r) {\n\t\tsiz = 0;\n\t\tdp[id][0] = 0;\n\t} else if(mid == l) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(mid + 1, r, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else if(mid == r) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(l, mid - 1, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else {\n\t\tint tl = cnt;\n\t\tint ls = solve(l, mid - 1, cnt ++);\n\t\tint tr = cnt;\n\t\tint rs = solve(mid + 1, r, cnt ++);\n\t\tsiz = ls + rs;\n\t\tfor(int i = 0; i <= siz; i ++) dp[id][i] = -INF;\n\t\tfor(int i = 0; i <= ls; i ++) for(int j = 0; j <= rs; j ++)\n\t\tdp[id][i + j] = max(dp[id][i + j], dp[tl][i] + dp[tr][j] - 2LL * i * j * a[mid]);\n\t}\n\t\n\tsiz ++; dp[id][siz] = -INF;\n\tfor(int i = siz; i >= 1; i --) dp[id][i] = max(dp[id][i], dp[id][i - 1] + 1LL * (m + 1 - 2 * i) * a[mid]);\n\treturn siz;\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, n) scanf(""%d"", &a[i]);\n\t\n\tcnt = 1;\n\tsolve(0, n - 1, 0);\n\tprintf(""%lld\\n"", dp[0][m]);\n\treturn 0;\n}']","['brute force', 'divide and conquer', 'dp', 'greedy', 'trees']",2900
https://codeforces.com//contest/1508/problem/B,B. Almost Sorted,Seiji Maki doesn t only like to observe relationships being unfolded he also likes to observe sequences of numbers especially permutations Today he has his eyes on permutations A permutation a 1 a 2 dots a n of 1 2 dots n is said to be if the condition a i 1 ge a i 1 holds for all i between 1 and n 1 inclusive Maki is considering the list of all almost sorted permutations of 1 2 dots n given in lexicographical order and he wants to find the k th permutation in this list Can you help him to find such permutation Permutation p is lexicographically smaller than a permutation q if and only if the following holds in the first position where p and q differ the permutation p has a smaller element than the corresponding element in q ,"['#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; int64_t K; cin >> N >> K; K--;\n\t\tif (N <= 62 && K >= (1ll << (N-1))) {\n\t\t\tcout << -1 << \'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> A; A.reserve(N);\n\t\tfor (int i = 0; i < N; ) {\n\t\t\tint j = i+1;\n\t\t\twhile (j < N && N-j-1 <= 62 && K >= (1ll << (N-j-1))) {\n\t\t\t\tK -= (1ll << (N-j-1));\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfor (int z = j-1; z >= i; z--) {\n\t\t\t\tA.push_back(z);\n\t\t\t}\n\t\t\ti = j;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << A[i]+1 << "" \\n""[i+1==N];\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","['binary search', 'combinatorics', 'constructive algorithms', 'implementation']",1800
https://codeforces.com//contest/461/problem/B,B. Appleman and Tree,Appleman has a tree with vertices Some of the vertices at least one are colored black and other vertices are colored white Consider a set consisting of edges of Appleman s tree If Appleman deletes these edges from the tree then it will split into parts Note that each part will be a tree with colored vertices Now Appleman wonders what is the number of sets splitting the tree in such a way that each resulting part will have exactly one black vertex Find this number modulo ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int MAX_N = int(1e5) + 10;\nconst int MOD = int(1e9) + 7;\n\nvoid addIt(int&x, int c) {\n\tx += c;\n\tif (x >= MOD)\n\t\tx -= MOD;\n}\n\nvector<int> E[MAX_N];\nint col[MAX_N];\nint n;\n\nint dp[MAX_N][2]; //white, black\n\nvoid dfs(int u, int par) {\n//\tfor (auto v : E[u])\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint v = *e;\n\t\tif (v != par) {\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n\tvector<int> am(2, 0);\n\tam[col[u]] = 1;\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint v = *e;\n\t\tif (v != par) {\n\t\t\tint*ch = dp[v];\n\t\t\tvector<int> nam(2, 0);\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t//link\n\t\t\t\t\tif (i + j < 2)\n\t\t\t\t\t\taddIt(nam[i + j], 1LL * am[i] * ch[j] % MOD);\n\t\t\t\t\t//cut\n\t\t\t\t\tif (j == 1)\n\t\t\t\t\t\taddIt(nam[i], 1LL * am[i] * ch[j] % MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t\tam = nam;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 2; ++i) {\n\t\tdp[u][i] = am[i];\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint p;\n\t\tscanf(""%d"", &p);\n\t\tE[i].push_back(p), E[p].push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(""%d"", col + i);\n\t}\n\tdfs(0, -1);\n\tcout << dp[0][1] << endl;\n}\n']","['dfs and similar', 'dp', 'trees']",2000
https://codeforces.com//contest/1555/problem/C,C. Coin Rows,Alice and Bob are playing a game on a matrix consisting of 2 rows and m columns The cell in the i th row in the j th column contains a i j coins in it Initially both Alice and Bob are standing in a cell 1 1 They are going to perform a sequence of moves to reach a cell 2 m The possible moves are Move right from some cell x y to x y 1 Move down from some cell x y to x 1 y First Alice makes until she reaches 2 m She collects the coins in all cells she visit including the starting cell When Alice finishes Bob starts his journey He also performs the moves to reach 2 m and collects the coins in all cells that he visited The score of the game is the total number of coins Bob collects Alice wants to minimize the score Bob wants to maximize the score What will the score of the game be if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<int>> a(2, vector<int>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> a[j][k];\n      }\n    }\n    vector<int> S1(m + 1);\n    S1[m] = 0;\n    for (int j = m - 1; j >= 0; j--){\n      S1[j] = S1[j + 1] + a[0][j];\n    }\n    vector<int> S2(m + 1);\n    S2[0] = 0;\n    for (int j = 0; j < m; j++){\n      S2[j + 1] = S2[j] + a[1][j];\n    }\n    int ans = INF;\n    for (int j = 0; j < m; j++){\n      ans = min(ans, max(S1[j + 1], S2[j]));\n    }\n    cout << ans << endl;\n  }\n}']","['brute force', 'constructive algorithms', 'dp', 'implementation']",1300
https://codeforces.com//contest/785/problem/B,B. Anton and Classes,Anton likes to play chess Also he likes to do programming No wonder that he decided to attend chess classes and programming classes Anton has variants when he will attend chess classes th variant is given by a period of time Also he has variants when he will attend programming classes th variant is given by a period of time Anton needs to choose of possible periods of time when he will attend chess classes and of possible periods of time when he will attend programming classes He wants to have a rest between classes so from all the possible pairs of the periods he wants to choose the one where the distance between the periods is maximal The distance between periods and is the minimal possible distance between a point in the first period and a point in the second period that is the minimal possible where and In particular when the periods intersect the distance between them is Anton wants to know how much time his rest between the classes will last in the best case Help Anton and find this number ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\nconst int MX=200111;\nint n,m;\nint l[MX],r[MX],l2[MX],r2[MX];\nint mxl,mnr,mxl2,mnr2;\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;i++)scanf(""%d%d"",&l[i],&r[i]);\n\tscanf(""%d"",&m);\n\tfor(int i=1;i<=m;i++)scanf(""%d%d"",&l2[i],&r2[i]);\n\tmnr=mnr2=0x3f3f3f3f;\n\tfor(int i=1;i<=n;i++)mxl=max(mxl,l[i]),mnr=min(mnr,r[i]);\n\tfor(int i=1;i<=m;i++)mxl2=max(mxl2,l2[i]),mnr2=min(mnr2,r2[i]);\n\tint ans=0;\n\tans=max(ans,mxl2-mnr);\n\tans=max(ans,mxl-mnr2);\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']","['greedy', 'sortings']",1100
https://codeforces.com//contest/187/problem/E,E. Heaven Tour,The story was not finished as PMP thought God offered him one more chance to reincarnate and come back to life But before he can come back God told him that PMP should ask great men including prominent programmers about their life experiences The men are standing on a straight line They are numbered through from left to right The coordinate of the th man is PMP should visit all these people one by one in arbitrary order Each men should be visited At the beginning of his tour he starts at location of th man and asks him about his experiences Each time PMP wants to change his location he should give a ticket to an angel and the angel carries him to his destination Angels take PMP from one location fly to his destination and put him down there Nobody else is visited in this movement Moving from th man to th man takes time PMP can get back to life as soon as he visits all men There are two types of angels Some angels are going to the right and they only accept right tickets Others are going the left and they only accept left tickets There are an unlimited number of angels of each type PMP has left tickets and right tickets PMP wants to get back to life as soon as possible to be able to compete in this year s final instead of the final he missed last year He wants to know the quickest way to visit all the men exactly once He also needs to know the exact sequence moves he should make ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,lt,rt,s;\nint di[101000];\nint dd[101000];\nconst long long INF=10000000000000000ll;\nlong long ans=INF;\nint aid[101000];\nint tid[101000],tt;\nbool flag;\nbool ansf;\nlong long ta;\ninline void cl(){tt=0;}\ninline void pp(int x){tid[tt++]=x;}\ninline void tr(){\n    //for(int i=0;i<tt;i++)printf(""%d "",tid[i]);\n   // puts("""");\n    if(ta<ans){\n        ans=ta;\n        ansf=flag;\n        for(int i=0;i<n-1;i++)aid[i]=tid[i];\n    }\n}\npair<int,int> ev[101000];\nint to[101000];\nbool rev[101000];\ninline void trylr(){\n    if(s==n-1)return;\n    if(rt==0)return;\n    int i,j;\n    if(lt==0){\n        if(s!=0)return;\n        cl();\n        for(i=1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0];\n        tr();\n        return;\n    }\n    if(lt<=s){\n        //puts(""Case 1"");\n        cl();\n        for(i=lt-1;i>=0;i--)pp(i);\n        for(i=lt;i<s;i++)pp(i);\n        for(i=s+1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0]+(long long)di[s]-di[0];\n        tr();\n        return;\n    }else if(rt==1){\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        for(i=n-1;i>s;i--)pp(i);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+(long long)di[n-1]-di[s+1];\n        tr();\n        return;\n    }else{\n        int mo=lt-s;\n        int evc=0;\n        for(i=s+1;i<n-1;i++){\n            ev[evc++]=make_pair(dd[i],i);\n        }\n        sort(ev,ev+evc);\n        for(i=0;i<evc;i++)to[ev[i].second]=i;\n        long long ss=0;\n        int bi=-1;\n        long long ba=INF;\n        set<int> XD;\n        set<int>::iterator pt;\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo-1;i<n;i++){\n            //printf(""i=%d ss=%I64d\\n"",i,ss);\n            if(ba>ss*2+di[n-1]-di[i]){\n                ba=ss*2+di[n-1]-di[i];\n                bi=i;\n            }\n            int toa=i-1;\n            if(i==n-mo-1){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                ss+=ev[*pt].first;\n            }else{\n                if(to[toa]<*pt){\n                    ss+=ev[to[toa]].first;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    ss+=ev[*pt].first;\n                }\n            }\n        }\n        //printf(""ba=%I64d bi=%d\\n"",ba,bi);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+ba;\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        memset(rev,0,sizeof(rev));\n        XD.clear();\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo;i<=bi;i++){\n            int toa=i-1;\n            if(i==n-mo){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                rev[ev[*pt].second]=1;\n            }else{\n                if(to[toa]<*pt){\n                    rev[toa]=1;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    rev[ev[*pt].second]=1;\n                }\n            }\n        }\n        for(i=s+1;i<bi;i=j+1){\n            for(j=i;j<bi-1&&rev[j];j++);\n            for(int q=j;q>=i;q--)pp(q);\n        }\n        for(i=n-1;i>=bi;i--){\n            pp(i);\n        }\n        tr();\n    }\n}\ninline void tryrl(){\n    //puts(""tryrl"");\n    swap(lt,rt);\n    s=n-1-s;\n    int i,j;\n    int l=di[n-1];\n    for(i=0;i<n;i++){\n        di[i]=l-di[i];\n    }\n    for(i=0,j=n-1;i<j;i++,j--)swap(di[i],di[j]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=1;\n    trylr();\n}\nint main(){\n    int i,j,k;\n    scanf(""%d%d%d"",&n,&lt,&s);\n    rt=n-1-lt;\n    s--;\n    for(i=0;i<n;i++)scanf(""%d"",&di[i]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=0;\n    trylr();\n    tryrl();\n    if(ans==INF)puts(""-1"");\n    else{\n        printf(""%I64d\\n"",ans);\n        for(i=0;i<n-1;i++)printf(""%d%c"",ansf?n-aid[i]:aid[i]+1,(i==n-2?\'\\n\':\' \'));\n    }\n}\n\n']","['data structures', 'greedy']",2900
https://codeforces.com//contest/919/problem/B,B. Perfect Number,We consider a positive integer perfect if and only if the sum of its digits is exactly 10 Given a positive integer k your task is to find the k th smallest perfect positive integer ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint k,ans;\n\ninline bool check(int u)\n{\n    int ans=0;\n    while(u)ans+=u%10,u/=10;\n    return ans==10;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>k;\n    for(int i=19;;i++)\n    {\n        if(check(i))ans++;\n        if(ans==k)\n        {\n            cout<<i<<endl;\n            break;\n        }\n    }\n    return 0;\n}']","['binary search', 'brute force', 'dp', 'implementation', 'number theory']",1100
https://codeforces.com//contest/760/problem/A,A. Petr and a calendar,Petr wants to make a calendar for current month For this purpose he draws a table in which columns correspond to weeks a week is seven consequent days from Monday to Sunday rows correspond to weekdays and cells contain dates For example a calendar for January 2017 should look like on the picture Petr wants to know how many columns his table should have given the month and the weekday of the first date of that month Assume that the year is non leap ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int c[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcout.tie(0); cin.tie(0);\n\n\tint n, d; cin >> n >> d;\n\tcout << (c[n - 1] + d - 1 + 6) / 7 << endl;\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/1442/problem/C,C. Graph Transpositions,You are given a directed graph of n vertices and m edges Vertices are numbered from 1 to n There is a token in vertex 1 The following actions are allowed Token movement To move the token from vertex u to vertex v if there is an edge u to v in the graph This action takes 1 second Graph transposition To transpose all the edges in the graph replace each edge u to v by an edge v to u This action takes increasingly more time k th transposition takes 2 k 1 seconds i e the first transposition takes 1 second the second one takes 2 seconds the third one takes 4 seconds and so on The goal is to move the token from vertex 1 to vertex n in the shortest possible time Print this time modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nint N,M;\nint dp[MX][2][21];\npi mn[MX][2];\nvi adj[MX][2];\npi bes[MX];\n\nusing T = pair<pi,pi>; // {transpositions, dist} and {vertex, color} ??\n// priority_queue<T,V<T>,greater<T>> pq;\n\n// BFS minimizing dist for transpositions < 21\n// Dijkstra minimizing {transpositions,dist}\n\n// void ad(pi loc, pi dist) {\n// \tif (dist.f < 21) {\n\n// \t} else {\n// \t\tif ()\n// \t}\n// }\n\nvoid bfs() {\n\tFOR(i,1,N+1) F0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\tdeque<T> todo;\n\tauto upd = [&](pi vertColor, pi info) { // OK\n\t\tif (dp[vertColor.f][vertColor.s][info.f] <= info.s) {\n\t\t\treturn 0;\n\t\t}\n\t\tdp[vertColor.f][vertColor.s][info.f] = info.s;\n\t\treturn 1;\n\t};\n\tauto ad_front = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.push_front({info,vertColor});\n\t};\n\tauto ad_back = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.pb({info,vertColor});\n\t};\n\tad_front({1,0},{0,0});\n\twhile (sz(todo)) { // {transpositions,dist}, {vert,color}\n\t\tT t = todo.ft; todo.pop_front();\n\t\tif (t.f.s > dp[t.s.f][t.s.s][t.f.f]) continue;\n\t\t// dbg(""TRANSPOSITIONS"",""DIST"",""VERT"",""COLOR"",t,adj[t.s.f][t.s.s]);\n\t\tif (t.f.f+1 < 21) ad_front({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad_back({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n}\n\npi dist[MX][2];\n\nvoid dijk() {\n\tdbg(""DIJK"");\n\tFOR(i,1,N+1) F0R(j,2) dist[i][j] = {MOD,MOD}; // transpositions dist\n\tpriority_queue<T,V<T>,greater<T>> todo;\n\tauto ad = [&](pi vertColor, pi info) {\n\t\tif (ckmin(dist[vertColor.f][vertColor.s],info)) {\n\t\t\ttodo.push({info,vertColor});\n\t\t}\n\t};\n\tad({1,0},{0,0});\n\twhile (sz(todo)) {\n\t\tauto t = todo.top(); todo.pop();\n\t\tif (t.f > dist[t.s.f][t.s.s]) continue;\n\t\tad({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n\tpi ans = min(dist[N][0],dist[N][1]);\n\tdbg(""HA"",ans);\n\tps(pow(mi(2),ans.f)-1+ans.s);\n\texit(0);\n\t// pi p = {};\n}\n\nint main() {\n\tsetIO(); re(N,M);\n\tF0R(i,M) {\n\t\tint u,v; re(u,v);\n\t\t// dbg(""ED"",u,v);\n\t\tadj[u][0].pb(v);\n\t\tadj[v][1].pb(u);\n\t}\n\tbfs();\n\tint ans = MOD;\n\tF0R(j,2) F0R(k,21) if (dp[N][j][k] != MOD) {\n\t\t// dbg(""HA"",j,k,dp[N][j][k]);\n\t\tckmin(ans,(1<<k)-1+dp[N][j][k]);\n\t}\n\tif (ans != MOD) {\n\t\tps(ans);\n\t\texit(0);\n\t}\n\tdijk();\n\n\t// FOR(i,1,N+1) {\n\t// \tmn[i] = MOD;\n\t// \tbes[i] = {MOD,MOD};\n\t// \tF0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\t// }\n\t// ad({1,0},{0,0});\n\t// F0R(i,21) {\n\n\t// }\n\t// while (1) {\n\t// \tT p = pq.top(); pq.pop();\n\t// \tif (mn[p.s] < p.f.f && p.f.f >= 21) continue;\n\t// \ttrav(t,adj[][]) {\n\n\t// \t}\n\t// }\n\t// FOR(i,1,N+1) F0R(j,21) dp[i][j] = MOD;\n\t// dp[1][0] = 1;\n\t// F0R(mov,21) {\n\n\t// }\n\t// first get min for each vert\n\t// if some are still not reached\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['dfs and similar', 'graphs', 'greedy', 'shortest paths']",2400
https://codeforces.com//contest/1673/problem/A,A. Subtle Substring Subtraction,Alice and Bob are playing a game with strings There will be t rounds in the game In each round there will be a string s consisting of lowercase English letters Alice moves first and both the players take alternate turns More formally if there was a string s s 1s 2 ldots s k the player can choose a substring s ls l 1 ldots s r 1 s r with length of corresponding parity and remove it After that the string will become s s 1 ldots s l 1 s r 1 ldots s k After the string becomes empty the round ends and each player calculates his her score for this round The score of a player is the sum of values of all characters removed by him her The value of texttt a is 1 the value of texttt b is 2 the value of texttt c is 3 ldots and the value of texttt z is 26 The player with higher score wins the round For each round determine the winner and the difference between winner s and loser s scores Assume that both players play optimally to maximize their score It can be proved that a draw is impossible ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar(\'-\'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nvoid solve(){\n    string a;\n    cin>>a;\n    if(SZ(a)%2==0){\n        int ans=0;\n        for(int i=0;i<SZ(a);i++)ans+=a[i]-\'a\'+1;\n        printf(""Alice %d\\n"",ans);\n    }else{\n        int k1=0,k2=0;\n        for(int i=0;i<SZ(a)-1;i++)k1+=a[i]-\'a\'+1;\n        k1-=a[SZ(a)-1]-\'a\'+1;\n        for(int i=1;i<SZ(a);i++)k2+=a[i]-\'a\'+1;\n        k2-=a[0]-\'a\'+1;\n        if(k1<k2)swap(k1,k2);\n        if(k1>0)printf(""Alice %d\\n"",k1);\n        else printf(""Bob %d\\n"",-k1);\n    }\n}\n\nint main(){\n    int T=read();\n    while(T--)solve();\n    return 0;\n}']","['games', 'greedy', 'strings']",800
https://codeforces.com//contest/165/problem/C,C. Another Problem on Strings,A string is if it consists only of characters and String is a of string if it has a non zero length and can be read starting from some position in string For example string has six substrings Two substrings are considered different if their positions of occurrence are different So if some string occurs multiple times we should consider it the number of times it occurs You are given a binary string Your task is to find the number of its substrings containing exactly characters ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nchar s[1100000];\nint sum[1100000];\nint main(){\n\tint k;\n\twhile( scanf(""%d %s"", &k, s+1)!=EOF ){\n\t\tint len=strlen(s+1);\n\t\trep(i, 1, len+1){\n\t\t\tsum[i]=sum[i-1]+(s[i]==\'1\');\n\t\t}\n\t\tLL ans=0;\n\t\trep(i, 1, len+1){\n\t\t\tint t1=sum[i-1]+k;\n\t\t\tif( sum[len]<t1 ) continue;\n\t\t\tint id1=lower_bound(sum+i, sum+len+1, t1)-sum;\n\t\t\tint id2=upper_bound(sum+i, sum+len+1, t1)-sum;\n\t\t\t\n\t\t\tans+=(id2-id1);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n\n']","['binary search', 'brute force', 'dp', 'math', 'strings', 'two pointers']",1600
https://codeforces.com//contest/1726/problem/C,C. Jatayu's Balanced Bracket Sequence,Last summer Feluda gifted Lalmohan Babu a bracket sequence s of length 2 n Topshe was bored during his summer vacations and hence he decided to draw an undirected graph of 2 n vertices using the s For any two distinct vertices i and j 1 le i j le 2 n Topshe draws an edge undirected and unweighted between these two nodes if and only if the s i ldots j forms a balanced bracket sequence Determine the number of in Topshe s graph See the Notes section for definitions of the underlined terms ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tint N;\n\tstr S;\n\tre(N, S);\n\tstr sofar;\n\tint ans = 0;\n\tchar last_char = \'.\';\n\tfor (char c: S) {\n\t\tif (c == \'(\') {\n\t\t\tif (last_char == \')\') {\n\n\t\t\t} else {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t} else {\n\n\t\t}\n\t\tlast_char = c;\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['data structures', 'dsu', 'graphs', 'greedy']",1300
https://codeforces.com//contest/1098/problem/A,A. Sum in the tree,Mitya has a rooted tree with n vertices indexed from 1 to n where the root has index 1 Each vertex v initially had an integer number a v ge 0 written on it For every vertex v Mitya has computed s v the sum of all values written on the vertices on the path from vertex v to the root as well as h v the depth of vertex v which denotes the number of vertices on the path from vertex v to the root Clearly s 1 a 1 and h 1 1 Then Mitya erased all numbers a v and by accident he also erased all values s v for vertices with even depth vertices with even h v Your task is to restore the values a v for every vertex or determine that Mitya made a mistake In case there are multiple ways to restore the values you re required to find one which minimizes the total sum of values a v for all vertices in the tree ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvi drz[nax];\nint oj[nax];\n\nll tab[nax];\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n\texit(0);\n}\n\nll wyn;\n\nvoid dfs(int v, ll w)\n{\n\tif (tab[v]==-1)\n\t{\n\t\ttab[v]=w;\n\t\tif (!drz[v].empty())\n\t\t{\n\t\t\tfor (int i : drz[v])\n\t\t\t\tif (tab[i]<w)\n\t\t\t\t\tnope();\n\t\t\ttab[v]=tab[drz[v][0]];\n\t\t\tfor (int i : drz[v])\n\t\t\t\ttab[v]=min(tab[v], tab[i]);\n\t\t}\n\t}\n\tif (tab[v]<w)\n\t\tnope();\n\tw=tab[v];\n\twyn+=tab[v]-tab[oj[v]];\n\tfor (int i : drz[v])\n\t\tdfs(i, w);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tint a;\n\t\tscanf(""%d"", &a);\n\t\tdrz[a].push_back(i);\n\t\toj[i]=a;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tdfs(1, 0);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['constructive algorithms', 'dfs and similar', 'greedy', 'trees']",1600
https://codeforces.com//contest/1704/problem/B,B. Luke is a Foodie,Luke likes to eat There are n piles of food aligned in a straight line in front of him The i th pile contains a i units of food Luke will walk from the 1 st pile towards the n th pile and he wants to eat every pile of food without walking back When Luke reaches the i th pile he can eat that pile if and only if v a i leq x where x is a fixed integer and v is Luke s food affinity Before Luke starts to walk he can set v to any integer Also for each i 1 leq i leq n Luke can his food affinity to any integer he eats the i th pile Find the minimum number of needed to eat every pile of food Note that the initial choice for v is considered as a change ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 17:07:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int ans = 0;\n    int beg = 0;\n    while (beg < n) {\n      int end = beg;\n      int mx = a[beg];\n      int mn = a[beg];\n      while (end + 1 < n) {\n        int new_mx = max(mx, a[end + 1]);\n        int new_mn = min(mn, a[end + 1]);\n        if (new_mx - new_mn > 2 * x) {\n          break;\n        }\n        mx = new_mx;\n        mn = new_mn;\n        end += 1;\n      }\n      ans += 1;\n      beg = end + 1;\n    }\n    cout << ans - 1 << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'greedy', 'implementation']",1000
https://codeforces.com//contest/1138/problem/B,B. Circus,Polycarp is a head of a circus troupe There are n an even number artists in the troupe It is known whether the i th artist can perform as a clown if yes then c i 1 otherwise c i 0 and whether they can perform as an acrobat if yes then a i 1 otherwise a i 0 Split the artists into two performances in such a way that each artist plays in exactly one performance the number of artists in the two performances is equal i e equal to frac n 2 the number of artists that can perform as clowns in the first performance is the same as the number of artists that can perform as acrobats in the second performance ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000;\nint n;\nchar s[maxn + 10], t[maxn + 10];\nvector<int> a, b, c, d;\n\nint main() {\n\tscanf(""%d"", &n);\n\tscanf(""%s%s"", s + 1, t + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (s[i] == \'0\' && t[i] == \'0\') a.push_back(i);\n\t\telse if (s[i] == \'1\' && t[i] == \'0\') b.push_back(i);\n\t\telse if (s[i] == \'0\' && t[i] == \'1\') c.push_back(i);\n\t\telse if (s[i] == \'1\' && t[i] == \'1\') d.push_back(i);\n\tfor (int i = 0; i <= (int)b.size(); ++i)\n\t\tfor (int j = 0; j <= (int)d.size(); ++j) {\n\t\t\tint s = (int)c.size() - i - 2 * j + (int)d.size();\n\t\t\tif (s >= 0 && s <= (int)c.size()) {\n\t\t\t\tint all = i + s + j;\n\t\t\t\tint k = n / 2 - all;\n\t\t\t\tif (k >= 0 && k <= (int)a.size()) {\n\t\t\t\t\tfor (int p = 0; p < k; ++p) printf(""%d "", a[p]);\n\t\t\t\t\tfor (int p = 0; p < i; ++p) printf(""%d "", b[p]);\n\t\t\t\t\tfor (int p = 0; p < s; ++p) printf(""%d "", c[p]);\n\t\t\t\t\tfor (int p = 0; p < j; ++p) printf(""%d "", d[p]);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(""-1"");\n}']","['brute force', 'greedy', 'math', 'strings']",1800
https://codeforces.com//contest/867/problem/A,A. Between the Offices,As you may know MemSQL has American offices in both San Francisco and Seattle Being a manager in the company you travel a lot between the two cities always by plane You prefer flying from Seattle to San Francisco than in the other direction because it s warmer in San Francisco You are so busy that you don t remember the number of flights you have made in either direction However for each of the last days you know whether you were in San Francisco office or in Seattle office You always fly at nights so you never were at both offices on the same day Given this information determine if you flew more times from Seattle to San Francisco during the last days or not ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\n#include <utility>\n#include <stack>\n#include <cstring>\n#include <bitset>\n#include <deque>\n#include <string>\n#include <list>\n#include <cstdlib>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 100000 + 100;\ntypedef long long ll;\ntypedef long double ld;\n\nint main()\n{\n\tstring s;\n\tint n;\n\twhile (cin >> n >> s)\n\t{\n\tint sf = 0, fs = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (s[i] == \'S\' && s[i - 1] == \'F\')\n\t\t\t{\n\t\t\t\tfs++;\n\t\t\t}\n\t\t\telse if (s[i] == \'F\' && s[i-1] == \'S\')\n\t\t\t{\n\t\t\t\tsf++;\n\t\t\t}\n\t\t}\n\t\tif (sf > fs)\n\t\t{\n\t\t\tcout << ""YES\\n"";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << ""NO\\n"";\n\t\t}\n\t}\n}']",['implementation'],800
https://codeforces.com//contest/1190/problem/A,A. Tokitsukaze and Discard Items,Recently Tokitsukaze found an interesting game Tokitsukaze had n items at the beginning of this game However she thought there were too many items so now she wants to discard m 1 le m le n special items of them These n items are marked with indices from 1 to n In the beginning the item with index i is placed on the i th position Items are divided into several pages orderly such that each page contains exactly k positions and the last positions on the last page may be left empty Tokitsukaze would do the following operation focus on the first special page that contains at least one special item and at one time Tokitsukaze would discard all special items on this page After an item is discarded or moved its old position would be empty and then the item below it if exists would move up to this empty position The movement may bring many items forward and even into previous pages so Tokitsukaze would keep waiting until all the items stop moving and then do the operation i e check the special page and discard the special items repeatedly until there is no item need to be discarded Tokitsukaze wants to know the number of operations she would do in total ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nll n, k;\nll a[N];\nint m;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%lld%d%lld"", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%lld"", &a[i]);\n\t\ta[i] -= i + 1;\n\t}\n\tint pos = 0;\n\tint ans = 0;\n\twhile(pos < m) {\n\t\tint r = pos + 1;\n\t\twhile(r < m && (a[r] + r - pos) / k == a[pos] / k) r++;\n\t\tans++;\n\t\tpos = r;\n\t}\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","['implementation', 'two pointers']",1400
https://codeforces.com//contest/1358/problem/B,B. Maria Breaks the Self-isolation,Maria is the most active old lady in her house She was tired of sitting at home She decided to organize a ceremony against the coronavirus She has n friends who are also grannies Maria is not included in this number The i th granny is ready to attend the ceremony provided that at the time of her appearance in the courtyard there will be at least a i other grannies there Note that grannies can come into the courtyard at the same time Formally the granny i agrees to come if the number of other grannies who came earlier or at the same time with her is greater than or equal to a i Grannies gather in the courtyard like that Initially only Maria is in the courtyard that is the initial number of grannies in the courtyard is 1 All the remaining n grannies are still sitting at home On each step Maria selects a subset of grannies none of whom have yet to enter the courtyard She promises each of them that at the time of her appearance there will be at least a i other grannies including Maria in the courtyard Maria can call several grannies at once In this case the selected grannies will go out into the courtyard She cannot deceive grannies that is the situation when the i th granny in the moment of appearing in the courtyard finds that now there are strictly less than a i other grannies except herself but including Maria is prohibited Please note that if several grannies appeared in the yard at the same time then each of them sees others at the time of appearance Your task is to find what maximum number of grannies including herself Maria can collect in the courtyard for the ceremony After all the more people in one place during quarantine the more effective the ceremony Consider an example if n 6 and a 1 5 4 5 1 9 then at the first step Maria can call grannies with numbers 1 and 5 each of them will see two grannies at the moment of going out into the yard note that a 1 1 le 2 and a 5 1 le 2 at the second step Maria can call grannies with numbers 2 3 and 4 each of them will see five grannies at the moment of going out into the yard note that a 2 5 le 5 a 3 4 le 5 and a 4 5 le 5 the 6 th granny cannot be called into the yard therefore the answer is 6 Maria herself and another 5 grannies ,"['// Author : PinkRabbit\n#include<bits/stdc++.h>\nusing namespace std;\n#define F(i,a,b) for(int i=a;i<=(b);++i)\n#define F2(i,a,b) for(int i=a;i<(b);++i)\n#define dF(i,a,b) for(int i=a;i>=(b);--i)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define Debug debug(""Passing [%s] in LINE %d\\n"",__FUNCTION__,__LINE__)\n#define MN 300005\n#define MM 600005\n#define ll long long\n#define mod 998244353\n#define inf 0x3f3f3f3f\n#define infll 0x3f3f3f3f3f3f3f3f\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mkp make_pair\n#define fi first\n#define se second\ninline int qpow(int b,ll e,int m=mod){int a=1;for(;e;e>>=1,b=(ll)b*b%m)if(e&1)a=(ll)a*b%m;return a;}\nint n,m,q,k;\nint a[MN],b[MN],f[MN],g[MN];\nvector<int>G[MN];\nint h[MN],nxt[MM],to[MM],tot;\ninline void ins(int x,int y){nxt[++tot]=h[x];to[tot]=y;h[x]=tot;}\nint main(){int tests=1;scanf(""%d"",&tests);\nwhile(tests--){\n\tscanf(""%d"",&n);\n\tF(i,1,n)scanf(""%d"",a+i);\n\tsort(a+1,a+n+1);\n\tint p=0;\n\tF(i,1,n)if(a[i]<=i)p=i;\n\tprintf(""%d\\n"",p+1);\n}\treturn 0;\n}\n']","['greedy', 'sortings']",1000
https://codeforces.com//contest/93/problem/D,D. Flags,When Igor K was a freshman his professor strictly urged him as well as all other freshmen to solve programming Olympiads One day a problem called Flags from a website called Timmy s Online Judge caught his attention In the problem one had to find the number of three colored flags that would satisfy the condition actually it doesn t matter Igor K quickly found the formula and got the so passionately desired Accepted However the professor wasn t very much impressed He decided that the problem represented on Timmy s Online Judge was very dull and simple it only had three possible colors of flag stripes and only two limitations He suggested a complicated task to Igor K and the fellow failed to solve it Of course we won t tell anybody that the professor couldn t solve it as well And how about you Can you solve the problem The flags consist of one or several parallel stripes of similar width The stripes can be one of the following colors white black red or yellow You should find the number of different flags with the number of stripes from to if a flag cannot have adjacent stripes of one color a flag cannot have adjacent white and yellow stripes a flag cannot have adjacent red and black stripes a flag cannot have the combination of black white and red stripes following one after another in this or reverse order symmetrical flags as for example a WB and a BW flag where W and B stand for the white and black colors are considered the same ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007ll\n\n#define D 51\nstruct matrix {ll a[D][D];};\n\nmatrix mat_prod(matrix &A, matrix &B){\n    int i,j,k;\n    matrix ans;\n    REP(i,D) REP(j,D) ans.a[i][j] = 0;\n    REP(i,D) REP(k,D) REP(j,D) ans.a[i][j] = (ans.a[i][j] + A.a[i][k] * B.a[k][j]) % MOD;\n    return ans;\n}\n\nmatrix mat_pow(matrix &A, ll N){\n    int i,j;\n    matrix ans;\n    REP(i,D) REP(j,D) ans.a[i][j] = ((i == j) ? 1 : 0);\n    for(i=62;i>=0;i--) if(N&(1ll<<i)) break;\n    for(;i>=0;i--){\n        ans = mat_prod(ans,ans);\n        if(N&(1ll<<i)) ans = mat_prod(ans,A);\n    }\n    return ans;\n}\n\nll func(int N){\n    int i,j,k;\n    \n    matrix A;\n    REP(i,51) REP(j,51) A.a[i][j] = 0;\n    REP(i,5) REP(j,5) REP(k,4) if(j/2 != k/2 && (j != 2 || i >= 2 || k >= 2 || i == k)){\n        A.a[25+i*5+j][j*5+k]++;\n        A.a[i*5+j][25+j*5+k]++;\n        A.a[25+i*5+j][50]++;\n        A.a[i*5+j][50]++;\n    }\n    A.a[50][50]++;\n    \n    matrix B = mat_pow(A,N);\n    return B.a[24][50];\n}\n\nll func2(int N){\n    return (func(N) + func((N+1)/2)) % MOD;\n}\n\nint main(void){\n    int L,R;\n    \n    cin >> L >> R;\n    ll ans = func2(R);\n    if(L > 1) ans -= func2(L-1);\n    ans = (ans + MOD) % MOD;\n    ans = ans * ((MOD + 1) / 2) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']","['dp', 'math', 'matrices']",2500
https://codeforces.com//contest/1771/problem/A,A. Hossam and Combinatorics,Hossam woke up bored so he decided to create an interesting array with his friend Hazem Now they have an array a of n positive integers Hossam will choose a number a i and Hazem will choose a number a j Count the number of interesting pairs a i a j that meet all the following conditions 1 le i j le n i neq j The absolute difference a i a j must be equal to the maximum absolute difference over all the pairs in the array More formally a i a j max 1 le p q le n a p a q ,"[""#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\n\n// вправо, вниз, влево, вверх\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\n// ход конем\n//int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n//int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::system_clock::now().time_since_epoch().count());\nint rndInteger (int l, int r) {\n    return uniform_int_distribution<int> (l, r)(rnd);\n}\n\nconst int MOD = (int) 998244353;\nconst int N = (int) 1e6 + 7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T;\n    cin >> T;\n    while(T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (auto &e : a) cin >> e;\n        sort(a.begin(), a.end());\n\n        int x = 0, y = 0;\n        for (int w : a)\n            if(w == a[n-1]) ++y;\n            else if(w == a[0]) ++x;\n        if(a[0] == a[n-1]) {\n            cout << n * (ll)(n-1) << '\\n';\n        } else {\n            cout << x * (ll)y * (ll)2 << '\\n';\n        }\n    }\n\n    return 0;\n}\n""]","['combinatorics', 'math', 'sortings']",900
https://codeforces.com//contest/588/problem/B,B. Duff in Love,Duff is in love with lovely numbers A positive integer is called if and only if there is no such positive integer such that is a divisor of Malek has a number store In his store he has only divisors of positive integer and he has all of them As a birthday present Malek wants to give her a number from his store He wants this number to be as big as possible Malek always had issues in math so he asked for your help Please tell him what is the biggest lovely number in his store ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fr(a,b,c) for(int (a) = (b); (a) < (c); ++(a))\n#define rp(a,b) fr(a,0,b)\n#define fre(a,b) for(int a = adj[b]; ~a; a = ant[a])\n#define cl(a,b) memset((a), (b), sizeof(a))\n#define sc(a) scanf(""%d"", &a)\n#define sc2(a,b) scanf(""%d%d"", &a, &b)\n#define sc3(a,b,c) scanf(""%d%d%d"", &a, &b, &c)\n#define scs(s) scanf(""%s"", s)\n#define pri(x) printf(""%d\\n"", x)\n\n#define iter(a) __typeof((a).begin())\n#define fore(a,b) for(iter(b) a = (b).begin(); a != (b).end(); ++a)\n\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n\n#define db(x) cerr << #x << "" == "" << x << endl\n#define dbs(x) cerr << x << endl\n#define _ << "", "" <<\n\nconst int oo = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector< vi > vii;\n\n#define N 2000009\n\nbool p[N];\nint pc, pr[N];\n\nvoid crivo(int n) {\n\tcl(p, 1);\n\tp[0] = p[1] = 0;\n\t\n\tfor(int i = 2; i*i <= n; i++) if (p[i]) {\n\t\tfor(int j = i*i; j <= n; j += i) p[j] = 0;\n\t}\n\t\n\tpc = 0;\n\tfr(i, 2, n+1) if (p[i]) pr[pc++] = i;\n}\n\nint main() {\n\tcrivo(N-4);\n\t\n\tll n;\n\twhile (scanf(""%I64d"", &n) == 1) {\n\t\tint j = 0;\n\t\tll ans = 1;\n\t\twhile(j < pc && n > 1) {\n\t\t\tif (n%pr[j] == 0) {\n\t\t\t\tans *= pr[j];\n\t\t\t\twhile (n%pr[j] == 0) n /= pr[j];\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tans *= n;\n\t\tcout << ans << \'\\n\';\n\t}\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",['math'],1300
https://codeforces.com//contest/835/problem/F,F. Roads in the Kingdom,In the Kingdom K there are towns numbered with integers from to The towns are connected by bi directional roads numbered with integers from to The th road connects the towns and and its length is There is no more than one road between two towns Also there are no roads that connect the towns with itself Let s call the inconvenience of the roads the maximum of the shortest distances between all pairs of towns Because of lack of money it was decided to close down one of the roads so that after its removal it is still possible to reach any town from any other You have to find the minimum possible inconvenience of the roads after closing down one of the roads ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\n#include<list>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct uni\n{\n\tint f[200010];\n\tint find(int x)\n\t{\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y)\n\t{\n\t\tf[find(x)]=find(y);\n\t}\n};\nuni un;\nlist<pii> l[200010];\nll dp[200010];\nint f[200010];\nint d[200010];\nint fsum[200010];\nint vis[200010];\nll dfs(int x,int fa,int dep,int sum2)\n{\n\tfsum[x]=sum2;\n\td[x]=dep;\n\tll s=0;\n\tf[x]=fa;\n\tdp[x]=0;\n\tfor(auto v:l[x])\n\t\tif(v.first!=fa&&!vis[v.first])\n\t\t{\n\t\t\ts=max(s,dfs(v.first,x,dep+1,v.second));\n\t\t\ts=max(s,dp[x]+dp[v.first]+v.second);\n\t\t\tdp[x]=max(dp[x],dp[v.first]+v.second);\n\t\t}\n\treturn s;\n}\nint a1[200010];\nint a2[200010];\nint cnt1,cnt2;\nll presum1[200010];\nll presum2[200010];\nll pref[200010];\nll suff[200010];\nll premax[200010];\nll sufmax[200010];\nll f1[200010];\nll f2[200010];\nint main()\n{\n//\tfreopen(""f.in"",""r"",stdin);\n//\tfreopen(""f.out"",""w"",stdout);\n\tmemset(vis,0,sizeof vis);\n\tint n;\n\tscanf(""%d"",&n);\n\tint x,y,z;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t\tun.f[i]=i;\n\tint sx,sy,sz;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d%d%d"",&x,&y,&z);\n\t\tif(un.find(x)!=un.find(y))\n\t\t{\n\t\t\tl[x].push_back(pii(y,z));\n\t\t\tl[y].push_back(pii(x,z));\n\t\t\tun.merge(x,y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsx=x;\n\t\t\tsy=y;\n\t\t\tsz=z;\n\t\t}\n\t}\n\tll ans=dfs(1,0,1,0);\n\tll ans2=0;\n\tcnt1=cnt2=0;\n\tint last=0;\n\twhile(sx!=sy)\n\t{\n\t\tif(d[sx]>d[sy])\n\t\t{\n\t\t\ta1[++cnt1]=sx;\n\t\t\tpresum1[cnt1]=last;\n\t\t\tlast=fsum[sx];\n\t\t\tsx=f[sx];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta2[++cnt2]=sy;\n\t\t\tpresum2[cnt2]=fsum[sy];\n\t\t\tsy=f[sy];\n\t\t}\n\t}\n\ta1[++cnt1]=sx;\n\tpresum1[cnt1]=last;\n\twhile(cnt2)\n\t{\n\t\tcnt1++;\n\t\ta1[cnt1]=a2[cnt2];\n\t\tpresum1[cnt1]=presum2[cnt2];\n\t\tcnt2--;\n\t}\n\tfor(i=2;i<=cnt1;i++)\n\t\tpresum1[i]+=presum1[i-1];\n\tfor(i=1;i<=cnt1;i++)\n\t\tvis[a1[i]]=1;\n\tll sum=presum1[cnt1];\n\tfor(i=1;i<=cnt1;i++)\n\t{\n\t\tll ans3=dfs(a1[i],0,1,0);\n\t\tans2=max(ans2,ans3);\n\t\tf1[i]=presum1[i]+dp[a1[i]];\n\t\tf2[i]=sum-presum1[i]+dp[a1[i]];\n\t}\n\tfor(i=2;i<=cnt1;i++)\n\t\tf1[i]=max(f1[i],f1[i-1]);\n\tfor(i=cnt1-1;i>=1;i--)\n\t\tf2[i]=max(f2[i],f2[i+1]);\n\tpremax[0]=sufmax[cnt1+1]=0;\n\tpref[0]=suff[cnt1+1]=0;\n\tpresum1[0]=0;\n\tpresum1[cnt1+1]=presum1[cnt1];\n\tfor(i=1;i<=cnt1;i++)\n\t{\n\t\tpremax[i]=max(premax[i-1],pref[i-1]+dp[a1[i]]+presum1[i]-presum1[i-1]);\n\t\tpref[i]=max(dp[a1[i]],pref[i-1]+presum1[i]-presum1[i-1]);\n\t}\n\tfor(i=cnt1;i>=1;i--)\n\t{\n\t\tsufmax[i]=max(sufmax[i+1],suff[i+1]+dp[a1[i]]+presum1[i+1]-presum1[i]);\n\t\tsuff[i]=max(dp[a1[i]],suff[i+1]+presum1[i+1]-presum1[i]);\n\t}\n\tfor(i=1;i<cnt1;i++)\n\t{\n\t\tll s=f1[i]+f2[i+1]+sz;\n\t\ts=max(s,ans2);\n\t\ts=max(s,max(premax[i],sufmax[i+1]));\n\t\tans=min(ans,s);\n\t}\n\tprintf(""%I64d\\n"",ans);\n\treturn 0;\n}']","['dfs and similar', 'dp', 'graphs', 'trees']",2500
https://codeforces.com//contest/1328/problem/A,A. Divisibility Problem,You are given two positive integers a and b In one move you can increase a by 1 replace a with a 1 Your task is to find the minimum number of moves you need to do in order to make a divisible by b It is possible that you have to make 0 moves as a is already divisible by b You have to answer t independent test cases ,"[""// clang-format off\n// powered by c++11\n// by Isaunoya\n#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i=(x);i<=(y);++i)\n#define Rep(i,x,y) for(register int i=(x);i>=(y);--i)\nusing namespace std;using db=double;using ll=long long;\nusing uint=unsigned int;using ull=unsigned long long;\nusing pii=pair<int,int>;\n#define Tp template\n#define fir first\n#define sec second\nTp<class T>void cmax(T&x,const T&y){if(x<y)x=y;}Tp<class T>void cmin(T&x,const T&y){if(x>y)x=y;}\n#define all(v) v.begin(),v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\nTp<class T>void sort(vector<T>&v){sort(all(v));}Tp<class T>void reverse(vector<T>&v){reverse(all(v));}\nTp<class T>void unique(vector<T>&v){sort(all(v)),v.erase(unique(all(v)),v.end());}inline void reverse(string&s){reverse(s.begin(),s.end());}\nconst int SZ=1<<23|233;\nstruct FILEIN{char qwq[SZ],*S=qwq,*T=qwq,ch;\n#ifdef __WIN64\n#define GETC getchar\n#else\ninline char GETC(){return(S==T)&&(T=(S=qwq)+fread(qwq,1,SZ,stdin),S==T)?EOF:*S++;}\n#endif\ninline FILEIN&operator>>(char&c){while(isspace(c=GETC()));return*this;}inline FILEIN&operator>>(string&s){s.clear();while(isspace(ch=GETC()));if(!~ch)return*this;s=ch;while(!isspace(ch=GETC())&&~ch)s+=ch;return*this;}\ninline FILEIN&operator>>(char*str){char*cur=str;while(*cur)*cur++=0;cur=str;while(isspace(ch=GETC()));if(!~ch)return*this;*cur=ch;while(!isspace(ch=GETC())&&~ch)*++cur=ch;*++cur=0;return*this;}\nTp<class T>inline void read(T&x){bool f=0;while((ch=GETC())<48&&~ch)f^=(ch==45);x=~ch?(ch^48):0;while((ch=GETC())>47)x=x*10+(ch^48);x=f?-x:x;}\ninline FILEIN&operator>>(int&x){return read(x),*this;}inline FILEIN&operator>>(ll&x){return read(x),*this;}inline FILEIN&operator>>(uint&x){return read(x),*this;}inline FILEIN&operator>>(ull&x){return read(x),*this;}\ninline FILEIN&operator>>(double&x){read(x);bool f=x<0;x=f?-x:x;if(ch^'.')return*this;double d=0.1;while((ch=GETC())>47)x+=d*(ch^48),d*=.1;return x=f?-x:x,*this;}\n}in;\nstruct FILEOUT{const static int LIMIT=1<<22;char quq[SZ],ST[233];int sz,O,pw[233];\nFILEOUT(){set(7);rep(i,pw[0]=1,9)pw[i]=pw[i-1]*10;}~FILEOUT(){flush();}\ninline void flush(){fwrite(quq,1,O,stdout),fflush(stdout),O=0;}\ninline FILEOUT&operator<<(char c){return quq[O++]=c,*this;}inline FILEOUT&operator<<(string str){if(O>LIMIT)flush();for(char c:str)quq[O++]=c;return*this;}\ninline FILEOUT&operator<<(char*str){if(O>LIMIT)flush();char*cur=str;while(*cur)quq[O++]=(*cur++);return*this;}\nTp<class T>void write(T x){if(O>LIMIT)flush();if(x<0){quq[O++]=45;x=-x;}do{ST[++sz]=x%10^48;x/=10;}while(x);while(sz)quq[O++]=ST[sz--];}\ninline FILEOUT&operator<<(int x){return write(x),*this;}inline FILEOUT&operator<<(ll x){return write(x),*this;}inline FILEOUT&operator<<(uint x){return write(x),*this;}inline FILEOUT&operator<<(ull x){return write(x),*this;}\nint len,lft,rig;void set(int l){len=l;}inline FILEOUT&operator<<(double x){bool f=x<0;x=f?-x:x,lft=x,rig=1.*(x-lft)*pw[len];return write(f?-lft:lft),quq[O++]='.',write(rig),*this;}\n}out;\n#define int long long\nstruct Math{\nvector<int>fac,inv;int mod;\nvoid set(int n,int Mod){fac.resize(n+1),inv.resize(n+1),mod=Mod;rep(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;inv[n]=qpow(fac[n],mod-2);Rep(i,n-1,0)inv[i]=inv[i+1]*(i+1)%mod;}\nint qpow(int x,int y){int ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}int C(int n,int m){if(n<0||m<0||n<m)return 0;return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint gcd(int x,int y){return!y?x:gcd(y,x%y);}int lcm(int x,int y){return x*y/gcd(x,y);}\n}math;\n// clang-format on\nsigned main(){\n\t//code begin.\n\tint _;\n\tin >> _;\n\twhile(_ --) {\n\t\tint a, b;\n\t\tin >> a >> b;\n\t\tint sum = ((a - 1) / b + 1) * b;\n\t\tout << (sum - a) << '\\n';\n\t}\n\treturn 0;\n\t//code end.\n}\n""]",['math'],800
https://codeforces.com//contest/258/problem/D,D. Little Elephant and Broken Sorting,The Little Elephant loves permutations of integers from to very much But most of all he loves sorting them To sort a permutation the Little Elephant repeatedly swaps some elements As a result he must receive a permutation This time the Little Elephant has permutation Its sorting program needs to make exactly moves during the th move it swaps elements that are at that moment located at the th and the th positions But the Little Elephant s sorting program happened to break down and now on every step it can equiprobably either do nothing or swap the required elements Now the Little Elephant doesn t even hope that the program will sort the permutation but he still wonders if he runs the program and gets some permutation how much will the result of sorting resemble the sorted one For that help the Little Elephant find the mathematical expectation of the number of permutation inversions after all moves of the program are completed We ll call a pair of integers an in permutatuon if the following inequality holds ,"['#include <cstdio>\n#include <cstring>\n\nconst int N = 1000;\n\nint n, m, p[N], a[N], b[N];\ndouble prob[N][N];\n\nint main() {\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(""%d"", p + i);\n    }\n    for (int i = 0; i < m; ++ i) {\n        scanf(""%d%d"", a + i, b + i);\n        a[i] --;\n        b[i] --;\n    }\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < n; ++ j) {\n            prob[i][j] = i < j ? 1.0 : 0.0;\n        }\n    }\n    for (int k = m - 1; k >= 0; -- k) {\n        int u = a[k];\n        int v = b[k];\n        for (int i = 0; i < n; ++ i) {\n            if (i != u && i != v) {\n                prob[i][u] = prob[i][v] = (prob[i][u] + prob[i][v]) / 2.0;\n                prob[u][i] = prob[v][i] = (prob[u][i] + prob[v][i]) / 2.0;\n            }\n        }\n        prob[u][v] = prob[v][u] = (prob[u][v] + prob[v][u]) / 2.0;\n    }\n    double answer = 0;\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < n; ++ j) {\n            if (p[i] > p[j]) {\n                answer += prob[i][j];\n            }\n        }\n    }\n    printf(""%.10f\\n"", answer);\n    return 0;\n}\n']","['dp', 'math', 'probabilities']",2600
https://codeforces.com//contest/961/problem/G,G. Partitions,You are given a set of elements indexed from to The weight of th element is The weight of some subset of a given set is denoted as The weight of some partition of a given set into subsets is recall that a partition of a given set is a set of its subsets such that every element of the given set belongs to exactly one subset in partition Calculate the sum of weights of all partitions of a given set into exactly subsets and print it modulo Two partitions are considered different iff there exist two elements and such that they belong to the same set in one of the partitions and to different sets in another partition ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll mypow(ll a, ll b) {\n\tif (b < 0) return 0;\n\tll rv = 1;\n\twhile (b) {\n\t\tif (b % 2) rv = (rv*a) % MOD;\n\t\ta = a*a%MOD;\n\t\tb /= 2;\n\t}\n\treturn rv;\n}\n\nll F[200050];\nll Finv[200050];\n\nll in[200050];\nint main() {\n\tll i, j;\n\tF[0] = 1;\n\tfor (i = 1; i <= 200000; i++) F[i] = F[i - 1] * i % MOD;\n\tfor (i = 0; i <= 200000; i++) Finv[i] = mul_inv(F[i]);\n\n\tint N, K;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) scanf(""%lld"", &in[i]);\n\n\tll a1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tll v1 = F[K - 1];\n\t\tv1 = v1 * Finv[i] % MOD;\n\t\tv1 = v1 * Finv[K - 1 - i] % MOD;\n\n\t\tll v2 = mypow(K - i, N - 1);\n\t\tv2 += mypow(K - i, N - 2) * (N - 1) % MOD;\n\t\tv1 = v1 * v2 % MOD;\n\t\tif (i % 2) a1 = (a1 - v1) % MOD;\n\t\telse a1 = (a1 + v1) % MOD;\n\t}\n\ta1 = (a1 + MOD) % MOD;\n\ta1 = a1 * Finv[K-1] % MOD;\n\n\tll a2 = 0;\n\tfor (i = 1; i <= N; i++) a2 = (a2 + in[i]) % MOD;\n\treturn !printf(""%lld\\n"", a1*a2%MOD);\n}\n']","['combinatorics', 'math', 'number theory']",2700
https://codeforces.com//contest/545/problem/B,B. Equidistant String,Little Susie loves strings Today she calculates distances between them As Susie is a small girl after all her strings contain only digits zero and one She uses the definition of Hamming distance We will define the distance between two strings and of the same length consisting of digits zero and one as the number of positions such that isn t equal to As besides everything else Susie loves symmetry she wants to find for two strings and of length such string of length that the distance from to was equal to the distance from to It s time for Susie to go to bed help her find such string or state that it is impossible ,"['//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    string S,P;\n    cin >> S >> P;\n    int n = S.size();\n    int dis = 0;\n    for(int i = 0; i < n;i++) if(S[i] != P[i]) dis++;\n    if(dis % 2){\n        cout << ""impossible\\n"";\n        return 0;\n    }\n    int c = 0;\n    string ans = """";\n    for(int i = 0; i < n;i++){\n        if(S[i] == P[i]){\n            ans += S[i];\n            continue;\n        }\n        if(c % 2) ans += S[i];\n        else ans += P[i];\n        c++;\n    }\n    cout << ans << endl;\n    return 0;\n    \n}']",['greedy'],1100
https://codeforces.com//contest/1859/problem/D,D. Andrey and Escape from Capygrad,An incident occurred in Capygrad the capital of Tyagoland where all the capybaras in the city went crazy and started throwing mandarins Andrey was forced to escape from the city as far as possible using portals Tyagoland is represented by a number line and the city of Capygrad is located at point 0 There are n portals all over Tyagoland each of which is characterised by four integers l i r i a i and b i 1 le l i le a i le b i le r i le 10 9 Note that the segment a i b i in the segment l i r i If Andrey is on the segment l i r i then the portal can teleport him to any point on the segment a i b i Andrey has a pass that allows him to use the portals an unlimited number of times Andrey thinks that the point x is on the segment l r if the inequality l le x le r is satisfied Andrey has q options for where to start his escape each option is characterized by a single integer x i the starting position of the escape He wants to escape from Capygrad as far as possible to the point with the maximum possible coordinate Help Andrey determine how far he could escape from Capygrad starting at each of the q positions ,"['#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt"")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include""dbg.h""\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return\'\\n\';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between \'\\n\'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<\'0\'||c>\'9\'){if(c==\'-\')f*=-1;c=getchar();}x=0;while(c>=\'0\'&&c<=\'9\'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<\'0\'||c>\'9\')&&c!=\'-\'&&c!=\'.\'){if(c==\'-\')f*=-1;c=getchar();}while(c>=\'0\'&&c<=\'9\'&&c!=\'.\')x=x*10+(c^48),c=getchar();if(c==\'.\')c=getchar();else return x*=f,*this;while(c>=\'0\'&&c<=\'9\')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str[len++]=c,c=getchar();str[len]=\'\\0\';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl=\'\\n\';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<\'\\n\';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar(\'0\'),*this;if(x<0)putchar(\'-\'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar(\'-\'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;putchar(\'.\');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nstruct node\n{\n\tint l,r,a,b;\n};\nbool cmp(node a,node b)\n{\n\treturn a.a<b.a;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.l<b.l;\n}\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>ss;\n\t\tvector<node>a(n);\n\t\tfor(int x=0;x<n;x++)\n\t\t\tcin>>a[x].l>>a[x].r>>a[x].a>>a[x].b,ss.push_back(a[x].l),ss.push_back(a[x].r),ss.push_back(a[x].a),ss.push_back(a[x].b);\n\t\tint q;\n\t\tcin>>q;\n\t\tvector<int>ques(q);\n\t\tfor(int x=0;x<q;x++)\n\t\t\tcin>>ques[x],ss.push_back(ques[x]);\n\t\tsort(a.begin(),a.end(),cmp);\n\t\tvector<node>b;\n\t\tfor(int x=0;x<n;x++)\n\t\t\tif(b.empty()||a[x].a>b.back().b)b.push_back(a[x]);\n\t\t\telse b.back().b=max(b.back().b,a[x].b),b.back().l=min(b.back().l,a[x].l),b.back().r=max(b.back().r,a[x].r);\n\t\treverse(b.begin(),b.end());\n\t\tmultiset<int>st;\n\t\tpriority_queue<pair<int,int>>pq;\n\t\tset<pair<int,int>>ans;\n\t\tans.insert({-10000000000,-10000000000});\n\t\tfor(auto q:b)\n\t\t{\n\t\t\twhile(!pq.empty()&&pq.top().first>q.b)st.erase(st.find(pq.top().second)),pq.pop();\n\t\t\tint res=q.b;\n\t\t\tif(!st.empty())res=max(res,*st.rbegin());\n\t\t\tst.insert(res);\n\t\t\tpq.push({q.l,res});\n\t\t\tans.insert({q.l,res});\n\t\t}\n\t\tfor(auto q:ques)\n\t\t\tcout<<max(q,prev(ans.upper_bound({q,10000000000}))->second)<<\' \';cout<<endl;\n\t}\n}']","['binary search', 'data structures', 'dp', 'dsu', 'greedy', 'sortings']",1800
https://codeforces.com//contest/1860/problem/E,E. Fast Travel Text Editor,You are given a string s consisting of lowercase Latin letters There s a cursor initially placed between two adjacent letters of the string The cursor can t be placed before the first or after the last letter In one move you can perform one of three actions move a cursor one position to the left if that doesn t place it before the first letter move a cursor one position to the right if that doesn t place it after the last letter let x be the letter immediately to the left of the cursor and y be the letter immediately to the right of the cursor Choose any pair of letters in the string such that the of them is x and the of them is y and move the cursor to the position between these two letters You are asked m queries In each query you are given two integers f and t which correspond to two valid positions of the cursor in the string In response to the query you have to calculate the minimum number of operations required to move the cursor from position f to position t ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    std::vector<int> p[26][26];\n    for (int i = 0; i < n - 1; i++) {\n        p[s[i] - \'a\'][s[i + 1] - \'a\'].push_back(i);\n    }\n    \n    std::vector dis(26, std::vector(26, std::vector(n - 1, -1)));\n    for (int a = 0; a < 26; a++) {\n        for (int b = 0; b < 26; b++) {\n            if (!p[a][b].empty()) {\n                std::queue<int> q;\n                bool vis[26][26] {};\n                vis[a][b] = true;\n                for (auto i : p[a][b]) {\n                    dis[a][b][i] = 0;\n                    q.push(i);\n                }\n                \n                while (!q.empty()) {\n                    int x = q.front();\n                    q.pop();\n                    \n                    if (x > 0 && dis[a][b][x - 1] == -1) {\n                        dis[a][b][x - 1] = dis[a][b][x] + 1;\n                        q.push(x - 1);\n                    }\n                    if (x < n - 2 && dis[a][b][x + 1] == -1) {\n                        dis[a][b][x + 1] = dis[a][b][x] + 1;\n                        q.push(x + 1);\n                    }\n                    \n                    int l = s[x] - \'a\', r = s[x + 1] - \'a\';\n                    if (!vis[l][r]) {\n                        vis[l][r] = true;\n                        for (auto i : p[l][r]) {\n                            if (dis[a][b][i] == -1) {\n                                dis[a][b][i] = dis[a][b][x] + 1;\n                                q.push(i);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    int m;\n    std::cin >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        x--, y--;\n        \n        int ans = std::abs(x - y);\n        for (int a = 0; a < 26; a++) {\n            for (int b = 0; b < 26; b++) {\n                if (!p[a][b].empty()) {\n                    ans = std::min(ans, dis[a][b][x] + dis[a][b][y] + 1);\n                }\n            }\n        }\n        std::cout << ans << ""\\n"";\n    }\n    \n    return 0;\n}\n']","['data structures', 'dfs and similar', 'graphs', 'shortest paths']",2400
https://codeforces.com//contest/1904/problem/F,F. Beautiful Tree,Lunchbox has a tree of size n rooted at node 1 Each node is then assigned a value Lunchbox considers the tree to be beautiful if each value is distinct and ranges from 1 to n In addition a beautiful tree must also satisfy m requirements of 2 types The node with the smallest value on the path between nodes a and b must be located at c The node with the largest value on the path between nodes a and b must be located at c Now you must assign values to each node such that the resulting tree is beautiful If it is impossible to do so output 1 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e6 + 5;\nconst int M = 3e7 + 5;\nint n, m, op[N], A[N], B[N], C[N];\nvector<int> tr[N];\n\nint dep[N], fa[N], sz[N], son[N];\n\nvoid dfs1(int u, int pre) {\n\tdep[u] = dep[pre] + 1, fa[u] = pre, sz[u] = 1;\n\tfor (int v : tr[u]) {\n\t\tif (v == pre) continue;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t\tif (sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\n\nint st[N], ed[N], id[N], top[N], cnt;\n\nvoid dfs2(int u, int tp) {\n\tst[u] = ++cnt, id[cnt] = u, top[u] = tp;\n\tif (son[u]) dfs2(son[u], tp);\n\tfor (int v : tr[u])\n\t\tif (v != fa[u] && v != son[u])\n\t\t\tdfs2(v, v);\n\ted[u] = cnt;\n}\n\nstruct Edge {\n\tint to, next;\n} e[M];\n\nint head[N], deg[N], cnte;\n\ninline void addedge(int u, int v) {\n\te[++cnte] = Edge{v, head[u]}, head[u] = cnte;\n\t++deg[v];\n}\n\nint prf_in[N], prf_out[N], tot;\n\n#define ls(x) (x << 1)\n#define rs(x) (x << 1 | 1)\n\nint ver_in[N], ver_out[N];\n\nvoid build(int x = 1, int l = 1, int r = n) {\n\tif (l == r) {\n\t\tver_in[x] = ver_out[x] = id[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(x), l, mid);\n\tbuild(rs(x), mid + 1, r);\n\tver_in[x] = ++tot, ver_out[x] = ++tot;\n\taddedge(ver_in[x], ver_in[ls(x)]);\n\taddedge(ver_in[x], ver_in[rs(x)]);\n\taddedge(ver_out[ls(x)], ver_out[x]);\n\taddedge(ver_out[rs(x)], ver_out[x]);\n}\n\nvoid addin(int L, int R, int s, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(s, ver_in[x]);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addin(L, R, s, ls(x), l, mid);\n\tif (R > mid) addin(L, R, s, rs(x), mid + 1, r);\n}\n\nvoid addout(int L, int R, int t, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(ver_out[x], t);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addout(L, R, t, ls(x), l, mid);\n\tif (R > mid) addout(L, R, t, rs(x), mid + 1, r);\n}\n\nint q[N], ans[N];\n\ninline void toposort() {\n\tint l = 1, r = 0, res = 0;\n\tfor (int i = 1; i <= tot; ++i)\n\t\tif (!deg[i]) q[++r] = i;\n\twhile (l <= r) {\n\t\tint u = q[l++];\n\t\tif (u <= n) ans[u] = ++res;\n\t\tfor (int i = head[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\t--deg[v];\n\t\t\tif (!deg[v]) q[++r] = v;\n\t\t}\n\t}\n\tif (r < tot) {\n\t\tcout << ""-1\\n"";\n\t} else {\n\t\tfor (int i = 1; i <= n; ++i) cout << ans[i] << \' \';\n\t\tcout << \'\\n\';\n\t}\n}\n\ninline void treeaddanc(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\telse addedge(prf_out[x], v);\n\t\tx = fa[top[x]];\n\t}\n\tif (y == x) return;\n\tif (op == 1) addin(st[y] + 1, st[x], v);\n\telse addout(st[y] + 1, st[x], v);\n}\n\ninline void treeadd(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] >= dep[top[y]]) {\n\t\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\t\telse addedge(prf_out[x], v);\n\t\t\tx = fa[top[x]];\n\t\t} else {\n\t\t\tif (op == 1) addedge(v, prf_in[y]);\n\t\t\telse addedge(prf_out[y], v);\n\t\t\ty = fa[top[y]];\n\t\t}\n\t}\n\tif (dep[x] < dep[y]) {\n\t\tif (op == 1) addin(st[x], st[y], v);\n\t\telse addout(st[x], st[y], v);\n\t} else {\n\t\tif (op == 1) addin(st[y], st[x], v);\n\t\telse addout(st[y], st[x], v);\n\t}\n} \n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= m; ++i) cin >> op[i] >> A[i] >> B[i] >> C[i];\n\tdfs1(1, 0);\n\tdfs2(1, 1);\n\ttot = n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tprf_in[i] = ++tot;\n\t\tprf_out[i] = ++tot;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\taddedge(prf_in[i], i);\n\t\taddedge(i, prf_out[i]);\n\t\tif (i != top[i]) {\n\t\t\taddedge(prf_in[i], prf_in[fa[i]]);\n\t\t\taddedge(prf_out[fa[i]], prf_out[i]);\n\t\t}\n\t}\n\tbuild();\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (A[i] == B[i]) continue;\n\t\tif (A[i] != C[i]) {\n\t\t\tif (st[A[i]] >= st[C[i]] && ed[A[i]] <= ed[C[i]]) treeaddanc(A[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], A[i], op[i], C[i]);\n\t\t}\n\t\tif (B[i] != C[i]) {\n\t\t\tif (st[B[i]] >= st[C[i]] && ed[B[i]] <= ed[C[i]]) treeaddanc(B[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], B[i], op[i], C[i]);\n\t\t}\n\t}\n\ttoposort();\n\treturn 0;\n}\n']","['data structures', 'dfs and similar', 'graphs', 'implementation', 'trees']",2800
https://codeforces.com//contest/1692/problem/A,A. Marathon,You are given four integers a b c d Timur and three other people are running a marathon The value a is the distance that Timur has run and b c d correspond to the distances the other three participants ran Output the number of participants in front of Timur ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""A""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int T;\n    cin >> T;\n    while(T--) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        int ans = 0;\n        if (b > a)\n            ans++;\n        if (c > a)\n            ans++;\n        if (d > a)\n            ans++;\n        cout << ans << endl;\n    }\n}']",['implementation'],800
https://codeforces.com//contest/1586/problem/E,E. Moment of Bloom,Hu Tao being the little prankster she is has tried to scare you with this graph problem You are given a connected undirected graph of n nodes with m edges You also have q queries Each query consists of two nodes a and b Initially all edges in the graph have a weight of 0 For each query you must choose a simple path starting from a and ending at b Then you add 1 to every edge along this path Determine if it s possible after processing all q queries for all edges in this graph to have an even weight If so output the choice of paths for each query If it is not possible determine the smallest number of extra queries you could add to make it possible It can be shown that this number will not exceed 10 18 under the given constraints A simple path is defined as any path that does not visit a node more than once An edge is said to have an even weight if its value is divisible by 2 ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q, qu[300005], qv[300005], par[300005], dep[300005], C[300005];\nvector<int> G[300005];\nbool vis[300005];\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\trep(i, G[v].size()) {\n\t\tint u = G[v][i];\n\t\tif(!vis[u]) {\n\t\t\tpar[u] = v; dep[u] = dep[v] + 1; dfs(u);\n\t\t}\n\t}\n}\n\nvector<int> A0, A1;\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, m) {\n\t\tint u, v;\n\t\tscanf(""%d%d"", &u, &v);\n\t\tG[v].push_back(u); G[u].push_back(v);\n\t}\n\tdfs(1);\n\t\n\tscanf(""%d"", &q);\n\trep(i, q) {\n\t\tscanf(""%d%d"", &qu[i], &qv[i]);\n\t\tC[qu[i]] ^= 1; C[qv[i]] ^= 1;\n\t}\n\tint tot = 0;\n\trep1(i, n) tot += C[i];\n\tif(tot != 0) {\n\t\tprintf(""NO\\n%d\\n"", tot / 2); return 0;\n\t}\n\tprintf(""YES\\n"");\n\trep(i, q) {\n\t\tint x = qu[i], y = qv[i];\n\t\tA0.clear(); A1.clear();\n\t\twhile(x != y) if(dep[x] > dep[y]) {\n\t\t\tA0.push_back(x); x = par[x];\n\t\t} else {\n\t\t\tA1.push_back(y); y = par[y];\n\t\t}\n\t\treverse(A1.begin(), A1.end());\n\t\tprintf(""%d\\n"", (int)A0.size() + (int)A1.size() + 1);\n\t\trep(j, A0.size()) printf(""%d "", A0[j]);\n\t\tprintf(""%d"", x);\n\t\trep(j, A1.size()) printf("" %d"", A1[j]);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'dfs and similar', 'dsu', 'graph matchings', 'graphs', 'greedy', 'trees']",2200
https://codeforces.com//contest/1646/problem/F,F. Playing Around the Table,There are n players numbered from 1 to n sitting around a round table The i 1 th player sits to the right of the i th player for 1 le i n and the 1 st player sits to the right of the n th player There are n 2 cards each of which has an integer between 1 and n written on it For each integer from 1 to n there are exactly n cards having this number Initially all these cards are distributed among all the players in such a way that each of them has exactly n cards In one operation each player chooses one of his cards and passes it to the player to his right All these actions are performed Player i is called if all his cards have the integer i written on them Their objective is to reach a configuration in which everyone is solid Find a way to do it using at most n 2 n operations You do need to minimize the number of operations ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    vector c(n, vector<int>(n));\n    vector<vector<int>> ans;\n    for (int i = 0; i < n; i += 1)\n        for (int j = 0; j < n; j += 1) {\n            cin >> c[i][j];\n            c[i][j] -= 1;\n        }\n    while (true) {\n        int ready = 1;\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) {\n                if (p[j]) ready = 0;\n                p[j] = 1;\n            }\n        }\n        if (ready) break;\n        vector<int> d(n);\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) p[j] += 1;\n            while (d[i] < n and p[d[i]] <= 1) d[i] += 1;\n        }\n        for (int k = 0; k < 2; k += 1)\n            for (int i = 0; i < n; i += 1)\n                if (d[(i + 1) % n] == n)\n                    d[(i + 1) % n] = d[i];\n        ans.push_back(d);\n        for (int i = 0; i < n; i += 1) {\n            for (int& j : c[i])\n                if (j == d[i]) {\n                    j = d[(i + n - 1) % n];\n                    break;\n                }\n        }\n    }\n    for (int i = 1; i < n; i += 1)\n        for (int j = 0; j < i; j += 1) {\n            vector<int> d(n);\n            for (int k = 0; k < n; k += 1) d[k] = (k + i + n - j) % n;\n            ans.push_back(d);\n            for (int i = 0; i < n; i += 1) {\n                for (int& j : c[i])\n                    if (j == d[i]) {\n                        j = d[(i + n - 1) % n];\n                        break;\n                    }\n            }\n        }\n    for (int i = 0; i < n; i += 1)\n        for (int j : c[i])\n            assert(i == j);\n    cout << ans.size() << ""\\n"";\n    for (auto ansi : ans) {\n        for (int ansij : ansi) cout << ansij + 1 << "" "";\n        cout << ""\\n"";\n    }\n    return 0;\n}']","['constructive algorithms', 'greedy', 'implementation']",2900
https://codeforces.com//contest/309/problem/B,B. Context Advertising,Advertising has become part of our routine And now in the era of progressive technologies we need your ideas to make advertising better In this problem we ll look at a simplified version of context advertising You ve got a text consisting of exactly words A standard advertising banner has exactly lines each line can contain at most characters The potential customer always likes it when they can see lots of advertising so you should determine which maximum number of consecutive words from the text can be written on the banner Single words in one line of the banner should be separated by spaces You are allowed to insert more than one space at once Note that you are not allowed to break the words that is each word in the text must occupy exactly one line in the banner Besides you cannot change the word order that is if you read the banner text consecutively from top to bottom and from left to right you should get some consecutive part of the advertisement text More formally the statement can be written like that Let s say that all words are indexed from to in the order in which they occur in the advertisement text Then you have to choose all words starting from some th one and ending with some th one so that all of them could be written on the banner There must be as many words as possible See the samples for clarifications ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\n#define MAXN 1000010\n\nchar buf[6000010];\n\nint N, R, C;\nstring S[MAXN];\n\nint A[MAXN];\nint ASum[MAXN];\nint to[MAXN];\n\nint crt[MAXN], nxt[MAXN];\n\nvoid solve(int e) {\n\tint i;\n\tif (e == 0) {\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tcrt[i] = i;\n\t\t}\n\t\treturn;\n\t}\n\tsolve(e / 2);\n\tfor (i = 0; i <= N; ++i) {\n\t\tnxt[i] = crt[crt[i]];\n\t}\n\tif (e % 2 != 0) {\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tcrt[i] = to[nxt[i]];\n\t\t}\n\t} else {\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tcrt[i] = nxt[i];\n\t\t}\n\t}\n}\n\nint main() {\n\tint i, j, r;\n\t\n\tfor (; ~scanf(""%d%d%d"", &N, &R, &C); ) {\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tscanf(""%s"", buf);\n\t\t\tS[i] = buf;\n\t\t}\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tA[i] = S[i].size() + 1;\n\t\t}\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tASum[i + 1] = ASum[i] + A[i];\n\t\t}\n\t\tfor (j = 0, i = 0; i <= N; ++i) {\n\t\t\tfor (; j <= N && ASum[j] - ASum[i] <= C + 1; ++j);\n\t\t\t--j;\n\t\t\tto[i] = j;\n\t\t}\n// cout<<""to : "";pv(to,to+N+1);\n\t\tsolve(R);\n// cout<<""crt : "";pv(crt,crt+N+1);\n\t\tint opt = -1;\n\t\tint im = -1;\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tif (opt < crt[i] - i) {\n\t\t\t\topt = crt[i] - i;\n\t\t\t\tim = i;\n\t\t\t}\n\t\t}\n\t\tfor (r = 0; r < R; ++r) {\n\t\t\tif (im == to[im]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = im; i < to[im]; ++i) {\n\t\t\t\tif (i > im) printf("" "");\n\t\t\t\tprintf(""%s"", S[i].c_str());\n\t\t\t}\n\t\t\tputs("""");\n\t\t\tim = to[im];\n\t\t}\ncerr<<""====""<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n']","['dp', 'two pointers']",2100
https://codeforces.com//contest/300/problem/D,D. Painting Square,Vasily the bear has got a large square white table of rows and columns The table has got a black border around this table Vasily the bear wants to paint his square table in exactly moves Each move is sequence of actions The bear chooses some square inside his table At that the square must have a black border painted around it Also the square shouldn t contain a black cell The number of cells in the square shouldn t be less than The bear chooses some row and some column inside the chosen square Then he paints each cell of this row and this column inside the chosen square After that the rectangles formed by the square s border and the newly painted cells must be squares of a non zero area The bear already knows numbers and Help him find the number of ways to paint the square in exactly moves Two ways to paint are called distinct if the resulting tables will differ in at least one cell As the answer can be rather large print the remainder after dividing it by ,"['//program 300-D\n\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint Get()\n{\n  char c;\n  while(c=getchar(),c<\'0\'||c>\'9\');\n  int X=0;\n  while(c>=\'0\'&&c<=\'9\')\n    {\n      X=X*10+c-48;\n      c=getchar();\n    }\n  return X;\n}\n\nconst int Mod=7340033;\n\nint main()\n{\n  static int DP[30][1001];\n  memset(DP,0,sizeof(DP));\n  DP[0][0]=1;\n  for(int i=1;i<30;i++)\n    {\n      static long long Calc[5][1001];\n      memset(Calc,0,sizeof(Calc));\n      Calc[0][0]=1;\n      for(int j=1;j<=4;j++)\n        for(int k=0;k<=1000;k++)\n          for(int x=0;x<=k;x++)\n            Calc[j][k]=(Calc[j][k]+Calc[j-1][k-x]*DP[i-1][x])%Mod;\n      for(int j=0;j<=1000;j++)\n        if(!j)\n          DP[i][j]=1;\n        else\n          DP[i][j]=Calc[4][j-1];\n    }\n  int Test=Get();\n  while(Test--)\n    {\n      int N=Get(),K=Get();\n      int Len=0;\n      while((N&1)&&(N>1))\n        {\n          N/=2;\n          Len++;\n        }\n      printf(""%d\\n"",DP[Len][K]);\n    }\n  return 0;\n}\n']","['dp', 'fft']",2300
https://codeforces.com//contest/1807/problem/A,A. Plus or Minus,You are given three integers a b and c such that of these two equations is true a b c a b c Output if the first equation is true and otherwise ,"['#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        if (a + b == c) cout << ""+\\n"";\n        else cout << ""-\\n"";\n    }\n}\n']",['implementation'],800
https://codeforces.com//contest/1766/problem/C,C. Hamiltonian Wall,Sir Monocarp Hamilton is planning to paint his wall The wall can be represented as a grid consisting of 2 rows and m columns Initially the wall is completely white Monocarp wants to paint a black picture on the wall In particular he wants cell i j the j th cell in the i th row to be colored black if c i j and to be left white if c i j Additionally he wants each column to have at least one black cell so for each j the following constraint is satisfied c 1 j c 2 j or both of them will be equal to In order for the picture to turn out smooth Monocarp wants to place down a paint brush in some cell x 1 y 1 and move it along the path x 1 y 1 x 2 y 2 dots x k y k so that for each i x i y i and x i 1 y i 1 share a common side all black cells appear in the path white cells don t appear in the path Determine if Monocarp can paint the wall ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<char>> c(2, vector<char>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> c[j][k];\n      }\n    }\n    vector<bool> ok(2, true);\n    int cnt = 0;\n    for (int j = 0; j < m; j++){\n      if (c[0][j] == \'B\' && c[1][j] == \'B\'){\n        cnt++;\n      }\n      if (c[0][j] == \'W\'){\n        ok[cnt % 2] = false;\n      }\n      if (c[1][j] == \'W\'){\n        ok[1 - cnt % 2] = false;\n      }\n    }\n    if (ok[0] || ok[1]){\n      cout << ""YES"" << endl;\n    } else {\n      cout << ""NO"" << endl;\n    }\n  }\n}']","['dp', 'implementation']",1300
https://codeforces.com//contest/63/problem/E,E. Sweets Game,Karlsson has visited Lillebror again They found a box of chocolates and a big whipped cream cake at Lillebror s place Karlsson immediately suggested to divide the sweets fairly between Lillebror and himself Specifically to play together a game he has just invented with the chocolates The winner will get the cake as a reward The box of chocolates has the form of a hexagon It contains 19 cells for the chocolates some of which contain a chocolate The players move in turns During one move it is allowed to eat one or several chocolates that lay in the neighboring cells on one line parallel to one of the box s sides The picture below shows the examples of allowed moves and of an unacceptable one The player who cannot make a move loses Karlsson makes the first move as he is Lillebror s guest and not vice versa The players play optimally Determine who will get the cake ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst char *a[15]={\n  ""abc"",\n  ""defg"",\n  ""hijkl"",\n  ""mnop"",\n  ""qrs"",\n  ""adh"",\n  ""beim"",\n  ""cfjnq"",\n  ""gkor"",\n  ""lps"",\n  ""cgl"",\n  ""bfkp"",\n  ""aejos"",\n  ""dinr"",\n  ""hmq"",\n};\n\nchar s[5];\n\nvector <int> moves;\nset <int> was;\n\nint ans[(1<<19) + 239];\n\nint main (void)\n{\n  for (int i=0; i<15; i++)\n  {\n    int l = strlen(a[i]);\n    for (int j=0; j<l; j++)\n      for (int k=j; k<l; k++)\n      {\n        int mask = 0;\n        for (int t=j; t<=k; t++)\n          mask |= (1 << (a[i][t] - \'a\'));\n        if (!was.count(mask)) {\n          was.insert(mask);\n          moves.push_back(mask);\n//          cout << mask << endl;\n        }\n      }\n  }\n\n  int mask = 0;\n  for (int i=0; i<19; i++) {\n    scanf(""%s"", s);\n    if (s[0] != \'.\')\n      mask |= (1 << i);\n  }\n\n  ans[0] = 1;\n  for (int i=1; i < (1 << 19); i++) \n  {\n    int win = 0;\n    for (int j=0; j<(int)moves.size() && !win; j++) {\n      if ((i | moves[j]) == i && ans[i ^ moves[j]]) \n        win = 1;\n    }\n    ans[i] = 1 - win;\n  }\n\n  cout << (ans[mask] ? ""Lillebror"" : ""Karlsson"") << endl;\n\n  return 0;\n}']","['bitmasks', 'dfs and similar', 'dp', 'games', 'implementation']",2000
https://codeforces.com//contest/1896/problem/D,D. Ones and Twos,You are given a 1 indexed array a of length n where each element is 1 or 2 Process q queries of the following two types check if there exists a subarray dagger of a whose sum equals to s change a i to v dagger An array b is a subarray of an array a if b can be obtained from a by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end In particular an array is a subarray of itself ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\nint tab[nax];\n\nint fen[nax];\n\nvoid pisz(int v, int x)\n{\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tfen[i]+=x;\n}\n\nint czyt(int v)\n{\n\tint ret=0;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n}\n\nset<int> jed;\n\nint pier()\n{\n\tif (jed.empty())\n\t\treturn n+1;\n\treturn (*jed.begin());\n}\n\nint ost()\n{\n\tif (jed.empty())\n\t\treturn 0;\n\tauto it=jed.end();\n\tit--;\n\treturn (*it);\n}\n\nvoid test()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfen[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t\tpisz(i, tab[i]);\n\tjed.clear();\n\tfor (int i=1; i<=n; i++)\n\t\tif (tab[i]==1)\n\t\t\tjed.insert(i);\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(""%d"", &typ);\n\t\tif (typ==2)\n\t\t{\n\t\t\tint x, w;\n\t\t\tscanf(""%d%d"", &x, &w);\n\t\t\tpisz(x, -tab[x]);\n\t\t\tif (tab[x]==1)\n\t\t\t\tjed.erase(x);\n\t\t\ttab[x]=w;\n\t\t\tpisz(x, tab[x]);\n\t\t\tif (tab[x]==1)\n\t\t\t\tjed.insert(x);\n\t\t\tcontinue;\n\t\t}\n\t\tint s;\n\t\tscanf(""%d"", &s);\n\t\tif (czyt(n)<s)\n\t\t{\n\t\t\tans(0);\n\t\t\tcontinue;\n\t\t}\n\t\tint bsa=0;\n\t\tint bsb=n;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb+2)>>1;\n\t\t\tif (czyt(bss)<=s)\n\t\t\t\tbsa=bss;\n\t\t\telse\n\t\t\t\tbsb=bss-1;\n\t\t}\n\t\tif (czyt(bsa)==s)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ost()>bsa)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pier()<=n-bsa)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tans(0);\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['binary search', 'data structures', 'divide and conquer', 'math', 'two pointers']",1700
https://codeforces.com//contest/1005/problem/C,C. Summarize to the Power of Two,A sequence a 1 a 2 dots a n is called good if for each element a i there exists an element a j i ne j such that a i a j is a power of two that is 2 d for some non negative integer d For example the following sequences are good 5 3 11 for example for a 1 5 we can choose a 2 3 Note that their sum is a power of two Similarly such an element can be found for a 2 and a 3 1 1 1 1023 7 39 89 25 89 Note that by definition an empty sequence with a length of 0 is good For example the following sequences are not good 16 for a 1 16 it is impossible to find another element a j such that their sum is a power of two 4 16 for a 1 4 it is impossible to find another element a j such that their sum is a power of two 1 3 2 8 8 8 for a 3 2 it is impossible to find another element a j such that their sum is a power of two You are given a sequence a 1 a 2 dots a n What is the minimum number of elements you need to remove to make it good You can delete an arbitrary set of elements ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n    map<int, int> A;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        A[x]++;\n    }\n\n    int sc = 0;\n\n    for (auto i : A) {\n\n        bool t = 0;\n        int x = (i.ft);\n\n        for (int j = 1; j < 34; j++) {\n            int y = (1 << j) - x;\n            if (y > 0 && A.count(y) && (y != x) || (y == x && A[y] > 1)) {\n                t = 1;\n                break;\n            }\n        }\n\n        if (!t) sc += i.sd;\n    }\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n']","['brute force', 'greedy', 'implementation']",1300
https://codeforces.com//contest/474/problem/A,A. Keyboard,Our good friend Mole is trying to code a big message He is typing on an unusual keyboard with characters arranged in following way qwertyuiopasdfghjkl zxcvbnm Unfortunately Mole is blind so sometimes it is problem for him to put his hands accurately He accidentally moved both his hands with one position to the left or to the right That means that now he presses not a button he wants but one neighboring button left or right as specified in input We have a sequence of characters he has typed and we want to find the original message ,"['#include <cstdio>\n#include <cstring>\n\nconst char kT[][32] = {""qwertyuiop"", ""asdfghjkl;"", ""zxcvbnm,./""};\nchar x[256], y[256];\n\nint main() {\n    for (int i = 0; i < 3; ++ i) {\n        int n = strlen(kT[i]);\n        for (int j = 0; j < n; ++ j) {\n            x[kT[i][j]] = i;\n            y[kT[i][j]] = j;\n        }\n    }\n    char cmd[2], buf[128];\n    scanf(""%s"", cmd);\n    scanf(""%s"", buf);\n    int n = strlen(buf);\n    for (int i = 0; i < n; ++ i) {\n        int r = x[buf[i]], c = y[buf[i]];\n        if (cmd[0] == \'R\') {\n            -- c;\n        } else {\n            ++ c;\n        }\n        putchar(kT[r][c]);\n    }\n    puts("""");\n    return 0;\n}\n']",['implementation'],900
https://codeforces.com//contest/1208/problem/F,F. Bits And Pieces,You are given an array a of n integers You need to find the maximum value of a i a j a k over all triplets i j k such that i j k Here denotes the bitwise AND operation and denotes the bitwise OR operation ,"[""/**\n *    author:  tourist\n *    created: 25.08.2019 18:01:53       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int BITS = 21;\nconst int MAX = (1 << BITS);\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<pair<int, int>> bests(MAX, make_pair(-1, -1));\n  auto Update = [&](pair<int, int>& p, int v) {\n    if (v > p.first) {\n      p.second = p.first;\n      p.first = v;\n    } else {\n      p.second = max(p.second, v);\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    Update(bests[a[i]], i);\n  }\n  for (int j = 0; j < BITS; j++) {\n    for (int i = 0; i < MAX; i++) {\n      if (i & (1 << j)) {\n        Update(bests[i ^ (1 << j)], bests[i].first);\n        Update(bests[i ^ (1 << j)], bests[i].second);\n      }\n    }\n  }\n  auto Can = [&](int num, int high) {\n    for (int i = 0; i < n; i++) {\n      int x = (a[i] ^ num) & high;\n      if (bests[x].second > i) {\n        return true;\n      }\n    }\n    return false;\n  };\n  int ans = 0;\n  int high = 0;\n  for (int j = BITS - 1; j >= 0; j--) {\n    high += (1 << j);\n    if (Can(ans + (1 << j), high)) {\n      ans += (1 << j);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","['bitmasks', 'dfs and similar', 'dp', 'greedy']",2600
https://codeforces.com//contest/1815/problem/C,C. Between,You are given an integer n as well as m pairs of integers a i b i where 1 leq a i b i leq n a i ne b i You want to construct a sequence satisfying the following requirements All elements in the sequence are integers between 1 and n There is exactly one element with value 1 in the sequence For each i 1 le i le m between any two elements on different positions in the sequence with value a i there is at least one element with value b i The sequence constructed has the length among all possible sequences satisfying the above properties Sometimes it is possible that such a sequence can be arbitrarily long in which case you should output Otherwise you should output and the sequence itself If there are multiple possible constructions that yield the maximum length output any ,"['/**\n *    author:  tourist\n *    created: 09.04.2023 11:03:05       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[y].push_back(x);\n    }\n    vector<int> d(n, -1);\n    vector<int> que(1, 0);\n    d[0] = 1;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (d[u] == -1) {\n          que.push_back(u);\n          d[u] = d[que[b]] + 1;\n        }\n      }\n    }\n    if (*min_element(d.begin(), d.end()) == -1) {\n      cout << ""INFINITE"" << \'\\n\';\n      continue;\n    }\n    cout << ""FINITE"" << \'\\n\';\n    vector<vector<int>> at(n + 1);\n    for (int i = 0; i < n; i++) {\n      at[d[i]].push_back(i);\n    }\n    vector<int> seq;\n    for (int from = 1; from <= n; from++) {\n      for (int val = n; val >= from; val--) {\n        for (int x : at[val]) {\n          seq.push_back(x);\n        }\n      }\n    }\n    cout << seq.size() << \'\\n\';\n    for (int i = 0; i < (int) seq.size(); i++) {\n      cout << seq[i] + 1 << "" \\n""[i == (int) seq.size() - 1];\n    }\n  }\n  return 0;\n}\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']",2200
https://codeforces.com//contest/1612/problem/F,F. Armor and Weapons,Monocarp plays a computer game There are n different sets of armor and m different weapons in this game If a character equips the i th set of armor and wields the j th weapon their power is usually equal to i j but some combinations of armor and weapons synergize well Formally there is a list of q ordered pairs and if the pair i j belongs to this list the power of the character equipped with the i th set of armor and wielding the j th weapon is not i j but i j 1 Initially Monocarp s character has got only the 1 st armor set and the 1 st weapon Monocarp can obtain a new weapon or a new set of armor in one hour If he wants to obtain the k th armor set or the k th weapon he must possess a combination of an armor set and a weapon that gets his power to k Of course after Monocarp obtains a weapon or an armor set he can use it to obtain new armor sets or weapons but he can go with any of the older armor sets and or weapons as well Monocarp wants to obtain the n th armor set the m th weapon What is the minimum number of hours he has to spend on it ,"['// xtqqwq\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,q;\nmap<int,int> a[200005];\nint d[61][200005];\n\nint main(){\n\tn=readint(); m=readint(); q=readint();\n\tint x,y;\n\tfor(int i=1;i<=q;i++){\n\t\tx=readint(); y=readint();\n\t\ta[x][y]=1;\n\t}\n\tmemset(d,-0x3f,sizeof(d));\n\td[0][1]=1;\n\tint ans=1<<30;\n\tfor(int i=0;i<60;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(d[i][j]<0) continue;\n\t\t\tchkmax(d[i+1][j],min(m,d[i][j]+j+(int)a[j].count(d[i][j])));\n\t\t\tchkmax(d[i+1][min(d[i][j]+j+(int)a[j].count(d[i][j]),n)],d[i][j]);\n\t\t}\n\t\tif(d[i+1][n]>=m) return printf(""%d\\n"",i+1),0;\n\t\tint cnt=i;\n\t\tif(d[i][n]>=0){\n\t\t\tfor(int j=d[i][n];j<m;j+=n+(int)a[n].count(j)) cnt++;\n\t\t\tchkmin(ans,cnt);\n\t\t}\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tif(d[i][j]==m){\n\t\t\t\tcnt=i;\n\t\t\t\tfor(int k=j;k<n;k+=m+(int)a[k].count(m)) cnt++;\n\t\t\t\tchkmin(ans,cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}']","['brute force', 'dp', 'greedy', 'shortest paths']",2800
https://codeforces.com//contest/675/problem/B,B. Restoring Painting,Vasya works as a watchman in the gallery Unfortunately one of the most expensive paintings was stolen while he was on duty He doesn t want to be fired so he has to quickly restore the painting He remembers some facts about it The painting is a square each cell contains a single integer from to and different cells may contain either different or equal integers The sum of integers in each of four squares is equal to the sum of integers in the top left square Four elements and are known and are located as shown on the picture below Help Vasya find out the number of distinct squares the satisfy all the conditions above Note that this number may be equal to meaning Vasya remembers something wrong Two squares are considered to be different if there exists a cell that contains two different integers in different squares ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ll n, a, b, c, d, ans = 0;\n    cin >> n >> a >> b >> c >> d;\n    for (int i = 1; i <= n; i++)\n    {\n        ll x1, x2, x3, x4, x5;\n        x1 = i;\n        x2 = x1 + b - c;\n        x4 = x1 + a - d;\n        x5 = x4 + b - c;\n        int cnt = 0;\n        if (x1 >= 1 && x1 <= n) cnt++;\n        if (x2 >= 1 && x2 <= n) cnt++;\n        if (x4 >= 1 && x4 <= n) cnt++;\n        if (x5 >= 1 && x5 <= n) cnt++;\n        if (cnt == 4) ans++;\n    }\n    cout << ans * n;\n\n    return 0;\n}\n']","['brute force', 'constructive algorithms', 'math']",1400
https://codeforces.com//contest/1832/problem/D1,D1. Red-Blue Operations  Easy Version , You are given an array consisting of n integers Initially all elements are red You can apply the following operation to the array multiple times During the i th operation you select an element of the array then if the element is red it increases by i and becomes blue if the element is blue it decreases by i and becomes red The operations are numbered from 1 i e during the first operation some element is changed by 1 and so on You are asked q queries of the following form given an integer k what can the largest minimum in the array be if you apply k operations to it Note that the operations don t affect the array between queries all queries are asked on the initial array a ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 1E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector<i64> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::sort(a.begin(), a.end());\n    \n    std::vector<i64> f(n + 1, inf);\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = std::min(f[i] + 1, a[i] + 1);\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    while (q--) {\n        i64 k;\n        std::cin >> k;\n        \n        if (k < n) {\n            std::cout << std::min(f[k], a[k]) << "" "";\n        } else {\n            i64 ans;\n            i64 s = sum;\n            if ((k - n) % 2 == 0) {\n                ans = f[n] + k - n;\n                s += 1LL * n * (k + k - n + 1) / 2 - (k - n) / 2;\n            } else {\n                ans = std::min(a[n - 1], f[n - 1] + k - (n - 1));\n                s += 1LL * (n - 1) * (k + k - n + 2) / 2 - (k - n + 1) / 2;\n            }\n            ans = std::min(1LL * ans, s >= 0 ? s / n : (s - n + 1) / n);\n            std::cout << ans << "" "";\n        }\n    }\n    std::cout << ""\\n"";\n    \n    return 0;\n}']","['binary search', 'greedy', 'implementation', 'math']",2100
https://codeforces.com//contest/311/problem/A,A. The Closest Pair,Currently Tiny is learning Computational Geometry When trying to solve a problem called The Closest Pair Of Points In The Plane he found that a code which gave a wrong time complexity got Accepted instead of Time Limit Exceeded The problem is the follows Given points in the plane find a pair of points between which the distance is minimized Distance between and is The pseudo code of the unexpected code is as follows input nfor i from 1 to n input the i th point s coordinates into p i sort array p by increasing of x coordinate first and increasing of y coordinate secondd INF here INF is a number big enoughtot 0for i from 1 to n for j from i 1 to n tot if p j x p i x d then break notice that break is only to be out of the loop for j d min d distance p i p j output dHere can be regarded as the running time of the code Due to the fact that a computer can only run a limited number of operations per second should not be more than in order not to get Time Limit Exceeded You are a great hacker Would you please help Tiny generate a test data and let the code get Time Limit Exceeded ,"['#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fo(i,n) for(int i=1;i<=n;i++)\n#define fe(i,n) for(__typeof(n.begin()) i=n.begin();i!=n.end();i++)\nint n,k;\nint main()\n{\n\tcin>>n>>k;\n\tif(k>=n*(n-1)/2)\n\t\tputs(""no solution"");\n\telse\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(""1 %d\\n"",i);\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation']",1300
https://codeforces.com//contest/1535/problem/E,E. Gold Transfer,You are given a rooted tree Each vertex contains a i tons of gold which costs c i per one ton Initially the tree consists only a root numbered 0 with a 0 tons of gold and price c 0 per ton There are q queries Each query has one of two types Add vertex i where i is an index of query as a son to some vertex p i vertex i will have a i tons of gold with c i per ton It s guaranteed that c i c p i For a given vertex v i consider the simple path from v i to the root We need to purchase w i tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy x tons of gold in some vertex v the remaining amount of gold in it decreases by x of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst int LOG = 19;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int q, a0, c0;\n  cin >> q >> a0 >> c0;\n  vector<int> A(1), C(1);\n  A[0] = a0;\n  C[0] = c0;\n  int N = 1;\n  vector<int> d(1, 0);\n  vector<int> P(1, -1);\n  vector<vector<int>> pp(LOG, vector<int>(1, -1));\n  vector<int> id(q + 1, -1);\n  id[0] = 0;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 1){\n      id[i + 1] = N;\n      int p, a, c;\n      cin >> p >> a >> c;\n      p = id[p];\n      P.push_back(p);\n      A.push_back(a);\n      C.push_back(c);\n      int d2 = d[p] + 1;\n      d.push_back(d2);\n      pp[0].push_back(p);\n      for (int j = 0; j < LOG - 1; j++){\n        if (pp[j][N] == -1){\n          pp[j + 1].push_back(-1);\n        } else {\n          pp[j + 1].push_back(pp[j][pp[j][N]]);\n        }\n      }\n      N++;\n    }\n    if (t == 2){\n      int v, w;\n      cin >> v >> w;\n      v = id[v];\n      if (A[v] == 0){\n        cout << 0 << ' ' << 0 << endl;\n      } else {\n        int p = v;\n        for (int j = LOG - 1; j >= 0; j--){\n          int p2 = pp[j][p];\n          if (p2 != -1){\n            if (A[p2] > 0){\n              p = p2;\n            }\n          }\n        }\n        int D = d[v] - d[p];\n        int ans1 = 0;\n        long long ans2 = 0;\n        for (int j = D; j >= 0; j--){\n          int v2 = v;\n          for (int k = 0; k < LOG; k++){\n            if ((j >> k & 1) == 1){\n              v2 = pp[k][v2];\n            }\n          }\n          int a = min(A[v2], w);\n          ans1 += a;\n          ans2 += (long long) C[v2] * a;\n          w -= a;\n          A[v2] -= a;\n          if (w == 0){\n            break;\n          }\n        }\n        cout << ans1 << ' ' << ans2 << endl;\n      }\n    }\n  }\n}""]","['binary search', 'data structures', 'dp', 'greedy', 'interactive', 'trees']",2200
https://codeforces.com//contest/139/problem/B,B. Wallpaper,Having bought his own apartment Boris decided to paper the walls in every room Boris s flat has rooms each of which has the form of a rectangular parallelepiped For every room we known its length width and height of the walls in meters different rooms can have different dimensions including height Boris chose types of wallpaper to paper the walls of the rooms with but it is not necessary to use all the types Each type of wallpaper is sold in rolls of a fixed length and width the length naturally shows how long the unfolded roll will be In addition for each type we know the price of one roll of this type The wallpaper of each type contains strips running along the length of the roll When gluing the strips must be located strictly vertically so the roll cannot be rotated even if the length is less than the width Besides a roll can be cut in an arbitrary manner but the joints of glued pieces should also be vertical In addition each room should be papered by only one type of wallpaper And pieces of the same roll cannot be used to paper different rooms That is for each room the rolls are purchased separately Also some rolls can be used not completely After buying an apartment Boris is short of cash so he wants to spend the minimum money on wallpaper Help him ,"['#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, s, t) for(i = (s); i < (t); i++)\n#define RFOR(i, s, t) for(i = (s)-1; i >= (t); i--)\n\nint a[512], b[512], p[512];\nint a1[512], b1[512], c1[512];\n\nint main()\n{\n  #ifdef __FIO\n  freopen(""in.txt"", ""r"", stdin);\n  freopen(""out.txt"", ""w"", stdout);\n  #endif\n  int n, m;\n  int i, j, k;\n  int ans, tans;\n  cin>>n;\n  for(i = 0; i < n; i++)\n    cin>>a1[i]>>b1[i]>>c1[i];\n  cin>>m;\n  for(i = 0; i < m; i++)\n    cin>>a[i]>>b[i]>>p[i];\n  ans = 0;\n  for(i = 0; i < n; i++)\n  {\n    a1[i] = (a1[i]+b1[i])*2;\n    tans = 1<<20;\n    for(j = 0; j < m; j++)\n    {\n      k = (a[j]/c1[i]) * b[j];\n      if(k)\n      {\n        tans = min(tans, (a1[i]+k-1)/k * p[j]);\n      }\n    }\n    ans += tans;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n']","['implementation', 'math']",1600
https://codeforces.com//contest/808/problem/G,G. Anthem of Berland,Berland has a long and glorious history To increase awareness about it among younger citizens King of Berland decided to compose an anthem Though there are lots and lots of victories in history of Berland there is the one that stand out the most King wants to mention it in the anthem as many times as possible He has already composed major part of the anthem and now just needs to fill in some letters King asked you to help him with this work The anthem is the string of no more than small Latin letters and question marks The most glorious victory is the string of no more than small Latin letters You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string in string is maximal Note that the occurrences of string in can overlap Check the third example for clarification ,"['#include<cstdio>\n#include<cstring>\nchar s1[100007],s2[100007];\nint fa[100007],f[100007],g[100007];\nbool is[100007];\nvoid maxs(int&a,int b){if(a<b)a=b;}\nint main(){\n\tscanf(""%s%s"",s1+1,s2+1);\n\tint l1=strlen(s1+1),l2=strlen(s2+1);\n\tfor(int i=2,j=0;i<=l2;++i){\n\t\twhile(j&&s2[i]!=s2[j+1])j=fa[j];\n\t\tif(s2[i]==s2[j+1])++j;\n\t\tfa[i]=j;\n\t}\n\tfor(int i=l2;i<=l1;++i){\n\t\tis[i]=1;\n\t\tfor(int a=0;a<l2;++a)if(s1[i-a]!=\'?\'&&s1[i-a]!=s2[l2-a]){\n\t\t\tis[i]=0;\n\t\t\tbreak;\n\t\t}\n\t\tg[i]=g[i-1];\n\t\tif(is[i]){\n\t\t\tf[i]=g[i-l2];\n\t\t\tfor(int j=fa[l2];j;j=fa[j]){\n\t\t\t\tmaxs(f[i],f[i-(l2-j)]);\n\t\t\t}\n\t\t\t++f[i];\n\t\t\tmaxs(g[i],f[i]);\n\t\t}\n\t}\n\tprintf(""%d"",g[l1]);\n\treturn 0;\n}']","['dp', 'strings']",2300
https://codeforces.com//contest/257/problem/E,E. Greedy Elevator,The floor office of international corporation CodeForces has the advanced elevator control system established It works as follows All office floors are sequentially numbered with integers from 1 to At time the elevator is on the first floor the elevator is empty and nobody is waiting for the elevator on other floors Next at times people come to the elevator For simplicity we assume that one person uses the elevator only once during the reported interval For every person we know three parameters the time at which the person comes to the elevator the floor on which the person is initially and the floor to which he wants to go The movement of the elevator between the floors is as follows At time is an integer the elevator is always at some floor First the elevator releases all people who are in the elevator and want to get to the current floor Then it lets in all the people waiting for the elevator on this floor If a person comes to the elevator exactly at time then he has enough time to get into it We can assume that all of these actions going in or out from the elevator are made instantly After that the elevator decides which way to move and at time the elevator gets to the selected floor The elevator selects the direction of moving by the following algorithm If the elevator is empty and at the current time no one is waiting for the elevator on any floor then the elevator remains at the current floor Otherwise let s assume that the elevator is on the floor number Then elevator calculates the directions priorities and is the sum of the number of people waiting for the elevator on the floors with numbers greater than and the number of people in the elevator who want to get to the floors with the numbers greater than is the sum of the number of people waiting for the elevator on the floors with numbers less than and the number of people in the elevator who want to get to the floors with the numbers less than If then the elevator goes one floor above the current one that is from floor to floor otherwise the elevator goes one floor below the current one that is from floor to floor Your task is to simulate the work of the elevator and for each person to tell the time when the elevator will get to the floor this person needs Please note that the elevator is large enough to accommodate all the people at once ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef long long int64;\n\nstruct Event\n{\n\tint floor, idx, target;\n\tfriend bool operator == (Event a, Event b)\n\t{\n\t\treturn a.idx == b.idx && a.floor == b.floor;\n\t}\n\tfriend bool operator < (Event a, Event b)\n\t{\n\t\treturn a.floor < b.floor || a.floor == b.floor && a.idx < b.idx;\n\t}\n\tstatic Event Null()\n\t{\n\t\tEvent ret;\n\t\tret.idx = -1;\n\t\treturn ret;\n\t}\n\tEvent(){}\n\tEvent(int a, int b, int c)\n\t{\n\t\tfloor = a, idx = b, target = c;\n\t}\n};\n\nstruct NODE{Event Val; int Pry, Size; struct NODE *L, *R;};\ntypedef struct NODE *TNODE;\n\nTNODE Head, Null;\n\ninline void Update(TNODE &Root){Root->Size= 1 + Root->L->Size + Root->R->Size;}\n\ninline void RotateLeft(TNODE &Root)\n{\n    TNODE Temp= Root->L;\n    Root->L= Temp->R;\n    Temp->R= Root;\n    Update(Root); Update(Temp);\n    Root= Temp;\n}\n\ninline void RotateRight(TNODE &Root)\n{\n    TNODE Temp= Root->R;\n    Root->R= Temp->L;\n    Temp->L= Root;\n    Update(Root); Update(Temp);\n    Root= Temp;\n}\n\nvoid Insert(TNODE &Root, Event Val)\n{\n    if(Root == Null)\n    {\n        Root= new(NODE);\n        Root->Val= Val;\n        Root->Size= 1;\n        Root->Pry= rand();\n        Root->L= Root->R= Null;\n        return ;\n    }\n    if(Root->Val < Val)\n    {\n        Insert(Root->R, Val);\n        if(Root->R->Pry < Root->Pry)RotateRight(Root);\n    }\n    else\n    {\n        Insert(Root->L, Val);\n        if(Root->L->Pry < Root->Pry)RotateLeft(Root);\n    }\n    Update(Root);\n}\n\nEvent FindNext(TNODE &Root, Event Val)\n{\n    if(Root == Null)return Event::Null();\n    if(Root->Val.floor < Val.floor)return FindNext(Root->R, Val);\n    Event Tmp= FindNext(Root->L, Val);\n    if(Tmp.idx != -1)return Tmp; else return Root->Val;\n}\n\nEvent FindPrev(TNODE &Root, Event Val)\n{\n    if(Root == Null)return Event::Null();\n    if(Val.floor < Root->Val.floor)return FindPrev(Root->L, Val);\n    Event Tmp= FindPrev(Root->R, Val);\n    if(Tmp.idx != -1)return Tmp; else return Root->Val;\n}\n\nint GetUp(TNODE &Root, int cur)\n{\n\tif(Root == Null)\n\t\treturn 0;\n\tif(Root->Val.floor > cur)\n\t\treturn Root->R->Size + 1 + GetUp(Root->L, cur);\n\treturn GetUp(Root->R, cur);\n}\n\nint GetDown(TNODE &Root, int cur)\n{\n\tif(Root == Null)\n\t\treturn 0;\n\tif(Root->Val.floor < cur)\n\t\treturn Root->L->Size + 1 + GetDown(Root->R, cur);\n\treturn GetDown(Root->L, cur);\n}\n\nvoid Delete(TNODE &Root, Event Val)\n{\n\tif(Root == Null)\n\t{\n\t\tprintf(""Delete Failed.\\n"");\n\t\texit(0);\n\t}\n\tif(Root->Val == Val)\n\t{\n\t\tif(Root->L == Null && Root->R == Null)\n\t\t{\n\t\t\tfree(Root);Root= Null; return ;\n\t\t}\n\t\tif(Root->L->Pry < Root->R->Pry)\n\t\t{\n\t\t\tRotateLeft(Root);\n\t\t\tDelete(Root->R, Val);\n\t\t}else\n\t\t{\n\t\t\tRotateRight(Root);\n\t\t\tDelete(Root->L, Val);\n\t\t}\n\t\tUpdate(Root);\n\t\treturn ;\n\t}\n\tif(Val < Root->Val)Delete(Root->L, Val);else Delete(Root->R, Val);\n\tUpdate(Root);\n}\n\nstruct Passenger\n{\n\tint t, s, f, idx;\n\tstatic bool Compare(Passenger a, Passenger b)\n\t{\n\t\treturn a.t < b.t;\n\t}\n}a[100005];\n\nint64 ans[100005];\n\nint n, m;\nint64 tick;\nint step;\n\nvoid Handle(Event x)\n{\n\tif(x.target == -1)\n\t{\n\t\t//printf(""Arrived : tick=%I64d, floor=%d, idx=%d\\n"", tick, x.floor, x.idx);\n\t\t++ step;\n\t\tans[x.idx] = tick;\n\t\tDelete(Head, x);\n\t}else\n\t{\n\t\t//printf(""Entered : tick=%I64d, floor=%d, target=%d, idx=%d\\n"", tick, x.floor, x.target, x.idx);\n\t\tDelete(Head, x);\n\t\tInsert(Head, Event(x.target, x.idx, -1));\n\t}\n}\n\nint main()\n{\n\tNull= new(NODE);\n\tNull->Val.idx = -1;\n    Null->Size= 0;\n    Null->Pry= 0x7fffffff;\n    Head= Null;\n\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i(1); i <= n; ++ i)\n\t{\n\t\tscanf(""%d%d%d"", &a[i].t, &a[i].s, &a[i].f);\n\t\ta[i].idx = i;\n\t}\n\tstd::sort(a + 1, a + 1 + n, Passenger::Compare);\n\tint pos = 1;\n\n\tEvent cur;\n\tcur.floor = 1;\n\twhile(step < n)\n\t{\n\t\tEvent Tmp;\n\t\twhile((Tmp = FindNext(Head, cur)).idx != -1)\n\t\t{\n\t\t\tif(Tmp.floor != cur.floor)\n\t\t\t\tbreak;\n\t\t\tHandle(Tmp);\n\t\t}\n\t\tif(step == n)\n\t\t\tbreak;\n\t\tif(Head->Size == 0)\n\t\t{\n\t\t\ttick = a[pos].t;\n\t\t\tfor(; pos <= n && a[pos].t == tick; ++ pos)\n\t\t\t{\n\t\t\t\t//printf(""Insert : tick=%I64d, cur=%d, floor=%d, idx=%d\\n"", tick, cur.floor, a[pos].s, a[pos].idx);\n\t\t\t\tInsert(Head, Event(a[pos].s, a[pos].idx, a[pos].f));\n\t\t\t}\n\t\t}else\n\t\t{\n\t\t\tint64 nextTime = tick;\n\t\t\tint Up = GetUp(Head, cur.floor), Down = GetDown(Head, cur.floor);\n\t\t\tEvent Next = FindNext(Head, cur), Prev = FindPrev(Head, cur);\n\t\t\tif(Up >= Down)\n\t\t\t\tnextTime += Next.floor - cur.floor;\n\t\t\telse\n\t\t\t\tnextTime += cur.floor - Prev.floor;\n\t\t\tif(pos <= n && a[pos].t <= nextTime)\n\t\t\t{\n\t\t\t\tint64 old = tick;\n\t\t\t\ttick = a[pos].t;\n\t\t\t\tfor(; pos <= n && a[pos].t == tick; ++ pos)\n\t\t\t\t{\n\t\t\t\t\t//printf(""Insert : tick=%I64d, cur=%d, floor=%d, idx=%d\\n"", tick, cur.floor, a[pos].s, a[pos].idx);\n\t\t\t\t\tInsert(Head, Event(a[pos].s, a[pos].idx, a[pos].f));\n\t\t\t\t}\n\t\t\t\tcur.floor = Up >= Down ? cur.floor + tick - old : cur.floor - tick + old;\n\t\t\t}else\n\t\t\t{\n\t\t\t\ttick = nextTime;\n\t\t\t\tcur.floor = Up >= Down ? Next.floor : Prev.floor;\n\t\t\t}\n\t\t}\n\n\t}\n\tfor(int i(1); i <= n; ++ i)\n\t\tprintf(""%I64d\\n"", ans[i]);\n}\n']","['data structures', 'implementation']",2200
https://codeforces.com//contest/1619/problem/B,B. Squares and Cubes,Polycarp likes squares and cubes of positive integers Here is the beginning of the sequence of numbers he likes 1 4 8 9 For a given number n count the number of integers from 1 to n that Polycarp likes In other words find the number of such x that x is a square of a positive integer number or a cube of a positive integer number or both a square and a cube simultaneously ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll n,m,t,vas,k,u;\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n;\n        vas=0;\n        for(int i=1; i<100000; i++){\n            m=(ll) i*i;\n            if(m<=n) vas++;\n            k=(ll) m*i;\n            u=sqrt(k);\n            if(k<=n && (u*u!=k)) vas++;\n        }\n        cout<<vas<<""\\n"";\n    }\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/1472/problem/D,D. Even-Odd Game,During their New Year holidays Alice and Bob play the following game using an array a of n integers Players take turns Alice moves first Each turn a player chooses any element and removes it from the array If Alice chooses then she adds it to her score If the chosen value is odd Alice s score does not change Similarly if Bob chooses then he adds it to his score If the chosen value is even then Bob s score does not change If there are no numbers left in the array then the game ends The player with the highest score wins If the scores of the players are equal then a draw is declared For example if n 4 and a 5 2 7 3 then the game could go as follows there are other options On the first move Alice chooses 2 and get two points Her score is now 2 The array a is now 5 7 3 On the second move Bob chooses 5 and get five points His score is now 5 The array a is now 7 3 On the third move Alice chooses 7 and get no points Her score is now 2 The array a is now 3 On the last move Bob chooses 3 and get three points His score is now 8 The array a is empty now Since Bob has more points at the end of the game he is the winner You want to find out who will win if both players play optimally ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nint a[N_MAX];\n\nvector <int> x, y;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        x.clear();\n        y.clear();\n        for(int i = 1; i <= n; i++)\n        {\n            x.push_back(0);\n            y.push_back(0);\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            if(a[i] & 1)\n                y.push_back(a[i]);\n            else\n                x.push_back(a[i]);\n        }\n        sort(x.begin(), x.end());\n        sort(y.begin(), y.end());\n        ll s1 = 0, s2 = 0;\n        bool turn = 0;\n        while(n--)\n        {\n            if(turn == 0)\n            {\n                if((int)x.back() > (int)y.back())\n                {\n                    s1 += x.back();\n                    x.pop_back();\n                }\n                else\n                    y.pop_back();\n            }\n            else\n            {\n                if((int)y.back() > (int)x.back())\n                {\n                    s2 += y.back();\n                    y.pop_back();\n                }\n                else\n                    x.pop_back();\n            }\n            turn = !turn;\n        }\n        if(s1 < s2)\n            cout << ""Bob\\n"";\n        else if(s1 == s2)\n            cout << ""Tie\\n"";\n        else\n            cout << ""Alice\\n"";\n    }\n    return 0;\n}\n']","['dp', 'games', 'greedy', 'sortings']",1200
https://codeforces.com//contest/583/problem/A,A. Asphalting Roads,City X consists of vertical and horizontal infinite roads forming intersections Roads both vertical and horizontal are numbered from to and the intersections are indicated by the numbers of the roads that form them Sand roads have long been recognized out of date so the decision was made to asphalt them To do this a team of workers was hired and a schedule of work was made according to which the intersections should be asphalted Road repairs are planned for days On the th day of the team arrives at the th intersection in the list and if of the two roads that form the intersection were already asphalted they asphalt both roads Otherwise the team leaves the intersection without doing anything with the roads According to the schedule of road works tell in which days at least one road will be asphalted ,"[""#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint a[55],b[55],n;\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n*n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(a[x]==0&&b[y]==0)a[x]=b[y]=1,cout<<i<<' ';\n\t}\n\treturn 0;\n}\n""]",['implementation'],1000
https://codeforces.com//contest/1750/problem/G,G. Doping,We call an array a of length n if for each 1 i le n it holds that a i a i 1 1 Let s call f p applied to a permutation dagger of length n as the number of subarrays it can be partitioned such that each one of them is fancy For example f 1 2 3 1 while f 3 1 2 2 and f 3 2 1 3 Given n and a permutation p of length n we define a permutation p of length n to be k special if and only if p is lexicographically smaller ddagger than p and f p k Your task is to count for each 1 le k le n the number of k special permutations modulo m dagger A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ddagger A permutation a of length n is lexicographically smaller than a permutation b of length n if and only if the following holds in the first position where a and b differ the permutation a has a smaller element than the corresponding element in b ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n\n/**\n * Description: Barrett reduction computes $a \\% b$ about 4 times faster than\n * usual where $b>1$ is constant but not known at compile time. Division by $b$\n * is replaced by multiplication by $m$ and shifting right 64 bits. Source:\n * KACTL\n * https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h\n * https://en.wikipedia.org/wiki/Barrett_reduction\n * Verification: http://www.usaco.org/index.php?page=viewproblem2&cpid=1045\n */\n\nusing ul = uint64_t;\nusing L = __uint128_t;\nstruct FastMod {\n\tul b, m;\n\tFastMod(ul b) : b(b), m(-1ULL / b) {}\n\tul reduce(ul a) {\n\t\tul q = (ul)((__uint128_t(m) * a) >> 64), r = a - q * b;\n\t\treturn r - (r >= b) * b;\n\t}\n};\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal)\n * https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp\n * Verification:\n * https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int id> struct Mint {\n\tstatic FastMod MF;\n\tstatic int mod() { return (int)MF.b; }\n\tstatic void set_mod(int m) {\n\t\tassert(1 <= m);\n\t\tMF = FastMod(m);\n\t}\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don\'t silently convert to int\n\tMint() { v = 0; }\n\tMint(ll _v) {\n\t\tv = int((-mod() < _v && _v < mod()) ? _v : _v % mod());\n\t\tif (v < 0) v += mod();\n\t}\n\tfriend bool operator==(const Mint &a, const Mint &b) { return a.v == b.v; }\n\tfriend bool operator!=(const Mint &a, const Mint &b) { return !(a == b); }\n\tfriend bool operator<(const Mint &a, const Mint &b) { return a.v < b.v; }\n\tfriend void re(Mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = Mint(x);\n\t}\n\tfriend str ts(Mint a) { return ts(a.v); }\n\n\tMint &operator+=(const Mint &m) {\n\t\tif ((v += m.v) >= mod()) v -= mod();\n\t\treturn *this;\n\t}\n\tMint &operator-=(const Mint &m) {\n\t\tif ((v -= m.v) < 0) v += mod();\n\t\treturn *this;\n\t}\n\tMint &operator*=(const Mint &m) {\n\t\tv = (int)MF.reduce((ll)v * m.v);\n\t\treturn *this;\n\t}\n\tMint &operator/=(const Mint &m) { return (*this) *= inv(m); }\n\tfriend Mint pow(Mint a, ll p) {\n\t\tMint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend Mint inv(const Mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, mod() - 2);\n\t}\n\n\tMint operator-() const { return Mint(-v); }\n\tMint &operator++() { return *this += 1; }\n\tMint &operator--() { return *this -= 1; }\n\tfriend Mint operator+(Mint a, const Mint &b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint &b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint &b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint &b) { return a /= b; }\n};\ntemplate <int id> FastMod Mint<id>::MF = FastMod(1);\nusing Mi = Mint<0>;\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don\'t silently convert to int\n\tmint() : v(0) {}\n\tmint(ll _v) {\n\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD;\n\t}\n\tbool operator==(const mint &o) const { return v == o.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend void re(mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = mint(x);\n\t}\n\tfriend str ts(mint a) { return ts(a.v); }\n\n\tmint &operator+=(const mint &o) {\n\t\tif ((v += o.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &o) {\n\t\tif ((v -= o.v) < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &o) {\n\t\tv = int((ll)v * o.v % MOD);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\n\nusing mi = mint<MOD, 5>; // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi, mi>;\nusing vpmi = V<pmi>;\n\nV<V<Mi>> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, V<Mi>(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$.\n * For XOR convolution ignore \\texttt{m} within \\texttt{fft}.\n * Time: O(N\\log N)\n * Source:\n * KACTL\n * (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n * https://cp-algorithms.com/algebra/fft.html\n * https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n * maroonrk\n * https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp\n * Verification:\n * https://judge.yosupo.jp/problem/convolution_mod\n * SPOJ polymul, CSA manhattan, CF Perfect Encoding\n * http://codeforces.com/contest/632/problem/E\n */\n\n// #include ""ModInt.h""\n\n// const int MOD = 998244353;\ntcT > void fft(V<T> &A, bool inv = 0) { // NTT\n\tint n = sz(A);\n\tassert((T::mod - 1) % n == 0);\n\tV<T> B(n);\n\tfor (int b = n / 2; b; b /= 2, swap(A, B)) { // w = n/b\'th root\n\t\tT w = pow(T::rt(), (T::mod - 1) / n * b), m = 1;\n\t\tfor (int i = 0; i < n; i += b * 2, m *= w) F0R(j, b) {\n\t\t\t\tT u = A[i + j], v = A[i + j + b] * m;\n\t\t\t\tB[i / 2 + j] = u + v;\n\t\t\t\tB[i / 2 + j + n / 2] = u - v;\n\t\t\t}\n\t}\n\tif (inv) {\n\t\treverse(1 + all(A));\n\t\tT z = T(1) / T(n);\n\t\teach(t, A) t *= z;\n\t}\n} // for NTT-able moduli\ntcT > V<T> mul(V<T> A, V<T> B) {\n\tif (!min(sz(A), sz(B))) return {};\n\tint s = sz(A) + sz(B) - 1, n = 1;\n\tfor (; n < s; n *= 2)\n\t\t;\n\tbool eq = A == B;\n\tA.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i, n) A[i] *= B[i];\n\tfft(A, 1);\n\tA.rsz(s);\n\treturn A;\n}\ntemplate <class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T> &v) {\n\t\tV<M> w(sz(v));\n\t\tF0R(i, sz(v)) w[i] = (int)v[i];\n\t\treturn w;\n\t};\n\treturn mul(con(x), con(y));\n} // arbitrary moduli\ntcT > V<T> MUL(const V<T> &A, const V<T> &B) {\n\tusing m0 = mint<(119 << 23) + 1, 62>;\n\tauto c0 = mulMod<m0>(A, B);\n\tusing m1 = mint<(5 << 25) + 1, 62>;\n\tauto c1 = mulMod<m1>(A, B);\n\tusing m2 = mint<(7 << 26) + 1, 62>;\n\tauto c2 = mulMod<m2>(A, B);\n\tint n = sz(c0);\n\tV<T> res(n);\n\tm1 r01 = 1 / m1(m0::mod);\n\tm2 r02 = 1 / m2(m0::mod), r12 = 1 / m2(m1::mod);\n\tF0R(i, n) { // a=remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i] - a) * r01).v,\n\t\t\tc = (((c2[i] - a) * r02 - b) * r12).v;\n\t\tres[i] = (T(c) * m1::mod + b) * m0::mod + a; // c fixes m2::mod\n\t}\n\treturn res;\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tints(N, M);\n\tMi::set_mod(M);\n\t// P = vi()\n\tvi P(N);\n\n\tre(P);\n\t// iota(all(P), 1);\n\t// shuffle(all(P), rng);\n\tvb used(N + 1);\n\tused.at(0) = 1;\n\tgenComb(N + 5);\n\tV<Mi> fac(N + 1);\n\tfac.at(0) = 1;\n\tFOR(i, 1, N + 1) fac.at(i) = i * fac.at(i - 1);\n\tauto get_comb = [&](int hi, int lo, int mid) {\n\t\treturn scmb.at(hi - lo).at(mid - lo) * fac.at(mid);\n\t};\n\tV<V<Mi>> to_add(N + 1);\n\tF0R(i, N + 1) { to_add.at(i).rsz(N + 1 - i); }\n\tauto shift = [&](V<Mi> v, int l, int r) {\n\t\tv.ins(begin(v), l, 0);\n\t\tF0R(i, sz(v)) to_add.at(r - l).at(i) += v.at(i);\n\t\t// to_add.at(r-l) += v;\n\t\t// // dbg(""START SHIFT"", sz(v), l, r);\n\t\t// // dbg(v);\n\t\t// F0R(i, sz(v)) F0R(m, r - l + 1) {\n\t\t// \ttot_ways.at(i + m) += scmb.at(r - l).at(m) * v.at(i);\n\t\t// }\n\t};\n\tint comps_so_far = 0;\n\tF0R(i, N) {\n\t\tdbg(""DOING"", i);\n\t\t// = p[1 ... i-1]\n\t\t// < p[i]\n\n\t\t// 0\n\t\t// 1: designated smaller\n\t\t// 2: designated equal to p[i-1] + 1\n\n\t\t// start < p[i]: for each k\n\t\t// start < p[i] and equal to p[i-1]+1\n\n\t\t// how many ways to select k segments and designate one as the start\n\t\tauto must_start = [&](int x) { return used.at(x - 1) && !used.at(x); };\n\t\tint num_unused = N - i;\n\t\tint num_must_start = 0;\n\t\tFOR(j, 1, N + 1) num_must_start += must_start(j);\n\t\tint ways_a = 0, ways_b = 0;\n\t\tFOR(start, 1, P.at(i)) if (!used.at(start)) {\n\t\t\tV<Mi> ways(num_unused + 1);\n\t\t\tif (must_start(start)) {\n\t\t\t\tif (i && start == P.at(i - 1) + 1) {\n\t\t\t\t\tFOR(comps, num_must_start - 1, num_unused) {\n\t\t\t\t\t\tways.at(1 + comps) =\n\t\t\t\t\t\t\tget_comb(num_unused - 1, num_must_start - 1, comps);\n\t\t\t\t\t}\n\t\t\t\t\tshift(ways, comps_so_far - 1, i);\n\t\t\t\t} else {\n\t\t\t\t\t++ways_a;\n\t\t\t\t\t// shift(ways, comps_so_far, i);\n\t\t\t\t}\n\t\t\t\t// num_unused - 1, num_must_start - 1\n\t\t\t} else {\n\t\t\t\t++ways_b;\n\t\t\t\t// num_unused - 1, num_must_start\n\t\t\t}\n\t\t}\n\t\tif (ways_a) {\n\t\t\tV<Mi> ways(num_unused + 1);\n\t\t\tFOR(comps, num_must_start - 1, num_unused) {\n\t\t\t\tways.at(1 + comps) =\n\t\t\t\t\tways_a *\n\t\t\t\t\tget_comb(num_unused - 1, num_must_start - 1, comps);\n\t\t\t}\n\t\t\tshift(ways, comps_so_far, i);\n\t\t}\n\t\tif (ways_b) {\n\t\t\tV<Mi> ways(num_unused + 1);\n\t\t\tFOR(comps, num_must_start, num_unused) {\n\t\t\t\tways.at(1 + comps) =\n\t\t\t\t\tways_b * get_comb(num_unused - 1, num_must_start, comps);\n\t\t\t}\n\t\t\tshift(ways, comps_so_far, i);\n\t\t}\n\t\tif (i && P.at(i) == P.at(i - 1) + 1) {\n\n\t\t} else {\n\t\t\t++comps_so_far;\n\t\t}\n\t\tused.at(P.at(i)) = 1;\n\t}\n\tROF(i, 1, N + 1) {\n\t\tF0R(j, sz(to_add.at(i))) {\n\t\t\tto_add.at(i - 1).at(j) += to_add.at(i).at(j);\n\t\t\tto_add.at(i - 1).at(j + 1) += to_add.at(i).at(j);\n\t\t}\n\t}\n\tauto tot_ways = to_add.at(0);\n\tFOR(i, 1, N + 1) {\n\t\tpr(tot_ways.at(i), \' \');\n\t\tFOR(j, i + 1, N + 1) {\n\t\t\ttot_ways.at(j) -= tot_ways.at(i) * scmb.at(N - i).at(j - i);\n\t\t}\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['combinatorics', 'dp', 'math']",3300
https://codeforces.com//contest/652/problem/D,D. Nested Segments,You are given segments on a line There are no ends of some segments that coincide For each segment find the number of segments it contains ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct sg{\n  in l,r,id;\n  sg(in a=0, in b=0, in c=0){\n    l=a;\n    r=b;\n    id=c;\n  }\n  bool operator<(const sg cp)const{\n    if(l==cp.l)\n      assert(id==cp.id);\n    return l<cp.l;\n  }\n};\nstruct fenw{\n  VI fw;\n  in n;\n  void ini(in pn){\n    n=pn;\n    fw.clear();\n    fw.resize(n,0);\n  }\n  void ad(in l, in x){\n    while(l<n){\n      fw[l]+=x;\n      l|=(l+1);\n    }\n  }\n  in sm(in l){\n    in r=0;\n    while(l>=0){\n      r+=fw[l];\n      l&=(l+1);\n      --l;\n    }\n    return r;\n  }\n};\nfenw mtr;\nvector<sg> sgs;\nVI vls;\nmap<in,in> dcd;\nVI res;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  sgs.resize(n);\n  forn(i,n){\n    cin>>sgs[i].l>>sgs[i].r;\n    vls.PB(sgs[i].l);\n    vls.PB(sgs[i].r);\n    sgs[i].id=i;\n  }\n  sort(all(vls));\n  forv(i,vls)\n    dcd[vls[i]]=i;\n  forv(i,sgs){\n    sgs[i].l=dcd[sgs[i].l];\n    sgs[i].r=dcd[sgs[i].r];\n  }\n  sort(all(sgs));\n  mtr.ini(sz(dcd)+3);\n  res.resize(n);\n  for(in i=sz(sgs)-1;i>=0;--i){\n    res[sgs[i].id]=mtr.sm(sgs[i].r);\n    mtr.ad(sgs[i].r,1);\n  }\n  forv(i,res)\n    cout<<res[i]<<""\\n"";\n  return 0;\n}\n']","['data structures', 'sortings']",1800
https://codeforces.com//contest/1465/problem/B,B. Fair Numbers,We call a positive integer number if it is divisible by each of its nonzero digits For example 102 is fair because it is divisible by 1 and 2 but 282 is not because it isn t divisible by 8 Given a positive integer n Find the minimum integer x such that n leq x and x is fair ,"['#include<bits/stdc++.h>\nnamespace mem{ //v2.10.1 => size: 15.80KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)        \\\n      func(float)                     \\\n      func(double)                    \\\n      func(long double)\n  \n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n  \n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::find;\n    using std::copy;\n    using std::fill;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n    using std::next_permutation;\n  }\n  \n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori\'s Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    \n    template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n    template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  }\n  \n  namespace modint{\n    template<const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x<0&&(x+=mod);}\n      \n      inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n      \n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n    };\n    \n    template<const int mod> inline Z<mod> finv(Z<mod> x){\n      if(x.x<2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n      Z<mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&1)s=s*a;\n      return s;\n    }\n    \n    template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n  \n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template<class T> inline T abs(T x){return x<0?-x:x;}\n    template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n    \n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n      \n      inline bool divide(u64 n){return n*i<=t;}\n      inline bool divide(i64 n){return u64(n<0?-n:n)*i<=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i<5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n  \n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)<<64)/b)),b(b){}\n      \n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n  \n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::multiset;\n    using std::unordered_set;\n    using std::unordered_multiset;\n    using std::map;\n    using std::multimap;\n    using std::unordered_map;\n    using std::unordered_multimap;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    using std::deque;\n    using std::bitset;\n    \n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n    \n    template<class T> struct vector:std::vector<T>{\n      using std::vector<T>::vector;\n      using iterator=typename std::vector<T>::iterator;\n      using const_iterator=typename std::vector<T>::const_iterator;\n      vector():std::vector<T>(){}\n      explicit vector(const std::vector<T> &plain):std::vector<T>(plain){}\n      \n      inline void reverse(){std::reverse(this->begin(),this->end());}\n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n      \n      inline iterator find(const T &x){return std::find(this->begin(),this->end(),x);}\n      inline iterator lower_bound(const T &x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator find(const T &x)const{return std::find(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &x)const{return std::upper_bound(this->begin(),this->end(),x);}\n\n      inline void sort(){std::sort(this->begin(),this->end());}\n      template<class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n      \n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n        vector rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set<T> &src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template<class R,class Function> inline vector<R> _map(Function func) const{\n        vector<R> res(this->size());\n        for(size_t i=0;i<this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n      template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n    };\n    \n    struct string:std::string{\n      using std::string::string;\n      string():std::string(""""){}\n      string(const std::string &plain):std::string(plain){}\n      \n      template<class T> inline string join(const vector<T> &vet) const;\n            \n      inline string slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return string(this->begin()+l,this->begin()+r);\n        string rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n      \n      vector<string> split(const string &dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector<string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n      \n      template<class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template<class... Args> static inline string format(const string &fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n  \n  #define __to_string(T)                   \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n    \n    inline string to_string(const string &s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &s){return string(s);}\n    template<const int mod> inline string to_string(const modint::Z<mod> &v){return std::to_string(v.x);}\n    \n    template<class T> inline string to_string(const vector<T> &ctn){return ""[""+string("","").join(ctn)+""]"";}\n    template<class T> inline string to_string(const set<T> &ctn){\n      string result=""{"";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+="","";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+""}"";\n    }\n    template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n      string result=""{"";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+="","";\n        flag=true;\n        result+=to_string(it.first)+"":""+to_string(it.second);\n      }\n      return result+""}"";\n    }\n    \n    template<class T> inline string string::join(const vector<T> &vet) const{\n      if(!vet.size())return """";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i<vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n    \n    inline string operator """" _s(const char *s){return string(s);}\n    inline string operator """" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator """" _s(long double x){return to_string(x);}\n    inline string operator """" _s(unsigned long long int x){return to_string(x);}\n  }\n  \n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1<<18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n    inline void flush(){fastio::flush(),fflush(stdout);}\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n    inline void flush(){fflush(stdout);}\n  #endif\n    \n    template<class T> inline void read_digit(T &x){x=getc(); while(!isdigit(x))x=getc();}\n    template<class T> inline void read_alpha(T &x){x=getc(); while(!isalpha(x))x=getc();}\n    template<class T> inline void read_lower(T &x){x=getc(); while(!islower(x))x=getc();}\n    template<class T> inline void read_upper(T &x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n  \n  #define __read(T)                             \\\n      inline void read(T &x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c==\'-\',c=getc();   \\\n        while(isdigit(c))x=x*10+c-\'0\',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n    #ifdef MEM_INT128\n      __read(__int128_t)\n      __read(__uint128_t)\n    #endif\n  #undef __read\n    \n    inline void read(char &x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&&!isspace(c))*s++=c,c=getc();\n      *s++=\'\\0\';\n    }\n    inline void read(container::string &s){\n      char c=getc();\n      s="""";\n      while(~c&&!isspace(c))s+=c,c=getc();\n    }\n    template<const int mod> inline void read(const modint::Z<mod> &x){read(x.x);}\n    \n    template<class T=int> inline T read(){T x; read(x); return x;}\n    template<class T,class... Args> inline void read(T &x,Args &... args){\n      read(x),read(args...);\n    }\n  \n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x<0)putc(\'-\'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc(\'0\'+x%10);        \\\n      }\n    __integer_mapper(__print)\n    #ifdef MEM_INT128\n      __print(__int128_t)\n      __print(__uint128_t)\n    #endif\n  #undef __print\n    \n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i<len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &s){\n      for(size_t i=0;i<s.length();i++)putc(s[i]);\n    }\n    template<const int mod> inline void print(const modint::Z<mod> &x){print(x.x);}\n    \n    template<class T,class... Args> inline void print(const T &x,Args... args){\n      print(x),print(args...);\n    }\n    template<class... Args> inline void println(Args... args){\n      print(args...),putc(\'\\n\');\n    }\n    \n    template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n  \n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,""\\033[%dm"",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\033[0m"");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,""\\033[%dm"",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\033[0m\\n"");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,""\\n"");\n      }\n  #endif\n    }\n    template<class T> inline void logs(const T &x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template<class T,class... Args> inline void logs(const T &x,Args... args){\n      logs(x),logs(args...);\n    }\n    template<class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,""\\n"");\n  #endif\n    }\n  }\n  \n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,""r"",stdin);}\n    inline void file_output(const char *dir){freopen(dir,""w"",stdout);}\n    inline void file_input(const std::string &dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &dir){file_output(dir.c_str());}\n\n    template<class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+"".in""_s);\n      file_output(name+"".out""_s);\n    }\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\nusing namespace mem;\nint T;\nlong long n;\nbool is_fair(long long n){\n  for(long long t=n;t;t/=10)\n    if(t%10&&n%(t%10)){\n      return false;\n    }\n  return true;\n}\nint main(){\n#ifdef memset0\n  freopen(""1.in"",""r"",stdin);\n#endif\n  read(T);\n  while(T--){\n    read(n);\n    while(!is_fair(n)){\n      ++n;\n    }\n    println(n);\n  }\n}']","['brute force', 'math', 'number theory']",1000
https://codeforces.com//contest/1658/problem/A,A. Marin and Photoshoot,Today Marin is at a cosplay exhibition and is preparing for a group photoshoot For the group picture the cosplayers form a horizontal line A group picture is considered if for every contiguous segment of at least 2 cosplayers the number of males does not exceed the number of females obviously Currently the line has n cosplayers which can be described by a binary string s The i th cosplayer is male if s i 0 and female if s i 1 To ensure that the line is you can invite some additional cosplayers possibly zero to join the line at any position You can t remove any cosplayer from the line Marin wants to know the minimum number of cosplayers you need to invite so that the group picture of all the cosplayers is She can t do this on her own so she s asking you for help Can you help her ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring a;\n\t\tint n;\n\t\tcin >> n >> a;\n\t\tint ans=0;\n\t\tfor(int i=1;i<a.size();i++)\n\t\t{\n\t\t\tif(a[i]==\'0\'&&a[i-1]==\'0\')\n\t\t\t\tans+=2;\n\t\t}\n\t\tfor(int i=2;i<a.size();i++)\n\t\t{\n\t\t\tif(a[i]==\'0\'&&a[i-2]==\'0\'&&a[i-1]!=\'0\')\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'implementation', 'math']",800
https://codeforces.com//contest/1731/problem/E,E. Graph Cost,You are given an initially empty undirected graph with n nodes numbered from 1 to n i e n nodes and 0 edges You want to add m edges to the graph so the graph won t contain any self loop or multiple edges If an edge connecting two nodes u and v is added its weight must be equal to the greatest common divisor of u and v i e gcd u v In order to add edges to the graph you can repeat the following process any number of times possibly zero choose an integer k ge 1 add exactly k edges to the graph each having a weight equal to k 1 Adding these k edges costs k 1 in total Note that you can t create self loops or multiple edges Also if you can t add k edges of weight k 1 you can t choose such k For example if you can add 5 more edges to the graph of weight 6 you may add them and it will cost 6 for the whole pack of 5 edges But if you can only add 4 edges of weight 6 to the graph you can t perform this operation for k 5 Given two integers n and m find the minimum total cost to form a graph of n vertices and exactly m edges using the operation above If such a graph can t be constructed output 1 Note that the final graph may consist of several connected components ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nnamespace Prime\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll M=(ll)(N-1)*(N-1);\n\tui pr[N],mn[N],phi[N],cnt;\n\tint mu[N];\n\tvoid init_prime()\n\t{\n\t\tui i,j,k;\n\t\tphi[1]=mu[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tif (!mn[i])\n\t\t\t{\n\t\t\t\tpr[cnt++]=i;\n\t\t\t\tphi[i]=i-1; mu[i]=-1;\n\t\t\t\tmn[i]=i;\n\t\t\t}\n\t\t\tfor (j=0; (k=i*pr[j])<N; j++)\n\t\t\t{\n\t\t\t\tmn[k]=pr[j];\n\t\t\t\tif (i%pr[j]==0)\n\t\t\t\t{\n\t\t\t\t\tphi[k]=phi[i]*pr[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tphi[k]=phi[i]*(pr[j]-1);\n\t\t\t\tmu[k]=-mu[i];\n\t\t\t}\n\t\t}\n\t\t//for (i=2;i<N;i++) if (mu[i]<0) mu[i]+=p;\n\t}\n\ttemplate<typename T> T getphi(T x)\n\t{\n\t\tassert(M>=x);\n\t\tT r=x;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\tif (x>=N) return r/x*(x-1);\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<typename T> vector<pair<T,ui>> getw(T x)\n\t{\n\t\tassert(M>=x);\n\t\tvector<pair<T,ui>> r;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\tif (x>=N)\n\t\t{\n\t\t\tr.push_back({x,1});\n\t\t\treturn r;\n\t\t}\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\treturn r;\n\t}\n}\nusing Prime::pr,Prime::phi,Prime::getw;\nusing Prime::mu,Prime::init_prime;\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tinit_prime();\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j;\n\t\tll m;\n\t\tcin>>n>>m;\n\t\tvector<ll> cnt(n+1);\n\t\tfor (i=1; i<=n; i++) cnt[i]=(ll)(n/i)*(n/i);\n\t\tfor (i=1; i<=n; i++) for (j=2; j*i<=n; j++) cnt[i]+=cnt[j*i]*mu[j];\n\t\tfor (i=2; i<=n; i++) cnt[i]=(cnt[i]-1>>1)/(i-1);\n\t\tll res=0;\n\t\t// dbg(cnt);\n\t\tfor (i=n; i>=2; i--)\n\t\t{\n\t\t\tll d=min(cnt[i],m/(i-1));\n\t\t\tm-=d*(i-1);\n\t\t\tres+=d*i;\n\t\t\t// dbg(m,res,i);\n\t\t}\n\t\tif (m) cout<<""-1\\n"";\n\t\telse cout<<res<<\'\\n\';\n\t}\n}\n']","['dp', 'greedy', 'math', 'number theory']",2000
https://codeforces.com//contest/1750/problem/F,F. Majority,Everyone was happy coding until suddenly a power shortage happened and the best competitive programming site went down Fortunately a system administrator bought some new equipment recently including some UPSs Thus there are some servers that are still online but we need all of them to be working in order to keep the round rated Imagine the servers being a binary string s of length n If the i th server is online then s i 1 and s i 0 otherwise A system administrator can do the following operation called that consists of the following phases Select two servers at positions 1 le i j le n such that both are online i e s i s j 1 The spread starts only from online servers Check if we have enough power to make the spread We consider having enough power if the number of turned on servers in range i j is at least the number of turned off servers in range i j More formally check whether 2 cdot s i s i 1 ldots s j ge j i 1 If the check is positive turn on all the offline servers in range i j More formally make s k 1 for all k from i to j We call a binary string s of length n if we can turn on all servers i e make s i 1 for 1 le i le n using the electricity spread operation any number of times possibly 0 Your task is to find the number of rated strings of length n modulo m ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n/**\n * Description: Barrett reduction computes $a \\% b$ about 4 times faster than\n * usual where $b>1$ is constant but not known at compile time. Division by $b$\n * is replaced by multiplication by $m$ and shifting right 64 bits. Source:\n * KACTL\n * https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h\n * https://en.wikipedia.org/wiki/Barrett_reduction\n * Verification: http://www.usaco.org/index.php?page=viewproblem2&cpid=1045\n */\n\nusing ul = uint64_t;\nusing L = __uint128_t;\nstruct FastMod {\n\tul b, m;\n\tFastMod(ul b) : b(b), m(-1ULL / b) {}\n\tul reduce(ul a) {\n\t\tul q = (ul)((__uint128_t(m) * a) >> 64), r = a - q * b;\n\t\treturn r - (r >= b) * b;\n\t}\n};\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal)\n * https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp\n * Verification:\n * https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int id> struct mint {\n\tstatic FastMod MF;\n\tstatic int mod() { return (int)MF.b; }\n\tstatic void set_mod(int m) {\n\t\tassert(1 <= m);\n\t\tMF = FastMod(m);\n\t}\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) {\n\t\tv = int((-mod() < _v && _v < mod()) ? _v : _v % mod());\n\t\tif (v < 0) v += mod();\n\t}\n\tfriend bool operator==(const mint &a, const mint &b) { return a.v == b.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend void re(mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = mint(x);\n\t}\n\tfriend str ts(mint a) { return ts(a.v); }\n\n\tmint &operator+=(const mint &m) {\n\t\tif ((v += m.v) >= mod()) v -= mod();\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &m) {\n\t\tif ((v -= m.v) < 0) v += mod();\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &m) {\n\t\tv = (int)MF.reduce((ll)v * m.v);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, mod() - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\ntemplate <int id> FastMod mint<id>::MF = FastMod(1);\n\ntypedef mint<0> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi, mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, vmi(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tints(N, M);\n\tmi::set_mod(M);\n\tvmi rated(N + 1), unrated(N + 1);\n\t// unrated.at(0) = 1;\n\tFOR(i, 1, N + 1) {\n\t\trated.at(i) = pow(mi(2), i);\n\t\tunrated.at(i) = unrated.at(i - 1);\n\t\t// first\n\t\tFOR(x, 1, i) if (2 * x + 1 <= i) { unrated.at(i) += rated.at(x); }\n\t\t// continue\n\t\tFOR(x, 1, i) if (3 * x + 1 <= i) {\n\t\t\tunrated.at(i) += rated.at(x) * unrated.at(i - (3 * x + 1));\n\t\t}\n\t\trated.at(i) -= 1; // none\n\t\tFOR(x, 1, i) { rated.at(i) -= rated.at(x) * (i - x + 1); }\n\t\tmi cum = 0;\n\t\tint cur = -1;\n\t\t// more than one\n\t\tROF(x, 1, i) {\n\t\t\twhile (cur + 1 <= i - 2 * x) cum += unrated.at(++cur);\n\t\t\trated.at(i) -= rated.at(x) * cum;\n\t\t\t// F0R(j, i - 2 * x + 1) {\n\t\t\t// \trated.at(i) -= unrated.at(j) * rated.at(x);\n\t\t\t// }\n\t\t}\n\t\t// dbg(i, rated.at(i));\n\t}\n\tps(rated.at(N));\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['combinatorics', 'dp', 'math', 'strings']",2700
https://codeforces.com//contest/287/problem/A,A. IQ Test,In the city of Ultima Thule job applicants are often offered an IQ test The test is as follows the person gets a piece of squared paper with a square painted on it Some of the square s cells are painted black and others are painted white Your task is to repaint cell the other color so that the picture has a square completely consisting of cells of the same color If the initial picture already has such a square the person should just say so and the test will be completed Your task is to write a program that determines whether it is possible to pass the test You cannot pass the test if either repainting any cell or no action doesn t result in a square consisting of cells of the same color ,"['#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fo(i,n) for(int i=1;i<=n;i++)\n#define fe(i,n) for(__typeof(n.begin()) i=n.begin();i!=n.end();i++)\nchar s[5][5];\nint n=4;\nint C(int x,int y)\n{\n\treturn s[x][y]==\'#\';\n}\nint main()\n{\n\tfr(i,n)\n\t\tscanf(""%s"",s[i]);\n\tfr(i,n-1)\n\t\tfr(j,n-1)\n\t\t{\n\t\t\tif(C(i,j)+C(i+1,j)+C(i,j+1)+C(i+1,j+1)!=2)\n\t\t\t{\n\t\t\t\tputs(""YES"");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(""NO"");\n}\n']","['brute force', 'implementation']",1100
https://codeforces.com//contest/1898/problem/A,A. Milica and String,Milica has a string s of length n consisting only of characters and She wants to modify s so it contains k instances of In one operation she can do the following Select an integer i 1 leq i leq n and a character c c is equal to either or Then replace of the first i characters of string s that is characters s 1 s 2 ldots s i with c Milica does not want to perform too many operations in order not to waste too much time on them She asks you to find the minimum number of operations required to modify s so it contains exactly k instances of She also wants you to find these operations that is integer i and character c selected in each operation ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    vector<int> pref(n + 1);\n    for (int i = 0; i < n; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == \'B\');\n    }\n    if (pref[n] == k) {\n        cout << ""0\\n"";\n        return;\n    }\n    cout << ""1\\n"";\n    if (pref[n] > k) {\n        for (int i = 0; i <= n; ++i) {\n            if (pref[n] - pref[i] == k) {\n                cout << i << "" "" << \'A\' << ""\\n"";\n                return;\n            }\n        }\n    } else {\n        for (int i = 0; i <= n; ++i) {\n            if (pref[n] - pref[i] + i == k) {\n                cout << i << "" "" << \'B\' << ""\\n"";\n                return;\n            }\n        }\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","['brute force', 'implementation', 'strings']",800
https://codeforces.com//contest/1421/problem/B,B. Putting Bricks in the Wall,Roger Waters has a square grid of size n times n and he wants to traverse his grid from the upper left 1 1 corner to the lower right corner n n Waters can move from a square to any other square adjacent by a side as long as he is still in the grid Also except for the cells 1 1 and n n every cell has a value 0 or 1 in it Before starting his traversal he will pick either a 0 or a 1 and will be able to only go to cells values in which are equal to the digit he chose The starting and finishing cells 1 1 and n n are exempt from this rule he may go through them regardless of picked digit Because of this the cell 1 1 takes value the letter and the cell n n takes value the letter For example in the first example test case he can go from 1 1 to n n by using the zeroes on this path 1 1 2 1 2 2 2 3 3 3 3 4 4 4 The rest of the band Pink Floyd wants Waters to not be able to do his traversal so while he is not looking they will in the grid from 0 to 1 or vice versa They are afraid they will not be quick enough and asked for your help in choosing the cells We can show that there always exists a solution for the given constraints Also note that Waters will pick his digit of the traversal after the band has changed his grid so he must not be able to reach n n no matter what digit he picks ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nchar s[505][505];\nint main(){\n\tint t, n;\n\tfor(cin >> t; t--;) {\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n ; i ++) cin >> s[i];\n\t\tif(s[0][1] == s[1][0]) {\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tif(s[0][1] != s[n - 1][n - 2]) {\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << 2 << endl;\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t\tcout << ""2 1"" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == s[0][1]) {\n\t\t\t\t\tcout << n << \' \' << n - 1 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << n - 1<< \' \' << n << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[0][1] == s[n - 1][n - 2]) {\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t}\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 2 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == \'1\') cout << n << \' \' << n - 1 << endl;\n\t\t\t\telse cout << n - 1 << "" "" << n << endl;\n\t\t\t\tif(s[0][1] == \'0\') cout << ""1 2"" << endl;\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n']","['constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/1108/problem/B,B. Divisors of Two Integers,Recently you have received two integer numbers x and y You forgot them but you remembered a list containing all divisors of x including 1 and x and all divisors of y including 1 and y If d is a divisor of both numbers x and y at the same time there are two occurrences of d in the list For example if x 4 and y 6 then the given list can be any permutation of the list 1 2 4 1 2 3 6 Some of the possible lists are 1 1 2 4 6 3 2 4 6 1 1 2 3 2 or 1 6 3 2 4 1 2 Your problem is to restore suitable integer numbers x and y that would yield the same list of divisors possibly in different order It is guaranteed that the answer exists i e the given list of divisors corresponds to some integers x and y ,"['#include <bits/stdc++.h>\n\n#define fn ""test""\n#define fn1 """"\n\nusing namespace std;\n\nconst int mn = 1 * (int)(1e5) + 10;\nconst int mod = 1 * (int)(1e9) + 7;\nconst int mm = 1 * (int)(1e3) + 10;\nconst int base = 1 * (int)(1e9);\nconst bool aNs = 0;\n\nint tt, ntest = 1;\n\nvoid docfile()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    if (ifstream(fn"".inp""))\n    {\n        freopen(fn"".inp"", ""r"", stdin);\n        if (!aNs) freopen(fn"".out"", ""w"", stdout);\n\t\telse freopen (fn"".ans"", ""w"", stdout);\n    }else if (ifstream(fn1"".inp""))\n    {\n        freopen(fn1"".inp"", ""r"", stdin);\n        freopen(fn1"".out"", ""w"", stdout);\n    }\n}\n\ntemplate <typename T>\nvoid read(T& x)\n{\n    x = 0; T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = ch == \'-\' ? - f : f, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - \'0\', ch = getchar();\n    x *= f;\n}\n\ntemplate <typename T>\nvoid write (T a)\n{\n    if (a < 0)\n    {\n        putchar (\'-\');\n        write (-a);\n        return;\n    }\n    if (a < 10)\n    {\n        putchar (\'0\' + a);\n        return;\n    }\n    write (a / 10);\n    putchar ((char)(\'0\' + (a % 10)));\n}\n\nbool ok[mn];\n\nvoid enter()\n{\n    int n;\n    cin >> n;\n    vector<int> a (n + 3);\n    map<int, int> mu;\n    int ma = 0, ma1 = 0;\n    for (int i = 1; i <= n; ++ i)\n    {\n        cin >> a[i];\n        ma = max (ma, a[i]);\n    }\n    int l = ma;\n    for (int i = 1; i <= n; ++ i)\n    {\n        if (ma % a[i] == 0 && !ok[a[i]])\n        {\n            ok[a[i]] = 1;\n            // ma /= a[i];\n        }\n        else ma1 = max (ma1, a[i]);\n    }\n    cout << l << "" "" << ma1;\n}\n\nvoid solve()\n{\n\n}\n\nvoid print_result()\n{\n\n}\n\nint main()\n{\n    docfile();\n    //cin>>ntest;\n    for (tt = 1; tt <= ntest; ++ tt)\n    {\n        enter();\n        solve();\n        print_result();\n    }\n}']","['brute force', 'greedy', 'math', 'number theory']",1100
https://codeforces.com//contest/708/problem/C,C. Centroids,is a connected acyclic graph Suppose you are given a tree consisting of vertices The vertex of this tree is called if the size of each connected component that appears if this vertex is removed from the tree doesn t exceed You are given a tree of size and can perform no more than one edge replacement is the operation of removing one edge from the tree without deleting incident vertices and inserting one new edge without adding new vertices in such a way that the graph remains a tree For each vertex you have to determine if it s possible to make it centroid by performing no more than one edge replacement ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int N = 400200;\nint n;\nvector<int> g[N];\nbool ans[N];\nint sz[N];\n\nvoid dfs(int v)\n{\n\tsz[v] = 1;\n\tfor (int u : g[v])\n\t{\n\t\tif (sz[u] != -1) continue;\n\t\tdfs(u);\n\t\tsz[v] += sz[u];\n\t}\n\treturn;\n}\n\nvoid dfsSolve(int v, int s)\n{\n\tans[v] = (2 * (n - sz[v] - s)) <= n;\n\tfor (int u : g[v])\n\t\tif (sz[u] < sz[v])\n\t\t\tdfsSolve(u, s);\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsz[i] = -1;\n\tdfs(0);\n\tint v = 0;\n\twhile(true)\n\t{\n\t\tint w = -1;\n\t\tfor (int u : g[v])\n\t\t{\n\t\t\tif (sz[u] > sz[v]) continue;\n\t\t\tif (2 * sz[u] >= n)\n\t\t\t{\n\t\t\t\tw = u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (w == -1) break;\n\t\tv = w;\n\t}\n\tif (2 * sz[v] == n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(""1 "");\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsz[i] = -1;\n\tdfs(v);\n\tans[v] = 1;\n\tint m1 = -1, m2 = -1;\n\tfor (int u : g[v])\n\t{\n\t\tif (sz[u] > m1)\n\t\t{\n\t\t\tm2 = m1;\n\t\t\tm1 = sz[u];\n\t\t}\n\t\telse if (sz[u] > m2)\n\t\t\tm2 = sz[u];\n\t}\n\tfor (int u : g[v])\n\t{\n\t\tif (sz[u] == m1)\n\t\t\tdfsSolve(u, m2);\n\t\telse\n\t\t\tdfsSolve(u, m1);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", (int)ans[i]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}']","['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'trees']",2300
https://codeforces.com//contest/912/problem/C,"C. Perun, Ult ",A lot of students spend their winter holidays productively Vlad has advanced very well in doing so For three days already fueled by salads and tangerines the leftovers from New Year celebration he has been calibrating his rating in his favorite MOBA game playing as a hero named Perun Perun has an ultimate ability called Thunderwrath At the instant of its activation each enemy on the map of them in total loses health points as a single time effect It also has a restriction it can only activated when the moment of time is an The initial bounty for killing an enemy is Additionally it increases by each second Formally if at some second the ability is activated and the th enemy is killed as a result i e his health drops to zero or lower Vlad earns units of gold Every enemy can receive damage as well as be healed There are multiple ways of doing so but Vlad is not interested in details For each of enemies he knows maximum number of health points for the th enemy initial health of the enemy on the th second the amount of health the th enemy can regenerate per second There also health updates Vlad knows about time when the health was updated the enemy whose health was updated updated health points for Obviously Vlad wants to maximize his profit If it s necessary he could even wait for years to activate his ability at the right second Help him determine the exact second note that it must be from inclusively to so that a single activation of the ability would yield Vlad the maximum possible amount of gold and print this amount ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define pii pair<int,int>\nusing namespace std;\nint n, m, AA, inc, K, INF = 2e9;\nstruct point {\n\tint M, R;\n\tvector<pii>T;\n}w[101000];\nmap<int, int>B;\nint main() {\n\tint i, h, t, a, j;\n\tscanf(""%d%d%d%d%d"", &n,&m,&AA,&inc,&K);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d%d%d"", &w[i].M, &h, &w[i].R);\n\t\tw[i].T.push_back({ 0, h });\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(""%d%d%d"", &t, &a, &h);\n\t\tw[a].T.push_back({ t,h });\n\t}\n\tint ck = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tsort(w[i].T.begin(), w[i].T.end());\n\t\tif (w[i].M <= K && inc) {\n\t\t\tck = 1;\n\t\t}\n\t\tif (w[i].T.back().second <= K && w[i].R == 0 && inc) {\n\t\t\tck = 1;\n\t\t}\n\t\tw[i].T.push_back({ INF,0 });\n\t\tfor (j = 0; j < w[i].T.size() - 1; j++) {\n\t\t\tpii tp = w[i].T[j];\n\t\t\tint t1 = tp.first, hh = tp.second;\n\t\t\tint t2 = w[i].T[j + 1].first;\n\t\t\tif (hh > K)continue;\n\t\t\tif (w[i].R == 0 || w[i].M <= K) {\n\t\t\t\tB[t1]++;\n\t\t\t\tB[t2]--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tt = (K - hh) / w[i].R;\n\t\t\t\tB[t1]++;\n\t\t\t\tB[min(t2, t1 + tt + 1)]--;\n\t\t\t}\n\t\t}\n\t}\n\tif (ck) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tint s = 0;\n\tlong long r = 0;\n\tfor (auto &tp : B){\n\t\tlong long t = 1ll*s*AA + 1ll*s*inc*(tp.first - 1);\n\t\tr = max(r, t);\n\t\ts += tp.second;\n\t}\n\tprintf(""%lld\\n"", r);\n}']","['brute force', 'greedy', 'sortings']",2500
https://codeforces.com//contest/778/problem/B,B. Bitwise Formula,Bob recently read about bitwise operations used in computers and He have studied their properties and invented a new game Initially Bob chooses integer bit depth of the game which means that all numbers in the game will consist of bits Then he asks Peter to choose some bit number After that Bob computes the values of variables Each variable is assigned either a constant bit number or result of bitwise operation Operands of the operation may be either variables defined before or the number chosen by Peter After that Peter s score equals to the sum of all variable values Bob wants to know what number Peter needs to choose to get the minimum possible score and what number he needs to choose to get the maximum possible score In both cases if there are several ways to get the same score find the minimum number which he can choose ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntemplate<typename Op>\nstatic void combine(vector<array<int, 2>> &out,\n                    const vector<array<int, 2>> &left,\n                    const vector<array<int, 2>> &right,\n                    const Op &op)\n{\n    int M = SZ(out);\n    for (int i = 0; i < M; i++)\n        for (int j = 0; j < 2; j++)\n            out[i][j] = op(left[i][j], right[i][j]);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, M;\n    cin >> N >> M;\n    map<string, vector<array<int, 2>>> vars;\n    vector<array<int, 2>> peter(M);\n    for (int i = 0; i < M; i++)\n    {\n        peter[i][0] = 0;\n        peter[i][1] = 1;\n    }\n    for (int i = 0; i < N; i++)\n    {\n        string name, assign, left;\n        cin >> name >> assign >> left;\n        vector<array<int, 2>> out(M);\n        if (left[0] == \'0\' || left[0] == \'1\')\n        {\n            for (int j = 0; j < M; j++)\n                out[j][0] = out[j][1] = left[j] - \'0\';\n        }\n        else\n        {\n            string op, right;\n            cin >> op >> right;\n            const auto &leftv = (left == ""?"") ? peter : vars[left];\n            const auto &rightv = (right == ""?"") ? peter : vars[right];\n            if (op == ""XOR"")\n                combine(out, leftv, rightv, [](int x, int y) { return x ^ y; });\n            else if (op == ""AND"")\n                combine(out, leftv, rightv, [](int x, int y) { return x & y; });\n            else if (op == ""OR"")\n                combine(out, leftv, rightv, [](int x, int y) { return x | y; });\n        }\n        vars[name] = out;\n    }\n    vector<int> lo(M), hi(M);\n    for (int i = 0; i < M; i++)\n    {\n        int sums[2] = {0, 0};\n        for (const auto &entry : vars)\n        {\n            for (int j = 0; j < 2; j++)\n                sums[j] += entry.second[i][j];\n        }\n        if (sums[1] > sums[0])\n            hi[i] = 1;\n        if (sums[1] < sums[0])\n            lo[i] = 1;\n    }\n    for (int i = 0; i < M; i++)\n        cout << lo[i];\n    cout << \'\\n\';\n    for (int i = 0; i < M; i++)\n        cout << hi[i];\n    cout << \'\\n\';\n\n    return 0;\n}\n']","['bitmasks', 'brute force', 'dfs and similar', 'expression parsing', 'implementation']",1800
https://codeforces.com//contest/634/problem/E,E. Preorder Test,For his computer science class Jacob builds a model tree with sticks and balls containing nodes in the shape of a tree Jacob has spent minutes building the th ball in the tree Jacob s teacher will evaluate his model and grade Jacob based on the effort he has put in However she does not have enough time to search his whole tree to determine this Jacob knows that she will examine the first nodes in a DFS order traversal of the tree She will then assign Jacob a grade equal to the minimum she finds among those nodes Though Jacob does not have enough time to rebuild his model he can choose the root node that his teacher starts from Furthermore he can rearrange the list of neighbors of in any order he likes Help Jacob find the best grade he can get on this assignment A DFS order traversal is an ordering of the nodes of a rooted tree built by a recursive DFS procedure initially called on the root of the tree When called on a given node the procedure does the following Print Traverse the list of neighbors of the node in order and iteratively call DFS procedure on each one Do not call DFS procedure on node if you came to node directly from ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nconst int MX = 2.1e5;\n\nint N, K;\nint ai[MX];\nVI E[MX];\nVI child[MX];\nbool light[MX];\nll dp[MX][5];\n/*\n0 -> root\n1 -> unknown, but parent is dark\n2 -> in the light set, on the path\n3 -> in the light set, NOT on the path, no path available\n4 -> in the light set, NOT on the path, path available\n*/\n\nconst int NINF = -1e9;\n\nvoid solve(int x)\n{\n\tforeach(o, child[x])\n\t\tsolve(o);\n\tll useNow = NINF;\n\t{\n\t\tll& ans = dp[x][4];\n\t\tans = NINF;\n\t\tif (light[x])\n\t\t{\n\t\t\t{\n\t\t\t\t// SAVE THE PATH FOR LATER\n\t\t\t\tll sum = 1;\n\t\t\t\tll bestDelta = 0;\n\t\t\t\tforeach(o, child[x])\n\t\t\t\t{\n\t\t\t\t\tsum += dp[o][3];\n\t\t\t\t\tbestDelta = max(bestDelta, dp[o][4] - dp[o][3]);\n\t\t\t\t}\n\t\t\t\tsum += bestDelta;\n\t\t\t\tans = max(ans, sum);\n\t\t\t}\n\t\t\t{\n\t\t\t\t// USE IT NOW\n\t\t\t\tll sum = 1;\n\t\t\t\tll bestA = 0;\n\t\t\t\tll bestB = 0;\n\t\t\t\tforeach(o, child[x])\n\t\t\t\t{\n\t\t\t\t\tll v1 = max(0LL, dp[o][3]);\n\t\t\t\t\tll v2 = dp[o][2];\n\t\t\t\t\tsum += v1;\n\t\t\t\t\tll delta = v2 - v1;\n\t\t\t\t\tif (delta > bestA)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestB = bestA;\n\t\t\t\t\t\tbestA = delta;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbestB = max(bestB, delta);\n\t\t\t\t}\n\t\t\t\tuseNow = sum + bestA + bestB;\n\t\t\t\tans = max(ans, useNow);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tll& ans = dp[x][3];\n\t\tans = NINF;\n\t\tif (light[x])\n\t\t{\n\t\t\tll sum = 1;\n\t\t\tforeach(o, child[x])\n\t\t\t\tsum += dp[o][3];\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\t{\n\t\tll& ans = dp[x][2];\n\t\tans = NINF;\n\t\tif (light[x])\n\t\t{\n\t\t\tll sum = 1;\n\t\t\tll bestDelta = 0;\n\t\t\tforeach(o, child[x])\n\t\t\t{\n\t\t\t\tll v1 = max(0LL, dp[o][3]);\n\t\t\t\tll v2 = dp[o][2];\n\t\t\t\tsum += v1;\n\t\t\t\tbestDelta = max(bestDelta, v2 - v1);\n\t\t\t}\n\t\t\tsum += bestDelta;\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\t{\n\t\tll& ans = dp[x][1];\n\t\tans = useNow;\n\t\tforeach(o, child[x])\n\t\t\tans = max(ans, dp[o][1]);\n\t}\n\t// printf(""%d [%s] -> %lld %lld %lld %lld\\n"", x, light[x] ? ""light"" : ""dark"", dp[x][1], dp[x][2], dp[x][3], dp[x][4]);\n}\n\nint ROOT = 0;\n\nbool ok(int threshold)\n{\n\t// printf(""Testing OK with threshold %d\\n"", threshold);\n\tji(N) light[i] = ai[i] >= threshold;\n\tif (light[ROOT])\n\t\treturn true;\n\tsolve(ROOT);\n\treturn dp[ROOT][1] >= K;\n}\n\nvoid init(int x, int par)\n{\n\tforeach(o, E[x]) if (o != par)\n\t{\n\t\tchild[x].pb(o);\n\t\tinit(o, x);\n\t}\n\t// printf(""%d:"", x);\n\t// foreach(o, child[x]) printf("" %d"", o);\n\t// printf(""\\n"");\n}\n\nint main()\n{\n\trint(N);\n\trint(K);\n\tji(N) rint(ai[i]);\n\tjk(N-1)\n\t{\n\t\tint u, v;\n\t\trint(u); rint(v);\n\t\t--u, --v;\n\t\tE[u].pb(v);\n\t\tE[v].pb(u);\n\t}\n\tji(N) if (ai[i] < ai[ROOT])\n\t\tROOT = i;\n\tinit(ROOT, -1);\n\tVI vals(N);\n\tji(N) vals[i] = ai[i];\n\tsort(vals.begin(), vals.end());\n\treverse(vals.begin(), vals.end());\n\tint lo = K-1;\n\tint hi = N-1;\n\twhile (lo != hi)\n\t{\n\t\t// printf(""[%d %d]\\n"", vals[lo], vals[hi]);\n\t\tint mid = (lo + hi) / 2;\n\t\tif (ok(vals[mid]))\n\t\t\thi = mid;\n\t\telse\n\t\t\tlo = mid+1;\n\t}\n\tprintf(""%d\\n"", vals[lo]);\n}\n']","['binary search', 'dfs and similar', 'graphs', 'greedy']",2600
https://codeforces.com//contest/701/problem/B,B. Cells Not Under Attack,Vasya has the square chessboard of size and rooks Initially the chessboard is empty Vasya will consequently put the rooks on the board one after another The cell of the field is under rook s attack if there is at least one rook located in the same row or in the same column with this cell If there is a rook located in the cell this cell is also under attack You are given the positions of the board where Vasya will put rooks For each rook you have to determine the number of cells which are after Vasya puts it on the board ,"['#include<cstdlib>\n#include<cctype>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<numeric>\n#include<iomanip>\n#include<bitset>\n#include<list>\n#include<stdexcept>\n#include<functional>\n#include<utility>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define MP make_pair\n#define PB push_back\n#define AA first\n#define BB second\n#define OP begin()\n#define ED end()\n#define SZ size()\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\n#define cmin(x,y) x=min(x,y)\n#define cmax(x,y) x=max(x,y)\nconst LL MOD = 1000000007;\nconst double PI = acos(-1.);\nconst double eps = 1e-9;\nLL modPow(LL a,LL b,LL MOD){\n\tLL ret=1;for(;b;b>>=1){\n\t\tif(b&1)ret=ret*a%MOD;a=a*a%MOD;\n\t}return ret;\n}\n\nint x[100005],y[100005];\nvoid solve(){\n\tint n,m;\n\tscanf(""%d%d"",&n,&m);\n\tint X=n,Y=n;\n\trep(i,0,n)x[i]=y[i]=0;\n\trep(i,0,m){\n\t\tint p,q;\n\t\tscanf(""%d%d"",&p,&q);\n\t\tif(!x[p])x[p]=1,X--;\n\t\tif(!y[q])y[q]=1,Y--;\n\t\tprintf(""%I64d "",1LL*X*Y);\n\t}\n\tprintf(""\\n"");\n}\n\nint main(){\n\tint _T=1;\n\trep(CA,0,_T){\n\t\tsolve();\n\t}\n\treturn 0;\n}']","['data structures', 'math']",1200
https://codeforces.com//contest/403/problem/E,E. Two Rooted Trees,You have two rooted undirected trees each contains vertices Let s number the vertices of each tree with integers from to The root of each tree is at vertex The edges of the first tree are painted blue the edges of the second one are painted red For simplicity let s say that the first tree is blue and the second tree is red Edge is called bad for edge if two conditions are fulfilled The color of edge is different from the color of edge Let s consider the tree of the same color that edge is Exactly one of vertices lies both in the subtree of vertex and in the subtree of vertex In this problem your task is to simulate the process described below The process consists of several stages On each stage edges of exactly one color are deleted On the first stage exactly one blue edge is deleted Let s assume that at the stage we ve deleted edges At the stage we will delete all undeleted bad edges for edge then we will delete all undeleted bad edges for edge and so on until we reach edge For each stage of deleting edges determine what edges will be removed on the stage Note that the definition of a bad edge always considers the initial tree before it had any edges removed ,"['#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<"" = ""<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define maxn 200010\n#define INF 1000000000\n\nstruct node\n{\n\tint left, right, mid, minv, minvi;\n};\n\nstruct SegT\n{\n\tnode a[524288];\n\t\n\tvoid update(int i)\n\t{\n\t\tif (a[i*2].minv<a[i*2+1].minv)\n\t\t{\n\t\t\ta[i].minv=a[i*2].minv; a[i].minvi=a[i*2].minvi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[i].minv=a[i*2+1].minv; a[i].minvi=a[i*2+1].minvi;\n\t\t}\n\t}\n\t\n\tvoid build(int i, int bg, int ed)\n\t{\n\t\ta[i].left=bg; a[i].right=ed; a[i].mid=(bg+ed)/2;\n\t\tif (bg==ed) { a[i].minv=INF; a[i].minvi=bg; return; }\n\t\tbuild(i*2,bg,a[i].mid); build(i*2+1,a[i].mid+1,ed);\n\t\tupdate(i);\n\t}\n\t\n\tvoid serere(int i, int pl, int val)\n\t{\n\t\tif (a[i].left==a[i].right) { a[i].minv=val; a[i].minvi=a[i].left; return; }\n\t\tif (pl<=a[i].mid) serere(i*2,pl,val); else serere(i*2+1,pl,val);\n\t\tupdate(i);\n\t}\n\t\n\tpair<int,int> query(int i, int bg, int ed)\n\t{\n\t\tif (bg<=a[i].left && a[i].right<=ed) return make_pair(a[i].minv,a[i].minvi);\n\t\tif (ed<=a[i].mid) return query(i*2,bg,ed);\n\t\tif (a[i].mid<bg) return query(i*2+1,bg,ed);\n\t\tpair<int,int> t1=query(i*2,bg,ed), t2=query(i*2+1,bg,ed);\n\t\tif (t1.first<t2.first) return t1; else return t2;\n\t}\n};\n\t\nstruct tree\n{\n\tint n, tot;\n\tvector<int> e[maxn];\n\tint parent[maxn], depth[maxn], lg2[maxn], killed[maxn];\n\tint p[maxn][20], lbound[maxn], rbound[maxn], whom[maxn];\n\tSegT t;\n\tmap< pair<int,int>, int> snum, sonum;\n\tvector< pair<int,int> > eo[maxn];\n\tint edge_o1[maxn], edge_o2[maxn];\n\tvector< pair<int,int> >::iterator iter[maxn];\n\t\n\tvoid dfs(int cur, int pre, int dep)\n\t{\n\t\ttot++; lbound[cur]=tot; whom[tot]=cur;\n\t\tdepth[cur]=dep; p[cur][0]=pre; parent[cur]=pre;\n\t\trep(i,1,lg2[dep]) p[cur][i]=p[p[cur][i-1]][i-1];\n\t\trept(it,e[cur])\n\t\t\tif (*it!=pre)\n\t\t\t\tdfs(*it,cur,dep+1);\n\t\t\t\n\t\trbound[cur]=tot;\n\t}\n\t\n\tint moveup(int x, int y)\n\t{\n\t\twhile (y) x=p[x][lg2[y&-y]], y-=y&-y;\n\t\treturn x;\n\t}\n\t\n\tint lca(int x, int y)\n\t{\n\t\tif (depth[x]>depth[y]) x=moveup(x,depth[x]-depth[y]); else y=moveup(y,depth[y]-depth[x]);\n\t\trepd(i,19,0)\n\t\t\tif (p[x][i]!=p[y][i])\n\t\t\t{\n\t\t\t\tx=p[x][i]; y=p[y][i];\n\t\t\t}\n\t\tif (x==y) return x; else return p[x][0];\n\t}\n\t\n\tvoid readin(int _n, int *d, int *od)\n\t{\n\t\tn=_n;\n\t\trep(i,1,n-1)\n\t\t{\n\t\t\tint x=d[i], y=i+1;\n\t\t\te[x].push_back(y); e[y].push_back(x);\n\t\t\tsnum[make_pair(x,y)]=i;\n\t\t\tsnum[make_pair(y,x)]=i;\n\t\t}\n\t\t\n\t\tlg2[1]=0; rep(i,2,maxn-1) lg2[i]=lg2[i/2]+1;\n\t\ttot=0;\n\t\tdfs(1,0,0);\n\t\tt.build(1,1,n);\n\t\t\n\t\trep(i,1,n-1)\n\t\t{\n\t\t\tint x=od[i], y=i+1;\n\t\t\tsonum[make_pair(x,y)]=i;\n\t\t\tsonum[make_pair(y,x)]=i;\n\t\t\tint z=depth[lca(x,y)];\n\t\t\teo[x].push_back(make_pair(z,i));\n\t\t\teo[y].push_back(make_pair(z,i));\n\t\t\tedge_o1[i]=x; edge_o2[i]=y;\n\t\t}\n\t\t\n\t\trep(i,1,n) eo[i].push_back(make_pair(INF,0));\n\t\trep(i,1,n) sort(eo[i].begin(),eo[i].end());\n\t\trep(i,1,n) t.serere(1,lbound[i],(eo[i].begin())->first);\n\t\trep(i,1,n) iter[i]=eo[i].begin();\n\t\tmemset(killed,0,sizeof killed);\n\t}\n\t\n\tvoid kill_edge(int x, int y)\n\t{\n\t\tkilled[sonum[make_pair(x,y)]]=1;\n\t}\n\t\n\tvoid kill(int x, int y, vector< pair<int,int> > &ret)\n\t{\n\t\tif (parent[y]==x) swap(x,y);\n\t\twhile (1)\n\t\t{\n\t\t\tpair<int,int> ts=t.query(1,lbound[x],rbound[x]);\n\t\t\tif (ts.first>=depth[x]) break;\n\t\t\tint where=whom[ts.second];\n\t\t\tint edge_id=iter[where]->second;\n\t\t\tif (!killed[edge_id])\n\t\t\t{\n\t\t\t\tkilled[edge_id]=1;\n\t\t\t\tret.push_back(make_pair(edge_o1[edge_id],edge_o2[edge_id]));\n\t\t\t}\n\t\t\titer[where]++;\n\t\t\tt.serere(1,lbound[where],iter[where]->first);\n\t\t}\n\t}\n\t\n};\n\ntree blue, red;\nint d1[maxn], d2[maxn];\n\nvoid lemon()\n{\n\tint n; scanf(""%d"",&n);\n\trep(i,1,n-1) scanf(""%d"",&d1[i]);\n\trep(i,1,n-1) scanf(""%d"",&d2[i]);\n\tint idx; scanf(""%d"",&idx);\n\tint x0=idx+1, y0=d1[idx];\n\tblue.readin(n,d1,d2);\n\tred.readin(n,d2,d1);\n\tred.kill_edge(x0,y0);\n\t\n\tint who=0;\n\tvector< pair<int,int> > cur, next;\n\tcur.push_back(make_pair(x0,y0));\n\twhile (!cur.empty())\n\t{\n\t\tnext.clear();\n\t\tif (who==0)\n\t\t{\n\t\t\tprintf(""Blue\\n"");\n\t\t\tvector<int> ans; ans.clear();\n\t\t\trept(it,cur) ans.push_back(blue.snum[*it]);\n\t\t\tsort(ans.begin(),ans.end());\n\t\t\trept(it,ans) printf(""%d "",*it); printf(""\\n"");\n\t\t\trept(it,cur) blue.kill(it->first,it->second,next);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(""Red\\n"");\n\t\t\tvector<int> ans; ans.clear();\n\t\t\trept(it,cur) ans.push_back(red.snum[*it]);\n\t\t\tsort(ans.begin(),ans.end());\n\t\t\trept(it,ans) printf(""%d "",*it); printf(""\\n"");\n\t\t\trept(it,cur) red.kill(it->first,it->second,next);\n\t\t}\n\t\tswap(cur,next);\n\t\twho=1-who;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""E.in"",""r"",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n']","['data structures', 'implementation', 'trees']",2900
https://codeforces.com//contest/145/problem/E,E. Lucky Queries,Petya brought home string with the length of The string only consists of lucky digits The digits are numbered from the left to the right starting with Now Petya should execute queries of the following form switch digits i e replace them with their opposites at all positions with indexes from to inclusive each digit is replaced with and each digit is replaced with find and print on the screen the length of the longest non decreasing subsequence of string Subsequence of a string is a string that can be obtained from by removing zero or more of its elements A string is called non decreasing if each successive digit is not less than the previous one Help Petya process the requests ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\nint n,m;\ntypedef struct {\n\tint n4,n7,n47,n74;\n\tint delayed;\n} T;\n\nint init[1024000];\nconst int LIMIT = (1<<21);\nT a[LIMIT];\n\ninline void change(int v)\n{\n\tswap(a[v].n4,a[v].n7);\n\tswap(a[v].n47,a[v].n74);\n\ta[v].delayed ^= 1;\n}\n\ninline void down(int v)\n{\n\tif (!a[v].delayed) return;\n\ta[v].delayed = 0;\n\tif (v*2 < LIMIT) change(v*2);\n\tif (v*2+1 < LIMIT) change(v*2+1);\n}\n\ninline void up(int v)\n{\n\tdown(v);\n\ta[v].n4 = a[v*2].n4 + a[v*2+1].n4;\n\ta[v].n7 = a[v*2].n7 + a[v*2+1].n7;\n\ta[v].n47 = max(a[v*2].n47 + a[v*2+1].n7, a[v*2].n4 + a[v*2+1].n47);\n\ta[v].n74 = max(a[v*2].n74 + a[v*2+1].n4, a[v*2].n7 + a[v*2+1].n74);\n}\n\nvoid build(int v, int l, int r)\n{\n\tif (l==r)\n\t{\n\t\tif (init[l]==4)\n\t\t\ta[v].n4 = 1;\n\t\telse\n\t\t\ta[v].n7 = 1;\n\t\ta[v].n47 = a[v].n74 = 1;\n\t}\n\telse\n\t{\n\t\tint mid = (l+r)/2;\n\t\tbuild(v*2,l,mid);\n\t\tbuild(v*2+1,mid+1,r);\n\t\tup(v);\n\t}\n}\n\nint cl,cr;\n\nvoid go(int v, int l, int r)\n{\n\tif (r < cl || cr < l) return;\n\tif (cl <= l && r <= cr)\n\t{\n\t\tchange(v);\n\t\treturn;\n\t}\n\tint mid = (l+r)/2;\n\tdown(v);\n\tgo(v*2,l,mid);\n\tgo(v*2+1,mid+1,r);\n\tup(v);\n}\n\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tscanf(""%d%d"",&n,&m);\n\tCLEAR(a);\n\tREP(i,n)\n\t{\n\t\tchar c;\n\t\tdo c = getc(stdin);\n\t\twhile (c!=\'4\'&&c!=\'7\');\n\t\tinit[i]=c-\'0\';\n\t}\n\n\t//REP(i,n) init[i]=i%2 ? 4 : 7;\n\n\tbuild(1,0,n-1);\n\tREP(i,m)\n\t{\n\t\tchar cmd[256];\n\t\tscanf(""%s"",cmd);\n\t\t//if (i%2 == 0) strcpy(cmd,""count""); else cmd[0]=0;\n\t\tif (strcmp(cmd,""count"")==0)\n\t\t\tprintf(""%d\\n"",a[1].n47);\n\t\telse\n\t\t{\n\t\t\tscanf(""%d%d"",&cl,&cr);\n\t\t\t//cl = rand()%n+1; cr = rand()%n+1; if (cl>cr) swap(cl,cr);\n\t\t\t--cl,--cr;\n\t\t\tgo(1,0,n-1);\n\t\t}\n\t}\n\treturn 0;\n}']",['data structures'],2400
https://codeforces.com//contest/181/problem/A,A. Series of Crimes,The Berland capital is shaken with three bold crimes committed by the Pihsters a notorious criminal gang The Berland capital s map is represented by an rectangular table Each cell of the table on the map represents some districts of the capital The capital s main detective Polycarpus took a map and marked there the districts where the first three robberies had been committed as asterisks Deduction tells Polycarpus that the fourth robbery will be committed in such district that all four robbed districts will form the vertices of some rectangle parallel to the sides of the map Polycarpus is good at deduction but he s hopeless at math So he asked you to find the district where the fourth robbery will be committed ,"['#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long i64;\ntypedef unsigned long long ui64;\n\nconst int intINF=999999999;\nconst i64 i64INF=99999999999999999ll;\nconst double doubleINF=9999999999.;\n\nusing namespace std;\n\nint X[4],Y[4],l;\n\nint main(){\n\tint n,m;\n\tchar c;\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(""%*c"");\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(""%c"",&c);\n\t\t\tif(c==\'*\') X[++l]=i,Y[l]=j;\n\t\t}\n\t}\n\tsort(X+1,X+4);\n\tsort(Y+1,Y+4);\n\tif(X[1]==X[2]) printf(""%d"",X[3]);\n\telse printf(""%d"",X[1]);\n\tprintf("" "");\n\tif(Y[1]==Y[2]) printf(""%d"",Y[3]);\n\telse printf(""%d"",Y[1]);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","['brute force', 'geometry', 'implementation']",800
https://codeforces.com//contest/696/problem/A,A. Lorenzo Von Matterhorn,Barney lives in NYC NYC has infinite number of intersections numbered with positive integers starting from 1 There exists a bidirectional road between intersections and and another road between and for every positive integer You can clearly see that there exists a unique shortest path between any two intersections Initially anyone can pass any road for free But since SlapsGiving is ahead of us there will consecutive events happen soon There are two types of events 1 Government makes a new rule A rule can be denoted by integers and As the result of this action the passing fee of all roads on the shortest path from to increases by dollars 2 Barney starts moving from some intersection and goes to intersection where there s a girl he wants to cuddle using his fake name Lorenzo Von Matterhorn He always uses the shortest path visiting minimum number of intersections or roads between two intersections Government needs your calculations For each time Barney goes to cuddle a girl you need to tell the government how much money he should pay sum of passing fee of all roads he passes ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nmap<ll,ll> dp;\nint q,ty,w;\nll u,v;\nint main() {\n\tscanf(""%d"",&q);\n\trep(i,0,q) {\n\t\tscanf(""%d%lld%lld"",&ty,&u,&v);\n\t\tif (ty==1) {\n\t\t\tscanf(""%d"",&w);\n\t\t\twhile (u!=v) {\n\t\t\t\tif (u>v) swap(u,v);\n\t\t\t\tdp[v]+=w; v/=2;\n\t\t\t}\n\t\t} else {\n\t\t\tll s=0;\n\t\t\twhile (u!=v) {\n\t\t\t\tif (u>v) swap(u,v);\n\t\t\t\ts+=dp[v]; v/=2;\n\t\t\t}\n\t\t\tprintf(""%lld\\n"",s);\n\t\t}\n\t}\n}\n']","['brute force', 'data structures', 'implementation', 'trees']",1500
https://codeforces.com//contest/1558/problem/F,F. Strange Sort,You have a permutation an array a a 1 a 2 ldots a n of distinct integers from 1 to n The length of the permutation n is odd Consider the following algorithm of sorting the permutation in increasing order A helper procedure of the algorithm f i takes a single argument i 1 le i le n 1 and does the following If a i a i 1 the values of a i and a i 1 are exchanged Otherwise the permutation doesn t change The algorithm consists of iterations numbered with consecutive integers starting with 1 On the i th iteration the algorithm does the following if i is odd call f 1 f 3 ldots f n 2 if i is even call f 2 f 4 ldots f n 1 It can be proven that after a finite number of iterations the permutation will be sorted in increasing order After how many iterations will this happen for the first time ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nint solve(vector<int> a){\n\tint n = (int)a.size();\n\tbool sorted = true;\n\tfor(int i = 0; i < n; i++) if(a[i] != i) sorted = false;\n\tif(sorted){\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i+1 < n; i += 2){\n\t\tif(a[i] > a[i+1]) swap(a[i], a[i+1]);\n\t}\n\tvector<int> loc(n);\n\tfor(int i = 0; i < n; i++) loc[a[i]] = i;\n\tvector<int> r(n+1, 0);\n\tfor(int i = 0; i <= n; i++) r[i] = n-i;\n\tNode segtree(r, 0, n+2);\n\tint ans = 0;\n\tint min1 = n;\n\tint max0 = n-1;\n\tfor(int i = n-1; i > 0; i--){\n\t\tsegtree.add(loc[i]+1, n+2, 1);\n\t\tsegtree.add(0, loc[i]+1, -1);\n\t\tmin1 = min(min1, loc[i]);\n\t\twhile(a[max0] >= i) max0--;\n\t\tans = max(ans, segtree.query(min1, max0+1));\n\t}\n\treturn 1 + max(ans - 1, 0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor(int& x : a){\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\t\tint ans = solve(a);\n\t\tcout << ans << '\\n';\n\t}\n}""]","['data structures', 'sortings']",3300
https://codeforces.com//contest/817/problem/A,A. Treasure Hunt,Captain Bill the Hummingbird and his crew recieved an interesting challenge offer Some stranger gave them a map potion of teleportation and said that only this potion might help them to reach the treasure Bottle with potion has two values and written on it These values define four moves which can be performed using the potion Map shows that the position of Captain Bill the Hummingbird is and the position of the treasure is You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline If it is possible for Captain to reach the treasure using the potion then output otherwise without quotes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nvoid solve() {\n    int x[2], y[2], a, b;\n    FOR(i, 0, 2) cin >> x[i] >> y[i];\n    cin >> a >> b;\n    int u = abs(x[0] - x[1]);\n    int v = abs(y[0] - y[1]);\n    if (u % a || v % b) {\n        cout << ""NO\\n"";\n        return;\n    }\n    if (u / a + v / b & 1) {\n        cout << ""NO\\n"";\n    }\n    else {\n        cout << ""YES\\n"";\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","['implementation', 'math', 'number theory']",1200
https://codeforces.com//contest/1854/problem/A2,A2. Dual  Hard Version ,You are given an array a 1 a 2 dots a n of integers positive negative or 0 You can perform multiple operations on the array possibly 0 operations In one operation you choose i j 1 leq i j leq n they can be equal and set a i a i a j i e add a j to a i Make the array non decreasing i e a i leq a i 1 for 1 leq i leq n 1 in at most 31 operations You do not need to minimize the number of operations ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nvector<pii> wyn;\n\nvoid zrob(int a, int b)\n{\n\ttab[a]+=tab[b];\n\twyn.push_back({a, b});\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &tab[i]);\n\t}\n\twyn.clear();\n\tint a=1;\n\tint b=1;\n\tint dod=0;\n\tint uje=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (tab[i]>0)\n\t\t\tdod++;\n\t\tif (tab[i]<0)\n\t\t\tuje++;\n\t\tif (tab[i]>tab[a])\n\t\t\ta=i;\n\t\tif (tab[i]<tab[b])\n\t\t\tb=i;\n\t}\n\tif (tab[a]+tab[b]>=0 && uje<=12)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tif (tab[i]<0)\n\t\t\t\tzrob(i, a);\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tzrob(i, i-1);\n\t}\n\telse\n\t{\n\t\tif (tab[a]+tab[b]<=0 && dod<=12)\n\t\t{\n\t\t\tfor (int i=1; i<=n; i++)\n\t\t\t\tif (tab[i]>0)\n\t\t\t\t\tzrob(i, b);\n\t\t\tfor (int i=n-1; i; i--)\n\t\t\t\tzrob(i, i+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (uje<=7)\n\t\t\t{\n\t\t\t\tfor (int i=1; i<=5; i++)\n\t\t\t\t\tzrob(a, a);\n\t\t\t\tfor (int i=1; i<=n; i++)\n\t\t\t\t\tif (tab[i]<0)\n\t\t\t\t\t\tzrob(i, a);\n\t\t\t\tfor (int i=2; i<=n; i++)\n\t\t\t\t\tzrob(i, i-1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(dod<=7);\n\t\t\t\tfor (int i=1; i<=5; i++)\n\t\t\t\t\tzrob(b, b);\n\t\t\t\tfor (int i=1; i<=n; i++)\n\t\t\t\t\tif (tab[i]>0)\n\t\t\t\t\t\tzrob(i, b);\n\t\t\t\tfor (int i=n-1; i; i--)\n\t\t\t\t\tzrob(i, i+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprintf(""%d\\n"", (int)wyn.size());\n\tfor (pii i : wyn)\n\t\tprintf(""%d %d\\n"", i.first, i.second);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['constructive algorithms', 'math']",1900
https://codeforces.com//contest/1098/problem/B,B. Nice table,You are given an n times m table consisting of characters Let s call a table if every 2 times 2 square contains all four distinct characters Your task is to find a nice table also consisting of that differs from the given table in the minimum number of characters ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\n\nusing pla=vector<vi>;\n\nint n, m;\n\npla tab;\n\nint pam;\npla wyn;\n\nchar wcz[nax];\nchar zn[]={\'A\', \'C\', \'T\', \'G\'};\n\nint tlu(char v)\n{\n\tfor (int i=0; i<4; i++)\n\t\tif (zn[i]==v)\n\t\t\treturn i;\n\tassert(0);\n}\n\nint roz(const pla &a, const pla &b)\n{\n\tint ret=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<m; j++)\n\t\t\tret+=(a[i][j]!=b[i][j]);\n\treturn ret;\n}\n\nint rozr(const pla &a, const pla &b, int r)\n{\n\tint ret=0;\n\tfor (int i=r; i<=r; i++)\n\t\tfor (int j=0; j<m; j++)\n\t\t\tret+=(a[i][j]!=b[i][j]);\n\treturn ret;\n}\n\nint rozc(const pla &a, const pla &b, int c)\n{\n\tint ret=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=c; j<=c; j++)\n\t\t\tret+=(a[i][j]!=b[i][j]);\n\treturn ret;\n}\n\nvoid cons(pla v)\n{\n\tint x=roz(v, tab);\n\tif (wyn.empty() || x<pam)\n\t{\n\t\twyn=v;\n\t\tpam=x;\n\t}\n}\n\nvoid dajr(int a, int b)\n{\n\tvi tu[2];\n\ttu[0]={a, b};\n\tfor (int i=0; i<4; i++)\n\t\tif (i!=a && i!=b)\n\t\t\ttu[1].push_back(i);\n\tpla gen(n, vi(m, 0));\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tvi rozy;\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int l=0; l<m; l++)\n\t\t\t\tgen[i][l]=(tu[i&1][(l+j)&1]);\n\t\t\trozy.push_back(rozr(gen, tab, i));\n\t\t}\n\t\tint w=(rozy[0]>rozy[1]);\n\t\tfor (int l=0; l<m; l++)\n\t\t\tgen[i][l]=(tu[i&1][(l+w)&1]);\n\t}\n\tcons(gen);\n}\n\nvoid dajc(int a, int b)\n{\n\tvi tu[2];\n\ttu[0]={a, b};\n\tfor (int i=0; i<4; i++)\n\t\tif (i!=a && i!=b)\n\t\t\ttu[1].push_back(i);\n\tpla gen(n, vi(m, 0));\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tvi rozy;\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int l=0; l<n; l++)\n\t\t\t\tgen[l][i]=(tu[i&1][(l+j)&1]);\n\t\t\trozy.push_back(rozc(gen, tab, i));\n\t\t}\n\t\tint w=(rozy[0]>rozy[1]);\n\t\tfor (int l=0; l<n; l++)\n\t\t\tgen[l][i]=(tu[i&1][(l+w)&1]);\n\t}\n\tcons(gen);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\ttab.resize(n, vi(m, 0));\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(""%s"", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\ttab[i][j]=tlu(wcz[j]);\n\t}\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tfor (int j=0; j<i; j++)\n\t\t{\n\t\t\tdajr(i, j);\n\t\t\tdajc(i, j);\n\t\t}\n\t}\n\t\n\t\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t\tprintf(""%c"", zn[wyn[i][j]]);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'math']",2100
https://codeforces.com//contest/554/problem/A,A. Kyoya and Photobooks,Kyoya Ootori is selling photobooks of the Ouran High School Host Club He has 26 photos labeled a to z and he has compiled them into a photo booklet with some photos in some order possibly with some photos being duplicated A photo booklet can be described as a string of lowercase letters consisting of the photos in the booklet in order He now wants to sell some special edition photobooks each with one extra photo inserted anywhere in the book He wants to make as many distinct photobooks as possible so he can make more money He asks Haruhi how many distinct photobooks can he make by inserting one extra photo into the photobook he already has Please help Haruhi solve this problem ,"['#pragma comment (linker, ""/STACK:1000000000"")\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nset <string> a;\n\nint main() {\n\tstring s;\n\n\tcin >> s;\n\n\tstring t;\n\n\tfor (int i = 0; i <= (int)s.size(); i++) {\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tt.clear();\n\t\t\tfor (int p = 0; p < i; p++) {\n\t\t\t\tt.push_back(s[p]);\n\t\t\t}\n\t\t\tt.push_back(\'a\' + j);\n\t\t\tfor (int p = i; p < (int)s.size(); p++) {\n\t\t\t\tt.push_back(s[p]);\n\t\t\t} \n\t\t\ta.insert(t);\n\t\t}\n\t}\n\n\tcout << a.size() << endl;\n\n\treturn 0;\n}\n']","['brute force', 'math', 'strings']",900
https://codeforces.com//contest/314/problem/D,D. Sereja and Straight Lines,Sereja placed points on a plane Now Sereja wants to place on the plane two straight lines intersecting at a right angle so that one of the straight lines intersect the axis at an angle of degrees and the maximum distance from the points to the straight lines were minimum In this problem we consider the distance between points and equal The distance between the point and the straight lines is the minimum distance from the point to some point belonging to one of the lines Help Sereja find the maximum distance from the points to the optimally located straight lines ,"['#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MAXN = 1<<18;\n\npair<LL,LL> pts[MAXN];\nLL minYL[MAXN],maxYL[MAXN],minYR[MAXN],maxYR[MAXN];\n\nconst LL INF = 2000000002;\nint main() {\n    int N;\n    scanf(""%d"",&N);\n    REP(i,N) {\n        int a,b;\n        scanf(""%d%d"",&a,&b);\n        pts[i].st = a - b;\n        pts[i].nd = a + b;\n    }\n\n    sort(pts, pts+N);\n    \n    minYL[0] = maxYL[0] = pts[0].nd;\n    FOR(i,1,N) {\n        minYL[i] = min(minYL[i-1], pts[i].nd);\n        maxYL[i] = max(maxYL[i-1], pts[i].nd);        \n    }\n\n    minYR[N-1] = maxYR[N-1] = pts[N-1].nd;\n    FORD(i,N-1,0) {\n        minYR[i] = min(minYR[i+1], pts[i].nd);\n        maxYR[i] = max(maxYR[i+1], pts[i].nd);        \n    }    \n    \n    LL L = 0, R = 4 * INF;\n    while (L < R) {\n        LL S = (L + R) / 2;\n        \n        bool can = false;\n        \n        int j = 0;\n        REP(i,N) {\n            while (j < N - 1 && pts[j+1].st - pts[i].st <= S) ++j;\n            if (i == 0 && j == N-1) can = true;\n            \n            LL minY = INF, maxY = -INF;\n            if (i > 0) {\n                minY = min(minY, minYL[i-1]);\n                maxY = max(maxY, maxYL[i-1]);\n            }\n            if (j < N - 1) {\n                minY = min(minY, minYR[j+1]);\n                maxY = max(maxY, maxYR[j+1]);\n            }\n            if (maxY - minY <= S) can = true;\n            \n            if (can) break;\n        }    \n        \n        if (can) R = S;\n        else L = S + 1;\n    }\n    \n    double result = L * 0.5;\n    printf(""%0.8lf\\n"", result);\n}    ']","['binary search', 'data structures', 'geometry', 'sortings', 'two pointers']",2500
https://codeforces.com//contest/1353/problem/B,B. Two Arrays And Swaps,You are given two arrays a and b both consisting of n positive greater than zero integers You are also given an integer k In one move you can choose two indices i and j 1 le i j le n and swap a i and b j i e a i becomes b j and vice versa Note that i and j can be equal or different in particular swap a 2 with b 2 or swap a 3 and b 9 both are acceptable moves Your task is to find the possible sum you can obtain in the array a if you can do no more than i e at most k such moves swaps You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,k;\n           cin>>a>>k;\n           vector <int> m1(a);\n           vector <int> m2(a);\n           for (int i=0;i<a;i++) {\n               cin>>m1[i]; \n           }\n           for (int i=0;i<a;i++) cin>>m2[i];\n           sort(m1.begin(),m1.end());\n           sort(m2.begin(),m2.end());\n           reverse(m2.begin(),m2.end());\n           int sum=0;\n           for (int i=0;i<a;i++) {\n               if (i<k) sum+=max(m1[i],m2[i]); else sum+=m1[i]; \n                \n           }\n           cout<<sum<<""\\n""; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","['greedy', 'sortings']",800
https://codeforces.com//contest/878/problem/C,C. Tournament,Recently a tournament in kinds of sports has begun in Berland Vasya wants to make money on the bets The scheme of the tournament is very mysterious and not fully disclosed Competitions are held back to back each of them involves two sportsmen who have not left the tournament yet Each match can be held in any of the kinds of sport Loser leaves the tournament The last remaining sportsman becomes the winner Apart of this the scheme can be arbitrary it is not disclosed in advance Vasya knows powers of sportsmen in each kind of sport He believes that the sportsmen with higher power always wins The tournament is held every year and each year one new participant joins it In the first tournament only one sportsman has participated in the second there were two sportsmen and so on Vasya has been watching the tournament for the last years Help him to find the number of possible winners for each of the tournaments ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n\nint K;\nint u[10];\nclass datax {\npublic:\n\tint a[10];\n\tint b[10];\n\tint c;\n\tdatax() {\n\t\tfor (int i = 0; i < K; i++) a[i] = b[i] = u[i];\n\t\tc = 1;\n\t}\n\tdatax operator + (const datax &l) const {\n\t\tdatax rv;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\trv.a[i] = min(a[i], l.a[i]);\n\t\t\trv.b[i] = max(b[i], l.b[i]);\n\t\t}\n\t\trv.c = c + l.c;\n\t\treturn rv;\n\t}\n\tbool operator < (const datax &l) const {\n\t\treturn a[0] < l.a[0];\n\t}\n};\n\nset <datax> Sx;\nint main() {\n\tint N, i, j;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j < K; j++) scanf(""%d"", &u[j]);\n\n\t\tdatax cur = datax();\n\t\twhile (!Sx.empty()) {\n\t\t\tauto it = Sx.lower_bound(cur);\n\t\t\tif (it != Sx.begin()) {\n\t\t\t\tit--;\n\t\t\t\tbool c1 = false, c2 = false;\n\t\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\t\tif (it->b[i] > cur.a[i]) c1 = true;\n\t\t\t\t\tif (cur.b[i] > it->a[i]) c2 = true;\n\t\t\t\t}\n\t\t\t\tif (c1 && c2) {\n\t\t\t\t\tcur = cur + *it;\n\t\t\t\t\tSx.erase(it);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tit = Sx.lower_bound(cur);\n\t\t\tif (it != Sx.end()) {\n\t\t\t\tbool c1 = false, c2 = false;\n\t\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\t\tif (it->b[i] > cur.a[i]) c1 = true;\n\t\t\t\t\tif (cur.b[i] > it->a[i]) c2 = true;\n\t\t\t\t}\n\t\t\t\tif (c1 && c2) {\n\t\t\t\t\tcur = cur + *it;\n\t\t\t\t\tSx.erase(it);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tSx.insert(cur);\n\t\tauto it = Sx.end();\n\t\tit--;\n\t\tprintf(""%d\\n"", it->c);\n\t}\n\treturn 0;\n}']","['data structures', 'graphs']",2700
https://codeforces.com//contest/1058/problem/A,A. In Search of an Easy Problem,When preparing a tournament Codeforces coordinators try treir best to make the first problem as easy as possible This time the coordinator had chosen some problem and asked n people about their opinions Each person answered whether this problem is easy or hard If at least one of these n people has answered that the problem is hard the coordinator decides to change the problem For the given responses check if the problem is easy enough ,"['//Williams Wu\n/*#include <EGE.h> //��ͼͷ�ļ�\n#define SHOW_CONSOLE*/\n/*#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdlib> //�������\ueeaf�����ڴ���亯��\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���*/\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <listt> //STL�����б�����\n#include <mapp> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <sett> //STL��������\n#include <sstream> //�����ַ�������\n#include <stackk> //STL��ջ����\n#include <stdexcept> //��\u05fc�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h> //���ַ���������/���\n#include <cwctype.h> //���ַ�����*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(u,v,nxt) for(int u=(v);(u)<=(nxt);(u)++)\n#define rep_(u,v,nxt) for(int u=(v);(u)<(nxt);(u)++)\n#define repf(u,v,nxt) for(int u=(v);(u)>=(nxt);(u)--)\n#define repf_(u,v,nxt) for(int u=(v);(u)>(nxt);(u)--)\n#define inf 0x3f3f3f3f  //0x7fffffff\n#define cle(u) memset(u,0,sizeof(u))\n#define clemin(u) memset(u,-1,sizeof(u))\n#define clemax(u) memset(u,0x3f,sizeof(u))  //127\nconst double PI=3.14159265358979323846264338327950288419716939937510;\nconst double E=2.7182818284590452353602874713526624977572470936999596;\nconst double eps=0.000000001;\ntypedef long long LL;\ninline int max(int u,int v){return u>v?u:v;}\ninline int min(int u,int v){return u<v?u:v;}\ninline LL gcd(LL u,LL v){return v?gcd(v,u%v):u;}\n///////////////////////optimize//////////////////////////\ntemplate <typename T>\ninline void read(T& u){char id;u=0;bool used=0;id=getchar();\nwhile(id>\'9\'||id<\'0\'){if(id==\'-\')used=1;id=getchar();}\nwhile((id<=\'9\'&&id>=\'0\')){u=u*10+id-\'0\';id=getchar();}if(used)u*=-1;}\ntemplate <typename T>\ninline void read(T& u,T& v){read(u);read(v);}\ntemplate <typename T>\ninline void read(T& u,T& v,T& tmp){read(u);read(v);read(tmp);}\n/////////////////variables&functions/////////////////////\n\nbool flag=0;\n\nint main() \n{\n    int n;\n    read(n);\n    rep(i,1,n) \n    {\n        int x;\n        read(x);\n        if(x) flag=1;\n    }\n    if(flag) puts(""HARD"");\n        else puts(""EASY"");\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",['implementation'],800
https://codeforces.com//contest/689/problem/E,E. Mike and Geometry Problem,Mike wants to prepare for IMO but he doesn t know geometry so his teacher gave him an interesting geometry problem Let s define to be the number of integer points in the segment with say that You are given two integers and and closed intervals on axis and you have to find In other words you should find the sum of the number of integer points in the intersection of any of the segments As the answer may be very large output it modulo Mike can t solve this problem so he needs your help You will help him won t you ,"['#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 400100;\n\nmap<int, int> nor;\nvector<int> vals, val;\nint sol, n, k, l[N], r[N], A[N];\nll P[N], I[N];\nll comb(int x, int y) {\n    return 1LL * P[x] * I[y] % mod * I[x - y] % mod;\n}\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""a.in"", ""r"", stdin);\n    freopen(""a.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n >> k;\n    FOR(i,1,n) {\n        cin >> l[i] >> r[i];\n        r[i]++;\n        vals.pb(l[i]);\n        vals.pb(r[i]);\n    }\n    P[0] = 1;\n    FOR(i,1,n) {\n        P[i] = 1LL * P[i - 1] * i % mod;\n    }\n    I[n] = powmod(P[n], mod - 2);\n    ROF(i,n-1,0) {\n        I[i] = I[i + 1] * (i + 1) % mod;\n    }\n    sort(vals.begin(), vals.end());\n    FIT(it,vals) {\n        if(!val.size()) {\n            val.pb(it);\n        } else if (val.back() != it) {\n            val.pb(it);\n        }\n    }\n    int t = 0;\n    FIT(it,val) {\n        nor[it] = ++t;\n    }\n    FOR(i,1,n) {\n        A[nor[l[i]]]++;\n        A[nor[r[i]]]--;\n    }\n    FOR(i,1,t) {\n        A[i] += A[i - 1];\n        if (A[i] >= k) {\n            sol += 1LL * comb(A[i],k) * (val[i] - val[i - 1]) % mod;\n            if (sol >= mod) {\n                sol -= mod;\n            }\n        }\n    }\n    cout << sol;\n    return 0;\n}']","['combinatorics', 'data structures', 'dp', 'geometry', 'implementation']",2000
https://codeforces.com//contest/766/problem/E,E. Mahmoud and a xor trip,Mahmoud and Ehab live in a country with cities numbered from to and connected by undirected roads It s guaranteed that you can reach any city from any other using these roads Each city has a number attached to it We define the distance from city to city as the of numbers attached to the cities on the path from to In other words if values attached to the cities on the path from to form an array of length then the distance between them is where is bitwise operation Mahmoud and Ehab want to choose two cities and make a journey from one to another The index of the start city is always less than or equal to the index of the finish city they may start and finish in the same city and in this case the distance equals the number attached to that city They can t determine the two cities so they try every city as a start and every city with greater index as a finish They want to know the total distance between all pairs of cities ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nll n, a[100100], b[100100];\nll cnt[100100][2];\nll sum;\nvector <int> g[100100];\n\nvoid dfs(int v, int pr = -1){\n    cnt[v][0] = cnt[v][1] = 0;\n    cnt[v][b[v]]++;\n    for(int i = 0; i < g[v].size(); ++i){\n        int to = g[v][i];\n        if(to != pr){\n            dfs(to, v);\n            sum += cnt[to][0] * cnt[v][1] + cnt[to][1] * cnt[v][0];\n            cnt[v][b[v]] += cnt[to][0];\n            cnt[v][b[v] ^ 1] += cnt[to][1];\n        }\n    }\n    sum += b[v];\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n    }\n    for(int i = 2, u, v; i <= n; ++i){\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll ans = 0;\n    for(int i = 0; i <= 20; ++i){\n        sum = 0;\n        for(int j = 1; j <= n; ++j){\n            if(a[j] & (1 << i)){\n                b[j] = 1;\n            }else{\n                b[j] = 0;\n            }\n        }\n        dfs(1);\n        ans += (sum << i);\n    }\n    cout << ans << endl;\n}\n']","['bitmasks', 'constructive algorithms', 'data structures', 'dfs and similar', 'dp', 'math', 'trees']",2100
https://codeforces.com//contest/281/problem/B,B. Nearest Fraction,You are given three positive integers Your task is to find the nearest fraction to fraction whose denominator is no more than Formally you should find such pair of integers that the value is as minimal as possible If there are multiple nearest fractions choose the one with the minimum denominator If there are multiple nearest fractions with the minimum denominator choose the one with the minimum numerator ,"[""#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\n#define eps 1e-7\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\n\tll x, y, n, a, b = -1;\n\tcin >> x >> y >> n;\n\tfor (ll d = 1; d <= n; d++) {\n\t\tll ini = 0, fim = n*x, m1, m2;\n\t\twhile (ini+2 < fim) {\n\t\t\tm1 = ini + (fim - ini)/3;\n\t\t\tm2 = fim - (fim - ini)/3;\n\t\t\tif (abs(x*d - m1*y) < abs(x*d - m2*y)) fim = m2;\n\t\t\telse ini = m1;\n\t\t}\n\t\tll val;\n\t\tif (abs(x*d - ini*y) <= abs(x*d - (ini+1)*y) && abs(x*d - ini*y) <= abs(x*d - fim*y)) val = ini;\n\t\telse if (abs(x*d - (ini+1)*y) <= abs(x*d - fim*y)) val = ini+1;\n\t\telse val = fim;\n\t\t\n\t\tif (b == -1 || b*abs(x*d - val*y) < d*abs(x*b - y*a)) {\n\t\t\tb = d;\n\t\t\ta = val;\n\t\t}\t\n\t}\n\tcout << a << '/' << b << endl;\n\treturn 0;\n}\n""]","['brute force', 'implementation', 'two pointers']",1700
https://codeforces.com//contest/1580/problem/C,C. Train Maintenance,Kawasiro Nitori is excellent in engineering Thus she has been appointed to help maintain trains There are n models of trains and Nitori s department will only have at most one train of each model at any moment In the beginning there are no trains at each of the following m days one train will be added or one train will be removed When a train of model i is added at day t it works for x i days day t inclusive then it is in maintenance for y i days then in work for x i days again and so on until it is removed In order to make management easier Nitori wants you to help her calculate how many trains are in maintenance in each day ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAGIC = 450;\n\nint n, m, x[200005], y[200005], cur, sum;\nint d0[200005], d1[455][455];\nint beg[200005];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep1(i, n) scanf(""%d%d"", &x[i], &y[i]);\n\t\n\trep(i, m) {\n\t\tint op, k, coef = 1;\n\t\tscanf(""%d%d"", &op, &k);\n\t\tif(op == 1) beg[k] = i;\n\t\telse {\n\t\t\tcoef = -1;\n\t\t\tif((i - 1 - beg[k]) % (x[k] + y[k]) < x[k]) cur --;\n\t\t}\n\t\tsum += coef;\n\t\tif(x[k] + y[k] < MAGIC) {\n\t\t\td1[x[k] + y[k]][beg[k] % (x[k] + y[k])] += coef; d1[x[k] + y[k]][(beg[k] + x[k]) % (x[k] + y[k])] -= coef;\n\t\t} else {\n\t\t\tfor(LL tmp = beg[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] += coef;\n\t\t\tfor(LL tmp = beg[k] + x[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] -= coef;\n\t\t}\n\t\tcur += d0[i];\n\t\tfor(int tmp = 2; tmp < MAGIC; tmp ++) cur += d1[tmp][i % tmp];\n\t\tprintf(""%d\\n"", sum - cur);\n\t}\n\treturn 0;\n}']","['brute force', 'data structures', 'implementation']",2200
https://codeforces.com//contest/1810/problem/A,A. Beautiful Sequence,A sequence of m integers a 1 a 2 ldots a m is if and only if there exists at least one i 1 le i le m such that a i i For example 3 2 3 is a good sequence since a 2 2 a 3 3 while 3 1 1 is not a good sequence since there is no i such that a i i A sequence a is if and only if there exists at least one subsequence of a satisfying that this subsequence is good For example 4 3 2 is a beautiful sequence since its subsequence 4 2 is good while 5 3 4 is not a beautiful sequence A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several possibly zero or all elements Now you are given a sequence check whether it is beautiful or not ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    bool ok = false;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        std::cin >> x;\n        \n        if (x <= i) {\n            ok = true;\n        }\n    }\n    \n    std::cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['brute force', 'greedy']",800
https://codeforces.com//contest/509/problem/F,F. Progress Monitoring,Programming teacher Dmitry Olegovich is going to propose the following task for one of his tests for students You are given a tree with vertices specified by its adjacency matrix What is the output of the following pseudocode used 1 n 0 0 procedure dfs v print v used v 1 for i 1 2 n if a v i 1 and used i 0 dfs i dfs 1 In order to simplify the test results checking procedure Dmitry Olegovich decided to create a tree such that the result is his favorite sequence On the other hand Dmitry Olegovich doesn t want to provide students with same trees as input otherwise they might cheat That s why Dmitry Olegovich is trying to find out the number of different trees such that the result of running the above pseudocode with as input is exactly the sequence Can you help him Two trees with vertices are called different if their adjacency matrices and are different i e there exists a pair such that and ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\n#define ll long long \n#define pp 1000000007\n#define N 510\nll dp[N][N];\nint a[N],n;\nll mo(ll a){\n   if(a>=0 && a<pp)return a;\n   a%=pp;\n   if(a<0)a+=pp;\n   return a;\n}\nint main(){\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++)scanf(""%d"",&a[i]);\n    for(int i=0;i<=n+1;i++)dp[i][i-1]=1;\n    for(int i=1;i<=n;i++)dp[i][i]=1;\n    for(int len=2;len<n;len++)\n      for(int i=1;i+len-1<=n;i++){\n        int j=i+len-1;\n        dp[i][j]=dp[i+1][j];\n        for(int k=i+1;k<=j;k++)\n          if(a[k]>a[i])dp[i][j]=mo(dp[i][j]+dp[i+1][k-1]*dp[k][j]);\n      }\n    cout<<dp[2][n]<<endl;\n    return 0;\n} \n']","['dp', 'trees']",2300
https://codeforces.com//contest/302/problem/D,D. Yaroslav and Time,Yaroslav is playing a game called Time The game has a timer showing the lifespan he s got left As soon as the timer shows 0 Yaroslav s character dies and the game ends Also the game has clock stations station number is at point of the plane As the player visits station number he increases the current time on his timer by The stations are for one time use only so if the player visits some station another time the time on his timer won t grow A player spends time units to move between stations where is the distance the player has covered and is some constant The distance between stations and is determined as Initially the player is at station number and the player has strictly more than zero and strictly less than one units of time At station number one unit of money can increase the time on the timer by one time unit you can buy only integer number of time units Now Yaroslav is wondering how much money he needs to get to station Help Yaroslav Consider the time to buy and to increase the timer value negligibly small ,"['#include <iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint n,dd;\nint a[200];\nint x[200],y[200];\nint g[200][200];\nint d[200];\nint app[200];\n\nint ab(int x)\n{\n\tif (x < 0) return -x;else return x;\n}\nint q[300];\n\nint main()\n{\n\tcin >> n >> dd;\n\tmemset(a,0,sizeof(a));\n\tfor (int i = 2; i <= n-1; i++) scanf(""%d"", &a[i]);\n\tfor (int i = 1; i <= n; i++) scanf(""%d %d"", &x[i], &y[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\tif (i == j) g[i][j] = 0; else g[i][j] = dd * (ab(x[i] - x[j]) + ab(y[i] -y[j])) - a[j];\n\tint t = 0;\n\tint w = 0;\t\n\tq[t] = 1;\n\tfor (int i = 1; i <= n;i++) d[i]= 500 * 100000;\n\td[1] = 0;\n\tmemset(app,0,sizeof(app));\n\tapp[1] = 1;\n\twhile (true)\n\t{\n\t\tint x = q[t];\n\t\tfor (int i = 1; i <= n; i++)\n\t\tif (d[i] > d[x] + g[x][i])\n\t\t{\n\t\t\td[i] = d[x] + g[x][i];\n\t\t\tif (app[i] == 0)\n\t\t\t{\n\t\t\t\tapp[i] = 1;\n\t\t\t\tw = (w+1)% 300;\n\t\t\t\tq[w] = i;\n\t\t\t}\n\t\t} \n\t\tapp[q[t]] = 0;\n\t\tt = (t + 1)% 300;\n\t\tif (t == w) break;\n\t}\t\n\tcout << d[n] << endl;\n\t//system(""pause"");\n}\n']","['binary search', 'dfs and similar', 'dp', 'shortest paths']",2100
https://codeforces.com//contest/1657/problem/B,B. XY Sequence,You are given four integers n B x and y You should build a sequence a 0 a 1 a 2 dots a n where a 0 0 and for each i ge 1 you can choose either a i a i 1 x or a i a i 1 y Your goal is to build such a sequence a that a i le B for all i and sum limits i 0 n a i is maximum possible ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nll solve() {\n\tll n, b, x, y;\n\tll c = 0;\n\tscanf(""%lld%lld%lld%lld"", &n, &b, &x, &y);\n\tll ans = 0;\n\twhile(n--) {\n\t\tif (c + x <= b)\n\t\t\tc += x;\n\t\telse\n\t\t\tc -= y;\n\t\tans += c;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) {\n\t\tprintf(""%lld\\n"", solve());\n\t}\n\n\treturn 0;\n}\n']",['greedy'],800
https://codeforces.com//contest/535/problem/D,D. Tavas and Malekas,Today Tavas fell asleep in Malekas place While he was sleeping Malekas did a little process on Malekas has a favorite string He determined all positions where matches More formally for each he condition is fullfilled Then Malekas wrote down one of subsequences of possibly he didn t write anything on a piece of paper Here a sequence is a subsequence of sequence if and only if we can turn into by removing some of its elements maybe no one of them or all After Tavas woke up Malekas told him everything He couldn t remember string but he knew that both and only contains lowercase English letters and also he had the subsequence he had written on that piece of paper Tavas wonders what is the number of possible values of He asked SaDDas but he wasn t smart enough to solve this So Tavas asked you to calculate this number for him Answer can be very large so Tavas wants you to print the answer modulo ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory.h>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nchar p[1000006];\nint z[1000006];\nbool f[1000006];\n\nint main() {\n  int n, m;\n  scanf(""%d %d"", &n, &m);\n  scanf(""%s"", p);\n\n  const int k = strlen(p);\n  for (int i = 1, l = 0, r = 0; i < k; i++) {\n    int cur = 0;\n    if (i <= r) {\n      cur = min(r - i + 1, z[i - l]);\n    }\n    while (i + cur < k && p[i + cur] == p[cur]) {\n      cur++;\n    }\n    if (i + cur - 1 > r) {\n      l = i;\n      r = i + cur - 1;\n    }\n    z[i] = cur;\n  }\n  z[0] = k;\n\n  if (m--) {\n    int y;\n    scanf(""%d"", &y);\n    y--;\n\n    for (int i = y; i < y + k; i++) {\n      f[i] = true;\n    }\n\n    while (m--) {\n      int t;\n      scanf(""%d"", &t);\n      t--;\n\n      if (y + k - 1 < t) {\n        for (int i = t; i < t + k; i++) {\n          f[i] = true;\n        }\n      } else {\n        const int j = t - y;\n        if (z[j] < k - j) {\n          puts(""0"");\n          return 0;\n        }\n\n        for (int i = y + k; i < t + k; i++) {\n          f[i] = true;\n        }\n      }\n\n      y = t;\n    }\n  }\n\n  int ans = 1;\n  for (int i = 0; i < n; i++) {\n    if (!f[i]) {\n      ans = (1ll * ans * 26) % mod;\n    }\n  }\n  printf(""%d\\n"", ans);\n\n  return 0;\n}']","['greedy', 'hashing', 'string suffix structures', 'strings']",1900
https://codeforces.com//contest/1534/problem/F2,F2. Falling Sand  Hard Version ,Little Dormi has recently received a puzzle from his friend and needs your help to solve it The puzzle consists of an upright board with n rows and m columns of cells some empty and some filled with blocks of sand and m non negative integers a 1 a 2 ldots a m 0 leq a i leq n In this version of the problem a i will always be the number of blocks of sand in column i When a cell filled with a block of sand is disturbed the block of sand will fall from its cell to the sand counter at the bottom of the column each column has a sand counter While a block of sand is falling other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall Specifically a block of sand disturbed at a cell i j will pass through all cells below and including the cell i j within the column disturbing all adjacent cells along the way Here the cells adjacent to a cell i j are defined as i 1 j i j 1 i 1 j and i j 1 if they are within the grid Note that the newly falling blocks can disturb other blocks In one operation you are able to disturb any piece of sand The puzzle is solved when there are a i blocks of sand counted in the i th sand counter for each column from 1 to m You are now tasked with finding the minimum amount of operations in order to solve the puzzle Note that Little Dormi will never give you a puzzle that is impossible to solve ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nvpi range;\n\nvoid upd_range(int c, pi p) {\n\tckmin(range[c].f,p.f);\n\tckmax(range[c].s,p.s);\n}\n\n/**\n * Description: Tarjan\'s, DFS once to generate \n \t* strongly connected components in topological order. $a,b$\n \t* in same component if both $a\\to b$ and $b\\to a$ exist.\n \t* Uses less memory than Kosaraju b/c doesn\'t store reverse edges.\n * Time: O(N+M)\n * Source: KACTL\n \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/graph/SCC.h\n * Verification: https://cses.fi/problemset/task/1686/\n */\n\nstruct SCC {\n\tint N, ti = 0; V<vi> adj;\n\tvi disc, comp, stk, comps;\n\tV<vi> comp_radj;\n\tvoid init(int _N) { N = _N; adj.rsz(N), disc.rsz(N), comp = vi(N,-1); }\n\tvoid ae(int x, int y) { adj[x].pb(y); }\n\tint dfs(int x) {\n\t\tint low = disc[x] = ++ti; stk.pb(x);\n\t\teach(y,adj[x]) if (comp[y] == -1) // comp[y] == -1, disc[y] != 0 -> in stack\n\t\t\tckmin(low,disc[y]?:dfs(y)); \n\t\tif (low == disc[x]) { // make new SCC, pop off stack until you find x\n\t\t\tcomps.pb(x); for (int y = -1; y != x;) \n\t\t\t\tcomp[y = stk.bk] = x, stk.pop_back();\n\t\t}\n\t\treturn low;\n\t}\n\tvoid gen() {\n\t\tF0R(i,N) if (!disc[i]) dfs(i);\n\t\treverse(all(comps));\n\t\t// vi in_deg(N);\n\t\tcomp_radj.rsz(N);\n\t\tF0R(i,N) each(j,adj[i]) if (comp[i] != comp[j]) {\n\t\t\tcomp_radj[comp[j]].pb(comp[i]);\n\t\t\t// ++in_deg[comp[j]];\n\t\t}\n\t\t// int ans = 0;\n\t\t// F0R(i,N) if (comp[i] == i && in_deg[i] == 0) ++ans;\n\t\t// return ans;\n\t}\n};\n\nint N,M;\nvs B;\nvi A;\nV<vb> done;\n\n// void make_done(int x, int y) {\n// \tif (x < 0 || x >= N || y <)\n// \tif (!done[x][y]) return;\n// \tdone[x][y] = 1;\n\n// }\n\nint main() {\n\tsetIO();\n\tre(N,M);\n\tB.rsz(N); re(B);\n\tA.rsz(M); re(A);\n\t// done = V<vb>(N,vb(M));\n\t// int ans = 0;\n\tV<vi> imp(N,vi(M));\n\tF0R(i,N) F0R(j,M) {\n\t\timp[i][j] = B[i][j] == \'#\';\n\t\tif (i) imp[i][j] |= imp[i-1][j];\n\t}\n\tauto exists = [&](int x, int y) {\n\t\treturn 0 <= x && x < N && 0 <= y && y < M && B[x][y] == \'#\';\n\t};\n\tSCC S; S.init(N*M);\n\tauto hsh = [&](int x, int y) {\n\t\treturn M*x+y;\t\n\t};\n\tauto ae = [&](pi x, pi y) {\n\t\tS.ae(hsh(x.f,x.s),hsh(y.f,y.s));\n\t};\n\tF0R(i,N) F0R(j,M) if (imp[i][j]) {\n\t\tF0R(d,4) {\n\t\t\tint ii = i+dx[d], jj = j+dy[d];\n\t\t\tif (exists(ii,jj)) ae({i,j},{ii,jj});\n\t\t}\n\t\tif (i+1 < N) ae({i,j},{i+1,j});\n\t}\n\tS.gen();\n\trange = vpi(N*M,mp(MOD,-MOD));\n\tF0R(i,N) F0R(j,M) if (exists(i,j)) {\n\t\tupd_range(hsh(i,j),{j,j});\n\t}\n\teach(c,S.comps) {\n\t\teach(u,S.comp_radj[c]) upd_range(c,range[u]);\n\t}\n\tvpi intervals;\n\tF0R(j,M) if (A[j]) {\n\t\tint i = N, cnt = 0;\n\t\twhile (cnt < A[j]) {\n\t\t\tassert(i); --i;\n\t\t\tcnt += B[i][j] == \'#\';\n\t\t}\n\t\tintervals.pb(range[S.comp[hsh(i,j)]]);\n\t\t// dbg(""GOT"",i,j);\n\t}\n\tdbg(intervals);\n\teach(t,intervals) swap(t.s,t.f);\n\tsort(all(intervals));\n\n\tint last_done = -MOD, ans = 0;\n\teach(t,intervals) {\n\t\tif (last_done >= t.s) continue;\n\t\tlast_done = t.f; ++ans;\n\t}\n\tps(ans);\n\n\t// sort(all(intervals));\n\n\t// dbg(""OH"",ans);\n\t// F0R(i,N) F0R(j,M) if (!imp[i][j]) --ans;\n\t// ps(ans);\n\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['dfs and similar', 'dp', 'graphs', 'greedy']",3000
https://codeforces.com//contest/579/problem/B,B. Finding Team Member,There is a programing contest named SnakeUp people want to compete for it In order to attend this contest people need to form teams of exactly two people You are given the strength of each possible combination of two people All the values of the strengths are Every contestant hopes that he can find a teammate so that their team s strength is as high as possible That is a contestant will form a team with highest strength possible by choosing a teammate from ones who are willing to be a teammate with him her More formally two people and may form a team if each of them is the best possible teammate among the contestants that remain unpaired for the other one Can you determine who will be each person s teammate ,"['//#include ""testlib.h""\n//#include <spoj.h>\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <assert.h>\n#include <time.h>\n#include <memory.h>\n#include <set>\n#include <numeric>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nint p[1111];\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, x;\n    cin >> n;\n    n *= 2;\n    vector<pair<int, pair<int, int> > > v;\n    for(int i = 2; i <= n; ++i)\n        for(int j = 1; j < i; ++j) {\n            cin >> x;\n            v.push_back({x, {i, j}});\n        }\n    sort(v.begin(), v.end()); reverse(v.begin(), v.end());\n    for(int i = 0; i < v.size(); ++i) {\n        if (p[v[i].second.first] == 0 && p[v[i].second.second] == 0) {\n            p[v[i].second.first] = v[i].second.second;\n            p[v[i].second.second] = v[i].second.first;\n        }\n    }\n    \n    for(int i = 1; i <= n; ++i)\n        cout << p[i] << "" \\n""[i==n];\n    \n    return 0;\n}\n']","['brute force', 'implementation', 'sortings']",1300
https://codeforces.com//contest/758/problem/A,A. Holiday Of Equality,In Berland it is the holiday of equality In honor of the holiday the king decided to equalize the welfare of all citizens in Berland by the expense of the state treasury Totally in Berland there are citizens the welfare of each of them is estimated as the integer in burles burle is the currency in Berland You are the royal treasurer which needs to count the minimum charges of the kingdom on the king s present The king can only give money he hasn t a power to take away them ,"['//#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll n,mx,x,sum;\nint main()\n{\n\tcin>>n;\n\tfor(ll i=1;i<=n;i++)\n\t\tcin>>x,mx=max(mx,x),sum+=x;\n\tcout<<mx*n-sum;\n}']","['implementation', 'math']",800
https://codeforces.com//contest/1661/problem/E,E. Narrow Components,You are given a matrix a consisting of 3 rows and n columns Each cell of the matrix is either free or taken A free cell y is reachable from a free cell x if at least one of these conditions hold x and y share a side there exists a free cell z such that z is reachable from x and y is reachable from z A connected component is a set of free cells of the matrix such that all cells in it are reachable from one another but adding any other free cell to the set violates this rule You are asked q queries about the matrix Each query is the following l r count the number of connected components of the matrix consisting of columns from l to r of the matrix a inclusive Print the answers to all queries ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  vector<string> a(3);\n  for (int i = 0; i < 3; i++){\n    cin >> a[i];\n  }\n  vector<int> c1(n + 1, 0);\n  for (int i = 0; i < n; i++){\n    c1[i + 1] = c1[i];\n    for (int j = 0; j < 3; j++){\n      if (a[j][i] == \'1\'){\n        c1[i + 1]++;\n        if (j > 0){\n          if (a[j - 1][i] == \'1\'){\n            c1[i + 1]--;\n          }\n        }\n      }\n    }\n  }\n  vector<int> c2(n, 0);\n  for (int i = 0; i < n - 1; i++){\n    c2[i + 1] = c2[i];\n    for (int j = 0; j < 3; j++){\n      if (a[j][i] == \'1\' && a[j][i + 1] == \'1\'){\n        c2[i + 1]++;\n        if (j > 0){\n          if (a[j - 1][i] == \'1\' && a[j - 1][i + 1] == \'1\'){\n            c2[i + 1]--;\n          }\n        }\n      }\n    }\n  }\n  vector<int> p;\n  for (int i = 0; i < n; i++){\n    if (a[0][i] == \'1\' && a[1][i] == \'1\' && a[2][i] == \'1\'){\n      p.push_back(i);\n    }\n  }\n  int cnt = p.size();\n  vector<int> L, R;\n  for (int i = 0; i < cnt - 1; i++){\n    if (p[i + 1] - p[i] >= 2){\n      bool ok = true;\n      for (int j = p[i] + 1; j < p[i + 1]; j++){\n        if (!(a[0][j] == \'1\' && a[1][j] == \'0\' && a[2][j] == \'1\')){\n          ok = false;\n        }\n      }\n      if (ok){\n        L.push_back(p[i]);\n        R.push_back(p[i + 1]);\n      }\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int l, r;\n    cin >> l >> r;\n    l--;\n    int ans1 = c1[r] - c1[l];\n    int ans2 = c2[r - 1] - c2[l];\n    int p1 = lower_bound(L.begin(), L.end(), l) - L.begin();\n    int p2 = lower_bound(R.begin(), R.end(), r) - R.begin();\n    int ans3 = max(p2 - p1, 0);\n    cout << ans1 - ans2 + ans3 << ""\\n"";\n  }\n}']","['brute force', 'data structures', 'dp', 'dsu', 'math', 'trees']",2500
https://codeforces.com//contest/659/problem/C,C. Tanya and Toys,In Berland recently a new collection of toys went on sale This collection consists of types of toys numbered with integers from to A toy from the new collection of the th type costs bourles Tania has managed to collect different types of toys from the new collection Today is Tanya s birthday and her mother decided to spend no more than bourles on the gift to the daughter Tanya will choose several different types of toys from the new collection as a gift Of course she does not want to get a type of toy which she already has Tanya wants to have as many distinct types of toys in her collection as possible as the result The new collection is too diverse and Tanya is too little so she asks you to help her in this ,"['#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nconst int maxn = 1e5 + 20;\n\nint n, m;\nint a[maxn];\nstd::vector<int> ans;\nstd::set<int> S;\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"",""r"",stdin);\n\tfreopen(""output.txt"",""w"",stdout);\n#endif\n\n//\tstd::ios::sync_with_stdio(false);\n\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(""%d"", &a[i]);\n\t\tS.insert(a[i]);\n\t}\n\t\n\tfor(int i = 1; m ; i++)\n\t{\n\t\tif(S.count(i)) continue;\n\t\t\n\t\tif(m >= i) ans.push_back(i), m -= i;\n\t\telse break;\n\t}\n\t\n\tprintf(""%d\\n"", ans.size());\n\tfor(int i = 0; i < ans.size(); i++) printf(""%d "", ans[i]);\n\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);\n\tfclose(stdout);\n#endif\n\treturn 0;\n}']","['greedy', 'implementation']",1200
https://codeforces.com//contest/106/problem/A,A. Card Game,There is a card game called Durak which means Fool in Russian The game is quite popular in the countries that used to form USSR The problem does not state all the game s rules explicitly you can find them later yourselves if you want To play durak you need a pack of cards Each card has a suit and and a rank in the increasing order and At the beginning of the game one suit is arbitrarily chosen as trump The players move like that one player puts one or several of his cards on the table and the other one should beat each of them with his cards A card beats another one if both cards have similar suits and the first card has a higher rank then the second one Besides a trump card can beat any non trump card whatever the cards ranks are In all other cases you can not beat the second card with the first one You are given the trump suit and two different cards Determine whether the first one beats the second one or not ,"['#include <iostream>\n#include <string>\n#include <string.h>\n\nusing namespace std;\n\nint num(char c){\n    if(c==\'T\')\n\treturn 10;\n    if(c==\'J\')\n\treturn 11;\n    if(c==\'Q\')\n\treturn 12;\n    if(c==\'K\')\n\treturn 13;\n    if(c==\'A\')\n\treturn 14;\n    return (c-\'0\');\n}\n\nint main(){\n    string a,b,c;\n    cin >> a >> b >> c;\n    if(b[1]==c[1]){\n\tif(num(b[0])>num(c[0])){\n\t    cout << ""YES\\n"";\n\t}else{\n\t    cout << ""NO\\n"";\n\t}\n    }else{\n\tif(b[1]==a[0]){\n\t    cout << ""YES\\n"";\n\t}else{\n\t    cout << ""NO\\n"";\n\t}\n    }\n}\n']",['implementation'],1000
https://codeforces.com//contest/1455/problem/B,B. Jumps,You are standing on the mathit OX axis at point 0 and you want to move to an integer point x 0 You can make several jumps Suppose you re currently at point y y may be negative and jump for the k th time You can either jump to the point y k or jump to the point y 1 What is the minimum number of jumps you need to reach the point x ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int64_t X;\n    cin >> X;\n    int64_t jumps = int64_t(floor(sqrt((long double) X)));\n\n    while (jumps * (jumps + 1) / 2 < X)\n        jumps++;\n\n    if (X == jumps * (jumps + 1) / 2 - 1)\n        jumps++;\n\n    cout << jumps << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","['constructive algorithms', 'math']",1200
https://codeforces.com//contest/1169/problem/A,A. Circle Metro,The circle line of the Roflanpolis subway has n stations There are two parallel routes in the subway The first one visits stations in order 1 to 2 to ldots to n to 1 to 2 to ldots so the next stop after station x is equal to x 1 if x n and 1 otherwise The second route visits stations in order n to n 1 to ldots to 1 to n to n 1 to ldots so the next stop after station x is equal to x 1 if x 1 and n otherwise All trains depart their stations simultaneously and it takes exactly 1 minute to arrive at the next station Two toads live in this city their names are Daniel and Vlad Daniel is currently in a train of the route at station a and will exit the subway when his train reaches station x Coincidentally Vlad is currently in a train of the route at station b and he will exit the subway when his train reaches station y Surprisingly all numbers a x b y are distinct Toad Ilya asks you to check if Daniel and Vlad will ever be at the same station at the same time during their journey In other words check if there is a moment when their trains stop at the same station Note that this includes the moments when Daniel or Vlad enter or leave the subway ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nint n;\nint a, b, c, d;\nint main()\n{\n    cin >> n >> a >> b >> c >> d;\n    while(a!=b && c!=d) {\n        if (a==c) {\n            cout << ""YES"";\n            return 0;\n        }\n        if (a!=n) {\n            a++;\n        } else {\n            a=1;\n        }\n        if (c!=1) {\n            c--;\n        } else {\n            c=n;\n        }\n    }\n    if (a==c) {\n        cout << ""YES"";\n        return 0;\n    }\n    cout << ""NO"";\n    return 0;\n}\n']","['implementation', 'math']",900
https://codeforces.com//contest/722/problem/D,D. Generating Sets,You are given a set of positive integers Set of positive integers is said to set if one can transform to by applying some number of the following two operation to integers in Take any integer and multiply it by two i e replace with Take any integer multiply it by two and add one i e replace with Note that integers in are not required to be distinct after each operation Two sets of distinct integers and are equal if they are equal as sets In other words if we write elements of the sets in the array in the increasing order these arrays would be equal Note that any set of integers or its permutation generates itself You are given a set and have to find a set that generates and the ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, n;\nint A[50000];\nint trie[50000*35][2];\nbool leaf[50000*35];\nvector<int> v;\n\nint dfs(int u, int lim, int x)\n{\n    int sum=leaf[u];\n    for(int i=0; i<2; i++) if(trie[u][i])\n        sum+=dfs(trie[u][i], lim, x*2+i);\n    if(x>=1 && x<=lim && sum>0)\n        sum--, v.push_back(x);\n    return sum;\n}\n\nint main()\n{\n    scanf(""%d"", &N);\n    n=1;\n    for(int i=0; i<N; i++)\n    {\n        scanf(""%d"", A+i);\n        int cur=1;\n        for(int j=30; j>=0; j--) if(A[i]>>j)\n        {\n            int b=(A[i]>>j)&1;\n            if(!trie[cur][b])\n                trie[cur][b]=++n;\n            cur=trie[cur][b];\n        }\n        leaf[cur]=true;\n    }\n    int lo=1, mid, hi=1000000000;\n    while(lo<hi)\n    {\n        v.clear();\n        mid=(lo+hi)/2;\n        if(dfs(1, mid, 0)==0)\n            hi=mid;\n        else\n            lo=mid+1;\n    }\n    v.clear();\n    dfs(1, lo, 0);\n    for(auto& it: v)\n        printf(""%d "", it);\n    printf(""\\n"");\n    return 0;\n}\n']","['binary search', 'data structures', 'dfs and similar', 'greedy', 'strings', 'trees']",1900
https://codeforces.com//contest/1121/problem/B,B. Mike and Children,Mike decided to teach programming to children in an elementary school He knows that it is not an easy task to interest children in that age to code That is why he decided to give each child sweets Mike has n sweets with sizes a 1 a 2 ldots a n All his sweets have sizes That is there is no such pair i j 1 leq i j leq n such that i ne j and a i a j Since Mike has taught for many years he knows that if he gives two sweets with sizes a i and a j to one child and a k and a p to another where a i a j neq a k a p then a child who has a smaller sum of sizes will be upset That is if there are two children who have different sums of sweets then one of them will be upset Apparently Mike does not want somebody to be upset Mike wants to invite children giving each of them sweets Obviously he can t give one sweet to two or more children His goal is to invite as many children as he can Since Mike is busy preparing to his first lecture in the elementary school he is asking you to find the maximum number of children he can invite giving each of them two sweets in such way that nobody will be upset ,"['#include <bits/stdc++.h>                                                                                                                                                                                                                                                                                            \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace std;\n\nint n;\nint a[1000001];\n\nint used[1000001];\n\nint main(){\n    #ifdef DIAS\n        freopen(""input.txt"", ""r"", stdin);\n        //freopen(""output.txt"", ""w"", stdout);\n    #elif NAME \n    \tfreopen(fn"".in"", ""r"", stdin);\n    \tfreopen(fn"".out"", ""w"", stdout);\n    #endif\n\tcin >> n;\n    for(int i = 1; i <= n; i++){\n    \tcin >> a[i];\n    }\n    int mx = 0;\n    for(int i = 1; i <= n; i++){\n    \tfor(int j = 1; j < i; j++){\n    \t\tused[a[i] + a[j]] ++;\n    \t\tmx = max(mx, used[a[i] + a[j]]);\n    \t}\n    }\n    cout << mx;\n}\n']","['brute force', 'implementation']",1200
https://codeforces.com//contest/78/problem/C,C. Beaver Game,Two beavers Timur and Marsel play the following game There are logs each of exactly meters in length The beavers move in turns For each move a beaver chooses a log and gnaws it into some number more than one of parts the length of each one is expressed by an integer and is no less than meters Each resulting part is also a log which can be gnawed in future by any beaver The beaver that can t make a move loses Thus the other beaver wins Timur makes the first move The players play in the optimal way Determine the winner ,"['/*\n * Author: fatboy_cw\n * Created Time:  2011/4/27 23:40:47\n * File Name: C.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\n\ntypedef long long lint;\n\nint main() {\n    lint n,m,k;\n    cin>>n>>m>>k;\n    bool flag=false;\n    for(lint i=1;i*i<=m;i++){\n        if(m%i==0){\n            if(i>=k && m/i>1){\n                flag=true;\n                break;\n            }\n            if(m/i>=k && i>1){\n                flag=true;\n                break;\n            }\n        }\n    }\n    if(!flag){\n        printf(""Marsel\\n"");\n    }\n    else{\n        if(n%2==1){\n            printf(""Timur\\n"");\n        }\n        else{\n            printf(""Marsel\\n"");\n        }\n    }\n    return 0;\n}\n\n']","['dp', 'games', 'number theory']",2000
https://codeforces.com//contest/616/problem/A,A. Comparing Two Long Integers,You are given two very long integers leading zeroes are allowed You should check what number or is greater or determine that they are equal The input size is very large so don t use the reading of symbols one by one Instead of that use the reading of a whole line or token As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in Don t use the function in instead of it use the function ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\nchar a[2000000];\nchar b[2000000];\n\n\nint main() {\n\tscanf("" %s"", a);\n\tscanf("" %s"", b);\n\tint na = strlen(a);\n\tint nb = strlen(b);\n\tchar *a1 = a;\n\tchar *b1 = b;\n\twhile (na > 1 && a1[0] == \'0\') {\n\t\t++a1;\n\t\t--na;\n\t}\n\twhile (nb > 1 && b1[0] == \'0\') {\n\t\t++b1;\n\t\t--nb;\n\t}\n\tif (na != nb) {\n\t\tif (na > nb)\n\t\t\tcout << "">"";\n\t\telse\n\t\t\tcout << ""<"";\n\t}\n\telse {\n\t\tint x = strcmp(a1, b1);\n\t\tif (x == 0)\n\t\t\tcout << ""="";\n\t\telse if (x < 0)\n\t\t\tcout << ""<"";\n\t\telse\n\t\t\tcout << "">"";\n\t}\n\treturn 0;\n}\n\n\n']","['implementation', 'strings']",900
https://codeforces.com//contest/1766/problem/E,E. Decomposition,For a sequence of integers x 1 x 2 dots x k let s define its as follows Process the sequence from the first element to the last one maintaining the list of its subsequences When you process the element x i append it to the end of the subsequence in the list such that the bitwise AND of its last element and x i is greater than 0 If there is no such subsequence in the list create a new subsequence with only one element x i and append it to the end of the list of subsequences For example let s analyze the decomposition of the sequence 1 3 2 0 1 3 2 1 processing element 1 the list of subsequences is empty There is no subsequence to append 1 to so we create a new subsequence 1 processing element 3 the list of subsequences is 1 Since the bitwise AND of 3 and 1 is 1 the element is appended to the first subsequence processing element 2 the list of subsequences is 1 3 Since the bitwise AND of 2 and 3 is 2 the element is appended to the first subsequence processing element 0 the list of subsequences is 1 3 2 There is no subsequence to append 0 to so we create a new subsequence 0 processing element 1 the list of subsequences is 1 3 2 0 There is no subsequence to append 1 to so we create a new subsequence 1 processing element 3 the list of subsequences is 1 3 2 0 1 Since the bitwise AND of 3 and 2 is 2 the element is appended to the first subsequence processing element 2 the list of subsequences is 1 3 2 3 0 1 Since the bitwise AND of 2 and 3 is 2 the element is appended to the first subsequence processing element 1 the list of subsequences is 1 3 2 3 2 0 1 The element 1 cannot be appended to any of the first two subsequences but can be appended to the third one The resulting list of subsequences is 1 3 2 3 2 0 1 1 Let f x 1 x 2 dots x k be the number of subsequences the sequence x 1 x 2 dots x k is decomposed into You are given a sequence a 1 a 2 dots a n where each element is an integer from 0 to 3 Let a i j be the sequence a i a i 1 dots a j You have to calculate sum limits i 1 n sum limits j i n f a i j ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++){\n    cin >> a[i];\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; i++){\n    if (a[i] == 0){\n      ans += (long long) (i + 1) * (n - i);\n    }\n  }\n  vector<array<int, 11>> P(4);\n  P[0] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n  P[1] = {1, 1, 7, 1, 4, 4, 10, 7, 9, 9, 10};\n  P[2] = {2, 4, 2, 2, 4, 6, 6, 7, 7, 10, 10};\n  P[3] = {3, 3, 3, 3, 5, 5, 5, 8, 8, 8, 10};\n  vector<int> L = {0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3};\n  vector<vector<long long>> dp(n + 1, vector<long long>(11, 0));\n  for (int i = 0; i < n; i++){\n    dp[i][0]++;\n    for (int j = 0; j < 11; j++){\n      dp[i + 1][P[a[i]][j]] += dp[i][j];\n    }\n  }\n  for (int i = 1; i <= n; i++){\n    for (int j = 0; j < 11; j++){\n      ans += dp[i][j] * L[j];\n    }\n  }\n  cout << ans << endl;\n}']","['binary search', 'brute force', 'data structures', 'divide and conquer', 'dp', 'two pointers']",2300
https://codeforces.com//contest/1850/problem/H,H. The Third Letter,In order to win his toughest battle Mircea came up with a great strategy for his army He has n soldiers and decided to arrange them in a certain way in camps Each soldier has to belong to exactly one camp and there is one camp at each integer point on the x axis at points cdots 2 1 0 1 2 cdots The strategy consists of m conditions Condition i tells that soldier a i should belong to a camp that is situated d i meters in front of the camp that person b i belongs to If d i 0 then a i s camp should be d i meters behind b i s camp Now Mircea wonders if there exists a partition of soldiers that respects the condition and he asks for your help Answer if there is a partition of the n soldiers that satisfies of the m conditions and otherwise Note that two different soldiers be placed in the same camp ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\n\nvoid solve () {\n\tint n, m;  cin >> n >> m;\n\tvector<array<int, 2>> adj[n];\n\tfor (int e = 0; e < m; ++e) {\n\t\tint u, v, w;  cin >> u >> v >> w;  u--, v--;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, -w});\n\t}\n\n\tmap<ll, ll> pos;\n\tfor (int u = 0; u < n; ++u) {\n\t\tif (!pos.count(u)) {\n\t\t\tqueue<int> q;  q.push(u);\n\t\t\tpos[u] = 0;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto u = q.front();  q.pop();\n\t\t\t\tfor (auto [v, w]: adj[u]) {\n\t\t\t\t\tif (pos.count(v)) {\n\t\t\t\t\t\tif (pos[v] - pos[u] != w) {\n\t\t\t\t\t\t\tcout << ""NO\\n"";\n\t\t\t\t\t\t\treturn ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos[v] = pos[u] + w;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ""YES\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","['dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation']",1700
https://codeforces.com//contest/1140/problem/E,E. Palindrome-less Arrays,Let s denote that some array b is if it contains a subarray b l b l 1 dots b r of odd length more than 1 l r and r l 1 is odd such that forall i in 0 1 dots r l b l i b r i If an array is not bad it is Now you are given an array a 1 a 2 dots a n Some elements are replaced by 1 Calculate the number of good arrays you can obtain by replacing each 1 with some integer from 1 to k Since the answer can be large print it modulo 998244353 ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=500005,P=998244353;\nint n,k,a[N],b[N],m,f[N];\n\ninline void read(int &i){\n\ti=0;char c=getchar();bool j=0;\n\tfor(;!isdigit(c);c=getchar())if(c==\'-\')j=1;\n\tfor(;isdigit(c);c=getchar())i=(i<<1)+(i<<3)+c-\'0\';i=j?-i:i;\n}\ninline ll Pow(ll a,int b){ll c=1;for(;b;a=a*a%P,b>>=1)if(b&1)c=c*a%P;return c;}\n\ninline int F(int n,int c,int t){\n\tif(!c)return k*Pow(k-1,n-1)%P;\n\tif(c==1)return Pow(k-1,n);\n\tf[0]=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)f[i]=1ll*f[i-1]*(k-1)%P;\n\tfor(int i=n;i>=1;--i){\n\t\tif((n-i)&1)ans-=f[i];\n\t\telse ans+=f[i];\n\t\tans%=P;\n\t}\n\tif(ans<0)ans+=P;\n\tif(!t){\n\t\tans=Pow(k-1,n+1)-ans;\n\t\tif(ans<0)ans+=P;\n\t\tans=ans*Pow(k-1,P-2)%P;\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tfor(int i=1;i<m;++i)if(b[i]>0&&b[i+1]>0&&b[i]==b[i+1])return 0;\n\tint as=1;\n\tfor(int i=1;i<=m;){\n\t\tint j=i;\n\t\tif(b[i]!=-1){i++;continue;}\n\t\twhile(j+1<=m&&b[j+1]==-1)j++;\n\t\tint c=0;\n\t\tif(i>1)c++;\n\t\tif(j<m)c++;\n\t\tas=1ll*as*F(j-i+1,c,b[i-1]==b[j+1])%P;\n\t\ti=j+1;\n\t}\n\treturn as;\n}\n\nint main(){\n\tread(n);read(k);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tfor(int i=1;i<=n;i+=2)b[++m]=a[i];\n\tint ans=calc();\n\tm=0;\n\tfor(int i=2;i<=n;i+=2)b[++m]=a[i];\n\tans=1ll*ans*calc()%P;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","['combinatorics', 'divide and conquer', 'dp']",2200
https://codeforces.com//contest/1909/problem/F1,F1. Small Permutation Problem  Easy Version ,You are given an integer n and an array a 1 a 2 dots a n of integers in the range 0 n A permutation p 1 p 2 dots p n of 1 2 dots n is good if for each i the following condition is true the number of values leq i in p 1 p 2 dots p i is exactly a i Count the good permutations of 1 2 dots n modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//対角線を超えず (x,y) に至る方法の数\nmint catalan(int x,int y){\n\tassert(y<=x);\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n//y=x+c を超えず (x,y) に至る方法の数\nmint catalan(int x,int y,int c){\n\tassert(y<=x+c);\n\treturn binom(x,y)-binom(x+c+1,y-c-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tif(!is_sorted(all(a))||a[n-1]<n)return print(0);\n\tint pre=0;\n\tmint ans=1;\n\trep(i,n){\n\t\tint dif=a[i]-pre;\n\t\tmint w=1;\n\t\tif(dif==0){\n\t\t\t//do nothing\n\t\t}else if(dif==1){\n\t\t\tw=1+(i-pre)*2;\n\t\t}else if(dif==2){\n\t\t\tw=(i-pre)*(i-pre);\n\t\t}else{\n\t\t\treturn print(0);\n\t\t}\n\t\tans*=w;\n\t\tpre=a[i];\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['brute force', 'combinatorics', 'dp', 'math']",2200
https://codeforces.com//contest/1209/problem/G2,G2. Into Blocks  hard version ,A sequence of integers is called if its elements are arranged in blocks like in 3 3 3 4 1 1 Formally if two elements are equal everything in between must also be equal Let s define of a sequence as a minimum possible number of elements to change to get a nice sequence However if you change at least one element of value x to value y you must also change all other elements of value x into y as well For example for 3 3 1 3 2 1 2 it isn t allowed to change first 1 to 3 and second 1 to 2 You need to leave 1 s untouched or change them to the same value You are given a sequence of integers a 1 a 2 ldots a n and q updates Each update is of form i x change a i to x Updates are not independent the change stays for the future Print the difficulty of the initial sequence and of the sequence after every update ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 3e5 + 7;\n\nint a[N];\nset <int> q[N];\nint cnt[N];\n\nstruct segm {\n  int l, r, x;\n};\n\nset <segm> e;\n\nbool operator < (const segm &a, const segm &b) {\n  return a.l < b.l;\n}\n\nconst int B = 300;\nconst int BL = B;\n\nint suf[N];\nint max_x[N];\nint jump_r[N];\nint cnt_here[N];\nint sum_here[N];\n\nvector <segm> orz[N];\n\nint w[N];\nint tr[N];\nbool vis[N];\n\nvoid rebuild_block(int l) {\n  l -= l % B;\n  static vector <segm> p;\n  p.clear();\n  for (int i = l; i < l + B && i < N; i++) {\n    if (vis[i]) {\n      p.push_back({i, tr[i], w[i]});\n    }\n  }\n  segm ret;\n  ret.l = 0;\n  ret.r = -1;\n  ret.x = 0;\n  static vector <segm> ans;\n  ans.clear();\n  for (auto c : p) {\n    if (c.l > ret.r) {\n      if (ret.r != -1) {\n        ans.push_back(ret);\n      }\n      ret = c;\n    } else {\n      ret.r = max(ret.r, c.r);\n      ret.x = max(ret.x, c.x);\n    }\n  }\n  if (ret.r != -1) {\n    ans.push_back(ret);\n  }\n  orz[l] = ans;\n  int j = -1;\n  int mx = 0;\n  int r = -1;\n  int sum = 0;\n  for (int i = l; i < l + B && i < N; i++) {\n    while (j + 1 < (int) ans.size() && ans[j + 1].l <= i) {\n      j++;\n      mx = max(mx, ans[j].x);\n      r = max(r, ans[j].r);\n      sum += ans[j].x;\n    }\n    sum_here[i] = sum;\n    cnt_here[i] = j + 1;\n    max_x[i] = mx;\n    jump_r[i] = r;\n  }\n}\n\nvoid del(int x, int i) {\n  int l = *q[x].begin(), r = *prev(q[x].end());\n  vis[l] = false;\n  e.erase({l, r, cnt[x]});\n  cnt[x]--;\n  q[x].erase(i);\n  rebuild_block(l);\n  if (cnt[x]) {\n    int l = *q[x].begin(), r = *prev(q[x].end());\n    vis[l] = true;\n    w[l] = cnt[x];\n    tr[l] = r;\n    e.insert({l, r, cnt[x]});\n    rebuild_block(l);\n  }\n}\n\nvoid add(int x, int i) {\n  if (cnt[x]) {\n    int l = *q[x].begin(), r = *prev(q[x].end());\n    vis[l] = false;\n    e.erase({l, r, cnt[x]});\n    rebuild_block(l);\n  }\n  cnt[x]++;\n  q[x].insert(i);\n  int l = *q[x].begin(), r = *prev(q[x].end());\n  vis[l] = true;\n  w[l] = cnt[x];\n  tr[l] = r;\n  e.insert({l, r, cnt[x]});\n  rebuild_block(l);\n}\n\nint ans() {\n  int vr = -1;\n  int tot = 0;\n  int gao = 0;\n  for (int i = 0; i < 200000; i += B) {\n    if (orz[i].empty()) continue;\n    if (vr <= i) {\n      tot += gao;\n      tot += sum_here[i + BL - 1] - orz[i].back().x;\n      gao = orz[i].back().x;\n      vr = orz[i].back().r;\n    } else {\n      int value = min(vr, i + BL - 1);\n      gao = max(gao, max_x[value]);\n      vr = max(vr, jump_r[value]);\n      if (cnt_here[value] != cnt_here[i + BL - 1]) {\n        tot += gao;\n        tot += sum_here[i + BL - 1] - sum_here[value] - orz[i].back().x;\n        gao = orz[i].back().x;\n        vr = orz[i].back().r;\n      }\n    }\n  }\n  return tot + gao;\n}\n\nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n = 200000, tq = 200000;\n  cin >> n >> tq;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n    q[a[i]].insert(i);\n    cnt[a[i]]++;\n    //add(a[i], i);\n  }\n  for (int i = 0; i < N; i++)  {\n    if (!q[i].empty()) {\n      vis[*q[i].begin()] = true;\n      w[*q[i].begin()] = cnt[i];\n      tr[*q[i].begin()] = *q[i].rbegin();\n      e.insert({*q[i].begin(), *q[i].rbegin(), cnt[i]});\n    }\n  }\n  for (int i = 0; i < N; i += BL) {\n    rebuild_block(i);\n  }\n  cout << n - ans() << \'\\n\';\n  for (int j = 0; j < tq; j++) {\n    int i, x;\n    cin >> i >> x;\n    i--, x--;\n    del(a[i], i);\n    a[i] = x;\n    add(a[i], i);\n    cout << n - ans() << \'\\n\';\n  }\n}\n']",['data structures'],3200
https://codeforces.com//contest/477/problem/B,B. Dreamoon and Sets,Dreamoon likes to play with sets integers and is defined as the largest positive integer that divides both and Let be a set of exactly four distinct integers greater than Define to be of rank if and only if for all pairs of distinct elements from Given and Dreamoon wants to make up sets of rank using integers from to such that no integer is used in two different sets of course you can leave some integers without use Calculate the minimum that makes it possible and print one possible solution ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\nint main() {\n\tscanf(""%d%d"",&n,&k);\n\tprintf(""%d\\n"",(6*n-1)*k);\n\trep(i,0,n) {\n\t\tprintf(""%d %d %d %d\\n"",(6*i+1)*k,(6*i+2)*k,(6*i+3)*k,(6*i+5)*k);\n\t}\n}\n']",['math'],1900
https://codeforces.com//contest/314/problem/E,E. Sereja and Squares,Sereja painted points on the plane point number has coordinates Then Sereja marked each point with a small or large English letter Sereja don t like letter so he didn t use it to mark points Sereja thinks that the points are marked beautifully if the following conditions holds all points can be divided into pairs so that each point will belong to exactly one pair in each pair the point with the lesser abscissa will be marked with a small English letter and the point with the larger abscissa will be marked with the same large English letter if we built a square on each pair the pair s points will be the square s opposite points and the segment between them will be the square s diagonal then among the resulting squares there won t be any intersecting or touching ones Little Petya erased some small and all large letters marking the points Now Sereja wonders how many ways are there to return the removed letters so that the points were marked beautifully ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MAXN = 1<<18;\nconst int MAGIC = 100000;\n\nint N;\n\nchar S[MAXN];\nunsigned int T[MAXN];\nint pleft[MAXN];\n\nunsigned brute() {\n    pleft[N] = 0;\n    FORD(i,N,0) {\n        pleft[i] = pleft[i+1];\n        if (S[i] == \'?\') ++pleft[i]; else --pleft[i];\n    }\n\n    T[0] = 1;\n    int L = 0, R = 0;\n    REP(i,N) {\n        FORD(j,R+2,L+1) T[j] = T[j-1];//[L+1,R+1];\n        T[L] = 0;        \n        ++L, ++R;\n        \n        if (S[i] == \'?\') {\n            L = max(0, L-2);\n            FOR(j,L,R+1) T[j] += T[j+2];        \n        }\n\n        while (R > pleft[i+1] + 1) {\n            T[R--] = 0;\n        }\n        \n\n    }\n    \n    unsigned int res = T[0];\n    REP(i,pleft[0] / 2) res *= 25;\n\n    return res;\n}\n\nint main() {\n    scanf(""%d%s"",&N,S);\n    if (N%2) {\n        printf(""0\\n"");\n        return 0;\n    }\n\n    unsigned int r = brute();\n    printf(""%u\\n"",r);\n}    ']",['dp'],2900
https://codeforces.com//contest/975/problem/D,D. Ghosts,Ghosts live in harmony and peace they travel the space without any purpose other than scare whoever stands in their way There are n ghosts in the universe they move in the OXY plane each one of them has its own velocity that does not change in time overrightarrow V V x overrightarrow i V y overrightarrow j where V x is its speed on the x axis and V y is on the y axis A ghost i has experience value EX i which represent how many ghosts tried to scare him in his past Two ghosts scare each other if they were in the same cartesian point at a moment of time As the ghosts move with constant speed after some moment of time there will be no further scaring and the experience of ghost kind GX sum i 1 n EX i will never increase Tameem is a red giant he took a picture of the cartesian plane at a certain moment of time T and magically all the ghosts were aligned on a line of the form y a cdot x b You have to compute what will be the experience index of the ghost kind GX in the indefinite future this is your task for today Note that when Tameem took the picture GX may already be greater than 0 because many ghosts may have scared one another at any moment between infty T ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define fr(x, y, z) for(int x=y;x<z;x++)\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppl;\nconst int ms=1e6;\n\n\n/*\n    3 types:\n        1 - on line ab,different speed\n        2 - \n*/\nmap<ll, map<pll,ll> > comp;\nmap<ll, ll > cnt;\nset<pll> ab;\nint main(){\n    ll n,a,b;\n    ll ans=0;\n    scanf(""%lld%lld%lld"",&n,&a,&b);\n    fr(i,0,n){\n        ll vx,vy,tsh;\n        scanf(""%lld%lld%lld"",&tsh,&vx,&vy);\n        cnt[a*vx-vy]++;\n        comp[a*vx-vy][pll(vx,vy)]++;\n        ans+=cnt[a*vx-vy]-comp[a*vx-vy][pll(vx,vy)];\n    }\n    cout<<ans*2<<endl;\n}']","['geometry', 'math']",2000
https://codeforces.com//contest/1661/problem/F,F. Teleporters,There are n 1 teleporters on a straight line located in points 0 a 1 a 2 a 3 a n It s possible to teleport from point x to point y if there are teleporters in of those points and it costs x y 2 energy You want to install some additional teleporters so that it is possible to get from the point 0 to the point a n possibly through some other teleporters spending than m energy in total Each teleporter you install must be located in an What is the minimum number of teleporters you have to install ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1000000000000000000;\nlong long cost(int d, int cnt){\n  int q = d / cnt;\n  int r = d % cnt;\n  return (long long) q * q * (cnt - r) + (long long) (q + 1) * (q + 1) * r;\n}\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n + 1);\n  a[0] = 0;\n  for (int i = 1; i <= n; i++){\n    cin >> a[i];\n  }\n  long long m;\n  cin >> m;\n  long long tv = 1, fv = INF;\n  while (fv - tv > 1){\n    long long mid = (tv + fv) / 2;\n    long long sum = 0;\n    for (int i = 0; i < n; i++){\n      long long d = a[i + 1] - a[i];\n      int tv2 = 1, fv2 = d + 1;\n      while (fv2 - tv2 > 1){\n        int mid2 = (tv2 + fv2) / 2;\n        long long x1 = cost(d, mid2 - 1);\n        long long x2 = cost(d, mid2);\n        if (x1 - x2 >= mid){\n          tv2 = mid2;\n        } else {\n          fv2 = mid2;\n        }\n      }\n      sum += cost(d, tv2);\n    }\n    if (sum <= m){\n      tv = mid;\n    } else {\n      fv = mid;\n    }\n  }\n  long long ans = 0;\n  long long sum = 0;\n  for (int i = 0; i < n; i++){\n    long long d = a[i + 1] - a[i];\n    int tv2 = 1, fv2 = d + 1;\n    while (fv2 - tv2 > 1){\n      int mid2 = (tv2 + fv2) / 2;\n      long long x1 = cost(d, mid2 - 1);\n      long long x2 = cost(d, mid2);\n      if (x1 - x2 > tv){\n        tv2 = mid2;\n      } else {\n        fv2 = mid2;\n      }\n    }\n    ans += tv2 - 1;\n    sum += cost(d, tv2);\n  }\n  ans += (sum - m + tv - 1) / tv;\n  cout << ans << endl;\n}']","['binary search', 'greedy']",2600
https://codeforces.com//contest/201/problem/B,B. Guess That Car ,A widely known among some people Belarusian sport programmer Yura possesses lots of information about cars That is why he has been invited to participate in a game show called Guess That Car The game show takes place on a giant parking lot which is meters long from north to south and meters wide from west to east The lot has dividing lines drawn from west to east and dividing lines drawn from north to south which divide the parking lot into by meter squares There is a car parked strictly inside each square The dividing lines are numbered from to from north to south and from to from west to east Each square has coordinates so that the square in the north west corner has coordinates and the square in the south east corner has coordinates See the picture in the notes for clarifications Before the game show the organizers offer Yura to occupy any of the intersection points of the dividing lines After that he can start guessing the cars After Yura chooses a point he will be prohibited to move along the parking lot before the end of the game show As Yura is a car expert he will always guess all cars he is offered it s just a matter of time Yura knows that to guess each car he needs to spend time equal to the square of the euclidean distance between his point and the center of the square with this car multiplied by some coefficient characterizing the machine s rarity the rarer the car is the harder it is to guess it More formally guessing a car with rarity placed in a square whose center is at distance from Yura takes seconds The time Yura spends on turning his head can be neglected It just so happened that Yura knows the rarity of each car on the parking lot in advance Help him choose his point so that the total time of guessing all cars is the smallest possible ,"[""#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint X,Y;\nint a[1010][1010];\nll sumx[1010],sumy[1010];\nll costx[1010],costy[1010];\n\nint main(void){\n    int i,j;\n    \n    cin >> X >> Y;\n    REP(i,X) REP(j,Y) cin >> a[i][j];\n    REP(i,X) REP(j,Y){\n        sumx[i] += a[i][j];\n        sumy[j] += a[i][j];\n    }\n    \n    REP(i,X+1) REP(j,X) costx[i] += sumx[j] * (2*i-2*j-1) * (2*i-2*j-1);\n    REP(i,Y+1) REP(j,Y) costy[i] += sumy[j] * (2*i-2*j-1) * (2*i-2*j-1);\n    \n    int ansx = 0, ansy = 0;\n    REP(i,X+1) if(costx[i] < costx[ansx]) ansx = i;\n    REP(i,Y+1) if(costy[i] < costy[ansy]) ansy = i;\n    \n    cout << 4 * (costx[ansx] + costy[ansy]) << endl << ansx << ' ' << ansy << endl;;\n    \n    return 0;\n}\n""]","['math', 'ternary search']",1800
https://codeforces.com//contest/519/problem/B,B. A and B and Compilation Errors,B loves to debug his code But before he runs the solution and starts debugging he has to first compile the code Initially the compiler displayed compilation errors each of them is represented as a positive integer After some effort B managed to fix some mistake and then another one mistake However despite the fact that B is sure that he corrected the two errors he can not understand exactly what compilation errors disappeared the compiler of the language which B uses shows errors in the new order every time B is sure that unlike many other programming languages compilation errors for his programming language do not depend on each other that is if you correct one error the set of other error does not change Can you help B find out exactly what two errors he corrected ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint n, a[3][N];\nset<int> s;\n\nint main() {\n    int i, j;\n    //freopen(""ttt"", ""r"", stdin);\n\n    cin >> n;\n\n    for(i = 0; i < 3; ++i) {\n        for(j = 1; j <= n - i; ++j)\n            scanf(""%d"", &a[i][j]);\n        sort(a[i] + 1, a[i] + n - i + 1);\n    }\n\n    for(i = 1; i <= n; ++i)\n    if(a[0][i] != a[1][i]) {\n        cout << a[0][i] << ""\\n"";\n        break;\n    }\n\n    for(i = 1; i < n; ++i)\n    if(a[1][i] != a[2][i]) {\n        cout << a[1][i] << ""\\n"";\n        break;\n    }\n\n    return 0;\n}\n']","['data structures', 'implementation', 'sortings']",1100
https://codeforces.com//contest/327/problem/A,A. Flipping Game,Iahub got bored so he invented a game to be played on paper He writes integers Each of those integers can be either 0 or 1 He s allowed to do exactly one move he chooses two indices and and flips all values for which their positions are in range that is Flip the value of means to apply operation The goal of the game is that after one move to obtain the maximum number of ones Write a program to solve the little game of Iahub ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\nint n, ans, a[105];\nint main()\n{\n    scanf(""%d"", &n);\n    rep(i, 1, n) scanf(""%d"", a + i);\n    rep(i, 1, n) rep(j, i, n)\n    {\n        int cnt = 0;\n        rep(k, i, j) a[k] ^= 1;\n        rep(k, 1, n) cnt += a[k];\n        if (cnt > ans) ans = cnt;\n        rep(k, i, j) a[k] ^= 1;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","['brute force', 'dp', 'implementation']",1200
https://codeforces.com//contest/982/problem/D,D. Shark,For long time scientists study the behavior of sharks Sharks as many other species alternate short movements in a certain location and long movements between locations Max is a young biologist For n days he watched a specific shark and now he knows the distance the shark traveled in each of the days All the distances are distinct Max wants to know now how many locations the shark visited He assumed there is such an integer k that if the shark in some day traveled the distance strictly less than k then it didn t change the location otherwise if in one day the shark traveled the distance greater than or equal to k then it was changing a location in that day Note that it is possible that the shark changed a location for several consecutive days in each of them the shark traveled the distance at least k The shark never returned to the same location after it has moved from it Thus in the sequence of n days we can find consecutive nonempty segments when the shark traveled the distance less than k in each of the days each such segment corresponds to one location Max wants to choose such k that the lengths of all such segments are equal Find such integer k that the number of locations is as large as possible If there are several such k print the smallest one ,"['#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#define rep(i,n) for(int i=1;i<=n;++i)\n#define pb push_back\nusing namespace std;\n\nusing namespace std;\n\nstruct node\n{\n\tint v,p;\n\tfriend bool operator <(node x,node y)\n\t{\n\t\treturn x.v<y.v;\n\t}\n}a[210000];\n\nstruct node2\n{\n\tint l,r;\n\tint cnt,sum;\n}st[210000*36];\n\nint v[210000],father[210000],num[210000],seq[210000];\nint n;\nint ll,ans,root,tot,sum;\n\nint getfather(int x)\n{\n\tif (x==father[x]) return x;\n\treturn father[x]=getfather(father[x]);\n}\n\nvoid modify(int &x,int l,int r,int p,int k)\n{\n\tif (x==0) \n\t{\n\t\tx=++tot; \n\t\tst[x].l=st[x].r=st[x].cnt=st[x].sum=0; \n\t}\n\tif (l==r) \n\t{\n\t    st[x].sum=st[x].sum+k; \n\t\tst[x].cnt=(st[x].sum>0);\n\t    return;\n\t}\n\tint mid=(l+r)/2;\n\tif (p<=mid)modify(st[x].l,l,mid,p,k);\n\telse modify(st[x].r,mid+1,r,p,k);\n\n\tst[x].cnt=st[st[x].l].cnt+st[st[x].r].cnt;\n}\nvoid init()\n{\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)father[i]=i,num[i]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d"",&v[i]);\n\t\ta[i].v=v[i]; \n\t\ta[i].p=i;\n\t}\n\tsort(a+1,a+n+1);\n}\nint main()\n{\n\tinit();\n\n\trep(i,n)\n\t{\n\t    int p=a[i].p; \n\t    seq[p]=1;\n\t    if (p>1) \n\t    {\n\t    \tif (seq[p-1]==1) \n\t    \t{\n\t    \t\tint tx=getfather(p-1); \n\t    \t\tint ty=getfather(p);\n    \t\t    modify(root,1,n,num[tx],-1);\n    \t\t    father[tx]=ty;\n    \t\t    num[ty]=num[ty]+num[tx];\n    \t\t    sum++;\n\t    \t}\n\t    }\n\t    if (p<n) \n\t    {\n\t    \tif (seq[p+1]==1) \n\t    \t{\n\t    \t\tint tx=getfather(p+1); \n\t    \t\tint ty=getfather(p);\n    \t\t    modify(root,1,n,num[tx],-1);\n    \t\t    father[tx]=ty;\n    \t\t    num[ty]=num[ty]+num[tx];\n    \t\t    sum++;\n\t    \t}\n\t    }\n\t    int tx=getfather(p);\n\t    modify(root,1,n,num[tx],1);\n\t    if (st[root].cnt==1 && i-sum>ll)\n\t\t{\n\t\t\t\tll=i-sum;\n\t\t\t\tans=a[i].v+1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']","['brute force', 'data structures', 'dsu', 'trees']",1900
https://codeforces.com//contest/407/problem/B,B. Long Path,One day little Vasya found himself in a maze consisting of rooms numbered from to Initially Vasya is at the first room and to get out of the maze he needs to get to the th one The maze is organized as follows Each room of the maze has two one way portals Let s consider room number someone can use the first portal to move from it to room number also someone can use the second portal to move from it to room number where In order not to get lost Vasya decided to act as follows Each time Vasya enters some room he paints a cross on its ceiling Initially Vasya paints a cross at the ceiling of room Let s assume that Vasya is in room and has already painted a cross on its ceiling Then if the ceiling now contains an odd number of crosses Vasya uses the second portal it leads to room otherwise Vasya uses the first portal Help Vasya determine the number of times he needs to use portals to get to room in the end ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\nconst int N = 1234567;\n\nint p[N], f[N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 1; i <= n; i++) scanf(""%d"", p + i);\n  f[1] = 2;\n  for (int i = 2; i <= n; i++) {\n    f[i] = 2;\n    for (int k = p[i]; k < i; k++) {\n      f[i] += f[k];\n      if (f[i] >= md) f[i] -= md;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    ans += f[i];\n    if (ans >= md) ans -= md;\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","['dp', 'implementation']",1600
https://codeforces.com//contest/813/problem/D,D. Two Melodies,Alice is a beginner composer and now she is ready to create another masterpiece And not even the single one but two at the same time Alice has a sheet with notes written on it She wants to take two such non empty non intersecting subsequences that both of them form a and sum of their lengths is maximal Subsequence forms a melody when each two adjacent notes either differs by or are congruent modulo You should write a program which will calculate maximum sum of lengths of such two non empty non intersecting subsequences that both of them form a melody ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 5140\nvoid build(){\n\n}\nint n , a[ N ];\nqueue<int> q[ 101010 ] , q2[ 7 ];\nvoid init(){\n  n = getint();\n  for( int i = 1 ; i <= n ; i ++ ){\n    a[ i ] = getint();\n    q[ a[ i ] ].push( i );\n    q2[ a[ i ] % 7 ].push( i );\n  }\n}\nint dp[ N ][ N ] , ans;\nint next( int vl , int rr ){\n  while( q[ vl ].size() and q[ vl ].front() <= rr )\n    q[ vl ].pop();\n  if( q[ vl ].empty() ) return -1;\n  return q[ vl ].front();\n}\nint next2( int vl , int rr ){\n  while( q2[ vl ].size() and q2[ vl ].front() <= rr )\n    q2[ vl ].pop();\n  if( q2[ vl ].empty() ) return -1;\n  return q2[ vl ].front();\n}\nvoid solve(){\n  ans = 2;\n  for( int i = 1 ; i <= n ; i ++ ){\n    for( int j = i + 1 ; j <= n ; j ++ )\n      dp[ i ][ j ] = 2;\n    dp[ 0 ][ i ] = 1;\n  }\n  for( int r = 1 ; r <= n ; r ++ )\n    for( int l = 0 ; l < r ; l ++ ){\n      if( dp[ l ][ r ] == 0 ) continue;\n      ans = max( ans , dp[ l ][ r ] );\n      {\n        if( l == 0 ){\n          for( int nxt = r + 1 ; nxt <= n ; nxt ++ )\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n        }else{\n          for( int dlt = -1 ; dlt <= 1 ; dlt += 2 ){\n            int nxt = next( a[ l ] + dlt , r );\n            if( nxt == -1 ) continue;\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n          }\n          int nxt = next2( a[ l ] % 7 , r );\n          if( nxt != -1 )\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n      }\n      {\n        for( int dlt = -1 ; dlt <= 1 ; dlt += 2 ){\n          int nxt = next( a[ r ] + dlt , r );\n          if( nxt == -1 ) continue;\n          dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n        {\n          int nxt = next2( a[ r ] % 7 , r );\n          if( nxt != -1 )\n            dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n        if( l == 0 ){\n          for( int nxt = r + 1 ; nxt <= n ; nxt ++ ){\n            if( a[ nxt ] % 7 == a[ r ] % 7 or\n                abs( a[ nxt ] - a[ r ] ) == 1 )\n            dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n          }\n        }\n      }\n    }\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","['dp', 'flows']",2600
https://codeforces.com//contest/185/problem/A,A. Plant,Dwarfs have planted a very interesting plant which is a triangle directed upwards This plant has an amusing feature After one year a triangle plant directed upwards divides into four triangle plants three of them will point upwards and one will point downwards After another year each triangle plant divides into four triangle plants three of them will be directed in the same direction as the parent plant and one of them will be directed in the opposite direction Then each year the process repeats The figure below illustrates this process Help the dwarfs find out how many triangle plants that point upwards will be in years ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007ll\n\nll power(ll n){\n    if(n == 0) return 1;\n    ll ans = power(n/2);\n    return ans * ans % MOD * ((n%2 == 1) ? 2 : 1) % MOD;\n}\n\nint main(void){\n    ll n;\n    \n    cin >> n;\n    ll t = power(n);\n    ll ans = t * (t + 1) % MOD * ((MOD + 1) / 2) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']",['math'],1300
https://codeforces.com//contest/779/problem/B,B. Weird Rounding,Polycarp is crazy about round numbers He especially likes the numbers divisible by In the given number of Polycarp wants to remove the least number of digits to get a number that is divisible by For example if in the number it is enough to delete a single digit In this case the result is that is divisible by Write a program that prints the minimum number of digits to be deleted from the given integer number so that the result is divisible by The result should not start with the unnecessary leading zero i e zero can start only the number which is required to be written as exactly one digit It is guaranteed that the answer exists ,"['#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <stack>\n#define sz size()\n#define pb push_back\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll exp(ll t,ll x){if(x==0) return 1;if(x==1) return t;if(x%2==1) return (t*exp((t*t)%mod,x/2))%mod;if(x%2==0) return exp((t*t)%mod,x/2);} \nll gcd(ll x,ll y){return x%y==0?y:gcd(y,x%y);}\nll lcm(ll x,ll y){return x*(y/gcd(x,y));}\nll bsum(ll u,ll b){return u<b?u:bsum(u/b,b)+u%b;}\nll prival(ll u,ll p){int cn=0;while(u%p==0){cn++;u=u/p;}return cn;}\nbool isprime(ll x){for(ll i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\nvoid YAY(void){cout<<""YES""<<endl;}\nvoid NAY(void){cout<<""NO""<<endl;}\nstring s;\nint cz, n, k;\nint main(void)\n{\n\tint i, j;\n\tcin>>s>>k;\n\tn=s.size();\n\tfor(i=0 ; i<n ; i++)\n\t{\n\t\tif(s[i]==\'0\')\n\t\t{\n\t\t\tcz++;\n\t\t}\n\t}\n\tif(cz>=k)\n\t{\n\t\tint cc=0;\n\t\tint ans=0;\n\t\tfor(i=n-1 ; i>=0 ; i--)\n\t\t{\n\t\t\tif(s[i]==\'0\')\n\t\t\t{\n\t\t\t\tcc++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(cc>=k)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tcout<<n-1;\n\t}\n\t\n}\n']","['brute force', 'greedy']",1100
https://codeforces.com//contest/1579/problem/G,G. Minimal Coverage,You are given n lengths of segments that need to be placed on an infinite axis with coordinates The first segment is placed on the axis so that one of its endpoints lies at the point with coordinate 0 Let s call this endpoint the of the first segment and let s call its as that endpoint that is not the start The start of each following segment must coincide with the end of the previous one Thus if the length of the next segment is d and the end of the previous one has the coordinate x the segment can be placed either on the coordinates x d x and then the coordinate of its end is x d or on the coordinates x x d in which case its end coordinate is x d The total of the axis by these segments is defined as their overall union which is basically the set of points covered by at least one of the segments It s easy to show that the coverage will also be a segment on the axis Determine the minimal possible length of the coverage that can be obtained by placing all the segments on the axis without changing their order ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"")\n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n;\nint a[10005];\nint d[10005][2005];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) cin >> a[i];\n        for(int i = 0;i <= 2000;i++) d[0][i] = i;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 0;j <= 2000;j++) {\n                d[i][j] = INF;\n                if(j-a[i] >= 0) d[i][j] = min(d[i][j],max(d[i-1][j-a[i]],j));\n                if(j+a[i] <= 2000) d[i][j] = min(d[i][j],max(d[i-1][j+a[i]],j));\n            }\n        }\n        int ans = INF;\n        for(int i = 0;i <= 2000;i++) ans = min(ans,d[n][i]);\n        cout << ans << \'\\n\';\n    }\n}\n']",['dp'],2200
https://codeforces.com//contest/1648/problem/F,F. Two Avenues,In order to make the capital of Berland a more attractive place for tourists the great king came up with the following plan choose two streets of the city and call them avenues Certainly these avenues will be proclaimed extremely important historical places which should attract tourists from all over the world The capital of Berland can be represented as a graph the vertices of which are crossroads and the edges are streets connecting two crossroads In total there are n vertices and m edges in the graph you can move in both directions along any street you can get from any crossroad to any other by moving only along the streets each street connects two different crossroads and no two streets connect the same pair of crossroads In order to reduce the flow of ordinary citizens moving along the great avenues it was decided to introduce a toll on each avenue in both directions Now you need to pay 1 tugrik for one passage along the avenue You don t have to pay for the rest of the streets Analysts have collected a sample of k citizens i th of them needs to go to work from the crossroad a i to the crossroad b i After two avenues are chosen each citizen will go to work along the path with minimal cost In order to earn as much money as possible it was decided to choose two streets as two avenues so that the total number of tugriks paid by these k citizens is maximized Help the king according to the given scheme of the city and a sample of citizens find out which two streets should be made avenues and how many tugriks the citizens will pay according to this choice ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class t,class u>\nvoid print_offset(const pair<t,u>&p,ll off,int suc=1){\n\tprint(p.a+off,2);\n\tprint(p.b+off,suc);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//内部でグラフをいじるから in,out を使うときは注意\n//hei[v] -> heavy edge で潜っていった時，自分含めて何個あるか\n//pe[v]: v->par[v] の辺の情報\n//-有向木のときは上から下の辺を入れてる\n//-無向木のときは下から上の辺を入れてる\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tpe[e]=e;\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//CF692F\n\tint getpar(int v,int len){\n\t\tassert(dep[v]>=len);\n\t\tint tar=dep[v]-len;\n\t\twhile(1){\n\t\t\tint h=head[v];\n\t\t\tif(dep[h]<=tar){\n\t\t\t\treturn ni[in[h]+(tar-dep[h])];\n\t\t\t}\n\t\t\tv=par[h];\n\t\t}\n\t\tassert(false);\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\tvi index;\n\t//vs を含む virtual tree を返す\n\t//返すのは virtual tree に使われた頂点と，辺の集合\n\t//辺の端点は，virtual tree における番号\n\t//元の木における番号を virtual tree の頂点番号に写すのが，index という変数\n\t//辺は ch->par の順\n\t//virtual tree は行き掛け順で番号がついている\n\t//特に，頂点 0 が根になるようにできている\n\tpair<vi,vc<pi>> tree_compress(vi vs){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tvc<pi> es;\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\treturn mp(vs,es);\n\t}\n\t//assume a is desdendant of b\n\t//ex=true <=> exclude b\n\ttemplate<class F>\n\tvoid subpath_work(int a,int b,bool ex,F f){\n\t\twhile(1){\n\t\t\tif(head[a]==head[b]){\n\t\t\t\tf(in[b]+ex,in[a]+1);\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tint h=head[a];\n\t\t\t\tf(in[h],in[a]+1);\n\t\t\t\ta=par[h];\n\t\t\t}\n\t\t}\n\t}\n\t//KUPC2021E\n\t//パスに対する操作順に注意\n\t//euler-tour 順にしたときの区間に作用していることに注意\n\t//ex=true exclude lca(a,b) (=apply path edges)\n\ttemplate<class F>\n\tvoid path_work(int a,int b,bool ex,F f){\n\t\tint c=lca(a,b);\n\t\tsubpath_work(a,c,ex,f);\n\t\tsubpath_work(b,c,true,f);\n\t}\n};\n\n//atcoder-library をまあまあコピーして使っている\n\n//N() が単位元\n\n//merge で片方が inactive のときはもう片方をそのまま返す，\n//といったときに，lazy の情報までコピーして渡さないようにする\n\n//get の最後の引数は単位元と口では言いつつ・・・？\n//たとえば min で最後の引数を 0 にしても 1 とかが返ってくることはある（一敗）\n\n//VERIFY:\n//https://atcoder.jp/contests/practice2/tasks/practice2_k\ntemplate<class N>\nstruct seglazy{\n\tvc<N> x;\n\tint L,s;\n\tseglazy(){}\n\ttemplate<class T>\n\tseglazy(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif(l==r)return N();\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml,smr;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = N::merge(sml, x[l++]);\n\t\t\tif (r & 1) smr = N::merge(x[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\n\t\treturn N::merge(sml, smr);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r, F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t//(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[0][cnt[0]++]=l++;\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t//(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[1][cnt[1]++]=--r;\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\t\trep(i,cnt[0])(x[buf[0][i]].*f)(forward<Args>(args)...);\n\t\tper(i,cnt[1])(x[buf[1][i]].*f)(forward<Args>(args)...);\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\t//XXI Opencup Krakow M\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\tassert(0<=r&&r<=s);\n        if(r==0)return mp(0,N());\n        r+=s;\n        for (int i = L; i >= 1; i--) push((r - 1) >> i);\n        N sm;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    push(r);\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\n//Range add,min\nstruct N{\n\tll lz,mn;\n\tN(ll v=infLL):lz(0),mn(v){}\n\tvoid add(ll v){\n\t\tmn+=v;\n\t\tlz+=v;\n\t}\n\tvoid push(N&x,N&y){\n\t\tx.add(lz);\n\t\ty.add(lz);\n\t\tlz=0;\n\t}\n\tstatic N merge(N x,N y){\n\t\treturn N(min(x.getm(),y.getm()));\n\t}\n\tll getm(){return mn;}\n\tbool ok(ll v){\n\t\treturn mn>v;\n\t}\n};\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<int> g=readGraph(n,m);\n\tvvc<int> t(n),z(n);\n\t{\n\t\tvi vis(n);\n\t\tauto dfs=[&](auto self,int v,int p)->void{\n\t\t\tassert(vis[v]==0);\n\t\t\tvis[v]=1;\n\t\t\tfor(auto to:g[v])if(to!=p){\n\t\t\t\tif(vis[to]==0){\n\t\t\t\t\tt[v].pb(to);\n\t\t\t\t\tself(self,to,v);\n\t\t\t\t}else if(vis[to]==1){\n\t\t\t\t\tz[v].pb(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[v]=2;\n\t\t};\n\t\tdfs(dfs,0,-1);\n\t}\n\tHLD<int> hld(t,0);\n\t\n\tauto work=[&](vc<pi> ls){\n\t\tvi res(n);\n\t\tfor(auto [a,b]:ls){\n\t\t\tres[a]++;\n\t\t\tres[b]++;\n\t\t\tres[hld.lca(a,b)]-=2;\n\t\t}\n\t\tauto dfs=[&](auto self,int v)->void{\n\t\t\tfor(auto ch:t[v]){\n\t\t\t\tself(self,ch);\n\t\t\t\tres[v]+=res[ch];\n\t\t\t}\n\t\t};\n\t\tdfs(dfs,0);\n\t\treturn res;\n\t};\n\t\n\tint qnum;cin>>qnum;\n\tvc<pi> qs(qnum);\n\tvvc<int> qup(n);\n\trep(i,qnum){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tqs[i]=pi(a,b);\n\t\tint c=hld.lca(a,b);\n\t\tqup[a].pb(c);\n\t\tqup[b].pb(c);\n\t}\n\t\n\tvi pass=work(qs);\n\tvi block;\n\tvi cov(n,0);\n\tvc<pi> binfo(n);\n\t{\n\t\tvc<pi> tmp;\n\t\trep(i,n)for(auto j:z[i])tmp.eb(i,j);\n\t\tblock=work(tmp);\n\t\tsort(all(tmp),[&](pi a,pi b){return hld.dep[a.b]>hld.dep[b.b];});\n\t\tunionfind uf(n);\n\t\tfor(auto [from,to]:tmp){\n\t\t\tpi e(from,to);\n\t\t\tfrom=uf.find(from);\n\t\t\twhile(hld.dep[from]>hld.dep[to]){\n\t\t\t\tcov[from]=hld.dep[to];\n\t\t\t\tbinfo[from]=e;\n\t\t\t\tint p=uf.find(hld.par[from]);\n\t\t\t\tuf.unite(p,from);\n\t\t\t\tfrom=p;\n\t\t\t}\n\t\t}\n\t}\n\tusing A=array<int,2>;\n\tvc<A> zup(n,A{inf,inf});\n\tauto updzup=[&](int v,int d){\n\t\trep(k,2){\n\t\t\tif(d<zup[v][k])swap(d,zup[v][k]);\n\t\t}\n\t};\n\t{\n\t\tauto dfs=[&](auto self,int v)->void{\n\t\t\tfor(auto j:z[v])updzup(v,hld.dep[j]);\n\t\t\tfor(auto ch:t[v]){\n\t\t\t\tself(self,ch);\n\t\t\t\tupdzup(v,zup[ch][0]);\n\t\t\t}\n\t\t};\n\t\tdfs(dfs,0);\n\t}\n\t\n\tint ans=-1;\n\tpi e1,e2;\n\tauto updans=[&](int val,pi x,pi y){\n\t\tif(chmax(ans,val)){\n\t\t\te1=x;\n\t\t\te2=y;\n\t\t}\n\t};\n\t{\n\t\tint x[2]{-inf,-inf};\n\t\tpi e[2]{};\n\t\trng(i,1,n){\n\t\t\tint v=block[i]==0?pass[i]:0;\n\t\t\tpi cur=pi(i,hld.par[i]);\n\t\t\trep(k,2)if(v>x[k]){\n\t\t\t\tswap(v,x[k]);\n\t\t\t\tswap(cur,e[k]);\n\t\t\t}\n\t\t}\n\t\tupdans(x[0]+x[1],e[0],e[1]);\n\t}\n\trng(i,1,n)if(block[i]==1){\n\t\tupdans(pass[i],pi(i,hld.par[i]),binfo[i]);\n\t}\n\t\n\tseglazy<N> seg(vc<ll>(n,0));\n\t\n\tconst int V=1<<30;\n\t\n\tauto upd=[&](int v,int w){\n\t\tfor(auto up:qup[v]){\n\t\t\tseg.ch(hld.dep[up],hld.dep[v],&N::add,w*2);\n\t\t}\n\t};\n\t\n\tauto sub=[&](auto self,int v,int w)->void{\n\t\tupd(v,w);\n\t\tfor(auto ch:t[v])self(self,ch,w);\n\t};\n\t\n\tvc<pi> ebuf;\n\t\n\tauto dfs=[&](auto self,int v)->void{\n\t\tint p=hld.par[v];\n\t\tint ban;\n\t\tif(p!=-1){\n\t\t\tebuf.eb(v,p);\n\t\t\tban=zup[p][0];\n\t\t\tif(ban==zup[v][0])ban=zup[p][1];\n\t\t\tif(ban<hld.dep[p]){\n\t\t\t\tseg.ch(ban,hld.dep[p],&N::add,V);\n\t\t\t}\n\t\t\tseg.point_change(hld.dep[p],&N::add,-pass[v]);\n\t\t}\n\t\tint hc=si(t[v])?hld.g[v][0]:-1;\n\t\tfor(auto ch:hld.g[v]){\n\t\t\tif(ch!=hc){\n\t\t\t\tself(self,ch);\n\t\t\t}\n\t\t}\n\t\tif(hc!=-1)self(self,hc);\n\t\tif(p!=-1){\n\t\t\tupd(v,1);\n\t\t\tfor(auto ch:hld.g[v]){\n\t\t\t\tif(ch!=hc){\n\t\t\t\t\tsub(sub,ch,1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cov[v]<hld.dep[p]){\n\t\t\t\tll val=seg.composite(cov[v],hld.dep[p]).mn;\n\t\t\t\tll unko=pass[v]-val;\n\t\t\t\tif(ans<unko){\n\t\t\t\t\tint pos=seg.max_right(cov[v],&N::ok,val).a;\n\t\t\t\t\tupdans(unko,ebuf.back(),ebuf[pos]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ban<hld.dep[p]){\n\t\t\t\tseg.ch(ban,hld.dep[p],&N::add,-V);\n\t\t\t}\n\t\t\tseg.point_change(hld.dep[p],&N::add,pass[v]);\n\t\t\tebuf.pop_back();\n\t\t}\n\t\tif(hld.head[v]==v){\n\t\t\tsub(sub,v,-1);\n\t\t}\n\t};\n\tdfs(dfs,0);\n\t\n\tprint(ans);\n\tprint_offset(e1,1);\n\tprint_offset(e2,1);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'dfs and similar', 'graphs']",3500
https://codeforces.com//contest/961/problem/B,B. Lecture Sleep,Your friend Mishka and you attend a calculus lecture Lecture lasts minutes Lecturer tells theorems during the th minute Mishka is really interested in calculus though it is so hard to stay awake for all the time of lecture You are given an array of Mishka s behavior If Mishka is asleep during the th minute of the lecture then will be equal to otherwise it will be equal to When Mishka is awake he writes down all the theorems he is being told during the th minute Otherwise he writes nothing You know some secret technique to keep Mishka awake for minutes straight However you can use it You can start using it at the beginning of any minute between and If you use it on some minute then Mishka will be awake during minutes such that and will write down all the theorems lecturer tells You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique to wake him up ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in1[100050];\nint in2[100050];\nll sum1[100050];\nll sum2[100050];\nint main() {\n\tint N, K, i, j;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in1[i]);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in2[i]);\n\tfor (i = 1; i <= N; i++) {\n\t\tsum1[i] = sum1[i - 1] + in1[i] * in2[i];\n\t\tsum2[i] = sum2[i - 1] + in1[i];\n\t}\n\n\tll mx = 0;\n\tfor (i = 1; i <= N - K + 1; i++) {\n\t\tll v = sum1[i - 1] + (sum2[i + K - 1] - sum2[i - 1]) + (sum1[N] - sum1[i + K - 1]);\n\t\tmx = max(mx, v);\n\t}\n\treturn !printf(""%lld\\n"", mx);\n}']","['data structures', 'dp', 'implementation', 'two pointers']",1200
https://codeforces.com//contest/1646/problem/D,D. Weight the Tree,You are given a tree of n vertices numbered from 1 to n A tree is a connected undirected graph without cycles For each i 1 2 ldots n let w i be the weight of the i th vertex A vertex is called if its weight is equal to the sum of the weights of all its neighbors Initially the weights of all nodes are unassigned Assign positive integer weights to each vertex of the tree such that the number of good vertices in the tree is maximized If there are multiple ways to do it you have to find one that minimizes the sum of weights of all vertices in the tree ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    if (n == 2) {\n        cout << ""2 2\\n1 1"";\n        return 0;\n    }\n    vector<vector<int>> G(n + 1);\n    for (int i = 1, u, v; i < n; i += 1) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<pair<int, int>> f(n + 1), g(n + 1);\n    function<void(int, int)> DFS = [&](int u, int p) {\n        for (int v : G[u])\n            if (v != p) {\n                DFS(v, u);\n                auto pr = min(f[v], g[v]);\n                g[u].first += pr.first;\n                g[u].second += pr.second;\n                f[u].first += g[v].first;\n                f[u].second += g[v].second;\n            }\n        f[u].first -= 1;\n        f[u].second += G[u].size() - 1;\n    };\n    DFS(1, 0);\n    auto pr = min(f[1], g[1]);\n    cout << -pr.first << "" "" << pr.second + n << ""\\n"";\n    vector<int> ans(n + 1, 1);\n    function<void(int, int, int)> DFS2 = [&](int u, int p, int cf) {\n        if (cf) ans[u] = G[u].size();\n        for (int v : G[u])\n            if (v != p) {\n                if (cf) DFS2(v, u, 0);\n                else DFS2(v, u, f[v] < g[v]);\n            }\n        f[u].first -= 1;\n        f[u].second += G[u].size() - 1;\n    };\n    DFS2(1, 0, f[1] < g[1]);\n    for (int i = 1; i <= n; i += 1) cout << ans[i] << "" "";\n    return 0;\n}']","['constructive algorithms', 'dfs and similar', 'dp', 'implementation', 'trees']",2000
https://codeforces.com//contest/351/problem/A,A. Jeff and Rounding,Jeff got real numbers as a birthday present The boy hates non integer numbers so he decided to slightly adjust the numbers he s got Namely Jeff consecutively executes operations each of them goes as follows choose indexes and that haven t been chosen yet round element to the nearest integer that isn t more than assign to round element to the nearest integer that isn t less than assign to Nevertheless Jeff doesn t want to hurt the feelings of the person who gave him the sequence That s why the boy wants to perform the operations so as to make the absolute value of the difference between the sum of elements before performing the operations and the sum of elements after performing the operations as small as possible Help Jeff find the minimum absolute value of the difference ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint a[4010],b[4010];\n\nint main(void){\n    int N,i;\n    \n    cin >> N;\n    REP(i,2*N){\n        double x;\n        cin >> x;\n        int y = (int)(x * 1000 + 0.5);\n        a[i] = y % 1000;\n    }\n    \n    int sum = 0;\n    REP(i,2*N) sum += a[i];\n    \n    REP(i,2*N) b[i] = ((a[i] == 0) ? 0 : 1000);\n    sort(b, b+2*N);\n    int low = 0, high = 0;\n    REP(i,N) low += b[i];\n    REP(i,N) high += b[N+i];\n    \n    int ans = (1<<29);\n    for(i=low;i<=high;i+=1000) ans = min(ans, abs(i - sum));\n    \n    printf(""%.3f\\n"", ans / 1000.0);\n    \n    return 0;\n}\n']","['dp', 'greedy', 'implementation', 'math']",1800
https://codeforces.com//contest/559/problem/A,A. Gerald s Hexagon,Gerald got a very curious hexagon for his birthday The boy found out that all the angles of the hexagon are equal to Then he measured the length of its sides and found that each of them is equal to an integer number of centimeters There the properties of the hexagon ended and Gerald decided to draw on it He painted a few lines parallel to the sides of the hexagon The lines split the hexagon into regular triangles with sides of 1 centimeter Now Gerald wonders how many triangles he has got But there were so many of them that Gerald lost the track of his counting Help the boy count the triangles ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint a[10];\nint main() {\n\trep(i,0,6) scanf(""%d"",a+i);\n\tprintf(""%d\\n"",(a[0]+a[1]+a[2])*(a[0]+a[1]+a[2])-a[0]*a[0]-a[2]*a[2]-a[4]*a[4]);\n}\n']","['brute force', 'geometry', 'math']",1600
https://codeforces.com//contest/946/problem/C,C. String Transformation,You are given a string consisting of small english letters In one move you can replace any character of this string to the next character in alphabetical order will be replaced with will be replaced with etc You cannot replace letter with any other letter Your target is to make some number of moves not necessary minimal to get string english alphabet as a subsequence Subsequence of the string is the string that is obtained by deleting characters at some positions You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible ,"['// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored ""-Wunused-result""\n#pragma GCC diagnostic ignored ""-Wunused-function""\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(""%d"", &x); }\nvoid _R(int64_t &x) { scanf(""%"" SCNd64, &x); }\nvoid _R(double &x) { scanf(""%lf"", &x); }\nvoid _R(char &x) { scanf("" %c"", &x); }\nvoid _R(char *x) { scanf(""%s"", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(""%d"", x); }\nvoid _W(const int64_t &x) { printf(""%"" PRId64, x); }\nvoid _W(const double &x) { printf(""%.16f"", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(""%s"", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(\' \'); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? \' \' : \'\\n\'); W(tail...); }\n\n#ifdef SHIK\n#include ""dump.hpp""\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=1e5+10;\nchar s[N];\nvoid main() {\n    R(s);\n    int n=strlen(s);\n    char c=\'a\';\n    REP(i,n) {\n        if ( c>\'z\' || s[i]>c ) continue;\n        s[i]=c++;\n    }\n    if ( c>\'z\' ) W(s);\n    else W(-1);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n']","['greedy', 'strings']",1300
https://codeforces.com//contest/1573/problem/A,A. Countdown,You are given a digital clock with n digits Each digit shows an integer from 0 to 9 so the whole clock shows an integer from 0 to 10 n 1 The clock will show leading zeroes if the number is smaller than 10 n 1 You want the clock to show 0 with as few operations as possible In an operation you can do one of the following decrease the number on the clock by 1 or swap two digits you can choose which digits to swap and they don t have to be adjacent Your task is to determine the minimum number of operations needed to make the clock show 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint i,j,k,n,m,t,res;\n\nint main(){\n\tscanf(""%d"",&t);\n\twhile(t--){\n\t\tscanf(""%d"",&n);res=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(""%1d"",&k);\n\t\t\tif(k){\n\t\t\t\tres+=1+k;\n\t\t\t\tif(i==n)res--;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",res);\n\t}\n}']",['greedy'],800
https://codeforces.com//contest/596/problem/C,C. Wilbur and Points,Wilbur is playing with a set of points on the coordinate plane All points have non negative integer coordinates Moreover if some point belongs to the set then all points such that and also belong to this set Now Wilbur wants to number the points in the set he has that is assign them distinct integer numbers from to In order to make the numbering Wilbur imposes the condition that if some point gets number then all from the set such that and must be assigned a number not less than For example for a set of four points and there are two aesthetically pleasing numberings One is and another one is Wilbur s friend comes along and challenges Wilbur For any point he defines it s as Now he gives Wilbur some and asks him to find an aesthetically pleasing numbering of the points in the set such that the point that gets number has it s special value equal to that is Now Wilbur asks you to help him with this challenge ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 1e5 + 49;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nint sz, w[maxN], m, sx[maxN], sy[maxN];\nint ans[maxN];\nset<pii> st;\nmap<pii, int> ind;\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tint ii = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> sx[i] >> sy[i];\n\t\tind[pii(sx[i], sy[i])] = i;\t\n\t\tif (!sx[i] && !sy[i]) ii = i;\t\n\t}\n\tst.insert({0, ii});\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tauto it = st.lower_bound(make_pair(w[i], -1));\n\t\tif (it != st.end() && (*it).x == w[i]) {\n\t\t\tans[m++] = (*it).second;\n\t\t\tint id = (*it).second;\n\t\t\tfor (int xadd = 0; xadd < 2; xadd++) {\n\t\t\t\tint nx = sx[id] + xadd, ny = sy[id] + (xadd ^ 1);\n\t\t\t\tif (ind.find(make_pair(nx, ny)) != ind.end()) {\n\t\t\t\t\tst.insert({ny - nx, ind[make_pair(nx, ny)]});\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.erase(it);\n\t\t} else {\n\t\t\tcout << ""NO\\n"";\n\t\t\treturn 0;\t\n\t\t}\n\t}\n\tcout << ""YES\\n"";\n\tfor (int i = 0; i < n; i++)\n\t\tcout << sx[ans[i]] << \' \' << sy[ans[i]] << \'\\n\';\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","['combinatorics', 'greedy', 'sortings']",1700
https://codeforces.com//contest/1712/problem/A,A. Wonderful Permutation,A Random PebbleYou are given a permutation p 1 p 2 ldots p n of length n and a positive integer k le n In one operation you can choose two indices i and j 1 le i j le n and swap p i with p j Find the minimum number of operations needed to make the sum p 1 p 2 ldots p k as small as possible A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define int long long\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n\nint T,n,ans,i,j,k,a[N]; \nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>k;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i];\n\t\t\tif(i<=k&&a[i]>k)++ans;\n\t\t}\n\t\tcout<<ans<<""\\n"";ans=0;\n\t}\n}']","['greedy', 'implementation']",800
https://codeforces.com//contest/1864/problem/E,E. Guess Game,Carol has a sequence s of n non negative integers She wants to play the Guess Game with Alice and Bob To play the game Carol will select two integer indices i a and i b within the range 1 n and set a s i a b s i b Please note that i a and i b may coincide Carol will tell the value of a to Alice the value of b to Bob the value of a mid b to both Alice and Bob where denotes the bitwise OR operation Please note that Carol will tell any information about s to either Alice or Bob Then the guessing starts The two players take turns making guesses with Alice starting first The goal of both players is to establish which of the following is true a b a b or a b In their turn a player can do one of the following two things say I don t know and pass the turn to the other player say I know followed by the answer a b a b or a b then the game ends Alice and Bob hear what each other says and can use this information to deduce the answer Both Alice and Bob are smart enough and only say I know when they are completely sure You need to calculate the expected value of the number of turns taken by players in the game Output the answer modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst int d=30;\n\nint n;\nll tab[nax];\n\nll wyn=0;\n\nll inv(ll v)\n{\n\tif (v<=1)\n\t\treturn v;\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nvoid rek(vll wek)\n{\n\tif (wek[0]==wek.back())\n\t{\n\t\twyn+=wek.size()*(ll)wek.size()*(ll)(__builtin_popcountll(wek[0])+1);\n\t\treturn;\n\t}\n\tll r=wek[0]^wek.back();\n\tint x=63-__builtin_clzll(r);\n\tvll a, b;\n\tfor (ll i : wek)\n\t{\n\t\tif (i&(1LL<<x))\n\t\t\ta.push_back(i);\n\t\telse\n\t\t\tb.push_back(i);\n\t}\n\tll kejsy=a.size()*(ll)b.size();\n\tll resz=wek.size()*(ll)wek.size()-kejsy;\n\tll wyz=0;\n\t{\n\t\tll p=wek[0]&(wek[0]^((1LL<<x)-1));\n\t\tp=__builtin_popcountll(p);\n\t\twyz=p+1;\n\t}\n\t//~ debug() << imie(wek) << imie(kejsy) << imie(resz);\n\twyn+=kejsy*(2*wyz+1);\n\twyn%=mod;\n\t//~ wyn+=resz;\n\t//~ wyn%=mod;\n\trek(a);\n\trek(b);\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tsort(tab+1, tab+1+n);\n\twyn=0;\n\t//~ map<ll,ll> mapa;\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ mapa[tab[i]]++;\n\t//~ wyn=0;\n\t//~ for (auto i : mapa)\n\t//~ {\n\t\t//~ wyn+=i.second*i.second*(__builtin_popcountll(i.first)+1);\n\t\t//~ wyn%=mod;\n\t//~ }\n\tvll wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back(tab[i]);\n\trek(wek);\n\t\n\twyn*=inv(n*(ll)n%mod);\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['bitmasks', 'data structures', 'games', 'math', 'probabilities', 'sortings', 'strings', 'trees']",2100
https://codeforces.com//contest/1630/problem/B,B. Range and Partition,Given an array a of n integers find a range of values x y x le y and split a into k 1 le k le n subarrays in such a way that Each subarray is formed by several continuous elements of a that is it is equal to a l a l 1 ldots a r for some l and r 1 leq l leq r leq n Each element from a belongs to exactly one subarray In each subarray the number of elements inside the range x y inclusive is than the number of elements outside the range An element with index i is inside the range x y if and only if x le a i le y Print any solution that minimizes y x ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint cnt[N];\nint k;\n\nvoid solve() {\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tcnt[a[i]]++;\n\t}\n\tint w = (n + k + 1) / 2;\n\tint L = 1, R = n + 1;\n\tint r = 1, sum = 0;\n\tfor (int l = 1; l <= n; l++) {\n\t\twhile(r <= n && sum < w) {\n\t\t\tsum += cnt[r];\n\t\t\tr++;\n\t\t}\n\t\tif (sum < w) break;\n\t\tif (r - l < R - L) {\n\t\t\tL = l;\n\t\t\tR = r;\n\t\t}\n\t\tsum -= cnt[l];\n\t}\n\tprintf(""%d %d\\n"", L, R - 1);\n\tint lst = 0;\n\tint p = 0;\n\tsum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (L <= a[i] && a[i] < R) {\n\t\t\tsum++;\n\t\t} else {\n\t\t\tsum--;\n\t\t}\n\t\tif (p + 1 < k && sum > p) {\n\t\t\tp++;\n\t\t\tprintf(""%d %d\\n"", lst + 1, i + 1);\n\t\t\tlst = i + 1;\n\t\t}\n\t}\n\tprintf(""%d %d\\n"", lst + 1, n);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['binary search', 'constructive algorithms', 'data structures', 'greedy', 'two pointers']",1800
https://codeforces.com//contest/830/problem/E,E. Perpetual Motion Machine,Developer Petr thinks that he invented a perpetual motion machine Namely he has a lot of which work in the following way Each element has one controller that can be set to any non negative real value If a controller is set on some value then the controller consumes energy units per second At the same time any two elements connected by a wire produce energy units per second where and are the values set on their controllers Petr has only a limited number of wires so he has already built some scheme of elements and wires and is now interested if it s possible to set the controllers in such a way that the system produces power as it consumes and at least one controller is set on the value different from Help him check this and if it s possible find the required values that should be set It is guaranteed that if there exist controllers settings satisfying the above conditions then there exist required integer values not greater than ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstruct bian{\n\tint next,point;\n}b[210000];\nint p[110000],d[110000],n,m,pd[110000],len,ans[110000];\nvector<int>A,x[10];\nint compare(vector<int>A,vector<int>B){\n\treturn A.size()<B.size();\n}\nvoid ade(int k1,int k2){\n\tb[++len]=(bian){p[k1],k2}; p[k1]=len; d[k1]++;\n}\nvoid add(int k1,int k2){\n\tade(k1,k2); ade(k2,k1);\n}\nvoid dfs(int k){\n\tpd[k]=1; A.push_back(k);\n\tfor (int i=p[k];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (pd[j]==0) dfs(j);\n\t}\n}\nvoid print(){\n\tprintf(""YES\\n"");\n\tfor (int i=1;i<=n;i++) printf(""%d "",ans[i]); printf(""\\n"");\n}\nvoid dfs2(int k1,int k2,int k3){\n\tx[k3].push_back(k1);\n\tfor (int i=p[k1];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (j!=k2) dfs2(j,k1,k3);\n\t}\n}\nint solveextra(int k){\n\tint tot=0;\n\tfor (int i=0;i<3;i++) x[i].clear();\n\tfor (int i=p[k];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tdfs2(j,k,tot); tot++;\n\t}\n\tsort(x,x+3,compare);\n\tint a=x[0].size(),b=x[1].size(),c=x[2].size();\n//\tcout<<""fa ""<<k<<"" ""<<a<<"" ""<<b<<"" ""<<c<<endl; \n\tint lima=0,limb=0,limc=0;\n\tif (a>1&&b>1&&c>1){\n\t\tlima=3; limb=3; limc=3;\n\t} else if (a==1&&b==1) return 0;\n\telse {\n\t\tlima=2;\n\t\tint flag=0;\n\t\tfor (int i=2;i<=b+1;i++){\n\t\t\tdouble now=1/4.0+1.0*(i-1)/2/i+(1.0)*(c)/2/(c+1);\n\t\t//\tcout<<""fa ""<<i<<"" ""<<c<<"" ""<<now<<endl;\n\t\t\tif (now+1e-9>1){\n\t\t\t\tlimb=i; limc=c+1; flag=1; break;\n\t\t\t}\n\t\t}\n\t\tif (flag==0) return 0;\n\t}\n\ttot=lima;\n\ttot=tot*limb/__gcd(tot,limb);\n\ttot=tot*limc/__gcd(tot,limc);\n\tans[k]=tot; int lim[3];\n\tlim[0]=lima; lim[1]=limb; lim[2]=limc;\n\tfor (int i=0;i<3;i++){\n\t\tint K=tot/lim[i];\n\t\tfor (int j=0;j<x[i].size();j++){\n\t\t\tans[x[i][j]]=max(1ll*K,tot-1ll*K*(j+1));\n\t\t}\n\t}\n\tprint(); return 1;\n}\nvoid solve(){\n\tscanf(""%d%d"",&n,&m); len=0;\n\tfor (int i=1;i<=n;i++) p[i]=d[i]=pd[i]=ans[i]=0;\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(""%d%d"",&k1,&k2);\n\t\tadd(k1,k2);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (pd[i]==0){\n\t\t\tA.clear();\n\t\t\tdfs(i); int totm=0;\n\t\t\tfor (int j=0;j<A.size();j++) totm+=d[A[j]];\n\t\t\ttotm/=2; //cout<<totm<<"" ""<<A.size()<<endl;\n\t\t\tif (totm>=A.size()){\n\t\t\t\tfor (int j=0;j<A.size();j++) ans[A[j]]=1;\n\t\t\t\tprint(); return;\n\t\t\t}\n\t\t\tint num=0;\n\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\tif (d[A[j]]==1) num++;\n\t\t\tif (num>=4){\n\t\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\t\tif (d[A[j]]==1) ans[A[j]]=1; else ans[A[j]]=2;\n\t\t\t\tprint(); return;\n\t\t\t}\n\t\t\tif (num==3){\n\t\t\t\tint where=0;\n\t\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\t\tif (d[A[j]]==3) where=A[j];\n\t\t\t\tif (solveextra(where)) return;\n\t\t\t}\n\t\t}\n\tprintf(""NO\\n"");\n}\nint main(){\n\tint t; scanf(""%d"",&t);\n\tfor (;t;t--) solve();\n\treturn 0;\n}']","['constructive algorithms', 'dp', 'graphs', 'implementation', 'math', 'trees']",3100
https://codeforces.com//contest/1492/problem/E,E. Almost Fault-Tolerant Database,You are storing an integer array of length m in a database To maintain internal integrity and protect data the database stores n copies of this array Unfortunately the recent incident may have altered the stored information in every copy in the database It s believed that the incident altered at most two elements in every copy You need to recover the original array based on the current state of the database In case there are multiple ways to restore the array report any If there is no array that differs from every copy in no more than two positions report that as well ,"['#include <bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n\nll MOD = (ll)1000000007;\nvector<vector<int>> nums;\nvector<int> test;\nvector<map<int, int>> ct;\nvector<vector<pair<int, int>>> ctsort;\n\nbool check() {\n    // cout << ""Checking "";\n    // for(int i = 0; i < test.size(); i++) cout << test[i] << \' \';\n    for(int i = 0; i < nums.size(); i++) {\n        int x = 0;\n        for(int j = 0; j < test.size(); j++) {\n            if(test[j] != nums[i][j]) x++;\n        }\n        if(x > 2) return false;\n    }\n    // cout << ""...good!\\n"";\n    return true;\n}\n\nbool rec(int i, int s) {\n    if(s < 0) return false;\n    if(i == -1) {\n        return check();\n    }\n    for(int j = 0; j < ctsort[i].size(); j++) {\n        test[i] = ctsort[i][j].second;\n        if(rec(i-1, s-ctsort[i][j].first)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t, m, n;\n    ll k, ans = 0;\n    string s1, s2;\n    bool sad = false;\n    cin >> m >> n;\n    nums.resize(m);\n    ct.resize(n);\n    ctsort.resize(n);\n    test.resize(n);\n    for(int i = 0; i < m; i++) {\n        nums[i].resize(n);\n        for(int j = 0; j < n; j++) {\n            cin >> nums[i][j];\n            ct[j][nums[i][j]]++;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        for(pair<int, int> p : ct[i]) {\n            ctsort[i].push_back({m - p.second, p.first});\n        }\n        sort(ctsort[i].begin(), ctsort[i].end());\n    }\n    // for(int i = 0; i < n; i++) {\n    //     for(int j = 0; j < ctsort[i].size(); j++) {\n    //         cout << ctsort[i][j].second << \' \' << ctsort[i][j].first << "" | "";\n    //     }\n    //     cout << \'\\n\';\n    // }\n    if(rec(n-1, 2*m)) {\n        cout << ""Yes\\n"";\n        for(int i = 0; i < n; i++) cout << test[i] << \' \';\n    }\n    else cout << ""No\\n"";\n}']","['brute force', 'constructive algorithms', 'dfs and similar', 'greedy', 'implementation']",2500
https://codeforces.com//contest/1654/problem/F,F. Minimal String Xoration,You are given an integer n and a string s consisting of 2 n lowercase letters of the English alphabet The characters of the string s are s 0s 1s 2 cdots s 2 n 1 A string t of length 2 n whose characters are denoted by t 0t 1t 2 cdots t 2 n 1 is a of s if there exists an integer j 0 le j leq 2 n 1 such that for each 0 leq i leq 2 n 1 t i s i oplus j where oplus denotes the operation bitwise XOR Find the lexicographically minimal of s A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tconst int nn = 1 << n;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cur(nn);\n\tfor (int i = 0; i < nn; ++i) {\n\t\tcur[i] = s[i] - \'a\';\n\t}\n\tvector<pair<int, int>> tmp(nn);\n\tfor (int len = 1; len < nn; len *= 2) {\n\t\tfor (int start = 0; start < nn; start += 2 * len) {\n\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\ttmp[start + i] = {cur[start + i], cur[start + len + i]};\n\t\t\t\ttmp[start + len + i] = {cur[start + len + i], cur[start + i]};\n\t\t\t}\n\t\t}\n\t\tauto tt = tmp;\n\t\tmake_unique(tt);\n\t\tfor (int i = 0; i < nn; ++i) {\n\t\t\tcur[i] = lower_bound(all(tt), tmp[i]) - tt.begin();\n\t\t}\n\t}\n\tint x = min_element(all(cur)) - cur.begin();\n\tstring t;\n\tfor (int i = 0; i < nn; ++i) {\n\t\tt += s[i ^ x];\n\t}\n\tcout << t << ""\\n"";\n}\n\nint main() {\n\tint t = 1; // nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","['bitmasks', 'data structures', 'divide and conquer', 'greedy', 'hashing', 'sortings', 'strings']",2800
https://codeforces.com//contest/1137/problem/E,E. Train Car Selection,Vasya likes to travel by train but doesn t like when the car he travels in is located in the tail of the train Vasya gets on the train at the station The train consists of n cars indexed from 1 to n counting from the locomotive head of the train Three types of events occur while the train is moving Some number of cars are added to the head of the train Some number of cars are added to the tail of the train Vasya recalculates the values of the convenience of the cars read more about it below At each moment of time we will index the cars from the head of the train starting from 1 Note that when adding new cars to the head of the train the indexing of the old ones may shift To choose which car to go in Vasya will use the value A i for each car where i is a car index which is calculated as follows At the beginning of the trip A i 0 as well as for the new cars at the time of their addition During the next recalculation Vasya chooses some integers b and s and adds to all A i value b i 1 cdot s Vasya hasn t decided yet where he will get on the train and where will get off the train so after each event of one of the three types he wants to know the least index of the car such that its value A i is minimal Since there is a lot of cars Vasya asked you to write a program that answers his question ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n  long long x, y;\n\n  point(long long x = 0, long long y = 0): x(x), y(y) {\n  }\n\n  point operator - (const point &b) const {\n    return point(x - b.x, y - b.y);\n  }\n};\n\nbool check(point p, point q, point r) {\n  point pp = p - q, rr = r - q;\n  return (long double) pp.x * rr.y >= (long double) pp.y * rr.x;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  int m;\n  cin >> n >> m;\n  long long add = 0, slope = 0;\n  vector<point> hull(1, point(0, 0));\n  while (m--) {\n    int type;\n    cin >> type;\n    if (type == 1) {\n      int cnt;\n      cin >> cnt;\n      hull.clear();\n      hull.push_back(point(0, 0));\n      n += cnt;\n      add = slope = 0;\n    } else if (type == 2) {\n      int cnt;\n      cin >> cnt;\n      while (hull.size() > 1 && check(point(n, -(n * slope + add)), hull[hull.size() - 2], hull[hull.size() - 1])) {\n        hull.pop_back();\n      }\n      hull.push_back(point(n, -(n * slope + add)));\n      n += cnt;\n    } else {\n      int b, s;\n      cin >> b >> s;\n      add += b;\n      slope += s;\n    }\n    while (hull.size() > 1 && slope * hull.back().x + hull.back().y >= slope * hull[hull.size() - 2].x + hull[hull.size() - 2].y) {\n      hull.pop_back();\n    }\n    cout << hull.back().x + 1 << "" "" << slope * hull.back().x + hull.back().y + add << ""\\n"";\n  }\n  return 0;\n}\n']","['data structures', 'greedy']",2700
https://codeforces.com//contest/1154/problem/A,A. Restoring Three Numbers,Polycarp has guessed three positive integers a b and c He keeps these numbers in secret but he writes down four numbers on a board in arbitrary order their pairwise sums three numbers and sum of all three numbers one number So there are four numbers on a board in random order a b a c b c and a b c You have to guess three numbers a b and c using given numbers Print three guessed integers in any order Pay attention that some given numbers a b and c can be equal it is also possible that a b c ,"[""// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  int a[4];\n  generate_n(a, 4, read);\n  sort(a, a + 4);\n  for (int i = 0; i < 3; ++i) {\n    cout << a[3] - a[i] << ' ';\n  }\n  return 0;\n}\n""]",['math'],800
https://codeforces.com//contest/553/problem/A,A. Kyoya and Colored Balls,Kyoya Ootori has a bag with colored balls that are colored with different colors The colors are labeled from to Balls of the same color are indistinguishable He draws balls from the bag one by one until the bag is empty He noticed that he drew the last ball of color before drawing the last ball of color for all from to Now he wonders how many different ways this can happen ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\n\nll choose[3000][3050];\n\nint main() {\n\tfor(ll i = 0; i < 3000; i++) {\n\t\tchoose[i][0] = choose[i][i] = 1;\n\t\tfor(ll j = 1; j < i; j++) {\n\t\t\tchoose[i][j] = choose[i - 1][j - 1] + choose[i - 1][j];\n\t\t\tif(choose[i][j] >= MOD) choose[i][j] -= MOD;\n\t\t}\n\t}\n\n\tll K; cin >> K;\n\tll cnt = 0;\n\tll ways = 1;\n\tfor(ll i = 0; i < K; i++) {\n\t\tll c;\n\t\tcin >> c;\n\t\tways *= choose[cnt + c - 1][cnt];\n\t\tways %= MOD;\n\t\tcnt += c;\n\t}\n\n\tcout << ways % MOD << '\\n';\n\n\treturn 0;\n}\n""]","['combinatorics', 'dp', 'math']",1500
https://codeforces.com//contest/559/problem/E,E. Gerald and Path,The main walking trail in Geraldion is absolutely straight and it passes strictly from the north to the south it is so long that no one has ever reached its ends in either of the two directions The Geraldionians love to walk on this path at any time so the mayor of the city asked the Herald to illuminate this path with a few spotlights The spotlights have already been delivered to certain places and Gerald will not be able to move them Each spotlight illuminates a specific segment of the path of the given length one end of the segment is the location of the spotlight and it can be directed so that it covers the segment to the south or to the north of spotlight The trail contains a monument to the mayor of the island and although you can walk in either directions from the monument no spotlight is south of the monument You are given the positions of the spotlights and their power Help Gerald direct all the spotlights so that the total length of the illuminated part of the path is as much as possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=310;\nVI pos;\nint n,m,a[N],l[N],pm[N],pl[N],pr[N];\nll dp[N][N][N],ans;\ninline void upd(ll &a,ll b) { if (a<b) a=b;}\nint main() {\n//\tfreopen(""E.in"",""r"",stdin);\n\tscanf(""%d"",&n);\n\trep(i,0,n) {\n\t\tscanf(""%d%d"",a+i,l+i);\n\t\tpos.pb(a[i]); pos.pb(a[i]+l[i]); pos.pb(a[i]-l[i]);\n\t}\n\tsort(all(pos));\n\tpos.erase(unique(all(pos)),pos.end());\n\trep(i,0,n) {\n\t\tpm[i]=lower_bound(all(pos),a[i])-pos.begin();\n\t\tpl[i]=lower_bound(all(pos),a[i]-l[i])-pos.begin();\n\t\tpr[i]=lower_bound(all(pos),a[i]+l[i])-pos.begin();\n//\t\tprintf(""%d %d %d %d\\n"",i,pm[i],pl[i],pr[i]);\n\t}\n\tm=SZ(pos);\n\trep(i,0,m) rep(j,0,m) rep(k,0,m) dp[i][j][k]=-(1ll<<60);\n\trep(k,0,m) dp[0][0][k]=0;\n\trep(i,0,m-1) {\n//\t\tprintf(""%d\\n"",pos[i+1]-pos[i]);\n\t\tint ps=-1;\n\t\trep(j,0,n) if (pm[j]==i) ps=j;\n\t\trep(j,0,m) rep(k,0,m) if (dp[i][j][k]>=0) {\n//\t\t\tprintf(""%d %d %d %I64d\\n"",i,j,k,dp[i][j][k]);\n\t\t\tif (ps==-1) {\n\t\t\t\tupd(dp[i+1][j][k],dp[i][j][k]+(j>=i+1||k<=i?(pos[i+1]-pos[i]):0));\n\t\t\t} else {\n\t\t\t\tupd(dp[i+1][max(j,pr[ps])][k],dp[i][j][k]+pos[i+1]-pos[i]);\n\t\t\t\tif (k==pl[ps]) {\n\t\t\t\t\trep(l,k,m) upd(dp[i+1][max(j,i)][l],dp[i][j][k]+((j>=i+1||l<=i)?(pos[i+1]-pos[i]):0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=0;\n\trep(i,0,m) upd(ans,dp[m-1][i][m-1]);\n\tprintf(""%I64d\\n"",ans);\n}\n']","['dp', 'sortings']",3000
https://codeforces.com//contest/955/problem/B,B. Not simply beatiful strings,Let s call a string if its letters can be realigned in such a way that they form two consequent groups of equal symbols note that different groups must contain different symbols For example is you can transform it to where the first three letters form a group of s and others a group of s but is not since in each possible consequent partition letters in these two groups coincide You re given a string Check whether it can be split into two non empty subsequences such that the strings formed by these subsequences are Here a subsequence is an arbitrary set of indexes of the string ,"['#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint c[26]={0}; string s; cin>>s;\n\tfor(char ch:s) c[ch-\'a\']++;\n\tint c1=0,cm=0;\n\tfor(int i=0;i<26;i++) if(c[i]>1)cm++; else if(c[i]==1) c1++;\n\tif(c1+cm>4) puts(""No"");\n\telse if(c1+cm==4) puts(""Yes"");\n\telse if(c1+cm==3) {\n\t\tif(cm) puts(""Yes""); else puts(""No"");\n\t}\n\telse if(c1+cm==2) {\n\t\tif(c1) puts(""No""); else puts(""Yes"");\n\t}\n\telse puts(""No"");\n\treturn 0;\n}']",['implementation'],1400
https://codeforces.com//contest/286/problem/E,E. Ladies  Shop,A ladies shop has recently opened in the city of Ultima Thule To get ready for the opening the shop bought bags Each bag is characterised by the total weight of the items you can put there The weird thing is you use these bags to put a set of items with the total weight strictly less than However the weights of the items that will be sold in the shop haven t yet been defined That s what you should determine right now Your task is to find the set of the items weights such that Any bag will be used That is for any there will be such set of items that their total weight will equal We assume that there is the infinite number of items of any weight You can put multiple items of the same weight in one bag For any set of items that have total weight less than or equal to there is a bag into which you can put this set Similarly a set of items can contain multiple items of the same weight Of all sets of the items weights that satisfy points 1 and 2 find the set with the minimum number of weights In other words value should be as small as possible Find and print the required set ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nstruct base{\n\tdouble a,b;\n\tbase(){}\n\tbase(double a,double b):a(a),b(b){}\n\tbase operator+(const base &x)const{\n\t\treturn base(a+x.a,b+x.b);\n\t}\n\tbase operator-(const base &x)const{\n\t\treturn base(a-x.a,b-x.b);\n\t}\n\tbase operator*(const base &x)const{\n\t\treturn base(a*x.a-b*x.b,a*x.b+b*x.a);\n\t}\n\tbase operator/(double d)const{\n\t\treturn base(a/d,b/d);\n\t}\n};\n\nconst int lim=1<<21;\nint src[lim + 100];\nbase ar[lim + 100];\n\nvoid fft (bool invert) {\n\tint n = lim;\n\t\n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (ar[i], ar[j]);\n\t}\n\t\n\tfor (int len=2; len<=n; len<<=1) {\n\t\tdouble ang = 2*PI/len * (invert ? -1 : 1);\n\t\tbase wlen (cos(ang), sin(ang));\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tbase w (1, 0);\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tbase u = ar[i+j],  v = ar[i+j+len/2] * w;\n\t\t\t\tar[i+j] = u + v;\n\t\t\t\tar[i+j+len/2] = u - v;\n\t\t\t\tw = w * wlen;\n\t\t\t}\n\t\t}\n\t}\n\tif (invert)\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tar[i] = ar[i] / n;\n}\n\nvoid square(){\n\tfft(false);\n\tforn(i,lim){\n\t\tar[i] = ar[i] * ar[i];\n\t}\n\tfft(true);\n}\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tint n,m;\n\tcin>>n>>m;\n\tforn(i,n){\n\t\tint a;\n\t\tscanf(""%d"",&a);\n\t\tsrc[a]=1;\n\t\tar[a].a=1;\n\t}\n\tforn(a,m+1){\n\t\tif(!src[a])\n\t\t\tcontinue;\n\t\tfor(int b=a+a;b<=m;b+=a){\n\t\t\tif(!src[b]){\n\t\t\t\tcout<<""NO"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tsquare();\n\tvector<int> res;\n\tforn(a,m+1){\n\t\t//cout<<ar[a].a<<\' \'<<ar[a].b<<endl;\n\t\tbool t=fabs(ar[a].a)>.5;\n\t\tif(t){\n\t\t\tif(!src[a]){\n\t\t\t\tcout<<""NO"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(src[a])\n\t\t\t\tres.pb(a);\n\t\t}\n\t}\n\t\n\tcout<<""YES\\n""<<sz(res)<<\'\\n\';\n\tforv(i,res){\n\t\tprintf(""%d "",res[i]);\n\t}\n\n\treturn 0;\n}\n']","['constructive algorithms', 'fft', 'math']",2800
https://codeforces.com//contest/1794/problem/E,E. Labeling the Tree with Distances,You are given an unweighted tree of n vertices numbered from 1 to n and a list of n 1 integers a 1 a 2 ldots a n 1 A tree is a connected undirected graph without cycles You will use each element of the list to label one vertex No vertex should be labeled twice You can label the only remaining unlabeled vertex with any integer A vertex x is called if it is possible to do this labeling so that for each vertex i its label is the distance between x and i The distance between two vertices s and t on a tree is the minimum number of edges on a path that starts at vertex s and ends at vertex t Find all good vertices ,"['#include <algorithm>\n#include <array>\n#include <iostream>\n#include <random>\n#include <set>\n#include <vector>\n#include <chrono>\nusing namespace std;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == \'-\')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nconst int P = 1e9 + 7;\n\ntypedef array<int, 10> Hash;\n \nHash operator*(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = 1LL * u[i] * v[i] % P;\n  return t;\n}\n\nHash operator+(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + v[i]) % P;\n  return t;\n}\n\nHash operator-(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] - v[i] + P) % P;\n  return t;\n}\n \nHash Base;\n \nHash mult_base(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (1LL * u[i] * Base[i]) % P;\n  return t;\n}\n\nHash add_one(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + 1) % P;\n  return t;\n}\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n \nint gen_base() {\n  static uniform_int_distribution<int> d(258, P - 1);\n  int b = d(rng);\n  return b % 2 == 0 ? b - 1 : b;\n}\n\nconst int N = 2e5;\n\nHash sub[N];\nvector<int> g[N];\n\nvoid dfs1(int p, int i) {\n  for (int j : g[i])\n    if (p != j) {\n      dfs1(i, j);\n      sub[i] = sub[i] + sub[j];\n    }\n  sub[i] = add_one(mult_base(sub[i]));\n}\n\nHash root[N];\n\nvoid dfs2(int p, int i, Hash up) {\n  root[i] = sub[i] + mult_base(up);\n  Hash all = up;\n  for (int j : g[i])\n    if (p != j)\n      all = all + sub[j];\n  for (int j : g[i])\n    if (p != j) {\n      Hash tmp = add_one(mult_base(all - sub[j]));\n      dfs2(i, j, tmp);\n    }\n}\n\nint main() {\n  for (int i = 0; i < 10; i++)\n    Base[i] = gen_base();\n  static int c[N];\n  int n = read();\n  for (int i = 0; i < n - 1; i++)\n    c[read()]++;\n  for (int h = 0; h < n - 1; h++) {\n    int i = read() - 1, j = read() - 1;\n    g[i].push_back(j), g[j].push_back(i);\n  }\n  dfs1(-1, 0);\n  Hash h;\n  fill(h.begin(), h.end(), 0);\n  dfs2(-1, 0, h);\n  Hash rn, pw;\n  for (int i = 0; i < 10; i++)\n    rn[i] = 0, pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    while (c[i]--)\n      rn = rn + pw;\n    pw = mult_base(pw);\n  }\n  set<Hash> ok;\n  for (int i = 0; i < 10; i++)\n    pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    ok.insert(pw + rn);\n    pw = mult_base(pw);\n  }\n  vector<int> ans;\n  for (int i = 0; i < n; i++)\n    if (ok.count(root[i]))\n      ans.push_back(i);\n  printf(""%d\\n"", (int) ans.size());\n  sort(ans.begin(), ans.end());\n  for (int i : ans)\n    printf(""%d "", i + 1);\n  printf(""\\n"");\n  return 0;\n}']","['data structures', 'dp', 'greedy', 'hashing', 'implementation', 'trees']",2400
https://codeforces.com//contest/1848/problem/F,F. Vika and Wiki,Recently Vika was studying her favorite internet resource Wikipedia On the expanses of Wikipedia she read about an interesting mathematical operation bitwise XOR denoted by oplus Vika began to study the properties of this mysterious operation To do this she took an array a consisting of n non negative integers and applied the following operation to all its elements at the same time a i a i oplus a i 1 bmod n Here x bmod y denotes the remainder of dividing x by y The elements of the array are numbered starting from 0 Since it is not enough to perform the above actions once for a complete study Vika repeats them until the array a becomes all zeros Determine how many of the above actions it will take to make all elements of the array a zero If this moment never comes output 1 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int mod = 998244353, N = 1 << 20;\n\nint n, a[N], b[N];\n \nvoid frank() {\n    cin >> n;\n    for (int i = 0; i <= 20; ++i) if (n == (1 << i)) {\n        n = i;\n        break;\n    }\n    for (int i = 0; i < (1 << n); ++i) cin >> a[i];\n    bool ok = 1;\n    for (int i = 0; i < (1 << n); ++i) ok &= a[i] == 0;\n    if (ok) {\n        cout << ""0\\n"";\n        return;\n    }\n    int res = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        bool ok = 1;\n        for (int j = 0; j < (1 << n); ++j) b[j] = a[j] ^ a[(j + (1 << i)) % (1 << n)];\n        for (int j = 0; j < (1 << n); ++j) ok &= b[j] == 0;\n        if (!ok) {\n            res += 1 << i;\n            memcpy(a, b, sizeof b);\n        }\n    }\n    cout << res + 1 << ""\\n"";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while (t--) {\n        frank();\n    }\n}']","['binary search', 'bitmasks', 'combinatorics', 'divide and conquer', 'dp', 'math']",2400
https://codeforces.com//contest/1631/problem/B,B. Fun with Even Subarrays,You are given an array a of n elements You can apply the following operation to it any number of times Select some subarray from a of even size 2k that begins at position l 1 le l le l 2 cdot k 1 le n k ge 1 and for each i between 0 and k 1 inclusive assign the value a l k i to a l i For example if a 2 1 3 4 5 3 then choose l 1 and k 2 applying this operation the array will become a 3 4 3 4 5 3 Find the minimum number of operations possibly zero needed to make all the elements of the array equal ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_n = 2e5 + 5;\n\nint a[max_n];\n\nvoid solve_tc(){\n\tint n; \n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tint operations = 0;\n\twhile (1){\n\t\tint similar_suffix = 0;\n\t\tfor (int i = n; i >= 1; i--){\n\t\t\tif (a[i] != a[n]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsimilar_suffix = n - i + 1;\n\t\t}\n\t\tif (similar_suffix == n){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = max(1, n - 2 * similar_suffix + 1); i <= n; i++){\n\t\t\ta[i] = a[n];\n\t\t}\n\t\toperations++;\n\t}\n\t\n\tcout << operations << ""\\n"";\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint tests;\n\tcin >> tests;\n\twhile (tests--){\n\t\tsolve_tc();\n\t}\n}']","['dp', 'greedy']",1100
https://codeforces.com//contest/1379/problem/F1,F1. Chess Strikes Back  easy version ,Ildar and Ivan are tired of chess but they really like the chessboard so they invented a new game The field is a chessboard 2n times 2m it has 2n rows 2m columns and the cell in row i and column j is colored white if i j is even and is colored black otherwise The game proceeds as follows Ildar marks some of the cells of the chessboard as and asks Ivan to place n times m kings on the remaining cells in such way so that there are no kings attacking each other A king can attack another king if they are located in the adjacent cells sharing an edge or a corner Ildar would like to explore different combinations of cells Initially all cells are marked as available and then he has q queries In each query he marks a cell as unavailable After each query he would like to know whether it is possible to place the kings on the available cells in a desired way Please help him ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n\ntuple<bool, int, int> domerge(tuple<bool, int, int> a, tuple<bool, int, int> b) {\n\treturn {\n\t\tget<0>(a) && get<0>(b) && get<2>(a) > get<1>(b),\n\t\tmax(get<1>(a), get<1>(b)),\n\t\tmin(get<2>(a), get<2>(b))\n\t};\n}\n\n\nclass SegmentTree {\npublic:\n\tvector< tuple<bool, int, int> > a;\n\tint n;\n\n\tSegmentTree(int sz) {\n\t\tn = sz;\n\t\ta.resize(4 * n, tuple<bool, int, int>(true, -1, 1000000000LL));\n\t}\n\n\tvoid set(int v, int vl, int vr, int i, tuple<bool, int, int> x) {\n\t\tif(vr - vl == 1) {\n\t\t\ta[v] = x;\n\t\t} else {\n\t\t\tint vm = (vl + vr) / 2;\n\t\t\tif(i < vm) {\n\t\t\t\tset(v * 2, vl, vm, i, x);\n\t\t\t} else {\n\t\t\t\tset(v * 2 + 1, vm, vr, i, x);\n\t\t\t}\n\t\t\ta[v] = domerge(a[v * 2], a[v * 2 + 1]);\n\t\t}\n\t}\n\n\tvoid set(int i, tuple<bool, int, int> x) {\n\t\tset(1, 0, n, i, x);\n\t}\n\n\ttuple<bool, int, int> get(int v, int vl, int vr, int l, int r) {\n\t\tif(vl == l && vr == r) {\n\t\t\treturn a[v];\n\t\t} else {\n\t\t\tint vm = (vl + vr) / 2;\n\t\t\tif(r <= vm) {\n\t\t\t\treturn get(v * 2, vl, vm, l, r);\n\t\t\t} else if(l >= vm) {\n\t\t\t\treturn get(v * 2 + 1, vm, vr, l, r);\n\t\t\t} else {\n\t\t\t\treturn domerge(get(v * 2, vl, vm, l, vm), get(v * 2 + 1, vm, vr, vm, r));\n\t\t\t}\n\t\t}\n\t}\n\n\ttuple<bool, int, int> get(int l, int r) {\n\t\treturn get(1, 0, n, l, r);\n\t}\n};\n\nsigned main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tSegmentTree st(n);\n\n\tfor(int cnt = 0; cnt < q; cnt++) {\n\t\tint i, j;\n\t\tcin >> i >> j;\n\t\ti--; j--;\n\t\tbool is_one = i % 2 == 0;\n\t\ti /= 2;\n\t\tj /= 2;\n\n\t\tauto line = st.get(i, i + 1);\n\t\tif(is_one) {\n\t\t\tget<2>(line) = min(get<2>(line), j);\n\t\t} else {\n\t\t\tget<1>(line) = max(get<1>(line), j);\n\t\t}\n\t\tget<0>(line) = get<1>(line) < get<2>(line);\n\t\tst.set(i, line);\n\n\t\tif(get<0>(st.get(0, n))) {\n\t\t\tcout << ""YES"" << ""\\n"";\n\t\t} else {\n\t\t\tcout << ""NO"" << ""\\n"";\n\t\t}\n\t}\n\n\treturn 0;\n}']","['binary search', 'data structures']",2700
https://codeforces.com//contest/275/problem/A,A. Lights Out,Lenny is playing a game on a grid of lights In the beginning of the game all lights are switched on Pressing any of the lights will toggle it and all side adjacent lights The goal of the game is to switch all the lights off We consider the toggling as follows if the light was switched on then it will be switched off if it was switched off then it will be switched on Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times Given the number of times each light is pressed you have to print the current state of each light ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <functional>\n#include <string>\n\nusing namespace std;\nint a[10][10];\nint main()\n{\n    memset(a,0,sizeof(a));\n    for(int i=1;i<=3;i++)\n     for(int j=1;j<=3;j++)\n      scanf(""%d"",&a[i][j]);\n    for(int i=1;i<=3;i++)\n    {\n        for(int j=1;j<=3;j++)\n        {\n            int cnt=a[i][j]+a[i-1][j]+a[i+1][j]+a[i][j-1]+a[i][j+1];\n            if(cnt%2==1)printf(""0"");\n            else printf(""1"");\n        }\n        printf(""\\n"");\n    }\n    return 0;\n}\n']",['implementation'],900
https://codeforces.com//contest/1485/problem/E,E. Move and Swap,You are given n 1 integers a 2 dots a n and a tree with n vertices rooted at vertex 1 The leaves are all at the same distance d from the root Recall that a tree is a connected undirected graph without cycles The distance between two vertices is the number of edges on the simple path between them All non root vertices with degree 1 are leaves If vertices s and f are connected by an edge and the distance of f from the root is greater than the distance of s from the root then f is called a child of s Initially there are a red coin and a blue coin on the vertex 1 Let r be the vertex where the red coin is and let b be the vertex where the blue coin is You should make d moves A move consists of three steps Move the red coin to any child of r Move the blue coin to any vertex b such that dist 1 b dist 1 b 1 Here dist x y indicates the length of the simple path between x and y Note that b and b are not necessarily connected by an edge You can optionally swap the two coins or skip this step Note that r and b can be equal at any time and there is no number written on the root After each move you gain a r a b points What s the maximum number of points you can gain after d moves ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint T,n,a[200005],d[200005],mxd,l[200005],r[200005];\nll f[200005];\nvector<int> v[200005],D[200005];\nvoid dfs(int x,int y){\n\tD[d[x]=d[y]+1].pb(x);\n\tif(d[x]>mxd)mxd=d[x];\n\tl[d[x]]=min(l[d[x]],a[x]);\n\tr[d[x]]=max(r[d[x]],a[x]);\n\tfor(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;++i)v[i].clear(),D[i].clear(),l[i]=orz,r[i]=-orz;\n\t\tmxd=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tv[x].pb(i),v[i].pb(x);\n\t\t}\n\t\tfor(int i=2;i<=n;++i)scanf(""%d"",a+i);\n\t\tdfs(1,0);\n\t\tfor(int i=0;i<D[mxd].size();++i){\n\t\t\tint x=D[mxd][i];\n\t\t\tf[x]=max(r[mxd]-a[x],a[x]-l[mxd]);\n\t\t}\n\t\tfor(int k=mxd-1;k;--k){\n\t\t\tll L=-orz*1ll*orz,R=-orz*1ll*orz;\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=-orz*1ll*orz;\n\t\t\t\tfor(int j=0;j<v[x].size();++j){\n\t\t\t\t\tint y=v[x][j];\n\t\t\t\t\tif(d[y]<d[x]) continue;\n\t\t\t\t\tf[x]=max(f[x],f[y]);\n\t\t\t\t}\n\t\t\t\tL=max(L,f[x]-a[x]);\n\t\t\t\tR=max(R,f[x]+a[x]);\n\t\t\t\tf[x]+=max(r[k]-a[x],a[x]-l[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=max(f[x],max(L+a[x],R-a[x]));\n\t\t\t}\n\t\t}\n\t\tprintf(""%I64d\\n"",f[1]);\n\t}\n    return 0;\n}\n']","['dfs and similar', 'dp', 'greedy', 'trees']",2500
https://codeforces.com//contest/194/problem/C,C. Cutting Figure,You ve gotten an sheet of squared paper Some of its squares are painted Let s mark the set of all painted squares as Set is connected Your task is to find the minimum number of squares that we can delete from set to make it not connected A set of painted squares is called if for every two squares and from this set there is a sequence of squares from the set beginning in and ending in such that in this sequence any square except for the last one shares a common side with the square that follows next in the sequence An empty set and a set consisting of exactly one square are connected by definition ,"[""#include<cassert>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint dr[] = {-1, 1, 0, 0};\nint dc[] = {0, 0, 1, -1};\n\nint main() {\n  int R, C;\n  cin >> R >> C;\n  vector<string> paper(R);\n  for(int r = 0; r < R; ++r)\n    cin >> paper[r];\n  int mini = 5;\n  int size_paper = 0;\n  \n  for(int r = 0; r < R; ++r)\n    for(int c = 0; c < C; ++c)\n      {\n        if(paper[r][c] == '.')\n          continue;\n        ++size_paper;\n        \n        int num_neighbours = 0;\n        for(int i = 0; i < 4; ++i)\n          {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if(nr >= R || nr < 0 || nc >= C || nc < 0)\n              continue;\n            num_neighbours += paper[nr][nc] == '#';\n          }\n        mini = min(mini, num_neighbours);\n      }\n  if(size_paper <= 2)\n    {\n      cout << -1 << endl;\n      return 0;\n    }\n\n  if(mini == 1)\n    {\n      cout << 1 << endl;\n      return 0;\n    }\n\n  for(int del_r = 0; del_r < R; ++del_r)\n    for(int del_c = 0; del_c < C; ++del_c)\n      {\n        if(paper[del_r][del_c] == '.')\n          continue;\n        \n        paper[del_r][del_c] = '.';\n\n        queue<pii> q;\n        vector<vector<bool>> visited(R, vector<bool>(C));\n        \n        int i = 0, nr, nc;\n\n        for(; i < 4; ++i)\n          {\n            nr = del_r + dr[i];\n            nc = del_c + dc[i];\n            if(nr >= R || nr < 0 || nc >= C || nc < 0)\n              continue;\n            if(paper[nr][nc] == '.')\n              continue;\n            break;\n          }\n        assert(i < 4);\n\n        int v = 1;\n        q.push(pii(nr, nc));\n        visited[nr][nc] = true;\n        while(!q.empty()) {\n          pii cur = q.front();\n          q.pop();\n          ++v;\n          int r = cur.first;\n          int c = cur.second; \n\n          for(int i = 0; i < 4; ++i)\n            {\n              nr = r + dr[i];\n              nc = c + dc[i];\n            \n              if(nr >= R || nr < 0 || nc >= C || nc < 0)\n                continue;\n              if(paper[nr][nc] == '.')\n                continue;\n              if(visited[nr][nc])\n                continue;\n\n              visited[nr][nc] = true;\n              q.push(pii(nr, nc));\n            }\n        }\n\n        if(v < size_paper - 1)\n          {\n            cout << 1 << endl;\n            return 0;\n          }\n\n        paper[del_r][del_c] = '#';\n      }\n\n  cout << 2 << endl;\n}\n""]","['constructive algorithms', 'dfs and similar', 'graphs', 'implementation', 'matrices', 'strings']",1700
https://codeforces.com//contest/266/problem/C,C. Below the Diagonal,You are given a square matrix consisting of rows and columns We assume that the rows are numbered from to from top to bottom and the columns are numbered from to from left to right Some cells cells in total of the the matrix are filled with ones the remaining cells are filled with zeros We can apply the following operations to the matrix Swap th and th rows of the matrix Swap th and th columns of the matrix You are asked to transform the matrix into a special form using these operations In that special form all the ones must be in the cells that lie below the main diagonal Cell of the matrix which is located on the intersection of the th row and of the th column lies below the main diagonal if ,"[""#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\nusing namespace std;\n\ntypedef long long ll;\nconst int BIGINT = 0x0FFFFFFF;\nconst ll BIGLL = 0x0FFFFFFFFFFFFFFFll;\nconst int MAXN = 1005;\n\n\nint n,m,x,y;\nint p[MAXN][2];\nbool ct[MAXN];\nvector< pair< int , pair<int,int> > > ans;\n\nvoid swap_and_commit(int t,int a,int b)\n{\n    if(t==1)\n    {\n        for(int i=0;i<m;i++)\n        {\n            if(p[i][0]==a) p[i][0]=b;\n            else if(p[i][0]==b) p[i][0]=a;\n        }\n        ans.push_back(make_pair(1,make_pair(a,b)));\n    }\n    else\n    {\n        for(int i=0;i<m;i++)\n        {\n            if(p[i][1]==a) p[i][1]=b;\n            else if(p[i][1]==b) p[i][1]=a;\n        }\n        ans.push_back(make_pair(2,make_pair(a,b)));\n    }\n}\n\nvoid solve(int l)\n{\n    if(l==n) return;\n    for(int i=1;i<=n;i++) ct[i]=false;\n    for(int i=0;i<m;i++)\n        if( p[i][1]>=l)\n            ct[p[i][0]]=true; \n    int freect=-1;\n    for(int i=1;i<=n;i++) if(!ct[i]) freect=i;\n    if(freect!=-1&&freect!=l)\n        swap_and_commit(1,l,freect);\n    for(int i=0;i<m;i++) \n        if(p[i][1]>l)\n        {\n            swap_and_commit(2,l,p[i][1]);\n            break;\n        }\n    solve(l+1);\n}\n\nint main()\n{\n    cin>>n; m=n-1;\n    for(int i=0;i<m;i++)\n        cin>>p[i][0]>>p[i][1];\n\n    solve(1);\n\n    cout << ans.size() << '\\n';\n    for(size_t i=0;i<ans.size();i++)\n        cout << ans[i].first << ' ' << ans[i].second.first << ' ' << ans[i].second.second << '\\n';\n    \n    return 0;\n}""]","['constructive algorithms', 'greedy', 'math']",2100
https://codeforces.com//contest/1371/problem/A,A. Magical Sticks,A penguin Rocher has n sticks He has exactly one stick with length i for all 1 le i le n He can connect some sticks If he connects two sticks that have lengths a and b he gets one stick with length a b Two sticks that were used in the operation disappear from his set and the new connected stick appears in his set and can be used for the next connections He wants to create the maximum number of sticks that have the same length It is not necessary to make all sticks have the same length some sticks can have the other length How many sticks with the equal length he can create ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint T, n;\nint main()\n{\n\tscanf(""%d"", &T);\n\twhile (T--)\n\t{\n\t\tscanf(""%d"", &n);\n\t\tprintf(""%d\\n"", (n + 1) / 2);\n\t}\n\treturn 0;\n}']",['math'],800
https://codeforces.com//contest/1914/problem/B,B. Preparing for the Contest,Monocarp is practicing for a big contest He plans to solve n problems to make sure he s prepared Each of these problems has a difficulty level the first problem has a difficulty level of 1 the second problem has a difficulty level of 2 and so on until the last n th problem which has a difficulty level of n Monocarp will choose some order in which he is going to solve all n problems Whenever he solves a problem which is more difficult than the last problem he solved he gets excited because he feels like he s progressing He doesn t get excited when he solves the first problem in his chosen order For example if Monocarp solves the problems in the order 3 underline 5 4 1 underline 6 2 he gets excited twice the corresponding problems are underlined Monocarp wants to get excited exactly k times during his practicing session Help him to choose the order in which he has to solve the problems ,"['//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=1e6+5,mod=1e9+7;\nll n,k,a[N];\nvoid prep(){\n}\nvoid solve()\n{\n    cin>>n>>k;\n    rep(i,n-k,n) cout<<i<<"" "";\n    reb(i,n-k-1,1) cout<<i<<"" "";\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']","['constructive algorithms', 'math']",800
https://codeforces.com//contest/1743/problem/D,D. Problem with Random Tests,You are given a string s consisting of n characters Each character of s is either or A substring of s is a contiguous subsequence of its characters You have to choose two substrings of s possibly intersecting possibly the same possibly non intersecting just any two substrings After choosing them you calculate the value of the chosen pair of substrings as follows let s 1 be the first substring s 2 be the second chosen substring and f s i be the integer such that s i is its binary representation for example if s i is f s i 26 the value is the of f s 1 and f s 2 Calculate the maximum possible value you can get and print it ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::string s;\n    std::cin >> s;\n    \n    if (s.find(\'1\') == std::string::npos) {\n        std::cout << 0 << ""\\n"";\n        return 0;\n    }\n    \n    int a = s.find(\'1\');\n    \n    if (s.substr(a).find(\'0\') == std::string::npos) {\n        std::cout << s.substr(a) << ""\\n"";\n        return 0;\n    }\n    \n    int b = a + s.substr(a).find(\'0\');\n    \n    auto ans = s;\n    \n    for (int i = 0; i <= b - a; i++) {\n        auto res = s;\n        for (int j = 0; j + i < n; j++) {\n            res[j + i] |= s[j];\n        }\n        ans = std::max(ans, res);\n    }\n    ans = ans.substr(ans.find(\'1\'));\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['brute force', 'dp', 'greedy', 'probabilities']",1700
https://codeforces.com//contest/1718/problem/C,C. Tonya and Burenka-179,Tonya was given an array of a of length n written on a postcard for his birthday For some reason the postcard turned out to be a so the index of the element located strictly to the right of the n th is 1 Tonya wanted to study it better so he bought a robot Burenka 179 A program for Burenka is a pair of numbers s k where 1 leq s leq n 1 leq k leq n 1 Note that k be equal to n Initially Tonya puts the robot in the position of the array s After that Burenka makes n steps through the array If at the beginning of a step Burenka stands in the position i then the following happens The number a i is added to the of the program Burenka moves k positions to the right i i k is executed if i becomes greater than n then i i n Help Tonya find the maximum possible of a program for Burenka if the initial usefulness of any program is 0 Also Tony s friend Ilyusha asks him to change the array q times Each time he wants to assign a p x for a given index p and a value x You need to find the maximum possible of the program after each of these changes ,"['/**\n *    author:  tourist\n *    created: 16.08.2022 17:54:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> ds;\n    int old = n;\n    for (int i = 2; i <= n; i++) {\n      if (n % i == 0) {\n        ds.push_back(old / i);\n        while (n % i == 0) {\n          n /= i;\n        }\n      }\n    }\n    n = old;\n    int sz = (int) ds.size();\n    vector<vector<long long>> b(sz);\n    for (int i = 0; i < sz; i++) {\n      b[i].resize(ds[i]);\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < sz; j++) {\n        b[j][i % ds[j]] += a[i];\n      }\n    }\n    multiset<long long> s;\n    for (int i = 0; i < sz; i++) {\n      for (int j = 0; j < ds[i]; j++) {\n        s.insert(b[i][j] * ds[i]);\n      }\n    }\n    cout << (*s.rbegin()) << \'\\n\';\n    while (q--) {\n      int pos, val;\n      cin >> pos >> val;\n      --pos;\n      int delta = val - a[pos];\n      a[pos] = val;\n      for (int i = 0; i < sz; i++) {\n        int j = pos % ds[i];\n        s.erase(s.find(b[i][j] * ds[i]));\n        b[i][j] += delta;\n        s.insert(b[i][j] * ds[i]);\n      }\n      cout << (*s.rbegin()) << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","['data structures', 'greedy', 'math', 'number theory']",2400
https://codeforces.com//contest/1005/problem/B,B. Delete from the Left,You are given two strings s and t In a single move you can choose any of two strings and delete the first that is the leftmost character After a move the length of the string decreases by 1 You can t choose a string if it is empty For example by applying a move to the string the result is the string by applying a move to the string the result is an empty string You are required to make two given strings equal using the fewest number of moves It is possible that in the end both strings will be equal to the empty string and so are equal to each other In this case the answer is obviously the sum of the lengths of the initial strings Write a program that finds the minimum number of moves to make two given strings s and t equal ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n    vector<int> A;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    string s1, s2;\n    cin >> s1 >> s2;\n    int i;\n    for (i = 0; i < min(s1.size(), s2.size());) {\n        if (s1[s1.size()-1-i] != s2[s2.size()-1-i]) {\n            break;\n        }\n        i++;\n    }\n\n    cout << s1.size()+s2.size()-2*i;\n\n\n}\n\n\n\n\n\n\n\n\n\n']","['brute force', 'implementation', 'strings']",900
https://codeforces.com//contest/1473/problem/G,G. Tiles,Consider a road consisting of several rows Each row is divided into several rectangular tiles and all tiles in the same row are equal The first row contains exactly one rectangular tile Look at the picture below which shows how the tiles are arranged The road is constructed as follows the first row consists of 1 tile then a 1 rows follow each of these rows contains 1 tile greater than the previous row then b 1 rows follow each of these rows contains 1 tile less than the previous row then a 2 rows follow each of these rows contains 1 tile greater than the previous row then b 2 rows follow each of these rows contains 1 tile less than the previous row then a n rows follow each of these rows contains 1 tile greater than the previous row then b n rows follow each of these rows contains 1 tile less than the previous row An example of the road with n 2 a 1 4 b 1 2 a 2 2 b 2 3 Rows are arranged from left to right You start from the only tile in the first row and want to reach the last row any tile of it From your current tile you can move to any tile in the next row which touches your current tile Calculate the number of different paths from the first row to the last row Since it can be large print it modulo 998244353 ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nconstexpr int P = 998244353;\nstd::vector<int> rev, roots{0, 1};\nint power(int a, int b) {\n    int res = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % P)\n        if (b & 1)\n            res = 1ll * res * a % P;\n    return res;\n}\nvoid dft(std::vector<int> &a) {\n    int n = a.size();\n    if (int(rev.size()) != n) {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; ++i)\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n    }\n    for (int i = 0; i < n; ++i)\n        if (rev[i] < i)\n            std::swap(a[i], a[rev[i]]);\n    if (int(roots.size()) < n) {\n        int k = __builtin_ctz(roots.size());\n        roots.resize(n);\n        while ((1 << k) < n) {\n            int e = power(3, (P - 1) >> (k + 1));\n            for (int i = 1 << (k - 1); i < (1 << k); ++i) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = 1ll * roots[i] * e % P;\n            }\n            ++k;\n        }\n    }\n    for (int k = 1; k < n; k *= 2) {\n        for (int i = 0; i < n; i += 2 * k) {\n            for (int j = 0; j < k; ++j) {\n                int u = a[i + j];\n                int v = 1ll * a[i + j + k] * roots[k + j] % P;\n                int x = u + v;\n                if (x >= P)\n                    x -= P;\n                a[i + j] = x;\n                x = u - v;\n                if (x < 0)\n                    x += P;\n                a[i + j + k] = x;\n            }\n        }\n    }\n}\nvoid idft(std::vector<int> &a) {\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    int inv = power(n, P - 2);\n    for (int i = 0; i < n; ++i)\n        a[i] = 1ll * a[i] * inv % P;\n}\nstruct Poly {\n    std::vector<int> a;\n    Poly() {}\n    Poly(int a0) {\n        if (a0)\n            a = {a0};\n    }\n    Poly(const std::vector<int> &a1) : a(a1) {\n        while (!a.empty() && !a.back())\n            a.pop_back();\n    }\n    int size() const {\n        return a.size();\n    }\n    int operator[](int idx) const {\n        if (idx < 0 || idx >= size())\n            return 0;\n        return a[idx];\n    }\n    Poly mulxk(int k) const {\n        auto b = a;\n        b.insert(b.begin(), k, 0);\n        return Poly(b);\n    }\n    Poly modxk(int k) const {\n        k = std::min(k, size());\n        return Poly(std::vector<int>(a.begin(), a.begin() + k));\n    }\n    Poly divxk(int k) const {\n        if (size() <= k)\n            return Poly();\n        return Poly(std::vector<int>(a.begin() + k, a.end()));\n    }\n    friend Poly operator+(const Poly a, const Poly &b) {\n        std::vector<int> res(std::max(a.size(), b.size()));\n        for (int i = 0; i < int(res.size()); ++i) {\n            res[i] = a[i] + b[i];\n            if (res[i] >= P)\n                res[i] -= P;\n        }\n        return Poly(res);\n    }\n    friend Poly operator-(const Poly a, const Poly &b) {\n        std::vector<int> res(std::max(a.size(), b.size()));\n        for (int i = 0; i < int(res.size()); ++i) {\n            res[i] = a[i] - b[i];\n            if (res[i] < 0)\n                res[i] += P;\n        }\n        return Poly(res);\n    }\n    friend Poly operator*(Poly a, Poly b) {\n        int sz = 1, tot = a.size() + b.size() - 1;\n        while (sz < tot)\n            sz *= 2;\n        a.a.resize(sz);\n        b.a.resize(sz);\n        dft(a.a);\n        dft(b.a);\n        for (int i = 0; i < sz; ++i)\n            a.a[i] = 1ll * a[i] * b[i] % P;\n        idft(a.a);\n        return Poly(a.a);\n    }\n    Poly &operator+=(Poly b) {\n        return (*this) = (*this) + b;\n    }\n    Poly &operator-=(Poly b) {\n        return (*this) = (*this) - b;\n    }\n    Poly &operator*=(Poly b) {\n        return (*this) = (*this) * b;\n    }\n    Poly deriv() const {\n        if (a.empty())\n            return Poly();\n        std::vector<int> res(size() - 1);\n        for (int i = 0; i < size() - 1; ++i)\n            res[i] = 1ll * (i + 1) * a[i + 1] % P;\n        return Poly(res);\n    }\n    Poly integr() const {\n        if (a.empty())\n            return Poly();\n        std::vector<int> res(size() + 1);\n        for (int i = 0; i < size(); ++i)\n            res[i + 1] = 1ll * a[i] * power(i + 1, P - 2) % P;\n        return Poly(res);\n    }\n    Poly inv(int m) const {\n        Poly x(power(a[0], P - 2));\n        int k = 1;\n        while (k < m) {\n            k *= 2;\n            x = (x * (2 - modxk(k) * x)).modxk(k);\n        }\n        return x.modxk(m);\n    }\n    Poly log(int m) const {\n        return (deriv() * inv(m)).integr().modxk(m);\n    }\n    Poly exp(int m) const {\n        Poly x(1);\n        int k = 1;\n        while (k < m) {\n            k *= 2;\n            x = (x * (1 - x.log(k) + modxk(k))).modxk(k);\n        }\n        return x.modxk(m);\n    }\n    Poly sqrt(int m) const {\n        Poly x(1);\n        int k = 1;\n        while (k < m) {\n            k *= 2;\n            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2);\n        }\n        return x.modxk(m);\n    }\n    Poly mulT(Poly b) const {\n        if (b.size() == 0)\n            return Poly();\n        int n = b.size();\n        std::reverse(b.a.begin(), b.a.end());\n        return ((*this) * b).divxk(n - 1);\n    }\n    std::vector<int> eval(std::vector<int> x) const {\n        if (size() == 0)\n            return std::vector<int>(x.size(), 0);\n        const int n = std::max(int(x.size()), size());\n        std::vector<Poly> q(4 * n);\n        std::vector<int> ans(x.size());\n        x.resize(n);\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                q[p] = std::vector<int>{1, (P - x[l]) % P};\n            } else {\n                int m = (l + r) / 2;\n                build(2 * p, l, m);\n                build(2 * p + 1, m, r);\n                q[p] = q[2 * p] * q[2 * p + 1];\n            }\n        };\n        build(1, 0, n);\n        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {\n            if (r - l == 1) {\n                if (l < int(ans.size()))\n                    ans[l] = num[0];\n            } else {\n                int m = (l + r) / 2;\n                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));\n                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));\n            }\n        };\n        work(1, 0, n, mulT(q[1].inv(n)));\n        return ans;\n    }\n};\nconstexpr int N = 2e5;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n;\n    std::cin >> n;\n    std::vector<int> dp{1};\n    int tot = 0;\n    std::vector<int> fac(N + 1), invFac(N + 1);\n    fac[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fac[i] = i64(fac[i - 1]) * i % P;\n    }\n    invFac[N] = power(fac[N], P - 2);\n    for (int i = N; i > 0; i--) {\n        invFac[i - 1] = i64(invFac[i]) * i % P;\n    }\n    auto binom = [&](int n, int m) -> int {\n        if (m < 0 || n < m) {\n            return 0;\n        }\n        return i64(fac[n]) * invFac[m] % P * invFac[n - m] % P;\n    };\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        int ntot = tot + a - b;\n        std::vector<int> g(tot + ntot + 1);\n        for (int j = -tot; j <= ntot; j++) {\n            g[j + tot] = binom(a + b, b + j);\n        }\n        auto f = Poly(dp) * Poly(g);\n        dp.resize(ntot + 1);\n        for (int j = 0; j <= ntot; j++) {\n            dp[j] = f[j + tot];\n        }\n        tot = ntot;\n    }\n    int ans = 0;\n    for (auto x : dp) {\n        ans = (ans + x) % P;\n    }\n    std::cout << ans << ""\\n"";\n    return 0;\n}']","['combinatorics', 'dp', 'fft', 'math']",2800
https://codeforces.com//contest/976/problem/B,B. Lara Croft and the New Game,You might have heard about the next game in Lara Croft series coming out this year You also might have watched its trailer Though you definitely missed the main idea about its plot so let me lift the veil of secrecy Lara is going to explore yet another dangerous dungeon Game designers decided to use good old 2D environment The dungeon can be represented as a rectangle matrix of rows and columns Cell is the cell in the th row in the th column Lara can move between the neighbouring by side cells in all four directions Moreover she has even chosen the path for herself to avoid all the traps She enters the dungeon in cell that is top left corner of the matrix Then she goes down all the way to cell the bottom left corner Then she starts moving in the snake fashion all the way to the right one cell up then to the left to the cell in nd column one cell up She moves until she runs out of non visited cells and given are such that she always end up in cell Lara has already moved to a neighbouring cell times Can you determine her current position ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint main() {\n\tll N, M, K;\n\tscanf(""%lld %lld %lld"", &N, &M, &K);\n\tif (K < N) return !printf(""%lld 1\\n"", K + 1);\n\n\tK -= N;\n\n\tll a1 = N - (K / (M - 1));\n\tll a2 = 0;\n\tif (a1 % 2 == N % 2) a2 = 2 + K % (M - 1);\n\telse a2 = M - K % (M - 1);\n\treturn !printf(""%lld %lld\\n"", a1, a2);\n}']","['implementation', 'math']",1300
https://codeforces.com//contest/866/problem/D,D. Buy Low Sell High,You can perfectly predict the price of a certain stock for the next days You would like to profit on this knowledge but only want to transact one share of stock per day That is each day you will either buy one share sell one share or do nothing Initially you own zero shares and you cannot sell shares when you don t own any At the end of the days you would like to again own zero shares but want to have as much money as possible ,"['/**\n *    author:  tourist\n *    created: 05.10.2017 21:52:46       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  multiset<int> s;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(""%d"", &x);\n    s.insert(x);\n    if (*s.begin() < x) {\n      ans += x - *s.begin();\n      s.erase(s.begin());\n      s.insert(x);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n']","['data structures', 'greedy', 'two pointers']",2400
https://codeforces.com//contest/355/problem/A,A. Vasya and Digital Root,Vasya has recently found out what a digital root of a number is and he decided to share his knowledge with you Let s assume that is the sum of digits of number for example Then the digital root of number equals to if if For example Vasya is afraid of large numbers so the numbers he works with are at most For all such numbers he has proved that Now Vasya wants to quickly find numbers with the given digital root The problem is he hasn t learned how to do that and he asked you to help him You task is given numbers and find the number consisting of exactly digits the leading zeroes are not allowed with digital root equal to or else state that such number does not exist ,"['#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tint k,d;\n\tcin >> k >> d;\n\tif (k>1 && d==0) {cout << ""No solution""; return 0;}\n\tcout << d;\n\tfor(int i=0; i<k-1; i++) cout << ""0"";\n\tcin >> k;\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/1638/problem/C,C. Inversion Graph,You are given a permutation p 1 p 2 dots p n Then an undirected graph is constructed in the following way add an edge between vertices i j such that i j if and only if p i p j Your task is to count the number of connected components in this graph Two vertices u and v belong to the same connected component if and only if there is at least one path along edges connecting u and v A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"[""// Author: wlzhouzhuan\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\nconst int N=1000005;\n\nint p[N],pre[N],suf[N];\nvoid solve(){\n\tint n=read();\n\trep(i,1,n){\n\t\tp[i]=read();\n\t\tpre[i]=max(pre[i-1],p[i]);\n\t}\n\tsuf[n+1]=1e9;\n\tper(i,n,1){\n\t\tsuf[i]=min(suf[i+1],p[i]);\n\t}\n\tint ans=1;\n\trep(i,1,n-1){\n\t\tif(pre[i]<suf[i+1]){\n\t\t\tans++;\n\t\t}\n\t}\n\tprint(ans,'\\n');\n}\n\nint main(){\n\tint T=read();\n\twhile(T--)solve();\n\treturn 0;\n}""]","['data structures', 'dsu', 'graphs', 'math']",1300
https://codeforces.com//contest/1015/problem/B,B. Obtaining the String,You are given two strings s and t Both strings have length n and consist of lowercase Latin letters The characters in the strings are numbered from 1 to n You can successively perform the following move any number of times possibly zero swap any two adjacent neighboring characters of s i e for any i 1 2 dots n 1 you can swap s i and s i 1 You can t apply a move to the string t The moves are applied to the string s one after another Your task is to obtain the string t from the string s Find any way to do it with at most 10 4 such moves ,"['#include<bits/stdc++.h>\n//#define ll int\n#define ll long long\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define yn idehfushefuwheuf\n#define y1 issdehfushefuwheuf\n#define endL ""\\n""\n#define all(a) a.begin(),a.end()\n#define p_b push_back\n#define pll pair<ll,ll>\n#define vout(a); cout<<a;return 0;\n#define sqr(a) ((a)*(a))\n\n\nconst ll gig = 1e18;\nconst ll gg = 25*1e6;\n\n\nusing namespace std;\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n//    freopen(""1.out"", ""r"", stdin);\n//    freopen(""1.out"", ""w"", stdout);\n\n    ll n;\n    string s, s1;\n    vector<ll> ot;\n    cin >> n;\n    cin >> s >> s1;\n\n    for (int i = 0; i < s.size(); i++) {\n        int j;\n        for (j = i; j < s.size(); j++) if (s[j] == s1[i]) break;\n        ll o = j;\n        if (j == s.size()) {\n            cout << -1;\n            return 0;\n        }\n        for (int j = o - 1;  i <= j; j--) {\n            ot.p_b(j);\n            swap(s[j], s[j + 1]);\n        }\n    }\n    cout << ot.size() << endL;\n    for (int i = 0; i < ot.size(); i++) cout << ot[i] + 1 << "" "";\n\n\n}\n']",['implementation'],1200
https://codeforces.com//contest/1850/problem/A,A. To My Critics,Suneet has three digits a b and c Since math isn t his strongest point he asks you to determine if you can choose any two digits to make a sum greater or equal to 10 Output if there is such a pair and otherwise ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tint a, b, c;  cin >> a >> b >> c;\n\tif (a + b + c - min({a, b, c}) >= 10)  cout << ""YES\\n"";\n\telse  cout << ""NO\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","['implementation', 'sortings']",800
https://codeforces.com//contest/1301/problem/D,D. Time to Run,Bashar was practicing for the national programming contest Because of sitting too much in front of the computer without doing physical movements and eating a lot Bashar became much fatter Bashar is going to quit programming after the national contest and he is going to become an actor just like his father so he should lose weight In order to lose weight Bashar is going to run for k kilometers Bashar is going to run in a place that looks like a grid of n rows and m columns In this grid there are two one way roads of one kilometer length between each pair of adjacent by side cells one road is going from the first cell to the second one and the other road is going from the second cell to the first one So there are exactly 4 n m 2n 2m roads Let s take for example n 3 and m 4 In this case there are 34 roads It is the picture of this case arrows describe roads Bashar wants to run by these rules He starts at the top left cell in the grid In one move Bashar may go up the symbol down the symbol left the symbol or right the symbol More formally if he stands in the cell in the row i and in the column j i e in the cell i j he will move to in the case to the cell i 1 j in the case to the cell i 1 j in the case to the cell i j 1 in the case to the cell i j 1 He wants to run exactly k kilometers so he wants to make exactly k moves Bashar can finish in any cell of the grid He can t go out of the grid so at any moment of the time he should be on some cell Bashar doesn t want to get bored while running so he must visit the same road twice Bashar asks you if it is possible to run by such rules If it is possible you should tell him how should he run You should give him a steps to do and since Bashar can t remember too many steps a should not exceed 3000 In every step you should give him an integer f and a string of moves s of length at most 4 which means that he should repeat the moves in the string s for f times He will perform the steps in the order you print them For example if the steps are 2 3 then the moves he is going to move are Can you help him and give him a correct sequence of moves such that the total distance he will run is equal to k kilometers or say that it is impossible ,"['#include <bits/stdc++.h>\n\nint n, m, k;\nstd::vector<std::pair<int, char>> vec, ans;\n\ninline void insert(int x, char c) {\n    if (x > 0) { vec.push_back({x, c}); }\n}\ninline void insertt(int x, char c) {\n    if (x > 0) { ans.push_back({x, c}); }\n}\n\nbool solve() {\n    for (auto i : vec) {\n        insertt(std::min(i.first, k), i.second);\n        k -= std::min(i.first, k);\n    }\n    return k <= 0;\n}\n\nint main() {\n    scanf(""%d%d%d"", &n, &m, &k);\n    for (int i = 1; i < n; i++) {\n        insert(m - 1, \'R\');\n        insert(m - 1, \'L\');\n        insert(1, \'D\');\n    }\n    insert(m - 1, \'R\');\n    for (int i = 1; i < m; i++) {\n        insert(n - 1, \'U\');\n        insert(n - 1, \'D\');\n        insert(1, \'L\');\n    }\n    insert(n - 1, \'U\');\n    if (!solve()) {\n        printf(""NO\\n"");\n    } else {\n        printf(""YES\\n"");\n        printf(""%d\\n"", ans.size());\n        for (auto i : ans) {\n            printf(""%d %c\\n"", i.first, i.second);\n        }\n    }\n    return 0;\n}']","['constructive algorithms', 'graphs', 'implementation']",2000
https://codeforces.com//contest/438/problem/C,C. The Child and Polygon,This time our child has a simple polygon He has to find the number of ways to split the polygon into non degenerate triangles each way must satisfy the following requirements each vertex of each triangle is one of the polygon vertex each side of the polygon must be the side of exactly one triangle the area of intersection of every two triangles equals to zero and the sum of all areas of triangles equals to the area of the polygon each triangle must be completely inside the polygon The picture below depicts an example of a correct splitting Please help the child Calculate the described number of ways modulo for him ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef linux\n#define LLD ""%lld""\n#else\n#define LLD ""%I64d""\n#endif\n\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double INF = inf;\nconst double EPS = eps;\n\nconst int mod = inf+7;\n\ninline void madd (int& a, int b)\n{\n  a+=b;\n  if (a>=mod)\n    a-=mod;\n}\n\nint mul (int a, int b)\n{\n  return (a*1ll*b)%mod;\n}\n\npii operator - (const pii& a, const pii& b)\n{\n  return mp(a.first-b.first,a.second-b.second);\n}\n                         \nll operator ^ (const pii& a, const pii& b)\n{\n  return a.first*1ll*b.second-a.second*1ll*b.first;\n}\n\nint n;\n//bool can[210][210];\nint D[210][210];\npii P[410];\nll S[210][210][210];\n\ninline bool check (int a, int b, int c)\n{\n  //cerr<<a<<"" ""<<b<<"" ""<<c<<endl;\n  int i;\n  ll s=S[a][b][c];\n  for (i=0; i<a; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=a+1; i<b; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=b+1; i<c; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=c+1; i<n; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  //cerr<<a<<"" ""<<b<<"" ""<<c<<endl;\n  return 1;\n}\n\nint main()\n{\n  int i, j, len, k;//l, r;\n  #ifdef LOCAL\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n  scanf(""%d"", &n);\n  for (i=0; i<n; i++)\n    scanf(""%d%d"", &P[i].first, &P[i].second);\n  for (i=n-1; i>=0; i--)\n    P[i]=P[i]-P[0];\n  ll s=0;\n  for (i=1; i<n-1; i++)\n    s+=(P[i]^P[i+1]);\n  if (s<0)\n    reverse(P+1,P+n);\n  for (i=0; i<n; i++)\n    P[i+n]=P[i];\n  for (i=0; i<n; i++)\n    for (j=0; j<n; j++)\n      for (k=0; k<n; k++)\n        S[i][j][k]=abs((P[i]-P[k])^(P[j]-P[k]));\n  //TIMESTAMP(cs);\n  /*for (i=0; i<n; i++)\n    for (j=0; j<n; j++)\n      if (i!=j)\n      {\n        can[i][j]=1;\n        pii diff=P[j]-P[i];\n        if (i<j)\n          l=i+1, r=j;\n        else\n          l=i+1, r=j+n;\n        while (l<r)\n        {\n          if (((P[l]-P[i])^diff)<=0)\n          {\n            can[i][j]=0;\n            break;\n          }\n          l++;\n        }\n        //cerr<<i<<"" ""<<j<<"" ""<<can[i][j]<<endl;\n      }   */\n  for (i=0; i<n-1; i++)\n    D[i][i+1]=1;\n  for (len=2; len<n; len++)\n    for (i=0; i+len<n; i++)\n    {\n      for (j=i+1; j<i+len; j++)\n      {\n        if (check(i,j,i+len))\n          madd(D[i][i+len],mul(D[i][j],D[j][i+len]));\n      }\n      //cerr<<len<<"" ""<<i<<"" ""<<D[[j]\n    }\n  printf(""%d\\n"", D[0][n-1]);\n  TIMESTAMP(end);\n  return 0;\n}\n']","['dp', 'geometry']",2500
https://codeforces.com//contest/446/problem/B,B. DZY Loves Modification,As we know DZY loves playing games One day DZY decided to play with a matrix To be more precise he decided to modify the matrix with exactly operations Each modification is one of the following Pick some row of the matrix and decrease each element of the row by This operation brings to DZY the value of pleasure equal to the sum of elements of the row before the decreasing Pick some column of the matrix and decrease each element of the column by This operation brings to DZY the value of pleasure equal to the sum of elements of the column before the decreasing DZY wants to know what is the largest total value of pleasure he could get after performing exactly modifications Please help him to calculate this value ,"['#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n#include <cassert>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n#define prev PREV\n#define j0 j1347829\n#define j1 j234892\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nint n;\nint m;\nint k, p;\nll row[1000];\nll col[1000];\nll sumcol[1000001];\nll sumrow[1000001];\nmultiset<ll> rows, cols;\nll colsub, rowsub;\n\nint main () {\n    scanf (""%d%d%d%d"", &n, &m, &k, &p);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            int x;\n            scanf (""%d"", &x);\n            row[i] += x;\n            col[j] += x;\n        }\n    for (int i = 0; i < n; i++) rows.insert (-row[i]);\n    for (int i = 0; i < m; i++) cols.insert (-col[i]);\n    ll ans = -1e18, srow = 0, scol = 0;\n    for (int i = 0; i < k; i++) {\n        {\n            ll tmp = -(*rows.begin());\n            rows.erase (rows.begin ());\n            rows.insert (-(tmp - m * p));\n            srow += tmp;\n            sumrow[i + 1] = srow;\n        }   \n        {\n            ll tmp = -(*cols.begin());\n            cols.erase (cols.begin ());\n            cols.insert (-(tmp - n * p));\n            scol += tmp;\n            sumcol[i + 1] = scol;\n        }\n    }\n    for (int i = 0; i <= k; i++) {\n        ll cur = sumrow[i] + sumcol[k - i] - (ll)i * (k - i) * p;\n        ans = max (ans, cur);\n    }\n    cout << ans << endl;        \n    return 0;\n}']","['brute force', 'data structures', 'greedy']",2000
https://codeforces.com//contest/408/problem/A,A. Line to Cashier,Little Vasya went to the supermarket to get some groceries He walked about the supermarket for a long time and got a basket full of products Now he needs to choose the cashier to pay for the products There are cashiers at the exit from the supermarket At the moment the queue for the th cashier already has people The th person standing in the queue to the th cashier has items in the basket Vasya knows that the cashier needs 5 seconds to scan one item after the cashier scans each item of some customer he needs 15 seconds to take the customer s money and give him the change Of course Vasya wants to select a queue so that he can leave the supermarket as soon as possible Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers ,"['#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <unordered_set>\n#include <stdio.h>\n#include <string.h>\n#include <unordered_map>\nusing namespace std;\n\n#define MOD 10e9+7\nint m[100000];\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0; i<n; i++)\n        cin>>m[i];\n    int v=1000000000;\n    for(int i=0; i<n; i++){\n        int sum=0;\n        for(int e=0; e<m[i]; e++){\n            int a;\n            cin>>a;\n            sum+=5*a;\n            sum+=15;\n        }\n        v=min(v,sum);\n    }\n    cout<<v<<endl;\n    return 0;\n}\n']",['implementation'],900
https://codeforces.com//contest/1551/problem/D1,D1. Domino  easy version ,There s a table of n times m cells n rows and m columns The value of n cdot m is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to find out whether it is possible to place frac nm 2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n,m,k;\n    cin >> n >> m >> k;\n    if(n % 2 == 0 && m % 2 == 0)\n    {\n        if(k % 2 == 0)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    else if(n % 2 == 1 && m % 2 == 0)\n    {\n        k -= m/2;\n        if(k >= 0 && k % 2 == 0)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    else if(n % 2 == 0 && m % 2 == 1)\n    {\n        if(k % 2 == 0 && k <= n * m / 2 - n / 2)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","['constructive algorithms', 'math']",1700
https://codeforces.com//contest/540/problem/E,E. Infinite Inversions,There is an infinite sequence consisting of all positive integers in the increasing order We performed operations with this sequence A is an operation of swapping the elements of the sequence on positions and Your task is to find the number of inversions in the resulting sequence i e the number of such index pairs that and ,"['#include<bits/stdc++.h>\n#define sz(x) int((x).size())\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> PII;\ntypedef std::pair<ll,ll> PLL;\n\ntemplate<class T> inline T pr(T x) { return --x; }\ntemplate<class T> inline T nx(T x) { return ++x; }\n\nconst int maxn = 200010;\nint n,a[maxn],b[maxn];\nvector<int> x,y;\nunordered_map<int,int> id;\n\nconst int T_maxn = maxn*2;\nstruct Trray {\n\tint c[T_maxn+10];\n\tinline int bit(int x) { return x&(-x); }\n\tinline void clr() { memset(c,0,sizeof(c)); }\n\tint add(int i,int k) {\n\t\tfor (; i<=T_maxn; i+=bit(i)) c[i] += k;\n\t}\n\tint pf(int i) {\n\t\tif (i<=0) return 0;\n\t\tint r = 0;\n\t\tfor (; i; i-=bit(i)) r += c[i];\n\t\treturn r;\n\t}\n\tinline int get(int i,int j) { return i>j?0:pf(j)-pf(i-1); }\n}ta;\n\nint main() {\n    int i,j,k,t,tt,T,Test;\n    scanf(""%d"",&n);\n    for (i=1; i<=n; ++i) {\n        scanf(""%d%d"",a+i,b+i);\n        x.push_back(a[i]); x.push_back(b[i]);\n    }\n    sort(x.begin(),x.end());\n    x.resize( unique(x.begin(),x.end()) - x.begin() );\n    for (i=0; i<sz(x); ++i) y.push_back(i);\n    for (i=1; i<=n; ++i) {\n        a[i] = lower_bound(x.begin(),x.end(),a[i]) - x.begin();\n        b[i] = lower_bound(x.begin(),x.end(),b[i]) - x.begin();\n        swap(y[a[i]],y[b[i]]);\n    }\n    ll ans = 0;\n    for (int e:y) {\n        ans += (ll)ta.get(e+2,sz(y));\n        ta.add(e+1,1);\n    }\n    for (i=0; i<sz(x); ++i) {\n        if (y[i]<i) {\n            t = x[i]-1-x[y[i]]-(i-y[i]-1);\n            ans += (ll)t;\n        }\n        else if (y[i]>i) {\n            ans += (ll)(t=x[y[i]]-x[i]-1-(y[i]-i-1));\n        }\n    }\n    printf(""%I64d\\n"",ans);\n\n    return 0;\n}\n']","['binary search', 'data structures', 'implementation', 'sortings', 'trees']",2100
https://codeforces.com//contest/1155/problem/F,F. Delivery Oligopoly,The whole delivery market of Berland is controlled by two rival companies BerEx and BerPS They both provide fast and reliable delivery services across all the cities of Berland The map of Berland can be represented as an graph The cities are vertices and the roads are edges between them Each pair of cities has no more than one road between them Each road connects different cities BerEx and BerPS are so competitive that for each pair of cities v u they have set up their paths from v to u in such a way that It is guaranteed that it was possible Now Berland government decided to cut down the road maintenance cost by abandoning some roads Obviously they want to maintain as little roads as possible However they don t want to break the entire delivery system So BerEx and BerPS should still be able to have their paths between every pair of cities non intersecting What is the minimal number of roads Berland government can maintain ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = 100100;\nconst int N = 15;\nconst int M = (1 << 14) + 7;\nbool g[N][N];\nint n, m;\nint edgesToMask[N][M];\nvector<int> pathInMask[M][N][N];\nint dp[M];\nint par[M][3];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v][u] = g[u][v] = 1;\n\t}\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int mask = 0; mask < (1 << n); mask++)\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (((mask >> u) & 1) == 0) continue;\n\t\t\t\tif (g[v][u])\n\t\t\t\t\tedgesToMask[v][mask]++;\n\t\t\t}\n\tfor (int v = 0; v < n; v++)\n\t\tpathInMask[1 << v][v][v].push_back(v);\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t//cerr << mask << endl;\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (pathInMask[mask][v][u].empty()) continue;\n\t\t\t\tfor (int w = 0; w < n; w++) {\n\t\t\t\t\tif ((mask >> w) & 1) continue;\n\t\t\t\t\tif (!g[u][w]) continue;\n\t\t\t\t\tint nmask = mask | (1 << w);\n\t\t\t\t\tif (!pathInMask[nmask][v][w].empty()) continue;\n\t\t\t\t\tpathInMask[nmask][v][w] = pathInMask[mask][v][u];\n\t\t\t\t\tpathInMask[nmask][v][w].push_back(w);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfor (int mask = 0; mask < (1 << n); mask++)\n\t\tdp[mask] = INF;\n\tdp[1] = 0;\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t//cerr << mask << endl;\n\t\tif (dp[mask] == INF) continue;\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif ((mask >> v) & 1) continue;\n\t\t\tif (edgesToMask[v][mask] >= 2) {\n\t\t\t\tint nmask = mask | (1 << v);\n\t\t\t\tif (dp[nmask] > dp[mask] + 2) {\n\t\t\t\t\tdp[nmask] = dp[mask] + 2;\n\t\t\t\t\tpar[nmask][0] = mask;\n\t\t\t\t\tpar[nmask][1] = par[nmask][2] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (edgesToMask[v][mask] == 0) continue;\n\t\t\tfor (int u = v + 1; u < n; u++) {\n\t\t\t\tif ((mask >> u) & 1) continue;\n\t\t\t\tif (edgesToMask[u][mask] == 0) continue;\n\t\t\t\tint all = ((1 << n) - 1) ^ mask ^ (1 << v) ^ (1 << u);\n\t\t\t\tfor (int smask = all;; smask = (smask - 1) & all) {\n\t\t\t\t\tint nmask = smask | (1 << v) | (1 << u);\n\t\t\t\t\tif (!pathInMask[nmask][v][u].empty()) {\n\t\t\t\t\t\tint w = dp[mask] + (int)pathInMask[nmask][v][u].size() + 1;\n\t\t\t\t\t\tif (w < dp[mask | nmask]) {\n\t\t\t\t\t\t\tdp[mask | nmask] = w;\n\t\t\t\t\t\t\tpar[mask | nmask][0] = mask;\n\t\t\t\t\t\t\tpar[mask | nmask][1] = v;\n\t\t\t\t\t\t\tpar[mask | nmask][2] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (smask == 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", dp[(1 << n) - 1]);\n//\tfflush(stdout);\n\tint mask = (1 << n) - 1;\n\twhile(mask > 1) {\n\t\t//cerr << mask << endl;\n\t\t//return 0;\n\t\tint nmask = par[mask][0];\n\t\tint v = par[mask][1];\n\t\tint u = par[mask][2];\n\t\tif (v == u) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int z = 0; cnt < 2 && z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[v][z]) continue;\n\t\t\t\tcnt++;\n\t\t\t\tprintf(""%d %d\\n"", v + 1, z + 1);\n\t\t\t}\n\t\t\tif (cnt != 2) throw;\n\t\t} else {\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[v][z]) continue;\n\t\t\t\tprintf(""%d %d\\n"", v + 1, z + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[u][z]) continue;\n\t\t\t\tprintf(""%d %d\\n"", u + 1, z + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int> z = pathInMask[mask ^ nmask][v][u];\n\t\t\tfor (int i = 0; i < (int)z.size() - 1; i++) {\n\t\t\t\tprintf(""%d %d\\n"", z[i] + 1, z[i + 1] + 1);\n\t\t\t}\n\t\t}\n\t\tmask = nmask;\n\t}\n\n\treturn 0;\n}\n']","['brute force', 'dp', 'graphs']",2800
https://codeforces.com//contest/668/problem/A,A. Little Artem and Matrix,Little Artem likes electronics He can spend lots of time making different schemas and looking for novelties in the nearest electronics store The new control element was delivered to the store recently and Artem immediately bought it That element can store information about the matrix of integers size There are inputs in that element i e each row and each column can get the signal When signal comes to the input corresponding to some row this row cyclically shifts to the left that is the first element of the row becomes last element second element becomes first and so on When signal comes to the input corresponding to some column that column shifts cyclically to the top that is first element of the column becomes last element second element becomes first and so on Rows are numbered with integers from to from top to bottom while columns are numbered with integers from to from left to right Artem wants to carefully study this element before using it For that purpose he is going to set up an experiment consisting of turns On each turn he either sends the signal to some input or checks what number is stored at some position of the matrix Artem has completed his experiment and has written down the results but he has lost the chip Help Artem find any initial matrix that will match the experiment results It is guaranteed that experiment data is consistent which means at least one valid matrix exists ,"['#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nint main() {\n\tint n; int m; int q;\n\twhile(~scanf(""%d%d%d"", &n, &m, &q)) {\n\t\tvector<vi> id(n, vi(m));\n\t\trep(i, n) rep(j, m)\n\t\t\tid[i][j] = i * m + j;\n\t\tvector<int> val(n * m, 0);\n\t\tvi tmp(n + m);\n\t\tfor(int ii = 0; ii < q; ++ ii) {\n\t\t\tint ty;\n\t\t\tscanf(""%d"", &ty);\n\t\t\tif(ty == 1) {\n\t\t\t\tint r;\n\t\t\t\tscanf(""%d"", &r), -- r;\n\t\t\t\trep(j, m) tmp[j] = id[r][j];\n\t\t\t\trotate(tmp.begin(), tmp.begin() + 1, tmp.begin() + m);\n\t\t\t\trep(j, m) id[r][j] = tmp[j];\n\t\t\t} else if(ty == 2) {\n\t\t\t\tint c;\n\t\t\t\tscanf(""%d"", &c), -- c;\n\t\t\t\trep(i, n) tmp[i] = id[i][c];\n\t\t\t\trotate(tmp.begin(), tmp.begin() + 1, tmp.begin() + n);\n\t\t\t\trep(i, n) id[i][c] = tmp[i];\n\t\t\t} else if(ty == 3) {\n\t\t\t\tint r; int c; int x;\n\t\t\t\tscanf(""%d%d%d"", &r, &c, &x), -- r, -- c;\n\t\t\t\tval[id[r][c]] = x;\n\t\t\t} else abort();\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, m) {\n\t\t\t\tif(j != 0) putchar(\' \');\n\t\t\t\tprintf(""%d"", val[i * m + j]);\n\t\t\t}\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}\n']",['implementation'],1400
https://codeforces.com//contest/1218/problem/B,B. Guarding warehouses,Bob Bubblestrong just got a new job as security guard Bob is now responsible for safety of a collection of warehouses each containing the most valuable Bubble Cup assets the high quality bubbles His task is to detect thieves inside the warehouses and call the police Looking from the sky each warehouse has a shape of a convex polygon Walls of no two warehouses intersect and of course none of the warehouses is built inside of another warehouse Little did the Bubble Cup bosses know how lazy Bob is and that he enjoys watching soap operas he heard they are full of bubbles from the coziness of his office Instead of going from one warehouse to another to check if warehouses are secured the plan Bob has is to monitor all the warehouses from the comfort of his office using the special X ray goggles The goggles have an infinite range so a thief in any of the warehouses could easily be spotted However the goggles promptly broke and the X rays are now strong only enough to let Bob see through a single wall Now Bob would really appreciate if you could help him find out what is the total area inside of the warehouses monitored by the broken goggles so that he could know how much area of the warehouses he needs to monitor in person ,"['#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<""=""<<h<<""\\n""; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != \',\') { cerr<<*sdbg++; } cerr<<""=""<<h<<"",""; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<"" = ""; FORE(itt, (x)) cerr <<*itt <<"", ""; cerr <<""\\n""; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << ""("" << pair.first << "", "" << pair.second << "")"";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << ""("" << t.st << "", "" << t.nd << "", "" << t.rd << "")""; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T, class DUPA> ostream& operator<<(ostream& out, set<T, DUPA> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\n\nconst LD kEps = 1e-9;\nconst LD kPi = 2 * acos(0);\nLD Sq(LD x) {\n  return x * x;\n}\nstruct Point {\n  LD x, y;\n  Point() {}\n  Point(LD a, LD b) : x(a), y(b) {}\n  Point(const Point& a) : x(a.x), y(a.y) {}\n  void operator=(const Point& a) { x = a.x; y = a.y; }\n  Point operator+(const Point& a) const { Point p(x + a.x, y + a.y); return p; }\n  Point operator-(const Point& a) const { Point p(x - a.x, y - a.y); return p; }\n  Point operator*(LD a) const { Point p(x * a, y * a); return p; }\n  Point operator/(LD a) const { assert(abs(a) > kEps); Point p(x / a, y / a); return p; }\n  Point& operator+=(const Point& a) { x += a.x; y += a.y; return *this; }\n  Point& operator-=(const Point& a) { x -= a.x; y -= a.y; return *this; }\n  Point& operator*=(LD a) { x *= a; y *= a; return *this;}\n  Point& operator/=(LD a) { assert(abs(a) > kEps); x /= a; y /= a; return *this; }\n  \n  bool IsZero() const {\n    return abs(x) < kEps && abs(y) < kEps;\n  }\n  bool operator==(const Point& a) const {\n    return (*this - a).IsZero();\n  }\n  LD CrossProd(const Point& a) const {\n    return x * a.y - y * a.x;\n  }\n  LD CrossProd(Point a, Point b) const {\n    a -= *this;\n    b -= *this;\n    return a.CrossProd(b);\n  }\n  LD DotProd(const Point& a) const {\n    return x * a.x + y * a.y;\n  }\n  LD Norm() const {\n    return sqrt(Sq(x) + Sq(y));\n  }\n  void NormalizeSelf() {\n    *this /= Norm();\n  }\n  Point Normalize() {\n    Point res(*this);\n    res.NormalizeSelf();\n    return res;\n  }\n  LD Dist(const Point& a) const {\n    return (*this - a).Norm();\n  }\n  LD Angle() const {\n    return atan2(y, x);\n  }\n  void RotateSelf(LD angle) {\n    LD c = cos(angle);\n    LD s = sin(angle);\n    LD nx = x * c - y * s;\n    LD ny = y * c + x * s;\n    y = ny;\n    x = nx;\n  }\n  Point Rotate(LD angle) const {\n    Point res(*this);\n    res.RotateSelf(angle);\n    return res;\n  }\n  static bool LexCmp(const Point& a, const Point& b) {\n    if (abs(a.x - b.x) > kEps) {\n      return a.x < b.x;\n    }\n    return a.y < b.y;\n  }\n  LD SqNorm() {\n    return x * x + y * y;\n  }\n  friend ostream& operator<<(ostream& out, Point m);\n};\n\nostream& operator<<(ostream& out, Point p) {\n  out << ""("" << p.x << "", "" << p.y << "")"";\n  return out;\n}\n\nstruct Circle {\n  Point center;\n  LD r;\n  Circle(LD x, LD y, LD rad) {\n    center = Point(x, y);\n    r = rad;\n  }\n  Circle(const Point& a, LD rad) : center(a), r(rad) {}\n  LD Area() const {\n    return kPi * Sq(r);\n  }\n  LD Perimeter() const {\n    return 2 * kPi * r;\n  }\n  LD Diameter() const {\n    return 2 * r;\n  }\n  Point RotateRightMost(LD ang) const {\n    return center + Point{r * cos(ang), r * sin(ang)};\n  }\n  bool operator==(const Circle& c) const {\n    return center == c.center && abs(r - c.r) < kEps;\n  }\n};\n\nstruct Line {\n  Point p[2];\n  bool is_seg;\n  Line(Point a, Point b, bool is_seg_ = false) {\n    p[0] = a;\n    p[1] = b;\n    is_seg = is_seg_;\n  }\n  Line() {\n  }\n  Point& operator[](int a) {\n    return p[a];\n  }\n  Point NormalVector() {\n    Point perp = p[1] - p[0];\n    perp.RotateSelf(kPi / 2);\n    perp.NormalizeSelf();\n    return perp;\n  }\n  \n  // (A, B, C) such that A^2 + B^2 = 1, (A, B) > (0, 0)\n  vector<LD> LineEqNormLD() { // seems ok\n    LD A = p[1].y - p[0].y;\n    LD B = p[0].x - p[1].x;\n    LD C = -(A * p[0].x + B * p[0].y);\n    assert(abs(A * p[1].x + B * p[1].y + C) < kEps);\n    LD norm = sqrt(Sq(A) + Sq(B));\n    vector<LD> res{A, B, C};\n    for (auto& x : res) { x /= norm; }\n    if (A < -kEps || (abs(A) < kEps && B < -kEps)) {\n      for (auto& x : res) { x *= -1; }\n    }\n    return res;\n  }\n  \n  // assumes that coordinates are integers!\n  vector<int> LineEqNormInt() { // seems ok\n    int A = round(p[1].y - p[0].y);\n    int B = round(p[0].x - p[1].x);\n    int C = -(A * p[0].x + B * p[0].y);\n    int gcd = abs(__gcd(A, __gcd(B, C)));\n    vector<int> res{A, B, C};\n    for (auto& x : res) { x /= gcd; }\n    if (A < 0 || (A == 0 && B < 0)) {\n      for (auto& x : res) { x *= -1; }\n    }\n    return res;\n  }\n};\n\nstruct Utils {\n  // 0, 1, 2 or 3 pts. In case of 3 pts it means they are equal\n  static vector<Point> InterCircleCircle(Circle a, Circle b) {\n    if (a.r + kEps < b.r) {\n      swap(a, b);\n    }\n    if (a == b) {\n      return vector<Point>{a.RotateRightMost(0), a.RotateRightMost(2 * kPi / 3),\n        a.RotateRightMost(4 * kPi / 3)};\n    }\n    Point diff = b.center - a.center;\n    LD dis = diff.Norm();\n    LD ang = diff.Angle();\n    LD longest = max(max(a.r, b.r), dis);\n    LD per = a.r + b.r + dis;\n    if (2 * longest > per + kEps) {\n      return vector<Point>();\n    }\n    if (abs(2 * longest - per) < 2 * kEps) {\n      return vector<Point>{a.RotateRightMost(ang)};\n    }\n    LD ang_dev = acos((Sq(a.r) + Sq(dis) - Sq(b.r)) / (2 * a.r * dis));\n    return vector<Point>{a.RotateRightMost(ang - ang_dev), a.RotateRightMost(ang + ang_dev)};\n  }\n  \n  static vector<Point> InterLineLine(Line a, Line b) { // working fine\n    Point vec_a = a[1] - a[0];\n    Point vec_b1 = b[1] - a[0];\n    Point vec_b0 = b[0] - a[0]; \n    LD tr_area = vec_b1.CrossProd(vec_b0);\n    LD quad_area = vec_b1.CrossProd(vec_a) + vec_a.CrossProd(vec_b0);\n    if (abs(quad_area) < kEps) { // parallel or coinciding\n      if (PtBelongToLine(b, a[0])) {\n        return {a[0], a[1]};\n      } else {\n        return {};\n      }\n    }\n    return {a[0] + vec_a * (tr_area / quad_area)};\n  } \n  \n  static Point ProjPointToLine(Point p, Line l) { ///Tested\n    Point diff = l[1] - l[0];\n    return l[0] + diff * (diff.DotProd(p - l[0]) / diff.DotProd(diff));\n  }\n  \n  static Point ReflectPtWRTLine(Point p, Line l) {\n    Point proj = ProjPointToLine(p, l);\n    return proj * 2 - p;\n  }\n  \n  static vector<Point> InterCircleLine(Circle c, Line l) { /// Tested here: http://codeforces.com/gym/100554/submission/10197624\n    Point proj = ProjPointToLine(c.center, l);\n    LD dis_proj = c.center.Dist(proj);\n    if (dis_proj > c.r + kEps) { return vector<Point>(); }\n    LD a = sqrt(max((LD)0, Sq(c.r) - Sq(dis_proj)));\n    Point dir = l[1] - l[0];\n    LD dir_norm = dir.Norm();\n    vector<Point> cands{proj + dir * (a / dir_norm), proj - dir * (a / dir_norm)};\n    if (cands[0].Dist(cands[1]) < kEps) { return vector<Point>{proj}; }\n    return cands;\n  }\n  \n  static bool PtBelongToLine(Line l, Point p) {\n    return abs(l[0].CrossProd(l[1], p)) < kEps;\n  }\n  \n  static bool PtBelongToSeg(Line l, Point p) { // seems ok\n    return abs(p.Dist(l[0]) + p.Dist(l[1]) - l[0].Dist(l[1])) < kEps;\n  }\n  \n  static vector<Point> InterCircleSeg(Circle c, Line l) { //seems ok\n    vector<Point> from_line = InterCircleLine(c, l);\n    vector<Point> res;\n    for (auto p : from_line) {\n      if (PtBelongToSeg(l, p)) { res.PB(p); }\n    }\n    return res;\n  }\n  \n  static vector<Point> TangencyPtsToCircle(Circle c, Point p) { // seems ok\n    LD d = c.center.Dist(p);\n    if (d < c.r - kEps) { return {}; }\n    if (d < c.r + kEps) { return {p}; }\n    LD from_cent = (p - c.center).Angle();\n    LD ang_dev = acos(c.r / d);\n    return {c.RotateRightMost(from_cent - ang_dev), c.RotateRightMost(from_cent + ang_dev)};\n  }\n  \n  // outer and inner tangents tested only locally (however I believe that rigorously)\n  static vector<Line> OuterTangents(Circle c1, Circle c2) {\n    if (c1 == c2) { return {}; } // is it surely best choice?\n    if (c1.r < c2.r) { swap(c1, c2); }\n    if (c2.r + c1.center.Dist(c2.center) < c1.r - kEps) { return {}; }\n    if (abs(c1.r - c2.r) < kEps) {\n      Point diff = c2.center - c1.center;\n      Point R = diff.Rotate(kPi / 2) * (c1.r / diff.Norm()); \n      return {{c1.center + R, c2.center + R}, {c1.center - R, c2.center - R}};\n    }\n    Point I = c1.center + (c2.center - c1.center) * (c1.r / (c1.r - c2.r)); \n    if (c2.r + c1.center.Dist(c2.center) < c1.r + kEps) {\n      return {{I, I + (c2.center - c1.center).Rotate(kPi / 2)}};\n    }\n    vector<Point> to1 = TangencyPtsToCircle(c1, I);\n    vector<Point> to2 = TangencyPtsToCircle(c2, I);\n    vector<Line> res{{to1[0], to2[0]}, {to1[1], to2[1]}};\n    assert(Utils::PtBelongToLine(res[0], I));\n    assert(Utils::PtBelongToLine(res[1], I));\n    return res;\n  }\n  \n  // unfortunately big part of code is same as in previous function\n  // can be joined when putting appropriate signs in few places\n  // however those ifs differ a bit hence it may not be good idea\n  // to necessarily join them\n  static vector<Line> InnerTangents(Circle c1, Circle c2) {\n    if (c1 == c2) { return {}; } // this time surely best choice\n    if (c1.r < c2.r) { swap(c1, c2); }\n    LD d = c1.center.Dist(c2.center);\n    if (d < c1.r + c2.r - kEps) { return {}; }\n    Point I = c1.center + (c2.center - c1.center) * (c1.r / (c1.r + c2.r));\n    if (d < c1.r + c2.r + kEps) {\n      return {{I, I + (c2.center - c1.center).Rotate(kPi / 2)}};\n    }\n    vector<Point> to1 = TangencyPtsToCircle(c1, I);\n    vector<Point> to2 = TangencyPtsToCircle(c2, I);\n    vector<Line> res{{to1[0], to2[0]}, {to1[1], to2[1]}};\n    assert(Utils::PtBelongToLine(res[0], I));\n    assert(Utils::PtBelongToLine(res[1], I));\n    return res;\n  }\n  \n  static bool AreParallel(Line l1, Line l2) { // seems ok\n    return abs(l1[0].CrossProd(l2[0], l1[1]) - l1[0].CrossProd(l2[1], l1[1])) < kEps;\n  }\n  \n  // returns a vector of points such that their convex hull is intersection of those segments\n  // SZ(res) == 0 => empty intersection, SZ(res) == 1 => intersection is a point, SZ(res) == 2 => intersection is a segment\n  static vector<Point> InterSegs(Line l1, Line l2) { // seems ok\n    if (!Point::LexCmp(l1[0], l1[1])) { swap(l1[0], l1[1]); }\n    if (!Point::LexCmp(l2[0], l2[1])) { swap(l2[0], l2[1]); }\n    if (AreParallel(l1, l2)) {\n      if (!PtBelongToLine(l1, l2[0])) { return vector<Point>(); }\n      vector<Point> ends(2);\n      for (int tr = 0; tr < 2; tr++) {\n        if (Point::LexCmp(l1[tr], l2[tr]) ^ tr) {\n          ends[tr] = l2[tr];\n        } else {\n          ends[tr] = l1[tr];\n        }\n      }\n      if ((ends[1] - ends[0]).IsZero()) {\n        ends.pop_back();\n      }\n      if (SZ(ends) == 2 && Point::LexCmp(ends[1], ends[0])) { return vector<Point>(); }\n      return ends;\n    } else {\n      vector<Point> p = InterLineLine(l1, l2);\n      if (PtBelongToSeg(l1, p[0]) && PtBelongToSeg(l2, p[0])) { return p; }\n      return vector<Point>();\n    }\n  }\n  \n  static LD Angle(Point P, Point Q, Point R) { // angle PQR\n    LD ang2 = (P - Q).Angle();\n    LD ang1 = (R - Q).Angle();\n    LD ans = ang1 - ang2;\n    if (ans < kEps) {\n      ans += 2 * kPi;\n    }\n    return ans;\n  }\n  \n  // tested here: http://codeforces.com/contest/600/submission/14961583\n  // DON\'T change anything as this will lead to precision errors\n  // don\'t know why, but this is the only version which works precisely even for very mean cases\n  static LD DiskInterArea(Circle c1, Circle c2) { // tested here: http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=006254 problem I\n    if (c1.r < c2.r) {\n      swap(c1, c2);\n    }\n    LD d = c1.center.Dist(c2.center);\n    if (c1.r + c2.r < d + kEps) {\n      return 0;\n    }\n    if (c1.r - c2.r > d - kEps) {\n      return kPi * Sq(c2.r);\n    }\n    LD alfa = acos((Sq(d) + Sq(c1.r) - Sq(c2.r)) / (2 * d * c1.r));\n    LD beta = acos((Sq(d) + Sq(c2.r) - Sq(c1.r)) / (2 * d * c2.r));\n    return alfa * Sq(c1.r) + beta * Sq(c2.r) - sin(2 * alfa) * Sq(c1.r) / 2 - sin(2 * beta) * Sq(c2.r) / 2;\n  }\n  \n  static Line RadAxis(Circle c1, Circle c2) {\n    LD d = c1.center.Dist(c2.center);\n    LD a = (Sq(c1.r) - Sq(c2.r) + Sq(d)) / (2 * d);\n    Point Q = c1.center + (c2.center - c1.center) * (a / d);\n    Point R = Q + (c2.center - c1.center).Rotate(kPi / 2);\n    return Line(Q, R);\n  }\n};\n\nstruct Polygon {\n  vector<Point> pts;\n  Polygon(vector<Point> pts_) : pts(pts_) {}\n  Polygon() : Polygon(vector<Point>()) {}\n  void Add(Point p) {\n    pts.push_back(p);\n  }\n  // positive for counterclockwise\n  double Area() {\n    double area = 0;\n    for (int i = 0; i < SZ(pts); i++) {\n      area += pts[i].CrossProd(pts[(i + 1) % SZ(pts)]);\n    }\n    area /= 2;\n    return area;\n  }\n  void OrientCounterclockwise() {\n    if (Area() < 0) {\n      reverse(pts.begin(), pts.end());\n    }\n  }\n  int next(int a) {\n    if (a + 1 < SZ(pts)) {\n      return a + 1;\n    }\n    return 0;\n  }\n  pair<int, int> FurthestPair() { // tested here: http://codeforces.com/contest/333/submission/11058065\n    MakeConvexHull();\n    OrientCounterclockwise();\n    int furth = 1;\n    pair<int, int> best_pair = make_pair(0, 0);\n    double best_dis = 0;\n    for (int i = 0; i < SZ(pts); i++) {\n      Point side = pts[next(i)] - pts[i];\n      while (side.CrossProd(pts[furth] - pts[i]) < side.CrossProd(pts[next(furth)] - pts[i])) {\n        furth = next(furth);\n      }\n      vector<int> vec{i, next(i)};\n      for (auto ind : vec) {\n        if (pts[ind].Dist(pts[furth]) > best_dis) {\n          best_pair = make_pair(ind, furth);\n          best_dis = pts[ind].Dist(pts[furth]);\n        }\n      }\n      cerr<<""Furthest from: ""<<pts[i]<<""-""<<pts[next(i)]<<"" is ""<<pts[furth]<<endl;\n    }\n    return best_pair;\n  }\n  // for square 34 \n  //            12 holds one_way_hull = {{1,3,4},{1,2,4}}\n  // resulting polygon is counterclockwise {1, 2, 4, 3}\n  vector<vector<Point>> MakeConvexHull() { // tested everywhere http://codeforces.com/contest/333/submission/11058065\n    vector<vector<Point>> one_way_hull(2);\n    sort(pts.begin(), pts.end(), Point::LexCmp);\n    for (int dir = -1; dir <= 1; dir += 2) {\n      int hull_num = (dir + 1) / 2;\n      auto& H = one_way_hull[hull_num];\n      one_way_hull[hull_num].push_back(pts[0]);\n      if (SZ(pts) > 1) {\n        H.push_back(pts[1]);\n      }\n      for (int i = 2; i < SZ(pts); i++) {\n        while (SZ(H) >= 2 &&\n          dir * (pts[i] - H[SZ(H) - 2]).CrossProd(H.back() - H[SZ(H) - 2]) > -kEps) {\n          H.pop_back();\n          }\n          H.push_back(pts[i]);\n      }\n      if (SZ(H) > 1 && (H[0] - H.back()).IsZero()) { H.pop_back(); }\n    }\n    pts.clear();\n    for (auto p : one_way_hull[1]) {\n      pts.push_back(p);\n    }\n    for (int i = SZ(one_way_hull[0]) - 2; i >= 1; i--) {\n      pts.push_back(one_way_hull[0][i]);\n    }\n    return one_way_hull;\n  }\n  \n  // without sides\n  vector<vector<bool>> InsideDiagonalsMatrix() { // tested here: http://codeforces.com/contest/438/submission/11063385\n    int n = pts.size();\n    vector<vector<bool>> res(n, vector<bool>(n));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        Line diag(pts[i], pts[j]);\n        if (i == j || abs(i - j) == 1 || abs(i - j) == n - 1) { continue; }\n        res[i][j] = 1;\n        for (int k = 0; k < n; k++) {\n          int kk = next(k);\n          Line side(pts[k], pts[kk]);\n          if (k == i || k == j || kk == i || kk == j) { continue; }\n          vector<Point> inter = Utils::InterSegs(diag, side);\n          if (SZ(inter)) { res[i][j] = 0; }\n        }\n        int act = next(i);\n        LD areas[2] = {0, 0};\n        int passed_j = 0;\n        while (act != i) {\n          passed_j |= (act == j);\n          areas[passed_j] += pts[i].CrossProd(pts[act], pts[next(act)]);\n          act = next(act);\n        }\n        if (areas[0] * areas[1] < kEps) {\n          res[i][j] = 0;\n        }\n      }\n    }\n    return res;\n  }\n  \n  // P needs to be strictly outside polygon \n  // polygon needs to be STRICTLY convex and counterclockwise oriented (as MakeConvexHull does)\n  // returns {L, R} so that PL, PR are tangents and PL is on left\n  vector<Point> Tangents(Point p) { // tested here: https://icpc.kattis.com/problems/spin (1169964)\n    vector<Point> res;\n    REP (tr, 2) {\n      auto GrThan = [&](int fir, int sec) { // fir on sec\'s left\n        return p.CrossProd(pts[sec], pts[fir]) > kEps;\n      };\n      bool up = false;\n      int cr = 0;\n      if (SZ(pts) >= 2) { cr = p.CrossProd(pts[0], pts[1]); }\n      if (abs(cr) < kEps && SZ(pts) >= 3) { cr = p.CrossProd(pts[0], pts[2]); }\n      up = (cr > 0);\n      VI bd{1, SZ(pts) - 1};\n      int faj = 0;\n      while (bd[0] + 6 <= bd[1]) { // better don\'t replace with smaller constants\n        VI h(2);\n        REP (hh, 2) { h[hh] = (bd[0] + bd[1] + bd[hh]) / 3; }\n        if (!GrThan(h[up ^ tr], 0) ^ tr) { bd[up ^ tr] = h[up ^ tr]; }\n        else {\n          int gr = GrThan(h[0], h[1]);\n          bd[gr ^ tr] = h[gr ^ tr];\n        }\n      }\n      FOR (i, bd[0], bd[1]) {\n        if (GrThan(i, faj) ^ tr) {\n          faj = i;\n        }\n      }\n      res.PB(pts[faj]);\n    }\n    return res;\n  }\n};\n\nstruct ConvexPolHalves { // tested here: https://icpc.kattis.com/problems/spin (1169964)\n  vector<vector<Point>> chains; // initialized by MakeConvexHull\n  bool BelongTo(Point p) { // including borders\n    if (SZ(chains[0]) == 1) {\n      return (chains[0][0] - p).IsZero();\n    }\n    if (p.x  + kEps < chains[0][0].x || p.x - kEps > chains[0].back().x) { return false; }\n    REP (tr, 2) {\n      int kl = 0, kp = SZ(chains[tr]) - 2, faj = 0;\n      while (kl <= kp) {\n        int aktc = (kl + kp) / 2;\n        if (chains[tr][aktc].x < p.x + kEps) {\n          kl = aktc + 1;\n          faj = aktc;\n        } else {\n          kp = aktc - 1;\n        }\n      }\n      Point fir = chains[tr][faj], sec = chains[tr][faj + 1];\n      if (abs(fir.x - sec.x) < kEps) {\n        if (tr == 0) { if (sec.y + kEps < p.y) { return false; } }\n        else { if (fir.y - kEps > p.y) { return false; } }\n      } else {\n        LD cr = fir.CrossProd(sec, p);\n        if (abs(cr) < kEps) { return true; }\n        if ((cr > 0) ^ tr) { return false; }\n      }\n    }\n    return true;\n  }\n};\n\n// CLIP START\nbool InUpper(Point a) {\n  if (abs(a.y) > kEps) {\n    return a.y > 0;\n  }\n  return a.x > 0;\n}\n\nbool angle_cmp(const Point a, const Point b) {\n  bool u = InUpper(a);\n  bool v = InUpper(b);\n  return u!=v ? u : a.CrossProd(b)>0;\n}\n\n/**\n * @brief a+(b-a)*f \\in c+lin(d-c)\n * @returns f\n */\nLD cross(Point a, Point b, Point c, Point d) {\n  return (d - c).CrossProd(a - c) / (d - c).CrossProd(a - b);\n}\n\nstruct ClipLine { // valid side is on left\n  ClipLine(Point A, Point B) : al(A), bl(B), a(A), b(B) {};\n  Point al,bl; // original line points\n  mutable Point a,b; // actual intersection points\n  Point dir() const { return bl - al; }\n  bool operator<(const ClipLine& l) const { return angle_cmp(dir(),l.dir()); }\n  Point cross(const ClipLine& l) {\n    return al + (bl - al) * ::cross(al, bl, l.al, l.bl);\n  }\n  bool left(Point p) {\n    return (bl - al).CrossProd(p - al) > 0;\n  }\n};\n\n// FIXME WATCH OUT IT DOESN\'T WORK IF YOU PUT THE SAME LINE TWICE!!!!\n// To deal with it set<vector<int>> of LineEqNormInt if your\n// points have integer coordinates and don\'t put line\n// with the same equation twice ot set<vector<LD>> with fancy comparator\n// that compares up to eps tolerance at every coordinate\n// and use LineEqNormLD\n\nstruct Clip {\n  Clip(LD r) : area(4*r*r) {\n    Point a{-r,-r}, b{r,-r}, c{r,r}, d{-r,r};\n    lines = {ClipLine(a,b), ClipLine(b,c), ClipLine(c,d), ClipLine(d,a)};\n  }\n  \n  void insert(Line l) { insert(ClipLine(l[0], l[1])); }\n  \n  void insert(ClipLine l) {\n    assert(abs(l.dir().SqNorm()) > kEps);\n    find(l);\n    while (size() && !l.left(it->a) && !l.left(it->b)) { erase(); }\n    if (size()) {\n      while (prev(), size() && !l.left(it->a) && !l.left(it->b)) { erase(); }\n    }\n    if (size() && (!l.left(it->a) || !l.left(it->b))) {\n      l.a = l.cross(*it);\n      area -= l.a.CrossProd(it->b)*.5; it->b = l.a; next();\n      l.b = l.cross(*it);\n      if ((l.a-l.b).SqNorm() < kEps) {\n        l.b = l.a;\n      }\n      area -= it->a.CrossProd(l.b) * .5;\n      it->a = l.b;\n      if (!(l.a - l.b).IsZero()) {\n        area += l.a.CrossProd(l.b)*.5;\n        lines.insert(l);\n      }\n    }\n    //assert(l.dir().SqNorm()>1e-13);\n  }\n  \n  void find(const ClipLine &l) {\n    it = lines.lower_bound(l);\n    if (it == lines.end()) { it = lines.begin(); }\n  }\n  \n  void recalculate() {\n    area = 0; for (const ClipLine &l : lines) area += l.a.CrossProd(l.b);\n    area *= .5;\n  }\n  \n  int size() { return lines.size(); }\n  void next() { if(++it==lines.end()) it = lines.begin(); }\n  void prev() { if(it==lines.begin()) it = lines.end(); --it; }\n  void erase() {\n    assert(it!=lines.end());\n    area -= it->a.CrossProd(it->b)*.5;\n    it = lines.erase(it);\n    if(it==lines.end()) it = lines.begin();\n  }\n  typename set<ClipLine>::iterator it;\n  set<ClipLine> lines;\n  LD area;\n};\n// CLIP ENDS\n\n// CENTERS BEGIN\nPoint Bary(Point A, Point B, Point C, LD a, LD b, LD c) {\n  return (A * a + B * b + C * c) / (a + b + c);\n}\n\nPoint Centroid(Point A, Point B, Point C) {\n  return Bary(A, B, C, 1, 1, 1);\n}\n\nPoint Circumcenter(Point A, Point B, Point C) {\n  LD a = (B - C).SqNorm(), b = (C - A).SqNorm(), c = (A - B).SqNorm();\n  return Bary(A, B, C, a * (b + c - a), b * (c + a - b), c * (a + b - c));\n}\n\nPoint Incenter(Point A, Point B, Point C) {\n  return Bary(A, B, C, (B - C).Norm(), (A - C).Norm(), (A - B).Norm());\n}\n\nPoint Orthocenter(Point A, Point B, Point C) {\n  LD a = (B - C).SqNorm(), b = (C - A).SqNorm(), c = (A - B).SqNorm();\n  return Bary(A, B, C, (a+b-c)*(c+a-b), (b+c-a)*(a+b-c), (c+a-b)*(b+c-a));\n}\n\nPoint Excenter(Point A, Point B, Point C) { // opposite to A\n  LD a = (B - C).Norm(), b = (A - C).Norm(), c = (A - B).Norm();\n  return Bary(A, B, C, -a, b, c);\n}\n\nconst int N = 1e5 + 5;\nint segs_ends[N][2];\nint is_in[N];\nPoint pts[N];\nbool Cmp(int a, int b) {\n  int ua = InUpper(pts[a]);\n  int ub = InUpper(pts[b]);\n  if (ua != ub) {\n    return ua > ub;\n  }\n  return pts[a].CrossProd(pts[b]) > 0;\n}\nPoint dir;\nPoint orig;\nLD GetDis(int a) {\n  debug(orig, dir, pts[segs_ends[a][0]], pts[segs_ends[a][1]]);\n  Point i1 = Utils::InterLineLine({orig, dir}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n  return i1.Norm();\n}\nstruct CmpSecik {\n  bool operator() (int a, int b) {\n    if (a == b) { return 0; }\n    LD d1 = GetDis(a);\n    LD d2 = GetDis(b);\n    if (abs(d1 - d2) > kEps) {\n      return d1 < d2;\n    }\n    Point i1 = Utils::InterLineLine({orig, dir}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n    Point oth_a = pts[segs_ends[a][0]] + pts[segs_ends[a][1]] - i1 * 2;\n    Point oth_b = pts[segs_ends[b][0]] + pts[segs_ends[b][1]] - i1 * 2;\n    if (i1.CrossProd(oth_a) > 0) {\n      return oth_a.CrossProd(oth_b) < 0;\n    } else {\n      return oth_a.CrossProd(oth_b) > 0;\n    }\n  }\n};\nint coll[N];\nLD Area(Point d1, Point d2, int a) {\n  \n  Point i1 = Utils::InterLineLine({orig, d1}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n  Point i2 = Utils::InterLineLine({orig, d2}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n  return i1.CrossProd(i2);\n}\nVI wh_segs_adj[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(4);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int ware;\n  cin>>ware;\n  int cur = 0;\n  RE (i, ware) {\n    int c;\n    cin>>c;\n    FOR (j, cur + 1, cur + c - 1) {\n      segs_ends[j][0] = j;\n      segs_ends[j][1] = j + 1;\n    }\n    segs_ends[cur + c][0] = cur + c;\n    segs_ends[cur + c][1] = cur + 1;\n    RE (j, c) {\n      cur++;\n      int x, y;\n      cin>>x>>y;\n      pts[cur] = {(LD)x, (LD)y};\n    }\n  }\n  RE (i, cur) {\n    REP (j, 2) {\n      wh_segs_adj[segs_ends[i][j]].PB(i);\n    }\n  }\n  pts[cur + 1] = {1, 0};\n  VI ord(cur);\n  iota(ALL(ord), 1);\n  sort(ALL(ord), Cmp);\n  VI wh(cur + 2);\n  REP (i, SZ(ord)) {\n    wh[ord[i]] = i;\n  }\n  ord.PB(cur + 1);\n  set<int, CmpSecik> miotelka;\n  dir = {1, 0};\n  RE (i, cur) {\n    int i1 = segs_ends[i][0];\n    int i2 = segs_ends[i][1];\n    LD cr = pts[i1].CrossProd(pts[i2]);\n    if (abs(cr) < kEps) {\n      coll[i] = 1;\n      continue;\n    } else if (cr < 0) {\n      swap(segs_ends[i][0], segs_ends[i][1]);\n    }\n    if (!InUpper(pts[segs_ends[i][0]]) && InUpper(pts[segs_ends[i][1]])) {\n      miotelka.insert(i);\n      is_in[i] = 1;\n    }\n  }\n  debug(miotelka);\n  LD res = 0;\n  for (auto next_dir_ind : ord) {\n    Point next_dir = pts[next_dir_ind];\n    debug(next_dir_ind, next_dir, miotelka);\n    if (abs(dir.CrossProd(next_dir)) > kEps) {\n      assert(SZ(miotelka) % 2 == 0);\n      if (SZ(miotelka) >= 2) {\n        auto it = miotelka.begin();\n        res -= Area(dir, next_dir, *it);\n        res += Area(dir, next_dir, *(next(it)));\n      }\n    }\n    dir = dir + next_dir;\n    VI to_rem, to_ins;\n    for (auto seg : wh_segs_adj[next_dir_ind]) {\n      if (coll[seg]) { continue; }\n      if (is_in[seg]) {\n        to_rem.PB(seg);\n      } else {\n        to_ins.PB(seg);\n      }\n      is_in[seg] ^= 1;\n    }\n    debug(wh_segs_adj[next_dir_ind], to_rem, to_ins);\n    for (auto rem : to_rem) {\n      miotelka.erase(rem);\n    }\n    dir = next_dir;\n    for (auto ins : to_ins) {\n      miotelka.insert(ins);\n    }\n  }\n  cout<<res/2<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n']","['data structures', 'geometry']",3000
https://codeforces.com//contest/1661/problem/C,C. Water the Trees,There are n trees in a park numbered from 1 to n The initial height of the i th tree is h i You want to water these trees so they all grow to the height The watering process goes as follows You start watering trees at day 1 During the j th day you can Choose a tree and water it If the day is odd e g 1 3 5 7 dots then the height of the tree increases by 1 If the day is even e g 2 4 6 8 dots then the height of the tree increases by 2 Or skip a day without watering any tree Note that you can t water more than one tree in a day Your task is to determine the number of days required to water the trees so they grow to the same height You have to answer t independent test cases ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1000000000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int j = 0; j < n; j++){\n      cin >> h[j];\n    }\n    int mx = 0;\n    for (int j = 0; j < n; j++){\n      mx = max(mx, h[j]);\n    }\n    long long ans = INF;\n    for (int j = 0; j < 3; j++){\n      long long sum = 0;\n      int cnt = 0;\n      for (int k = 0; k < n; k++){\n        sum += mx + j - h[k];\n        if ((mx + j - h[k]) % 2 == 1){\n          cnt++;\n        }\n      }\n      long long res = sum / 3 * 2;\n      if (sum % 3 == 1){\n        res++;\n      }\n      if (sum % 3 == 2){\n        res += 2;\n      }\n      res = max(res, (long long) cnt * 2 - 1);\n      ans = min(ans, res);\n    }\n    cout << ans << endl;\n  }\n}']","['binary search', 'greedy', 'math']",1700
https://codeforces.com//contest/878/problem/E,E. Numbers on the blackboard,A sequence of integers is written on a blackboard Soon Sasha will come to the blackboard and start the following actions let and be two adjacent numbers before then he can remove them and write instead of them He will perform these operations until one number is left Sasha likes big numbers and will get the biggest possible number Nikita wants to get to the blackboard before Sasha and erase some of the numbers He has options in the option he erases all numbers to the left of the th number and all numbers to the right of th number i e all numbers between the th and the th inclusive remain on the blackboard For each of the options he wants to know how big Sasha s final number is going to be This number can be very big so output it modulo ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\n\nll in[100050];\nll sum[100050];\nll po2[100050];\nll getsum(int p1, int p2) {\n\tll rv = sum[p2] - sum[p1 - 1];\n\trv = (rv + MOD) % MOD;\n\trv = rv * mul_inv(po2[p1 - 1]) % MOD;\n\treturn rv;\n}\n\nll nxt[100050][2];\n\nll par[20][100050][2];\nint main() {\n\tint N, Q, i, j;\n\tscanf(""%d %d"", &N, &Q);\n\n\tpo2[0] = 1;\n\tfor (i = 1; i <= N; i++) po2[i] = po2[i - 1] * 2 % MOD;\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(""%lld"", &in[i]);\n\t\tsum[i] = sum[i - 1] + in[i] * po2[i];\n\t\tsum[i] %= MOD;\n\t\tsum[i] += MOD;\n\t\tsum[i] %= MOD;\n\t}\n\tfor (i = 1; i <= N; i++) {\n\t\tll s = 0;\n\t\tfor (j = i; j >= 1; j--) {\n\t\t\ts = 2 * s + in[j];\n\t\t\tif (s <= 0) {\n\t\t\t\tnxt[i][0] = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s >= 1000000000) break;\n\t\t}\n\t\tnxt[i][1] = getsum(nxt[i][0] + 1, i);\n\t}\n\n\tfor (i = 0; i <= N; i++) par[0][i][0] = nxt[i][0], par[0][i][1] = nxt[i][1];\n\tfor (i = 1; i < 20; i++) {\n\t\tfor (j = 1; j <= N; j++) {\n\t\t\tint np = par[i - 1][j][0];\n\t\t\tpar[i][j][0] = par[i - 1][np][0];\n\t\t\tpar[i][j][1] = (par[i - 1][j][1] + par[i - 1][np][1]) % MOD;\n\t\t}\n\t}\n\n\twhile (Q--) {\n\t\tint l, r;\n\t\tscanf(""%d %d"", &l, &r);\n\t\tif (l == r) {\n\t\t\tprintf(""%lld\\n"", (in[l] + 2 * MOD) % MOD);\n\t\t\tcontinue;\n\t\t}\n\n\t\tll ans = (in[l] + MOD) % MOD;\n\t\tl++;\n\t\n\t\tfor (i = 19; i >= 0; i--) {\n\t\t\tint p = par[i][r][0];\n\t\t\tif (p >= l) {\n\t\t\t\tans = (ans + par[i][r][1]) % MOD;\n\t\t\t\tr = p;\n\t\t\t}\n\t\t}\n\t\tans += getsum(l, r);\n\t\tprintf(""%lld\\n"", ans % MOD);\n\t}\n\treturn 0;\n}']","['combinatorics', 'dp']",3300
https://codeforces.com//contest/144/problem/D,D. Missile Silos,A country called Berland consists of cities numbered with integer numbers from to Some of them are connected by bidirectional roads Each road has some length There is a path from each city to any other one by these roads According to some Super Duper Documents Berland is protected by the Super Duper Missiles The exact position of the Super Duper Secret Missile Silos is kept secret but Bob managed to get hold of the information That information says that all silos are located exactly at a distance from the capital The capital is located in the city with number The documents give the formal definition the Super Duper Secret Missile Silo is located at some place which is either city or a point on a road if and only if the shortest distance from this place to the capital along the roads of the country equals exactly Bob wants to know how many missile silos are located in Berland to sell the information then to enemy spies Help Bob ,"['#include <string>\n#include <algorithm>\n#include <utility>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <utility>\n#include <time.h>\n#include <string.h>\nusing namespace std;\n\n\nint main( void )\n{\n\tint n, m, s;\n\tcin >> n >> m >> s;\n\t-- s;\n\tvector< vector<int> > adj(n);\n\tvector<int> u(m), v(m), w(m);\n\tfor( int i =0; i < m; i ++ ){\n\t\tcin >> u[i] >> v[i] >> w[i];\n\t\t-- u[i];\n\t\t-- v[i];\n\t\tadj[u[i]].push_back(i);\n\t\tadj[v[i]].push_back(i);\n\t}\n\tlong long l;\n\tcin >> l;\n\n\tpriority_queue< pair<int,int> > wl;\n\twl.push(pair<int,int>(0,s));\n\n\tvector<int> visited(n,0);\n\tvector<int> dist(n,-1);\n\twhile( !wl.empty() ){\n\t\tint D = -wl.top().first;\n\t\tint i = wl.top().second;\n\t\twl.pop();\n\t\tif( visited[i] ) continue;\n\t\tvisited[i] = true;\n\t\tdist[i] = D;\n\t\tfor( int j = 0; j < adj[i].size(); j ++ ){\n\t\t\tint e = adj[i][j];\n\t\t\tint t = u[e] == i ? v[e] : u[e];\n\t\t\tint d2 = D + w[e];\n\t\t\twl.push(pair<int,int>(-d2,t));\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor( int i =0; i < m; i ++ ){\n\t\tlong long A1 = -1, A2 = -1;\n\t\tif( dist[u[i]] < l && l < dist[u[i]] + w[i] && l <= dist[v[i]] + (dist[u[i]] + w[i] - l) )\n\t\t\tA1 = l - dist[u[i]];\n\t\tif( dist[v[i]] < l && l < dist[v[i]] + w[i] && l <= dist[u[i]] + (dist[v[i]] + w[i] - l) )\n\t\t\tA2 = (dist[v[i]] + w[i] - l);\n\t\tif( A1 >= 0 ) ++ ans;\n\t\tif( A2 >= 0 && A2 != A1 ) ++ ans;\n\t}\n\tfor( int i = 0; i < n; i ++ ){\n\t\tif( dist[i] == l )\n\t\t\t++ ans;\n\t}\n\tcout << ans << endl;\n}\n']","['data structures', 'dfs and similar', 'graphs', 'shortest paths']",1900
https://codeforces.com//contest/299/problem/C,C. Weird Game,Yaroslav Andrey and Roman can play cubes for hours and hours But the game is for three so when Roman doesn t show up Yaroslav and Andrey play another game Roman leaves a word for each of them Each word consists of binary characters or After that the players start moving in turns Yaroslav moves first During a move a player must choose an integer from 1 to which hasn t been chosen by anybody up to that moment Then the player takes a piece of paper and writes out the corresponding character from his string Let s represent Yaroslav s word as Similarly let s represent Andrey s word as Then if Yaroslav choose number during his move then he is going to write out character on the piece of paper Similarly if Andrey choose number during his move then he is going to write out character on the piece of paper The game finishes when no player can make a move After the game is over Yaroslav makes some integer from the characters written on his piece of paper Yaroslav can arrange these characters as he wants Andrey does the same The resulting numbers can contain leading zeroes The person with the largest number wins If the numbers are equal the game ends with a draw You are given two strings and Determine the outcome of the game provided that Yaroslav and Andrey play optimally well ,"['//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define fi first\n#define se second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,1,-1};\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << "" = "" << (x) << endl;\n#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;\n\nint n;\nstring s, t;\nint a, b, c;\nint p, q, now;\n\nstring win(){\n    if(p > q) return ""First"";\n    else if(p < q) return ""Second"";\n    else return ""Draw"";\n}\n\nint main(){\n    cin >> n >> s >> t;\n    rep(i, n * 2){\n\tif(s[i] == \'1\' && t[i] == \'1\') ++a;\n\telse if(s[i] == \'1\' && t[i] == \'0\') ++b;\n\telse if(s[i] == \'0\' && t[i] == \'1\') ++c;\n    }\n    p = (a + 1) / 2;\n    q = a - p;\n    now = a;\n    if(now & 1){\n\tif(c){\n\t    --c;\n\t    ++q;\n\t    ++now;\n\t}\n\telse if(b){\n\t    --b;\n\t    ++now;\n\t}else{\n\t    cout << win() << endl;\n\t    return 0;\n\t}\n    }\n    while(now < n * 2){\n\trep(i, 2){\n\t    if(i == 0){\n\t\tif(b){\n\t\t    --b;\n\t\t    ++p;\n\t\t    ++now;\n\t\t}\n\t\telse if(c){\n\t\t    --c;\n\t\t    ++now;\n\t\t}else{\n\t\t    cout << win() << endl;\n\t\t    return 0;\n\t\t}\n\t    }else{\n\t\tif(c){\n\t\t    --c;\n\t\t    ++q;\n\t\t    ++now;\n\t\t}\n\t\telse if(b){\n\t\t    --b;\n\t\t    ++now;\n\t\t}else{\n\t\t    cout << win() << endl;\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n    }\n    cout << win() << endl;\n    return 0;\n}\n']","['games', 'greedy']",1500
https://codeforces.com//contest/1168/problem/A,A. Increasing by Modulo,Toad Zitz has an array of integers each integer is between 0 and m 1 inclusive The integers are a 1 a 2 ldots a n In one operation Zitz can choose an integer k and k indices i 1 i 2 ldots i k such that 1 leq i 1 i 2 ldots i k leq n He should then change a i j to a i j 1 bmod m for each chosen integer i j The integer m is fixed for all operations and indices Here x bmod y denotes the remainder of the division of x by y Zitz wants to make his array non decreasing with the minimum number of such operations Find this minimum number of operations ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\n#define maxN 323456\nint n, m;\nint a[maxN];\n\nbool check(int c) {\n\tint premin = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] + c < m) {\n\t\t\tif (a[i] + c < premin) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpremin = max(premin, a[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[i] + c - m < premin)\n\t\t\t\tpremin = max(premin, a[i]);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t}\n\tint l = -1, r = m;\n\twhile (l + 1 < r) {\n\t\tint c = (l + r) / 2;\n\t\tif (check(c))\n\t\t\tr = c;\n\t\telse\n\t\t\tl = c;\n\t}\n\tprintf(""%d\\n"", r);\n}']","['binary search', 'greedy']",1700
https://codeforces.com//contest/1682/problem/D,D. Circular Spanning Tree,There are n nodes arranged in a circle numbered from 1 to n in the clockwise order You are also given a binary string s of length n Your task is to construct a tree on the given n nodes satisfying the two conditions below or report that there such tree does not exist For each node i 1 le i le n the degree of node is even if s i 0 and odd if s i 1 No two edges of the tree intersect internally in the circle The edges are allowed to intersect on the circumference Note that all edges are drawn as straight line segments For example edge u v in the tree is drawn as a line segment connecting u and v on the circle A tree on n nodes is a connected graph with n 1 edges ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nchar s[200005];\nint ansu[200005],ansv[200005],tmp;\nint js[200005],cnt;\nbool vis[200005];\nint main()\n{\n\tint t,n,ans=0,ans1=0,tsl,las;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tscanf(""%s"",s+1);\n\t\ttsl=0;\n\t\tfor(int i=1;i<=n;i++)if(s[i]==\'1\')tsl++;\n\t\tif(tsl==0||tsl%2==1)\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(""YES\\n"");\n\t\ttmp=0;\n\t\tcnt=0;\n\t\tlas=0;\n\t\tfor(int i=1;i<=n;i++)vis[i]=false;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'0\'&&las!=0)\n\t\t\t{\n\t\t\t\tansu[++tmp]=i;\n\t\t\t\tvis[i]=true;\n\t\t\t\tansv[tmp]=las;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t\tif(s[i]==\'1\')\n\t\t\t{\n\t\t\t\tif(las!=0)js[++cnt]=las;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'0\'&&vis[i]==false)\n\t\t\t{\n\t\t\t\tansu[++tmp]=i;\n\t\t\t\tansv[tmp]=las;\n\t\t\t\tvis[i]=true;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t\tif(s[i]==\'1\')break;\n\t\t}\n\t\tjs[++cnt]=las;\n\t\t//printf(""!!!%d\\n"",cnt);\n\t\tfor(int i=2;i<=cnt;i++)\n\t\t{\n\t\t\tansu[++tmp]=js[1];\n\t\t\tansv[tmp]=js[i];\n\t\t}\n\t\tfor(int i=1;i<=tmp;i++)printf(""%d %d\\n"",ansu[i],ansv[i]);\n\t}\n\treturn 0;\n} ']","['constructive algorithms', 'implementation', 'trees']",2000
https://codeforces.com//contest/407/problem/C,C. Curious Array,You ve got an array consisting of integers Moreover there are queries each query can be described by three integers Query means that we should add to each element where Record means the binomial coefficient or the number of combinations from elements into groups of elements You need to fulfil consecutively all queries and then print the final array ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\nconst int N = 100010;\nconst int K = 100;\nconst int K10 = K + 10;\n\nint inv[K10];\nint ans[K10][N];\n\nvoid init() {\n  for (int k = 0; k <= K; k++) {\n    inv[k] = 1;\n    int step = 1 << 30;\n    while (step > 0) {\n      inv[k] = (long long)inv[k] * inv[k] % md;\n      if (step & (md - 2)) inv[k] = (long long)inv[k] * k % md;\n      step >>= 1;\n    }\n  }\n}\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) x -= md;\n}\n\nint nouse[N];\n\nint main() {\n  init();\n  int n, tt;\n  scanf(""%d %d"", &n, &tt);\n  for (int i = 1; i <= n; i++) scanf(""%d"", nouse + i);\n  for (int i = 0; i <= K; i++)\n    for (int j = 0; j <= n + 1; j++) ans[i][j] = 0;\n  while (tt--) {\n    int ll, rr, k;\n    scanf(""%d %d %d"", &ll, &rr, &k);\n    add(ans[K - k][ll], 1);\n    add(ans[K - k][rr + 1], md - 1);\n    int u = 1;\n    for (int i = K - k + 1; i <= K; i++) {\n      int t = i - (K - k);\n      u = (long long)u * (t + rr - ll) % md;\n      u = (long long)u * inv[t] % md;\n      add(ans[i][rr + 1], md - u);\n    }\n  }\n  for (int j = 0; j <= K; j++)\n    for (int i = 1; i <= n; i++) {\n      add(ans[j][i], ans[j][i - 1]);\n      if (j > 0) {\n        add(ans[j][i], ans[j - 1][i]);\n      }\n    }\n  for (int i = 1; i <= n; i++) {\n    add(nouse[i], ans[K][i]);\n    printf(""%d"", nouse[i] % md);\n    if (i < n) printf("" "");\n  }\n  printf(""\\n"");\n  return 0;\n}\n']","['brute force', 'combinatorics', 'implementation', 'math']",2500
https://codeforces.com//contest/465/problem/B,B. Inbox  100500 ,Over time Alexey s mail box got littered with too many letters Some of them are read while others are unread Alexey s mail program can either show a list of all letters or show the content of a single letter As soon as the program shows the content of an unread letter it becomes read letter if the program shows the content of a read letter nothing happens In one click he can do any of the following operations Move from the list of letters to the content of any single letter Return to the list of letters from single letter viewing mode In single letter viewing mode move to the next or to the previous letter in the list You cannot move from the first letter to the previous one or from the last letter to the next one The program cannot delete the letters from the list or rearrange them Alexey wants to read all the unread letters and go watch football Now he is viewing the list of all letters and for each letter he can see if it is read or unread What minimum number of operations does Alexey need to perform to read all unread letters ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iostream>\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i != _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 1000;\n\nint n;\nbool a[maxn + 5];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tscanf(""%d"", &n);\n\tREP(i, 0, n) scanf(""%d"", a + i);\n\tint ans = 0;\n\tint lst = -oo;\n\tREP(i, 0, n)\n\t{\n\t\tif (a[i])\n\t\t{\n\t\t\tif (lst == -oo) lst = i - 1;\n\t\t\tans += min(2, i - lst);\n\t\t\tlst = i;\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/91/problem/E,E. Igloo Skyscraper,Today the North Pole hosts an Olympiad in a sport called toy igloo skyscrapers building There are walruses taking part in the contest Each walrus is given a unique number from to After start each walrus begins to build his own igloo skyscraper Initially at the moment of time equal to the height of the skyscraper th walrus is equal to Each minute the th walrus finishes building floors The journalists that are reporting from the spot where the Olympiad is taking place make queries to the organizers Each query is characterized by a group of three numbers The organizers respond to each query with a number such that 1 Number lies on the interval from to inclusive 2 The skyscraper of the walrus number possesses the maximum height among the skyscrapers of all walruses from the interval at the moment of time For each journalists query print the number of the walrus that meets the above given criteria If there are several possible answers print any of them ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef pair <int64, int64> pii64;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nconst int blocksize = 250;\n\nstruct block {\n\tint l, r;\n\tint size;\n\tint64 next_time;\n\tint pmax;\n};\n\nint n, k, m;\npii64 A[100000];\nblock blocks[500];\nint ans[100000];\nint L[100000], R[100000], T[100000];\nvector <pii> Q;\n\nbool myless (pii64 a, pii64 b, int64 tm) {\n\treturn a.fs + tm * a.sc < b.fs + tm * b.sc;\n}\n\nvoid process (int v, int64 tm) {\n\tint best = blocks[v].l;\n\tfor (int i = blocks[v].l; i <= blocks[v].r; i ++)\n\t\tif (myless (A[best], A[i], tm))\n\t\t\tbest = i;\n\tblocks[v].pmax = best;\n\tblocks[v].next_time = inf;\n\tpii64 cur = A[best];\n\tfor (int i = blocks[v].l; i <= blocks[v].r; i ++) {\n\t\tpii64 tmp = A[i];\n\t\tif (cur.sc < tmp.sc)\n\t\t\tblocks[v].next_time = min (blocks[v].next_time, (cur.fs - tmp.fs) / (tmp.sc - cur.sc) + 1);\n\t}\n}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf (""%d%d"", &n, &k);\n\tforn (i, n) {\n\t\tint x, y;\n\t\tscanf (""%d %d"", &x, &y);\n\t\tA[i] = mp ((int64)x, (int64)y);\n\t}\n\tQ.resize (k);\n\tforn (i, k) {\n\t\tscanf (""%d%d%d"", &L[i], &R[i], &T[i]);\n\t\tL[i] --;\n\t\tR[i] --;\n\t\tQ[i] = mp (T[i], i);\n\t}\n\tsort (all (Q));\n\tint l = 0;\n\tint m = 0;\n\twhile (l < n) {\n\t\tint r = min (l + blocksize - 1, n-1);\n\t\tblocks[m].l = l;\n\t\tblocks[m].r = r;\n\t\tblocks[m].size = r - l + 1;\n\t\tl = r + 1;\n\t\tm ++;\n\t}\n\tforn (i, m) {\n\t\tblocks[i].pmax = blocks[i].l;\n\t\tblocks[i].next_time = -1;\n\t}\n\tforn (i, k) {\n\t\tint num = Q[i].sc;\n\t\tint best = L[num];\n\t\tint r1 = R[num];\n\t\tint l1 = L[num];\n\t\tforn (j, m) {\n\t\t\tif (T[num] >= blocks[j].next_time)\n\t\t\t\tprocess (j, T[num]);\n\t\t\tif (L[num] <= blocks[j].l && blocks[j].r <= R[num]) {\n\t\t\t\tif (myless (A[best], A[blocks[j].pmax], T[num]))\n\t\t\t\t\tbest = blocks[j].pmax;\n\t\t\t\tr1 = min (r1, blocks[j].l - 1);\n\t\t\t\tl1 = max (l1, blocks[j].r + 1);\n\t\t\t}\n\t\t}\n\t\tl1 = max (l1, r1 + 1);\n\t\tfor (int j = L[num]; j <= r1; j ++)\n\t\t\tif (myless (A[best], A[j], T[num]))\n\t\t\t\tbest = j;\n\t\tfor (int j = l1; j <= R[num]; j ++)\n\t\t\tif (myless (A[best], A[j], T[num]))\n\t\t\t\tbest = j;\n\t\tans[num] = best;\n\t}\n\tforn (i, k)\n\t\tprintf (""%d\\n"", ans[i]+1);\n\treturn 0;\n}\n']","['data structures', 'geometry']",2500
https://codeforces.com//contest/204/problem/B,B. Little Elephant and Cards,The Little Elephant loves to play with color cards He has cards each has exactly two colors the color of the front side and the color of the back side Initially all the cards lay on the table with the front side up In one move the Little Elephant can turn any card to the other side The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color for each card the color of the upper side is considered Help the Little Elephant to find the minimum number of moves needed to make the set of cards funny ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint x[111111];\nint y[111111];\nmap<int,int> m,w;\nset<int> s;\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tint n;\n\tcin>>n;\n\tREP(i,n){\n\t\tscanf(""%d %d"",&x[i],&y[i]);\n\t\tm[x[i]]++;\n\t\ts.insert(x[i]);\n\t\tif(x[i]!=y[i]){\n\t\t\tw[y[i]]++;\n\t\t\ts.insert(y[i]);\n\t\t}\n\t}\n\tint best = -1;\n\n\tfor(set<int>::iterator it = s.begin();it!=s.end();it++){\n\t\tint val = *it;\n\t\tif(m[val] + w[val] >= (n+1)/2){\n\t\t\tint need = (n+1)/2 - m[val];\n\t\t\tneed = max(need, 0);\n\t\t\tif(best==-1 || best > need) best = need;\n\t\t}\n\t}\n\n\tcout<<best<<endl;\n\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","['binary search', 'data structures']",1500
https://codeforces.com//contest/1698/problem/F,F. Equal Reversal,There is an array a of length n You may perform the following operation on it Choose two indices l and r where 1 le l le r le n and a l a r Then reverse the subsegment from the l th to the r th element i e set a l a l 1 ldots a r 1 a r to a r a r 1 ldots a l 1 a l You are also given another array b of length n which is a permutation of a Find a sequence of at most n 2 operations that transforms array a into b or report that no such sequence exists ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define N 300005\n#define ll long long\n#define mod 998244353\n\nint T,n,i,j,qwq,s,fl,gg,k,p[N],c[N],a[N],b[N],op[N][2],tot;\nll ans;\nvoid OP(int l,int r){\n\top[++tot][0]=l;\n\top[tot][1]=r;\n\tfor(int i=l;i+i<l+r;++i){\n\t\tswap(a[i],a[l+r-i]);\n\t}\n}\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>b[i];\n\t\t}\n\t\ta[n+1]=a[n+2]=b[n+1]=b[n+2]=0;\n\t\tif(a[1]!=b[1]||a[n]!=b[n]){\n\t\t\tcout<<""NO\\n"";continue;\n\t\t}\n\t\telse{\n\t\t\ttot=0;gg=0;\n\t\t\tfor(i=1;i<=n;++i){\n\t\t\t\tif(a[i]==b[i])continue;\n\t\t\t\tint fl=0;\n\t\t\t\tfor(j=i+1;j<=n;++j){\n\t\t\t\t\tif(a[j]==b[i]&&a[j+1]==a[i-1]){\n\t\t\t\t\t\tOP(i-1,j+1);fl=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fl)continue;\n\t\t\t\tfor(j=1;j<=n;++j)c[j]=0;\n\t\t\t\tfor(j=i+1;j<=n;++j){\n\t\t\t\t\tif(a[j]==b[i]&&a[j-1]==a[i-1]){\n\t\t\t\t\t\t++c[j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(j=i+1;j<=n;++j)c[j]+=c[j-1]; \n\t\t\t\tfl=0;\n\t\t\t\tfor(j=i-1;j<=n;++j){\n\t\t\t\t\tfor(k=j+1;k<=n;++k){\n\t\t\t\t\t\tif(a[j]==a[k]&&c[k-1]-c[j-1]){\n\t\t\t\t\t\t\tOP(j,k);fl=1;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(fl)break;\n\t\t\t\t}\n\t\t\t\tif(fl){\n\t\t\t\t\tfor(j=i+1;j<=n;++j){\n\t\t\t\t\t\tif(a[j]==b[i]&&a[j+1]==a[i-1]){\n\t\t\t\t\t\t\tOP(i-1,j+1);break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tgg=1;cout<<""NO\\n"";break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!gg){\n\t\t\t\tcout<<""YES\\n"";cout<<tot<<""\\n"";\n\t\t\t\tfor(i=1;i<=tot;++i)cout<<op[i][0]<<"" ""<<op[i][1]<<""\\n"";\n\t\t\t}\n\t\t}\n\t}\n}']","['constructive algorithms', 'graphs', 'implementation', 'math']",2800
https://codeforces.com//contest/1244/problem/D,D. Paint the Tree,You are given a tree consisting of n vertices A tree is an undirected connected acyclic graph You have to paint each vertex into one of three colors For each vertex you know the cost of painting it in every color You have to paint the vertices so that any path consisting of exactly three distinct vertices does not contain any vertices with equal colors In other words let s consider all triples x y z such that x neq y y neq z x neq z x is connected by an edge with y and y is connected by an edge with z The colours of x y and z should be pairwise distinct Let s call a painting which meets this condition You have to calculate the minimum cost of a painting and find one of the optimal paintings If there is no painting report about it ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nvector<int> son[100010];\nll cost[3][100010];\nll p[3] = {0, 1, 2};\nll ans[3], _min = 1e18;\nll a[100010];\nint out[100010];\nint main() {\n    scanf(""%d"", &n);\n    for(int i = 1; i <= n; i++) scanf(""%d"", cost[0] + i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", cost[1] + i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", cost[2] + i);\n    for(int i = 1; i < n; i++) {\n        int u, v;\n        scanf(""%d%d"", &u, &v);\n        son[u].push_back(v), son[v].push_back(u);\n    }\n    for(int i = 1; i <= n; i++) {\n        if(son[i].size() == 1) a[1] = i;\n    }\n    for(int i = 1; i < n; i++) {\n        if(son[a[i]].size() > 2) return puts(""-1""), 0;\n        if(son[a[i]][0] != a[i - 1]) a[i + 1] = son[a[i]][0];\n        else a[i + 1] = son[a[i]][1];\n    }\n    do {\n        long long now = 0;\n        for(int i = 1; i <= n; i++) {\n            now += cost[p[i % 3]][a[i]];\n        }\n        if(now < _min) _min = now, memcpy(ans, p, sizeof p);\n    } while(next_permutation(p, p + 3));\n    cout << _min << endl;\n    for(int i = 1; i <= n; i++) out[a[i]] = ans[i % 3] + 1;\n    for(int i = 1; i <= n; i++) printf(""%d%c"", out[i], "" \\n""[i == n]);\n    return 0;\n}']","['brute force', 'constructive algorithms', 'dp', 'graphs', 'implementation', 'trees']",1800
https://codeforces.com//contest/160/problem/B,B. Unlucky Ticket,Each of you probably has your personal experience of riding public transportation and buying tickets After a person buys a ticket which traditionally has an number of digits he usually checks whether the ticket is lucky Let us remind you that a ticket is lucky if the sum of digits in its first half matches the sum of digits in its second half But of course not every ticket can be lucky Far from it Moreover sometimes one look at a ticket can be enough to say right away that the ticket is not lucky So let s consider the following that can definitely determine an unlucky ticket We ll say that a ticket is definitely unlucky if each digit from the first half corresponds to some digit from the second half so that each digit from the first half is than the corresponding digit from the second one or each digit from the first half is than the corresponding digit from the second one Each digit should be used exactly once in the comparisons In other words there is such between the digits of the first and the second half of the ticket that either each digit of the first half turns out than the corresponding digit of the second half or each digit of the first half turns out than the corresponding digit from the second half For example ticket meets the following unluckiness criterion and will not be considered lucky the sought correspondence is and ticket also meets the criterion the sought correspondence is and and ticket does not meet the criterion You have a ticket in your hands it contains digits Your task is to check whether it meets the unluckiness criterion ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tvector<int> a, b;\n\tfor (int i = 0; i < n * 2; ++i) {\n\t\tif (i < n)\n\t\t\ta.push_back(s[i] - \'0\');\n\t\telse\n\t\t\tb.push_back(s[i] - \'0\');\n\t}\n\tsort(a.begin(), a.end());\n\tsort(b.begin(), b.end());\n\n\tbool cmp = true;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] <= b[i])\n\t\t\tcmp = false;\n\t}\n\n\tif (cmp) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\n\tcmp = true;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] >= b[i])\n\t\t\tcmp = false;\n\t}\n\n\tif (cmp) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\n\tputs(""NO"");\n\treturn 0;\n}\n']","['greedy', 'sortings']",1100
https://codeforces.com//contest/1214/problem/C,C. Bad Sequence,Petya s friends made him a birthday present a bracket sequence Petya was quite disappointed with his gift because he dreamed of correct bracket sequence yet he told his friends nothing about his dreams and decided to fix present himself To make everything right Petya is going to move at most one bracket from its original place in the sequence to any other position Reversing the bracket e g turning into or vice versa isn t allowed We remind that bracket sequence s is called correct if s is empty s is equal to t where t is correct bracket sequence s is equal to t 1 t 2 i e concatenation of t 1 and t 2 where t 1 and t 2 are correct bracket sequences For example are correct while and are not Help Petya to fix his birthday present and understand whether he can move one bracket so that the sequence becomes correct ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n;\nchar s[N];\nint main() {\n\tscanf(""%d"",&n);\n\tscanf(""%s"",s);\n\tint bal=0,mbal=0;\n\trep(i,0,n) {\n\t\tif (s[i]==\'(\') bal++; else bal--;\n\t\tmbal=min(mbal,bal);\n\t}\n\tputs((bal==0&&mbal>=-1)?""Yes"":""No"");\n}\n']","['data structures', 'greedy']",1200
https://codeforces.com//contest/1697/problem/A,A. Parkway Walk,You are walking through a parkway near your house The parkway has n 1 benches in a row numbered from 1 to n 1 from left to right The distance between the bench i and i 1 is a i meters Initially you have m units of energy To walk 1 meter of distance you spend 1 unit of your energy You can t walk if you have no energy Also you can restore your energy by and this is the only way to restore the energy When you are sitting you can restore any integer amount of energy you want if you sit longer you restore more energy Note that the amount of your energy m Your task is to find the amount of energy you have to by sitting on benches to reach the bench n 1 from the bench 1 and end your walk You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 18:34:19       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n      int a;\n      cin >> a;\n      s += a;\n    }\n    cout << max(0, s - m) << \'\\n\';\n  }\n  return 0;\n}\n']","['greedy', 'implementation']",800
https://codeforces.com//contest/368/problem/B,B. Sereja and Suffixes,Sereja has an array consisting of integers The boy cannot sit and do nothing he decided to study an array Sereja took a piece of paper and wrote out integers For each number he wants to know how many distinct numbers are staying on the positions Formally he want to find the number of distinct numbers among Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time Help him find the answer for the described question for each ,"['/*\n * Package: StandardCodeLibrary.Core\n * */\n//引进常用的头文件并使用std名字空间;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//用于减少代码量的宏;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//调试相关的宏;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(""OLE"");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,""r"",stdin)\n#define output(out) freopen(out,""w"",stdout)\n#else\n#define prt(x) cerr<<""第""<<__LINE__<<""行\\t: ""<<#x""\\t=""<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define runtime() cerr<<""Used: ""<<db(clock())/CLOCKS_PER_SEC<<""s""<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//常用数据类型;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//常用常量:int的最大值;lli的最大值;db的误差相关常数;欧拉常数;圆周率;移动向量;取模使用的除数;\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//常用函数:最大最小值更新;数学相关函数;输入和输出;树状数组;并查集;可合并堆;\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ninline lli bin_pow(lli x,lli y){lli z=1;whl(y){if(y&1)z=mod(z*x);x=mod(sqr(x)),y>>=1;}rtn z;}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<"" ""<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?"""":"" "");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));rrep(i,y){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ninline void make_set(vpii& st){rep(i,sz(st))st[i]=mp(i,1);}\ninline int find_set(vpii& st,int x){int y=x,z;whl(y!=st[y].x)y=st[y].x;whl(x!=st[x].x)z=st[x].x,st[x].x=y,x=z;rtn y;}\ninline bool union_set(vpii& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?(st[a].y>st[b].y?st[a].x=b,st[a].y+=st[b].y:st[b].x=a,st[b].y+=st[a].y),true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//初始化;\nstruct Initializer{\n#ifndef DEBUG\nInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n~Initializer(){runtime();}\n#endif\n}initializer;\n\n//非标准;\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx::rope<char> rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tvi a(n);\n\tcin>>a;\n\tsi s;\n\tvi cnt(n);\n\trrep(i,n)\n\t{\n\t\ts.ins(a[i]);\n\t\tcnt[i]=sz(s);\n\t}\n\trep(i,m)\n\t{\n\t\tint l;\n\t\tcin>>l;\n\t\tcout<<cnt[--l]<<endl;\n\t}\n}\n']","['data structures', 'dp']",1100
https://codeforces.com//contest/634/problem/B,B. XOR Equation,Two integers and have a sum of and a bitwise XOR of How many possible values are there for the ordered pair ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nll solve(ll s, ll x)\n{\n\tll os = s;\n\tll ways = 1;\n\tfor (int qaz = 60; qaz >= 0; qaz--)\n\t{\n\t\tll c = 1LL << qaz;\n\t\tif (c & x)\n\t\t{\n\t\t\tways *= 2;\n\t\t\ts -= c;\n\t\t\tif (s < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll change = c*2;\n\t\t\tif (change <= s)\n\t\t\t\ts -= change;\n\t\t}\n\t}\n\tif (s != 0)\n\t\treturn 0;\n\tif (os == x)\n\t\tways -= 2;\n\treturn ways;\n}\n\nint main()\n{\n\tll s, x;\n\trint(s); rint(x);\n\tprintf(""%lld\\n"", solve(s, x));\n}\n']","['constructive algorithms', 'dp', 'implementation', 'math']",1700
https://codeforces.com//contest/346/problem/E,E. Doodle Jump,It is a very popular game and xiaodao likes it very much One day when playing the game she wondered whether there exists a platform that the doodler couldn t reach due to the limits of its jumping ability Consider the following problem There are platforms The height of the th platform is mod where and are positive co prime integers The maximum possible height of a Doodler s jump is That is it can jump from height to height if Initially the Doodler is on the ground the height of which is 0 The question is whether it can reach the highest platform or not For example when the heights of the platforms are as in the picture below With the first jump the Doodler can jump to the platform at height with the second one the Doodler can jump to the platform at height but then it can t jump to any of the higher platforms So it can t reach the highest platform User xiaodao thought about the problem for a long time but didn t solve it so she asks you for help Also she has a lot of instances of the problem Your task is solve all of these instances ,"['#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nstruct Run {\n    i64 l;\n    i64 d0, d;\n    i64 z0, dz;\n};\n\ni64 untilx(const vector<Run> &rs, i64 x) {\n/*    cerr << x << \'\\n\';\n    for (auto r: rs) {\n        cerr << r.l << \' \' << r.d0 << \' \' << r.d << \' \' << r.z0 << \' \' << r.dz << \'\\n\';\n    }*/\n    if (!x) return 1e18;\n    for (auto r: rs) {\n        if (r.d0 - r.d * r.l > x) continue;\n        if (r.d0 <= x) return r.z0;\n        i64 k = (r.d0 - x - 1) / r.d + 1;\n        return r.z0 + k * r.dz;\n    }\n    assert(false);\n    return -1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int T;\n    cin >> T;\n    for1(tc, T) {\n//        cerr << tc << \'\\n\';\n        i64 a, n, p, h;\n        cin >> a >> n >> p >> h;\n        a %= p;\n        if (a <= h) {\n            cout << ""YES"" << \'\\n\';\n            continue;\n        }\n        i64 L = a, R = p - a;\n        i64 Lz = 1, Rz = 1;\n        vector<Run> ls = {{0, L, 0, 1, 0}}, rs = {{0, R, 0, 1, 0}};\n        while (max(L, R) > 1) {\n//            cerr << L << \' \' << Lz << \' \' << R << \' \' << Rz << \'\\n\';\n            if (L > R) {\n                i64 len = L / R;\n                ls.pb({len, L, R, Lz, Rz});\n                Lz += Rz * len;\n                L %= R;\n            } else {\n                i64 len = R / L;\n                rs.pb({len, R, L, Rz, Lz});\n                Rz += Lz * len;\n                R %= L;\n            }\n        }\n        i64 LC = untilx(ls, h);\n        i64 RC = untilx(rs, h);\n//        cerr << LC << \' \' << RC << \'\\n\';\n        cout << (n < LC + RC - 1 ? ""NO"" : ""YES"") << \'\\n\';\n//        cout << (n < LC + RC - 1 ? ""NO"" : ""YES"") << \'\\n\';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","['math', 'number theory']",3000
https://codeforces.com//contest/1574/problem/C,C. Slay the Dragon,Recently Petya learned about a new game Slay the Dragon As the name suggests the player will have to fight with dragons To defeat a dragon you have to kill it and defend your castle To do this the player has a squad of n heroes the strength of the i th hero is equal to a i According to the rules of the game exactly one hero should go kill the dragon all the others will defend the castle If the dragon s defense is equal to x then you have to send a hero with a strength of at least x to kill it If the dragon s attack power is y then the total strength of the heroes defending the castle should be at least y The player can increase the strength of any hero by 1 for one gold coin This operation can be done any number of times There are m dragons in the game the i th of them has defense equal to x i and attack power equal to y i Petya was wondering what is the minimum number of coins he needs to spend to defeat the i th dragon Note that the task is solved improvements are not saved ,"[""/**\n *    author:  tourist\n *    created: 20.09.2021 17:39:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  long long total = accumulate(a.begin(), a.end(), 0LL);\n  int q;\n  cin >> q;\n  while (q--) {\n    long long x, y;\n    cin >> x >> y;\n    long long ans = (long long) 9e18;\n    auto it = lower_bound(a.begin(), a.end(), x);\n    if (it != a.end()) {\n      long long have = total - (*it);\n      long long add = max(0LL, y - have);\n      ans = min(ans, add);\n    }\n    if (it != a.begin()) {\n      long long have = total - (*prev(it));\n      long long add = max(0LL, y - have);\n      add += x - (*prev(it));\n      ans = min(ans, add);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]","['binary search', 'greedy', 'sortings', 'ternary search']",1300
https://codeforces.com//contest/1362/problem/C,C. Johnny and Another Rating Drop,The last contest held on Johnny s favorite competitive programming platform has been received rather positively However Johnny s rating has dropped again He thinks that the presented tasks are lovely but don t show the truth about competitors skills The boy is now looking at the ratings of consecutive participants written in a binary system He thinks that the more such ratings differ the more unfair is that such people are next to each other He defines the difference between two numbers as the number of bit positions where one number has zero and another has one we suppose that numbers are padded with leading zeros to the same length For example the difference of 5 101 2 and 14 1110 2 equals to 3 since 0101 and 1110 differ in 3 positions Johnny defines the unfairness of the contest as the sum of such differences counted for neighboring participants Johnny has just sent you the rating sequence and wants you to find the unfairness of the competition You have noticed that you ve got a sequence of integers from 0 to n That s strange but the boy stubbornly says that everything is right So help him and find the desired unfairness for received numbers ,"['#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint t; cin >> t;\n\n\twhile (t--) {\n\t\tll n; cin >> n;\n\t\tll res = 0;\n\t\twhile (n) {\n\t\t\tres += n;\n\t\t\tn /= 2;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}']","['bitmasks', 'greedy', 'math']",1400
https://codeforces.com//contest/141/problem/E,E. Clearing Up,After Santa Claus and his assistant Elf delivered all the presents and made all the wishes come true they returned to the North Pole and found out that it is all covered with snow Both of them were quite tired and they decided only to remove the snow from the roads connecting huts The North Pole has huts connected with roads One can go along the roads in both directions The Elf offered to split Santa Claus will clear up the wide roads and the Elf will tread out the narrow roads For each road they decided who will clear it Santa Claus or the Elf To minimize the efforts they decided to clear the road so as to fulfill both those conditions between any two huts should exist along the cleared roads Santa Claus and the Elf should clear the same number of roads At this point Santa Claus and his assistant Elf wondered which roads should they clear up ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair< int, int > PRII;\ntypedef pair< double ,double > PRDD;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\n\n#define Size(a) ((int)a.size())\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\n#define x first\n#define y second\n#define p_b push_back\n#define m_p make_pair\n#define oo 1000000000\n#define eps 1e-12\nconst double pi = acos(-1.0);\n\n#define maxn 1000 + 10\n#define maxm 100000 + 10\n\nint n,m,m1 = 0,m2 = 0;\nint e1[maxm][3],e2[maxm][3],used[maxm];\nint fa[maxn];\n\nint getfa( int i ) { return fa[i] == i ? i : fa[i] = getfa(fa[i]); }\n\nint main()\n{\n    int i,u,v,t = 0;\n\tchar ch;\n    \n\tscanf(""%d%d"",&n,&m);\n\tfor( i = 1 ; i <= m ; ++i )\n\t\t{\n\t\t\tscanf(""%d%d %c"",&u,&v,&ch);\n\t\t\tif( ch == \'S\' )\n\t\t\t\t++m1, e1[m1][0] = u, e1[m1][1] = v, e1[m1][2] = i;\n\t\t\tif( ch == \'M\' )\n\t\t\t\t++m2, e2[m2][0] = u, e2[m2][1] = v, e2[m2][2] = i;\n\t\t}\n\n\tif( !(n & 1) || m1 < (n-1)/2 || m2 < (n-1)/2 )\n\t\tprintf(""-1\\n"");\n\telse\n\t\t{\n\t\t\tfor( i = 1 ; i <= n ; ++i )\n\t\t\t\tfa[i] = i;\n\t\t\tfor( i = 1 ; i <= m1 ; ++i )\n\t\t\t\t{\n\t\t\t\t\tu = getfa(e1[i][0]);\n\t\t\t\t\tv = getfa(e1[i][1]);\n\t\t\t\t\tfa[u] = v;\n\t\t\t\t}\n\t\t\tfor( i = 1 ; i <= m2 ; ++i )\n\t\t\t\t{\n\t\t\t\t\tu = getfa(e2[i][0]);\n\t\t\t\t\tv = getfa(e2[i][1]);\n\t\t\t\t\tif( u != v )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t++t;\n\t\t\t\t\t\t\tfa[u] = v;\n\t\t\t\t\t\t\tused[e2[i][2]] = i;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif( t > (n-1)/2 )\n\t\t\t\tprintf(""-1\\n"");\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor( i = 1 ; i <= n ; ++i )\n\t\t\t\t\t\tfa[i] = i;\n\t\t\t\t\tfor( i = 1 ; i <= m ; ++i )\n\t\t\t\t\t\tif( used[i] )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tu = getfa(e2[used[i]][0]);\n\t\t\t\t\t\t\t\tv = getfa(e2[used[i]][1]);\n\t\t\t\t\t\t\t\tfa[u] = v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor( i = 1 ; i <= m2 ; ++i )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tu = getfa(e2[i][0]);\n\t\t\t\t\t\t\tv = getfa(e2[i][1]);\n\t\t\t\t\t\t\tif( u != v && t < (n-1)/2 )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t++t;\n\t\t\t\t\t\t\t\t\tfa[u] = v;\n\t\t\t\t\t\t\t\t\tused[e2[i][2]] = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tif( t < (n-1)/2 )\n\t\t\t\t\t\tprintf(""-1\\n"");\n\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor( i = 1 ; i <= m1 ; ++i )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tu = getfa(e1[i][0]);\n\t\t\t\t\t\t\t\t\tv = getfa(e1[i][1]);\n\t\t\t\t\t\t\t\t\tif( u != v )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t++t;\n\t\t\t\t\t\t\t\t\t\t\tfa[u] = v;\n\t\t\t\t\t\t\t\t\t\t\tused[e1[i][2]] = i;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( t < n-1 )\n\t\t\t\t\t\t\t\tprintf(""-1\\n"");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintf(""%d\\n"",t);\n\t\t\t\t\t\t\t\t\tfor( i = 1 ; i <= m ; ++i )\n\t\t\t\t\t\t\t\t\t\tif( used[i] )\n\t\t\t\t\t\t\t\t\t\t\tprintf(""%d%c"",i,--t?\' \':\'\\n\');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n    return 0;\n}\n']","['constructive algorithms', 'dp', 'dsu', 'graphs']",2300
https://codeforces.com//contest/585/problem/F,F. Digits of Number Pi,Vasily has recently learned about the amazing properties of number In one of the articles it has been hypothesized that whatever the sequence of numbers we have in some position this sequence is found among the digits of number Thus if you take for example the epic novel War and Peace of famous Russian author Leo Tolstoy and encode it with numbers then we will find the novel among the characters of number Vasily was absolutely delighted with this because it means that all the books songs and programs have already been written and encoded in the digits of Vasily is of course a bit wary that this is only a hypothesis and it hasn t been proved so he decided to check it out To do this Vasily downloaded from the Internet the archive with the sequence of digits of number starting with a certain position and began to check the different strings of digits on the presence in the downloaded archive Vasily quickly found short strings of digits but each time he took a longer string it turned out that it is not in the archive Vasily came up with a definition that a string of length is a if it contains a substring of length of at least which occurs in the archive To complete the investigation Vasily took large numbers with the same number of digits and now he wants to find the number of numbers in the interval from to which are in the archive Help Vasily calculate this value modulo ,"['#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nint nxt[1005*55][10];\nint n;\n\nchar s[1005];\nint ln;\nint loc[1005][1005];\nint dep[1005*55];\n\nchar x[55];\nint d;\nbool alloweq;\n\n#define MOD 1000000007\nint cache[55][1005*55][2][2];\n\nint go(int di, int nd, int md, int ce) {\n    md |= dep[nd] >= d/2;\n    if (di == d) return md && (alloweq || ce == 0);\n    if (cache[di][nd][md][ce] != -1) return cache[di][nd][md][ce];\n    int uv = 9;\n    if (ce) uv = x[di]-\'0\';\n    long long res = 0;\n    FO(v,0,uv+1) res += go(di+1, nxt[nd][v], md, ce && v==uv);\n    return cache[di][nd][md][ce] = res % MOD;\n}\n\nint main() {\n    scanf("" %s"", s);\n    ln = strlen(s);\n    FO(i,0,ln) {\n        int c = 0;\n        FO(j,i,ln) {\n            int v = s[j]-\'0\';\n            if (!nxt[c][v]) {\n                nxt[c][v] = ++n;\n            }\n            c = nxt[c][v];\n            loc[i][j] = c;\n            dep[c] = j-i+1;\n            if (dep[c] > 50) break;\n        }\n    }\n    FO(dij,0,ln+1) FO(i,0,ln) {\n        int j = i+dij;\n        if (j < ln) {\n            FO(v,0,10) {\n                if (!nxt[loc[i][j]][v]) {\n                    nxt[loc[i][j]][v] = nxt[loc[i+1][j]][v];\n                }\n            }\n        }\n    }\n    scanf("" %s"", x);\n    d = strlen(x);\n    memset(cache,-1,sizeof cache);\n    alloweq = false;\n    int tmp = go(0,0,0,1);\n    scanf("" %s"", x);\n    memset(cache,-1,sizeof cache);\n    alloweq = true;\n    int tmp2 = go(0,0,0,1);\n\n    printf(""%d\\n"", (tmp2-tmp+MOD)%MOD);\n}\n\n']","['dp', 'implementation', 'strings']",3200
https://codeforces.com//contest/1687/problem/A,A. The Enchanted Forest,The enchanted forest got its name from the magical mushrooms growing here They may cause illusions and generally should not be approached Marisa comes to pick mushrooms in the Enchanted Forest The Enchanted forest can be represented by n points on the X axis numbered 1 through n Before Marisa started her friend Patchouli used magic to detect the initial number of mushroom on each point represented by a 1 a 2 ldots a n Marisa can start out at point in the forest on minute 0 Each minute the followings happen in order She moves from point x to y x y le 1 possibly y x She collects all mushrooms on point y A new mushroom appears on each point in the forest Note that she collect mushrooms on minute 0 Now Marisa wants to know the maximum number of mushrooms she can pick after k minutes ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nll a[N];\nint n, k;\n\nvoid solve() {\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tif (k > n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] += k - n;\n\t\tk = n;\n\t}\n\tll ans = 0;\n\tll sum = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tsum += a[i];\n\tans = max(ans, sum);\n\tfor (int i = k; i < n; i++) {\n\t\tsum += a[i] - a[i - k];\n\t\tans = max(ans, sum);\n\t}\n\tans += (ll)k * (k - 1) / 2;\n\tprintf(""%lld\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['brute force', 'greedy']",1600
https://codeforces.com//contest/1561/problem/C,C. Deep Down Below,In a certain video game the player controls a hero characterized by a single integer value The hero will have to beat monsters that are also characterized by a single integer value On the current level the hero is facing n caves To pass the level the hero must enter all the caves in some order each cave exactly once and exit every cave safe and sound When the hero enters cave i he will have to fight k i monsters in a row first a monster with armor a i 1 then a monster with armor a i 2 and so on finally a monster with armor a i k i The hero can beat a monster if and only if the hero s power is strictly greater than the monster s armor If the hero can t beat the monster he s fighting the game ends and the player loses Note that once the hero enters a cave he can t exit it before he fights all the monsters in it strictly in the given order Each time the hero beats a monster the hero s power increases by 1 Find the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nstruct cave{\n\tLL siz,val;\n\tcave(){}\n\tcave(LL S,LL V){siz=S,val=V;}\n\tbool operator < (cave ano) const {return val<ano.val || (val==ano.val && siz>ano.siz);}\n}a[100005];\nLL n;\nvoid Solve()\n{\n\tscanf(""%lld"",&n);\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tLL siz;\n\t\tscanf(""%lld"",&siz);\n\t\tLL val=0;\n\t\tfor(LL j=1;j<=siz;++j)\n\t\t{\n\t\t\tLL s;\n\t\t\tscanf(""%lld"",&s);\n\t\t\tval=max(val,s-j+2);\n\t\t}\n\t\ta[i]=cave(siz,val);\n\t}\n\tsort(a+1,a+1+n);\n\tLL ans=a[1].val,pos=a[1].val+a[1].siz;\n\tfor(LL i=2;i<=n;++i)\n\t{\n\t\tif(pos>a[i].val)\tpos+=a[i].siz;\n\t\telse\tans+=a[i].val-pos,pos=a[i].val+a[i].siz;\n\t}\n\tprintf(""%lld\\n"",ans);\n}\nint main(){\n\tLL T;\n\tscanf(""%lld"",&T);\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}']","['binary search', 'greedy', 'sortings']",1300
https://codeforces.com//contest/625/problem/D,D. Finals in arithmetic,Vitya is studying in the third grade During the last math lesson all the pupils wrote on arithmetic quiz Vitya is a clever boy so he managed to finish all the tasks pretty fast and Oksana Fillipovna gave him a new one that is much harder Let s denote a of an integer as follows number is considered in decimal notation and then reverted If there are any leading zeroes afterwards they are thrown away For example if we flip the result is the integer but flipping we obtain and by flipping we come to Oksana Fillipovna picked some number without leading zeroes and flipped it to get number Then she summed and and told Vitya the resulting value His goal is to find any valid As Oksana Fillipovna picked some small integers as and Vitya managed to find the answer pretty fast and became interested in finding some general algorithm to deal with this problem Now he wants you to write the program that for given finds any without leading zeroes such that or determine that such doesn t exist ,"['#include <bits/stdc++.h>\nusing namespace std;\nchar str[100005];\nint a[100005];\nint main(){\n\tscanf(""%s"",str);\n\tint l=strlen(str);\n\tif(l==1){\n\t\tint d=str[0]-\'0\';\n\t\tif(d%2==0) printf(""%d\\n"",d/2);\n\t\telse printf(""0\\n"");\n\t\treturn 0;\n\t}\n\tint x1=0,x2=l-1;\n\tint d1=str[0]-\'0\',d2=str[l-1]-\'0\';\n\tbool fail=0;\n\twhile(x1<x2){\n\t\tif(x2-1==x1){\n\t\t\tif(d1==d2){\n\t\t\t\ta[x2]=d1/2;\n\t\t\t\ta[x1]=d1-d1/2;\n\t\t\t}\n\t\t\telse if(d1-1==d2+10){\n\t\t\t\ta[x2]=(d1-1)/2;\n\t\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\t}\n\t\t\telse fail=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(d1==d2){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\';\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+1&&d2>=0){\n\t\t\ta[x2]=d2/2;\n\t\t\ta[x1]=d2-d2/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+10&&d2<9){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse if(d1-1==d2+10&&d2<9){\n\t\t\ta[x2]=(d1-1)/2;\n\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse{\n\t\t\tfail=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!fail&&a[0]){\n\t\tfor(int x=0;x<l;x++) printf(""%d"",a[x]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\telse if(l==2){\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tfail=0;\n\tx1=1,x2=l-1;\n\td1=(str[0]-\'0\')*10+str[1]-\'0\',d2=str[l-1]-\'0\';\n\twhile(x1<x2){\n\t\tif(x2-1==x1){\n\t\t\tif(d1==d2){\n\t\t\t\ta[x2]=d1/2;\n\t\t\t\ta[x1]=d1-d1/2;\n\t\t\t}\n\t\t\telse if(d1-1==d2+10){\n\t\t\t\ta[x2]=(d1-1)/2;\n\t\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\t}\n\t\t\telse fail=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(d1==d2){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\';\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+1&&d2>=0){\n\t\t\ta[x2]=d2/2;\n\t\t\ta[x1]=d2-d2/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+10&&d2<9){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse if(d1-1==d2+10&&d2<9){\n\t\t\ta[x2]=(d1-1)/2;\n\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse{\n\t\t\tfail=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!fail&&a[1]){\n\t\tfor(int x=1;x<l;x++) printf(""%d"",a[x]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\tprintf(""0\\n"");\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation', 'math']",2400
https://codeforces.com//contest/1348/problem/E,E. Phoenix and Berries,Phoenix is picking berries in his backyard There are n shrubs and each shrub has a i red berries and b i blue berries Each basket can contain k berries But Phoenix has decided that each basket may only contain berries from the same shrub or berries of the same color red or blue In other words all berries in a basket must be from the same shrub or and have the same color For example if there are two shrubs with 5 red and 2 blue berries in the first shrub and 2 red and 1 blue berries in the second shrub then Phoenix can fill 2 baskets of capacity 4 completely the first basket will contain 3 red and 1 blue berries from the first shrub the second basket will contain the 2 remaining red berries from the first shrub and 2 red berries from the second shrub Help Phoenix determine the maximum number of baskets he can ,"['#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=510;\nint n,k,a[MAXN],b[MAXN];\nll dp[2][MAXN],sum,ans;\nint main () {\n\tscanf(""%d%d"",&n,&k);\n\tfor (int i=0;i<k;i++) {dp[0][i]=-1e18;}\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=0;j<k;j++) {dp[i&1][j]=-1e18;}\n\t\tscanf(""%d%d"",&a[i],&b[i]);\n\t\tfor (int j=0;j<k;j++){ \n\t\t\tint tmp=(sum%k+k-j)%k;\n\t\t\tfor (int l=0;l<min(k,a[i]+1);l++) {\n\t\t\t\tint tmp2=((a[i]+b[i])%k+k-l)%k;\n\t\t\t\t//cout << i << ""    "" << j << ""  "" << tmp << ""    "" << l << ""  "" << tmp2 << ""    "" << dp[i&1][(j+l)%k] << ""    "";\n\t\t\t\tif (tmp2>b[i]) {continue;}\n\t\t\t\tdp[i&1][(j+l)%k]=max(dp[i&1][(j+l)%k],dp[(i&1)^1][j]+(j+l)/k+(tmp+tmp2)/k+(a[i]+b[i]-tmp2-l)/k);\n\t\t\t\t//cout << dp[i&1][(j+l)%k] << ""    "" << dp[(i&1)^1][j]+(j+l)/k+(tmp+tmp2)/k+(a[i]+b[i]-tmp2-l)/k << endl;\n\t\t\t}\n\t\t}\n\t\tsum+=a[i];\n\t\tsum+=b[i];\n\t}\n\tans=0;\n\tfor (int i=0;i<k;i++) {ans=max(ans,dp[n&1][i]);}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}\n']","['brute force', 'dp', 'greedy', 'math']",2400
https://codeforces.com//contest/817/problem/C,C. Really Big Numbers,Ivan likes to learn different things about numbers but he is especially interested in numbers Ivan thinks that a positive integer number is if the difference between and the sum of its digits in decimal representation is not less than To prove that these numbers may have different special properties he wants to know how rare or not rare they are in fact he needs to calculate the quantity of numbers that are not greater than Ivan tried to do the calculations himself but soon realized that it s too difficult for him So he asked you to help him in calculations ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nint sum(long long n) {\n    int res = 0;\n    while (n) {\n        res += n % 10;\n        n /= 10;\n    }\n    return res;\n}\n\nvoid solve() {\n    long long n, s; cin >> n >> s;\n    long long l = 1, r = n + 1;\n    while (l < r) {\n        long long m = l + r >> 1;\n        if (m - sum(m) < s) {\n            l = m + 1;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << n + 1 - (l + r) / 2 << ""\\n"";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","['binary search', 'brute force', 'dp', 'math']",1600
https://codeforces.com//contest/434/problem/B,B. Nanami s Digital Board,Nanami is an expert at playing games This day Nanami s good friend Hajime invited her to watch a game of baseball Unwilling as she was she followed him to the stadium But Nanami had no interest in the game so she looked around to see if there was something that might interest her That s when she saw the digital board at one end of the stadium The digital board is pixels in height and pixels in width every pixel is either light or dark The pixels are described by its coordinate The th pixel of the th line is pixel The board displays messages by switching a combination of pixels to light and the rest to dark Nanami notices that the state of the pixels on the board changes from time to time At certain times certain pixels on the board may switch from light to dark or from dark to light Nanami wonders what is the area of the biggest light block such that a specific pixel is on its side A light block is a sub rectangle of the board in which all pixels are light Pixel belongs to a side of sub rectangle with and as its upper left and lower right vertex if and only if it satisfies the logical condition or and or or and Nanami has all the history of changing pixels also she has some questions of the described type can you answer them ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\nint n, m, q;\nconst int MAX_N = 1000 + 10;\nint a[MAX_N][MAX_N];\n\nstruct TR {\n\tbool flip, swap;\n\tint n;\n\n\tTR() {\n\t}\n\n\tTR(bool f, bool s, int n) :\n\t\t\tflip(f), swap(s), n(n) {\n\t}\n\n\tvoid trans(int&r, int&c) {\n\t\tif (swap) {\n\t\t\tstd::swap(r, c);\n\t\t}\n\t\tif (flip) {\n\t\t\tr = n - 1 - r;\n\t\t}\n\t}\n};\n\nstruct Board {\n\tint a[MAX_N][MAX_N], n, m;\n\tint up[MAX_N][MAX_N]; //r,c\n\tTR tr;\n\n\tvoid init(int n, int m, TR tr) {\n\t\tthis->n = n, this->m = m;\n\t\tthis->tr = tr;\n\t}\n\n\tvoid set(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t}\n\n\tvoid reset(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t\tprocessCol(c);\n\t}\n\n\tvoid processCol(int c) {\n\t\tup[0][c] = a[0][c];\n\t\tfor (int r = 1; r < n; ++r) {\n\t\t\tif (a[r][c] == 1) {\n\t\t\t\tup[r][c] = up[r - 1][c] + 1;\n\t\t\t} else {\n\t\t\t\tup[r][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid doit() {\n\t\tfor (int c = 0; c < m; ++c) {\n\t\t\tprocessCol(c);\n\t\t}\n\t}\n\n\tint ask(int r, int c) {\n\t\ttr.trans(r, c);\n//\t\tcout << r << "" "" << c << endl;\n\t\t//at row r, above it ,contain column c\n\t\t//min at left\n\t\tstatic int what[MAX_N];\n\t\twhat[c] = up[r][c];\n\t\tfor (int i = c - 1; i >= 0; --i) {\n\t\t\twhat[i] = min(what[i + 1], up[r][i]);\n\t\t}\n\t\tfor (int i = c + 1; i < m; ++i) {\n\t\t\twhat[i] = min(what[i - 1], up[r][i]);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint R = c;\n\t\tfor (int i = c; i >= 0; --i) {\n\t\t\twhile (R + 1 < m && what[R + 1] >= what[i])\n\t\t\t\t++R;\n\t\t\tans = max(ans, what[i] * (R - i + 1));\n\t\t}\n\t\tint L = c;\n\t\tfor (int i = c; i < m; ++i) {\n\t\t\twhile (L > 0 && what[L - 1] >= what[i])\n\t\t\t\t--L;\n\t\t\tans = max(ans, what[i] * (i - L + 1));\n\t\t}\n\t\treturn ans;\n\t}\n} D[4];\n\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tscanf(""%d"", a[i] + j);\n\t\t}\n\t}\n\tD[0].init(n, m, TR(false, false, n));\n\tD[1].init(n, m, TR(true, false, n));\n\tD[2].init(m, n, TR(false, true, m));\n\tD[3].init(m, n, TR(true, true, m));\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\tD[i].set(r, c, a[r][c]);\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < D[i].m; ++c) {\n\t\t\tD[i].processCol(c);\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tint op;\n\t\tscanf(""%d"", &op);\n\t\tif (op == 1) {\n\t\t\tint r, c;\n\t\t\tscanf(""%d%d"", &r, &c), --r, --c;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tD[i].reset(r, c, 1 - a[r][c]);\n\t\t\t}\n\t\t\ta[r][c] = 1 - a[r][c];\n\t\t} else {\n\t\t\tint r, c;\n\t\t\tscanf(""%d%d"", &r, &c), --r, --c;\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tans = max(ans, D[i].ask(r, c));\n\t\t\t}\n\t\t\tprintf(""%d\\n"", ans);\n\t\t}\n\t}\n}\n']","['divide and conquer', 'dp', 'dsu', 'implementation', 'two pointers']",2000
https://codeforces.com//contest/1550/problem/C,C. Manhattan Subarrays,Suppose you have two points p x p y p and q x q y q Let s denote the Manhattan distance between them as d p q x p x q y p y q Let s say that three points p q r form a triple if d p r d p q d q r Let s say that an array b 1 b 2 dots b m is if it is impossible to choose three indices i j k such that the points b i i b j j and b k k form a bad triple You are given an array a 1 a 2 dots a n Calculate the number of subarrays of a A subarray of the array a is the array a l a l 1 dots a r for some 1 le l le r le n Note that according to the definition subarrays of length 1 and 2 are ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        std::vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n        \n        auto isGood = [&](int l, int r) {\n            for (int i = l; i <= r; i++) {\n                for (int j = i + 1; j <= r; j++) {\n                    for (int k = j + 1; k <= r; k++) {\n                        if (a[i] >= a[j] && a[j] >= a[k]) {\n                            return false;\n                        }\n                        if (a[i] <= a[j] && a[j] <= a[k]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            \n            return true;\n        };\n        \n        int ans = 0;\n        for (int i = 0, j = 0; i < n; i++) {\n            while (!isGood(j, i)) {\n                j++;\n            }\n            \n            ans += i - j + 1;\n        }\n        \n        std::cout << ans << ""\\n"";\n    }\n    \n    return 0;\n}']","['brute force', 'geometry', 'greedy', 'implementation']",1700
https://codeforces.com//contest/1862/problem/D,D. Ice Cream Balls,Tema decided to improve his ice cream making skills He has already learned how to make ice cream in a cone balls Before his ice cream obsession Tema was interested in mathematics Therefore he is curious about the number of balls he needs to have in order to make n types of ice cream There are plenty possible ice cream flavours 1 2 3 dots Tema can make two balls ice cream with any flavours probably the same Two ice creams are considered different if their sets of ball flavours are different For example 1 2 2 1 but 1 1 neq 1 2 For example having the following ice cream balls 1 1 2 Tema can make only two types of ice cream 1 1 and 1 2 Help Tema answer this question It can be shown that answer always exist ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY long long\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e9)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n;\nIL TY solve(TY now){\n\tTY l=1,r=3e9,ans=0;\n\twhile(l<=r){\n\t\tTY mid=(l+r)>>1;\n\t\tif(mid*(mid-1)/2<=now)ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}return ans+now-ans*(ans-1)/2;\n}\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tn=qr();\n\t\tqw(solve(n),\'\\n\');\n\t}\n    return 0;\n}']","['binary search', 'combinatorics', 'constructive algorithms', 'math']",1300
https://codeforces.com//contest/1917/problem/B,B. Erase First or Second Letter,You are given a string s of length n Let s define two operations you can apply on the string remove the first character of the string remove the second character of the string Your task is to find the number of distinct strings that can be generated by applying the given operations on the initial string any number of times possibly zero in any order ,"[""#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\nusing namespace std;\nconst int maxn=100005;\nint T,n,tg[30];\nchar str[maxn];\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>str+1;\n\t\tfor(int i=0;i<26;++i)tg[i]=0;\n\t\tint ans=0,num=0;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif((++tg[str[i]-'a'])==1)++num;\n\t\t\tans+=num;\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}""]","['brute force', 'combinatorics', 'data structures', 'dp', 'strings']",1100
https://codeforces.com//contest/762/problem/A,A. k-th divisor,You are given two integers and Find th smallest divisor of or report that it doesn t exist Divisor of is any such natural number that can be divided by it without remainder ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\nLL n , k;\nvoid init(){\n  n = getint();\n  k = getint();\n}\nvoid solve(){\n  vector<LL> v;\n  for( LL i = 1 ; i * i <= n ; i ++ )\n    if( n % i == 0 ){\n      v.push_back( i );\n      if( n / i != i )\n        v.push_back( n / i );\n    }\n  sort( v.begin() , v.end() );\n  if( k > (int)v.size() )\n    puts( ""-1"" );\n  else\n    printf( ""%lld\\n"" , v[ k - 1 ] );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","['math', 'number theory']",1400
https://codeforces.com//contest/671/problem/D,D. Roads in Yusland,Mayor of Yusland just won the lottery and decided to spent money on something good for town For example repair all the roads in the town Yusland consists of intersections connected by bidirectional roads One can travel from any intersection to any other intersection using only these roads There is only one road repairing company in town named RC company Company s center is located at the intersection RC company doesn t repair roads you tell them Instead they have workers at some intersections who can repair only some specific paths The th worker can be paid coins and then he repairs on a path from to some that from to intersection Mayor asks you to choose the cheapest way to hire some subset of workers in order to repair all the roads in Yusland It s allowed that some roads will be repaired more than once If it s impossible to repair all roads print ,"['#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 311111\n\n#define TASK ""1""\n\nusing namespace std;\n\nvector<int> v[N], ch[N];\nvector<pair<int, int> > z[N];\nint n, m;\n\nint d[N];\n\n\nvoid dfs(int x, int pr, int de) {\n\td[x] = de;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tint to = v[x][i];\n\t\tif (to != pr) {\n\t\t\tdfs(to, x, de + 1);\n\t\t\tch[x].pb(to);\n\t\t}\n\t}\n}\n\n\nlong long dp[N];\n\nset<pair<long long, int > > Q[N];\nlong long ad[N];\nint bad = 0;\n\nvoid calc(int x) {\n\tif (ch[x].size() == 0) {\n\t\tad[x] = 0;\n\t\tfor (int i = 0; i < z[x].size(); i++) Q[x].insert(mp(z[x][i].S, z[x][i].F));\n\t\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\t\tif (Q[x].size() == 0) {\n\t\t\tbad = 1;\n\t\t\tdp[x] = 0;\n\t\t} else {\n\t\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < ch[x].size(); i++) calc(ch[x][i]);\n\tlong long sum = 0;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tsum += dp[ch[x][i]];\n\t}\n\tint la = -1;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tad[ch[x][i]] += sum - dp[ch[x][i]];\n\t\tif (la == -1 || Q[ch[x][i]].size() > Q[la].size()) la = ch[x][i];\n\t}\n\n\tfor (int i = 0; i < ch[x].size(); i++) if (ch[x][i] != la) {\n\t\tint u = ch[x][i];\n\t\tfor (auto it = Q[u].begin(); it != Q[u].end(); ++it) {\n\t\t\tlong long cost = (*it).F + ad[u] - ad[la];\n\t\t\tQ[la].insert(mp(cost, (*it).S));\n\t\t}\n\t}\n\tfor (int i = 0; i < z[x].size(); i++) {\n\t\tlong long cost = z[x][i].S + sum - ad[la];\n\t\tQ[la].insert(mp(cost, z[x][i].F));\n\t}\n\tswap(Q[la], Q[x]);\n\tad[x] = ad[la];\n\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\tif (Q[x].size() == 0) {\n\t\tbad = 1;\n\t\tdp[x] = 0;\n\t} else {\n\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t}\n}\n\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK"".in"",""r"",stdin);\t\n\t\tfreopen(TASK"".out"",""w"",stdout);\n\t#endif\t\t\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(0, 0, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, co;\n\t\tscanf(""%d%d%d"", &x, &y, &co);\n\t\tx--;\n\t\ty--;\n\t\tif (d[x] < d[y]) swap(x, y);\n\n\t\tz[x].pb(mp(d[y], co));\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tcalc(v[0][i]);\n\t\tans += dp[v[0][i]];\n\t}\n\tif (bad) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}']","['data structures', 'dp', 'greedy']",2900
https://codeforces.com//contest/1931/problem/G,G. One-Dimensional Puzzle,You have a one dimensional puzzle all the elements of which need to be put in one row connecting with each other All the puzzle elements are completely white and distinguishable from each other only if they have different shapes Each element has straight borders at the top and bottom and on the left and right it has connections each of which can be a protrusion or a recess You rotate the elements You can see that there are exactly 4 types of elements Two elements can be connected if the right connection of the left element is opposite to the left connection of the right element All possible types of elements The puzzle contains c 1 c 2 c 3 c 4 elements of each type The puzzle is considered complete if you have managed to combine elements into one long chain You want to know how many ways this can be done ,"[""// Problem: G. One-Dimensional Puzzle\n// Contest: Codeforces - Codeforces Round 925 (Div. 3)\n// URL: https://codeforces.com/contest/1931/problem/G\n// Memory Limit: 256 MB\n// Time Limit: 4000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\nconst int MOD = 998244353;\n\nint T;\n\nll qpow(ll a, ll p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint c1, c2, c3, c4; cin >> c1 >> c2 >> c3 >> c4;\n\tint n = 2 * (c1 + c2 + c3 + c4 + 10);\n\tvector<ll> fac(n + 1), inv(n + 1);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % MOD;\n\tinv[n] = qpow(fac[n], MOD - 2);\n\tfor (int i = n - 1; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n\tauto C = [&](int n, int m) {\n\t\tif (n < m || n < 0 || m < 0) return 0ll;\n\t\treturn fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n\t};\n\tif (c2 == c1) {\n\t\tif (c1 == 0) {\n\t\t\tif (c3 == 0 || c4 == 0) cout << 1 << '\\n';\n\t\t\telse cout << 0 << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tll ans1 = C(c2 + c4, c4) * C(c2 + c3 - 1, c3) % MOD;\n\t\tll ans2 = C(c2 + c4 - 1, c4) * C(c2 + c3, c3) % MOD;\n\t\tcout << (ans1 + ans2) % MOD << '\\n';\n\t} else if (c2 == c1 - 1) {\n\t\tcout << C(c1 + c4 - 1, c4) * C(c1 + c3 - 1, c3) % MOD << '\\n';\n\t} else if (c2 == c1 + 1) {\n\t\tcout << C(c2 + c4 - 1, c4) * C(c2 + c3 - 1, c3) % MOD << '\\n';\n\t} else cout << 0 << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}""]","['combinatorics', 'math', 'number theory']",2000
https://codeforces.com//contest/231/problem/A,A. Team,One day three best friends Petya Vasya and Tonya decided to form a team and take part in programming contests Participants are usually offered several problems during programming contests Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution Otherwise the friends won t write the problem s solution This contest offers problems to the participants For each problem we know which friend is sure about the solution Help the friends find the number of problems for which they will write a solution ,"['#include<vector> \n#include<list> \n#include<map> \n#include<set> \n#include<deque> \n#include<queue> \n#include<stack> \n#include<bitset> \n#include<algorithm> \n#include<functional> \n#include<numeric> \n#include<utility> \n#include<iostream> \n#include<sstream> \n#include<iomanip> \n#include<cmath> \n#include<cstdlib> \n#include<cctype> \n#include<string> \n#include<cstring> \n#include<cstdio> \n#include<ctime> \n#include<climits> \n#include<complex> \n#define sz(x) (int)((x).size()) \n#define rep(i,n) for (int i=0;i<n;i++) \n#define mp make_pair \n#define pb push_back\n#define fi first\n#define se second \n#define all(x) x.begin(),x.end() \n#define clr(x) memset((x),0,sizeof(x)) \n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e) \nusing namespace std; \nconst double eps=1e-8; \nconst double pi=acos(-1.0); \nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;} \ntypedef long long ll; \ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<string> vs; \ntypedef pair<int,int> pii; \ntypedef vector<pii> vpi; \nint main()\n{\n    int i,j,k,n;\n    cin>>n;\n    int s=0;\n    while (n--)\n    {\n        j=0;\n        for (i=0;i<3;i++)\n        {\n            cin>>k;\n            j+=k;\n        }\n        s+=j>=2;\n    }\n    cout<<s<<endl;\n    return 0;\n}']","['brute force', 'greedy']",800
https://codeforces.com//contest/1475/problem/A,A. Odd Divisor,You are given an integer n Check if n has an divisor greater than one does there exist such a number x x 1 that n is divisible by x and x is odd For example if n 6 then there is x 3 If n 4 then such a number does not exist ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        ll n; re(n);\n        while (n%2 == 0) n /= 2;\n        if (n != 1) {\n            cout << ""YES\\n"";\n        } else {\n            cout << ""NO\\n"";\n        }\n    }\n    return 0;\n}']","['math', 'number theory']",900
https://codeforces.com//contest/1527/problem/D,D. MEX Tree,You are given a tree with n nodes numerated from 0 to n 1 For each k between 0 and n inclusive you have to count the number of unordered pairs u v u neq v such that the of all the node labels in the shortest path from u to v including end points is k The of a sequence of integers is the smallest non negative integer that does not belong to the sequence ,"['/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n//#pragma GCC optimize(""Ofast,no-stack-protector"")\n//#pragma GCC optimize(""fast-math"")\n//#pragma GCC target(""avx2"")\n// if avx2 not supported, use this instead\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n\n// something\n//#pragma GCC optimize(""O3"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""avx"")  //Enable AVX\n\n#include <bits/stdc++.h>\n#ifdef ONPC\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored ""-Wunused-const-variable""\n#endif\n#define all(x) (x).begin(), (x).end()\n#define fr first\n#define sc second\n#define m_p make_pair\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define low_bo(a, x) ((int)(lower_bound(a.begin(), a.end(), x) - a.begin()))\n#define up_bo(a, x) ((int)(upper_bound(a.begin(), a.end(), x) - a.begin()))\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define popcnt(x) __builtin_popcount(x)\n#define shuffle(a) shuffle(a.begin(), a.end(), rnd)\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nusing namespace std;\n\n/*\nconst int MEMSIZE = 1e9;\nchar memory[MEMSIZE];\nint memorypos;\ninline void * operator new(size_t n){\n    if (memorypos + n >= MEMSIZE)\n        memorypos = MEMSIZE / 3;\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\ninline void operator delete(void *){}\n*/\n\nusing ll = long long;\n\n#ifndef ONPC\n#define cerr cerr_maksim\nstruct Cerr : public ostream {\n    template<typename T>\n    Cerr& operator<<(T const&) {\n        return *this;\n    }\n} cerr;\n#endif\n\n#ifdef ONPC\nmt19937 rnd(223);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n\ntemplate<typename T>\nvoid setmin(T &x, T y) {\n    x = min(x, y);\n}\n\ntemplate<typename T>\nvoid setmax(T &x, T y) {\n    x = max(x, y);\n}\n\nnamespace Ment {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n\n    template<typename T>\n    class Modular {\n    public:\n        using Type = typename decay<decltype(T::value)>::type;\n\n        constexpr Modular() : value() {}\n\n        template<typename U>\n        Modular(const U &x) {\n            value = normalize(x);\n        }\n\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n\n        const Type &operator()() const { return value; }\n\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n\n        constexpr static Type mod() { return T::value; }\n\n        Modular &operator+=(const Modular &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n\n        Modular &operator-=(const Modular &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n\n        template<typename U>\n        Modular &operator+=(const U &other) { return *this += Modular(other); }\n\n        template<typename U>\n        Modular &operator-=(const U &other) { return *this -= Modular(other); }\n\n        Modular &operator++() { return *this += 1; }\n\n        Modular &operator--() { return *this -= 1; }\n\n        Modular operator++(int) {\n            Modular result(*this);\n            *this += 1;\n            return result;\n        }\n\n        Modular operator--(int) {\n            Modular result(*this);\n            *this -= 1;\n            return result;\n        }\n\n        Modular operator-() const { return Modular(-value); }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n#ifdef _WIN32\n            uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n            uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n            asm(\n            ""divl %4; \\n\\t""\n            : ""=a"" (d), ""=d"" (m)\n            : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n            );\n            value = m;\n#else\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n\n        Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n        template<typename U>\n        friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\n    private:\n        Type value;\n    };\n\n    template<typename T>\n    bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\n\n    template<typename T, typename U>\n    bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\n\n    template<typename T, typename U>\n    bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\n    template<typename T>\n    bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T>\n    bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\n    template<typename T>\n    Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T>\n    Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T>\n    Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T>\n    Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> power(const Modular<T> &a, const U &b) {\n        assert(b >= 0);\n        Modular<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    string to_string(const Modular<T> &number) {\n        return to_string(number());\n    }\n\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n        return stream << number();\n    }\n\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n        typename common_type<typename Modular<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = Modular<T>::normalize(x);\n        return stream;\n    }\n\n    constexpr int md = 1e9 + 7;\n    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n}\nusing Ment::Mint;\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\n#define TIME (clock() * 1.0 / CLOCKS_PER_SEC)\n\n// WARNING!!!!!!\n// Maksim reads solution\n// be careful!!!!\n\n// solution starts here\n\nusing ld = double;\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 2e5 + 100, maxw = (1 << 20) + 5, inf = 1e9 + 100, LG = 18;\n\nvector<int> e[maxn];\n\nint up[LG][maxn], sz[maxn], h[maxn];\n\npair<int, int> seg[maxn];\n\nint tnow;\n\nvoid dfs(int v = 0, int p = -1) {\n    sz[v] = 1;\n    seg[v].fr = tnow++;\n    for (int i : e[v])\n        if (i != p) {\n            h[i] = h[v] + 1;\n            dfs(i, v);\n            sz[v] += sz[i];\n            up[0][i] = v;\n        }\n    seg[v].sc = tnow - 1;\n}\n\n// v anc of u\n\nbool isanc(int v, int u) {\n    return seg[v].fr <= seg[u].fr && seg[v].sc >= seg[u].sc;\n}\n\nint climb(int v, int t) {\n    for (int i = 0; i < LG; i++)\n        if ((1 << i) & t)\n            v = up[i][v];\n    return v;\n}\n\nint get_lca(int v, int u) {\n    if (h[v] < h[u])\n        swap(v, u);\n    v = climb(v, h[v] - h[u]);\n    if (v == u)\n        return v;\n    for (int i = LG - 1; i >= 0; i--)\n        if (up[i][v] != up[i][u])\n            v = up[i][v], u = up[i][u];\n    return up[0][v];\n}\n\nint n;\n\nvoid solve() {\n    tnow = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        e[i].clear();\n    for (int i = 1; i < n; i++) {\n        int v, u;\n        cin >> v >> u;\n        e[v].push_back(u);\n        e[u].push_back(v);\n    }\n    dfs();\n    for (int j = 1; j < LG; j++)\n        for (int i = 0; i < n; i++)\n            up[j][i] = up[j - 1][up[j - 1][i]];\n\n    vector<ll> dp(n + 2);\n    dp[0] = n * (ll)(n - 1) / 2;\n    dp[1] = dp[0];\n    for (int i : e[0])\n        dp[1] -= sz[i] * (ll)(sz[i] - 1) / 2;\n\n    int v = 0, u = 1;\n    for (int it = 2; it <= n; it++) {\n        cerr << ""at "" << it - 1 << "" "" << v << \' \' << u << \'\\n\';\n        if (h[v] < h[u])\n            swap(v, u);\n        if (isanc(u, v)) {\n            dp[it] = sz[v] * (ll)(n - sz[climb(v, h[v] - h[u] - 1)]);\n        } else {\n            dp[it] = sz[v] * (ll)sz[u];\n        }\n        if (it == n)\n            break;\n\n        int lca = get_lca(v, u);\n        if (isanc(lca, it) && (isanc(it, v) || isanc(it, u)))\n            continue;\n\n        if (isanc(u, v)) {\n            if (isanc(v, it)) {\n                v = it;\n                continue;\n            }\n            if (isanc(climb(v, h[v] - h[u] - 1), it)) {\n                break;\n            }\n            u = it;\n            continue;\n        }\n        if (isanc(v, it)) {\n            v = it;\n            continue;\n        }\n        if (isanc(u, it)) {\n            u = it;\n            continue;\n        }\n        break;\n    }\n    for (int i = 0; i <= n; i++)\n        cout << dp[i] - dp[i + 1] << \' \';\n    cout << \'\\n\';\n    //todo clear\n}\n\n// check test counter\n\nint main() {\n#ifdef ONPC\n    freopen(""../a.in"", ""r"", stdin);\n    freopen(""../a.out"", ""w"", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(20);\n    //precalc();\n    if (false) {\n        int te = 0;\n        while (1) {\n            cerr << ++te << \'\\n\';\n            solve();\n        }\n    }\n    int ts;\n    ts = 1;\n    cin >> ts;\n    for (int its = 1; its <= ts; its++) {\n        //cerr << ""\\nts "" << its << \'\\n\';\n        //cout << ""Case #"" << its << "": "";\n        solve();\n    }\n#ifdef ONPC\n    cerr << ""\\n\\nConsumed "" << TIME << \'\\n\';\n#endif\n}']","['combinatorics', 'dfs and similar', 'implementation', 'math', 'trees']",2400
https://codeforces.com//contest/1678/problem/B1,B1. Tokitsukaze and Good 01-String  easy version ,Tokitsukaze has a binary string s of length n consisting only of zeros and ones n is Now Tokitsukaze divides s into of subsegments and for each subsegment all bits in each subsegment are the same After that s is considered good if the lengths of all subsegments are even For example if s is it will be divided into and Their lengths are 2 2 4 respectively which are all even numbers so is good Another example if s is it will be divided into and and their lengths are 3 2 2 3 Obviously is not good Tokitsukaze wants to make s good by changing the values of some positions in s Specifically she can perform the operation any number of times change the value of s i to or 1 leq i leq n Can you tell her the minimum number of operations to make s good ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int N=200010;\nLL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\')x=x*10ll+ch-\'0\',ch=getchar();\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvoid solve()\n{\n\tn=read();\n\tscanf(""%s"",s+1);\n\tint ans=0,c=0;\n\tchar lst=s[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]==lst)c++,lst=s[i];\n\t\telse\n\t\t{\n\t\t\tif(!(c&1))c=1,lst=s[i];\n\t\t\telse\n\t\t\t{\n//\t\t\t\tprintf(""i = %d\\n"",i);\n\t\t\t\tc++;\n\t\t\t\tans++;\n\t\t\t\tlst=\'1\'+\'0\'-s[i];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"",ans);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)solve();\n \treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/731/problem/E,E. Funny Game,Once upon a time Petya and Gena gathered after another programming competition and decided to play some game As they consider most modern games to be boring they always try to invent their own games They have only stickers and markers but that won t stop them The game they came up with has the following rules Initially there are stickers on the wall arranged in a row Each sticker has some number written on it Now they alternate turn Petya moves first One move happens as follows Lets say there are stickers on the wall The player who makes the current move picks some integer from to and takes leftmost stickers removes them from the wall After that he makes the new sticker puts it to the left end of the row and writes on it the new integer equal to the sum of all stickers he took on this move Game ends when there is only one sticker left on the wall The score of the player is equal to the sum of integers written on all stickers he took during all his moves The goal of each player is to maximize the difference between his score and the score of his opponent Given the integer and the initial sequence of stickers on the wall define the result of the game i e the difference between the Petya s and Gena s score if both players play optimally ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)2e5+5;\nint n,a[N],m,s[N],ans[N];\n\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t\tcin >> a[i];\n\ts[0]=a[0];\n\tfor(int i=1;i<n;i++)\n\t\ts[i]=s[i-1]+a[i];\n\tans[n-2]=s[n-1];\n\tm=s[n-2]-ans[n-2];\n\tfor(int i=n-3;i>=0;i--)\n\t{\n\t\tif(i==0)ans[i]=max(m,s[n-1]); else ans[i]=max(m,s[n-1]-s[i-1]);\n\t\tm=max(m,s[i]-ans[i]);\n\t}\n\tcout << ans[0];\n\treturn 0;\n}\n']","['dp', 'games']",2200
https://codeforces.com//contest/625/problem/E,E. Frog Fights,Ostap Bender recently visited frog farm and was inspired to create his own frog game Number of frogs are places on a cyclic gameboard divided into cells Cells are numbered from to but the board is cyclic so cell number goes right after the cell number in the direction of movement th frog during its turn can jump for cells Frogs move in turns game starts with a move by frog On its turn th frog moves cells forward knocking out all the frogs on its way If there is a frog in the last cell of the path of the th frog that frog is also knocked out After this the value is decreased by the number of frogs that were knocked out during this turn If is zero or goes negative then th frog doesn t make moves anymore After frog number finishes its turn frog number starts to move then frog number and so on After the frog number makes its move frog starts to move again then frog and so on this process goes forever If some frog was already knocked out from the board we consider that it skips all its moves Help Ostap to identify what frogs will stay on the board at the end of a game ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define ll long long \n#define inf 1000000007\n#define mod 1000000007\n#define N 100005\n#define DBG(x) cerr<<(#x)<<""=""<<x<<endl;\n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n\ntemplate <class T> inline void Max(T &a,T b){if(a<b)a=b;}\ntemplate <class T> inline void Min(T &a,T b){if(a>b)a=b;}\n\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1LL*ans*a%mod;\n        a=1LL*a*a%mod;b>>=1;\n    }\n    return ans;\n}\nint ne[N],pr[N],dead[N],p[N],a[N],z[N],m,val[N],p1[N];\npii b[N];\npriority_queue<pii>q;\nvoid check(int u,int v){\n    int dist=p[v]-p[u];\n    if(dist<0)dist+=m;\n    if(dist<=a[u]&&u<v)val[u]=1;\n    else if(a[u]<=a[v])val[u]=inf;\n    else if(u>v){\n        int k=dist/(a[u]-a[v]);\n        if(dist%(a[u]-a[v]))k++;\n        val[u]=k;\n    }\n    else{\n        int k=1;dist-=a[u];\n        k+=dist/(a[u]-a[v]);\n        if(dist%(a[u]-a[v]))k++;\n        val[u]=k;\n    }\n    q.push(mp(-val[u],-u));\n}\nbool check2(int u,int v,int k){\n    ll pos1=z[u]*m+p[u]+1LL*a[u]*k;\n    ll pos2=z[v]*m+p[v]+1LL*a[v]*(k-1);\n    if(u>v)pos2+=a[v];\n    if(p1[u]>p1[v])pos2+=m;\n    return pos1>=pos2;\n}\nint main(){\n    int n,i,j,k;\n    scanf(""%d%d"",&n,&m);\n    for(i=0;i<n;i++){\n        scanf(""%d%d"",&p[i],&a[i]);\n        p[i]--;\n        p1[i]=p[i];\n        b[i]=mp(p[i],i);\n    }\n    sort(b,b+n);\n    b[n]=b[0];\n    for(i=0;i<n;i++){\n        j=b[i].y,k=b[i+1].y;\n        ne[j]=k;\n        pr[k]=j;\n        check(j,k);\n    }\n    int ans=n;\n    while(!q.empty()){\n        int u=-q.top().y;\n        int t=-q.top().x;\n        q.pop();\n        if(dead[u])continue;\n        if(t==inf)break;\n        int v=ne[u];\n        bool ok=true;\n        while(check2(u,v,t)){\n            ok=false;\n            dead[v]=true;\n            ans--;\n            if(ans==1)break;\n            v=ne[v];\n            ne[u]=v,pr[v]=u;\n            if(a[u]){\n                a[u]--;\n                p[u]+=t;\n                z[u]+=p[u]/m;\n                p[u]%=m;\n            }\n        }\n        if(ans==1)break;\n        if(ok)continue;\n        check(u,ne[u]);\n        check(pr[u],u);\n    }\n    printf(""%d\\n"",ans);\n    for(i=0;i<n;i++)if(!dead[i])printf(""%d "",i+1);puts("""");\n    return 0;\n}\n\n']","['data structures', 'greedy']",2800
https://codeforces.com//contest/1619/problem/C,C. Wrong Addition,Tanya is learning how to add numbers but so far she is not doing it correctly She is adding two numbers a and b using the following algorithm If one of the numbers is shorter than the other Tanya adds leading zeros so that the numbers are the same length The numbers are processed from right to left that is from the least significant digits to the most significant In the first step she adds the last digit of a to the last digit of b and writes their sum in the answer At each next step she performs the same operation on each pair of digits in the same place and writes the result to the side of the answer For example the numbers a 17236 and b 3465 Tanya adds up as follows large begin array r begin array r 17236 03465 end array hline begin array r 1106911 end array end array calculates the sum of 6 5 11 and writes 11 in the answer calculates the sum of 3 6 9 and writes the result to the left side of the answer to get 911 calculates the sum of 2 4 6 and writes the result to the left side of the answer to get 6911 calculates the sum of 7 3 10 and writes the result to the left side of the answer to get 106911 calculates the sum of 1 0 1 and writes the result to the left side of the answer and get 1106911 As a result she gets 1106911 You are given two positive integers a and s Find the number b such that by adding a and b as described above Tanya will get s Or determine that no suitable b exists ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,a,s,b;\n\nll rek(ll a,ll s){\n    if(s){\n        ll b;\n        ll va=a%10, vs=s%10;\n        a/=10; s/=10;\n        //cout<<va<<"" ""<<vs<<"" ""<<a<<"" ""<<s<<""\\n"";\n        if(vs>=va){\n            b=rek(a,s);\n            if(b!=-1){\n                b*=10;\n                b+=vs-va;\n                return b;\n            }\n        }\n        if(s%10==1 && vs<va && (a<=s/10)){\n            b=rek(a,s/10);\n            if(b!=-1){\n                b*=10;\n                b+=vs-va+10;\n                return b;\n            }\n        }\n        return -1;\n    }\n    else return 0;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>a>>s;\n        b=rek(a,s);\n        cout<<b<<""\\n"";\n    }\n}\n']",['implementation'],1200
https://codeforces.com//contest/93/problem/E,E. Lostborn,Igor K very much likes a multiplayer role playing game WineAge II Who knows perhaps that might be the reason for his poor performance at the university As any person who plays the game he is interested in equipping his hero with as good weapon and outfit as possible One day as he was reading the game s forum yet again he discovered a very interesting fact As it turns out each weapon in the game is characterised with different numbers They are called hit indicators and according to the game developers plan they are pairwise coprime The damage that is inflicted during a hit depends not only on the weapon s characteristics but also on the hero s strength parameter Thus if the hero s strength equals than the inflicted damage will be calculated as the number of numbers on the segment that aren t divisible by any hit indicator Recently having fulfilled another quest Igor K found a new Lostborn sword He wants to know how much damage he will inflict upon his enemies if he uses it ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint K,a[110];\nll dp[102][300010];\n\nll func(int pos, ll N){\n    if(pos == 0) return N;\n    if(N < 300000 && dp[pos][N] != -1) return dp[pos][N];\n    ll ans = func(pos-1,N) - func(pos-1,N/a[pos-1]);\n    if(N < 300000) dp[pos][N] = ans;\n    return ans;\n}\n\nint main(void){\n    ll N;\n    int i,j;\n    \n    cin >> N;\n    cin >> K;\n    REP(i,K) cin >> a[i];\n    sort(a,a+K);\n    REP(i,K+1) REP(j,300010) dp[i][j] = -1;\n    \n    ll ans = func(K,N);\n    cout << ans << endl;\n    \n    return 0;\n}\n']","['dp', 'math', 'number theory']",2600
https://codeforces.com//contest/1327/problem/G,G. Letters and Question Marks,You are given a string S and an array of strings t 1 t 2 dots t k Each string t i consists of lowercase Latin letters from to S consists of lowercase Latin letters from to and question marks Each string t i has its cost c i an integer number The value of some string T is calculated as sum limits i 1 k F T t i cdot c i where F T t i is the number of occurences of string t i in T as a substring For example F text aaabaaa text aa 4 You have to replace all question marks in S with lowercase Latin letters from to so the value of S is maximum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\n\nconst int AC_SIGMA=14,AC_V=22,AC_N=2010;\nstruct node {\n\tnode *go[AC_V],*fail,*f;\n\tll fg;\n}pool[AC_N],*cur,*root,*q[AC_N];\nnode* newnode() {\n\tnode *p=cur++;\n\tmemset(p->go,0,sizeof(p->go)); p->fail=p->f=NULL; p->fg=0;\n\treturn p;\n}\nvoid init() { cur=pool; root=newnode();}\nnode* append(node *p,int w) {\n\tif (!p->go[w]) p->go[w]=newnode(),p->go[w]->f=p;\n\treturn p=p->go[w];\n}\nvoid build() {\n\tint t=1;\n\tq[0]=root;\n\trep(i,0,t) rep(j,0,AC_SIGMA) if (q[i]->go[j]) {\n\t\tnode *v=q[i]->go[j],*p=v->f->fail;\n\t\twhile (p&&!p->go[j]) p=p->fail;\n\t\tif (p) v->fail=p->go[j]; else v->fail=root;\n\t\tq[t++]=q[i]->go[j];\n\t}\n\trep(i,0,t) if (q[i]->fail) q[i]->fg+=q[i]->fail->fg;\n\trep(i,0,t) rep(j,0,AC_SIGMA) if (!q[i]->go[j]) {\n\t\tnode *p=q[i]->fail;\n\t\tif (!p) q[i]->go[j]=root; else q[i]->go[j]=p->go[j];\n\t}\n}\n\nint k,go[20][1010];\nll val[20][1010];\nchar s[401000];\nll dp[(1<<14)+10][1010],tmp[1010];\n\nint main() {\n\tscanf(""%d"",&k);\n\tinit();\n\trep(i,0,k) {\n\t\tscanf(""%s"",s);\n\t\tnode *p=root;\n\t\tint m=strlen(s);\n\t\trep(j,0,m) p=append(p,s[j]-\'a\');\n\t\tint w;\n\t\tscanf(""%d"",&w);\n\t\tp->fg+=w;\n\t}\n\tbuild();\n\tscanf(""%s"",s);\n\tint n=strlen(s);\n\tVI qm;\n\trep(i,0,n) if (s[i]==\'?\') qm.pb(i);\n\tint m=SZ(qm),g=cur-pool;\n\trep(S,0,(1<<14)) rep(j,0,g) dp[S][j]=-(1ll<<60);\n\tdp[0][0]=0;\n\t/*rep(j,0,g) {\n\t\tprintf(""%d %lld\\n"",j,pool[j].fg);\n\t\trep(k,0,14) printf(""go %d %d %d\\n"",j,k,pool[j].go[k]-pool);\n\t}*/\n\tll ans=-(1ll<<60);\n\trep(pf,0,m+1) {\n\t\tint l=(pf==0)?0:qm[pf-1]+1;\n\t\tint r=(pf==m)?(n-1):(qm[pf]-1);\n\t\trep(j,0,g) {\n\t\t\tnode *p=pool+j;\n\t\t\tll ss=0;\n\t\t\trep(k,l,r+1) {\n\t\t\t\tassert(s[k]!=\'?\');\n\t\t\t\tp=p->go[s[k]-\'a\'];\n\t\t\t\tss+=p->fg;\n\t\t\t}\n\t\t\tgo[pf][j]=p-pool;\n\t\t\tval[pf][j]=ss;\n\t\t}\n\t}\n\trep(S,0,(1<<14)) {\n\t\tint pf=__builtin_popcount(S);\n\t\tif (pf>m) continue;\n\t\trep(j,0,g) tmp[j]=-(1ll<<60);\n\t\trep(j,0,g) tmp[go[pf][j]]=max(tmp[go[pf][j]],dp[S][j]+val[pf][j]);\n\t\tif (__builtin_popcount(S)==m) {\n\t\t\trep(i,0,g) ans=max(ans,tmp[i]);\n\t\t}\n\t\t//rep(k,0,g) printf(""Tmp %d %d %lld\\n"",S,k,tmp[k]);\n\t\t//rep(k,0,g) printf(""Dp %d %d %lld\\n"",S,k,dp[S][k]);\n\t\trep(j,0,14) if (!(S&(1<<j))) {\n\t\t\trep(k,0,g) {\n\t\t\t\tnode *p=pool[k].go[j];\n\t\t\t\tdp[S|(1<<j)][p-pool]=max(dp[S|(1<<j)][p-pool],tmp[k]+p->fg);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"",ans);\n}']","['bitmasks', 'dp', 'string suffix structures']",2800
https://codeforces.com//contest/336/problem/A,A. Vasily the Bear and Triangle,Vasily the bear has a it has one vertex at point and the opposite vertex at point Of course the sides of Vasya s favorite rectangle are parallel to the coordinate axes Vasya also loves triangles if the triangles have one vertex at point That s why today he asks you to find two points and such that the following conditions hold the coordinates of points are integers Besides the following inequation holds the triangle formed by point and is rectangular and isosceles is right all points of the favorite rectangle are located inside or on the border of triangle the area of triangle is as small as possible Help the bear find the required points It is not so hard to proof that these points are unique ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint x, y, x1, y1, x2, y2;\n\nint main()\n{\n\tscanf(""%d %d"", &x, &y);\n\tif (x > 0)\n\t{\n\t\tif (y > 0)\n\t\t{\n\t\t\tx1 = x + y, y1 = 0;\n\t\t\tx2 = 0, y2 = x + y;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tx1 = x - y, y1 = 0;\n\t\t\tx2 = 0, y2 = 0 - (x - y);\n\t\t}\n\t}\n\n\telse\n\t{\n\t\tif (y < 0)\n\t\t{\n\t\t\tx1 = x + y, y1 = 0;\n\t\t\tx2 = 0, y2 = x + y;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tx1 = x - y, y1 = 0;\n\t\t\tx2 = 0, y2 = 0 - (x - y);\n\t\t}\n\t}\n\t\n\tif (x1 > x2)\n\t\tswap(x1, x2), swap(y1, y2);\n\tprintf(""%d %d %d %d\\n"", x1, y1, x2, y2);\n\treturn 0;\n}\n']","['implementation', 'math']",1000
https://codeforces.com//contest/992/problem/C,C. Nastya and a Wardrobe,Nastya received a gift on New Year a magic wardrobe It is magic because in the end of each month the number of dresses in it doubles i e the number of dresses becomes twice as large as it is in the beginning of the month Unfortunately right after the doubling the wardrobe eats one of the dresses if any with the probability It happens every month except the last one in the year Nastya owns dresses now so she became interested in the expected number of dresses she will have in one year Nastya lives in Byteland so the year lasts for months Nastya is really busy so she wants you to solve this problem You are the programmer after all Also you should find the answer modulo because it is easy to see that it is always integer ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int m>\nstruct modint {\n\n\tunsigned x;\n\n\tmodint() : x(0) {}\n\n\tmodint(long long arg) {\n\t\targ %= m;\n\t\tif (arg < 0) {\n\t\t\tx = arg + m;\n\t\t} else {\n\t\t\tx = arg;\n\t\t}\n\t}\t\n\n\tmodint& operator+= (const modint& other) {\n\t\tx += other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator*= (const modint& other) {\n\t\tx = (x * 1ll * other.x) % m;\n\t\treturn *this;\n\t}\n\n\tmodint& operator-= (const modint& other) {\n\t\tx += m - other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator+ (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp += other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator- (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp -= other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator* (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp *= other;\n\t\treturn tmp;\n\t}\n\n\texplicit operator int () const {\n\t\treturn x;\n\t}\n\n\tmodint& operator++ () {\n\t\t++x;\n\t\tif (x == m) {\n\t\t\tx = 0;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator-- () {\n\t\tif (x == 0) {\n\t\t\tx = m-1;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator++ (int) {\n\t\tmodint tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\n\tmodint operator-- (int) {\n\t\tmodint tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\n\tbool operator== (const modint& other) const {\n\t\treturn x == other.x;\n\t}\n\n\tbool operator!= (const modint& other) const {\n\t\treturn x != other.x;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^ (T arg) const {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg == 1) {\n\t\t\treturn x;\n\t\t}\n\t\tauto t = *this ^ (arg >> 1);\n\t\tt *= t;\n\t\tif (arg & 1) {\n\t\t\tt *= *this;\n\t\t}\n\t\treturn t;\n\t}\n\n\tmodint inv() const {\n\t\treturn *this ^ (m-2);\n\t}\n};\n\nconst int MOD = 1\'000\'000\'007;\ntypedef modint<MOD> mint;\n\ntypedef long long ll;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tll x, k;\n\tcin >> x >> k;\n\n\tif (x == 0)\n\t\treturn cout << ""0\\n"", 0;\n\n\tmint z = x;\n\tz *= mint(2) ^ (k+1);\n\tz -= mint(2) ^ k;\n\tz += 1;\n\n\tcout << (int)z << \'\\n\';\n}']",['math'],1600
https://codeforces.com//contest/1685/problem/B,B. Linguistics,Alina has discovered a weird language which contains only 4 words texttt A texttt B texttt AB texttt BA It also turned out that there are no spaces in this language a sentence is written by just concatenating its words into a single string Alina has found one such sentence s and she is curious is it possible that it consists of precisely a words texttt A b words texttt B c words texttt AB and d words texttt BA In other words determine if it s possible to concatenate these a b c d words in some order so that the resulting string is s Each of the a b c d words must be used exactly once in the concatenation but you can choose the order in which they are concatenated ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\n#define maxn 200005\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\n#define str string\nchar s[maxn];\nint ed[27];\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int x[2];\n        int u, v;\n        scanf(""%d%d%d%d"", &u, &v, &x[0], &x[1]);\n        int cnt[2] = {u + x[0] + x[1], v + x[0] + x[1]};\n        scanf(""%s"", s + 1);\n        int n = strlen(s + 1);\n        for (int i = 1; i <= n; i++) {\n            cnt[s[i] - \'A\'] -= 1;\n        }\n        int flag = 1; \n        int sum = 0;\n        vector<pi> h;\n        if (cnt[0] != 0 || cnt[1] != 0) flag = 0;\n        else {\n            s[n + 1] = \'C\';\n            for (int i = 1; i <= n; ) {\n                int j = i;\n                while (j < n && s[j] != s[j + 1]) j += 1;\n                int clen = j - i + 1;\n                if (clen % 2) sum += clen / 2;\n                else\n                    h.pb(mp(clen, s[i] - \'A\'));\n                i = j + 1;\n            }\n            sort(h.begin(), h.end());\n           // cout << sum << endl;\n            for (auto w : h) {\n                pi v = mp(w.se, w.fi);\n                //cout << v.fi << \' \' << v.se << endl;\n                int tr = v.se / 2;\n                if (x[v.fi] >= tr) x[v.fi] -= tr;\n                else {\n                    int cur = min(x[v.fi], tr);\n                    x[v.fi] -= cur;\n                    tr -= cur; tr -= 1;\n                    x[v.fi ^ 1] -= min(x[v.fi ^ 1], tr);\n                }\n            }\n            if (x[0] + x[1] > sum) flag = 0;\n        }\n        if (flag) printf(""Yes\\n"");\n        else printf(""No\\n"");\n    }\n    return (0-0); //<3\n}']","['greedy', 'implementation', 'sortings', 'strings']",2000
https://codeforces.com//contest/917/problem/C,C. Pollywog,As we all know Dart is some kind of creature from Upside Down world For simplicity we call their kind Dart and other pollywogs are playing a game There are stones in a row numbered from through from left to right At most pollywog may be sitting on each stone at a time Initially the pollywogs are sitting on the first stones one pollywog on each stone Dart and his friends want to end up on the last stones At each second the leftmost pollywog should jump to the right A pollywog can jump at most stones more specifically a pollywog can jump from stone number to stones A pollywog can t jump on an occupied stone Jumping a distance takes amounts of energy from the pollywog Also stones are Each time landing on a special stone takes amounts of energy in addition to the energy for jump from the pollywog could be negative in this case it means the pollywog absorbs amounts of energy Pollywogs want to spend as little energy as possible this value could be negative They re just pollywogs so they asked for your help Tell them the total change in their energy in case they move optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef long long ll;\ntypedef vector<ll> VI;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int M=100;\nconst ll inf=1ll<<60;\nint x,k,n,q,cur,m,p,w,ed;\nint st[400],ps[400],c[100];\nll cost[M][M],g[40][M][M];\nmap<int,VI> dp;\nmap<int,int> hs;\nint cc[10];\nvector<PII> e;\nvoid jumpto(int x) {\n\tx=min(x,ed);\n\tif (cur>=x) return;\n\tVI p=dp[cur];\n\tint d=x-cur;\n\tper(k,0,30) if (d&(1<<k)) {\n\t\tVI q(m,inf);\n\t\trep(i,0,m) rep(j,0,m) q[j]=min(q[j],p[i]+g[k][i][j]);\n\t\tp=q;\n\t}\n\tdp[x]=p;\n\tcur=x;\n}\nvoid moveto(int x) {\n\tx=min(x,ed);\n\tif (cur>=x) return;\n\tVI p=dp[cur];\n\trep(y,cur,x) {\n\t\tVI q(m,inf);\n\t\trep(j,1,k+1) if (hs.count(y+j)) cc[j]=hs[y+j]; else cc[j]=0;\n\t\trep(i,0,m) {\n\t\t\tint S=st[i];\n\t\t\tif (S%2==0) q[ps[S>>1]]=min(q[ps[S>>1]],p[i]);\n\t\t\telse {\n\t\t\t\trep(j,1,k+1) {\n\t\t\t\t\tS=st[i]^1; int cs=c[j]+cc[j];\n\t\t\t\t\tif ((S&(1<<j))==0) {\n\t\t\t\t\t\tS|=(1<<j); S>>=1;\n\t\t\t\t\t\tq[ps[S]]=min(q[ps[S]],p[i]+cs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp=q;\n\t}\n\tdp[x]=p;\n\tcur=x;\n}\nint main() {\n\tscanf(""%d%d%d%d"",&x,&k,&n,&q);\n\trep(S,0,(1<<k)) if (__builtin_popcount(S)==x) st[ps[S]=m++]=S;\n\trep(i,1,k+1) scanf(""%d"",c+i);\n\trep(i,0,m) rep(j,0,m) cost[i][j]=inf;\n\trep(i,0,m) {\n\t\tif (st[i]%2==0) cost[i][ps[st[i]>>1]]=0;\n\t\telse rep(j,1,k+1) {\n\t\t\tint S=st[i]; S^=1;\n\t\t\tif ((S&(1<<j))==0) {\n\t\t\t\tS|=(1<<j); S>>=1;\n\t\t\t\tcost[i][ps[S]]=c[j];\n\t\t\t}\n\t\t}\n\t}\n\ted=n-x+1;\n\trep(it,0,30) {\n\t\tif (it==0) {\n\t\t\trep(i,0,m) rep(j,0,m) g[it][i][j]=cost[i][j];\n\t\t} else {\n\t\t\trep(i,0,m) rep(j,0,m) g[it][i][j]=inf;\n\t\t\trep(k,0,m) {\n\t\t\t\trep(i,0,m) rep(j,0,m) rep(k,0,m) g[it][i][j]=min(g[it][i][j],g[it-1][i][k]+g[it-1][k][j]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,q) {\n\t\tscanf(""%d%d"",&p,&w); e.pb(mp(p,w));\n\t\ths[p]=w;\n\t}\n\tsort(all(e));\n\tdp[1]=VI(m,inf); dp[1][0]=0;\n\tcur=1;\n\trep(i,0,q) {\n\t\tjumpto(e[i].fi-k);\n\t\tmoveto(e[i].fi+1);\n\t}\n\tjumpto(n-x+1);\n\tprintf(""%lld\\n"",dp[n-x+1][0]);\n}\n']","['combinatorics', 'dp', 'matrices']",2900
https://codeforces.com//contest/990/problem/C,C. Bracket Sequences Concatenation Problem,A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters 1 and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are 1 1 1 1 1 and and are not You are given n bracket sequences s 1 s 2 dots s n Calculate the number of pairs i j 1 le i j le n such that the bracket sequence s i s j is a regular bracket sequence Operation means concatenation i e If s i s j and s j s i are regular bracket sequences and i ne j then both pairs i j and j i must be counted in the answer Also if s i s i is a regular bracket sequence the pair i i must be counted in the answer ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 800015;\nconst int nil = 400005;\n\nchar tmp[Maxn];\nint n;\nint st[Maxn], mn[Maxn];\nvector <int> V[Maxn];\nll res;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%s"", tmp); int tlen = strlen(tmp);\n\t\tmn[i] = Maxn;\n\t\tfor (int j = 0; j < tlen; j++) {\n\t\t\tif (tmp[j] == \'(\') st[i]++;\n\t\t\telse st[i]--;\n\t\t\tmn[i] = min(mn[i], st[i]);\n\t\t}\n\t\tV[st[i] + nil].push_back(mn[i]);\n\t}\n\tfor (int i = 0; i < Maxn; i++) if (V[i].size())\n\t\tsort(V[i].begin(), V[i].end());\n\tfor (int i = 0; i < n; i++) if (mn[i] >= 0) {\n\t\tint ost = nil - st[i];\n\t\tint add = V[ost].end() - lower_bound(V[ost].begin(), V[ost].end(), -st[i]);\n\t\tres += add;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}']",['implementation'],1500
https://codeforces.com//contest/434/problem/C,C. Tachibana Kanade s Tofu,Tachibana Kanade likes Mapo Tofu very much One day the canteen cooked all kinds of tofu to sell but not all tofu is Mapo Tofu only those spicy enough can be called Mapo Tofu Each piece of tofu in the canteen is given a based number all numbers are in the range and being based numbers and for every based integer in the range there exists a piece of tofu with that number To judge what tofu is Mapo Tofu Tachibana Kanade chose based number strings and assigned a value to each string If a string appears in the number of a tofu the value of the string will be added to the value of that tofu If a string appears multiple times then the value is also added that many times Initially the value of each tofu is zero Tachibana Kanade considers tofu with values no more than to be Mapo Tofu So now Tachibana Kanade wants to know how many pieces of tofu are Mapo Tofu ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 200 + 10;\nconst int MAX_M = 20 + 1;\nconst int MAX_K = 500 + 10;\nconst int MOD = 1000000007;\nint n, m, k;\n\nconst int CHARSET = 20;\nconst int MAX_N_NODES = int(3e5) + 10;\n\nint pointer;\nstruct Node {\n\tNode*ch[CHARSET], *fail, *par;\n\tNode*jump[CHARSET];\n\n\tint end;\n\tNode() {\n\t\tmemset(ch, 0, sizeof ch);\n\t\tfail = 0;\n\t\tend = 0;\n\t}\n\tNode*go(int w);\n}*root;\n\nNode nodePool[MAX_N_NODES], *cur;\nconst int MAX_ID = 400 + 10;\n\nint getId(Node*u) {\n\treturn u - nodePool;\n}\n\nNode*newNode() {\n\tNode*t = cur++;\n\tmemset(t->ch, 0, sizeof t->ch);\n\tt->fail = 0;\n\treturn t;\n}\n\nNode* Node::go(int w) {\n\tif (ch[w] == 0) {\n\t\tch[w] = newNode();\n\t\tch[w]->par = this;\n\t}\n\treturn ch[w];\n}\n\nvoid init() {\n\tcur = nodePool;\n\troot = newNode();\n\troot->par = 0;\n}\n\nvoid build() {\n\tstatic Node*que[MAX_N_NODES];\n\tint qh = 0, qt = 0;\n\tque[qt++] = root;\n\twhile (qh < qt) {\n\t\tNode*t = que[qh++];\n\t\tfor (int c = 0; c < CHARSET; ++c) {\n\t\t\tNode*v = t->ch[c];\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tNode*f = t->fail;\n\t\t\twhile (f && f->ch[c] == 0)\n\t\t\t\tf = f->fail;\n\t\t\tif (f == 0)\n\t\t\t\tv->fail = root;\n\t\t\telse\n\t\t\t\tv->fail = f->ch[c];\n\t\t\tque[qt++] = v;\n\t\t}\n\t}\n\t//calculate JUMP\n\tfor (int j = 0; j < m; ++j) {\n\t\troot->jump[j] = root->ch[j] ? root->ch[j] : root;\n//\t\tif (root->jump[j] == 0)\n//\t\t\troot->jump[j] = root;\n\t}\n\n\tfor (int i = 1; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (u->ch[j])\n\t\t\t\tu->jump[j] = u->ch[j];\n\t\t\telse\n\t\t\t\tu->jump[j] = u->fail->jump[j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tif (u->fail)\n\t\t\tu->end += u->fail->end;\n\t}\n}\n\nvector<int> L, R;\n\nvector<int> str[MAX_N];\nint v[MAX_N];\n\nvoid read(vector<int>&arr) {\n\tint n;\n\tcin >> n;\n\tarr.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i];\n\t}\n}\n\nint memo[202][410][501];\n\nint rec(int at, bool leadingZero, bool sameL, bool sameR, Node*u, int have) {\n\thave += u->end;\n\tif (have > k)\n\t\treturn 0;\n\n\tif (at == L.size()) {\n\t\treturn 1;\n\t}\n\n\tbool save = !(sameL || sameR);\n\tint ret = 0;\n\tif (save) {\n\t\tret = memo[at][getId(u)][have];\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t\tret = 0;\n\t}\n\n\tfor (int nxt = 0; nxt < m; ++nxt) { //nxt digit\n\t\tif (sameL && nxt < L[at])\n\t\t\tcontinue;\n\t\tif (sameR && nxt > R[at])\n\t\t\tcontinue;\n\t\tNode*nu = u;\n\t\tif (!leadingZero || nxt > 0)\n\t\t\tnu = u->jump[nxt];\n\n\t\tret += rec(at + 1, leadingZero && (nxt == 0), sameL && (nxt == L[at]),\n\t\t\t\tsameR && (nxt == R[at]), nu, have);\n\t\tif (ret >= MOD)\n\t\t\tret -= MOD;\n\t}\n\n\tif (save) {\n\t\tmemo[at][getId(u)][have] = ret;\n\t}\n\n\treturn ret;\n}\n\nint main() {\n//\tcout << sizeof(memo) / (1024 * 1024.0) << endl;\n\tcin >> n >> m >> k;\n\tread(L), read(R);\n\twhile (L.size() < R.size())\n\t\tL.insert(L.begin(), 0);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tread(str[i]);\n\t\tcin >> v[i];\n\t}\n\tinit();\n\tfor (int i = 0; i < n; ++i) {\n\t\tNode*u = root;\n\t\tfor (int j = 0; j < str[i].size(); ++j) {\n\t\t\tu = u->go(str[i][j]);\n\t\t}\n\t\tu->end += v[i];\n\t}\n\tbuild();\n\tmemset(memo, -1, sizeof memo);\n\tint ans = rec(0, true, true, true, root, 0);\n\tcout << ans << endl;\n}\n']",['dp'],2500
https://codeforces.com//contest/1665/problem/B,B. Array Cloning Technique,You are given an array a of n integers Initially there is only one copy of the given array You can do operations of two types Choose any array and clone it After that there is one more copy of the chosen array Swap two elements from two copies maybe in the same copy on any positions You need to find the minimal number of operations needed to obtain a copy where all elements are equal ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nmap <int,int> mp;\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tint mx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tmx=max(mx,++mp[x]);\n\t\t}\n\t\tmp.clear();\n\t\tint ans=n-mx;\n\t\twhile(mx<n) ++ans,mx*=2;\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'greedy', 'sortings']",900
https://codeforces.com//contest/1364/problem/B,B. Most socially-distanced subsequence,Given a permutation p of length n find its subsequence s 1 s 2 ldots s k of length at least 2 such that s 1 s 2 s 2 s 3 ldots s k 1 s k is as big as possible over all subsequences of p with length at least 2 Among all such subsequences choose the one whose length k is as small as possible If multiple subsequences satisfy these conditions you are allowed to find any of them A sequence a is a subsequence of an array b if a can be obtained from b by deleting some possibly zero or all elements A permutation of length n is an array of length n in which every element from 1 to n occurs exactly once ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto &i : a) {\n      cin >> i;\n    }\n    int i = 0;\n    vector<int> res;\n    while (true) {\n      res.emplace_back(a[i]);\n      int j = i + 1;\n      if (j == n) {\n        break;\n      } else if (a[j] > a[i]) {\n        while (a[j] > a[j - 1] && j < n) {\n          j++;\n        }\n        i = j - 1;\n      } else {\n        while (a[j] < a[j - 1] && j < n) {\n          j++;\n        }\n        i = j - 1;\n      }\n    }\n    cout << res.size() << '\\n';\n    for (const auto &j : res) {\n      cout << j << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n""]","['greedy', 'two pointers']",1300
https://codeforces.com//contest/866/problem/C,C. Gotta Go Fast,You re trying to set the record on your favorite video game The game consists of levels which must be completed sequentially in order to beat the game You usually complete each level as fast as possible but sometimes finish a level slower Specifically you will complete the th level in either seconds or seconds where and there s a percent chance of completing it in seconds After completing a level you may decide to either continue the game and play the next level or reset the game and start again from the first level Both the decision and the action are instant Your goal is to complete all the levels sequentially in at most total seconds You want to minimize the expected amount of time playing before achieving that goal If you continue and reset optimally how much total time can you expect to spend playing ,"['/**\n *    author:  tourist\n *    created: 30.09.2017 20:16:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 55;\nconst int MAX = 12345;\n\nint a[N], b[N], p[N], sum_b[N];\ndouble f[N][MAX];\n\nint main() {\n  int n, r;\n  scanf(""%d %d"", &n, &r);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d %d %d"", a + i, b + i, p + i);\n  }\n  sum_b[0] = 0;\n  for (int i = 0; i < n; i++) {\n    sum_b[i + 1] = sum_b[i] + b[i];\n  }\n  double low = 0.0, high = 1e15;\n  for (int it = 0; it < 120; it++) {\n    double mid = (low + high) * 0.5;\n    for (int i = n; i >= 0; i--) {\n      for (int j = 0; j <= sum_b[i]; j++) {\n        if (i == n) {\n          f[i][j] = (j <= r ? 0.0 : mid);\n          continue;\n        }\n        f[i][j] = 0.01 * ((f[i + 1][j + a[i]] + a[i]) * p[i] + (f[i + 1][j + b[i]] + b[i]) * (100 - p[i]));\n        if (i > 0) {\n          f[i][j] = min(f[i][j], mid);\n        }\n      }\n    }\n    if (f[0][0] > mid) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  double ans = 0.5 * (low + high);\n  printf(""%.17f\\n"", ans);\n  return 0;\n}\n']","['binary search', 'dp', 'probabilities']",2400
https://codeforces.com//contest/731/problem/C,C. Socks,Arseniy is already grown up and independent His mother decided to leave him alone for days and left on a vacation She have prepared a lot of food left some money and washed all Arseniy s clothes Ten minutes before her leave she realized that it would be also useful to prepare instruction of which particular clothes to wear on each of the days she will be absent Arseniy s family is a bit weird so all the clothes is enumerated For example each of Arseniy s socks is assigned a unique integer from to Thus the only thing his mother had to do was to write down two integers and for each of the days the indices of socks to wear on the day obviously stands for the left foot and for the right Each sock is painted in one of colors When mother already left Arseniy noticed that according to instruction he would wear the socks of different colors on some days Of course that is a terrible mistake cause by a rush Arseniy is a smart boy and by some magical coincidence he posses jars with the paint one for each of colors Arseniy wants to repaint some of the socks in such a way that for each of days he can follow the mother s instructions and wear the socks of the same color As he is going to be very busy these days he will have no time to change the colors of any socks so he has to finalize the colors now The new computer game Bota 3 was just realised and Arseniy can t wait to play it What is the minimum number of socks that need their color to be changed in order to make it possible to follow mother s instructions and wear the socks of the same color during each of days ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)2e5+5;\n\nint sz[N],p[N],n,m,k,c[N],a,b,ans,gr,maxi;\nmap <int,int> s[N];\n\nint get(int x)\n{\n\tif(p[x]==x) return x;\n\tp[x]=get(p[x]);\n\treturn p[x];\n}\n\nvoid unite(int a,int b)\n{\n\ta=get(a);\n\tb=get(b);\n\tif(a==b) return;\n\tif(sz[p[a]]<sz[p[b]])\n\t{\n\t\tsz[p[b]]+=sz[p[a]];\n\t\tp[p[a]]=p[b];\n\t} else\n\t{\n\t\tsz[p[a]]+=sz[p[b]];\n\t\tp[p[b]]=p[a];\n\t}\n}\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n >> m >> k;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin >> c[i];\n\t\tc[i]--;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tp[i]=i;\n\t\tsz[i]=1;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tunite(a,b);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tget(i);\n\t\tgr=p[i];\n\t\ts[gr][c[i]]++;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(p[i]!=i)continue;\n\t\tmaxi=0;\n\t\tfor(auto it=s[i].begin();it!=s[i].end();it++)\n\t\t\tmaxi=max(maxi,it->second);\n\t\tans+=sz[i]-maxi;\n\t}\n\tcout << ans;\n\t\n\treturn 0;\n}\n']","['dfs and similar', 'dsu', 'graphs', 'greedy']",1600
https://codeforces.com//contest/1439/problem/E,E. Cheat and Win,Let s consider a 10 9 1 times 10 9 1 field The rows are numbered with integers from 0 to 10 9 and the columns are numbered with integers from 0 to 10 9 Let s define as x y the cell located in the x th row and y th column Let s call a cell x y good if x y 0 there is the bitwise and operation Let s build a graph where vertices will be all good cells of the field and we will make an edge between all pairs of adjacent by side good cells It can be proved that this graph will be a tree connected graph without cycles Let s hang this tree on vertex 0 0 so we will have a rooted tree with root 0 0 Two players will play the game Initially some good cells are black and others are white Each player on his turn chooses a black good cell and a subset of its ancestors possibly empty and inverts their colors from white to black and vice versa The player who can t move because all good cells are white loses It can be proved that the game is always finite Initially all cells are white You are given m pairs of cells For each pair color all cells in a simple path between them as black Note that we do not invert their colors we paint them black Sohrab and Mashtali are going to play this game Sohrab is the first player and Mashtali is the second Mashtali wants to win and decided to cheat He can make the following operation multiple times before the game starts choose a cell and invert colors of all vertices on the path between it and the root of the tree Mammad who was watching them wondered what is the minimum number of operations Mashtali should do to have a winning strategy Find the answer to this question for the initial painting of the tree It can be proved that at least one possible way to cheat always exists ,"[""#include <bits/extc++.h>\n\nstruct splitmix64_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\t// http://xorshift.di.unimi.it/splitmix64.c\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\n\ntemplate <typename K, typename V, typename Hash = splitmix64_hash>\nusing hash_map = __gnu_pbds::gp_hash_table<K, V, Hash>;\n\ntemplate <typename K, typename Hash = splitmix64_hash>\nusing hash_set = hash_map<K, __gnu_pbds::null_type, Hash>;\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tbool has_root = false;\n\thash_map<int, vector<pair<int, int>>> mp;\n\n\tauto get_jmp = [&](array<int, 2> p) -> pair<bool, array<int, 2>> {\n\t\tassert(!(p[0] & p[1]));\n\t\tif (p[0] == 0 && p[1] == 0) {\n\t\t\treturn {false, {-1,0}};\n\t\t}\n\t\tif (!((p[0]-1) & p[1])) {\n\t\t\t// decrease 0\n\t\t\treturn {false, {p[0] & ~(p[1]-1), p[1]}};\n\t\t} else {\n\t\t\treturn {true, {p[0], p[1] & ~(p[0]-1)}};\n\t\t}\n\t};\n\tauto dep = [&](array<int, 2> p) { return p[0] + p[1]; };\n\n\tint M; cin >> M;\n\twhile (M--) {\n\t\tarray<int, 2> v1, v2; cin >> v1[0] >> v1[1] >> v2[0] >> v2[1];\n\t\twhile (true) {\n\t\t\tif (dep(v1) == 0 && dep(v2) == 0) {\n\t\t\t\thas_root = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tauto [d1, n1] = get_jmp(v1);\n\t\t\tauto [d2, n2] = get_jmp(v2);\n\t\t\tassert(n1[!d1] == v1[!d1]);\n\t\t\tassert(n2[!d2] == v2[!d2]);\n\n\t\t\tif (d1 == d2 && n1 == n2) {\n\t\t\t\t// get the deeper of the two\n\t\t\t\tint x1 = dep(v1), x2 = dep(v2);\n\t\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\t\tassert(x1 <= x2);\n\t\t\t\tmp[n1[!d1] * 2 + d1].push_back({x1-1, x2});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dep(n1) > dep(n2)) { swap(n1, n2), swap(d1, d2), swap(v1, v2); }\n\t\t\tassert(dep(n1) <= dep(n2));\n\n\t\t\tmp[n2[!d2] * 2 + d2].push_back({dep(n2), dep(v2)});\n\t\t\tv2 = n2;\n\t\t}\n\t}\n\n\thash_map<int, bool> tot_flip;\n\n\tif (has_root) tot_flip[0] ^= 1;\n\tfor (auto& [_, vec] : mp) {\n\t\tsort(vec.begin(), vec.end());\n\t\tint cur_hi = -1;\n\t\tfor (auto it : vec) {\n\t\t\tif (it.first > cur_hi) {\n\t\t\t\tif (cur_hi >= 0) tot_flip[cur_hi] ^= 1;\n\t\t\t\ttot_flip[it.first] ^= 1;\n\t\t\t}\n\t\t\tcur_hi = max(cur_hi, it.second);\n\t\t}\n\t\tif (cur_hi >= 0) {\n\t\t\ttot_flip[cur_hi] ^= 1;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (auto it : tot_flip) {\n\t\tif (it.second) {\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n""]","['bitmasks', 'data structures', 'games', 'trees']",3500
https://codeforces.com//contest/1537/problem/A,A. Arithmetic Array,An array b of length k is called good if its arithmetic mean is equal to 1 More formally if frac b 1 cdots b k k 1 Note that the value frac b 1 cdots b k k is not rounded up or down For example the array 1 1 1 2 has an arithmetic mean of 1 25 which is not equal to 1 You are given an integer array a of length n In an operation you can append a integer to the end of the array What s the minimum number of operations required to make the array good We have a proof that it is always possible with finitely many operations ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include ""map""\ntypedef double ld;\ntypedef long long ll;\n#define all(x) x.begin(), x.end()\nusing namespace std;\nvoid solve() {\n    int n;\n    cin >> n;\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        int b;\n        cin >> b;\n        res += b;\n    }\n    res -= n;\n    if (res == 0) {\n        cout << ""0\\n"";\n    } else if (res < 0) {\n        cout << ""1\\n"";\n    } else {\n        cout << res << \'\\n\';\n    }\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q;\n    cin >> q;\n    while (q--) solve();\n}\n']","['greedy', 'math']",800
https://codeforces.com//contest/1520/problem/D,D. Same Differences,You are given an array a of n integers Count the number of pairs of indices i j such that i j and a j a i j i ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl ""\\n""\n\n#define sz(x) int((x).size())\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tint arr[n];\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> arr[i];\n\t}\n\tlong ans = 0;\n\tmap<int, int> cnt;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x = arr[i] - i;\n\t\tans += cnt[x];\n\t\tcnt[x]++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']","['data structures', 'hashing', 'math']",1200
https://codeforces.com//contest/1300/problem/A,A. Non-zero,Guy Manuel and Thomas have an array a of n integers a 1 a 2 dots a n In one step they can add 1 to any element of the array Formally in one step they can choose any integer index i 1 le i le n and do a i a i 1 What is the minimum number of steps they need to do to make both the sum and the product of all elements in the array Formally find the minimum number of steps to make a 1 a 2 dots a n ne 0 and a 1 cdot a 2 cdot dots cdot a n ne 0 ,"['#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < \'0\' || ch > \'9\') && ch != \'-\') ch = getchar();\n\tif(ch == \'-\'){f = true; ch = getchar();}\n\twhile(ch >= \'0\' && ch <= \'9\'){x = x * 10 + ch - \'0\'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nint t, n, x, cnt, sum; \nint main(){\n\tread(t);\n\twhile(t --){\n\t\tread(n); cnt = sum = 0;\n\t\tfor(Rint i = 1;i <= n;++ i) read(x), cnt += !x, sum += x + !x;\n\t\tprintf(""%d\\n"", cnt + !sum);\n\t}\n}']","['implementation', 'math']",800
https://codeforces.com//contest/1228/problem/B,B. Filling the Grid,Suppose there is a h times w grid consisting of empty or full cells Let s make some definitions r i is the number of consecutive full cells connected to the left side in the i th row 1 le i le h In particular r i 0 if the leftmost cell of the i th row is empty c j is the number of consecutive full cells connected to the top end in the j th column 1 le j le w In particular c j 0 if the topmost cell of the j th column is empty In other words the i th row starts exactly with r i full cells Similarly the j th column starts exactly with c j full cells You have values of r and c Initially all cells are empty Find the number of ways to fill grid cells to satisfy values of r and c Since the answer can be very large find the answer modulo 1000000007 10 9 7 In other words find the remainder after division of the answer by 1000000007 10 9 7 ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1010, P = 1000000007;\n\nint vis[N][N];\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  int n, m;\n  scanf(""%d%d"", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int r;\n    scanf(""%d"", &r);\n    for (int j = 1; j <= r; ++j)\n      vis[i][j] = 1;\n    vis[i][r + 1] = -1;\n  }\n  for (int j = 1; j <= m; ++j) {\n    int c;\n    scanf(""%d"", &c);\n    for (int i = 1; i <= c; ++i)\n      if (vis[i][j] == -1) {\n        puts(""0"");\n        return 0;\n      } else\n        vis[i][j] = 1;\n    if (vis[c + 1][j] == 1) {\n      puts(""0"");\n      return 0;\n    }\n    vis[c + 1][j] = -1;\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (vis[i][j] == 0)\n        ans = ans * 2 % P;\n  printf(""%d\\n"", ans);\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']","['implementation', 'math']",1400
https://codeforces.com//contest/1795/problem/F,F. Blocking Chips,You are given a tree consisting of n vertices There are k chips placed in vertices a 1 a 2 dots a k All a i are distinct Vertices a 1 a 2 dots a k are colored black initially The remaining vertices are white You are going to play a game where you perform some moves possibly zero On the i th move 1 indexed you are going to move the i 1 bmod k 1 st chip from its current vertex to an adjacent vertex and color that vertex So if k 3 you move chip 1 on move 1 chip 2 on move 2 chip 3 on move 3 chip 1 on move 4 chip 2 on move 5 and so on If there is no adjacent white vertex then the game ends What s the maximum number of moves you can perform ,"['/**\n *    author:  tourist\n *    created: 16.02.2023 18:44:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> que(1, 0);\n    vector<int> pv(n, -1);\n    pv[0] = -2;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (pv[u] == -1) {\n          que.push_back(u);\n          pv[u] = que[b];\n        }\n      }\n    }\n    int k;\n    cin >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    int low = 0, high = n;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      vector<int> val(n, -1);\n      for (int i = 0; i < k; i++) {\n        val[a[i]] = mid / k + (i < mid % k);\n      }\n      bool ok = true;\n      vector<int> down(n, 0);\n      for (int it = n - 1; it >= 0; it--) {\n        int i = que[it];\n        if (val[i] >= 0) {\n          if (down[i] < val[i]) {\n            if (pv[i] < 0) {\n              ok = false;\n              break;\n            }\n            if (val[pv[i]] >= 0) {\n              ok = false;\n              break;\n            }\n            val[pv[i]] = val[i] - 1;\n          }\n        } else {\n          if (pv[i] >= 0) {\n            down[pv[i]] = max(down[pv[i]], down[i] + 1);\n          }\n        }\n      }\n      if (ok) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << \'\\n\';\n  }\n  return 0;\n}\n']","['binary search', 'constructive algorithms', 'dfs and similar', 'greedy', 'trees']",2400
https://codeforces.com//contest/1843/problem/B,B. Long Long,Today Alex was brought array a 1 a 2 dots a n of length n He can apply as many operations as he wants including zero operations to change the array elements In 1 operation Alex can choose any l and r such that 1 leq l leq r leq n and multiply all elements of the array from l to r inclusive by 1 In other words Alex can replace the subarray a l a l 1 dots a r by a l a l 1 dots a r in 1 operation For example let n 5 the array is 1 2 0 3 1 l 2 and r 4 then after the operation the array will be 1 2 0 3 1 Alex is late for school so you should help him find the maximum possible sum of numbers in the array which can be obtained by making any number of operations as well as the minimum number of operations that must be done for this ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint a[N];\nvoid solve()\n{\n\tn=read();\tll ans=0;\tll tot=0;\n\tfor(int i=1;i<=n;++i)\ta[i]=read();\n\tbool flag=false;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tans+=abs(a[i]);\n\t\tif(a[i]>0)\tflag=false;\n\t\tif(a[i]<0)\n\t\t{\n\t\t\tif(!flag)\tflag=true,++tot;\n\t\t}\n\t}\n\tprintf(""%lld %lld\\n"",ans,tot);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}']","['greedy', 'math', 'two pointers']",800
https://codeforces.com//contest/533/problem/C,C. Board Game,Polycarp and Vasiliy love simple logical games Today they play a game with infinite chessboard and one pawn for each player Polycarp and Vasiliy move in turns Polycarp starts In each turn Polycarp can move his pawn from cell to or Vasiliy can move his pawn from to one of cells and are also allowed to skip move There are some additional restrictions a player is forbidden to move his pawn to a cell with negative coordinate or coordinate or to the cell containing opponent s pawn The winner is the first person to reach cell You are given the starting coordinates of both pawns Determine who will win if both of them play optimally well ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\nint X1,Y1,X2,Y2;\nvoid spr(){\n  int ruchy = X2 - X1;\n  if(ruchy <= 0)return;\n  int yy = max(0,Y2-ruchy);\n  int ruchy2 = Y1 - yy;\n  if(ruchy2 <= ruchy){\n    puts(""Polycarp"");\n    exit(0);\n  }\n}\nmain(){\n  make2(X1,Y1);\n  make2(X2,Y2);\n  spr();\n  swap(X1,Y1);\n  swap(X2,Y2);\n  spr();\n  puts(""Vasiliy"");\n  \n}']","['games', 'greedy', 'implementation', 'math']",1700
https://codeforces.com//contest/1409/problem/E,E. Two Platforms,There are n points on a plane The i th point has coordinates x i y i You have two horizontal platforms both of length k Each platform can be placed anywhere on a plane but it should be placed on the same y coordinate and have If the left border of the platform is x y then the right border is x k y and all points between borders including borders belong to the platform Note that platforms can share common points overlap and it is not necessary to place both platforms on the same y coordinate When you place both platforms on a plane all points start falling down decreasing their y coordinate If a point collides with some platform at some moment the point stops and is Points which never collide with any platform are lost Your task is to find the maximum number of points you can if you place both platforms optimally You have to answer t independent test cases For better understanding please read the section below to see a picture for the first test case ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long lli;\ntypedef pair<int, int> ii;\ntypedef pair<lli, lli> ll;\n\nint x[200005], len[200005], suff[200005];\n\nint main() {\n\tint tc, n, k, y, r, temp, maxi;\n\tscanf(""%d"", &tc);\n\twhile (tc--) {\n\t\tscanf(""%d %d"", &n, &k);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(""%d"", &x[i]);\n\t\tsort(x, x + n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(""%d"", &y);\n\t\tr = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (r + 1 < n) {\n\t\t\t\tif (x[r + 1] > x[i] + k)\n\t\t\t\t\tbreak;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tlen[i] = r - i + 1;\n\t\t}\n\t\tsuff[n - 1] = len[n - 1];\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tsuff[i] = max(suff[i + 1], len[i]);\n\t\tmaxi = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttemp = len[i];\n\t\t\tr = i + temp;\n\t\t\tif (r < n)\n\t\t\t\ttemp += suff[r];\n\t\t\tmaxi = max(maxi, temp);\n\t\t}\n\t\tprintf(""%d\\n"", maxi);\n\t}\n\treturn 0;\n}']","['binary search', 'dp', 'sortings', 'two pointers']",1800
https://codeforces.com//contest/534/problem/C,C. Polycarpus  Dice,Polycarp has dice The th dice shows numbers from to Polycarp rolled all the dice and the sum of numbers they showed is Agrippina didn t see which dice showed what number she knows only the sum and the values However she finds it enough to make a series of statements of the following type dice couldn t show number For example if Polycarp had two six faced dice and the total sum is then Agrippina can state that each of the two dice couldn t show a value less than five otherwise the remaining dice must have a value of at least seven which is impossible For each dice find the number of values for which it can be guaranteed that the dice couldn t show these values if the sum of the shown values is ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define For(i,a,b) for(int i=a;i<b;i++)\n#define pb push_back\n#define mod 1000000007\n#define reset(s,val) memset(s,val,sizeof(s))\n#define eps 0.0000001\n#define pi acos(-1)\n#define sqr(x) (x)*(x)\n#define maxn 32000\n\nlong long n,a,lis[200005],s,mi,ma;\n\nint main( ){\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    cin>>n>>a;\n    s=0;\n    For(i,0,n)\n    {\n        cin>>lis[i];\n        s+=lis[i];\n    }\n    For(i,0,n)\n    {\n        mi=max(1ll,a-s+lis[i]);\n        ma=min(lis[i],a-n+1);\n        //cout<<mi<<ma<<endl;\n        cout<<lis[i]-ma+mi-1<<\' \';\n    }\n}\n']",['math'],1600
https://codeforces.com//contest/743/problem/B,B. Chloe and the sequence ,Chloe the same as Vladik is a competitive programmer She didn t have any problems to get to the olympiad like Vladik but she was confused by the task proposed on the olympiad Let s consider the following algorithm of generating a sequence of integers Initially we have a sequence consisting of a single element equal to Then we perform steps On each step we take the sequence we ve got on the previous step append it to the end of itself and insert in the middle the minimum positive integer we haven t used before For example we get the sequence after the first step the sequence after the second step The task is to find the value of the element with index the elements are numbered from in the obtained sequence i e after steps Please help Chloe to solve the problem ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,k;\n\nlong long get(long long n, long long k) {\n    long long length=(1ll<<n)-1;\n    if(length/2+1==k) return n;\n    else if(k<=length/2) return get(n-1,k);\n    else return get(n-1,k-length/2-1);\n}\n\nint main() {\n    scanf(""%lld %lld"", &n, &k);\n    printf(""%lld\\n"", get(n,k));\n\n    return 0;\n}\n']","['binary search', 'bitmasks', 'constructive algorithms', 'implementation']",1200
https://codeforces.com//contest/1915/problem/A,A. Odd One Out,You are given three digits a b c Two of them are equal but the third one is different from the other two Find the value that occurs exactly once ,"['#include ""bits/stdc++.h""\nusing namespace std;       \n\n// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\nusing ll = long long;\nusing ld = long double;\n#define pb push_back\n#define ff first\n#define ss second\n#define sz(x) (ll)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nvoid freopen(string s) { freopen((s+"".in"").c_str(), ""r"", stdin); freopen((s+"".out"").c_str(), ""w"", stdout); }\nvoid IOIGold2024_InshAllah() { ios_base::sync_with_stdio(false); cin.tie(NULL); }\nll binmul(ll a, ll b, ll c) { ll res = 0; while(b) { if(b&1) (res += a) %= c; (a += a) %= c; b >>= 1; } return res; }\nll binpow(ll a, ll b, ll c) { ll res = 1; while(b) { if(b&1) (res *= a) %= c; (a *= a) %= c; b >>= 1; } return res; }\ntemplate<typename T> T gcd(T a, T b) { if(b==0) return a; return gcd(b, a%b); }\ntemplate<typename T> T lcm(T a, T b) { return a/gcd(a, b)*b; }\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nld rnd() { return rng()%INT_MAX*1.0/INT_MAX; }\n\nconst ll inf = 1e18+7, MX = LLONG_MAX, MN = LLONG_MIN;\nconst ll mod = 1e9+7, N = 3e5+5;\n\nvoid kigash() {\n    ll a, b, c;\n    cin>>a>>b>>c;\n    if(a!=b && a!=c) cout<<a<<""\\n"";\n    else if(a!=b && c!=b) cout<<b<<""\\n"";\n    else cout<<c<<""\\n"";\n    return;\n}\n\nsigned main(/*Kigash Amir*/) {\n    // freopen("""");\n    IOIGold2024_InshAllah();\n    ll tt = 1;\n    cin>>tt;\n    for(ll i=1; i<=tt; i++) {\n        kigash();\n    }\n}']","['bitmasks', 'implementation']",800
https://codeforces.com//contest/1499/problem/D,D. The Number of Pairs,You are given three positive greater than zero integers c d and x You have to find the number of pairs of positive integers a b such that equality c cdot lcm a b d cdot gcd a b x holds Where lcm a b is the least common multiple of a and b and gcd a b is the greatest common divisor of a and b ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MX = 20000000;\n\nvector<int> primes;\nint sieve[20202020];\nll ans;\nint c, d, x;\n\nvoid f(int g) {\n\tint y = (x / g + d);\n\tif(y % c) return;\n\ty /= c;\n\tint cnt = 0, last = 0;\n\twhile(y > 1) {\n\t\tint t = sieve[y];\n\t\tif(last != t) { cnt++; last = t; }\n\t\ty /= t;\n\t}\n\tans += (1 << cnt);\n}\n\nint main() {\n\tfor(int i = 2; i <= MX; i++) {\n\t\tif(!sieve[i]) { sieve[i] = i; primes.push_back(i); }\n\t\tfor(int j : primes) {\n\t\t\tif(i * j > MX) break;\n\t\t\tsieve[i * j] = j;\n\t\t\tif(i % j == 0) break;\n\t\t}\n\t}\n\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%d%d%d"", &c, &d, &x);\n\t\tans = 0;\n\t\tfor(int i = 1; i * i <= x; i++) {\n\t\t\tif(x % i) continue;\n\t\t\tf(i);\n\t\t\tif(i != x / i) f(x / i);\n\t\t}\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\treturn 0;\n}']","['dp', 'math', 'number theory']",2100
https://codeforces.com//contest/1238/problem/B,B. Kill 'Em All,Ivan plays an old action game called Heretic He s stuck on one of the final levels of this game so he needs some help with killing the monsters The main part of the level is a large corridor so large and narrow that it can be represented as an infinite coordinate line The corridor is divided into two parts let s assume that the point x 0 is where these parts meet The right part of the corridor is filled with n monsters for each monster its initial coordinate x i is given and since all monsters are in the right part every x i is positive The left part of the corridor is filled with crusher traps If some monster enters the left part of the corridor or the origin so its current coordinate becomes to 0 it gets instantly killed by a trap The main weapon Ivan uses to kill the monsters is the Phoenix Rod It can launch a missile that explodes upon impact obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter Formally suppose that Ivan launches a missile so that it explodes in the point c Then every monster is either killed by explosion or pushed away Let some monster s current coordinate be y then if c y then the monster is killed if y c then the monster is pushed r units to the left so its current coordinate becomes y r if y c then the monster is pushed r units to the right so its current coordinate becomes y r Ivan is going to kill the monsters as follows choose some integer point d and launch a missile into that point then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps then if at least one monster is still alive choose another integer point probably the one that was already used and launch a missile there and so on What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters You may assume that every time Ivan fires the Phoenix Rod he chooses the impact point optimally You have to answer q independent queries ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint q;\nint n,r;\nvector<int>vec;\n\nint main(){\n\tscanf(""%d"",&q);\n\twhile(q--){\n\t\tscanf(""%d%d"",&n,&r); vec.clear();\n\t\trep(i,n){ int a; scanf(""%d"",&a); vec.pb(a); }\n\t\tSORT(vec); ERASE(vec);\n\t\tll gen = 0;\n\t\tfor(int i=vec.size()-1;i>=1;i--){\n\t\t\tgen += r;\n\t\t\tif(vec[i-1] <= gen){\n\t\t\t\tprintf(""%d\\n"",vec.size()-i); goto nxt;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",vec.size()); nxt:;\n\t}\n}']","['greedy', 'sortings']",1300
https://codeforces.com//contest/732/problem/A,A. Buy a Shovel,Polycarp urgently needs a shovel He comes to the shop and chooses an appropriate one The shovel that Policarp chooses is sold for burles Assume that there is an unlimited number of such shovels in the shop In his pocket Polycarp has an unlimited number of 10 burle coins and exactly one coin of burles What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change It is obvious that he can pay for 10 shovels without any change by paying the requied amount of 10 burle coins and not using the coin of burles But perhaps he can buy fewer shovels and pay without any change Note that Polycarp should buy at least one shovel ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint a , b;\nint main(){\n    cin >> a >> b;\n    for(int i=1;i<=10;++i){\n        int x = a * i;\n        if(x % 10 == 0 || x % 10 == b){\n            cout << i << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n']","['brute force', 'constructive algorithms', 'implementation', 'math']",800
https://codeforces.com//contest/961/problem/E,E. Tufurama,One day Polycarp decided to rewatch his absolute favourite episode of well known TV series Tufurama He was pretty surprised when he got results only for season 7 episode 3 with his search query of Watch Tufurama season 3 episode 7 online full hd free This got Polycarp confused what if he decides to rewatch the entire series someday and won t be able to find the right episodes to watch Polycarp now wants to count the number of times he will be forced to search for an episode using some different method TV series have seasons numbered through the th season has episodes numbered through Polycarp thinks that if for some pair of integers and exist both season episode and season episode then one of these search queries will include the wrong results Help Polycarp to calculate the number of such pairs ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint indt[600000];\nvoid update(int p, int v) {\n\tp += IT_MAX;\n\tfor (; p; p /= 2) indt[p] += v;\n}\nint getsum(int p1, int p2) {\n\tp1 += IT_MAX;\n\tp2 += IT_MAX;\n\tint rv = 0;\n\tfor (; p1 <= p2; p1 /= 2, p2 /= 2) {\n\t\tif (p1 % 2 == 1) rv = rv + indt[p1++];\n\t\tif (p2 % 2 == 0) rv = rv + indt[p2--];\n\t}\n\treturn rv;\n}\n\nint in[200050];\n\nvector <int> Vq[200050];\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(""%d"", &in[i]);\n\t\tif (in[i] <= N) Vq[in[i]].push_back(i);\n\t}\n\n\tfor (i = 1; i <= N; i++) update(i, 1);\n\t\n\tll ans = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (auto it : Vq[i - 1]) update(it, -1);\n\t\tans += getsum(i + 1, min(N, in[i]));\n\t}\n\treturn !printf(""%lld\\n"", ans);\n}']",['data structures'],1900
https://codeforces.com//contest/1294/problem/B,B. Collecting Packages,There is a robot in a warehouse and n packages he wants to collect The warehouse can be represented as a coordinate grid Initially the robot stays at the point 0 0 The i th package is at the point x i y i It is guaranteed that there are no two packages at the same point It is also guaranteed that the point 0 0 doesn t contain a package The robot is semi broken and only can move up and right In other words in one move the robot can go from the point x y to the point x 1 y or to the point x y 1 As we say above the robot wants to collect all n packages He wants to do it with the minimum possible number of moves If there are several possible traversals the robot wants to choose the lexicographically smallest path The string s of length n is lexicographically less than the string t of length n if there is some index 1 le j le n that for all i from 1 to j 1 s i t i and s j t j It is the standard comparison of string like in a dictionary Most programming languages compare strings in this way ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nstruct node{\n    int x,y;\n    bool operator<(const node &t)const{\n        if(x==t.x)return y<t.y;\n        return x<t.x;\n    }\n}a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        scanf(""%d"",&n);\n        for(int i=1;i<=n;i++){\n            scanf(""%d%d"",&a[i].x,&a[i].y);\n        }\n        sort(a+1,a+1+n);\n        a[0].x=a[0].y=0;\n        int flag=1;\n        for(int i=1;i<=n;i++){\n            if(a[i].y<a[i-1].y){\n                flag=0;break;\n            }\n        }\n        if(flag==0){\n            printf(""NO\\n"");\n            continue;\n        }\n        puts(""YES"");\n        for(int i=0;i<n;i++){\n            while(a[i].x<a[i+1].x){\n                a[i].x++;\n                printf(""R"");\n            }\n            while(a[i].y<a[i+1].y){\n                a[i].y++;\n                printf(""U"");\n            }\n        }printf(""\\n"");\n    }\n    return 0;\n}\n']","['implementation', 'sortings']",1200
https://codeforces.com//contest/1198/problem/C,C. Matching vs Independent Set,You are given a graph with 3 cdot n vertices and m edges You are to find a matching of n edges an independent set of n vertices A set of edges is called a matching if no two edges share an endpoint A set of vertices is called an independent set if no two vertices are connected with an edge ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\n\nvector <pii> graf[nax];\nint out[nax];\n\nvoid test()\n{\n\tvi ma, in;\n\tscanf(""%d%d"", &n, &m);\n\tn*=3;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tout[i]=0;\n\t\tgraf[i].clear();\n\t}\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back({b, i});\n\t\tgraf[b].push_back({a, i});\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (out[i])\n\t\t\tcontinue;\n\t\tpii som={-1, -1};\n\t\tfor (pii j : graf[i])\n\t\t\tif (!out[j.first])\n\t\t\t\tsom=j;\n\t\tif (som.first>0)\n\t\t{\n\t\t\tout[i]=out[som.first]=1;\n\t\t\tma.push_back(som.second);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout[i]=1;\n\t\t\tin.push_back(i);\n\t\t}\n\t}\n\tif ((int)ma.size()>(int)in.size())\n\t{\n\t\tprintf(""Matching\\n"");\n\t\tfor (int i=0; i<n/3; i++)\n\t\t\tprintf(""%d "", ma[i]);\n\t\tprintf(""\\n"");\n\t}\n\telse\n\t{\n\t\tprintf(""IndSet\\n"");\n\t\tfor (int i=0; i<n/3; i++)\n\t\t\tprintf(""%d "", in[i]);\n\t\tprintf(""\\n"");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['constructive algorithms', 'graphs', 'greedy', 'sortings']",2000
https://codeforces.com//contest/1478/problem/C,C. Nezzar and Symmetric Array,Long time ago there was a symmetric array a 1 a 2 ldots a 2n consisting of 2n Array a 1 a 2 ldots a 2n is called symmetric if for each integer 1 le i le 2n there exists an integer 1 le j le 2n such that a i a j For each integer 1 le i le 2n Nezzar wrote down an integer d i equal to the sum of absolute differences from a i to all integers in a i e d i sum j 1 2n a i a j Now a million years has passed and Nezzar can barely remember the array d and totally forget a Nezzar wonders if there exists any symmetric array a consisting of 2n distinct integers that generates the array d ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 200100\n\ntypedef long long ll;\n\nint n;\nll a[N], d[N];\n\nint main() {\n    int T;\n    scanf(""%d"", &T);\n    while (T --) {\n\t\tscanf(""%d"", &n);\n\t\tfor (int i = 0; i < 2 * n; i ++) scanf(""%lld"", &d[i]);\n\t\tsort(d, d + 2 * n);\n\t\tbool ok = true; d[2*n] = a[n] = 0;\n\t\tfor (int i = n - 1; i >= 0; i --) {\n\t\t\tif (d[2*i] != d[2*i+1]) ok = false;\n\t\t\tll del = d[2*i+2] - d[2*i];\n\t\t\tif (del == 0 || del % (2 * (i + 1)) != 0) ok = false;\n\t\t\ta[i] = a[i+1] - del / (2 * (i + 1));\n\t\t}\n\t\tif (ok && a[0] > 0) puts(""YES"");\n\t\telse puts(""NO"");\n    }\n\n    return 0;\n}\n']","['implementation', 'math', 'sortings']",1700
https://codeforces.com//contest/1051/problem/B,B. Relatively Prime Pairs,You are given a set of all integers from l to r inclusive l r r l 1 le 3 cdot 10 5 and r l is always odd You want to split these numbers into exactly frac r l 1 2 pairs in such a way that for each pair i j the greatest common divisor of i and j is equal to 1 Each number should appear in exactly one of the pairs Print the resulting pairs or output that no solution exists If there are multiple solutions print any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll L,R;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>L>>R;\n\tcout<<""YES""<<endl;\n\twhile(L<R) {\n\t\tcout<<L<<"" ""<<(L+1)<<endl;\n\t\tL+=2;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']","['greedy', 'math', 'number theory']",1000
https://codeforces.com//contest/1353/problem/A,A. Most Unstable Array,You are given two integers n and m You have to construct the array a of length n consisting of i e integers greater than or equal to zero such that the sum of elements of this array is m and the value sum limits i 1 n 1 a i a i 1 is the maximum possible Recall that x is the absolute value of x In other words you have to maximize the sum of absolute differences between adjacent consecutive elements For example if the array a 1 3 2 5 5 0 then the value above for this array is 1 3 3 2 2 5 5 5 5 0 2 1 3 0 5 11 Note that this example but it shows how the required value for some array is calculated You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,b;\n           cin>>a>>b;\n           if (a==1) {cout<<""0\\n""; return; }\n           if (a==2) {cout<<b<<""\\n""; return; }\n           cout<<2*b<<""\\n""; return; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","['constructive algorithms', 'greedy', 'math']",800
https://codeforces.com//contest/106/problem/B,B. Choosing Laptop,Vasya is choosing a laptop The shop has laptops to all tastes Vasya is interested in the following properties processor speed ram and hdd Vasya is a programmer and not a gamer which is why he is not interested in all other properties If all three properties of a laptop are than those properties of some other laptop then the first laptop is considered outdated by Vasya Among all laptops Vasya does not consider outdated he chooses the cheapest one There are very many laptops which is why Vasya decided to write a program that chooses the suitable laptop However Vasya doesn t have his own laptop yet and he asks you to help him ,"['//yeah lets clear a page 2 problem first (successfully)\n\n#include <iostream> //ray, scott picks problem\n#include <cstdio> //steven, ok http://codeforces.com/problemset/page/2?order=BY_SOLVED_DESC\n#include <algorithm> // scott, http://www.codeforces.com/problemset/problem/106/B\n#include <cstring> //ray, richard get out\n\nusing namespace std; //steven\nconst int MAXN = 110; // scott\n\nint N; //ray, wtf\n//struct laptop { //steven, my bad\nstruct notlaptop { //scott ray li go\n    int speed, ram, hdd, cost; //ray, sorry comp is freezing\n    notlaptop(int a, int b, int c, int d) { // steven\n        speed = a; ram = b; hdd = c; cost = d; //scott\n    } //ray\n    notlaptop()<% %>//steven\n}//scott\n;//ray\n\nnotlaptop ar[MAXN]; //steven\n\nint main() //scott\n{ //ray\nscanf(""%d"", &N); //steven\nfor (int i = 0; i < N; i++) //scott\n{ //ray, scott why you give me the boring lines gayboi, also lets race richard/travis/nathan after this;\nint a,b,c,d; //steven\ncin >> a >> b >> c >> d; //scott gogo ray li\nar[i] = notlaptop (a,b,c,d); //ray\n}//steven also can we code simultaneously on different lines\n\nint bcost = 1e9, res = -1; //scott this is the best cost found\n\nfor(int i=0; i<N; i++){ //ray\nbool outdated = false; //steven, rpeng gave us his stypi want to troll it if we\'re losing?\nfor (int j = 0; j < N; j++) { //scott we won\'t lose dude\n    if (ar[i].speed < ar[j].speed and ar[i].ram < ar[j].ram and ar[i].hdd < ar[j].hdd){ //ray\n        outdated = true; break; }  } //guys i was expecting scott to put another } not my fault\n//steven, http://www.youtube.com/watch?v=O1U4aiEvudY&feature=youtu.be\n\nif (!outdated){ //scott\n    if (ar[i].cost < bcost){ //ray\n           bcost = ar[i].cost, res = i + 1; //steven\n    } //scott ray you can do the other }\n} //ray, nig\n} //steven, niggaaa\n\ncout << res << ""\\n""; //scott\n} //ray, dafuck are you talking about\n//steven nigga you need to return 0 holy shit\n//dude we compile error\n//ray, holy shit steven you are so bad scott gogogogogo\n']","['brute force', 'implementation']",1000
https://codeforces.com//contest/892/problem/A,A. Greed,Jafar has cans of cola Each can is described by two integers remaining volume of cola and can s capacity Jafar has decided to pour all remaining cola into just cans determine if he can do this or not ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint a[100005], b[100005];\n\nint main(void) {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    long long s = 0;\n    for (int i = 0; i < n; ++i) cin >> a[i], s += a[i];\n    for (int i = 0; i < n; ++i) cin >> b[i];\n    sort(b, b + n);\n    if (s <= b[n-1] + b[n-2]) cout << ""YES"" << endl;\n    else cout << ""NO"" << endl;\n}\n']","['greedy', 'implementation']",900
https://codeforces.com//contest/338/problem/A,A. Quiz,Manao is taking part in a quiz The quiz consists of consecutive questions A correct answer gives one point to the player The game also has a counter of consecutive correct answers When the player answers a question correctly the number on this counter increases by 1 If the player answers a question incorrectly the counter is reset that is the number on it reduces to 0 If after an answer the counter reaches the number then it is reset and the player s score is doubled Note that in this case first 1 point is added to the player s score and then the total score is doubled At the beginning of the game both the player s score and the counter of consecutive correct answers are set to zero Manao remembers that he has answered exactly questions correctly But he does not remember the order in which the questions came He s trying to figure out what his minimum score may be Help him and compute the remainder of the corresponding number after division by ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst long long md = 1000000009;\n\nlong long pw(long long a, long long b) {\n  long long x = 1, step = 1LL << 60;\n  while (step > 0) {\n    x = x * x % md;\n    if (step & b) x = x * a % md;\n    step >>= 1;\n  }\n  return x;\n}\n\nint main() {\n  long long n, m, k;\n  cin >> n >> m >> k;\n  long long ll = 0, rr = m / k;\n  while (ll < rr) {\n    long long mid = (ll + rr) >> 1;\n    long long N = n - mid * k;\n    long long M = m - mid * k;\n    if (N - N / k >= M) rr = mid;\n    else ll = mid + 1;\n  }\n  long long p = ll;\n  long long ans = m - p * k;\n  long long u = (pw(2, p + 1) + md - 2) % md;\n  ans = (ans + k * u) % md;\n  cout << ans << endl;\n  return 0;\n}\n']","['greedy', 'math', 'number theory']",1600
https://codeforces.com//contest/1809/problem/D,D. Binary String Sorting,You are given a binary string s consisting of only characters and or You can perform several operations on this string possibly zero There are two types of operations choose two consecutive elements and swap them In order to perform this operation you pay 10 12 coins choose any element from the string and remove it In order to perform this operation you pay 10 12 1 coins Your task is to calculate the minimum number of coins required to sort the string s in non decreasing order i e transform s so that s 1 le s 2 le dots le s m where m is the length of the string after applying all operations An empty string is also considered sorted in non decreasing order ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 X = 1E12;\nconstexpr i64 inf = 1E18;\n\nvoid update(i64 &a, i64 b) {\n    if (a > b) {\n        a = b;\n    }\n}\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    std::vector dp(n + 1, std::array<i64, 2>{inf, inf});\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int x = 0; x < 2; x++) {\n            if (s[i] - \'0\' >= x) {\n                update(dp[i + 1][s[i] - \'0\'], dp[i][x]);\n            }\n            update(dp[i + 1][x], dp[i][x] + X + 1);\n            if (i + 1 < n && x <= s[i + 1] - \'0\' && s[i + 1] <= s[i]) {\n                update(dp[i + 2][s[i] - \'0\'], dp[i][x] + X);\n            }\n        }\n    }\n    std::cout << std::min(dp[n][0], dp[n][1]) << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'greedy']",1800
https://codeforces.com//contest/1774/problem/D,D. Same Count One,ChthollyNotaSeniorious received a special gift from AquaMoon n binary arrays of length m AquaMoon tells him that in one operation he can choose any two arrays and any position pos from 1 to m and swap the elements at positions pos in these arrays He is fascinated with this game and he wants to find the minimum number of operations needed to make the numbers of 1s in all arrays the same He has invited you to participate in this interesting game so please try to find it If it is possible please output specific exchange steps in the format described in the output section Otherwise please output 1 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 100100;\nconst int M = (int)1e6 + 7;\nint n, m;\narray<int, 3> ans[M];\nint ansSz;\nvector<int> a[N];\nint sum[N];\n\nvoid solve() {\n\tscanf(""%d%d"", &n, &m);\n\tint tot = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i].resize(m);\n\t\tsum[i] = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(""%d"", &a[i][j]);\n\t\t\tsum[i] += a[i][j];\n\t\t}\n\t\ttot += sum[i];\n\t}\n\tif (tot % n != 0) {\n\t\tprintf(""-1\\n"");\n\t\treturn;\n\t}\n\ttot /= n;\n\tansSz = 0;\n\tint p = 0, q = 0;\n\twhile(true) {\n\t\twhile(p < n && sum[p] >= tot) p++;\n\t\twhile(q < n && sum[q] <= tot) q++;\n\t\tassert(1 ^ (p == n) ^ (q == n));\n\t\tif (p == n) break;\n\t\tfor (int i = 0; sum[p] < tot && sum[q] > tot && i < m; i++) {\n\t\t\tif (a[p][i] == 1 || a[q][i] == 0) continue;\n\t\t\tans[ansSz++] = {p, q, i};\n\t\t\tsum[p]++;\n\t\t\tsum[q]--;\n\t\t\tswap(a[p][i], a[q][i]);\n\t\t}\n\t}\n\tprintf(""%d\\n"", ansSz);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(""%d %d %d\\n"", ans[i][0] + 1, ans[i][1] + 1, ans[i][2] + 1);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'implementation', 'two pointers']",1600
https://codeforces.com//contest/95/problem/B,B. Lucky Numbers,Petya loves lucky numbers Everybody knows that positive integers are if their decimal representation doesn t contain digits other than and For example numbers are lucky and are not Lucky number is if it s decimal representation contains equal amount of digits and For example numbers are super lucky and are not One day Petya came across a positive integer Help him to find the least super lucky number which is not less than ,"['#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int maxn=200000+10;\nchar st[maxn];\nint res[maxn];\nint need[maxn];\nint n;\n\nint main()\n{\n\tscanf(""%s"",st+1);\n\tn=strlen(st+1);\n\n\tfor (int i=n;i;i--)\n\tif (st[i]<\'4\') need[i]=0;else\n\tif (st[i]==\'4\') need[i]=min(1,need[i+1]);else\n\tif (st[i]<\'7\') need[i]=1;else\n\tif (st[i]==\'7\') need[i]=need[i+1]+1;\n\telse need[i]=1000000000;\n\n\tif (n%2==0)\n\t{\n\t\tbool ok=1;\n\t\tint a=0,b=0,c=4,flag=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\tif (flag)\n\t\t{\n\t\t\tif (a+1<=n/2) res[i]=4,a++;\n\t\t\telse res[i]=7,b++;\n\t\t} else\n\t\t{\n\t\t\tif (st[i]<\'4\' && a+1<=n/2) res[i]=4,a++,flag=1;else\n\t\t\tif (st[i]==\'4\' && a+1<=n/2 && need[i+1]<=n/2-b)res[i]=4,a++;else\n\t\t\tif (st[i]<\'7\' && b+1<=n/2) res[i]=7,b++,flag=1;else\n\t\t\tif (st[i]==\'7\' && b+1<=n/2) res[i]=7,b++;\n\t\t\telse ok=0;\n\t\t}\n\t\tif (ok)\n\t\t{\n\t\t\tfor (int i=1;i<=n;i++) printf(""%d"",res[i]);\n\t\t\tprintf(""\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tn+=2;\n\t} else n+=1;\n\tfor (int i=1;i<=n/2;i++) printf(""4"");\n\tfor (int i=1;i<=n/2;i++) printf(""7"");\n\tprintf(""\\n"");\n}\n']","['dp', 'greedy']",1800
https://codeforces.com//contest/1530/problem/F,F. Bingo,Getting ready for VK Fest 2021 you prepared a table with n rows and n columns and filled each cell of this table with some event related with the festival that could either happen or not for example whether you will win a prize on the festival or whether it will rain Forecasting algorithms used in VK have already estimated the probability for each event to happen Event in row i and column j will happen with probability a i j cdot 10 4 All of the events are mutually independent Let s call the table if there exists a line such that all n events on it happen The line could be any horizontal line cells i 1 i 2 ldots i n for some i any vertical line cells 1 j 2 j ldots n j for some j the main diagonal cells 1 1 2 2 ldots n n or the antidiagonal cells 1 n 2 n 1 ldots n 1 Find the probability of your table to be winning and output it modulo 31 607 see Output section ,"['#include <bits/stdc++.h>\n\nconstexpr int P = 31607;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, int b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    const auto inv = Z(10000).inv();\n    \n    std::vector a(n, std::vector<Z>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int x;\n            std::cin >> x;\n            a[i][j] = x * inv;\n        }\n    }\n    \n    Z ans = 1;\n    \n    for (int md = 0; md <= 1; md++) {\n        for (int ad = 0; ad <= 1; ad++) {\n            auto b = a;\n            \n            Z res = ((md + ad) % 2 == 0 ? -1 : 1);\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((md && i == j) || (ad && i + j == n - 1)) {\n                        res *= b[i][j];\n                        b[i][j] = 1;\n                    }\n                }\n            }\n            \n            std::function<void(int, std::vector<Z>, Z)> dfs = [&](int r, std::vector<Z> v, Z coef) {\n                if (r == n) {\n                    for (int i = 0; i < n; i++) {\n                        coef *= 1 - v[i];\n                    }\n                    ans += coef;\n                    return;\n                }\n                Z tmp = -coef;\n                for (int i = 0; i < n; i++) {\n                    tmp *= b[r][i];\n                }\n                dfs(r + 1, v, tmp);\n                for (int i = 0; i < n; i++) {\n                    v[i] *= b[r][i];\n                }\n                dfs(r + 1, v, coef);\n            };\n            dfs(0, std::vector<Z>(n, 1), res);\n        }\n    }\n    \n    std::cout << ans.val() << ""\\n"";\n    \n    return 0;\n}']","['bitmasks', 'combinatorics', 'dp', 'math', 'probabilities']",2600
https://codeforces.com//contest/1918/problem/A,A. Brick Wall,A brick is a strip of size 1 times k placed horizontally or vertically where k can be an arbitrary number that is at least 2 k ge 2 A brick wall of size n times m is such a way to place several bricks inside a rectangle n times m that all bricks lie either horizontally or vertically in the cells do not cross the border of the rectangle and that each cell of the n times m rectangle belongs to exactly one brick Here n is the height of the rectangle n times m and m is the width that there can be bricks with different values of k in the same brick wall The wall stability is the difference between the number of horizontal bricks and the number of vertical bricks that if you used 0 horizontal bricks and 2 vertical ones then the stability will be What is the maximal possible stability of a wall of size n times m It is guaranteed that under restrictions in the statement at least one n times m wall exists ,"['#include<bits/stdc++.h>\n#define N ;\n#define P 1000000007\n#define INF 1061109567\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline ll read(){\n\tll x=0,f=1;char ch=GC;\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=GC;}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=(x<<1)+(x<<3)+(ch^48);ch=GC;}\n\treturn x*f;\n}\nvoid Solve(){\n\tint n=read(),m=read();\n\tprintf(""%d\\n"",n*(m/2));\n}\nint main(){\n\tfor(int T=read();T--;)Solve();\n\treturn 0;\n}']","['constructive algorithms', 'greedy', 'implementation', 'math']",800
https://codeforces.com//contest/1366/problem/D,D. Two Divisors,You are given n integers a 1 a 2 dots a n For each a i find its d 1 1 and d 2 1 such that gcd d 1 d 2 a i 1 where gcd a b is the greatest common divisor of a and b or say that there is no such pair ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int X = 2e7;\n\nbitset<X> is_prime;\nvector<int> pf;\nvector<int> pr;\n\nvoid init(){\n\tpf.resize(X, 0);\n\tis_prime.flip();\n\tis_prime[0] = is_prime[1] = false;\n\tfor(int i = 2; i < X; i++){\n\t\tif(is_prime[i]){\n\t\t\tpr.push_back(i);\n\t\t\tpf[i] = i;\n\t\t}\n\t\tfor(int p : pr){\n\t\t\tif(ll(i) * p >= X) break;\n\t\t\tpf[i * p] = p;\n\t\t\tis_prime[i * p] = false;\n\t\t\tif(i % p == 0) break;\n\t\t}\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<int> b(n, -1), c(n, -1);\n\tfor(int i = 0; i < n; i++){\n\t\tint r;\n\t\tcin >> r;\n\t\tint p = pf[r];\n\t\tassert(r % p == 0);\n\t\tint g = r;\n\t\tint h = 1;\n\t\twhile(g % p == 0){\n\t\t\tg /= p;\n\t\t\th *= p;\n\t\t}\n\t\tif(g != 1){\n\t\t\tb[i] = g;\n\t\t\tc[i] = h;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) cout << b[i] << ' ';\n\tcout << '\\n';\n\tfor(int i = 0; i < n; i++) cout << c[i] << ' ';\n\tcout << '\\n';\n}""]","['constructive algorithms', 'math', 'number theory']",2000
https://codeforces.com//contest/203/problem/D,D. Hit Ball,When Valera was playing football on a stadium it suddenly began to rain Valera hid in the corridor under the grandstand not to get wet However the desire to play was so great that he decided to train his hitting the ball right in this corridor Valera went back far enough put the ball and hit it The ball bounced off the walls the ceiling and the floor corridor and finally hit the exit door As the ball was wet it left a spot on the door Now Valera wants to know the coordinates for this spot Let s describe the event more formally The ball will be considered a point in space The door of the corridor will be considered a rectangle located on plane such that the lower left corner of the door is located at point and the upper right corner is located at point The corridor will be considered as a rectangular parallelepiped infinite in the direction of increasing coordinates of In this corridor the floor will be considered as plane and the ceiling as plane parallel to and passing through point We will also assume that one of the walls is plane and the other wall is plane parallel to and passing through point We ll say that the ball hit the door when its coordinate was equal to Thus the coordinates of the spot are point where To hit the ball Valera steps away from the door at distance and puts the ball in the center of the corridor at point After the hit the ball flies at speed This means that if the ball has coordinates then after one second it will have coordinates See image in notes for clarification When the ball collides with the ceiling the floor or a wall of the corridor it bounces off in accordance with the laws of reflection the angle of incidence equals the angle of reflection In the problem we consider the ideal physical model so we can assume that there is no air resistance friction force or any loss of energy ,"[""#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iomanip>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<ctime>\nusing namespace std;\n\ndouble x,y,z;\ndouble vx,vy,vz; \n\nint main()\n{\n\tcin>>x>>z>>y;\n\tcin>>vx>>vy>>vz;\n\tdouble t=-y/vy;\n\tdouble px,pz;\n\tpx=vx*t+x/2;\n\tpz=vz*t;\n\twhile(px<0) px+=x*2;\n\twhile(px>=x*2) px-=x*2;\n\twhile(pz<0) pz+=z*2;\n\twhile(pz>=z*2) pz-=z*2;\n\tif(px>x) px=x+x-px;\n\tif(pz>z) pz=z+z-pz;\n\tcout<<setiosflags(ios::fixed)<<setprecision(10)<<px<<' '<<pz<<endl;\n\t\n\t\n\treturn 0;\n}\n/*\n7 2 11\n3 -11 2\n*/\n\n""]","['geometry', 'implementation', 'math']",1700
https://codeforces.com//contest/723/problem/C,C. Polycarp at the Radio,Polycarp is a music editor at the radio station He received a playlist for tomorrow that can be represented as a sequence where is a band which performs the th song Polycarp likes bands with the numbers from to but he doesn t really like others We define as the number of songs the group is going to perform tomorrow Polycarp wants to change the playlist in such a way that the minimum among the numbers will be as large as possible Find this maximum possible value of the minimum among the and the minimum number of changes in the playlist Polycarp needs to make to achieve it One change in the playlist is a replacement of the performer of the th song with any other group ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N(2222);\nint cnt[N], a[N];\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tint ans1(n / m);\n\tfor(int i(0); i < n; i++) {\n\t\tcin >> a[i];\n\t\tif(a[i] <= m) {\n\t\t\tcnt[a[i]]++;\n\t\t}\n\t}\n\tint ans2(0);\n\tfor(int i(0); i < n; i++) {\n\t\tif(a[i] > m || a[i] <= m && cnt[a[i]] > ans1) {\n\t\t\tfor(int j(1); j <= m; j++) {\n\t\t\t\tif(cnt[j] < ans1) {\n\t\t\t\t\tif(a[i] <= m) {\n\t\t\t\t\t\tcnt[a[i]]--;\n\t\t\t\t\t}\n\t\t\t\t\ta[i] = j;\n\t\t\t\t\tcnt[j] ++;\n\t\t\t\t\tans2++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d %d\\n"", ans1, ans2);\n\tfor(int i(0); i < n; i++) {\n\t\tprintf(""%d%c"", a[i], i == n - 1 ? \'\\n\' : \' \');\n\t}\n}\n']",['greedy'],1600
https://codeforces.com//contest/1922/problem/B,B. Forming Triangles,You have n sticks numbered from 1 to n The length of the i th stick is 2 a i You want to choose 3 sticks out of the given n sticks and form a triangle out of them using the sticks as the sides of the triangle A triangle is called non degenerate if its area is greater than 0 You have to calculate the number of ways to choose exactly 3 sticks so that a triangle can be formed out of them Note that the order of choosing sticks does not matter for example choosing the 1 st 2 nd and 4 th stick is the same as choosing the 2 nd 4 th and 1 st stick ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include ""debug.h""  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    cin >> n;\n    vector<int> c(n + 1);\n    for (int i = 0, a; i < n; i += 1) {\n      cin >> a;\n      c[a] += 1;\n    }\n    i64 ans = 0, sum = 0;\n    for (i64 ci : c) {\n      ans += ci * (ci - 1) * (ci - 2) / 6;\n      ans += ci * (ci - 1) / 2 * sum;\n      sum += ci;\n    }\n    cout << ans << ""\\n"";\n  }\n}']","['combinatorics', 'constructive algorithms', 'math', 'sortings']",1200
https://codeforces.com//contest/1876/problem/A,A. Helmets in Night Light,Pak Chanek is the chief of a village named Khuntien On one night filled with lights Pak Chanek has a sudden and important announcement that needs to be notified to all of the n residents in Khuntien First Pak Chanek shares the announcement directly to one or more residents with a cost of p for each person After that the residents can share the announcement to other residents using a magical helmet shaped device However there is a cost for using the helmet shaped device For each i if the i th resident has got the announcement at least once either directly from Pak Chanek or from another resident he she can share the announcement to at most a i other residents with a cost of b i If Pak Chanek can also control how the residents share the announcement to other residents what is the minimum cost for Pak Chanek to notify all n residents of Khuntien about the announcement ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll p;\n\npll tab[nax];\n\nvoid test()\n{\n\tscanf(""%d%lld"", &n, &p);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i].second);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i].first);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i].first=min(tab[i].first, p);\n\tsort(tab+1, tab+1+n);\n\tll wyn=p;\n\tint wsk=1;\n\tll ile=0;\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\twyn+=tab[wsk].first;\n\t\tile++;\n\t\tif (ile==tab[wsk].second)\n\t\t{\n\t\t\tile=0;\n\t\t\twsk++;\n\t\t}\n\t}\n\tprintf(""%lld\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['greedy', 'sortings']",1000
https://codeforces.com//contest/1701/problem/E,E. Text Editor,You wanted to write a text t consisting of m lowercase Latin letters But instead you have written a text s consisting of n lowercase Latin letters and now you want to fix it by obtaining the text t from the text s Initially the cursor of your text editor is at the end of the text s after its last character In one move you can do one of the following actions press the left button so the cursor is moved to the left by one position or does nothing if it is pointing at the beginning of the text i e before its first character press the right button so the cursor is moved to the right by one position or does nothing if it is pointing at the end of the text i e after its last character press the home button so the cursor is moved to the beginning of the text before the first character of the text press the end button so the cursor is moved to the end of the text after the last character of the text press the backspace button so the character before the cursor is removed from the text if there is no such character nothing happens Your task is to calculate the minimum number of moves required to obtain the text t from the text s using the given set of actions or determine it is impossible to obtain the text t from the text s You have to answer T independent test cases ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:52:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    string t;\n    cin >> s >> t;\n    int ptr = 0;\n    int pref = 0;\n    for (int i = 0; i < n; i++) {\n      if (ptr < m && s[i] == t[ptr]) {\n        if (i == ptr) {\n          pref += 1;\n        }\n        ptr += 1;\n      }\n    }\n    if (ptr < m) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    int ans = n - pref;\n    const int inf = (int) 1e9;\n    vector<int> d0(m + 1, inf);\n    vector<int> d1(m + 1, inf);\n    vector<int> d2(m + 1, inf);\n    d0[0] = d1[0] = d2[0] = 0;\n    for (char c : s) {\n      vector<int> f0(m + 1, inf);\n      vector<int> f1(m + 1, inf);\n      vector<int> f2(m + 1, inf);\n      for (int i = 0; i <= m; i++) {\n        f0[i] = min(f0[i], d0[i] + 2);\n        f2[i] = min(f2[i], d2[i] + 1);\n        if (i < m && c == t[i]) {\n          f0[i + 1] = min(f0[i + 1], d0[i] + 1);\n          f1[i + 1] = min(f1[i + 1], d1[i]);\n          f2[i + 1] = min(f2[i + 1], d2[i] + 1);\n        }\n      }\n      for (int i = 0; i <= m; i++) {\n        f1[i] = min(f1[i], f0[i]);\n        f2[i] = min(f2[i], f1[i]);\n      }\n      swap(d0, f0);\n      swap(d1, f1);\n      swap(d2, f2);\n    }\n    ans = min(ans, d2[m] + 1);\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'dp', 'greedy', 'strings']",2500
https://codeforces.com//contest/233/problem/A,A. Perfect Permutation,A is a sequence of integers consisting of distinct positive integers each of them doesn t exceed Let s denote the th element of permutation as We ll call number the size of permutation Nickolas adores permutations He likes some permutations more than the others He calls such permutations perfect A permutation is such permutation that for any is the permutation size the following equations hold and Nickolas asks you to print any perfect permutation of size for the given ,"['#include<cstdio>\n\nint n;\n\nint main()\n{\nscanf(""%d"",&n);\nif (n&1) printf(""-1\\n"");\nelse\n  for (int i=1;i<=n/2;i++) printf(""%d %d "",i*2,i*2-1);\nreturn 0;\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/437/problem/A,A. The Child and Homework,Once upon a time a child got a test consisting of multiple choice questions as homework A multiple choice question consists of four choices and Each choice has a description and the child should find out the only one that is correct Fortunately the child knows how to solve such complicated test The child will follow the algorithm If there is some choice whose description at least twice shorter than all other descriptions or at least twice longer than all other descriptions then the child thinks the choice is great If there is exactly one great choice then the child chooses it Otherwise the child chooses the child think it is the luckiest choice You are given a multiple choice questions can you predict child s choose ,"['#include <cstdio>\n#include <string>\n#include <cstdlib>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#define rep(i, a, b) for (int i = a; i < b; ++i)\n#define dep(i, a, b) for (int i = a; i > b; --i)\nusing namespace std;\n\nchar s[10][1010];\nint len[10], rank[10], cnt;\n\nbool rk_cmp(const int &a, const int &b)\n{\n\treturn len[a] < len[b];\n}\nint main()\n{\n\trep(i, 0, 4)\n\t{\n\t\tscanf(""%s"",s[i]+1);\n\t\tlen[i] = strlen(s[i]+1) - 2;\n\t\trank[i] = i;\n\t}\n\tsort(rank, rank+4, rk_cmp);\n\tif (len[rank[0]] * 2 <= len[rank[1]]) cnt += 1;\n\tif (len[rank[2]] * 2 <= len[rank[3]]) cnt += 2;\n\tif (cnt == 1) printf(""%c"", rank[0]+\'A\');\n\telse if (cnt == 2) printf(""%c"", rank[3]+\'A\');\n\telse printf(""C""); \n}\n']",['implementation'],1300
https://codeforces.com//contest/1398/problem/D,D. Colored Rectangles,You are given three multisets of pairs of colored sticks R pairs of red sticks the first pair has length r 1 the second pair has length r 2 dots the R th pair has length r R G pairs of green sticks the first pair has length g 1 the second pair has length g 2 dots the G th pair has length g G B pairs of blue sticks the first pair has length b 1 the second pair has length b 2 dots the B th pair has length b B You are constructing rectangles from these pairs of sticks with the following process take a pair of sticks of one color take a pair of sticks of another color different from the first one add the area of the resulting rectangle to the total area Thus you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color Each pair of sticks can be used at most once some pairs can be left unused You are not allowed to split a pair into independent sticks What is the maximum area you can achieve ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 202;\nint a[N], b[N], c[N];\nint dp[N][N][N];\nint n, m, k;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(""%d"", &b[i]);\n\tsort(b, b + m);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(""%d"", &c[i]);\n\tsort(c, c + k);\n\n\tfor (int i = n; i >= 0; i--)\n\t\tfor (int j = m; j >= 0; j--)\n\t\t\tfor (int h = k; h >= 0; h--) {\n\t\t\t\tif (i > 0 && j > 0)\n\t\t\t\t\tdp[i - 1][j - 1][h] = max(dp[i - 1][j - 1][h], dp[i][j][h] + a[i - 1] * b[j - 1]);\n\t\t\t\tif (i > 0 && h > 0)\n\t\t\t\t\tdp[i - 1][j][h - 1] = max(dp[i - 1][j][h - 1], dp[i][j][h] + a[i - 1] * c[h - 1]);\n\t\t\t\tif (j > 0 && h > 0)\n\t\t\t\t\tdp[i][j - 1][h - 1] = max(dp[i][j - 1][h - 1], dp[i][j][h] + b[j - 1] * c[h - 1]);\n\t\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= m; j++)\n\t\t\tfor (int h = 0; h <= k; h++)\n\t\t\t\tans = max(ans, dp[i][j][h]);\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","['dp', 'greedy', 'sortings']",1800
https://codeforces.com//contest/301/problem/D,D. Yaroslav and Divisors,Yaroslav has an array consisting of distinct integers Also he has queries Query number is represented as a pair of integers The answer to the query is the number of pairs of integers such that is the divisor of Help Yaroslav answer all his queries ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nstruct Fen {\n\tint fen[200002];\n\tinline void upd(int x, int val) {\n\t\tfor (; x >= 0; x = (x & (x + 1)) - 1) fen[x] += val;\n\t}\n\tinline int sum(int x) {\n\t\tint ans = 0;\n\t\tfor (; x <= 200000; x |= x + 1) ans += fen[x];\n\t\treturn ans;\n\t}\n};\n\nint a,b,c,d,n,m,k;\nint mas[200002], inv[200002];\nint ans[200002];\nFen rt;\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\t\n\tscanf(""%d%d"", &n, &m);\n\trept(i, n) {\n\t\tscanf(""%d"", &mas[i]);\n\t\tinv[mas[i]] = i;\n\t}\n\t\n\tvector<pii> tot;\n\trep(i, n) {\n\t\tfor (int j = i; j <= n; j += i) {\n\t\t\ta = inv[i];\n\t\t\tb = inv[j];\n\t\t\tif (a > b) swap(a, b);\n\t\t\ttot.pb(mp(a, b));\n\t\t}\n\t}\n\n\tSORT(tot);\n\tvector<pair<pii, int> > quer;\n\trept(i, m) {\n\t\tscanf(""%d%d"", &a, &b); --a; --b;\n\t\tquer.pb(mp(mp(a, b), i));\n\t}\n\tSORT(quer);\n\n\ta = L(tot) - 1; b = 0;\n\tFORD(i, L(quer) - 1, 0) {\n\t\twhile (a >= 0 && tot[a].x >= quer[i].x.x) {\n\t\t\trt.upd(tot[a].y, 1);\n\t\t\t--a;\n\t\t\t++b;\n\t\t}\n\t\tint res = b - rt.sum(quer[i].x.y + 1);\n\t\tans[quer[i].y] = res;\n\t}\n\trept(i, m) {\n\t\tprintf(""%d\\n"", ans[i]);\n\t}\n}\n']",['data structures'],2200
https://codeforces.com//contest/66/problem/C,C. Petya and File System,Recently on a programming lesson little Petya showed how quickly he can create files and folders on the computer But he got soon fed up with this activity and he decided to do a much more useful thing He decided to calculate what folder contains most subfolders including nested folders nested folders of nested folders and so on and what folder contains most files including the files in the subfolders More formally the subfolders of the folder are all its directly nested folders and the subfolders of these nested folders The given folder is not considered the subfolder of itself A file is regarded as lying in a folder if and only if it either lies directly in this folder or lies in some subfolder of the folder For a better understanding of how to count subfolders and files for calculating the answer see notes and answers to the samples You are given a few files that Petya has managed to create The path to each file looks as follows is single capital letter from the set are folder names Each folder name is nonempty sequence of lowercase Latin letters and digits from 0 to 9 is a file name in the form of where the and the are nonempty sequences of lowercase Latin letters and digits from 0 to 9 It is also known that there is no file whose path looks like That is each file is stored in some folder but there are no files directly in the root Also let us assume that the disk root is not a folder Help Petya to find the largest number of subfolders which can be in some folder and the largest number of files that can be in some folder counting all its subfolders ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""c""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nstring s;\n\nmap <string, int> mp;\n\nint res1[100005], res2[100005], cnt = 0;\n\nvoid Load ()\n{\n}\n\nvoid Solve ()\n{\n    int ans1 = 0, ans2 = 0;\n    string s;\n\n    while (cin >> s)\n    {\n        int i = 0;\n        while (s[i] != char(92) || s[i - 1] == \':\') i++;\n\n        string cur = s.substr (0, i);\n        if (mp.find (cur) == mp.end()) mp[cur] = cnt++;\n\n        int f = mp[cur];\n\n        while (i < s.size())\n        {\n            while (i < s.size() && s[i] != char(92))\n                cur += s[i++];\n\n            if (i == s.size()) break;\n            if (mp.find (cur) == mp.end())\n            {\n                res1[f]++;\n                if (res1[f] > ans1) ans1 = res1[f];\n                mp[cur] = cnt++;\n            }\n            cur += s[i++];\n        }\n        res2[f]++;\n        if (res2[f] > ans2) ans2 = res2[f];\n    }\n\n    cout << ans1 << "" "" << ans2;\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","['data structures', 'implementation']",1800
https://codeforces.com//contest/1748/problem/D,D. ConstructOR ,You are given three integers a b and d Your task is to find any integer x which satisfies all of the following conditions or determine that no such integers exist 0 le x lt 2 60 a x is divisible by d b x is divisible by d Here denotes the bitwise OR operation ,"['# include <cstdlib>\n# include <utility>\n# include <cassert>\n# include <algorithm>\n# include <cstdio>\n\nnamespace khin {\n  using namespace std;\n  namespace main {\n    inline namespace source {\n      typedef unsigned long int ulong;\n      typedef unsigned short int ushort;\n      typedef unsigned int uint;\n    }\n    namespace d { void main(); }\n  }\n}\n\nint main() { khin::main::d::main(); }\n\nnamespace khin::main::d {\n  namespace test_case {\n    typedef pair<long long int, long long int> pair;\n    pair exgcd(int const a, int const b) {\n      if (!b) return make_pair(1ll, 0ll);\n      if (!a) return make_pair(0ll, 1ll);\n      auto const [x, y](exgcd(a % b, b % a));\n      return make_pair(x - (b / a) * y, y - (a / b) * x);\n    }\n    uint f(uint const a, uint const b, uint const c) {\n      assert(a), assert(b), assert(c);\n      uint const gcd(__gcd(a, b)); assert(!(c % gcd));\n      return 1ull * (exgcd(a, b).first % (int)b + b) * (c / gcd) % b;\n    }\n    void main() {\n      uint a, b, d;\n      scanf(""%u%u%u"", &a, &b, &d);\n      if (__builtin_ctz(a) < __builtin_ctz(d)) { printf(""%i\\n"", -1); return; }\n      if (__builtin_ctz(b) < __builtin_ctz(d)) { printf(""%i\\n"", -1); return; }\n      unsigned long long int x(a | b);\n      if (x % d)\n        x |= (unsigned long long int)f((0b1u << 30) % d, d, d - x % d) << 30;\n      assert(!((a | x) % d)), assert(!((b | x) % d));\n      printf(""%llu\\n"", x);\n    }\n  }\n  void main() {\n    ushort t;\n    scanf(""%hu"", &t);\n    while (test_case::main(), --t);\n  }\n}']","['bitmasks', 'chinese remainder theorem', 'combinatorics', 'constructive algorithms', 'math', 'number theory']",2100
https://codeforces.com//contest/1051/problem/A,A. Vasya And Password,Vasya came up with a password to register for a string s The password in should be a string consisting of lowercase and uppercase Latin letters and digits But since takes care of the security of its users user passwords must contain at least one digit at least one uppercase Latin letter and at least one lowercase Latin letter For example the passwords and are valid and the passwords and are not A substring of string s is a string x s l s l 1 dots s l len 1 1 le l le s 0 le len le s l 1 len is the length of the substring Note that the empty string is also considered a substring of s it has the length 0 Vasya s password however may come too weak for the security settings of He likes his password so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions This operation should be performed once and ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint T;\nstring S,A=""aA1"";\nint N;\n\nbool ok(string S) {\n\tint mask=0;\n\tFORR(c,S) {\n\t\tif(c>=\'0\' && c<=\'9\') mask |= 1;\n\t\tif(c>=\'a\' && c<=\'z\') mask |= 2;\n\t\tif(c>=\'A\' && c<=\'Z\') mask |= 4;\n\t}\n\treturn mask==7;\n}\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>S;\n\t\tN=S.size();\n\t\t\n\t\tif(ok(S)) {\n\t\t\tcout<<S<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(i,N) {\n\t\t\tstring T=S;\n\t\t\tFOR(j,3) {\n\t\t\t\tT[i]=A[j];\n\t\t\t\tif(ok(T)) {\n\t\t\t\t\tcout<<T<<endl;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(i,N-1) {\n\t\t\tstring T=S;\n\t\t\tFOR(x,3) {\n\t\t\t\tFOR(y,3) {\n\t\t\t\t\tT[i]=A[x];\n\t\t\t\t\tT[i+1]=A[y];\n\t\t\t\t\tif(ok(T)) {\n\t\t\t\t\t\tcout<<T<<endl;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout:\n\t\t;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']","['greedy', 'implementation', 'strings']",1200
https://codeforces.com//contest/1931/problem/D,D. Divisible Pairs,Polycarp has two favorite integers x and y they can be equal and he has found an array a of length n Polycarp considers a pair of indices langle i j rangle 1 le i j le n if a i a j is divisible by x a i a j is divisible by y For example if x 5 y 2 n 6 a 1 2 7 4 9 6 then the only pairs are langle 1 5 rangle a 1 a 5 1 9 10 10 is divisible by 5 and a 1 a 5 1 9 8 8 is divisible by 2 langle 4 6 rangle a 4 a 6 4 6 10 10 is divisible by 5 and a 4 a 6 4 6 2 2 is divisible by 2 Find the number of pairs in the array a ,"[""// Problem: D. Divisible Pairs\n// Contest: Codeforces - Codeforces Round 925 (Div. 3)\n// URL: https://codeforces.com/contest/1931/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n, x, y; cin >> n >> x >> y;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tmap<pair<int, int>, int> mp;\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += mp[{(x - a[i] % x) % x, a[i] % y}];\n\t\tmp[{a[i] % x, a[i] % y}]++;\n\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}""]","['combinatorics', 'math', 'number theory']",1300
https://codeforces.com//contest/1201/problem/D,D. Treasure Hunting,You are on the island which can be represented as a n times m table The rows are numbered from 1 to n and the columns are numbered from 1 to m There are k treasures on the island the i th of them is located at the position r i c i Initially you stand at the lower left corner of the island at the position 1 1 If at any moment you are at the cell with a treasure you can pick it up without any extra time In one move you can move up from r c to r 1 c left from r c to r c 1 or right from position r c to r c 1 Because of the traps you can t move down However moving up is also risky You can move up only if you are in a safe column There are q safe columns b 1 b 2 ldots b q You want to collect all the treasures as fast as possible Count the minimum number of moves required to collect all the treasures ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nvector<int> p[maxn];\nint b[maxn];\n\nint main() {\n    int n, m, k, q; scanf(""%d%d%d%d"", &n, &m, &k, &q);\n    int tp = 0;\n    for (int i = 0; i < k; ++i) {\n        int r, c; scanf(""%d%d"", &r, &c);\n        p[r].push_back(c);\n        tp = max(tp, r);\n    }\n    for (int i = 0; i < q; ++i) scanf(""%d"", &b[i]);\n    sort(b, b + q);\n    \n    int prv = 1, s = 1;\n    vector<pair<int, long long>> cand;\n\n    if (p[1].empty()) {\n        for (int i = 0; i < q; ++i) cand.emplace_back(b[i], b[i] - 1); \n        s = 2;\n    } else {\n        cand = {make_pair(1, 0)};\n    }\n\n    for (int i = s; i <= n; ++i) {\n        if (p[i].empty()) continue;\n        sort(p[i].begin(), p[i].end());\n        int dist = i - prv;\n        int lb = p[i].front(), rb = p[i].back();\n        long long ld = 1e18, rd = 1e18;\n\n        for (int j = 0; j < (int)cand.size(); ++j) {\n            long long ldp = cand[j].second + abs(cand[j].first - rb) + abs(rb - lb) + dist;\n            long long rdp = cand[j].second + abs(cand[j].first - lb) + abs(rb - lb) + dist;\n            ld = min(ld, ldp);\n            rd = min(rd, rdp);\n        }\n\n        if (i == tp) {\n            printf(""%lld\\n"", min(ld, rd));\n            return 0;\n        }\n\n        int pos = lower_bound(b, b + q, lb) - b;\n        vector<pair<int, long long>> ncand;\n        if (pos != q) ncand.emplace_back(b[pos], ld + abs(b[pos] - lb));\n        if (pos > 0) ncand.emplace_back(b[pos - 1], ld + abs(b[pos - 1] - lb));\n        pos = lower_bound(b, b + q, rb) - b;\n        if (pos != q) ncand.emplace_back(b[pos], rd + abs(b[pos] - rb));\n        if (pos > 0) ncand.emplace_back(b[pos - 1], rd + abs(b[pos - 1] - rb));\n\n        cand = ncand;\n        prv = i;\n    }\n    assert(false);\n}\n']","['binary search', 'dp', 'greedy', 'implementation']",2100
https://codeforces.com//contest/1775/problem/C,C. Interesting Sequence,Petya and his friend robot Petya like to solve exciting math problems One day Petya came up with the numbers n and x and wrote the following equality on the board n n 1 dots m x where denotes the bitwise AND operation Then he suggested his friend Petya find such a minimal m m ge n that the equality on the board holds Unfortunately Petya couldn t solve this problem in his head and decided to ask for computer help He quickly wrote a program and found the answer Can you solve this difficult problem ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tint n,x;\n\t\tcin>>n>>x;\n\t\t\n\t\tint res=n^x;\n\t\t\n\t\tif (n==x) cout<<n<<endl;\n\t\telse if (x==0) cout<<(2LL<<__lg(n))<<endl;\n\t\telse if ((n&x)==x && __builtin_ctzll(n^res)>__lg(res)+1){\n\t\t\tint temp=2LL<<__lg(res);\n\t\t\tn-=n&(temp-1);\n\t\t\tn|=temp;\n\t\t\tcout<<n<<endl;\n\t\t}\n\t\telse cout<<""-1""<<endl;\n\t}\n}\n']","['bitmasks', 'math']",1600
https://codeforces.com//contest/336/problem/B,B. Vasily the Bear and Fly,One beautiful day Vasily the bear painted circles of the same radius on a coordinate plane Circles with numbers from to had centers at points respectively Circles with numbers from to had centers at points respectively Naturally the bear painted the circles for a simple experiment with a fly The experiment continued for days Each day of the experiment got its own unique number from to inclusive On the day number the following things happened The fly arrived at the coordinate plane at the center of the circle with number is the result of dividing number by number rounded down to an integer The fly went along the coordinate plane to the center of the circle number is the remainder after dividing number by number The bear noticed that the fly went from the center of circle to the center of circle along the shortest path with all points lying on the border or inside at least one of the circles After the fly reached the center of circle it flew away in an unknown direction Help Vasily count the average distance the fly went along the coordinate plane during each of these days ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint m, i;\ndouble Now, S, r, dis[100005], s[100005];\n\nint main()\n{\n\tscanf(""%d %lf"", &m, &r);\n\tdis[0] = r * 2.0;\n\tdis[1] = r * 2.0 + r * sqrt(2.0);\n\tdis[2] = r * 2.0 + 2 * r * sqrt(2.0);\n\tfor (i = 3; i <= m; i++)\n\t\tdis[i] = dis[i - 1] + r * 2.0;\n\ts[0] = dis[0];\n\tfor (i = 1; i <= m; i++)\n\t\ts[i] = s[i - 1] + dis[i];\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tNow = s[i - 1] + s[m - i] - dis[0];\n\t\tNow /= (double)(m);\n\t\tS += Now;\n\t}\n\t\n\tS /= (double)(m);\n\tprintf(""%.10lf\\n"", S);\n\treturn 0;\n}\n']",['math'],1900
https://codeforces.com//contest/1166/problem/E,E. The LCMs Must be Large,Dora the explorer has decided to use her money after several years of juicy royalties to go shopping What better place to shop than Nlogonia There are n stores numbered from 1 to n in Nlogonia The i th of these stores offers a a i Each day among the last m days Dora bought a single integer from some of the stores The same day Swiper the fox bought a single integer from all the stores that Dora did not buy an integer from on that day Dora considers Swiper to be her rival and she considers that she beat Swiper on day i if and only if the least common multiple of the numbers she bought on day i is strictly greater than the least common multiple of the numbers that Swiper bought on day i The least common multiple LCM of a collection of integers is the smallest positive integer that is divisible by all the integers in the collection However Dora forgot the values of a i Help Dora find out if there are positive integer values of a i such that she beat Swiper on day You don t need to find what are the possible values of a i though Note that it is possible for some values of a i to coincide in a solution ,"['#pragma GCC optimize(""Ofast"")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define y0 holdtheflower\n#define y1 enjoythecolorandscent\n#define yn walkthroughthesoulgarden\n#define j1 feelthewarmbreathofkindnessandsalvation\n\n#define endl \'\\n\'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint m, n;\nvector<vector<bool>> Dora, Swiper;\n\nbool contains(vector<bool> &a, vector<bool> &b) {\n\tfor (int i=0; i<a.size(); i++) {\n\t\tif (!a[i]) continue;\n\t\tif (b[i]) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid Input() {\n\tcin >> m >> n; Dora.resize(m); Swiper.resize(m);\n\tfor (int i=0; i<m; i++) {\n\t\tDora[i].resize(n, false); Swiper[i].resize(n, true);\n\t\tint s; cin >> s;\n\t\tfor (int x=0; x<s; x++) {\n\t\t\tint z; cin >> z; z--;\n\t\t\tDora[i][z] = true; Swiper[i][z] = false;\n\t\t}\n\t}\n}\n\nvoid Solve() {\n\tfor (int i=0; i<m; i++) {\n\t\tfor (int j=0; j<m; j++) {\n\t\t\tif (contains(Dora[i], Swiper[j])) {\n\t\t\t\tcout << ""impossible\\n""; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ""possible\\n"";\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}\n\n/******************************************\\\n *  Thuy-Trang Tran, #Team4T\'s Leader     *\n *  #Team4T Primary Flagship - Salvation  *\n\\******************************************/']","['bitmasks', 'brute force', 'constructive algorithms', 'math', 'number theory']",2100
https://codeforces.com//contest/1325/problem/F,F. Ehab s Last Theorem,It s the year 5555 You have a graph and you want to find a long cycle and a huge independent set just because you can But for now let s just stick with finding either Given a connected graph with n vertices you can choose to either find an independent set that has lceil sqrt n rceil vertices find a cycle of length lceil sqrt n rceil An independent set is a set of vertices such that no two of them are connected by an edge A simple cycle is a cycle that doesn t contain any vertex twice I have a proof you can always solve one of these problems but it s too long to fit this margin ,"['///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 2e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, m, sq, sq2;\nvector<int> g[maxn], ta[maxn];\nint mark[maxn], h[maxn], par[maxn];\n\nvoid dfs(int v)\n{\n    ta[h[v]%sq2].push_back(v);\n    mark[v] = 1;\n    for(auto u : g[v])\n        if(!mark[u])\n        {\n            h[u] = h[v] + 1;\n            par[u] = v;\n            dfs(u);\n        }\n        else\n            if(h[v] - h[u] + 1 >= sq)\n            {\n                cout<< 2 <<""\\n"";\n\n                vector<int> ans;\n                int V = v;\n                while(v != u)\n                {\n                    ans.push_back(v);\n                    v = par[v];\n                }\n                ans.push_back(u);\n\n                cout<< ans.size() <<""\\n"";\n                for(auto x : ans) cout<< x <<"" "";\n\n                exit(0);\n            }\n\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n >> m;\n    int x = sqrt(n);\n    if(x * x == n)\n        sq = sqrt(n);\n    else\n        sq = sqrt(n) + 1;\n    sq2 = sqrt(n);\n\n    for(int i = 1, u , v; i <= m; i++)\n    {\n        cin>> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(1);\n\n    cout<< 1 <<""\\n"";\n    for(int i = 0; i < sq2; i++)\n        if(ta[i].size() >= sq)\n        {\n            for(int j = 0; j < sq; j++)\n                cout<< ta[i][j] <<"" "";\n            return 0;\n        }\n}\n\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']",2500
https://codeforces.com//contest/1367/problem/A,A. Short Substrings,Alice guesses the strings that Bob made for her At first Bob came up with the secret string a consisting of lowercase English letters The string a has a length of 2 or more characters Then from string a he builds a new string b and offers Alice the string b so that she can guess the string a Bob builds b from a as follows he writes all the substrings of length 2 of the string a in the order from left to right and then joins them in the same order into the string b For example if Bob came up with the string a then all the substrings of length 2 of the string a are Therefore the string b You are given the string b Help Alice to guess the string a that Bob came up with It is guaranteed that b was built according to the algorithm given above It can be proved that the answer to the problem is unique ,"[""#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nvoid f()\n{\n\tstring s, ans;\n\tcin >> s;\n\tans += s[0];\n\tfl(i,1,s.size())\n\t{\n\t\tans += s[i];\n\t\ti++;\n\t}\t\t\n\tcout << ans << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}""]","['implementation', 'strings']",800
https://codeforces.com//contest/1809/problem/B,B. Points on Plane,You are given a two dimensional plane and you need to place n chips on it You can place a chip only at a point with integer coordinates The cost of placing a chip at the point x y is equal to x y where a is the absolute value of a The cost of placing n chips is equal to the among the costs of each chip You need to place n chips on the plane in such a way that the Euclidean distance between each pair of chips is than 1 and the cost is the minimum possible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    i64 x = std::sqrt(n);\n    while (x * x < n) {\n        x += 1;\n    }\n    while ((x - 1) * (x - 1) >= n) {\n        x -= 1;\n    }\n    \n    x -= 1;\n    \n    std::cout << x << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['binary search', 'greedy', 'math']",1000
https://codeforces.com//contest/101/problem/E,E. Candies and Stones,Little Gerald and his coach Mike play an interesting game At the beginning of the game there is a pile consisting of candies and a pile consisting of stones Gerald and Mike move in turns Mike goes first During his move Mike checks how many candies and stones Gerald has eaten Let Gerald eat candies and stones Then Mike awards Gerald prize points Gerald during his move either eats a candy from the pile of candies or a stone from the pile of stones As Mike sees that Gerald has eaten everything apart one candy and one stone he awards points for the last time and the game ends Gerald is not allowed to eat all the candies and he is not allowed to eat all the stones too Tell Gerald how to play to get the largest possible number of points it is required to find one of the possible optimal playing strategies for Gerald ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++) \n#define REP(i,n) FOR(i,0,n) \n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint n,m,p;\nint x[22222];\nint y[22222];\nint d[10007][650];\n\nint d1[20000];\nint d2[20000];\n\nstring res;\nbool first = true;\n\nvoid go(){\n\tif(n==0 && m==0) return;\n\tif(n==0){\n\t\tres.pb(\'S\');\n\t\tm--;\n\t\tgo();\n\t\treturn;\n\t}\n\tif(m==0){\n\t\tres.pb(\'C\');\n\t\tn--;\n\t\tgo();\n\t\treturn;\n\t}\n\t\n\tif(n==10000 && first){\n\t\tfirst = false;\n\t\treturn;\n\t}\n\n\tint row = n;\n\tif(row>10000) row-=10000;\n\n\tint md = m % 31;\n\tint dv = m / 31;\n\t\t\t\n\tif(d[row][dv] &(1<<md)){\n\t\tres.pb(\'S\');\n\t\tm--;\n\t\tgo();\n\t}else{\n\t\tres.pb(\'C\');\n\t\tn--;\n\t\tgo();\n\t}\n}\n\nint solve(){\n\tCL(d1,0);\n\tCL(d2,0);\n\tCL(d,0);\n\n\tint *f1 = d1;\n\tint *f2 = d2;\n\n\tREP(i,n){\n\t\tint md = -1;\n\t\tint dv = 0;\n\t\tREP(j,m){\n\t\t\tmd ++;\n\t\t\tif(md>=31) md-=31,dv++;\n\t\t\tint row = i;\n\t\t\tif(row>10000) row-=10000;\n\t\t\tif(d[row][dv] &(1<<md))\n\t\t\t\td[row][dv] ^= (1<<md);\n\n\t\t\tf1[j] = (x[i]+y[j]);\n\t\t\tif(f1[j]>=p) f1[j]-=p;\n\n\t\t\tint v1 = j?f1[j-1]:-1;\n\t\t\tint v2 = i?f2[j]:-1;\n\n\t\t\tif(v1==-1 && v2==-1) continue;\n\t\t\t\n\t\t\t\n\t\t\tif(v1>v2){\n\t\t\t\tf1[j] += v1;\n\t\t\t\td[row][dv] |= (1<<md);\n\t\t\t}else{\n\t\t\t\tf1[j] += v2;\n\t\t\t}\n\t\t}\n\t\tswap(f1,f2);\n\t}\n\treturn f2[m-1];\n}\n\nbool check(string s,int val){\n\tint t = (x[0] +y[0])%p;\n\tint a = 0, b = 0;\n\tREP(i,s.size()){\n\t\tif(s[i]==\'C\') a++;\n\t\telse b++;\n\t\tt += (x[a] + y[b])%p;\n\t}\n\tif(t!=val){\n\t\tputs(""FUCK"");\n\t\treturn 0;\n\t}\n\telse puts(""OK"");\n\treturn 1;\n}\n\nint main(){ \n#ifdef LocalHost\n\tfreopen(""input.txt"",""r"",stdin);\n//\tfreopen(""output.txt"",""w"",stdout);\n#endif\n\tcin>>n>>m>>p;\n\t\n\t/*int it = 0;\nhere:\n\tit++;\n\tsrand(it);\n\t\n\tn = 11111;//9999 + rand()%10 + 1;\n\tm = 5;// + rand() %100 + 1;\n\tp = rand() % 1000 + 1;\n\t*/\n\tREP(i,n){\n\t\tscanf(""%d"",x+i);\n\t\t//x[i] = rand();\n\t\tx[i]%=p;\n\t}\n\tREP(i,m){\n\t\tscanf(""%d"",y+i);\n\t\t//y[i] = rand();\n\t\ty[i]%=p;\n\t}\n\t\n\tres="""";\n\tint qq = solve();\n\tcout<<qq<<endl;\n\tn--,m--;\n\tgo();\n\tn++,m++;\n\tsolve();\n\tn--,m--;\n\tgo();\n\treverse(res.begin(),res.end());\n\t//if(check(res,qq))\n\t//\tgoto here;\n\tprintf(""%s\\n"",res.c_str());\n#ifdef LocalHost\n\tcout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n\treturn 0;\n}']","['divide and conquer', 'dp']",2500
https://codeforces.com//contest/733/problem/C,C. Epidemic in Monstropolis,There was an epidemic in Monstropolis and all monsters became sick To recover all monsters lined up in queue for an appointment to the only doctor in the city Soon monsters became hungry and began to eat each other One monster can eat other monster if its weight is than the weight of the monster being eaten and they stand in the queue next to each other Monsters eat each other instantly There are no monsters which are being eaten at the same moment After the monster eats the monster the weight of the monster increases by the weight of the eaten monster In result of such eating the length of the queue decreases by one all monsters after the eaten one step forward so that there is no empty places in the queue again A monster can eat several monsters one after another Initially there were monsters in the queue the th of which had weight For example if weights are in order of queue monsters are numbered from to from left to right then some of the options are the first monster can t eat the second monster because is not greater than the second monster can t eat the third monster because is not greater than the second monster can t eat the fifth monster because they are not neighbors the second monster can eat the first monster the queue will be transformed to After some time someone said a good joke and all monsters recovered At that moment there were monsters in the queue the th of which had weight Both sequences and contain the weights of the monsters in the order from the first to the last You are required to provide one of the possible orders of eating monsters which led to the current queue or to determine that this could not happen Assume that the doctor didn t make any appointments while monsters were eating each other ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int MX=(1<<20) , inf = -(1<<29);\nint dp[509][509];\nint sum[509] , n , arr[509];\nvector < pair < int , char > > sol;\nint calc(int x , int y){\n    if(x > y || x == y) return 1;\n    int &ret = dp[x][y]; if(ret != -1) return ret;\n    ret = 0;\n    for(int k = x ; k < y ; k++){\n        if(sum[k] - sum[x-1] != sum[y] - sum[k])\n            ret |= ( calc(x , k) && calc(k+1 , y) );\n    }\n    return ret;\n}\nvoid find_sol(int x , int y , int add){\n    if(x > y || x == y) return;\n    for(int k = x ; k < y ; k++){\n        if(sum[k] - sum[x-1] != sum[y] - sum[k] && calc(x , k) && calc(k+1 , y) ){\n            find_sol(x , k , add);\n            find_sol(k+1 , y , add+1);\n            if(sum[k] - sum[x-1] > sum[y] - sum[k])\n                sol.push_back({add+1 , \'R\'});\n            else sol.push_back({add+2 , \'L\'});\n            break;\n        }\n    }\n}\nbool solve(vector < int > v){\n    n = v.size();\n    for(int j=1;j<=n;j++){\n        arr[j] = v[j-1];\n        sum[j] = arr[j] + sum[j-1];\n    }\n    memset(dp , -1 , sizeof(dp));\n    sol.clear();\n    if(!calc(1,n)) return 0;\n    find_sol(1 , n , 0);\n    return 1;\n}\nint aa , bb;\nint main(){\n    scanf(""%d"",&aa);\n    vector < int > src;\n    for(int j=1;j<=aa;j++){\n        int x;\n        scanf(""%d"",&x);\n        src.push_back(x);\n    }\n    bool nosol = 0;\n    reverse(src.begin() , src.end());\n    scanf(""%d"",&bb);\n    vector < pair < int , char > > wholy;\n    for(int iter = 1 ; iter <= bb ; iter++){\n        vector < int > v;\n        int x;\n        scanf(""%d"",&x);\n        while(!src.empty()){\n            if(src.back() > x) break;\n            v.push_back(src.back());\n            x-=src.back();\n            src.pop_back();\n        }\n        if(x){\n            nosol = 1;\n            break;\n        }\n        if(!solve(v)){\n            nosol = 1;\n            break;\n        }\n        for(auto pp : sol)\n            wholy.push_back({pp.first + iter -1 , pp.second});\n    }\n    if(src.size()) nosol = 1;\n    if(nosol){\n        puts(""NO"");\n        return 0;\n    }\n    puts(""YES"");\n    for(auto pp : wholy)\n        cout<<pp.first<<\' \'<<pp.second<<endl;\n}\n\n']","['constructive algorithms', 'dp', 'greedy', 'two pointers']",1800
https://codeforces.com//contest/677/problem/E,E. Vanya and Balloons,Vanya plays a game of balloons on the field of size where each cell contains a balloon with one of the values or The goal is to destroy a cross such that the product of all values of balloons in the cross is maximum possible There are two types of crosses normal and rotated For example o o ooooo o o oro o o o o o o o oFormally the cross is given by three integers and such that The normal cross consists of balloons located in cells where stay for the number of the row and for the number of the column such that and Rotated cross consists of balloons located in cells such that and Vanya wants to know the maximum possible product of the values of balls forming one cross As this value can be large output it modulo ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst int md=1e9+7;\nint n;\nint a[1003][1003];\nchar q;\nlong double d2[100000];\nlong double d3[100000];\nint up[1003][1003][4];\nint dn[1003][1003][4];\nint lt[1003][1003][4];\nint rt[1003][1003][4];\nint lu[1003][1003][4];\nint ru[1003][1003][4];\nint lulu[1003][1003];\nint ruru[1003][1003];\nint rdrd[1003][1003];\nint ldld[1003][1003];\nint ll[1003][1003];\nint rr[1003][1003];\nint dd[1003][1003];\nint uu[1003][1003];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin>>n;\n    long double k2=log(2.);\n    long double k3=log(3.);\n    for(int i=1;i<=10000;i++)\n    {\n        d2[i]=d2[i-1]+k2;\n        d3[i]=d3[i-1]+k3;\n    }\n    bool f=false;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            cin>>q;\n            a[i][j]=q-\'0\';\n            if(a[i][j]==1)\n                f=true;\n            for(int k=0;k<=3;k++)\n            {\n                up[i][j][k]=up[i-1][j][k];\n                lt[i][j][k]=lt[i][j-1][k];\n                lu[i][j][k]=lu[i-1][j-1][k];\n            }\n            up[i][j][a[i][j]]++;\n            lt[i][j][a[i][j]]++;\n            lu[i][j][a[i][j]]++;\n            if(a[i][j]==0)\n            {\n                uu[i][j]=0;\n                ll[i][j]=0;\n            }else\n            {\n                uu[i][j]=uu[i-1][j]+1;\n                ll[i][j]=ll[i][j-1]+1;\n            }\n        }\n    for(int i=n;i>0;--i)\n        for(int j=n;j>0;--j)\n        {\n            for(int k=0;k<=3;k++)\n            {\n                dn[i][j][k]=dn[i+1][j][k];\n                rt[i][j][k]=rt[i][j+1][k];\n            }\n            dn[i][j][a[i][j]]++;\n            rt[i][j][a[i][j]]++;\n            if(a[i][j]==0)\n            {\n                dd[i][j]=0;\n                rr[i][j]=0;\n            }else\n            {\n                dd[i][j]=dd[i+1][j]+1;\n                rr[i][j]=rr[i][j+1]+1;\n            }\n        }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            if(a[i][j])\n                lulu[i][j]=1+lulu[i-1][j-1];\n        }\n    for(int i=1;i<=n;i++)\n        for(int j=n;j;--j)\n        {\n            for(int k=0;k<=4;k++)\n                ru[i][j][k]=ru[i-1][j+1][k];\n            ru[i][j][a[i][j]]++;\n            if(a[i][j])\n               ruru[i][j]=1+ruru[i-1][j+1];\n        }\n    for(int i=n;i;--i)\n        for(int j=1;j<=n;j++)\n            if(a[i][j])\n                ldld[i][j]=1+ldld[i+1][j-1];\n    for(int i=n;i;--i)\n        for(int j=n;j;--j)\n            if(a[i][j])\n                rdrd[i][j]=1+rdrd[i+1][j+1];\n    pair<int,int> ans=make_pair(0,0);\n    long double rans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(a[i][j])\n            {\n                int kek=n;\n                kek=min(kek,dd[i][j]);\n                kek=min(kek,uu[i][j]);\n                kek=min(kek,ll[i][j]);\n                kek=min(kek,rr[i][j]);\n                int a2=up[i+kek-1][j][2]-up[i-kek][j][2]+lt[i][j+kek-1][2]-lt[i][j-kek][2];\n                int a3=up[i+kek-1][j][3]-up[i-kek][j][3]+lt[i][j+kek-1][3]-lt[i][j-kek][3];\n                if(a[i][j]==2)\n                    --a2;\n                else\n                if(a[i][j]==3)\n                    --a3;\n                if(d2[a2]+d3[a3]>rans)\n                {\n                    rans=d2[a2]+d3[a3];\n                    ans=make_pair(a2,a3);\n                }\n                kek=n;\n                kek=min(kek,lulu[i][j]);\n                kek=min(kek,ruru[i][j]);\n                kek=min(kek,ldld[i][j]);\n                kek=min(kek,rdrd[i][j]);\n                a2=lu[i+kek-1][j+kek-1][2]-lu[i-kek][j-kek][2]+ru[i+kek-1][j-kek+1][2]-ru[i-kek][j+kek][2];\n                a3=lu[i+kek-1][j+kek-1][3]-lu[i-kek][j-kek][3]+ru[i+kek-1][j-kek+1][3]-ru[i-kek][j+kek][3];\n                if(a[i][j]==2)\n                    --a2;\n                else\n                if(a[i][j]==3)\n                    --a3;\n                if(d2[a2]+d3[a3]>rans)\n                {\n                    rans=d2[a2]+d3[a3];\n                    ans=make_pair(a2,a3);\n                }\n            }\n    long long cur_ans=1;\n    if(ans==make_pair(0,0))\n    {\n        if(f)\n            cout<<""1\\n"";\n        else\n            cout<<""0\\n"";\n    }else\n    {\n        for(int i=0;i<ans.first;i++)\n            cur_ans=(cur_ans+cur_ans)%md;\n        for(int i=0;i<ans.second;i++)\n            cur_ans=(cur_ans+cur_ans+cur_ans)%md;\n        cout<<cur_ans<<""\\n"";\n    }\n}\n']","['binary search', 'brute force', 'dp', 'implementation']",2300
https://codeforces.com//contest/1692/problem/E,E. Binary Deque,Slavic has an array of length n consisting only of zeroes and ones In one operation he removes either the first or the last element of the array What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to s after performing all the operations In case the sum s can t be obtained after any amount of operations you should output ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""E""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, s;\n        cin >> n >> s;\n        vector<int> a(n);\n        cin >> a;\n        if (accumulate(all(a), 0) < s) {\n            cout << ""-1\\n"";\n            continue;\n        }\n        vector<int> pref(n + 1, 0);\n        for (int i = 0; i < n; ++i)\n            pref[i + 1] = pref[i] + a[i];\n        int ans = n;\n        for (int i = 0; i < n; ++i) {\n            if (pref[n] - pref[i] < s) break;\n            int j = upper_bound(all(pref), pref[i] + s) - pref.begin();\n            ans = min(ans, i + n - j + 1);\n        }\n        cout << ans << endl;\n    }\n}']","['binary search', 'implementation', 'two pointers']",1200
https://codeforces.com//contest/1810/problem/E,E. Monsters,There is an undirected graph with n vertices and m edges Initially for each vertex i there is a monster with danger a i on that vertex For a monster with danger a i you can defeat it if and only if you have defeated at least a i other monsters before Now you want to defeat all the monsters First you choose some vertex s and defeat the monster on that vertex since you haven t defeated any monsters before a s has to be 0 Then you can move through the edges If you want to move from vertex u to vertex v then the following must hold either the monster on vertex v has been defeated before or you can defeat it now For the second case you defeat the monster on vertex v and reach vertex v You can pass the vertices and the edges any number of times Determine whether you can defeat all the monsters or not ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int leader(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return leader(x) == leader(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[leader(x)];\n    }\n};\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        \n        if (std::pair(a[u], u) < std::pair(a[v], v)) {\n            std::swap(u, v);\n        }\n        adj[u].push_back(v);\n    }\n    \n    std::vector<bool> ok(n);\n    \n    std::vector<int> order(n);\n    std::iota(order.begin(), order.end(), 0);\n    std::sort(order.begin(), order.end(), [&](int i, int j) {\n        return std::pair(a[i], i) < std::pair(a[j], j);\n    });\n    \n    DSU dsu(n);\n    \n    for (auto x : order) {\n        ok[x] = a[x] == 0;\n        for (auto y : adj[x]) {\n            y = dsu.leader(y);\n            if (ok[y] && dsu.size(y) >= a[x]) {\n                ok[x] = true;\n            }\n            dsu.merge(x, y);\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!dsu.same(0, i)) {\n            std::cout << ""NO\\n"";\n            return;\n        }\n    }\n    \n    if (ok[dsu.leader(0)]) {\n        std::cout << ""YES\\n"";\n    } else {\n        std::cout << ""NO\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy']",2100
https://codeforces.com//contest/1086/problem/B,B. Minimum Diameter Tree,You are given a tree an undirected connected graph without cycles and an integer s Vanya wants to put weights on all edges of the tree so that all weights are non negative real numbers and their sum is s At the same time he wants to make the diameter of the tree as small as possible Let s define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree In other words the diameter of a weighed tree is the length of the longest simple path in the tree where length of a path is equal to the sum of weights over all edges in the path Find the minimum possible diameter that Vanya can get ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, S;\n  cin >> N >> S;\n\n  vector<int> degs(N + 1);\n  for (int i = 0; i < N - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ++degs[u];\n    ++degs[v];\n  }\n\n  const int leaves = count(ALL(degs), 1);\n\n  cout << (LD)2 * S / leaves << ""\\n"";\n}\n\n']","['greedy', 'implementation', 'trees']",1700
https://codeforces.com//contest/387/problem/B,B. George and Round,George decided to prepare a Codesecrof round so he has prepared problems for the round Let s number the problems with integers through George estimates the th problem s complexity by integer To make the round he needs to put at least problems there Besides he needs to have at least one problem with complexity exactly at least one with complexity exactly and at least one with complexity exactly Of course the round can also have problems with other complexities George has a poor imagination It s easier for him to make some already prepared problem simpler than to come up with a new one and prepare it George is magnificent at simplifying problems He can simplify any already prepared problem with complexity to any positive integer complexity by changing limits on the input data However nothing is so simple George understood that even if he simplifies some problems he can run out of problems for a round That s why he decided to find out the minimum number of problems he needs to come up with in addition to the he s prepared in order to make a good round Note that George can come up with a new problem of any complexity ,"['#include <bits/stdc++.h>\n\n\n\n#define NN 3333\n\nusing namespace std;\n\ntypedef long long INT;\n\ntypedef pair<int, int> pii;\n\n\n\nint a[NN], b[NN];\n\n\n\nint main() {\n\n\n\n\tint n,m,i,j;\n\n\tcin>>n>>m;\n\n\t\n\n\tfor(i=0; i<n; i++) scanf(""%d"", a+i);\n\n\tfor(i=0; i<m; i++) scanf(""%d"", b+i);\n\n\t\n\n\tint pos=m-1;\n\n\tint ans=0;\n\n\tfor(i=n-1; i>=0; i--){\n\n\t\tif(pos<0) break;\n\n\t\tif(b[pos]>=a[i]) pos--;\n\n\t\telse ans++;\n\n\t}\n\n\tans+=i+1;\n\n\tcout<<ans<<endl;\n\n\n\n\treturn 0;\n\n}\n\n\n                ']","['brute force', 'greedy', 'two pointers']",1200
https://codeforces.com//contest/1300/problem/B,B. Assigning to Classes,of the array a 1 a 2 dots a 2k 1 of odd number of elements is defined as follows let b 1 b 2 dots b 2k 1 be the elements of the array in the sorted order Then median of this array is equal to b k 1 There are 2n students the i th student has skill level a i It s that all skill levels are distinct Let s define as the median of skill levels of students of the class As a principal of the school you would like to assign each student to one of the 2 classes such that each class has not divisible by 2 The number of students in the classes may be equal or different by your choice Every student has to be assigned to exactly one class Among such partitions you want to choose one in which the absolute difference between skill levels of the classes is minimized What is the minimum possible absolute difference you can achieve ,"['#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < \'0\' || ch > \'9\') && ch != \'-\') ch = getchar();\n\tif(ch == \'-\'){f = true; ch = getchar();}\n\twhile(ch >= \'0\' && ch <= \'9\'){x = x * 10 + ch - \'0\'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nconst int N = 200003;\nint n, a[N], t, ans;\nint main(){\n\tread(t);\n\twhile(t --){\n\t\tread(n);\n\t\tfor(Rint i = 1;i <= 2 * n;++ i) read(a[i]);\n\t\tsort(a + 1, a + 2 * n + 1);\n\t\tprintf(""%d\\n"", a[n + 1] - a[n]);\n\t}\n}']","['greedy', 'implementation', 'sortings']",1000
https://codeforces.com//contest/1825/problem/C,C. LuoTianyi and the Show,There are n people taking part in a show about VOCALOID They will sit in the row of seats numbered 1 to m from left to right The n people come and sit in order Each person occupies a seat in one of three ways Sit in the seat next to the left of the leftmost person who is already sitting or if seat 1 is taken then leave the show If there is no one currently sitting sit in seat m Sit in the seat next to the right of the rightmost person who is already sitting or if seat m is taken then leave the show If there is no one currently sitting sit in seat 1 Sit in the seat numbered x i If this seat is taken then leave the show Now you want to know what is the maximum number of people that can take a seat if you can let people into the show in any order ,"['#pragma GCC optimize(""Ofast,unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")\n#include<bits/stdc++.h>\n#define int long long\nconst int N=2e5+5,M=305;\nusing namespace std;\nint m,n;\nint l,r,len;\nint a[N],sum;\nvoid solve()\n{\n\tcin>>n>>m;\n\tl=0;r=0;len=0;sum=0;\n\tfor(int i=1,x;i<=n;i++)\n\t{\n\t\tcin>>x;\n\t\tif(x==-1)l++;\n\telse if(x==-2)r++;\n\telse a[++len]=x;\n\t}\n\tsort(a+1,a+len+1);\n\tlen=unique(a+1,a+len+1)-a-1;\n//\tcout<<""debug:""<<l<<\' \'<<r<<\' \'<<len<<\' \'<<n<<\' \'<<m<<\'\\n\';\n\tfor(int i=1;i<=len;i++)\n\tsum=max(sum,min(a[i]-i,l)+min(m-a[i]-len+i,r));\n\tsum=max({sum,min(m-len,r),min(m-len,l)});\n\tcout<<sum+len<<\'\\n\';\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}']","['greedy', 'sortings']",1400
https://codeforces.com//contest/131/problem/B,B. Opposites Attract,Everybody knows that opposites attract That is the key principle of the Perfect Matching dating agency The Perfect Matching matchmakers have classified each registered customer by his interests and assigned to the th client number Of course one number can be assigned to any number of customers Perfect Matching wants to advertise its services and publish the number of opposite couples that is the couples who have opposite values of Each couple consists of exactly two clients The customer can be included in a couple an arbitrary number of times Help the agency and write the program that will find the sought number by the given sequence For example if then any two elements and form a couple if and have different parity Consequently in this case the sought number equals 4 Of course a client can t form a couple with him herself ,"['#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nmap <int,int> a;\nint main()\n{\n    int n;\n    scanf(""%d"",&n);\n    for (int i=1;i<=n;i++)\n    {\n        int x=0;\n        scanf(""%d"",&x);\n        a[x]++;\n    }\n    ll ans=0;\n    for (int i=1;i<=10;i++)\n        ans+=ll(a[i])*a[-i];\n    ans+=ll(a[0])*(a[0]-1)/2;\n    printf(""%I64d\\n"",ans);\n    return(0);\n}\n']","['implementation', 'math']",1200
https://codeforces.com//contest/47/problem/A,A. Triangular numbers,A triangular number is the number of dots in an equilateral triangle uniformly filled with dots For example three dots can be arranged in a triangle thus three is a triangular number The th triangular number is the number of dots in a triangle with dots on a side You can learn more about these numbers from Wikipedia http en wikipedia org wiki Triangular number Your task is to find out if a given integer is a triangular number ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define VT vector\ntypedef VT<int> VI;\ntypedef VT<VI> VVI;\ntypedef VT<string> VS;\ntypedef VT<double> VD;\ntypedef VT<VD> VVD;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,a,b) for(int i=(int)a;i<=(int)b;++i)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define MP make_pair\n\n\nint main(int argc, char* argv[])\n{\n    int n; \n    cin>>n;\n\n    bool yes = false;\n\n    for(int i = 1; i <= n; ++i)\n    {\n        if (i*(i+1) / 2 == n)\n            yes = true;\n    }\n\n    if (yes)\n        cout << ""YES\\n"";\n    else\n        cout << ""NO\\n"";\n\n    int temp;\n    std::cin >> temp;\n}\n']","['brute force', 'math']",800
https://codeforces.com//contest/861/problem/A,A. k-rounding,For a given positive integer denote its rounding as the minimum positive integer such that ends with or more zeros in base and is divisible by For example rounding of is is the minimum integer such that it ends with or more zeros and is divisible by Write a program that will perform the rounding of ,"['#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n#define DEBUG(numx) cout << \'>\' << #numx << \':\' << numx << endl;\n#define REP(idx1,num1) for(int idx1=0;idx1<(num1);idx1++)\n#define FOR(idx1,num1,bin) for(int idx1=(num1);idx1<=(bin);idx1++)\n#define FORD(idx1,num1,bin) for(int idx1=(num1);idx1>=(bin);idx1--)\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(""%d"",&num1)\n#define sll(num1) scanf(""%lld"",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define ll long long\n#define TRACE\n \n//FILE *fin = freopen(""in"",""r"",stdin);\n//FILE *fout = freopen(""out"",""s2numx"",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << "": "" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << "" | "" << #nn3 << "": "" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << endl;\n#define trace5(num1, bin, ch, d, e)    cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #e << "": "" << e << endl;\n#define trace6(num1, bin, ch, d, e, det) cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #e << "": "" << e << "" | "" << #det << "": "" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, e)\n#define trace6(num1, bin, ch, d, e, det)\n \n#endif\n #define ll long long\n#define pi(numx) printf(""%d\\num1"",numx)\n#define F first\n#define pb push_back\n#define mp make_pair\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n\n\nint main() {\n\tll num1,num2;\n\tcin >> num1 >> num2;\n\tll kent1 = 1LL;\n\tfor (int i = 1 ; i <= num2 ; i++)\n\t\tkent1 *= 10LL;\n\tll result = __gcd(kent1,num1);\n\tcout << kent1 / result * num1 << endl;\n\treturn 0;\n}\n ']","['math', 'number theory']",1100
https://codeforces.com//contest/1283/problem/A,A. Minutes Before the New Year,New Year is coming and you are excited to know how many minutes remain before the New Year You know that currently the clock shows h hours and m minutes where 0 le hh 24 and 0 le mm 60 Your task is to find the number of minutes before the New Year You know that New Year comes when the clock shows 0 hours and 0 minutes You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tint t;\n\tscanf(""%d"",&t);\n\n\tfor(int k = 0 ; k < t ; k++)\n\t{\n\t\tint h, m;\n\t\tscanf(""%d %d"",&h,&m);\n\n\t\tint all = 24*60;\n\t\tall -= h*60;\n\t\tall -= m;\n\n\t\tprintf(""%d\\n"",all);\n\t}\n}']",['math'],800
https://codeforces.com//contest/1497/problem/C1,C1. k-LCM  easy version ,You are given a positive integer n Find k positive integers a 1 a 2 ldots a k such that a 1 a 2 ldots a k n LCM a 1 a 2 ldots a k le frac n 2 Here LCM is the least common multiple of numbers a 1 a 2 ldots a k We can show that for given constraints the answer always exists ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n, k;\n        cin >> n >> k;\n        while (k > 3) {\n            --k;\n            --n;\n            cout << 1 << "" "";\n        }\n        if (n % 2) {\n            cout << 1 << "" "" << n / 2 << "" "" << n / 2 << \'\\n\';\n        } else {\n            if (n % 4 == 0) cout << n / 2 << "" "" << n / 4 << "" "" << n / 4 << \'\\n\';\n            else cout << 2 << "" "" << n / 2 - 1 << "" "" << n / 2 - 1 << \'\\n\';\n        }\n    }\n}\n/*\n*/\n']","['constructive algorithms', 'math']",1200
https://codeforces.com//contest/1547/problem/D,D. Co-growing Sequence,A sequence of non negative integers a 1 a 2 dots a n is called if for all i from 1 to n 1 all ones of binary representation in a i are in the places of ones of binary representation in a i 1 in other words a i a i 1 a i where denotes bitwise AND If n 1 then the sequence is considered as well For example the following four sequences are growing 2 3 15 175 in binary it s 10 2 11 2 1111 2 10101111 2 5 in binary it s 101 2 1 3 7 15 in binary it s 1 2 11 2 111 2 1111 2 0 0 0 in binary it s 0 2 0 2 0 2 The following three sequences are non growing 3 4 5 in binary it s 11 2 100 2 101 2 5 4 3 in binary it s 101 2 100 2 011 2 1 2 4 8 in binary it s 0001 2 0010 2 0100 2 1000 2 Consider two sequences of non negative integers x 1 x 2 dots x n and y 1 y 2 dots y n Let s call this pair of sequences if the sequence x 1 oplus y 1 x 2 oplus y 2 dots x n oplus y n is where oplus denotes bitwise XOR You are given a sequence of integers x 1 x 2 dots x n Find the lexicographically minimal sequence y 1 y 2 dots y n such that sequences x i and y i are co growing The sequence a 1 a 2 dots a n is lexicographically smaller than the sequence b 1 b 2 dots b n if there exists 1 le k le n such that a i b i for any 1 le i k but a k b k ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int prev = 0;\n        for (int i = 0; i < n; i++) {\n            int y = prev & (~a[i]);\n            cout << y << "" "";\n            prev = a[i] ^ y;\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']","['bitmasks', 'constructive algorithms', 'greedy']",1300
https://codeforces.com//contest/1430/problem/A,A. Number of Apartments,Recently a new building with a new layout was constructed in Monocarp s hometown According to this new layout the building consists of three types of apartments three room five room and seven room apartments It s also known that each room of each apartment has exactly one window In other words a three room apartment has three windows a five room five windows and a seven room seven windows Monocarp went around the building and counted n windows Now he is wondering how many apartments of each type the building may have Unfortunately Monocarp only recently has learned to count so he is asking you to help him to calculate the possible quantities of three room five room and seven room apartments in the building that has n windows If there are multiple answers you can print any of them Here are some examples if Monocarp has counted 30 windows there could have been 2 three room apartments 2 five room apartments and 2 seven room apartments since 2 cdot 3 2 cdot 5 2 cdot 7 30 if Monocarp has counted 67 windows there could have been 7 three room apartments 5 five room apartments and 3 seven room apartments since 7 cdot 3 5 cdot 5 3 cdot 7 67 if Monocarp has counted 4 windows he should have mistaken since no building with the aforementioned layout can have 4 windows ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tscanf(""%d"",&n);\n\tFor(i,0,n/5) For(j,0,(n-5*i)/7)\n\t\tif ((n-5*i-7*j)%3==0){\n\t\t\tcout<<(n-5*i-7*j)/3<<\' \'<<i<<\' \'<<j<<endl;\n\t\t\treturn; \n\t\t}\n\tcout<<-1<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']","['brute force', 'constructive algorithms', 'math']",900
https://codeforces.com//contest/1641/problem/A,A. Great Sequence,A sequence of positive integers is called for a positive integer x if we can split it into pairs in such a way that in each pair the first number multiplied by x is equal to the second number More formally a sequence a of size n is great for a positive integer x if n is even and there exists a permutation p of size n such that for each i 1 le i le frac n 2 a p 2i 1 cdot x a p 2i Sam has a sequence a and a positive integer x Help him to make the sequence great find the minimum possible number of positive integers that should be added to the sequence a to make it great for the number x ,"['/**\n *    author:  tourist\n *    created: 23.02.2022 13:04:00       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    vector<bool> used(n, false);\n    int ans = 0;\n    int j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n      if (used[i]) {\n        continue;\n      }\n      if (a[i] % x == 0) {\n        int f = a[i] / x;\n        while (j >= 0 && (used[j] || a[j] > f)) {\n          j -= 1;\n        }\n        if (j >= 0 && !used[j] && a[j] == f) {\n          used[i] = true;\n          used[j] = true;\n          ans += 1;\n        }\n      }\n    }\n    cout << n - 2 * ans << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'greedy', 'sortings']",1200
https://codeforces.com//contest/1469/problem/D,D. Ceil Divisions,You have an array a 1 a 2 dots a n where a i i In one step you can choose two indices x and y x neq y and set a x left lceil frac a x a y right rceil ceiling function Your goal is to make array a consist of n 1 ones and 1 two in no more than n 5 steps Note that you don t have to minimize the number of steps ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        std::vector<std::pair<int, int>> ans;\n        while (n > 2) {\n            int s = std::ceil(std::sqrt(n));\n            for (int i = s + 1; i < n; ++i) {\n                ans.emplace_back(i, i + 1);\n            }\n            ans.emplace_back(n, s);\n            ans.emplace_back(n, s);\n            n = s;\n        }\n        std::cout << ans.size() << ""\\n"";\n        for (auto [x, y] : ans) {\n            std::cout << x << "" "" << y << ""\\n"";\n        }\n    }\n    return 0;\n}']","['brute force', 'constructive algorithms', 'math', 'number theory']",1700
https://codeforces.com//contest/807/problem/B,B. T-Shirt Hunt,Not so long ago the Codecraft 17 contest was held on Codeforces The top 25 participants and additionally random 25 participants out of those who got into top 500 will receive a Codeforces T shirt Unfortunately you didn t manage to get into top 25 but you got into top 500 taking place Now the elimination round of 8VC Venture Cup 2017 is being held It has been announced that the Codecraft 17 T shirt winners will be chosen as follows Let be the number of points of the winner of the elimination round of 8VC Venture Cup 2017 Then the following pseudocode will be executed i s div 50 mod 475repeat 25 times i i 96 42 mod 475 print 26 i Here is the integer division operator is the modulo the remainder of division operator As the result of pseudocode execution 25 integers between 26 and 500 inclusive will be printed These will be the numbers of places of the participants who get the Codecraft 17 T shirts It is guaranteed that the 25 printed integers will be pairwise distinct for any value of You re in the lead of the elimination round of 8VC Venture Cup 2017 having points You believe that having at least points in the current round will be enough for victory To change your final score you can make any number of successful and unsuccessful hacks A successful hack brings you 100 points an unsuccessful one takes 50 points from you It s difficult to do successful hacks though You want to win the current round and at the same time ensure getting a Codecraft 17 T shirt What is the smallest number of hacks you have to do to achieve that ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool tshirt(int p, int score) {\n    int r = (score/50)%475;\n    for(int i=0;i<25;i++) {\n        r = (r*96+42)%475;\n        if(r+26 == p) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int p, x, y;\n    cin >> p >> x >> y;\n    int score = x;\n    while(score-50 >= y) {\n        score -= 50;\n    }\n    while(!tshirt(p,score)) {\n        score += 50;\n    }\n    score -= x;\n    score += 50;\n    if(score < 0) {\n        score = 0;\n    }\n    cout << score/100 << endl;\n}']","['brute force', 'implementation']",1300
https://codeforces.com//contest/533/problem/A,A. Berland Miners,The biggest gold mine in Berland consists of caves connected by transitions The entrance to the mine leads to the cave number it is possible to go from it to any remaining cave of the mine by moving along the transitions The mine is being developed by the InMine Inc miners work for it Each day the corporation sorts miners into caves so that each cave has at most one miner working there For each cave we know the height of its ceiling in meters and for each miner we know his height also in meters If a miner s height doesn t exceed the height of the cave ceiling where he is then he can stand there comfortably otherwise he has to stoop and that makes him unhappy Unfortunately miners typically go on strike in Berland so InMine makes all the possible effort to make miners happy about their work conditions To ensure that no miner goes on strike you need make sure that no miner has to stoop at any moment on his way from the entrance to the mine to his cave in particular he must be able to stand comfortably in the cave where he works To reach this goal you can choose exactly one cave and increase the height of its ceiling by several meters However enlarging a cave is an expensive and complex procedure That s why InMine Inc asks you either to determine the minimum number of meters you should raise the ceiling of some cave so that it is be possible to sort the miners into the caves and keep all miners happy with their working conditions or to determine that it is impossible to achieve by raising ceiling in exactly one cave ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 500100\nint n;\nset<int> skal;\nmap<int,int> m;\nint h[MAX];\nvector<int> d[MAX];\nint k;\nint s[MAX];\nvector<int> prze;\nconst int MAXX = 1<<20;\nstruct node{\n  int sum,suf;\n  void licz(node a,node b){\n    sum = a.sum + b.sum;\n    suf = min(b.suf,a.suf + b.sum);\n  }\n  void add(int il){\n    sum += il;\n    suf = min(0,sum);\n  }\n}dp[MAXX*2 + 5];\nint add(int a,int il){\n  a += MAXX;\n  dp[a].add(il);\n  while(1){\n    a/=2;\n    dp[a].licz(dp[a*2],dp[a*2+1]);\n    if(a == 1)break;\n  }\n}\nvoid dfs(int nr,int oj,int war){\n  MI(war,h[nr]);\n  prze.PB(war);\n  R(i,(int)d[nr].size())\n    if(d[nr][i]!=oj)\n      dfs(d[nr][i],nr,war);\n}\nint wyn = -1;\nint nowa;\nint stara;\nvector<int> wart;\nvoid dfsw(int nr,int oj,int war){\n  MI(war,h[nr]);\n  if(war <= stara)return;\n  wart.PB(war);\n  R(i,(int)d[nr].size())\n    if(d[nr][i]!=oj)\n      dfsw(d[nr][i],nr,war);\n}\nvoid dfsn(int nr,int oj,int war){\n  MI(war,h[nr]);\n  if(war < nowa){\n    stara = h[nr];\n    h[nr] = nowa;\n    wart.clear();\n    dfsw(nr,oj,nowa);\n    R(i,wart.size())\n      add(wart[i],1);\n    add(stara,(int)wart.size() * -1);\n    if(dp[1].suf == 0){\n      MA(wyn,stara);\n    }\n    R(i,wart.size())\n      add(wart[i],-1);\n    add(stara,(int)wart.size());\n    h[nr] = stara;\n  }else{\n    R(i,(int)d[nr].size())\n      if(d[nr][i]!=oj)\n        dfsn(d[nr][i],nr,war);\n  }\n}\nvoid licz(){\n  dfsn(0,-1,1e9);\n}\nint wyc(int szu){\n  int nr=0;\n  for(int a:skal){\n    if(nr == szu)return a;\n    nr++;\n  }\n}\nmain(){\n  make(n);\n  R(i,n){\n    make(h[i]);\n    skal.insert(h[i]);\n  }\n  R(i,n-1){\n    int a,b;\n    make2(a,b);\n    a--;b--;\n    d[a].PB(b);\n    d[b].PB(a);\n  }\n  make(k);\n  R(i,k){\n    make(s[i]);\n    skal.insert(s[i]);\n  }\n  int nr=0;\n  for(int a:skal){\n    m[a] = nr;\n    nr++;\n  }\n  R(i,n)h[i] = m[h[i]];\n  R(i,k)s[i] = m[s[i]];\n  dfs(0,-1,nr);\n  R(i,prze.size())add(prze[i],1);\n  R(i,k)add(s[i],-1);\n  if(dp[1].suf == 0){\n    puts(""0"");\n    return 0;\n  }\n  sort(s,s+k,greater<int>());\n  sort(ALL(prze),greater<int>());\n  R(i,k){\n    if(prze[i] < s[i]){\n      nowa = s[i];\n      licz();\n      if(wyn == -1){\n        puts(""-1"");\n        return 0;\n      }\n      printf(""%d\\n"",wyc(nowa) - wyc(wyn));\n      return 0;\n    }\n  }\n  assert(0);\n}']","['binary search', 'data structures', 'dfs and similar', 'greedy', 'trees']",3000
https://codeforces.com//contest/166/problem/E,E. Tetrahedron,You are given a tetrahedron Let s mark its vertices with letters and correspondingly An ant is standing in the vertex of the tetrahedron The ant is quite active and he wouldn t stay idle At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron The ant just can t stand on one place You do not have to do much to solve the problem your task is to count the number of ways in which the ant can go from the initial vertex to itself in exactly steps In other words you are asked to find out the number of different cyclic paths with the length of from vertex to itself As the number can be quite large you should print it modulo ,"['#pragma comment(linker, ""/stack:64000000"")\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <utility>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <memory.h>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <deque>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <map>\n#include <deque>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define for1(i, n) for (int i = 1; i <= int(n); i++)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb push_back\n#define pii pair <int, int>\n#define vi vector <int>\n#define mp make_pair\n\ntemplate <typename X> inline X abs (const X &a) {return a < 0? -a: a;}\ntemplate <typename X> inline X sqr (const X &a) {return a * a;}\n\nconst int INF = INT_MAX / 2;\nconst ll INF64 = LLONG_MAX / 2LL;\nconst ld EPS = 1E-9, PI = 3.1415926535897932384626433832795;\n\nconst ll MOD = 1000000007LL;\n\ninline vector <vector <ll> > mul (const vector <vector <ll> > &a, const vector <vector <ll> > &b)\n{\n    vector <vector <ll> > res (4);\n    forn (i, 4)\n        res[i].resize (4);\n\n    forn (i, 4)\n        forn (j, 4)\n            forn (k, 4)\n            {\n                res[i][j] = (res[i][j] + ((a[i][k] % MOD) * (b[k][j] % MOD)) % MOD) % MOD;\n            }       \n\n    return res;\n}\n\nvector <vector <ll> > binPow (const vector <vector <ll> > &a, int k)\n{\n    if (k == 0)\n    {\n        vector <vector <ll> > res (4);\n        forn (i, 4)\n            res[i].resize (4);\n\n        forn (i, 4)\n            res[i][i] = 1;\n\n        return res;\n    }\n\n    if (k & 1)\n        return mul (binPow (a, k - 1), a);\n    else\n    {\n        vector <vector <ll> > res = binPow (a, (k >> 1));\n        return mul (res, res);\n    }\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n\n    int n;\n    cin >> n;\n\n    vector <vector <ll> > g;\n    \n    g.resize (4);\n    forn (i, 4)\n        g[i].resize (4);\n\n    forn (i, 4)\n        forn (j, 4)\n            g[i][j] = (i == j? 0: 1);\n\n    vector <vector <ll> > ans = binPow (g, n);\n\n    cout << ans[0][0] << endl;\n\n    return 0;\n}']","['dp', 'math', 'matrices']",1500
https://codeforces.com//contest/1660/problem/B,B. Vlad and Candies,Not so long ago Vlad had a birthday for which he was presented with a package of candies There were n types of candies there are a i candies of the type i 1 le i le n Vlad decided to eat exactly one candy every time choosing any of the candies of a type that is currently the most frequent if there are several such types he can choose of them To get the maximum pleasure from eating Vlad to eat two candies of the same type in a row Help him figure out if he can eat all the candies without eating two identical candies in a row ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i];\n  }\n  A.pb(0);\n  sort(all(A));\n  if (A[n] - A[n - 1] > 1) {\n    cout << ""NO\\n"";\n  } else {\n    cout << ""YES\\n"";\n  }\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}']",['math'],800
https://codeforces.com//contest/536/problem/E,E. Tavas on the Path,Tavas lives in Tavaspolis Tavaspolis has cities numbered from to connected by bidirectional roads There exists a path between any two cities Also each road has a length Tavas favorite strings are binary strings they contain only 0 and 1 For any binary string like is its can be calculated as follows Consider there are exactly blocks of s in this string a block of s in is a maximal consecutive substring of that only contains with lengths Define where is a given sequence if then Tavas loves queries He asks you to answer queries In each query he gives you numbers and you should print following number Consider the roads on the path from city to city Build the binary string of length such that if and only if where is the length of road You should print for this query ,"['#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\ntypedef long long ll;\n#define mo 1000000007\nvoid gn(int &x){\n    char c;while((c=getchar())<\'0\'||c>\'9\');x=c-\'0\';\n    while((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';\n}\nusing namespace std;\nint n,m;\nint g[100005]={0};\nstruct edge{\n       int v,w,next;\n}e[200005];int etot=0;\nvoid ae(int u,int v,int w){\n     e[etot].v=v;e[etot].w=w;e[etot].next=g[u];g[u]=etot++;\n     e[etot].v=u;e[etot].w=w;e[etot].next=g[v];g[v]=etot++;\n}\nint sz[100005];\nint bfs[100005],p,q,fa[100005],son[100005]={0},up[100005],h[100005],id[100005],idtot=0;\nvoid build(){\n     p=q=0;\n     bfs[q++]=1;\n     fa[1]=0;h[1]=0;\n     int u,v,i;\n     while(p<q){\n               u=bfs[p++];\n               for ( i=g[u];~i;i=e[i].next)if((v=e[i].v)!=fa[u]){\n                   fa[v]=u;\n                   bfs[q++]=v;\n                   h[v]=h[u]+1;\n               }\n     }\n     for (i=1;i<=n;i++)sz[i]=1;\n     sz[0]=0;\n     for (i=n-1;i>=0;i--){\n         sz[fa[bfs[i]]]+=sz[bfs[i]];\n         if(sz[bfs[i]]>sz[son[fa[bfs[i]]]])son[fa[bfs[i]]]=bfs[i];\n     }\n     for (i=n-1;i>=0;i--)if(!son[v=bfs[i]]){         \n         while(v!=1 && son[fa[v]]==v)v=fa[v];\n         p=v;\n         while(v)up[v]=p,id[v]=++idtot,v=son[v];\n     }\n}\nint f[111111];\nstruct que{\n    int u,v,l,id;\n}Q[111111];\nstruct edg{\n    int u,v,w;\n}E[111111];\nint cmpe(const edg&a,const edg&b){\n    return a.w>b.w;\n}\nint cmpq(const que&a,const que&b){\n    return a.l>b.l;\n}\nint ans[111111];\n\nstruct data{\n    int l,su,r,len;\n};\ninline data rev(const data&a){\n    return (data){a.r,a.su,a.l,a.len};\n}\ninline int eval(const data&a){\n    if(a.l==a.len)return f[a.l];\n    else return f[a.l]+f[a.r]+a.su;\n}\ninline data operator+(const data&a,const data&b){\n    data ans;\n    ans.len=a.len+b.len;\n    if(a.l!=a.len && b.l!=b.len){\n        ans.l=a.l,ans.r=b.r,ans.su=a.su+b.su+f[a.r+b.l];\n    }else if(a.l==a.len && b.l==b.len){\n        ans.l=ans.r=ans.len;ans.su=0;\n    }else if(a.l==a.len){\n        ans.l=a.l+b.l,ans.r=b.r,ans.su=b.su;\n    }else ans.l=a.l,ans.r=b.r+a.r,ans.su=a.su;\n    return ans;\n}\n\ndata seg[444444];\nint I;\ndata v;\n\nvoid upd(int l,int r,int x){\n    if(l==r)seg[x]=v;\n    else{\n        int mid=l+r>>1;\n        if(I<=mid)upd(l,mid,x<<1);\n        else upd(mid+1,r,x<<1|1);\n        seg[x]=seg[x<<1]+seg[x<<1|1];\n    }\n}\nint l1,r1;\nvoid qr(int l,int r,int x){\n    if(l1<=l && r<=r1)v=v+seg[x];\n    else{\n        int mid=l+r>>1;\n        if(l1<=mid)qr(l,mid,x<<1);\n        if(r1>mid)qr(mid+1,r,x<<1|1);\n    }\n}\nint query(int x,int y){\n    data mex,mey;\n    mex=mey=(data){0,0,0,0};\n    while(up[x]!=up[y]){\n        if(h[up[x]]>h[up[y]])swap(x,y),swap(mex,mey);\n        l1=id[up[y]],r1=id[y];\n        v=(data){0,0,0,0};\n        qr(1,n,1);\n        mey=v+mey;\n        y=fa[up[y]];\n    }\n    if(h[x]>h[y])swap(x,y),swap(mex,mey);\n    l1=id[x]+1,r1=id[y];\n    v=(data){0,0,0,0};\n    if(l1<=r1)qr(1,n,1);\n    data ans=rev(mex)+v+mey;\n    return eval(ans);\n}\nvoid init(int l,int r,int x){\n    if(l==r){\n        seg[x]=(data){0,0,0,1};\n    }else{\n        int mid=l+r>>1;\n        init(l,mid,x<<1);\n        init(mid+1,r,x<<1|1);\n        seg[x]=seg[x<<1]+seg[x<<1|1];\n    }\n}\nint main()\n{\n    memset(g,-1,sizeof(g));\n    int q;\n    scanf(""%d%d"",&n,&q);\n    f[0]=0;for (int i=1;i<=n-1;i++)scanf(""%d"",&f[i]);\n    for (int i=1;i<=n-1;i++){\n        int u,v,w;scanf(""%d%d%d"",&u,&v,&w);\n        ae(u,v,w);\n        E[i]=(edg){u,v,w};\n    }\n    for (int i=1;i<=q;i++){\n        scanf(""%d%d%d"",&Q[i].u,&Q[i].v,&Q[i].l);\n        Q[i].id=i;\n    }\n    sort(Q+1,Q+1+q,cmpq);\n    sort(E+1,E+1+(n-1),cmpe);\n    init(1,n,1);\n    build();\n    for (int i=1;i<=n-1;i++)if(h[E[i].u]>h[E[i].v])swap(E[i].u,E[i].v);\n    for (int i=1,cur=1;i<=q;i++){\n        while(cur<=n-1 && E[cur].w>=Q[i].l){\n            I=id[E[cur].v];\n            v=(data){1,0,1,1};\n            upd(1,n,1);\n            cur++;\n        }\n        ans[Q[i].id]=query(Q[i].u,Q[i].v);\n    }\n    for (int i=1;i<=q;i++)printf(""%d\\n"",ans[i]);\n    return 0;\n}\n']","['data structures', 'divide and conquer', 'trees']",3100
https://codeforces.com//contest/1936/problem/C,C. Pokémon Arena,You are at a dueling arena You also possess n Pok mons Initially only the 1 st Pok mon is standing in the arena Each Pok mon has m attributes The j th attribute of the i th Pok mon is a i j Each Pok mon also has a cost to be hired the i th Pok mon s cost is c i You want to have the n th Pok mon stand in the arena To do that you can perform the following two types of operations any number of times in any order Choose three integers i j k 1 le i le n 1 le j le m k 0 increase a i j by k permanently The cost of this operation is k Choose two integers i j 1 le i le n 1 le j le m and hire the i th Pok mon to duel with the current Pok mon in the arena based on the j th attribute The i th Pok mon will win if a i j is the j th attribute of the current Pok mon in the arena otherwise it will lose After the duel only the winner will stand in the arena The cost of this operation is c i Find the minimum cost you need to pay to have the n th Pok mon stand in the arena ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\nll kosz[nax];\nvll wek[nax];\n\nint k;\n\nvector<vector<pll>> graf;\n\nvll odl;\n\nvoid ogarnij()\n{\n\twhile((int)graf.size()<=k)\n\t\tgraf.push_back(vector<pll>(0));\n}\n\nvoid edge(int a, int b, ll w)\n{\n\tgraf[a].push_back({b, w});\n\t//~ debug() << imie(a) << imie(b) << imie(w);\n}\n\nvoid test()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld "", &kosz[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twek[i].clear();\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tll x;\n\t\t\tscanf(""%lld"", &x);\n\t\t\twek[i].push_back(x);\n\t\t}\n\t}\n\tk=n;\n\tgraf.clear();\n\togarnij();\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tvector<pll> pos;\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tk++;\n\t\t\togarnij();\n\t\t\tedge(j, k, 0);\n\t\t\tedge(k, j, kosz[j]);\n\t\t\tpos.push_back({wek[j][i], k});\n\t\t}\n\t\tsort(pos.begin(), pos.end());\n\t\tfor (int j=1; j<n; j++)\n\t\t{\n\t\t\tedge(pos[j-1].second, pos[j].second, 0);\n\t\t\tedge(pos[j].second, pos[j-1].second, pos[j].first-pos[j-1].first);\n\t\t}\n\t}\n\todl.clear();\n\todl.resize(k+1, -1);\n\tpriority_queue<pll> kol;\n\todl[1]=0;\n\tkol.push({0, 1});\n\twhile(!kol.empty())\n\t{\n\t\tint v=kol.top().second;\n\t\tll w=-kol.top().first;\n\t\tkol.pop();\n\t\tif (odl[v]!=w)\n\t\t\tcontinue;\n\t\tfor (pll i : graf[v])\n\t\t{\n\t\t\tll x=i.second+w;\n\t\t\tif (odl[i.first]!=-1 && odl[i.first]<=x)\n\t\t\t\tcontinue;\n\t\t\todl[i.first]=x;\n\t\t\t//~ if (i.first==n && x==1)\n\t\t\t//~ {\n\t\t\t\t//~ debug() << imie(v) << imie(w) << imie(i);\n\t\t\t\t//~ exit(0);\n\t\t\t//~ }\n\t\t\tkol.push({-x, i.first});\n\t\t}\n\t}\n\tprintf(""%lld\\n"", odl[n]);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['data structures', 'graphs', 'greedy', 'implementation', 'shortest paths', 'sortings']",2400
https://codeforces.com//contest/77/problem/C,C. Beavermuncher-0xFF,You are given a tree completely occupied by beavers A tree is a connected undirected graph without cycles The tree consists of vertices the th vertex contains beavers Beavermuncher 0xFF works by the following principle being at some vertex it can go to the vertex if they are connected by an edge and eat beaver located at the vertex It is impossible to move to the vertex if there are no beavers left in Beavermuncher 0xFF just stand at some vertex and eat beavers in it Beavermuncher 0xFF must move without stops Why does the Beavermuncher 0xFF works like this Because the developers have not provided place for the battery in it and eating beavers is necessary for converting their mass into pure energy It is guaranteed that the beavers will be shocked by what is happening which is why they will not be able to move from a vertex of the tree to another one As for the Beavermuncher 0xFF it can move along each edge in both directions while conditions described above are fulfilled The root of the tree is located at the vertex This means that the Beavermuncher 0xFF begins its mission at the vertex and it must return there at the end of experiment because no one is going to take it down from a high place Determine the maximum number of beavers Beavermuncher 0xFF can eat and return to the starting vertex ,"['#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define y0 y3487465\n#define y1 y8687969\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) {\n    re x > 0 ? x : -x;\n}\n\nint n;\nint m, s;\nvector<pair<ll, int> > v[200000];\nint k[200000];\n\nll go (int x, int p) {\n    k[x]--;\n    for (int i = 0; i < sz (v[x]); i++) {\n        int y = v[x][i].se;\n        if (k[y] > 0 && y != p) v[x][i].fi = go (y, x); else v[x][i].fi = -1;\n    }\n    sort (all (v[x]));\n    reverse (all (v[x]));\n    ll cur = 0;\n    for (int i = 0; i < sz (v[x]) && k[x] > 0; i++) {\n        if (v[x][i].fi < 0) continue;\n        cur += v[x][i].fi + 2;\n        k[x]--;\n    }   \n    for (int i = 0; i < sz (v[x]); i++) {\n        int y = v[x][i].se;\n        if (y == p) continue;\n        int tmp = min (k[x], k[y]);\n        k[x] -= tmp;\n        k[y] -= tmp;\n        cur += 2 * tmp;\n    }\n    re cur;\n}\n\nint main() {\n    scanf (""%d"", &n);\n    for (int i = 0; i < n; i++) scanf (""%d"", &k[i]);\n    for (int i = 0; i + 1 < n; i++) {\n        int a, b;\n        scanf (""%d%d"", &a, &b); a--; b--;\n        v[a].pb (mp (0, b));\n        v[b].pb (mp (0, a));\n    }\n    scanf (""%d"", &s); s--;\n    k[s]++;\n    cout << go (s, s) << endl;\n    return 0;\n}']","['dfs and similar', 'dp', 'dsu', 'greedy', 'trees']",2100
https://codeforces.com//contest/1497/problem/D,D. Genius,There are n problems numbered with integers from 1 to n i th problem has the complexity c i 2 i tag tag i and score s i After solving the problem i it s allowed to solve problem j if and only if text IQ c i c j and tag i neq tag j After solving it your text IQ changes and becomes text IQ c i c j and you gain s i s j points Any problem can be the first You can solve problems in any order and as many times as you want Initially your text IQ 0 Find the maximum number of points that can be earned ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        int n;\n        cin >> n;\n        vector<int> tag(n), s(n);\n        for (int i = 0; i < n; ++i) cin >> tag[i];\n        for (int i = 0; i < n; ++i) cin >> s[i];\n        vector<ll> ans(n, 0);\n        for (int i = 0; i < n; ++i) {\n            for (int j = i - 1; j > -1; --j) {\n                if (tag[i] != tag[j]) {\n                    ll ans1 = max(ans[i], ans[j] + abs(s[j] - s[i]));\n                    ll ans2 = max(ans[j], ans[i] + abs(s[j] - s[i]));\n                    ans[i] = max(ans[i], ans1);\n                    ans[j] = max(ans[j], ans2);\n                }\n            }\n        }\n        cout << *max_element(all(ans)) << \'\\n\';\n    }\n}\n']","['bitmasks', 'dp', 'graphs', 'number theory']",2500
https://codeforces.com//contest/448/problem/C,C. Painting Fence,Bizon the Champion isn t just attentive he also is very hardworking Bizon the Champion decided to paint his old fence his favorite color orange The fence is represented as vertical planks put in a row Adjacent planks have no gap between them The planks are numbered from the left to the right starting from one the th plank has the width of meter and the height of meters Bizon the Champion bought a brush in the shop the brush s width is meter He can make vertical and horizontal strokes with the brush During a stroke the brush s full surface must touch the fence at all the time see the samples for the better understanding What minimum number of strokes should Bizon the Champion do to fully paint the fence Note that you are allowed to paint the same area of the fence multiple times ,"['#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define int64 long long\n#define N 5010\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m,an;\nint a[N];\ninline int64 work(int l,int r,int cen) {\n\tint i,last=l,mi=a[l];\n\tint64 s=r-l+1,sum;\n\tFor(i,l,r) mi=min(mi,a[i]);\n\tsum=mi-cen;\n\tFor(i,l,r) if (a[i]==mi) {\n\t\tif (last<i) sum+=work(last,i-1,mi);\n\t\tlast=i+1;\n\t}\n\tif (last<=r) sum+=work(last,r,mi);\n\treturn min(s,sum);\n}\nint main() {\n\tscanf(""%d"",&n);\n\tFor(i,1,n) scanf(""%d"",&a[i]);\n\tan=work(1,n,0);\n\tprintf(""%I64d\\n"",an);\n\treturn 0;\n}\n']","['divide and conquer', 'dp', 'greedy']",1900
https://codeforces.com//contest/1083/problem/E,E. The Fair Nut and Rectangles,The Fair Nut got stacked in planar world He should solve this task to get out You are given n rectangles with vertexes in 0 0 x i 0 x i y i 0 y i For each rectangle you are also given a number a i Choose some of them that the area of union minus sum of a i of the chosen ones is maximum It is guaranteed that there are no nested rectangles Nut has no idea how to find the answer so he asked for your help ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1200*1007;\nusing mag=long double;\n\nint n;\n\npair <pll,ll> tab[nax];\n\npll operator - (pll a, pll b)\n{\n\treturn {a.first-b.first, a.second-b.second};\n}\n\nmag ilowek(pll s, pll a, pll b)\n{\n\ta=a-s;\n\tb=b-s;\n\treturn a.first*(mag)b.second-a.second*(mag)b.first;\n}\n\nll wyn;\nll dp[nax];\n\nvector <pll> oto;\n\nvoid wrzuc(pll v)\n{\n\tint r=oto.size();\n\twhile(r>=2 && ilowek(oto[r-2], oto[r-1], v)<=0)\n\t{\n\t\tr--;\n\t\toto.pop_back();\n\t}\n\toto.push_back(v);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld%lld%lld"", &tab[i].first.first, &tab[i].first.second, &tab[i].second);\n\tsort(tab+1, tab+1+n);\n\tint l=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twrzuc({dp[i-1], tab[i-1].first.first});\n\t\tll x=tab[i].first.first;\n\t\tll y=tab[i].first.second;\n\t\tl=min(l, (int)oto.size()-1);\n\t\twhile(l+1<(int)oto.size() && oto[l+1].first-oto[l+1].second*y>=oto[l].first-oto[l].second*y)\n\t\t\tl++;\n\t\tdp[i]=oto[l].first+y*(x-oto[l].second)-tab[i].second;\n\t\twyn=max(wyn, dp[i]);\n\t\t//~ debug() << tab[i] << "" "" << dp[i] << "" "" << oto;\n\t}\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['data structures', 'dp', 'geometry']",2400
https://codeforces.com//contest/1360/problem/D,D. Buying Shovels,Polycarp wants to buy n shovels The shop sells packages with shovels The store has k types of packages the package of the i th type consists of exactly i shovels 1 le i le k The store has an infinite number of packages of each type Polycarp wants to choose type of packages and then buy several one or more packages of this type What is the smallest number of packages Polycarp will have to buy to get exactly n shovels For example if n 8 and k 7 then Polycarp will buy 2 packages of 4 shovels Help Polycarp find the minimum number of packages that he needs to buy given that he will buy exactly n shovels in total the sizes of packages he will buy are all the same and the number of shovels in each package is an integer from 1 to k inclusive ,"['#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < \'0\' || cc > \'9\' ) {  if( cc == \'-\' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= \'0\' && cc <= \'9\' )  cn = cn * 10 + cc - \'0\', cc = getchar() ;\n\treturn cn * flus ;\n}\nint n, k ; \nsigned main()\n{\n\tint T = gi() ; \n\twhile( T-- ) {\n\t\tn = gi(), k = gi() ; int ans = n ; \n\t\tfor( re int i = 1; i <= sqrt(n); ++ i ) {\n\t\t\tif( n % i ) continue ; \n\t\t\tif( i <= k ) ans = min( ans, n / i ) ;\n\t\t\tif( ( n / i ) <= k ) ans = min( ans, i ) ;\n\t\t}\n\t\tprintf(""%lld\\n"", ans ) ;\n\t}\n\treturn 0 ;\n}']","['math', 'number theory']",1300
https://codeforces.com//contest/864/problem/E,E. Fire,Polycarp is in really serious trouble his house is on fire It s time to save the most valuable items Polycarp estimated that it would take seconds to save th item In addition for each item he estimated the value of the moment after which the item will be completely burned and will no longer be valuable for him at all In particular if then th item cannot be saved Given the values for each of the items find a set of items that Polycarp can save such that the total value of this items is maximum possible Polycarp saves the items one after another For example if he takes item first and then item then the item will be saved in seconds and the item in seconds after fire started ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint f[110][2010];\nint g[110][2010];\nstruct p\n{\n\tint t,d,p,id;\n};\np a[110];\nint cmp(p a,p b)\n{\n\treturn a.d<b.d;\n}\nvoid solve(int x,int y,int s)\n{\n\tif(x<0)\n\t\tprintf(""%d\\n"",s);\n\telse\n\t{\n\t\tif(!g[x][y])\n\t\t\tsolve(x-1,y,s);\n\t\telse\n\t\t{\n\t\t\tsolve(x-1,y-a[x].t,s+1);\n\t\t\tprintf(""%d "",a[x].id);\n\t\t}\n\t}\n}\nint main()\n{\n\tmemset(f,0x80,sizeof f);\n\tf[0][0]=0;\n\tint n;\n\tscanf(""%d"",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d%d%d"",&a[i].t,&a[i].d,&a[i].p);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=2000;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tg[i][j]=0;\n\t\t\tif(j>=a[i].t&&j<a[i].d)\n\t\t\t\tif(f[i-1][j-a[i].t]+a[i].p>f[i][j])\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=f[i-1][j-a[i].t]+a[i].p;\n\t\t\t\t\tg[i][j]=1;\n\t\t\t\t}\n\t\t}\n\tint ans1=-1,ans2=-1;\n\tfor(i=0;i<=2000;i++)\n\t\tif(f[n][i]>ans1)\n\t\t{\n\t\t\tans1=f[n][i];\n\t\t\tans2=i;\n\t\t}\n\tprintf(""%d\\n"",ans1);\n\tsolve(n,ans2,0);\n\treturn 0;\n}']","['dp', 'sortings']",2000
https://codeforces.com//contest/762/problem/D,D. Maximum path,You are given a rectangular table Each cell contains an integer You can move from one cell to another if they share a side Find such path from the upper left cell to the bottom right cell of the table that doesn t visit any of the cells twice and the sum of numbers written in the cells of this path is maximum possible ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nvoid build(){\n\n}\nLL n , a[ 3 ][ N ] , dp[ N ][ 4 ];\nvoid init(){\n  n = getint();\n  for( int j = 0 ; j < 3 ; j ++ )\n    for( int i = 1 ; i <= n ; i ++ )\n      a[ j ][ i ] = getint();\n}\ninline LL sum( int col , int fr , int to ){\n  if( fr > to ) swap( fr , to );\n  LL ret = 0;\n  for( int i = fr ; i <= to ; i ++ )\n    ret += a[ i ][ col ];\n  return ret;\n}\nvoid solve(){\n  dp[ 0 ][ 0 ] = 0;\n  dp[ 0 ][ 1 ] = -INF16;\n  dp[ 0 ][ 2 ] = -INF16;\n  dp[ 0 ][ 3 ] = -INF16;\n  for( int i = 1 ; i <= n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      dp[ i ][ j ] = -INF16;\n    for( int j = 0 ; j < 3 ; j ++ )\n      for( int nj = 0 ; nj < 3 ; nj ++ )\n        dp[ i ][ nj ] = max( dp[ i ][ nj ] ,\n                             dp[ i - 1 ][ j ] + sum( i , j , nj ) );\n    LL al = sum( i , 0 , 2 );\n    for( int j : { 0 , 2 } ){\n      dp[ i ][ 3 ] = max( dp[ i ][ 3 ] , dp[ i - 1 ][ j ] + al );\n      dp[ i ][ j ] = max( dp[ i ][ j ] , dp[ i - 1 ][ 3 ] + al );\n    }\n  }\n  printf( ""%lld\\n"" , dp[ n ][ 2 ] );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","['dp', 'greedy', 'implementation']",2300
https://codeforces.com//contest/1650/problem/B,B. DIV + MOD,Not so long ago Vlad came up with an interesting function f a x left lfloor frac x a right rfloor x bmod a where left lfloor frac x a right rfloor is frac x a rounded x bmod a the remainder of the integer division of x by a For example with a 3 and x 11 the value f 3 11 left lfloor frac 11 3 right rfloor 11 bmod 3 3 2 5 The number a is fixed and known to Vlad Help Vlad find the maximum value of f a x if x can take any integer value from l to r inclusive l le x le r ,"[""#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\nvoid solve(){\n\tll l,r,a; cin>>l>>r>>a;\n\tll ans = r/a+r%a;\n\tll down = r/a*a;\n\tif(l<down) down--;\n\tans = max(ans,down/a + down%a);\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}""]",['math'],900
https://codeforces.com//contest/630/problem/F,F. Selection of Personnel,One company of IT City decided to create a group of innovative developments consisting from to people and hire new employees for it After placing an advertisment the company received resumes Now the HR department has to evaluate each possible group composition and select one of them Your task is to count the number of variants of group composition to evaluate ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\nll cnk(ll n, int k)\n{\n    ll res = 1;\n    forn(i, k) res = (res * (n - i)) / (i + 1);\n    return res;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    ll n, t;\n\n    cin >> n;\n    ll res = cnk(n, 5) + cnk(n, 6) + cnk(n, 7);\n    cout << res;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","['combinatorics', 'math']",1300
https://codeforces.com//contest/1733/problem/E,E. Conveyor,There is a conveyor with 120 rows and 120 columns Each row and column is numbered from 0 to 119 and the cell in i th row and j th column is denoted as i j The top leftmost cell is 0 0 Each cell has a belt and all belts are initially facing to the right Initially a slime ball is on the belt of 0 0 and other belts are empty Every second the state of the conveyor changes as follows All slime balls on the conveyor move one cell in the direction of the belt at the same time If there is no cell in the moved position the slime gets out of the conveyor and if two slime balls move to the same cell they merge into one All belts with slime ball in the previous second change direction at the same time belts facing to the right become facing to the down and vice versa A new slime ball is placed on cell 0 0 There are q queries each being three integers t x and y You have to find out if there is a slime at the cell x y after t seconds from the start Can you do it ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=5e3+1e2+7;\n\nint T;\n\nint n,m;\n\nlong long f[121][121][2];\n\nlong long solve(long long t,int x,int y)\n{\n\tif(t<(x+y))\n\t\treturn 0;\n\tt=(t-(x+y)+1);\n\tmemset(f,0,sizeof(f));\n\tf[0][0][0]=t;\n\tfor(int i=0;i<120;i++)\n\t\tfor(int j=0;j<120;j++)\n\t\t{\n\t\t\tlong long s=f[i][j][0];\n\t\t\tf[i][j][0]=(s+1)/2;\n\t\t\tf[i][j][1]=s/2;\n\t\t\tf[i][j+1][0]+=(f[i][j][0]);\n\t\t\tf[i+1][j][0]+=(f[i][j][1]);\n\t\t}\n\treturn f[x][y][0]+f[x][y][1];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tlong long t,x,y;\n\t\tcin>>t>>x>>y;\n\t\tlong long a=solve(t,x,y);\n\t\tlong long b=solve(t-1,x,y);\n\t\tif(x+y>t)\n\t\t\tcout<<""NO\\n"";\n\t\telse if(a!=b)\n\t\t\tcout<<""YES\\n"";\n\t\telse\n\t\t\tcout<<""NO\\n"";\n\t}\n}']","['constructive algorithms', 'dp', 'math']",2700
https://codeforces.com//contest/1569/problem/F,F. Palindromic Hamiltonian Path,You are given a simple undirected graph with n vertices n is even You are going to write a letter on each vertex Each letter should be one of the first k letters of the Latin alphabet A path in the graph is called Hamiltonian if it visits each vertex exactly once A string is called palindromic if it reads the same from left to right and from right to left A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order A string of length n is good if each letter is one of the first k lowercase Latin letters if you write the i th letter of the string on the i th vertex of the graph there will exist a palindromic Hamiltonian path in the graph Note that the path doesn t necesserily go through the vertices in order 1 2 dots n Count the number of good strings ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 13; \n\nint N, M, K;\nll ans = 0;\nvi color, match;\nvi cc[MX];\nint nc = 0;\nset<vi> okMatches;\nll numWays[MX];\nbool graph[MX][MX];\n\n\nbool goMatch(int p) {\n    if (p == N) {\n        if (okMatches.count(match)) { \n            ans += numWays[nc];\n            return true;\n        }\n        return false;\n    }\n    if (match[p] != -1) {\n        return goMatch(p+1); \n    }\n\n    trav(a, cc[color[p]]) {\n        if (a == p || match[a] != -1) continue;\n        match[a] = p; match[p] = a;\n        if (goMatch(p+1)) return true;\n        match[p] = -1; match[a] = -1;\n    }\n    return false;\n    \n}\n\nvoid goColor(int p) {\n    if (p == N) {\n        F0R(i, nc) if (sz(cc[i])%2) return;\n        match = vi(N, -1);\n        goMatch(0);\n        return;\n    }\n    int onc = nc;\n    F0R(i, onc+1) {\n        ckmax(nc, i+1);\n        color[p] = i;\n        cc[i].pb(p);\n        goColor(p+1);\n        cc[i].pop_back();\n    }\n    nc = onc;\n}\n\nvoid initMatch(int p) {\n    if (p == N) {\n        //dbg(match);\n        //check if hamiltonian path\n        vector<vi> pairs;\n        F0R(i, N) {\n            if (i < match[i]) {\n                pairs.pb({i, match[i]});\n            }\n        }\n        bool ok[N/2][N/2]; F0R(i, N/2) F0R(j, N/2) ok[i][j] = false;\n        F0R(i, N/2) {\n            F0R(j, N/2) {\n                F0R(a, 2) {\n                    F0R(b, 2) {\n                        if (graph[pairs[i][a]][pairs[j][b]] && graph[pairs[i][1-a]][pairs[j][1-b]]) { \n                            ok[i][j] = true;\n                            /*if (i == j) {\n                                dbg(i, pairs[i]);\n                            }*/\n                        }\n                        if (i == j && graph[pairs[i][a]][pairs[j][b]]) {\n                            ok[i][j] = true;\n                            //dbg(i, pairs[i]);\n                        }\n                    }\n                }\n            }\n        }\n        vi perm; F0R(i, sz(pairs)) perm.pb(i);\n        do {\n            bool val = true;\n            F0R(i, N/2 - 1) if (!ok[perm[i]][perm[i+1]]) val = false;\n            if (!ok[perm[0]][perm[0]]) val = false;\n            if (val) {\n                //dbg(match, perm);\n                okMatches.ins(match); return;\n            }\n        } while (next_permutation(all(perm)));\n\n        return;\n    }\n    if (match[p] != -1) {\n        initMatch(p+1); return;\n    }\n\n    FOR(a, p+1, N) {\n        if (a == p || match[a] != -1) continue;\n        match[a] = p; match[p] = a;\n        initMatch(p+1);\n        match[p] = -1; match[a] = -1;\n    }\n}\n\nvoid solve() {\n    cin >> N >> M >> K;\n    numWays[0] = 1;\n    FOR(i, 1, MX) numWays[i] = numWays[i-1] * (K-i+1);\n    F0R(i, M) {\n        int X, Y; cin >> X >> Y; X--; Y--;\n        graph[X][Y] = true;\n        graph[Y][X] = true;\n    }\n    match = vi(N, -1);\n    color = vi(N);\n    initMatch(0);\n    goColor(0);\n    cout << ans << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']","['brute force', 'dfs and similar', 'dp', 'graphs', 'hashing']",3000
https://codeforces.com//contest/1422/problem/F,F. Boring Queries,Yura owns a quite ordinary and boring array a of length n You think there is nothing more boring than that but Vladik doesn t agree In order to make Yura s array even more boring Vladik makes q boring queries Each query consists of two integers x and y Before answering a query the bounds l and r for this query are calculated l last x bmod n 1 r last y bmod n 1 where last is the answer on the previous query zero initially and bmod is the remainder operation Whenever l r they are swapped After Vladik computes l and r for a query he is to compute the least common multiple LCM on the segment l r of the initial array a modulo 10 9 7 LCM of a multiset of integers is the smallest positive integer that is divisible by all the elements of the multiset The obtained LCM is the answer for this query Help Vladik and compute the answer for each query ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nint n,m,a[N];\nI Pow(ll t,int x,ll s=1){\n\tfor(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;\n\treturn s;\n}\nnamespace T1{\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,n\n#define lson lc,L,mid\n#define rson rc,mid+1,R\n\tconst int B=sqrt(N),M=90;\n\tint tot,pri[N],tag[N];\n\tstruct node{\n\t\tint w[M];\n\t\tV ins(const node&u){\n\t\t\tFOR(i,1,86)cmax(w[i],u.w[i]);\n\t\t}\n\t\tV init(){FOR(i,1,86)w[i]=0;}\n\t\tI val(int out=1){\n\t\t\tFOR(i,1,86)out=Pow(pri[i],w[i],out);\n\t\t\treturn out;\n\t\t}\n\t}t[N<<2],tmp;\n\tV build(int p,int L,int R){\n\t\tif(L==R){\n\t\t\tFOR(i,1,86)\n\t\t\t\twhile(a[L]%pri[i]==0)\n\t\t\t\t\tt[p].w[i]++,a[L]/=pri[i];\n\t\t\treturn;\n\t\t}\n\t\tint mid=L+R>>1;\n\t\tbuild(lson),build(rson),t[p]=t[lc],t[p].ins(t[rc]);\n\t}\n\tV init(){\n\t\tint p;\n\t\tFOR(i,2,B){\n\t\t\tif(!tag[i])pri[++tot]=i;\n\t\t\tFOR(j,1,tot){\n\t\t\t\tif((p=i*pri[j])>B)break;\n\t\t\t\ttag[p]=1;\n\t\t\t\tif(i%pri[j]==0)break;\n\t\t\t}\n\t\t}\n\t\tbuild(root);\n\t}\n\tV ask(int p,int L,int R,int l,int r){\n\t\tif(L==l&&R==r)return tmp.ins(t[p]);\n\t\tint mid=L+R>>1;\n\t\tif(l>mid)return ask(rson,l,r);\n\t\tif(r<=mid)return ask(lson,l,r);\n\t\task(lson,l,mid),ask(rson,mid+1,r);\t\n\t}\n\tI ask(int l,int r){\n\t\ttmp.init();\n\t\task(root,l,r);\n\t\treturn tmp.val();\n\t}\n#undef lc\n#undef rc\n#undef root\n#undef lson\n#undef rson\n}\nnamespace T2{\n#define lc t[p].ls\n#define rc t[p].rs\n#define lson lc,L,mid\n#define rson rc,mid+1,R\n#define root(p) rt[p],1,n\n\tint tot,rt[N],last[N];\n\tstruct ele{\n\t\tint ls,rs,tag;\n\t}t[N<<5];\n\tV modify(int&p,int L,int R,int l,int r,int x){\n\t\tt[++tot]=t[p],p=tot;\n\t\tif(L==l&&R==r)return void(t[p].tag=1ll*t[p].tag*x%mod);\n\t\tint mid=L+R>>1;\n\t\tif(l>mid)return modify(rson,l,r,x);\n\t\tif(r<=mid)return modify(lson,l,r,x);\n\t\tmodify(lson,l,mid,x),modify(rson,mid+1,r,x);\n\t}\n\tV init(){\n\t\tt[0].tag=1;\n\t\tFOR(i,1,n)if(rt[i]=rt[i-1],a[i]>1)\n\t\t\tmodify(root(i),last[a[i]]+1,i,a[i]),last[a[i]]=i;\n\t}\n\tI ask(int p,int L,int R,int x){\n\t\tif(L==R)return t[p].tag;\n\t\tint mid=L+R>>1;\n\t\tif(x<=mid)return 1ll*t[p].tag*ask(lson,x)%mod;\n\t\tif(x> mid)return 1ll*t[p].tag*ask(rson,x)%mod;\n\t}\n\tI ask(int l,int r){return ask(root(r),l);}\n#undef lc\n#undef rc\n#undef root\n#undef lson\n#undef rson\n}\nV input(){\n\tn=getint();\n\tFOR(i,1,n)a[i]=getint();\n}\nV init(){\n\tT1::init(),T2::init();\n}\nV work(){\n\tint ans=0;\n\tm=getint();\n\tfor(int l,r;m--;cout<<ans<<\'\\n\'){\n\t\tl=(getint()+ans)%n+1,r=(getint()+ans)%n+1;\n\t\tif(l>r)swap(l,r);\n\t\tans=1ll*T1::ask(l,r)*T2::ask(l,r)%mod;\n\t}\n}\nint main(){\n//\tfreopen(""test.in"",""r"",stdin);\n//\tfreopen(""test.out"",""w"",stdout);\n//\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n//\t}\n\treturn 0;\n}\n']","['data structures', 'math', 'number theory']",2700
https://codeforces.com//contest/1213/problem/D1,D1. Equalizing by Division  easy version , You are given an array a consisting of n integers In one move you can choose any a i and divide it by 2 rounding down in other words in one move you can set a i lfloor frac a i 2 rfloor You can perform such an operation possibly zero number of times with a i Your task is to calculate the minimum possible number of operations required to obtain at least k equal numbers in the array ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint a[N];\n\nvector<int> v[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n, k;\n    cin >> n >> k;\n    int ans = 0;\n    fr(i, 1, n) {\n        cin >> a[i];\n        int val = a[i];\n        int c = 0;\n        while(val) {\n            v[val].pb(c);\n            val >>= 1;\n            c++;\n        }\n        ans += c;\n    }\n    fr(i, 1, N - 1) {\n        sort(all(v[i]));\n        if(sz(v[i]) >= k) {\n            int cur = 0;\n            fr(j, 0, k - 1)\n                cur += v[i][j];\n            ans = min(ans, cur);\n        }\n    }\n    cout << ans;\n    return 0;\n}']","['brute force', 'implementation']",1500
https://codeforces.com//contest/757/problem/A,A. Gotta Catch Em' All ,Bash wants to become a Pokemon master one day Although he liked a lot of Pokemon he has always been fascinated by Bulbasaur the most Soon things started getting serious and his fascination turned into an obsession Since he is too young to go out and catch Bulbasaur he came up with his own way of catching a Bulbasaur Each day he takes the front page of the newspaper He cuts out the letters one at a time from anywhere on the front page of the newspaper to form the word without quotes and sticks it on his wall Bash is very particular about case the first letter of must be upper case and the rest must be lower case By doing this he thinks he has caught one Bulbasaur He then repeats this step on the left over part of the newspaper He keeps doing this until it is not possible to form the word from the newspaper Given the text on the front page of the newspaper can you tell how many Bulbasaurs he will catch today Note ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string s = ""Bulbasaur"";\n\nconst int N = 1234567;\n\nchar foo[N];\n\nint cnt[N];\n\nint main() {\n  scanf(""%s"", foo);\n  for (int j = 0; j < 256; j++) {\n    cnt[j] = 0;\n  }\n  for (int i = 0; foo[i]; i++) {\n    cnt[foo[i]]++;\n  }\n  int ans = 0;\n  while (true) {\n    bool ok = true;\n    for (int k = 0; k < (int) s.length(); k++) {\n      if (cnt[s[k]] <= 0) {\n        ok = false;\n        break;\n      }\n      cnt[s[k]]--;\n    }\n    if (!ok) {\n      break;\n    }\n    ans++;\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/1080/problem/A,A. Petya and Origami,Petya is having a party soon and he has decided to invite his n friends He wants to make invitations in the form of origami For each invitation he needs red sheets green sheets and blue sheets The store sells an infinite number of notebooks of each color but each notebook consists of only color with k sheets That is each notebook contains k sheets of either red green or blue Find the minimum number of notebooks that Petya needs to buy to invite all n of his friends ,"['#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nint main(){\n  int n, k;\n  scanf(""%d%d"", &n, &k);\n  printf(""%d\\n"", (n * 2 + k - 1) / k + (n * 5 + k - 1) / k + (n * 8 + k - 1) / k);\n  return 0;\n}']",['math'],800
https://codeforces.com//contest/1903/problem/F,F. Babysitting,Theofanis wants to play video games however he should also take care of his sister Since Theofanis is a CS major he found a way to do both He will install some cameras in his house in order to make sure his sister is okay His house is an undirected graph with n nodes and m edges His sister likes to play at the edges of the graph so he has to install a camera to at least one endpoint of every edge of the graph Theofanis wants to find a vertex cover that maximizes the minimum difference between indices of the chosen nodes More formally let a 1 a 2 ldots a k be a vertex cover of the graph Let the minimum difference between indices of the chosen nodes be the minimum lvert a i a j rvert where i neq j out of the nodes that you chose Can you find the maximum possible minimum difference between indices of the chosen nodes over all vertex covers ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 20;\n\nstruct SAT {\n  vector <int> g[N << 1], stk;\n  int dep[N << 1], low[N << 1], scc_id[N << 1];\n  int n, _id, _t;\n  bool is[N];\n  SAT() {}\n  void init(int _n) {\n    n = _n, _id = _t = 0;\n    for (int i = 0; i < 2 * n; ++i)\n      g[i].clear(), dep[i] = scc_id[i] = -1;\n    stk.clear();\n  }\n  void add_edge(int x, int y) { g[x].push_back(y); }\n  int rev(int i) { return i < n ? i + n : i - n; }\n  void add_ifthen(int x, int y)\n  { add_clause(rev(x), y); }\n  void add_clause(int x, int y)\n  { add_edge(rev(x), y), add_edge(rev(y), x); }\n  void dfs(int i) {\n    dep[i] = low[i] = _t++, stk.push_back(i);\n    for (int j : g[i]) if (scc_id[j] == -1) {\n      if (dep[j] == -1) dfs(j);\n      low[i] = min(low[i], low[j]);\n    }\n    if (low[i] == dep[i]) {\n      int id = _id++, x;\n      do {\n        x = stk.back(), stk.pop_back(), scc_id[x] = id;\n      } while (x != i);\n    }\n  }\n  bool solve() {\n    // is[i] = true -> i, is[i] = false -> -i\n    for (int i = 0; i < 2 * n; ++i) if (dep[i] == -1)\n      dfs(i);\n    for (int i = 0; i < n; ++i) {\n      if (scc_id[i] == scc_id[i + n]) return false;\n      if (scc_id[i] < scc_id[i + n]) is[i] = true;\n      else is[i] = false;\n    }\n    return true;\n  }\n} sat;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector <pair <int, int>> edge(m);\n        for (auto &[u, v] : edge) {\n            cin >> u >> v, --u, --v;\n        }\n        auto add = [&](int l, int r, int id) {\n            for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) {\n                    sat.add_clause(sat.rev(id), sat.rev(l)), l++;\n                }\n                if (r & 1) {\n                    --r, sat.add_clause(sat.rev(id), sat.rev(r));\n                }\n            }\n        };\n        auto ask = [&](int num) {\n            sat.init(2 * n);\n            for (int i = 1; i < n; ++i) {\n                sat.add_ifthen(i << 1, i);\n                sat.add_ifthen(i << 1 | 1, i);\n            }\n            for (auto [u, v] : edge) {\n                sat.add_clause(u + n, v + n);\n            }\n            for (int i = 0; i < n; ++i) {\n                add(max(i - num + 1, 0), i, i + n);\n                add(i + 1, min(i + num, n), i + n);\n            }\n            return sat.solve();\n        };\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            (ask(l + r >> 1) ? l : r) = l + r >> 1;\n        }\n        cout << l << '\\n';\n    }\n}""]","['2-sat', 'binary search', 'data structures', 'graphs', 'trees']",2500
https://codeforces.com//contest/712/problem/A,A. Memory and Crow,There are integers written in a row For all from to values are defined by the crows performing the following procedure The crow sets initially The crow then adds to subtracts adds the number and so on until the th number Thus Memory gives you the values and he now wants you to find the initial numbers written in the row Can you do it ,"['#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define maxn 100100\ntypedef long long ll;\nll a[maxn],b[maxn];\nint n;\n\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(""%I64d"",a+i);\n\t\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tb[i]=a[i]+a[i+1];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(""%I64d "",b[i]);\n\treturn 0;\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/1886/problem/C,C. Decreasing String,Recall that string a is lexicographically smaller than string b if a is a prefix of b and a ne b or there exists an index i 1 le i le min a b such that a i b i and for any index j 1 le j i a j b j Consider a sequence of strings s 1 s 2 dots s n each consisting of lowercase Latin letters String s 1 is given explicitly and all other strings are generated according to the following rule to obtain the string s i a character is removed from string s i 1 in such a way that string s i is lexicographically minimal For example if s 1 mathrm dacb then string s 2 mathrm acb string s 3 mathrm ab string s 4 mathrm a After that we obtain the string S s 1 s 2 dots s n S is the concatenation of all strings s 1 s 2 dots s n You need to output the character in position pos of the string S i e the character S pos ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    i64 pos;\n    std::cin >> pos;\n    pos--;\n    int x, y;\n    for (int i = 0; i < n; i++) {\n        int len = n - i;\n        if (pos < len) {\n            x = i;\n            y = pos;\n            break;\n        }\n        pos -= len;\n    }\n    \n    std::string t;\n    for (auto c : s) {\n        while (x > 0 && !t.empty() && c < t.back()) {\n            t.pop_back();\n            x--;\n        }\n        t += c;\n    }\n    std::cout << t[y];\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::cout << std::fixed << std::setprecision(10);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    std::cout << ""\\n"";\n    \n    return 0;\n}\n']","['implementation', 'strings']",1600
https://codeforces.com//contest/1630/problem/E,E. Expected Components,Given a cyclic array a of size n where a i is the value of a in the i th position Let us define that a permutation of a is equal to another permutation of a if and only if their values are the same for each position i or we can transform them to each other by performing some cyclic rotation Let us define for a cyclic array b its number of components as the number of connected components in a graph where the vertices are the positions of b and we add an edge between each pair of adjacent positions of b with equal values note that in a cyclic array the first and last position are also adjacents Find the expected value of components of a permutation of a if we select it equiprobably over the set of all the different permutations of a ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = (int)1e6 + 7;\nint cnt[N];\nint n;\nint a[N];\nint m, g;\nMint dp[N][2];\n\nint gcd(int x, int y) {\n\treturn (y == 0 ? x : gcd(y, x % y));\n}\n\nFactorials F(N);\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx--;\n\t\tcnt[x]++;\n\t}\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cnt[i] != 0)\n\t\t\ta[m++] = cnt[i];\n\tif (m == 1) {\n\t\tprintf(""1\\n"");\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[i][0] = dp[i][1] = 0;\n\tg = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tg = gcd(g, a[i]);\n\tfor (int x = g; x > 0; x--) {\n\t\tif (g % x) continue;\n\t\tassert(n % x == 0);\n\t\tint z = n / x;\n\t\tassert(z > 1);\n\t\tdp[x][1] = 0;\n\t\tdp[x][0] = F.f[z];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint f = a[i] / x;\n\t\t\tdp[x][1] -= Mint(f) * Mint(f - 1);\n\t\t\tdp[x][0] *= F.fi[f];\n\t\t}\n\t\tdp[x][1] /= z - 1;\n\t\tdp[x][1] += z;\n\t\tdp[x][1] *= dp[x][0];\n\t\tfor (int y = 2 * x; y <= g; y += x) {\n\t\t\tif (g % y) continue;\n\t\t\tdp[x][0] -= dp[y][0];\n\t\t\tdp[x][1] -= dp[y][1] * (y / x);\n\t\t}\n\t\t//eprintf(""x = %d, cnt = %u, sum = %u\\n"", x, dp[x][0].x, dp[x][1].x);\n\t}\n\tMint P = 0, Q = 0;\n\tfor (int x = 1; x <= g; x++) if (g % x == 0) {\n\t\tP += (dp[x][1] * x) * x;\n\t\tQ += dp[x][0] * x;\n\t}\n\tprintf(""%u\\n"", (P / Q).x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['combinatorics', 'math', 'number theory', 'probabilities']",2900
https://codeforces.com//contest/1512/problem/A,A. Spy Detected ,You are given an array a consisting of n n ge 3 positive integers It is known that in this array all the numbers except one are the same for example in the array 4 11 4 4 all numbers except one are equal to 4 Print the index of the element that does not equal others The numbers in the array are numbered from one ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=100010;\nconst int mod=1000000007;\nusing namespace std;\n\nint num[def],pos[def];\n\nint main()\n{\tint _=1,__=1,n,x;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=100;i++)num[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&x);\n\t\t\tnum[x]++;\n\t\t\tpos[x]=i;\n\t\t}\n\t\tfor(int i=1;i<=100;i++)if(num[i]==1){\n\t\t\tprintf(""%d\\n"",pos[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}']","['brute force', 'implementation']",800
https://codeforces.com//contest/850/problem/A,A. Five Dimensional Points,You are given set of points in 5 dimensional space The points are labeled from to No two points coincide We will call point if there are different points and not equal to from the given set such that angle between vectors and is acute i e strictly less than Otherwise the point is called The angle between vectors and in 5 dimensional space is defined as where is the scalar product and is length of Given the list of points print the indices of the good points in ascending order ,"['#include<map>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 1000000 + 10;\n\nint n;\nint x[N][5];\n\nvoid solve()\n{\n    cin >> n;\n    if (n > 100) {\n        cout << 0 << endl;\n        return;\n    }\n    for(int i = 0; i < n; ++ i) {\n        for(int j = 0; j < 5; ++ j) {\n            scanf(""%d"", &x[i][j]);\n        }\n    }\n    vector<int> vec;\n    for(int i = 0; i < n; ++ i) {\n        int flag = true;\n        for(int j = 0; j < n; ++ j) {\n            if (j == i) continue;\n            for(int k = j + 1; k < n; ++ k) {\n                if (k == i) continue;\n                long long sum = 0;\n                for(int w = 0; w < 5; ++ w) {\n                    sum += (x[j][w] - x[i][w]) * (x[k][w] - x[i][w]);\n                }\n                if (sum > 0) {\n                    flag = false;\n                }\n            }\n        }\n        if (flag) vec.push_back(i + 1);\n    }\n    cout << vec.size() << endl;\n    for(auto e: vec) {\n        cout << e << endl;\n    }\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n']","['brute force', 'geometry', 'math']",1700
https://codeforces.com//contest/1201/problem/A,A. Important Exam,A class of students wrote a multiple choice test There are n students in the class The test had m questions each of them had 5 possible answers A B C D or E There is exactly one correct answer for each question The correct answer for question i worth a i points Incorrect answers are graded with zero points The students remember what answers they gave on the exam but they don t know what are the correct answers They are very optimistic so they want to know what is the maximum possible total score of all students in the class ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1000 + 5;\nchar s[maxn][maxn];\nint a[maxn];\n\nint main() {\n    int n, m; scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n; ++i) scanf(""%s"", s[i]);\n    for (int i = 0; i < m; ++i) scanf(""%d"", &a[i]);\n    long long ans = 0;\n    for (int i = 0; i < m; ++i) {\n        vector<int> cnt(5, 0);\n        for (int j = 0; j < n; ++j) cnt[s[j][i] - \'A\']++;\n        ans += 1ll * a[i] * *max_element(cnt.begin(), cnt.end());\n    }\n    printf(""%lld\\n"", ans);\n}\n']","['implementation', 'strings']",900
https://codeforces.com//contest/1490/problem/A,A. Dense Array,Polycarp calls an array dense if the greater of any two adjacent elements is not more than twice bigger than the smaller More formally for any i 1 le i le n 1 this condition must be satisfied frac max a i a i 1 min a i a i 1 le 2For example the arrays 1 2 3 4 3 1 1 1 and 5 10 are dense And the arrays 5 11 1 4 2 6 6 1 are dense You are given an array a of n integers What is the minimum number of numbers you need to add to an array to make it dense You can insert numbers anywhere in the array If the array is already dense no numbers need to be added For example if a 4 2 10 1 then the answer is 5 and the array itself after inserting elements into it may look like this a 4 2 underline textbf 3 underline textbf 5 10 underline textbf 6 underline textbf 4 underline textbf 2 1 there are other ways to build such a ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint get(int a, int b)\n{\n\tint ret = 0;\n\n\twhile (a > 2 * b)\n\t{\n\t\tb *= 2;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint t;\n\tint n;\n\tint arr[100];\n\tint i;\n\tint ans;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\tans = 0;\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] > 2 * arr[i - 1])\n\t\t\t{\n\t\t\t\tans += get(arr[i], arr[i - 1]);\n\t\t\t}\n\t\t\telse if (arr[i - 1] > 2 * arr[i])\n\t\t\t{\n\t\t\t\tans += get(arr[i - 1], arr[i]);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n}""]","['greedy', 'math']",800
https://codeforces.com//contest/587/problem/C,C. Duff in the Army,Recently Duff has been a soldier in the army Malek is her commander Their country Andarz Gu has cities numbered from to and bidirectional roads Each road connects two different cities There exist a unique path between any two cities There are also people living in Andarz Gu numbered from to Each person has and ID number ID number of person is and he she lives in city number Note that there may be more than one person in a city also there may be no people living in the city Malek loves to order That s why he asks Duff to answer to queries In each query he gives her numbers and To answer a query Assume there are people living in the cities lying on the path from city to city Assume these people s IDs are in increasing order If then Duff should tell Malek numbers in this order In the other words Malek wants to know minimums on that path or less if there are less than people Duff is very busy at the moment so she asked you to help her and answer the queries ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int MAXN = 100001, LOG = 17;\nvi e[MAXN];\nint up[LOG + 1][MAXN];\nint h[MAXN];\nvi x[LOG + 1][MAXN];\n\nvoid dfs(int v, int p) {\n    up[0][v] = p;\n    for (int u: e[v]) {\n        if (u == p) continue;\n        h[u] = h[v] + 1;\n        dfs(u, v);\n    }\n}\n\nint jmp(int v, int d) {\n    ford(i, LOG) {\n        if ((1 << i) <= d) {\n            v = up[i][v];\n            d -= 1 << i;\n        }\n    }\n    return v;\n}\n\nint lca(int u, int v) {\n    if (h[u] < h[v]) swap(u, v);\n    u = jmp(u, h[u] - h[v]);\n    if (u == v) return u;\n    ford(i, LOG) {\n        int uu = up[i][u], vv = up[i][v];\n        if (uu != vv) u = uu, v = vv;\n    }\n    return up[0][u];\n}\n\nvi merg(const vi &a, const vi &b, int A) {\n    vi v;\n    int i = 0, j = 0;\n    while (i < a.size() && j < b.size() && v.size() < A) {\n        if (a[i] == b[j]) {\n            v.pb(a[i]);\n            ++i; ++j;\n            continue;\n        }\n        if (a[i] < b[j]) v.pb(a[i++]);\n        else v.pb(b[j++]);\n    }\n    while (i < a.size() && v.size() < A) v.pb(a[i++]);\n    while (j < b.size() && v.size() < A) v.pb(b[j++]);\n    return v;\n}\n\nvoid upq(int v, int d, int a, vector<vi *> &res) {\n//    vi res;\n    ford(i, LOG) {\n        if ((1 << i) <= d) {\n            res.pb(&x[i][v]);\n            v = up[i][v];\n            d -= 1 << i;\n        }\n    }\n//    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N, M, Q;\n//    cin >> N >> M >> Q; \n    scanf(""%d%d%d"", &N, &M, &Q);\n    forn(i, N - 1) {\n        int x, y;\n//        cin >> x >> y;\n        scanf(""%d%d"", &x, &y);\n        --x; --y;\n        e[x].pb(y);\n        e[y].pb(x);\n    }\n    forn(i, M) {\n        int v;\n//        cin >> v;\n        scanf(""%d"", &v);\n        --v;\n        x[0][v].pb(i);\n    }\n    forn(i, N) {\n        sort(all(x[0][i]));\n        if (x[0][i].size() > 10) x[0][i].resize(10);\n    }\n    dfs(0, 0);\n    forn(i, LOG) forn(j, N) {\n        up[i + 1][j] = up[i][up[i][j]];\n        x[i + 1][j] = merg(x[i][j], x[i][up[i][j]], 10);\n    }\n    cerr << ""built\\n"";\n    forn(q, Q) {\n        int u, v, a;\n//        cin >> u >> v >> a;\n        scanf(""%d%d%d"", &u, &v, &a);\n        --u; --v;\n        int w = lca(u, v);\n        vector<vi*> res;\n        upq(u, h[u] - h[w] + 1, a, res);\n        upq(v, h[v] - h[w], a, res);\n        vi ans;\n        vi ind(res.size());\n        set<pii> s;\n        forn(i, res.size()) {\n            if (!res[i]->empty()) s.insert(mp((*res[i])[0], i));\n        }\n        while (!s.empty() && ans.size() < a) {\n            int x = s.begin()->fi, j = s.begin()->se;\n            //if (ans.empty() || ans.back() != x) ans.pb(x);\n            ans.pb(x);\n            s.erase(s.begin());\n            ++ind[j];\n            if (ind[j] < res[j]->size()) s.insert(mp((*res[j])[ind[j]], j));\n        }\n        printf(""%d"", (int)ans.size());\n        for (int x: ans) printf("" %d"", x + 1);\n        printf(""\\n"");\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","['data structures', 'trees']",2200
https://codeforces.com//contest/521/problem/A,A. DNA Alignment,Vasya became interested in bioinformatics He s going to write an article about similar cyclic DNA sequences so he invented a new method for determining the similarity of cyclic sequences Let s assume that strings and have the same length then the function is defined as the number of positions in which the respective symbols of and are Function can be used to define the function of Vasya distance where is obtained from string by applying left circular shift times For example Vasya found a string of length on the Internet Now he wants to count how many strings there are such that the Vasya distance from the string attains maximum possible value Formally speaking must satisfy the equation Vasya could not try all possible strings to find an answer so he needs your help As the answer may be very large count the number of such strings modulo ,"['#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nchar ch[110000];\nint n,w,mo=1e9+7,num;\nint quick(int k1,int k2){\n\tint k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3=1ll*k3*k1%mo; k1=1ll*k1*k1%mo; k2>>=1;\n\t}\n\treturn k3;\n}\nint main(){\n\tscanf(""%d"",&n); int ans=0;\n\tscanf(""%s"",ch+1);\n\tnum=0; w=0;\n\tfor (int i=1;i<=n;i++) if (ch[i]==\'A\') num++; \n\tif (ans<num){ans=num; w=1;} else if (ans==num) w++;\n\tnum=0;\n\tfor (int i=1;i<=n;i++) if (ch[i]==\'C\') num++; \n\tif (ans<num){ans=num; w=1;} else if (ans==num) w++; \n\tnum=0;\n\tfor (int i=1;i<=n;i++) if (ch[i]==\'G\') num++;\n\tif (ans<num){ans=num; w=1;} else if (ans==num) w++;\n\tnum=0;\n\tfor (int i=1;i<=n;i++) if (ch[i]==\'T\') num++; \n\tif (ans<num){ans=num; w=1;} else if (ans==num) w++;\n\tcout<<quick(w,n)<<endl;\n\treturn 0;\n}']","['greedy', 'math']",1500
https://codeforces.com//contest/372/problem/D,D. Choosing Subtree is Fun,There is a tree consisting of vertices The vertices are numbered from to Let s define the length of an interval as the value The score of a subtree of this tree is the maximum length of such an interval that the vertices with numbers belong to the subtree Considering all subtrees of the tree whose size is at most return the maximum score of the subtree Note that in this problem tree is not rooted so a subtree is an arbitrary connected subgraph of the tree ,"['#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n//#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(int)n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ACCU accumulate\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<ll> VL;\nconst ll mod=1000000007;\nconst double eps=1e-9;\nconst double pi=acos(0)*2;\nll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nconst int N=201000;\nset<int> mp;\nint dep[N],f[N],F[N][20],id[N],cnt[N];\nint y[N],nxt[N],fst[N],tot,ans,n,k,u,v;\n\nvoid add(int u,int v) {tot++;y[tot]=v;nxt[tot]=fst[u];fst[u]=tot;}\nvoid dfs(int u,int p) { f[u]=p;id[cnt[u]=++tot]=u;\n\tfor (int j=fst[u];j;j=nxt[j]) if (y[j]!=p) dep[y[j]]=dep[u]+1,dfs(y[j],u);}\nint LCA(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tfor (int k=dep[v]-dep[u],j=17;j>=0;j--) if ((k>>j)&1) v=F[v][j],k^=(1<<j);\n\tif (u==v) return u;\n\tfor (int k=17;f[u]!=f[v];u=F[u][k],v=F[v][k]) for (;k && F[u][k]==F[v][k];k--);\n\treturn f[u];\n}\nvoid modify(char ch,int u) {\n\ttypeof(mp.begin()) it=mp.lower_bound(cnt[u]);\n\tif (*it==cnt[u]) mp.erase(cnt[u]),it=mp.lower_bound(cnt[u]);\n\tif (!mp.size()) {if (ch==\'+\') mp.insert(cnt[u]);return;}\n\tint q=id[(it==mp.end())?*mp.begin():*it],p=id[(it--==mp.begin())?*(--mp.end()):*it];\n\tint dt=dep[u]-dep[LCA(p,u)]-dep[LCA(q,u)]+dep[LCA(p,q)];\n\tif (ch==\'+\') ans+=dt,mp.insert(cnt[u]); else ans-=dt;\t\n}\nbool check(int v) {\n\tans=0;\n\tmp.clear();\n\trep(i,1,v) modify(\'+\',i);\n\trep(i,v,n+1) {\n\t\tmodify(\'+\',i);\n\t\tif (ans+1<=k) return 1;\n\t\tmodify(\'-\',i+1-v);\n\t}\n\treturn 0;\n} \nint main() {\n\tscanf(""%d%d"",&n,&k);\n\trep(i,1,n) scanf(""%d%d"",&u,&v),add(u,v),add(v,u);\n\ttot=0;dfs(1,0);id[n+1]=n+1;\n\trep(i,1,n+1) F[i][0]=f[i];\n\trep(j,1,18) rep(i,1,n+1) F[i+1][j]=F[F[i+1][j-1]][j-1];\n\tint l=1,r=n+1;\n\twhile (l+1<r) {\n\t\tint md=(l+r)>>1;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tprintf(""%d\\n"",l);\n\treturn 0;\n}\n']","['binary search', 'data structures', 'dfs and similar', 'trees', 'two pointers']",2600
https://codeforces.com//contest/1287/problem/B,B. Hyperset,Bees Alice and Alesya gave beekeeper Polina famous card game Set as a Christmas present The deck consists of cards that vary in four features across three options for each kind of feature number of shapes shape shading and color In this game some combinations of three cards are said to make up a For every feature color number shape and shading the three cards must display that feature as either all the same or pairwise different The picture below shows how sets look Polina came up with a new game called Hyperset In her game there are n cards with k features each feature has three possible values or The original Set game can be viewed as Hyperset with k 4 Similarly to the original game three cards form a if all features are the same for all cards or are pairwise different The goal of the game is to compute the number of ways to choose three cards that form a Unfortunately winter holidays have come to an end and it s time for Polina to go to school Help Polina find the number of sets among the cards lying on the table ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1505;\n\nstring s[N];\nmap<string, int> cnt;\nint n, k;\n\nvoid read() {\n  cin >> n >> k;\n  for (int i = 0 ; i < n ; i++) {\n    cin >> s[i];\n  }\n}\n\nlong long work() {\n  long long ret = 0;\n\n  for (int i = 0 ; i < n ; i++) {\n    for (int j = i+1 ; j < n ; j++) {\n      string cur = """";\n\n      for (int kk = 0 ; kk < k ; kk++) {\n        if (s[i][kk] == s[j][kk]) {\n          cur += s[i][kk];\n        } else {\n          if (\'S\' != s[i][kk] && \'S\' != s[j][kk]) {\n            cur += \'S\';\n          }         \n          if (\'E\' != s[i][kk] && \'E\' != s[j][kk]) {\n            cur += \'E\';\n          }\n          if (\'T\' != s[i][kk] && \'T\' != s[j][kk]) {\n            cur += \'T\';\n          }\n        }\n      }\n\n      if (cnt.count(cur)) {\n        ret += cnt[cur];\n      }\n    }\n\n    cnt[s[i]]++;\n  }\n\n  return ret;\n}\n\nint main() {\n  read();\n  cout << work() << endl;\n  return 0;\n}']","['brute force', 'data structures', 'implementation']",1500
https://codeforces.com//contest/1886/problem/E,E. I Wanna be the Team Leader,Monocarp is a team leader in a massive IT company There are m projects his team of programmers has to complete numbered from 1 to m The i th project has a difficulty level b i There are n programmers in the team numbered from 1 to n The j th programmer has a stress tolerance level a j Monocarp wants to assign the programmers to the projects in such a way that each programmer is assigned to no more than one project each project has at least one programmer assigned to it let k programmers be assigned to the i th project then all the assigned programmers have to have a stress tolerance level greater than or equal to frac b i k Help Monocarp to find a valid assignment If there are multiple answers print any of them ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::array<int, 2>> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i][0];\n        a[i][1] = i;\n    }\n    std::sort(a.begin(), a.end(), std::greater());\n    \n    std::vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> b[i];\n    }\n    \n    std::vector f(m, std::vector<int>(n, n + 1));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int l = j + 1 - ((b[i] - 1) / a[j][0] + 1);\n            if (l >= 0) {\n                f[i][l] = std::min(f[i][l], j + 1);\n            }\n        }\n        for (int j = n - 2; j >= 0; j--) {\n            f[i][j] = std::min(f[i][j], f[i][j + 1]);\n        }\n    }\n    \n    std::vector<int> dp(1 << m, n + 1);\n    dp[0] = 0;\n    for (int s = 1; s < (1 << m); s++) {\n        for (int i = 0; i < m; i++) {\n            if (s >> i & 1) {\n                int t = s ^ (1 << i);\n                if (dp[t] < n) {\n                    dp[s] = std::min(dp[s], f[i][dp[t]]);\n                }\n            }\n        }\n    }\n    \n    if (dp.back() <= n) {\n        std::cout << ""YES\\n"";\n        std::vector<std::vector<int>> ans(m);\n        int s = (1 << m) - 1;\n        while (s > 0) {\n            for (int i = 0; i < m; i++) {\n                if (s >> i & 1) {\n                    int t = s ^ (1 << i);\n                    if (dp[t] < n && f[i][dp[t]] == dp[s]) {\n                        for (int j = dp[t]; j < dp[s]; j++) {\n                            ans[i].push_back(a[j][1] + 1);\n                        }\n                        s = t;\n                        break;\n                    }\n                }\n            }\n        }\n        for (auto x : ans) {\n            std::cout << x.size();\n            for (auto y : x) {\n                std::cout << "" "" << y;\n            }\n            std::cout << ""\\n"";\n        }\n    } else {\n        std::cout << ""NO\\n"";\n    }\n    \n    return 0;\n}\n']","['bitmasks', 'constructive algorithms', 'dp', 'greedy', 'math', 'sortings', 'two pointers']",2400
https://codeforces.com//contest/257/problem/D,D. Sum,Vasya has found a piece of paper with an array written on it The array consists of integers Vasya noticed that the following condition holds for the array for any positive integer Vasya wants to add either a or a before each number of array Thus Vasya will get an expression consisting of summands The value of the resulting expression is the sum of all its elements The task is to add signs and before each number so that the value of expression meets the limits Print a sequence of signs and satisfying the given limits It is guaranteed that the solution for the problem exists ,"['#include <stdio.h>\n#include <stdlib.h>\n\nint n, i, Now, Tag, a[100005];\nchar Ans[100005];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tif (n == 1)\n\t{\n\t\tprintf(""+\\n"");\n\t\treturn 0;\n\t}\n\t\n\tNow = a[n];\n\tAns[n] = \'+\';\n\tfor (i = n - 1; i >= 1; i--)\n\t{\n\t\tif (Now > a[i])\n\t\t\tAns[i] = \'-\', Now -= a[i];\n\t\telse\n\t\t\tAns[i] = \'+\', Now = a[i] - Now;\n\t}\n\t\n\tTag = 0;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tif (Tag == 0)\n\t\t\tprintf(""%c"", Ans[i]);\n\t\telse\n\t\t\tprintf(""%c"", \'+\' + \'-\' - Ans[i]);\n\t\tif (Ans[i] == \'+\')\n\t\t\tTag = 1 - Tag;\n\t}\n\t\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","['greedy', 'math']",1900
https://codeforces.com//contest/1600/problem/F,F. Party Organization,On the great island of Baltia there live N people numbered from 1 to N There are exactly M pairs of people that are friends with each other The people of Baltia want to organize a successful party but they have very strict rules on what a party is and when the party is successful On the island of Baltia a party is a gathering of exactly 5 people The party is considered to be successful if either all the people at the party are friends with each other so that they can all talk to each other without having to worry about talking to someone they are not friends with or no two people at the party are friends with each other so that everyone can just be on their phones without anyone else bothering them Please help the people of Baltia organize a successful party or tell them that it s impossible to do so ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << ""["" << #x << ""] = [""; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\nint n, m;\nvector<set<int>> adj;\nvector<int> friends;\nvector<int> priorityList;\n\nint randi() {\n  return rand() % 1000 * 1000 + rand() % 1000;\n}\n\nvoid bf(int i) {\n  if (i == 5) {\n    REP(j, 5) cout << friends[j] << "" "";\n    exit(0);\n  }\n  int last = friends[i - 1];\n  for (int u: adj[last]) if (u > last && adj[u].size() >= 4) {\n    bool ok = true;\n    REP(j, i) if (!adj[u].count(friends[j])) {\n      ok = false; break;\n    }\n    if (ok) {\n      friends.push_back(u);\n      bf(i + 1);\n      friends.pop_back();\n    }\n  }\n}\n\nvoid bff(int i) {\n  if (i == 5) {\n    REP(j, 5) cout << friends[j] << "" "";\n    exit(0);\n  }\n  int last = friends[i - 1];\n  FOR(u, last + 1, n) if (adj[u].size() + 4 <= n) {\n    bool ok = true;\n    REP(j, i) if (adj[u].count(friends[j])) {\n      ok = false; break;\n    }\n    if (ok) {\n      friends.push_back(u);\n      bff(i + 1);\n      friends.pop_back();\n    }\n  }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n    adj.assign(n + 1, set<int>());\n    REP(i, m) {\n      int u, v;\n      cin >> u >> v;\n      adj[u].insert(v);\n      adj[v].insert(u);\n    }\n\n    FOR(i, 1, n) priorityList.push_back(i);\n    sort(priorityList.begin(), priorityList.end(), [&](const int i, const int j) {\n      if (adj[i].size() != adj[j].size()) {\n        return adj[i].size() > adj[j].size();\n      } else {\n        return i < j;\n      }\n    });\n\n    FOR(i, 1, n) if (adj[i].size() >= 4) {\n      friends.clear();\n      friends.push_back(i);\n      bf(1);\n    }\n\n    FOR(i, 1, n) if (adj[i].size() + 4 <= n) {\n      friends.clear();\n      friends.push_back(i);\n      bff(1);\n    }\n\n    // FOR(times, 1, 1000000) {\n    //   friends.clear();\n    //   FOR(i, 1, 5) friends.push_back(randi() % n + 1);\n    //   sort(friends.begin(), friends.end());\n    //   bool ok = true;\n    //   FOR(i, 0, 4) if (friends[i] == friends[i + 1]) {\n    //     ok = false;\n    //   }\n    //   FOR(i, 0, 4) {\n    //     FOR(j, i + 1, 4) {\n    //       int u = friends[i];\n    //       int v = friends[j];\n    //       if (adj[u].count(v)) {\n    //         ok = false;\n    //         break;\n    //       }\n    //     }\n    //     if (!ok) break;\n    //   }\n    //   if (ok) {\n    //     for (int u: friends) cout << u << "" "";\n    //     exit(0);        \n    //   }\n    // }\n\n    cout << -1 << endl;\n    return 0;\n}\n']","['brute force', 'math', 'probabilities']",2300
https://codeforces.com//contest/1787/problem/C,C. Remove the Bracket,RSJ has a sequence a of n integers a 1 a 2 ldots a n and an integer s For each of a 2 a 3 ldots a n 1 he chose a pair of x i and y i such that x i y i a i and x i s cdot y i s geq 0 Now he is interested in the value F a 1 cdot x 2 y 2 cdot x 3 y 3 cdot x 4 ldots y n 2 cdot x n 1 y n 1 cdot a n Please help him find the minimum possible value F he can get by choosing x i and y i optimally It can be shown that there is always at least one valid way to choose them ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, s;\n\t\tcin >> n >> s;\n\t\tvector<pi> a(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif (x >= 2 * s)\n\t\t\t\ta[i] = {x - s, s};\n\t\t\telse\n\t\t\t\ta[i] = {x - min(x, s), min(x, s)};\n\t\t}\n\t\tvector<pi> dp(n + 1);\n\t\tdp[1][0] = (a[0][0] + a[0][1]) * a[1][0];\n\t\tdp[1][1] = (a[0][0] + a[0][1]) * a[1][1];\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tdp[i][j] = min(dp[i - 1][0] + a[i - 1][1] * a[i][j], dp[i - 1][1] + a[i - 1][0] * a[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << min(dp[n - 2][0] + a[n - 2][1] * (a[n - 1][0] + a[n - 1][1]), dp[n - 2][1] + a[n - 2][0] * (a[n - 1][0] + a[n - 1][1])) << ""\\n"";\n\t}\n}\n']","['dp', 'greedy', 'math']",1600
https://codeforces.com//contest/1923/problem/E,E. Count Paths,You are given a tree consisting of n vertices numbered from 1 to n Every vertex is colored in some color denoted by an integer from 1 to n A simple path of the tree is called if it consists of at least 2 vertices the first and the last vertices of the path have the same color no other vertex on the path has the same color as the first vertex Count the number of the simple paths of the tree Note that paths are considered undirected i e the path from x to y is the same as the path from y to x ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n        c[i]--;\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<std::map<int, int>> mp(n);\n    i64 ans = 0;\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            self(self, y, x);\n            if (mp[y].count(c[x])) {\n                ans += mp[y][c[x]];\n                mp[y].erase(c[x]);\n            }\n            if (mp[x].size() < mp[y].size()) {\n                std::swap(mp[x], mp[y]);\n            }\n            for (auto [a, b] : mp[y]) {\n                ans += 1LL * b * mp[x][a];\n                mp[x][a] += b;\n            }\n            mp[y].clear();\n        }\n        mp[x][c[x]] += 1;\n    };\n    dfs(dfs, 0, -1);\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['data structures', 'dfs and similar', 'dp', 'dsu', 'graphs', 'trees']",2000
https://codeforces.com//contest/1572/problem/D,D. Bridge Club,There are currently n hot topics numbered from 0 to n 1 at your local bridge club and 2 n players numbered from 0 to 2 n 1 Each player holds a different set of views on those n topics more specifically the i th player holds a positive view on the j th topic if i 2 j 0 and a negative view otherwise Here denotes the bitwise AND operation You are going to organize a bridge tournament capable of accommodating at most k pairs of players bridge is played in teams of two people You can select teams arbitrarily while each player is in at most one team but there is one catch two players cannot be in the same pair if they disagree on 2 or more of those n topics as they would argue too much during the play You know that the i th player will pay you a i dollars if they play in this tournament Compute the maximum amount of money that you can earn if you pair the players in your club optimally ,"['/**\n *    author:  tourist\n *    created: 18.09.2021 18:04:02       \n**/\n#undef _GLIBCXX_DEBUG\n\n#undef LOCAL\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nnamespace radix {\n\nvector<int> p(65537);\n\ntemplate<typename T>\nvoid SortShift(vector<T>& a, vector<T>& new_a, int shift) {\n  assert(a.size() == new_a.size());\n  int n = static_cast<int>(a.size());\n  fill(p.begin(), p.end(), 0);\n  for (int i = 0; i < n; i++) p[1 + ((a[i] >> shift) & 0xffff)]++;\n  for (int i = 1; i <= 65536; i++) p[i] += p[i - 1];\n  for (int i = 0; i < n; i++) new_a[p[(a[i] >> shift) & 0xffff]++] = a[i];\n}\n\nvoid Sort(vector<int32_t>& a) {\n  constexpr int32_t flip = static_cast<int32_t>(1) << 31;\n  for (auto& aa : a) aa ^= flip;\n  vector<int32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  for (auto& aa : a) aa ^= flip;\n}\n\nvoid Sort(vector<uint32_t>& a) {\n  vector<uint32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n}\n\nvoid Sort(vector<int64_t>& a) {\n  constexpr int64_t flip = static_cast<int64_t>(1) << 63;\n  for (auto& aa : a) aa ^= flip;\n  vector<int64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n  for (auto& aa : a) aa ^= flip;\n}\n\nvoid Sort(vector<uint64_t>& a) {\n  vector<uint64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n}\n\n}  // namespace radix\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    cin >> a[i];\n  }\n  vector<int> kb(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    kb[i] = (__builtin_popcount(i));\n  }\n  vector<int> side(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    side[i] = (kb[i] % 2);\n  }\n  vector<int64_t> all((1 << (n - 1)) * n);\n  int ptr = 0;\n  for (int i = 0; i < (1 << n); i++) {\n    if (side[i] == 0) {\n      for (int j = 0; j < n; j++) {\n        int ni = i ^ (1 << j);\n        all[ptr] = ((long long) (a[i] + a[ni])) << (2 * n);\n        all[ptr] += ((long long) i) << n;\n        all[ptr] += ni;\n        ptr += 1;\n      }\n    }\n  }\n  assert(ptr == (int) all.size());\n  radix::Sort(all);\n  reverse(all.begin(), all.end());\n  k = min(k, (1 << (n - 1)));\n  vector<int> used(1 << n, 0);\n  vector<pair<int, int>> es;\n  vector<int> vs;\n  int ans = 0;\n  ptr = 0;\n  for (int iter = 0; iter < k; iter++) {\n    int pi = -1, pj = -1;\n    while (ptr < (int) all.size()) {\n      int i = (int) ((all[ptr] >> n) & ((1 << n) - 1));\n      int j = (int) (all[ptr] & ((1 << n) - 1));\n      if (!used[i] && !used[j]) {\n        pi = i;\n        pj = j;\n        break;\n      }\n      ptr += 1;\n    }\n    sort(vs.begin(), vs.end());\n    int sz = (int) vs.size();\n    vector<vector<int>> g(sz, vector<int>(sz, 0));\n    for (int i = 0; i < sz; i++) {\n      if (side[vs[i]] == 0) {\n        for (int j = 0; j < sz; j++) {\n          if (side[vs[j]] == 1 && kb[vs[i] ^ vs[j]] == 1) {\n            g[i][j] = 1;\n          }\n        }\n      }\n    }\n    for (auto& e : es) {\n      int x = (int) (lower_bound(vs.begin(), vs.end(), e.first) - vs.begin());\n      int y = (int) (lower_bound(vs.begin(), vs.end(), e.second) - vs.begin());\n      g[x][y] ^= 1;\n      g[y][x] ^= 1;\n    }\n    vector<int> opt(sz, -1);\n    vector<int> who(sz, -1);\n    for (int i = 0; i < sz; i++) {\n      for (int bit = 0; bit < n; bit++) {\n        int j = vs[i] ^ (1 << bit);\n        if (!used[j] && a[j] > opt[i]) {\n          opt[i] = a[j];\n          who[i] = j;\n        }\n      }\n    }\n    debug(vs, es, g);\n    vector<int> pr(sz, -1);\n    vector<int> que(sz);\n    int mi = -1, mj = -1, mx = -1;\n    for (int start = 0; start < sz; start++) {\n      if (side[vs[start]] == 1 && opt[start] >= 0) {\n        fill(pr.begin(), pr.end(), -1);\n        pr[start] = -2;\n        int qIt = 0;\n        int qSz = 1;\n        que[0] = start;\n        while (qIt < qSz) {\n          int i = que[qIt++];\n          for (int j = 0; j < sz; j++) {\n            debug(i, j, pr, g[i][j]);\n            if (g[i][j] && pr[j] == -1) {\n              que[qSz++] = j;\n              pr[j] = i;\n            }\n          }\n        }\n        for (int j = 0; j < sz; j++) {\n          if (side[vs[j]] == 0 && pr[j] != -1 && opt[j] >= 0) {\n            if (opt[start] + opt[j] > mx) {\n              mx = opt[start] + opt[j];\n              mi = start;\n              mj = j;\n            }\n          }\n        }\n      }\n    }\n    if (pi == -1 || mx > a[pi] + a[pj]) {\n      assert(mx >= 0);\n      int start = mi;\n      fill(pr.begin(), pr.end(), -1);\n      pr[start] = -2;\n      int qIt = 0;\n      int qSz = 1;\n      que[0] = start;\n      while (qIt < qSz) {\n        int i = que[qIt++];\n        for (int j = 0; j < sz; j++) {\n          if (g[i][j] && pr[j] == -1) {\n            que[qSz++] = j;\n            pr[j] = i;\n          }\n        }\n      }\n      debug(pr);\n      auto Flip = [&](pair<int, int> p) {\n        auto it = find(es.begin(), es.end(), p);\n        if (it == es.end()) {\n          es.push_back(p);\n        } else {\n          *it = es.back();\n          es.pop_back();\n        }\n      };\n      int at = mj;\n      while (at != mi) {\n        int x = vs[at];\n        int y = vs[pr[at]];\n        assert(side[x] != side[y]);\n        if (side[x] == 1) {\n          swap(x, y);\n        }\n        Flip(make_pair(x, y));\n        at = pr[at];\n      }\n      es.emplace_back(who[mi], vs[mi]);\n      es.emplace_back(vs[mj], who[mj]);\n      used[who[mi]] = 1;\n      used[who[mj]] = 1;\n      vs.push_back(who[mi]);\n      vs.push_back(who[mj]);\n      ans += mx;\n    } else {\n      used[pi] = 1;\n      used[pj] = 1;\n      vs.push_back(pi);\n      vs.push_back(pj);\n      es.emplace_back(pi, pj);\n      ans += a[pi] + a[pj];\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","['flows', 'graph matchings', 'graphs', 'greedy']",2800
https://codeforces.com//contest/1365/problem/F,F. Swaps Again,Ayush Ashish and Vivek are busy preparing a new problem for the next Codeforces round and need help checking if their test cases are valid Each test case consists of an integer n and two arrays a and b of size n If after some possibly zero operations described below array a can be transformed into array b the input is said to be Otherwise it is An operation on array a is select an integer k 1 le k le lfloor frac n 2 rfloor swap the prefix of length k with the suffix of length k For example if array a initially is 1 2 3 4 5 6 after performing an operation with k 2 it is transformed into 5 6 3 4 1 2 Given the set of test cases help them determine if each one is or ,"['#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint t=1;\n\tscanf(""%d"" ,&t);\n\twhile(t--){\n\t\tint n;\n\t\tscanf(""%d"", &n);\n\t\tvector <int> a(n), b(n);\n\t\tfor(int&i:a){\n\t\t\tscanf(""%d"", &i);\n\t\t}\n\t\tfor(int&i:b){\n\t\t\tscanf(""%d"", &i);\n\t\t}\n\t\tvector <pair <int, int> > pairsa, pairsb;\n\t\tfor(int i = 0;i < n/2;i ++){\n\t\t\tpair <int, int> inp;\n\t\t\tinp=make_pair(a[i], a[n-1-i]);\n\t\t\tif(inp.first>inp.second)\n\t\t\t\tswap(inp.first, inp.second);\n\t\t\tpairsa.push_back(inp);\n\t\t\tinp=make_pair(b[i], b[n-1-i]);\n\t\t\tif(inp.first>inp.second)\n\t\t\t\tswap(inp.first, inp.second);\n\t\t\tpairsb.push_back(inp);\n\t\t}\n\t\tsort(pairsa.begin(), pairsa.end());\n\t\tsort(pairsb.begin(), pairsb.end());\n\t\tbool can=true;\n\t\tfor(int i = 0;i < n/2;i ++){\n\t\t\tif(pairsa[i]!=pairsb[i])\n\t\t\t\tcan=false;\n\t\t}\n\t\tif(n&1){\n\t\t\tif(a[n/2]!=b[n/2])\n\t\t\t\tcan=false;\n\t\t}\n\t\tprintf(can?""Yes\\n"":""No\\n"");\n\t}\n}']","['constructive algorithms', 'implementation', 'sortings']",2100
https://codeforces.com//contest/578/problem/B,B.  Or  Game,You are given numbers You can perform at most operations For each operation you can multiply one of the numbers by We want to make as large as possible where denotes the bitwise OR Find the maximum possible value of after performing at most operations optimally ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 200100;\nll a[N];\nll b[N];\nll c[N];\nll x;\nint k;\nint n;\n\nint main()\n{\n    scanf(""%d%d%lld"", &n, &k, &x);\n    ll y = 1;\n    for (int i = 0; i < k; i++)\n        y *= x;\n    for (int i = 0; i < n; i++)\n        scanf(""%lld"", &a[i]);\n    b[0] = 0;\n    for (int i = 0; i < n; i++)\n        b[i + 1] = b[i] | a[i];\n    c[n] = 0;\n    for (int i = n - 1; i >= 0; i--)\n        c[i] = c[i + 1] | a[i];\n    ll ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        ans = max(ans, b[i] | c[i + 1] | (a[i] * y));\n    }\n    printf(""%lld\\n"", ans);\n\n    return 0;\n}']","['brute force', 'greedy']",1700
https://codeforces.com//contest/401/problem/A,A. Vanya and Cards,Vanya loves playing He even has a special set of cards to play with Each card has a single integer The number on the card can be positive negative and can even be equal to zero The only limit is the number on each card doesn t exceed in the absolute value Natasha doesn t like when Vanya spends a long time playing so she hid all of his cards Vanya became sad and started looking for the cards but he only found of them Vanya loves the balance so he wants the sum of all numbers on found cards equal to zero On the other hand he got very tired of looking for cards Help the boy and say what is the minimum number of cards does he need to find to make the sum equal to zero You can assume that initially Vanya had infinitely many cards with each integer number from to ,"['#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nint n,m,x,sum,ans;\n\nint main()\n{\n    cin>>n>>m;\n    sum=0;\n    for(int i=0;i<n;i++)\n    {\n        scanf(""%d"",&x);\n        sum+=x;\n    }\n    if(sum<0)sum=-sum;\n    ans=sum/m;\n    if(sum%m)ans++;\n    cout<<ans;\n    return 0;\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/185/problem/B,B. Mushroom Scientists,As you very well know the whole Universe traditionally uses three dimensional Cartesian system of coordinates In this system each point corresponds to three real coordinates In this coordinate system the distance between the center of the Universe and the point is calculated by the following formula Mushroom scientists that work for the Great Mushroom King think that the Universe isn t exactly right and the distance from the center of the Universe to a point equals To test the metric of mushroom scientists the usual scientists offered them a task find such that the distance between the center of the Universe and the point is maximum possible in the metric of mushroom scientists The mushroom scientists aren t good at maths so they commissioned you to do the task Note that in this problem it is considered that ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint main(void){\n    int S,a,b,c;\n    \n    cin >> S >> a >> b >> c;\n    \n    if(a == 0 && b == 0 && c == 0){\n        printf(""0.0 0.0 0.0\\n"");\n        return 0;\n    }\n    \n    double x = a / (double)(a + b + c) * S;\n    double y = b / (double)(a + b + c) * S;\n    double z = c / (double)(a + b + c) * S;\n    printf(""%.20f %.20f %.20f\\n"", x, y, z);\n    \n    return 0;\n}\n']","['math', 'ternary search']",1800
https://codeforces.com//contest/1935/problem/E,E. Distance Learning Courses in MAC,The New Year has arrived in the Master s Assistance Center which means it s time to introduce a new feature Now students are given distance learning courses with a total of n courses available For the i th distance learning course a student can receive a grade ranging from x i to y i However not all courses may be available to each student Specifically the j th student is only given courses with numbers from l j to r j meaning the distance learning courses with numbers l j l j 1 ldots r j The creators of the distance learning courses have decided to determine the final grade in a special way Let the j th student receive grades c l j c l j 1 ldots c r j for their distance learning courses Then their final grade will be equal to c l j c l j 1 ldots c r j where denotes the bitwise OR operation Since the chatbot for solving distance learning courses is broken the students have asked for your help For each of the q students tell them the maximum final grade they can achieve ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,a[N],b[N],p[N],q[N],bt,ans;\nbitset<N>vs;\nstruct dat{\n    int v,t;\n    dat operator+(const dat &z)\n    const{\n        int p=t&z.t;\n        if(p){\n            p=__lg(p);\n            return{v|z.v|((1<<p+1)-1),((t|z.t)>>p)<<p};\n        }else return{v|z.v,t|z.t};\n    }\n    int val(){\n        int res=v,l=v,k=t,x;\n        // cerr<<v<<"" ""<<t<<endl;\n        while(k){\n            x=__lg(k),k^=1<<x;\n            res=max(res,l|((1<<x)-1));\n            l|=1<<x;\n        }res=max(res,l);\n        return res;\n    }\n}d[N],sm[N],sum;\n#define ls x<<1\n#define rs x<<1|1\nvoid build(int x,int l,int r){\n    if(l==r)sm[x]=d[l];\n    else{\n        int md=l+r>>1;\n        build(ls,l,md);\n        build(rs,md+1,r);\n        sm[x]=sm[ls]+sm[rs];\n    }\n}\nvoid qsm(int x,int l,int r,int L,int R){\n    if(l>=L&&r<=R)sum=sum+sm[x];\n    else{\n        int md=l+r>>1;\n        if(L<=md)qsm(ls,l,md,L,R);\n        if(md<R)qsm(rs,md+1,r,L,R);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<=n;++i){\n            cin>>l>>r,d[i]={};\n            while(r){\n                x=__lg(r);\n                if(l&&x==__lg(l)){\n                    l^=1<<x,r^=1<<x;\n                    d[i].v|=1<<x;\n                }else{\n                    d[i].t=r;break;\n                }\n            }\n        }\n        build(1,1,n);\n        for(cin>>T2;T2--;){\n            cin>>l>>r,sum={};\n            qsm(1,1,n,l,r);\n            printf(""%d "",sum.val());\n        }puts("""");\n    }\n    return 0;\n}']","['bitmasks', 'brute force', 'data structures', 'greedy', 'math']",2400
https://codeforces.com//contest/1677/problem/D,D. Tokitsukaze and Permutations,Tokitsukaze has a permutation p She performed the following operation to p k times in one operation for each i from 1 to n 1 in order if p i p i 1 swap p i p i 1 After exactly k times of operations Tokitsukaze got a new sequence a obviously the sequence a is also a permutation After that Tokitsukaze wrote down the value sequence v of a on paper Denote the value sequence v of the permutation a of length n as v i sum j 1 i 1 a i a j where the value of a i a j define as if a i a j the value is 1 otherwise is 0 in other words v i is equal to the number of elements greater than a i that are to the left of position i Then Tokitsukaze went out to work There are three naughty cats in Tokitsukaze s house When she came home she found the paper with the value sequence v to be bitten out by the cats leaving several holes so that the value of some positions could not be seen clearly She forgot what the original permutation p was She wants to know how many different permutations p there are so that the value sequence v of the new permutation a after k operations is the same as the v written on the paper not taking into account the unclear positions Since the answer may be too large print it modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nmint p2[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi a=readvi(n);\n\tmint ans=1;\n\trep(i,n-k){\n\t\tint j=i+k;\n\t\tint w;\n\t\tif(a[i]==-1){\n\t\t\tw=j+1;\n\t\t}else if(a[i]==0){\n\t\t\tw=k+1;\n\t\t}else{\n\t\t\tw=1;\n\t\t}\n\t\tans*=w;\n\t}\n\trng(i,n-k,n){\n\t\tint j=i-(n-k);\n\t\tint w;\n\t\tif(a[i]==0||a[i]==-1){\n\t\t\tw=j+1;\n\t\t}else{\n\t\t\tw=0;\n\t\t}\n\t\tans*=w;\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['dp', 'math']",2500
https://codeforces.com//contest/1794/problem/C,C. Scoring Subsequences,The of a sequence s 1 s 2 ldots s d is defined as displaystyle frac s 1 cdot s 2 cdot ldots cdot s d d where d 1 cdot 2 cdot ldots cdot d In particular the score of an empty sequence is 1 For a sequence s 1 s 2 ldots s d let m be the maximum score among all its subsequences Its is defined as the maximum length of a subsequence with a score of m You are given a sequence a 1 a 2 ldots a n of integers of length n In other words the condition a 1 leq a 2 leq ldots leq a n is satisfied For each k 1 2 ldots n find the cost of the sequence a 1 a 2 ldots a k A sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several possibly zero or all elements ,"['#include <iostream>\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\ntemplate<class T>\nusing iset = tree<T, null_type, greater<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == \'-\')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nstring read_s() {\n  string s;\n  char c = getchar();\n  while (isspace(c))\n    c = getchar();\n  while (c != EOF && !isspace(c))\n    s += c, c = getchar();\n  return s;\n}\n\nint main() {\n  int t = read();\n  while (t--) {\n    int n = read();\n    static int a[100000];\n    for (int i = 0; i < n; i++)\n      a[i] = read();\n    iset<pair<int, int>> s;\n    for (int i = 0; i < n; i++) {\n      s.insert({a[i], i});\n      int low = 1, hi = i + 1;\n      while (low < hi) {\n        int t = (low + hi) / 2 + 1;\n        if (s.find_by_order(t - 1)->first >= t)\n          low = t;\n        else\n          hi = t - 1;\n      }\n      printf(""%d "", low);\n    }\n    printf(""\\n"");\n  }\n  return 0;\n}']","['binary search', 'greedy', 'math', 'two pointers']",1300
https://codeforces.com//contest/1543/problem/D2,D2. RPD and Rap Sheet  Hard Version ,Every decimal number has a base k equivalent The individual digits of a base k number are called k its Let s define the k itwise XOR of two k its a and b as a b bmod k The k itwise XOR of two base k numbers is equal to the new number formed by taking the k itwise XOR of their corresponding k its The k itwise XOR of two decimal numbers a and b is denoted by a oplus k b and is equal to the decimal representation of the k itwise XOR of the base k representations of a and b All further numbers used in the statement below are in decimal unless specified You have hacked the criminal database of Rockport Police Department RPD also known as the Rap Sheet But in order to access it you require a password You don t know it but you are quite sure that it lies between 0 and n 1 inclusive So you have decided to guess it Luckily you can try at most n times without being blocked by the system But the system is adaptive Each time you make an incorrect guess it changes the password Specifically if the password before the guess was x and you guess a different number y then the system changes the password to a number z such that x oplus k z y Guess the password and break into the system ,"['// Problem: D1. RPD and Rap Sheet (Easy Version)\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/D1\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nint n,k;\nint f(int x,int y)//减\n{\n\tint res=0,base=1;\n\twhile(x||y)\n\t{\n\t\tres+=(x%k+k-y%k)%k*base;\n\t\tbase*=k;\n\t\tx/=k,y/=k;\n\t}\n\treturn res;\n}\nint g(int x,int y)//加\n{\n\tint res=0,base=1;\n\twhile(x||y)\n\t{\n\t\tres+=(x%k+y%k)%k*base;\n\t\tbase*=k;\n\t\tx/=k,y/=k;\n\t}\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tn=read(),k=read();\n\t\tint s=0;\n        bool t=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t{\n\t\t\tint cur;\n            if(t) cur=g(f(0,i),s);\n            else cur=g(i,s);\n\t\t\tprintf(""%lld\\n"",cur);\n\t\t\tfflush(stdout);\n\t\t\ts=f(cur,s),t^=1;//s-cur\n\t\t\tif(read()==1) break;\n\t\t\t//如果i是0，会变成ixor s\n            //printf(""*%lld\\n"",s);\n\t\t}\n\t}\n\treturn 0;\n}']","['brute force', 'constructive algorithms', 'interactive', 'math']",2200
https://codeforces.com//contest/761/problem/C,C. Dasha and Password,After overcoming the stairs Dasha came to classes She needed to write a password to begin her classes The password is a string of length which satisfies the following requirements There is at least one digit in the string There is at least one lowercase small letter of the Latin alphabet in the string There is at least one of three listed symbols in the string Considering that these are programming classes it is not easy to write the password For each character of the password we have a fixed string of length on each of these strings there is a pointer on some character The th character displayed on the screen is the pointed character in the th string Initially all pointers are on characters with indexes in the corresponding strings all positions are numbered starting from one During one operation Dasha can move a pointer in one string one character to the left or to the right Strings are cyclic it means that when we move the pointer which is on the character with index to the left it moves to the character with the index and when we move it to the right from the position it moves to the position You need to determine the minimum number of operations necessary to make the string displayed on the screen a valid password ,"[""#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == '-')\n\t\t\ts = -1, c = getChar();\n\t\twhile ('0' <= c && c <= '9')\n\t\t\tx = x * 10 + c - '0', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar('-'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)('0' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 51;\nstring s[N];\nint dp[N][1 << 3]; //[had][num/char/special]\nint dist[N][1 << 3];\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> s[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tdist[i][0] = 0;\n\t\tdist[i][1] = m + 1;\n\t\tdist[i][2] = m + 1;\n\t\tdist[i][4] = m + 1;\n\n\t\tdist[i][3] = n * m;\n\t\tdist[i][5] = n * m;\n\t\tdist[i][6] = n * m;\n\t\tdist[i][7] = n * m;\n\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tint calc = min(j, m - j);\n\t\t\tif (s[i][j] >= 'a' && s[i][j] <= 'z')\n\t\t\t\tdist[i][1] = min(dist[i][1], calc);\n\t\t\telse if (s[i][j] >= '0' && s[i][j] <= '9')\n\t\t\t\tdist[i][2] = min(dist[i][2], calc);\n\t\t\telse if (s[i][j] == '#' || s[i][j] == '*' || s[i][j] == '&')\n\t\t\t\tdist[i][4] = min(dist[i][4], calc);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = 0; j < 8; ++j)\n\t\t\tdp[i][j] = 1 << 20;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < 8; ++j)\n\t\t\tfor (int z = 0; z < 8; ++z)\n\t\t\t{\n\t\t\t\tint to = j | z;\n\t\t\t\tdp[i + 1][to] = min(dp[i + 1][to], dp[i][j] + dist[i][z]);\n\t\t\t}\n\tcout << dp[n][7] << endl;\n\treturn 0;\n}""]","['brute force', 'dp', 'implementation']",1500
https://codeforces.com//contest/1935/problem/F,F. Andrey s Tree,Master Andrey loves trees dagger very much so he has a tree consisting of n vertices But it s not that simple Master Timofey decided to steal one vertex from the tree If Timofey stole vertex v from the tree then vertex v and all edges with one end at vertex v are removed from the tree while the numbers of other vertices remain unchanged To prevent Andrey from getting upset Timofey decided to make the resulting graph a tree again To do this he can add edges between any vertices a and b but when adding such an edge he must pay a b coins to the Master s Assistance Center Note that the resulting tree vertex v Timofey has not yet decided which vertex v he will remove from the tree so he wants to know for each vertex 1 leq v leq n the minimum number of coins needed to be spent to make the graph a tree again after removing vertex v as well as which edges need to be added dagger A tree is an undirected connected graph without cycles ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,ans,sz[N],f[N];\nint gf(int x){while(x!=f[x])x=f[f[f[f[x]]]];return x;}\nvector<int>lk[N];\nint stk[N],tp;\nstruct dat{\n    int l,r;\n    dat operator+(const dat &z)\n    const{return{min(l,z.l),max(r,z.r)};}\n}bc[N],d[N];\nbitset<N>vs;\nvoid mg(int x,int y){\n    x=gf(x),y=gf(y);\n    if(x!=y){\n        if(sz[x]<sz[y])swap(x,y);\n        sz[f[y]=x]+=sz[y];\n        stk[++tp]=y,bc[tp]=d[x],d[x]=d[x]+d[y];\n    }\n}\nvoid rec(){\n    int x=stk[tp];\n    d[f[x]]=bc[tp--];\n    sz[f[x]]-=sz[x],f[x]=x;\n}\nstruct Eg{int x,y;}g[N];\nint gt;\nvoid sol(int l,int r){\n    if(l==r){\n        int i,y,k,lt=tp;\n        gt=0;\n        for(int x:lk[l]){\n            y=gf(x);\n            // printf(""_l:%d y:%d l:%d r:%d\\n"",l,y,d[y].l,d[y].r);\n            if(d[y].l>1&&d[y].l-1!=l){\n                k=gf(d[y].l-1);\n                g[++gt]={d[y].l-1,d[y].l};\n                mg(k,y);\n            }y=gf(x);\n            if(d[y].r<n&&d[y].r+1!=l){\n                k=gf(d[y].r+1);\n                g[++gt]={d[y].r,d[y].r+1};\n                mg(k,y);\n            }\n        }\n        for(int x:lk[l]){\n            y=gf(x);\n            if(d[y].r==l-1&&l<n){\n                g[++gt]={l-1,l+1};\n                break;\n            }\n        }\n        while(tp>lt)rec();\n        for(i=1,k=0;i<=gt;++i)k+=g[i].y-g[i].x;\n        printf(""%d %d\\n"",k,gt);\n        for(i=1;i<=gt;++i)printf(""%d %d\\n"",g[i].x,g[i].y);\n        puts("""");\n    }else{\n        int md=l+r>>1,lt=tp,i,x;\n        for(x=r;x>md;--x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(l,md);\n        for(x=r;x>md;--x)vs[x]=0;\n        while(tp>lt)rec();\n        for(x=l;x<=md;++x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(md+1,r);\n        for(x=l;x<=md;++x)vs[x]=0;\n        while(tp>lt)rec();\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<n;++i){\n            cin>>x>>y;\n            lk[x].push_back(y);\n            lk[y].push_back(x);\n        }\n        for(x=1;x<=n;++x)\n            sz[f[x]=x]=1,d[x]={x,x};\n        sol(1,n);\n        for(x=1;x<=n;++x)lk[x].clear();\n    }\n    return 0;\n}']","['binary search', 'constructive algorithms', 'data structures', 'dfs and similar', 'dsu', 'greedy', 'implementation', 'trees']",2800
https://codeforces.com//contest/1601/problem/B,B. Frog Traveler,Frog Gorf is traveling through Swamp kingdom Unfortunately after a poor jump he fell into a well of n meters depth Now Gorf is on the bottom of the well and has a long way up The surface of the well s walls vary in quality somewhere they are slippery but somewhere have convenient ledges In other words if Gorf is on x meters below ground level then in one jump he can go up on any integer distance from 0 to a x meters inclusive Note that Gorf can t jump down only up Unfortunately Gorf has to take a break after each jump including jump on 0 meters And after jumping up to position x meters below ground level he ll slip exactly b x meters down while resting Calculate the minimum number of jumps Gorf needs to reach ground level ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[300005], b[300005];\nint dp[300005], pre[300005], pv[300005];\nset<int> R;\nqueue<int> que;\nint main()\n{\n\tscanf(""%d"", &n);\n\trep1(i, n) {\n\t\tscanf(""%d"", &a[i]); a[i] = i - a[i];\n\t}\n\trep1(i, n) {\n\t\tscanf(""%d"", &b[i]); b[i] += i;\n\t}\n\t\n\trep(i, n) dp[i] = -1;\n\tdp[n] = 0;\n\tque.push(n);\n\trep(i, n) R.insert(i);\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\twhile(true) {\n\t\t\tset<int>::iterator it = R.lower_bound(a[v]);\n\t\t\tif(it == R.end() || *it > v) break;\n\t\t\tif(dp[b[*it]] == -1) {\n\t\t\t\tpre[b[*it]] = v; pv[b[*it]] = *it;\n\t\t\t\tdp[b[*it]] = dp[v] + 1; que.push(b[*it]);\n\t\t\t}\n\t\t\tR.erase(it);\n\t\t}\n\t}\n\t\n\tif(dp[0] == -1) printf(""-1\\n"");\n\telse {\n\t\tprintf(""%d\\n"", dp[0]);\n\t\tvector<int> ans;\n\t\tfor(int i = 0; i != n; i = pre[i]) ans.push_back(pv[i]);\n\t\tfor(int i = (int)ans.size() - 1; i >= 0; i --) printf(""%d "", ans[i]);\n\t}\n\treturn 0;\n}']","['data structures', 'dfs and similar', 'dp', 'graphs', 'shortest paths', 'two pointers']",1900
https://codeforces.com//contest/1661/problem/D,D. Progressions Covering,You are given two arrays an array a consisting of n zeros and an array b consisting of n integers You can apply the following operation to the array a an arbitrary number of times choose some subsegment of a of length k and add the arithmetic progression 1 2 ldots k to this subsegment i e add 1 to the first element of the subsegment 2 to the second element and so on The chosen subsegment should be inside the borders of the array a i e if the left border of the chosen subsegment is l then the condition 1 le l le l k 1 le n should be satisfied Note that the progression added is always 1 2 ldots k but not the k k 1 ldots 1 or anything else i e the leftmost element of the subsegment always increases by 1 the second element always increases by 2 and so on Your task is to find the possible number of operations required to satisfy the condition a i ge b i for each i from 1 to n Note that the condition a i ge b i should be satisfied for all elements at once ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  vector<long long> b(n);\n  for (int i = 0; i < n; i++){\n    cin >> b[i];\n  }\n  reverse(b.begin(), b.end());\n  vector<long long> imos_a(n + 1, 0), imos_b(n + 1, 0);\n  long long ans = 0;\n  for (int i = 0; i <= n - k; i++){\n    b[i] -= imos_a[i] * i + imos_b[i];\n    if (b[i] > 0){\n      long long cnt = (b[i] + k - 1) / k;\n      ans += cnt;\n      imos_a[i] -= cnt;\n      imos_a[i + k] += cnt;\n      imos_b[i] += cnt * (k + i);\n      imos_b[i + k] -= cnt * (k + i);\n    }\n    imos_a[i + 1] += imos_a[i];\n    imos_b[i + 1] += imos_b[i];\n  }\n  long long mx = 0;\n  for (int i = n - k + 1; i < n; i++){\n    b[i] -= imos_a[i] * i + imos_b[i];\n    if (b[i] > 0){\n      mx = max(mx, (b[i] + n - i - 1) / (n - i));\n    }\n    imos_a[i + 1] += imos_a[i];\n    imos_b[i + 1] += imos_b[i];\n  }\n  cout << ans + mx << endl;\n}']","['data structures', 'greedy']",1900
https://codeforces.com//contest/1658/problem/B,B. Marin and Anti-coprime Permutation,Marin wants you to count number of permutations that are A permutation of length n is a permutation that has the following property gcd 1 cdot p 1 2 cdot p 2 dots n cdot p n 1 where gcd is the greatest common divisor A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint a[1000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n&1) cout << ""0\\n"";\n\t\telse\n\t\t{\n\t\t\tint ans=1;\n\t\t\tfor(int i=1;i<=n/2;i++)\n\t\t\t\tans=(ans*i%mod*i)%mod;\n\t\t\tcout << ans << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","['combinatorics', 'math', 'number theory']",800
https://codeforces.com//contest/416/problem/C,C. Booking System,Innovation technologies are on a victorious march around the planet They integrate into all spheres of human activity A restaurant called Dijkstra s Place has started thinking about optimizing the booking system There are booking requests received by now Each request is characterized by two numbers and the size of the group of visitors who will come via this request and the total sum of money they will spend in the restaurant correspondingly We know that for each request all people want to sit at the same table and are going to spend the whole evening in the restaurant from the opening moment at 18 00 to the closing moment Unfortunately there only are tables in the restaurant For each table we know the maximum number of people who can sit at it A table can have only people from the same group sitting at it If you cannot find a large enough table for the whole group then all visitors leave and naturally pay nothing Your task is given the tables and the requests decide which requests to accept and which requests to decline so that the money paid by the happy and full visitors was maximum ,"[""#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 1000 + 10;\n\nint n, k;\nint c[N], p[N], r[N];\nint vis[N];\npair<int, int> b[N];\npair< pair<int, int>, int> a[N];\n\nvoid solve()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tcin >> c[i] >> p[i];\n\t\ta[i] = make_pair(make_pair(p[i], - c[i]), i);\n\t}\n\tsort(a, a + n);\n\tcin >> k;\n\tfor(int i = 0; i < k; ++ i) {\n\t\tcin >> r[i];\n\t\tb[i] = make_pair(r[i], i);\n\t}\n\tsort(b, b + k);\n\n\tint ret = 0;\n\tvector< pair<int, int> > vec;\n\n\tfor(int i = n - 1; i >= 0; -- i) {\n\t\tint tmp = -a[i].first.second;\n\n\t\tfor(int j = 0; j < k; ++ j) {\n\t\t\tif (b[j].first >= tmp && ! vis[j]) {\n\t\t\t\tvis[j] = true;\n\t\t\t\tret += a[i].first.first;\n\t\t\t\tvec.push_back(make_pair(a[i].second + 1, b[j].second + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << vec.size() << ' ' << ret << endl;\n\tfor(int i = 0; i < vec.size(); ++ i) {\n\t\tcout << vec[i].first << ' ' << vec[i].second << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n""]","['binary search', 'dp', 'greedy', 'implementation']",1600
https://codeforces.com//contest/1795/problem/C,C. Tea Tasting,A tea manufacturer decided to conduct a massive tea tasting n sorts of tea will be tasted by n tasters Both the sorts of tea and the tasters are numbered from 1 to n The manufacturer prepared a i milliliters of the i th sort of tea The j th taster can drink b j milliliters of tea at once The tasting will be conducted in steps During the first step the i th taster tastes the i th sort of tea The i th taster drinks min a i b i tea how much is available of the i th sort and how much the i th taster can drink a i also decreases by this amount Then all tasters move to the previous sort of tea Thus during the second step the i th taster tastes the i 1 st sort of tea The i th taster drinks min a i 1 b i tea The 1 st person ends the tasting During the third step the i th taster tastes the i 2 nd sort of tea The 2 nd taster ends the tasting This goes on until everyone ends the tasting Take a look at the tasting process for n 3 a 10 20 15 b 9 8 6 In the left row there are the current amounts of each sort of tea In the right column there are current amounts of tea each taster has drunk in total The arrow tells which taster each tea goes to on the current step The number on the arrow is the amount minimum of how much is available of the sort of tea and how much the taster can drink For each taster print how many milliliters of tea he she will drink in total ,"['/**\n *    author:  tourist\n *    created: 16.02.2023 18:38:42       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) { \n      cin >> a[i];\n    }\n    vector<long long> b(n);\n    for (int i = 0; i < n; i++) { \n      cin >> b[i];\n    }\n    multiset<long long> s;\n    long long delta = 0;\n    for (int i = 0; i < n; i++) {\n      s.insert(a[i] - delta);\n      long long ans = 0;\n      while (!s.empty() && *s.begin() + delta <= b[i]) {\n        ans += *s.begin() + delta;\n        s.erase(s.begin());\n      }\n      ans += (long long) s.size() * b[i];\n      delta -= b[i];\n      cout << ans << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']","['binary search', 'data structures', 'implementation']",1500
https://codeforces.com//contest/875/problem/F,F. Royal Questions,In a medieval kingdom the economic crisis is raging Milk drops fall Economic indicators are deteriorating every day money from the treasury disappear To remedy the situation King Charles Sunnyface decided make his sons princes marry the brides with as big dowry as possible In search of candidates the king asked neighboring kingdoms and after a while several delegations arrived with unmarried princesses Receiving guests Karl learned that the dowry of the th princess is of golden coins Although the action takes place in the Middle Ages progressive ideas are widespread in society according to which no one can force a princess to marry a prince whom she does not like Therefore each princess has an opportunity to choose two princes for each of which she is ready to become a wife The princes were less fortunate they will obey the will of their father in the matter of choosing a bride Knowing the value of the dowry and the preferences of each princess Charles wants to play weddings in such a way that the total dowry of the brides of all his sons would be as great as possible At the same time to marry all the princes or princesses is not necessary Each prince can marry no more than one princess and vice versa each princess can marry no more than one prince Help the king to organize the marriage of his sons in the most profitable way for the treasury ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,m,f[200010],g[200010],p;\nstruct orz\n{\n\tint u,v,w;\n}x[200010];\ninline bool cmp(orz a,orz b)\n{\n\treturn a.w>b.w;\n}\ninline int fa(int i)\n{\n\treturn f[i]==i?i:f[i]=fa(f[i]);\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k;\n\tscanf(""%d%d"",&n,&m);\n\tfor(i=1;i<=m;i++)\n\t  scanf(""%d%d%d"",&x[i].u,&x[i].v,&x[i].w);\n\tsort(x+1,x+m+1,cmp);\n\tfor(i=1;i<=n;i++)\n\t  f[i]=i;\n\tfor(i=1;i<=m;i++)\n\t  {\n\t   j=fa(x[i].u);\n\t   k=fa(x[i].v);\n\t   if(j==k)\n\t     {\n\t      if(g[j]==0)\n\t        {\n\t\t\t g[j]++;\n\t\t\t p+=x[i].w;\n\t\t\t}\n\t\t }\n\t   else\n\t     if(g[j]+g[k]<=1)\n\t       {\n\t\t\tf[k]=j;\n\t\t\tg[j]+=g[k];\n\t\t\tp+=x[i].w;\n\t\t   }\n\t  }\n\tprintf(""%d\\n"",p);\n\treturn 0;\n}\n']","['dsu', 'graphs', 'greedy']",2500
https://codeforces.com//contest/724/problem/B,B. Batch Sort,You are given a table consisting of rows and columns Numbers in each row form a permutation of integers from to You are allowed to pick two elements in one row and swap them but for each row Also you are allowed to pick two columns and swap them Thus you are allowed to perform from to actions in total You have to check whether it s possible to obtain the identity permutation in each row In other words check if one can perform some of the operation following the given rules and make each row sorted in increasing order ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint p[30][30],n,m;\nbool check() {\n\trep(i,0,n) {\n\t\tint cnt=0;\n\t\trep(j,0,m) cnt+=p[i][j]!=j+1;\n\t\tif (cnt>2) return 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,n) rep(j,0,m) scanf(""%d"",&p[i][j]);\n\trep(a,0,m) rep(b,a,m) {\n\t\trep(i,0,n) swap(p[i][a],p[i][b]);\n\t\tif (check()) {\n\t\t\tputs(""YES"");\n\t\t\treturn 0;\n\t\t}\n\t\trep(i,0,n) swap(p[i][a],p[i][b]);\n\t}\n\tputs(""NO"");\n}\n']","['brute force', 'greedy', 'implementation', 'math']",1500
https://codeforces.com//contest/59/problem/A,A. Word,Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word That s why he decided to invent an extension for his favorite browser that would change the letters register in every word so that it either only consisted of lowercase letters or vice versa only of uppercase ones At that as little as possible letters should be changed in the word For example the word must be replaced with and the word with If a word contains an equal number of uppercase and lowercase letters you should replace all the letters with lowercase ones For example should be replaced by Your task is to use the given method on one given word ,"[""#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tint n = s.size();\n\tint low=0;\n\tfor(int i=0; i<n; ++i) low += !!islower(s[i]);\n\tint hi = n-low;\n\tfor(int i=0; i<n; ++i)\n\t\ts[i] = (low>=hi) ? tolower(s[i]) : toupper(s[i]);\n\tcout<<s<<'\\n';\n}\n""]","['implementation', 'strings']",800
https://codeforces.com//contest/734/problem/F,F. Anton and School,Anton goes to school his favorite lessons are arraystudying He usually solves all the tasks pretty fast but this time the teacher gave him a complicated one given two arrays and of length find array such that where means bitwise AND while means bitwise OR Usually Anton is good in arraystudying but this problem is too hard so Anton asks you to help ,"['#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 200500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\nll a[maxn];\nint b[maxn];\nint c[maxn];\nint bit[64];\nint bits2[64];\n\nvoid check( int n ) {\n    ll sum = 0LL;\n\tfor ( int j = 0; j < n; j++ ) {\n\t    sum += a[j];\n\t\tint x = a[j];\n\t\tint pos = 0;\n\t\twhile ( x ) {\n\t\t\tbit[pos++] += x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t}\n\tfor ( int j = 0; j < n; j++ ) {\n\t\tint x = a[j];\n\t\tint pos = 0;\n\t\tfor ( int i = 0; i < 64; i++ )\n\t\t\tbits2[i] = 0;\n\t\twhile ( x ) {\n\t\t\tbits2[pos++] = x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t\tll cnt = 0LL;\n\t\tll deg = 1LL;\n\t\tfor ( int i = 0; i < 60; i++ ) {\n\t\t\tif ( bits2[i] )\n\t\t\t\tcnt += 1LL * bit[i] * deg;\n\t\t\tdeg *= 2LL;\n\t\t}\n\t\tif ( cnt != b[j] ) {\n\t\t\tputs( ""-1"" );\n\t\t\texit( 0 );\n\t\t}\n\t\tif ( 1LL * a[j] * n + sum != 1LL * b[j] + 1LL * c[j] ) {\n\t\t\tputs( ""-1"" );\n\t\t\texit( 0 );\n        }\n    }\n}\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( ""input.txt"", ""r"", stdin );\n    // freopen( ""output.txt"", ""w"", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n;\n    ll sum = 0LL;\n    scanf ( ""%d"", &n );\n    for ( int j = 0; j < n; j++ ) {\n    \tscanf ( ""%d"", &b[j] );\n    \tsum += 1LL * b[j];\n    }\n    for ( int j = 0; j < n; j++ ) {\n   \t\tscanf ( ""%d"", &c[j] );\n   \t\tsum += 1LL * c[j];\n    }\n    if ( sum % ( 2LL * n ) != 0LL ) {\n    \tputs( ""-1"" );\n    \treturn 0;\n    }\n    sum /= 2LL * n;\n    for ( int j = 0; j < n; j++ ) {\n    \tint cur = b[j] + c[j];\n    \ta[j] = cur - sum;\n    \tif ( a[j] < 0LL ) {\n    \t\tputs( ""-1"" );\n    \t\treturn 0;\n    \t}\n    \tif ( 1LL * a[j] % n != 0LL ) {\n    \t\tputs( ""-1"" );\n    \t\treturn 0;\n    \t}\n    \ta[j] /= 1LL * n;\n    }\n    check( n );\n    for ( int j = 0; j < n; j++ )\n    \tcout << a[j] << \' \';\n    return 0;\n}\n']","['bitmasks', 'constructive algorithms', 'implementation', 'math']",2500
https://codeforces.com//contest/1785/problem/D,D. Wooden Spoon,2 n people numbered with distinct integers from 1 to 2 n are playing in a single elimination tournament The bracket of the tournament is a full binary tree of height n with 2 n leaves When two players meet each other in a match a player with the number always wins The winner of the tournament is the player who wins all n their matches A virtual consolation prize Wooden Spoon is awarded to a player who satisfies the following n conditions they lost their first match the player who beat them lost their second match the player who beat that player lost their third match ldots the player who beat the player from the previous condition lost the final match of the tournament It can be shown that there is always exactly one player who satisfies these conditions Consider all possible 2 n arrangements of players into the tournament bracket For each player find the number of these arrangements in which they will be awarded the Wooden Spoon and print these numbers modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define M_PI 0\n\ntemplate <typename T> T mod_inv_in_range(T a, T m) {\n\t// assert(0 <= a && a < m);\n\tT x = a, y = m;\n\tT vx = 1, vy = 0;\n\twhile (x) {\n\t\tT k = y / x;\n\t\ty %= x;\n\t\tvy -= k * vx;\n\t\tstd::swap(x, y);\n\t\tstd::swap(vx, vy);\n\t}\n\tassert(y == 1);\n\treturn vy < 0 ? m + vy : vy;\n}\n\ntemplate <typename T> T mod_inv(T a, T m) {\n\ta %= m;\n\ta = a < 0 ? a + m : a;\n\treturn mod_inv_in_range(a, m);\n}\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = mod_inv_in_range(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv -= MOD-o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\n\n/**\n * Author: Andrew He\n * Source: http://neerc.ifmo.ru/trains/toulouse/2017/fft2.pdf\n * Papers about accuracy: http://www.daemonology.net/papers/fft.pdf, http://www.cs.berkeley.edu/~fateman/papers/fftvsothers.pdf\n * For integers rounding works if $(|a| + |b|)\\max(a, b) < \\mathtt{\\sim} 10^9$, or in theory maybe $10^6$.\n */\n\nnamespace ecnerwala {\nnamespace fft {\n\nusing std::swap;\nusing std::vector;\nusing std::min;\nusing std::max;\n\ntemplate<class T> int sz(T&& arg) { using std::size; return int(size(std::forward<T>(arg))); }\ninline int nextPow2(int s) { return 1 << (s > 1 ? 32 - __builtin_clz(s-1) : 0); }\n\n// Complex\ntemplate <typename dbl> struct cplx { /// start-hash\n\tdbl x, y;\n\tcplx(dbl x_ = 0, dbl y_ = 0) : x(x_), y(y_) { }\n\tfriend cplx operator+(cplx a, cplx b) { return cplx(a.x + b.x, a.y + b.y); }\n\tfriend cplx operator-(cplx a, cplx b) { return cplx(a.x - b.x, a.y - b.y); }\n\tfriend cplx operator*(cplx a, cplx b) { return cplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n\tfriend cplx conj(cplx a) { return cplx(a.x, -a.y); }\n\tfriend cplx inv(cplx a) { dbl n = (a.x*a.x+a.y*a.y); return cplx(a.x/n,-a.y/n); }\n};\n\n// getRoot implementations\ntemplate <typename num> struct getRoot {\n\tstatic num f(int k) = delete;\n};\ntemplate <typename dbl> struct getRoot<cplx<dbl>> {\n\tstatic cplx<dbl> f(int k) {\n\t\tdbl a=2*M_PI/k;\n\t\treturn cplx<dbl>(cos(a),sin(a));\n\t}\n};\ntemplate <int MOD> struct primitive_root {\n\tstatic const int value;\n};\ntemplate <> struct primitive_root<998244353> {\n\tstatic const int value = 3;\n};\ntemplate <int MOD> struct getRoot<modnum<MOD>> {\n\tstatic modnum<MOD> f(int k) {\n\t\tassert((MOD-1)%k == 0);\n\t\treturn pow(modnum<MOD>(primitive_root<MOD>::value), (MOD-1)/k);\n\t}\n};\n\ntemplate <typename num> class fft {\n\tstatic vector<int> rev;\n\tstatic vector<num> rt;\n\npublic:\n\tstatic void init(int n);\n\ttemplate <typename Iterator> static void go(Iterator begin, int n);\n\n\tstatic vector<num> scratch_a;\n\tstatic vector<num> scratch_b;\n};\n\ntemplate <typename num> vector<int> fft<num>::rev({0,1});\ntemplate <typename num> vector<num> fft<num>::rt(2, num(1));\ntemplate <typename num> vector<num> fft<num>::scratch_a;\ntemplate <typename num> vector<num> fft<num>::scratch_b;\n\ntemplate <typename num> void fft<num>::init(int n) {\n\tif (n <= sz(rt)) return;\n\trev.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\trev[i] = (rev[i>>1] | ((i&1)*n)) >> 1;\n\t}\n\trt.reserve(n);\n\tfor (int k = sz(rt); k < n; k *= 2) {\n\t\trt.resize(2*k);\n\t\tnum z = getRoot<num>::f(2*k);\n\t\tfor (int i = k/2; i < k; i++) {\n\t\t\trt[2*i] = rt[i], rt[2*i+1] = rt[i]*z;\n\t\t}\n\t}\n}\n\ntemplate <typename num> template <typename Iterator> void fft<num>::go(Iterator begin, int n) {\n\tinit(n);\n\tint s = __builtin_ctz(sz(rev)/n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i < (rev[i]>>s)) {\n\t\t\tswap(*(begin+i), *(begin+(rev[i]>>s)));\n\t\t}\n\t}\n\tfor (int k = 1; k < n; k *= 2) {\n\t\tfor (int i = 0; i < n; i += 2 * k) {\n\t\t\tIterator it1 = begin + i, it2 = it1 + k;\n\t\t\tfor (int j = 0; j < k; j++, ++it1, ++it2) {\n\t\t\t\tnum t = rt[j+k] * *it2;\n\t\t\t\t*it2 = *it1 - t;\n\t\t\t\t*it1 = *it1 + t;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate <typename num> struct fft_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tvector<num>& fa = fft<num>::scratch_a;\n\t\tvector<num>& fb = fft<num>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<num>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\t\tcopy(ia, ia+sza, fa.begin());\n\t\tfill(fa.begin()+sza, fa.begin()+n, num(0));\n\t\tcopy(ib, ib+szb, fb.begin());\n\t\tfill(fb.begin()+szb, fb.begin()+n, num(0));\n\t\tfft<num>::go(fa.begin(), n);\n\t\tfft<num>::go(fb.begin(), n);\n\t\tnum d = inv(num(n));\n\t\tfor (int i = 0; i < n; i++) fa[i] = fa[i] * fb[i] * d;\n\t\treverse(fa.begin()+1, fa.begin()+n);\n\t\tfft<num>::go(fa.begin(), n);\n\t\tcopy(fa.begin(), fa.begin()+s, io);\n\t}\n};\n\ntemplate <typename num>\nstruct fft_inverser {\n\ttemplate <typename IterA, typename IterOut>\n\tstatic void inverse(IterA ia, int sza, IterOut io) {\n\t\tvector<num>& fa = fft<num>::scratch_a;\n\t\tvector<num>& fb = fft<num>::scratch_b;\n\n\t\tif (sza == 0) return;\n\t\tint s = nextPow2(sza) * 2;\n\t\tfft<num>::init(s);\n\t\tif (sz(fa) < s) fa.resize(s);\n\t\tif (sz(fb) < s) fb.resize(s);\n\t\tfb[0] = inv(*ia);\n\t\tfor (int n = 1; n < sza; ) {\n\t\t\tfill(fb.begin() + n, fb.begin() + 4 * n, num(0));\n\t\t\tn *= 2;\n\t\t\tcopy(ia, ia+min(n,sza), fa.begin());\n\t\t\tfill(fa.begin()+min(n,sza), fa.begin()+2*n, 0);\n\t\t\tfft<num>::go(fb.begin(), 2*n);\n\t\t\tfft<num>::go(fa.begin(), 2*n);\n\t\t\tnum d = inv(num(2*n));\n\t\t\tfor (int i = 0; i < 2*n; i++) fb[i] = fb[i] * (2 - fa[i] * fb[i]) * d;\n\t\t\treverse(fb.begin()+1, fb.begin()+2*n);\n\t\t\tfft<num>::go(fb.begin(), 2*n);\n\t\t}\n\t\tcopy(fb.begin(), fb.begin()+sza, io);\n\t}\n};\n\ntemplate <typename dbl>\nstruct fft_double_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tvector<cplx<dbl>>& fa = fft<cplx<dbl>>::scratch_a;\n\t\tvector<cplx<dbl>>& fb = fft<cplx<dbl>>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<cplx<dbl>>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\n\t\tfill(fa.begin(), fa.begin() + n, 0);\n\t\t{ auto it = ia; for (int i = 0; i < sza; ++i, ++it) fa[i].x = *it; }\n\t\t{ auto it = ib; for (int i = 0; i < szb; ++i, ++it) fa[i].y = *it; }\n\t\tfft<cplx<dbl>>::go(fa.begin(), n);\n\t\tfor (auto& x : fa) x = x * x;\n\t\tfor (int i = 0; i < n; ++i) fb[i] = fa[(n-i)&(n-1)] - conj(fa[i]);\n\t\tfft<cplx<dbl>>::go(fb.begin(), n);\n\t\t{ auto it = io; for (int i = 0; i < s; ++i, ++it) *it = fb[i].y / (4*n); }\n\t}\n};\n\ntemplate <typename mnum>\nstruct fft_mod_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tusing cnum = cplx<double>;\n\t\tvector<cnum>& fa = fft<cnum>::scratch_a;\n\t\tvector<cnum>& fb = fft<cnum>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<cnum>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\n\t\t{ auto it = ia; for (int i = 0; i < sza; ++i, ++it) fa[i] = cnum(int(*it) & ((1<<15)-1), int(*it) >> 15); }\n\t\tfill(fa.begin()+sza, fa.begin() + n, 0);\n\t\t{ auto it = ib; for (int i = 0; i < szb; ++i, ++it) fb[i] = cnum(int(*it) & ((1<<15)-1), int(*it) >> 15); }\n\t\tfill(fb.begin()+szb, fb.begin() + n, 0);\n\n\t\tfft<cnum>::go(fa.begin(), n);\n\t\tfft<cnum>::go(fb.begin(), n);\n\t\tdouble r0 = 0.5 / n; // 1/2n\n\t\tfor (int i = 0; i <= n/2; i++) {\n\t\t\tint j = (n-i)&(n-1);\n\t\t\tcnum g0 = (fb[i] + conj(fb[j])) * r0;\n\t\t\tcnum g1 = (fb[i] - conj(fb[j])) * r0;\n\t\t\tswap(g1.x, g1.y); g1.y *= -1;\n\t\t\tif (j != i) {\n\t\t\t\tswap(fa[j], fa[i]);\n\t\t\t\tfb[j] = fa[j] * g1;\n\t\t\t\tfa[j] = fa[j] * g0;\n\t\t\t}\n\t\t\tfb[i] = fa[i] * conj(g1);\n\t\t\tfa[i] = fa[i] * conj(g0);\n\t\t}\n\t\tfft<cnum>::go(fa.begin(), n);\n\t\tfft<cnum>::go(fb.begin(), n);\n\t\tusing ll = long long;\n\t\tconst ll m = mnum::MOD;\n\t\tauto it = io;\n\t\tfor (int i = 0; i < s; ++i, ++it) {\n\t\t\t*it = mnum((ll(fa[i].x+0.5)\n\t\t\t\t\t\t+ (ll(fa[i].y+0.5) % m << 15)\n\t\t\t\t\t\t+ (ll(fb[i].x+0.5) % m << 15)\n\t\t\t\t\t\t+ (ll(fb[i].y+0.5) % m << 30)) % m);\n\t\t}\n\t}\n};\n\ntemplate <class multiplier, typename num>\nstruct multiply_inverser {\n\ttemplate <typename IterA, typename IterOut>\n\tstatic void inverse(IterA ia, int sza, IterOut io) {\n\t\tif (sza == 0) return;\n\t\tint s = nextPow2(sza);\n\t\tvector<num> b(s,num(0));\n\t\tvector<num> tmp(2*s);\n\t\tb[0] = inv(*ia);\n\t\tfor (int n = 1; n < sza; ) {\n\t\t\t// TODO: could be square instead of multiply\n\t\t\tmultiplier::multiply(b.begin(),n,b.begin(),n,tmp.begin());\n\t\t\tint nn = min(sza,2*n);\n\t\t\tmultiplier::multiply(tmp.begin(),nn,ia,nn,tmp.begin());\n\t\t\tfor (int i = n; i < nn; i++) b[i] = -tmp[i];\n\t\t\tn = nn;\n\t\t}\n\t\tcopy(b.begin(), b.begin()+sza, io);\n\t}\n};\n\ntemplate <class multiplier, typename T> vector<T> multiply(const vector<T>& a, const vector<T>& b) {\n\tif (sz(a) == 0 || sz(b) == 0) return {};\n\tvector<T> r(max(0, sz(a) + sz(b) - 1));\n\tmultiplier::multiply(begin(a), sz(a), begin(b), sz(b), begin(r));\n\treturn r;\n}\n\ntemplate <typename T> vector<T> fft_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_multiplier<T>, T>(a, b);\n}\ntemplate <typename T> vector<T> fft_double_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_double_multiplier<T>, T>(a, b);\n}\ntemplate <typename T> vector<T> fft_mod_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_mod_multiplier<T>, T>(a, b);\n}\n\ntemplate <class inverser, typename T> vector<T> inverse(const vector<T>& a) {\n\tvector<T> r(sz(a));\n\tinverser::inverse(begin(a), sz(a), begin(r));\n\treturn r;\n}\ntemplate <typename T> vector<T> fft_inverse(const vector<T>& a) {\n\treturn inverse<fft_inverser<T>, T>(a);\n}\ntemplate <typename T> vector<T> fft_double_inverse(const vector<T>& a) {\n\treturn inverse<multiply_inverser<fft_double_multiplier<T>, T>, T>(a);\n}\ntemplate <typename T> vector<T> fft_mod_inverse(const vector<T>& a) {\n\treturn inverse<multiply_inverser<fft_mod_multiplier<T>, T>, T>(a);\n}\n\n}} // namespace ecnerwala::fft\n\nusing num = modnum<998244353>;\n\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint N;\n\tcin >> N;\n\tvector<num> x = {1};\n\tfor(int n = 1; n <= N; n++){\n\t\tvector<num> cx(1 << (n-1), 0);\n\t\tfor(int i = 0; i < x.size(); i++){\n\t\t\tx[i] *= ifact[i] * ifact[(1 << (n-1)) - 1 - i];\n\t\t}\n\t\tfor(int i = 0; i < cx.size(); i++){\n\t\t\tcx[i] = ifact[i] * ifact[(1 << (n-1)) - 1 - i];\n\t\t}\n\t\tvector<num> y((1 << n) - 1, 0);\n\t\tvector<num> cc = ecnerwala::fft::fft_multiply(x, cx);\n\t\tfor(int a = 0; a < y.size(); a++){\n\t\t\ty[a] = cc[a] * fact[a] * fact[(1 << n) - 2 - a];\n\t\t}\n\t\t// for(int a = 0; a < y.size(); a++){\n\t\t// \tfor(int i = 0; i <= a; i++){\n\t\t// \t\ty[a] += x[i] * ncr(a, i) * ncr((1 << n) - 2 - a, (1 << (n-1)) - 1 - i);\n\t\t// \t}\n\t\t// }\n\t\ty.push_back(0);\n\t\tfor(num& z : y) z *= fact[(1 << (n-1))] * 2;\n\t\tx = y;\n\t}\n\treverse(x.begin(), x.end());\n\tfor(num a : x) cout << a << \'\\n\';\n}']","['combinatorics', 'dp', 'fft', 'math']",2400
https://codeforces.com//contest/1526/problem/D,D. Kill Anton,After rejecting 10 100 data structure problems Errorgorn is very angry at Anton and decided to kill him Anton s DNA can be represented as a string a which only contains the characters there are only 4 distinct characters Errorgorn can change Anton s DNA into string b which must be a of a However Anton s body can defend against this attack In 1 second his body can swap 2 characters of his DNA to transform it back to a Anton s body is smart and will use the minimum number of moves To maximize the chance of Anton dying Errorgorn wants to change Anton s DNA the string that maximizes the time for Anton s body to revert his DNA But since Errorgorn is busy making more data structure problems he needs your help to find the best string B Can you help him ,"['//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>\'9\'||ch<\'0\') {\n\t\t\tch=getchar();\n\t\t\tif(ch==\'-\')fu=1;\n\t\t}\n\t\twhile(ch<=\'9\'&&ch>=\'0\') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>\'9\'||ch<\'0\') {\n\t\t\tch=getchar();\n\t\t\tif(ch==\'-\')fu=1;\n\t\t}\n\t\twhile(ch<=\'9\'&&ch>=\'0\') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0) {\n\t\t\tputchar(\'0\');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar(\'-\') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + \'0\' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\nll n,res;\nchar s[114514];\nstack<int>sta[200];\nint temp[114514];\nint c[114514];\nstring s1,s2,s3,s4,ans;\ninline void add(int pos) {\n\twhile(pos<=n) {\n\t\t++c[pos];\n\t\tpos+=(-pos&pos);\n\t}\n}\ninline int query(int pos) {\n\tint rt=0;\n\twhile(pos) {\n\t\trt+=c[pos];\n\t\tpos-=(-pos&pos);\n\t}\n\treturn rt;\n}\ninline ll ak() {\n\tF(i,1,n)c[i]=0;\n\tll rt=0;\n\tUF(i,n,1) {\n\t\trt+=query(temp[i]);\n\t\tadd(temp[i]);\n\t}\n\treturn rt;\n}\ninline ll check(string b) {\n\tb.insert(0,""#"");\n\tUF(i,n,1) {\n\t\tsta[s[i]].push(i);\n\t}\n\tF(i,1,n) {\n\t\ttemp[i]=sta[b[i]].top();\n\t\tsta[b[i]].pop();\n\t}\n\treturn ak();\n}\nint main() {\n\tF(fdafdas,1,read()) {\n\t\tscanf(""%s"",s+1);\n\t\tn=strlen(s+1);\n\t\tres=-1;\n\t\ts1.clear();\n\t\ts2.clear();\n\t\ts3.clear();\n\t\ts4.clear();\n\t\tF(i,1,n) {\n\t\t\tif(s[i]==\'A\')s1.push_back(\'A\');\n\t\t\tif(s[i]==\'N\')s2.push_back(\'N\');\n\t\t\tif(s[i]==\'O\')s3.push_back(\'O\');\n\t\t\tif(s[i]==\'T\')s4.push_back(\'T\');\n\t\t}\nll sss=check(s1+s2+s3+s4);if(sss>res){res=sss;ans=s1+s2+s3+s4;}\nsss=check(s1+s2+s4+s3);if(sss>res){res=sss;ans=s1+s2+s4+s3;}\nsss=check(s1+s3+s2+s4);if(sss>res){res=sss;ans=s1+s3+s2+s4;}\nsss=check(s1+s3+s4+s2);if(sss>res){res=sss;ans=s1+s3+s4+s2;}\nsss=check(s1+s4+s2+s3);if(sss>res){res=sss;ans=s1+s4+s2+s3;}\nsss=check(s1+s4+s3+s2);if(sss>res){res=sss;ans=s1+s4+s3+s2;}\nsss=check(s2+s1+s3+s4);if(sss>res){res=sss;ans=s2+s1+s3+s4;}\nsss=check(s2+s1+s4+s3);if(sss>res){res=sss;ans=s2+s1+s4+s3;}\nsss=check(s2+s3+s1+s4);if(sss>res){res=sss;ans=s2+s3+s1+s4;}\nsss=check(s2+s3+s4+s1);if(sss>res){res=sss;ans=s2+s3+s4+s1;}\nsss=check(s2+s4+s1+s3);if(sss>res){res=sss;ans=s2+s4+s1+s3;}\nsss=check(s2+s4+s3+s1);if(sss>res){res=sss;ans=s2+s4+s3+s1;}\nsss=check(s3+s1+s2+s4);if(sss>res){res=sss;ans=s3+s1+s2+s4;}\nsss=check(s3+s1+s4+s2);if(sss>res){res=sss;ans=s3+s1+s4+s2;}\nsss=check(s3+s2+s1+s4);if(sss>res){res=sss;ans=s3+s2+s1+s4;}\nsss=check(s3+s2+s4+s1);if(sss>res){res=sss;ans=s3+s2+s4+s1;}\nsss=check(s3+s4+s1+s2);if(sss>res){res=sss;ans=s3+s4+s1+s2;}\nsss=check(s3+s4+s2+s1);if(sss>res){res=sss;ans=s3+s4+s2+s1;}\nsss=check(s4+s1+s2+s3);if(sss>res){res=sss;ans=s4+s1+s2+s3;}\nsss=check(s4+s1+s3+s2);if(sss>res){res=sss;ans=s4+s1+s3+s2;}\nsss=check(s4+s2+s1+s3);if(sss>res){res=sss;ans=s4+s2+s1+s3;}\nsss=check(s4+s2+s3+s1);if(sss>res){res=sss;ans=s4+s2+s3+s1;}\nsss=check(s4+s3+s1+s2);if(sss>res){res=sss;ans=s4+s3+s1+s2;}\nsss=check(s4+s3+s2+s1);if(sss>res){res=sss;ans=s4+s3+s2+s1;}\n\t\tputs(ans.c_str());\n\t}\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms', 'data structures', 'math', 'strings']",2200
https://codeforces.com//contest/807/problem/A,A. Is it rated ,Here it is The Ultimate Question of Competitive Programming Codeforces and Everything And you are here to answer it Another Codeforces round has been conducted No two participants have the same number of points For each participant from the top to the bottom of the standings their rating before and after the round is known It s known that if at least one participant s rating has changed then the round was rated for sure It s also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating then at least one round participant s rating has changed In this problem you should not make any other assumptions about the rating system Determine if the current round is rated unrated or it s impossible to determine whether it is rated of not ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool rated(vector<pair<int,int> > vec) {\n    for(int i=0;i<vec.size();i++) {\n        if(vec[i].first != vec[i].second) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool unrated(vector<pair<int,int> > vec) {\n    if(rated(vec)) {\n        return false;\n    }\n    for(int i=0;i<vec.size()-1;i++) {\n        if(vec[i].first < vec[i+1].first) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int,int> > vec(n);\n    for(int i=0;i<n;i++) {\n        cin >> vec[i].first >> vec[i].second;\n    }\n    if(rated(vec)) {\n        cout << ""rated"" << endl;\n    } else if(unrated(vec)) {\n        cout << ""unrated"" << endl;\n    } else {\n        cout << ""maybe"" << endl;\n    }\n}']","['implementation', 'sortings']",900
https://codeforces.com//contest/1913/problem/F,F. Palindromic Problem,You are given a string s of length n consisting of lowercase Latin letters You are allowed to replace at most one character in the string with an arbitrary lowercase Latin letter Print the lexicographically minimal string that can be obtained from the original string and contains the maximum number of palindromes as substrings Note that if a palindrome appears more than once as a substring it is counted the same number of times it appears The string a is lexicographically smaller than the string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b are different the string a contains a letter that appears earlier in the alphabet than the corresponding letter in b ,"['/**\n *    author:  tourist\n *    created: 18.12.2023 09:53:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> suffix_array(int n, const T &s, int char_bound) {\n  vector<int> a(n);\n  if (n == 0) {\n    return a;\n  }\n  if (char_bound != -1) {\n    vector<int> aux(char_bound, 0);\n    for (int i = 0; i < n; i++) {\n      aux[s[i]]++;\n    }\n    int sum = 0;\n    for (int i = 0; i < char_bound; i++) {\n      int add = aux[i];\n      aux[i] = sum;\n      sum += add;\n    }\n    for (int i = 0; i < n; i++) {\n      a[aux[s[i]]++] = i;\n    }\n  } else {\n    iota(a.begin(), a.end(), 0);\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\n  }\n  vector<int> sorted_by_second(n);\n  vector<int> ptr_group(n);\n  vector<int> new_group(n);\n  vector<int> group(n);\n  group[a[0]] = 0;\n  for (int i = 1; i < n; i++) {\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\n  }\n  int cnt = group[a[n - 1]] + 1;\n  int step = 1;\n  while (cnt < n) {\n    int at = 0;\n    for (int i = n - step; i < n; i++) {\n      sorted_by_second[at++] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      if (a[i] - step >= 0) {\n        sorted_by_second[at++] = a[i] - step;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      ptr_group[group[a[i]]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      int x = sorted_by_second[i];\n      a[ptr_group[group[x]]++] = x;\n    }\n    new_group[a[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (group[a[i]] != group[a[i - 1]]) {\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\n      } else {\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\n      }\n    }\n    swap(group, new_group);\n    cnt = group[a[n - 1]] + 1;\n    step <<= 1;\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<int> suffix_array(const T &s, int char_bound) {\n  return suffix_array((int) s.size(), s, char_bound);\n}\n\ntemplate <typename T>\nvector<int> build_lcp(int n, const T &s, const vector<int> &sa) {\n  assert((int) sa.size() == n);\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    pos[sa[i]] = i;\n  }\n  vector<int> lcp(max(n - 1, 0));\n  int k = 0;\n  for (int i = 0; i < n; i++) {\n    k = max(k - 1, 0);\n    if (pos[i] == n - 1) {\n      k = 0;\n    } else {\n      int j = sa[pos[i] + 1];\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n        k++;\n      }\n      lcp[pos[i]] = k;\n    }\n  }\n  return lcp;\n}\n\ntemplate <typename T>\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\n  return build_lcp((int) s.size(), s, sa);\n}\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  string u = s + ""#"" + string(s.rbegin(), s.rend());\n  auto sa = suffix_array(u, 256);\n  auto lcp = build_lcp(u, sa);\n  SparseTable<int> st(lcp, [&](int i, int j) { return min(i, j); });\n  vector<int> pos(sa.size());\n  for (int i = 0; i < (int) sa.size(); i++) {\n    pos[sa[i]] = i;\n  }\n  auto LCP = [&](int i, int j) {\n    i = n + 1 + (n - 1 - i);\n    i = pos[i];\n    j = pos[j];\n    if (i > j) {\n      swap(i, j);\n    }\n    return st.get(i, j - 1);\n  };\n  const int ALPHA = 26;\n  vector<vector<long long>> delta(n, vector<long long>(ALPHA));\n  vector<long long> broke_k(n + 1);\n  vector<long long> broke_b(n + 1);\n  auto Add = [&](int l, int r, int k, int b) {\n    broke_k[l] += k;\n    broke_k[r + 1] -= k;\n    broke_b[l] += b;\n    broke_b[r + 1] -= b;\n  };\n  long long init = 0;\n  for (int t = 0; t <= 2 * (n - 1); t++) {\n    int i = t >> 1;\n    int j = (t + 1) >> 1;\n    int v = LCP(i, j);\n    init += v;\n    if (i - v >= 0 && j + v < n) {\n      assert(s[i - v] != s[j + v]);\n      int add = 1;\n      if (i - v - 1 >= 0 && j + v + 1 < n) {\n        add += LCP(i - v - 1, j + v + 1);\n      }\n      delta[i - v][(int) (s[j + v] - \'a\')] += add;\n      delta[j + v][(int) (s[i - v] - \'a\')] += add;\n    }\n    if (i == j) {\n      i -= 1;\n      j += 1;\n      v -= 1;\n    }\n    if (v > 0) {\n      Add(i - v + 1, i, 1, -(i - v));\n      Add(j, j + v - 1, -1, j + v);\n    }\n  }\n  vector<long long> broke(n);\n  for (int i = 0; i < n; i++) {\n    broke[i] = broke_k[i] * i + broke_b[i];\n    broke_k[i + 1] += broke_k[i];\n    broke_b[i + 1] += broke_b[i];\n  }\n  auto Better = [&](pair<int, int> a, pair<int, int> b) {\n    assert(a.first <= b.first);\n    if (a.first == b.first) {\n      return a.second < b.second;\n    }\n    return a.second < (int) (s[a.first] - \'a\');\n  };\n  long long ans = init;\n  pair<int, int> p = {n, -1};\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = 0; j < 26; j++) {\n      if (j == (int) (s[i] - \'a\')) {\n        continue;\n      }\n      long long cur = init + delta[i][j] - broke[i];\n      pair<int, int> q = {i, j};\n      if (cur > ans || (cur == ans && Better(q, p))) {\n        ans = cur;\n        p = q;\n      }\n    }\n  }\n  cout << ans << \'\\n\';\n  if (p.first < n) {\n    s[p.first] = (char) (\'a\' + p.second);\n  }\n  cout << s << \'\\n\';\n  return 0;\n}\n']","['binary search', 'data structures', 'hashing', 'string suffix structures', 'strings']",2800
https://codeforces.com//contest/303/problem/A,A. Lucky Permutation Triple,Bike is interested in permutations A permutation of length is an integer sequence such that each integer from 0 to appears exactly once in it For example is a permutation of length 3 while both and is not A permutation triple of permutations of length is called a Lucky Permutation Triple if and only if The sign denotes the th element of permutation The modular equality described above denotes that the remainders after dividing by and dividing by are equal Now he has an integer and wants to find a Lucky Permutation Triple Could you please help him ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    if (n % 2 == 0) {\n        cout << -1 << endl;\n    } else {\n        for (int i = 0; i < n; ++i) {\n            cout << i << "" \\n""[i == n - 1];\n        }\n        for (int i = 0; i < n; ++i) {\n            cout << ((n - 2) * (LL) i) % n << "" \\n""[i == n - 1];\n        }\n        for (int i = 0; i < n; ++i) {\n            cout << ((n - 1) * (LL) i) % n << "" \\n""[i == n - 1];\n        }\n    }\n}\n']","['constructive algorithms', 'implementation', 'math']",1300
https://codeforces.com//contest/346/problem/D,D. Robot Control,The boss of the Company of Robot is a cruel man His motto is Move forward Or Die And that is exactly what his company s product do Look at the behavior of the company s robot when it is walking in the directed graph This behavior has been called Three Laws of Robotics Law 1 The Robot will destroy itself when it visits a vertex of the graph which it has already visited Law 2 The Robot will destroy itself when it has no way to go that is when it reaches a vertex whose out degree is zero Law 3 The Robot will move randomly when it has multiple ways to move that is when it reach a vertex whose out degree is more than one Of course the robot can move only along the directed edges of the graph Can you imagine a robot behaving like that That s why they are sold at a very low price just for those who are short of money including mzry1992 of course mzry1992 has such a robot and she wants to move it from vertex to vertex in a directed graph safely without self destruction Luckily she can send her robot special orders at each vertex A special order shows the robot which way to move if it has multiple ways to move to prevent random moving of the robot according to Law 3 When the robot reaches vertex mzry1992 takes it off the graph immediately So you can see that as long as there exists a path from to she can always find a way to reach the goal whatever the vertex has the outdegree of zero or not Sample 2 However sending orders is expensive so your task is to find the minimum number of orders mzry1992 needs to send in the worst case Please note that mzry1992 can give orders to the robot on the graph Look at the first sample to clarify that part of the problem ,"['#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n//#pragma comment(linker,""/STACK:102400000,102400000"")\n\nint n, m;\nint OutDeg[1000001];\nvector <int> toMe[1000001];\nint S, T;\nvector <int> queue[1000001];\nint alreadyDeg[1000001];\nint minOut[1000001];\nint ans;\n\nint MAIN()\n{\n\tcin >> n >> m;\n\tmemset(OutDeg, 0, sizeof(OutDeg));\n\tmemset(alreadyDeg, 0, sizeof(alreadyDeg));\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tOutDeg[a] ++;\n\t\ttoMe[b].push_back(a);\n\t}\n\tcin >> S >> T;\n\tans = 100000000;\n\tqueue[0].push_back(T);\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tvector <int> waiting;\n\n\t\tfor(int j = 0; j < queue[i].size(); j++)\n\t\t{\n\t\t\tint v = queue[i][j];\n\t\t\t//cout << ""i = "" << i << "", v = "" << v << endl;\n\t\t\tif(v == S)\n\t\t\t\tans = i;\n\t\t\tfor(int k = 0; k < toMe[v].size(); k++)\n\t\t\t{\n\t\t\t\tint u = toMe[v][k];\n\n\t\t\t\tif(alreadyDeg[u] == OutDeg[u])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(alreadyDeg[u] == 0)\n\t\t\t\t{\n\t\t\t\t\talreadyDeg[u] ++;\n\t\t\t\t\tminOut[u] = i;\n\t\t\t\t}\n\t\t\t\telse if(minOut[u] == i)\n\t\t\t\t\talreadyDeg[u] ++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tminOut[u] ++;\n\t\t\t\t\talreadyDeg[u] = OutDeg[u];\n\t\t\t\t}\n\t\t\t\tif(alreadyDeg[u] == OutDeg[u])\n\t\t\t\t\tqueue[minOut[u]].push_back(u);\n\t\t\t\telse\n\t\t\t\t\twaiting.push_back(u);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < waiting.size(); k++)\n\t\t{\n\t\t\tint u = waiting[k];\n\n\t\t\tif(OutDeg[u] != alreadyDeg[u])\n\t\t\t{\n\t\t\t\talreadyDeg[u] = OutDeg[u];\n\t\t\t\tminOut[u] ++;\n\t\t\t\tqueue[minOut[u]].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans <= n)\n\t\tcout << ans << endl;\n\telse\n\t\tcout << -1 << endl;\n\treturn 0;\n}\n\nint main()\n{\n\t#ifdef LOCAL_TEST\n\t\tfreopen(""in.txt"", ""r"", stdin);\n\t\tfreopen(""out.txt"", ""w"", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\treturn MAIN();\n}\n']","['dp', 'graphs', 'shortest paths']",2600
https://codeforces.com//contest/477/problem/D,D. Dreamoon and Binary,Dreamoon saw a large integer written on the ground and wants to print its binary form out Dreamoon has accomplished the part of turning into its binary format Now he is going to print it in the following manner He has an integer and can only perform the following two operations in any order for unlimited times each Print n in binary form without leading zeros each print will append to the right of previous prints Increase n by 1 Let s define an as a sequence of operations that can successfully print binary representation of without leading zeros and ends with a print operation i e operation 1 Dreamoon wants to know how many different ideal sequences are there and the length in operations of the shortest ideal sequence The answers might be large so please print them modulo 1000000007 Let s define the string representation of an ideal sequence as a string of and where the th character in the string matches the th operation performed Two ideal sequences are called different if their string representations are different ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=5010;\nstruct node {\n\tnode *s[2]; int cr;\n} pool[N*N/2],*cur=pool,*rt=pool;\nint dp[N][N],dp2[N][N],rk[N][N],ret;\nint tot,n;\nPII ret2;\nchar s[N];\nvoid dfs(node *p) {\n\tp->cr=tot++;\n\tif (p->s[0]) dfs(p->s[0]);\n\tif (p->s[1]) dfs(p->s[1]);\n}\nvoid upd(PII &a,PII b) {\n\tif (b.se<=a.se) a=b;\n\telse {\n\t\tif (a.fi-b.fi>=30||b.fi>=30) a=b;\n\t\telse {\n\t\t\tll s1=0,s2=0;\n\t\t\trep(j,n-a.fi+1,n+1) s1=s1*2+s[j]-\'0\';\n\t\t\trep(j,n-b.fi+1,n+1) s2=s2*2+s[j]-\'0\';\n\t\t\tif (s1+a.se>s2+b.se) a=b;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(""%s"",s+1);\n\tn=strlen(s+1);\n\trt=cur++;\n\trep(i,1,n+1) {\n\t\tnode *p=rt;\n\t\trep(j,i,n+1) {\n\t\t\tint w=s[j]-\'0\';\n\t\t\tif (!p->s[w]) p->s[w]=cur++;\n\t\t\tp=p->s[w];\n\t\t\trk[i][j]=p-pool;\n\t\t}\n\t}\n\tdfs(rt);\n\trep(i,1,n+1) rep(j,i,n+1) rk[i][j]=pool[rk[i][j]].cr;\n\tmemset(dp2,0x20,sizeof(dp2));\n\tdp[0][0]=1;\n\trep(i,1,n+1) {\n\t\trep(j,1,i) if (s[i-j+1]==\'1\') {\n\t\t\tif (i>=2*j) {\n\t\t\t\tif (rk[i-2*j+1][i-j]<=rk[i-j+1][i]) {\n\t\t\t\t\tdp[i][j]=dp[i-j][j];\n\t\t\t\t\tdp2[i][j]=dp2[i-j][j]+1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j]=dp[i-j][j-1];\n\t\t\t\t\tdp2[i][j]=dp2[i-j][j-1]+1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp[i][j]=dp[i-j][i-j];\n\t\t\t\tdp2[i][j]=dp2[i-j][i-j]+1;\n\t\t\t}\n\t\t}\n\t\tdp[i][i]=1; dp2[i][i]=1;\n\t\tdp2[i][0]=0x20202020;\n\t\trep(j,1,i+1) {\n\t\t\tdp[i][j]=(dp[i][j-1]+dp[i][j])%mod;\n\t\t\tdp2[i][j]=min(dp2[i][j-1],dp2[i][j]);\n\t\t}\n\t}\n\tprintf(""%d\\n"",dp[n][n]);\n\tret2=mp(n,1);\n\trep(i,2,n+1) if (s[i]==\'1\'&&dp2[n][n-i+1]<=n) \n\t\tupd(ret2,mp(n-i+1,dp2[n][n-i+1]));\n\tret=0;\n\trep(i,n-ret2.fi+1,n+1) ret=(ret*2+s[i]-\'0\')%mod;\n\tret=(ret+ret2.se)%mod;\n\tprintf(""%d\\n"",ret);\n}\n']","['dp', 'strings']",2700
https://codeforces.com//contest/1782/problem/G,G. Diverse Coloring,In this problem we will be working with rooted binary trees A tree is called a rooted binary tree if it has a fixed root and every vertex has at most two children Let s assign a color white or blue to each vertex of the tree and call this assignment a of the tree Let s call a coloring if every vertex has a neighbor a parent or a child colored into an opposite color compared to this vertex It can be shown that any tree with at least two vertices allows a diverse coloring Let s define the of a coloring as the absolute value of the difference between the number of white vertices and the number of blue vertices Now to the problem Initially the tree consists of a single vertex with the number 1 which is its root Then for each i from 2 to n a new vertex i appears in the tree and it becomes a child of vertex p i It is guaranteed that after each step the tree will keep being a binary tree rooted at vertex 1 that is each vertex will have at most two children After every new vertex is added print the smallest value of disbalance over all possible diverse colorings of the current tree Moreover after adding the last vertex with the number n also print a diverse coloring with the smallest possible disbalance as well ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, p[N], deg[N], ns, vis[N], tag[N], ans[N];\nint to[N], tow[N], sum[N];\nvi e[N], G[N];\nvoid dfs(int x, int rt, int rtx) {\n\tif(rtx) \n\t\tsum[rt] -= 1;\n\telse \n\t\tsum[rt] += 1;\n\tto[x] = rt;\n\ttow[x] = rtx;\n\tfor(auto v : G[x]) if(!to[v]) \n//\t\tcout << x << "" -> "" << v << endl, \n\t\tdfs(v, rt, rtx ^ 1);\n}\nint S[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) deg[i] = 0, sum[i] = 0, tow[i] = 0, ans[i] = 0, \n\t\tto[i] = 0, tow[i] = 0, e[i].clear(), G[i].clear();\n\tL(i, 2, n) {\n\t\tcin >> p[i];\n\t\tdeg[i] += 1;\n\t\tdeg[p[i]] += 1;\n\t\tns = i & 1;\n\t\tif(i == 4) {\n\t\t\tL(i, 1, 4) \n\t\t\t\tif(deg[i] == 3)\n\t\t\t\t\tns = 2;\n \t\t}\n \t\tcout << ns << \'\\n\';\n\t\te[i].emplace_back(p[i]);\n\t\te[p[i]].emplace_back(i);\n\t} \n\tif(n <= 4) {\n\t\tL(msk, 0, (1 << n) - 1) {\n\t\t\tint bt = __builtin_popcount(msk);\n\t\t\tif(n - bt * 2 != ns) continue;\n\t\t\tint qwq = 1;\n\t\t\tL(i, 1, n) {\n\t\t\t\tint ok = 0;\n\t\t\t\tfor(auto v : e[i]) {\n\t\t\t\t\tif((msk >> (i - 1) & 1) != (msk >> (v - 1) & 1)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\tif(!ok) qwq = 0;\n\t\t\t}\n\t\t\tif(qwq) {\n\t\t\t\tL(i, 1, n) cout << ((msk >> (i - 1) & 1) ? \'w\' : \'b\');\n\t\t\t\tcout << \'\\n\';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t\treturn ;\n\t}\n\tqueue < int > q;\n\tL(i, 1, n) if(deg[i] == 1) q.push(i);\n\tL(i, 1, n) vis[i] = 0, tag[i] = 0, S[i] = 1; \n\twhile(sz(q)) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tvis[u] = 1;\n//\t\tcout << ""u = "" << u << endl;\n\t\t\n\t\tint to = -1;\n\t\tfor(auto v : e[u]) {\n\t\t\tif(!vis[v]) {\n\t\t\t\t--deg[v];\n\t\t\t\tif(deg[v] == 1) \n\t\t\t\t\tq.push(v);\n\t\t\t\tto = v;\n\t\t\t}\n\t\t}\n\t\t\n//\t\tcout << ""act "" << u << "" : "" << S[u] << endl;\n\t\tif(tag[u]) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(auto v : e[u]) \n\t\t\tif(S[v] >= 0) \n\t\t\t\tto = v;\n\t\tif(to == -1) \n\t\t\tto = e[u][0];\n//\t\tcout << u << "" : "" << S[u] << endl;\n\t\t\n\t\tG[u].emplace_back(to);\n\t\tG[to].emplace_back(u);\n\t\tS[to] -= S[u];\n\t\ttag[u] = tag[to] = true;\n\t}\n\t\n//\tL(i, 1, n) \n//\t\tcout << S[i] << \' \';\n//\tcout << endl;\n\t\n\tvi arr;\n\tL(i, 1, n) if(!to[i]) \n\t\tsum[i] = 0, dfs(i, i, 0), arr.emplace_back(i);\n\t\n\tsort(arr.begin(), arr.end(), [&] (int x, int y) {\n\t\treturn abs(sum[x]) > abs(sum[y]);\n\t});\n\tint all = 0;\n\tfor(auto u : arr) {\n\t\tint ab = abs(sum[u]);\n//\t\tcout << ""ab = "" << ab << endl; \n\t\tif(all <= 0) {\n\t\t\tall += ab;\n\t\t\tans[u] = 0 ^ (sum[u] < 0);\n\t\t} else {\n\t\t\tall -= ab;\n\t\t\tans[u] = 1 ^ (sum[u] < 0);\n\t\t}\n\t}\n\tL(i, 1, n) \n\t\tans[i] = ans[to[i]] ^ tow[i];\n\tassert(all == ns);\n\t\n\tL(i, 1, n) \n\t\tif(ans[i]) cout << \'w\';\n\t\telse cout << \'b\';\n\tcout << \'\\n\';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ']","['constructive algorithms', 'dp', 'greedy', 'trees']",3200
https://codeforces.com//contest/1304/problem/A,A. Two Rabbits,Being tired of participating in too many Codeforces rounds Gildong decided to take some rest in a park He sat down on a bench and soon he found two rabbits hopping around One of the rabbits was taller than the other He noticed that the two rabbits were hopping The positions of the two rabbits can be represented as integer coordinates on a horizontal line The taller rabbit is currently on position x and the shorter rabbit is currently on position y x lt y Every second each rabbit hops to another position The taller rabbit hops to the positive direction by a and the shorter rabbit hops to the negative direction by b For example let s say x 0 y 10 a 2 and b 3 At the 1 st second each rabbit will be at position 2 and 7 At the 2 nd second both rabbits will be at position 4 Gildong is now wondering Let s find a moment in time in seconds after which the rabbits will be at the same point ,"['#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\nusing namespace std;\n\n\nint main(){\n\tint T , N , M , x , y;\n\tfor(cin >> T ; T ; --T){\n\t\tcin >> N >> M >> x >> y;\n\t\tcout << ((M - N) % (x + y) == 0 ? (M - N) / (x + y) : -1) << endl;\n\t}\n\treturn 0;\n}\n']",['math'],800
https://codeforces.com//contest/610/problem/D,D. Vika and Segments,Vika has an infinite sheet of squared paper Initially all squares are white She introduced a two dimensional coordinate system on this sheet and drew black horizontal and vertical segments parallel to the coordinate axes All segments have width equal to square that means every segment occupy some set of neighbouring squares situated in one row or one column Your task is to calculate the number of painted cells If a cell was painted more than once it should be calculated exactly once ,"[""#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\nint n;\nstruct seg{\n    int x1,y1,x2,y2;\n}s[111111];\nseg v[111111],h[111111];\nseg vn[111111];int ntot=0;\nint vtot=0,htot=0;\nint cmpx(const seg&a,const seg&b){\n    if(a.x1==b.x1)return a.y1<b.y1;\n    return a.x1<b.x1;\n}\nint cmpy(const seg&a,const seg&b){\n    if(a.y1==b.y1)return a.x1<b.x1;\n    return a.y1<b.y1;\n}\n\nstruct node{\n    int x,y,sg;\n}tt[222222];int ttot=0;\n\n\n\nint cmpnode(const node&a,const node&b){\n    return a.x<b.x;\n}\nstruct nnode{int ch[2],sz,v,fix;}t[1000005];int ndtot=0;\nint root=0;\nvoid rot(int &x,int f){\n    int y=t[x].ch[!f];\n    t[x].ch[!f]=t[y].ch[f];\n    t[y].ch[f]=x;\n    t[y].sz=t[x].sz;\n    t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz+1;\n    x=y;\n}\nvoid ins(int &x,int v){\n    if(x==0){\n        x=++ndtot;\n        t[x].ch[0]=t[x].ch[1]=0;\n        t[x].sz=1;\n        t[x].fix=rand();\n        t[x].v=v;\n    }else{\n        int f=v>=t[x].v;\n        ins(t[x].ch[f],v);\n        t[x].sz++;\n        if(t[t[x].ch[f]].fix<t[x].fix)rot(x,!f);\n    }\n}\nvoid del(int &x){\n    if(!t[x].ch[0] && !t[x].ch[1])x=0;\n    else{\n        int f=!t[x].ch[0] || t[x].ch[1]&&t[t[x].ch[1]].fix<t[t[x].ch[0]].fix;\n        rot(x,!f);\n        t[x].sz--;\n        del(t[x].ch[!f]);\n    }\n}\nvoid del_num(int &x,int v){\n    if(t[x].v==v)del(x);\n    else{\n        int f=v>=t[x].v;\n        t[x].sz--;\n        del_num(t[x].ch[f],v);\n    }\n}\nint rk(int v){\n    int x=root;int ans=0;\n    while(x){\n        if(t[x].v>=v)x=t[x].ch[0];\n        else{\n            ans+=t[t[x].ch[0]].sz+1;\n            x=t[x].ch[1];\n        }\n    }\n    return ans+1;\n}\nint main()\n{\n    gn(n);\n    for (int i=1;i<=n;i++){\n        gn(s[i].x1);\n        gn(s[i].y1);\n        gn(s[i].x2);\n        gn(s[i].y2);\n        if(s[i].x1>s[i].x2)swap(s[i].x1,s[i].x2);\n        if(s[i].y1>s[i].y2)swap(s[i].y1,s[i].y2);\n        if(s[i].x1==s[i].x2){\n            v[++vtot]=s[i];\n        }else h[++htot]=s[i];\n    }\n    sort(h+1,h+1+htot,cmpy);\n\n    ll sum=0;\n    for (int i=1,j;i<=htot;i=j){\n        for (j=i;j<=htot && h[j].y1==h[i].y1;j++);\n\n        int far=-inf;\n        for (int k=i;k<j;k++){\n            if(h[k].x1>far){\n                if(far!=-inf)tt[++ttot]=(node){far+1,h[i].y1,-1};\n                tt[++ttot]=(node){h[k].x1,h[i].y1,+1};\n                far=max(far,h[k].x2);\n            }else{\n                far=max(far,h[k].x2);\n            }\n        }\n        tt[++ttot]=(node){far+1,h[i].y1,-1};\n    }\n    for (int i=1;i<=ttot;i++)sum-=tt[i].x*tt[i].sg;\n\n    sort(tt+1,tt+1+ttot,cmpnode);\n\n    sort(v+1,v+1+vtot,cmpx);\n\n    for (int i=1,j;i<=vtot;i=j){\n        for (j=i;j<=vtot && v[j].x1==v[i].x1;j++);\n\n        int far=-inf,st=-inf;\n        for (int k=i;k<j;k++){\n            if(v[k].y1>far){\n                if(far!=-inf)vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n                st=v[k].y1;\n                far=max(far,v[k].y2);\n            }else{\n                far=max(far,v[k].y2);\n            }\n        }\n        vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n    }\n\n    sort(vn+1,vn+1+ntot,cmpx);\n\n    int cur=1;\n    for (int i=1;i<=ntot;i++){\n        while(cur<=ttot && tt[cur].x<=vn[i].x1){\n            if(tt[cur].sg==1){\n                ins(root,tt[cur].y);\n            }else{\n                del_num(root,tt[cur].y);\n            }\n            cur++;\n        }\n        int coin = rk(vn[i].y2+1)-rk(vn[i].y1);\n        sum+=vn[i].y2-vn[i].y1+1 - coin;\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n""]","['constructive algorithms', 'data structures', 'geometry', 'two pointers']",2300
https://codeforces.com//contest/1786/problem/A2,A2. Alternating Deck  hard version ,Alice has n cards each card is either black or white The cards are stacked in a deck in such a way that the card colors alternate starting from a white card Alice deals the cards to herself and to Bob dealing at once several cards from the top of the deck in the following order one card to herself two cards to Bob three cards to Bob four cards to herself five cards to herself six cards to Bob seven cards to Bob eight cards to herself and so on In other words on the i th step Alice deals i top cards from the deck to one of the players on the first step she deals the cards to herself and then alternates the players every two steps When there aren t enough cards at some step Alice deals all the remaining cards to the current player and the process stops How many cards of each color will Alice and Bob have at the end ,"[""// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, m;\nint a[N];\nint c[2][2];\n\nvoid solve() {\n\tqread(n);\n\trep(i, 0, 1) rep(j, 0, 1) c[i][j] = 0;\n\tc[0][1] = 1;\n\tint nw = 2, cc = 2, f = 1;\n\twhile(nw <= n) {\n\t\tint to = min(nw + cc - 1, n);\n\t\trep(i, nw, to) ++c[f][i & 1];\n\t\t++cc;\n\t\tnw = to + 1;\n\t\tto = min(nw + cc - 1, n);\n\t\trep(i, nw, to) ++c[f][i & 1];\n\t\t++cc;\n\t\tnw = to + 1; f ^= 1;\n\t}\n\tcout << c[0][1] << ' ' << c[0][0] << ' ' << c[1][1] << ' ' << c[1][0] << '\\n';\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n""]",['implementation'],800
https://codeforces.com//contest/992/problem/A,A. Nastya and an Array,Nastya owns too many arrays now so she wants to delete the least important of them However she discovered that this array is magic Nastya now knows that the array has the following properties In one second we can add an arbitrary possibly negative integer to all elements of the array that are not equal to zero When all elements of the array become equal to zero the array explodes Nastya is always busy so she wants to explode the array as fast as possible Compute the minimum time in which the array can be exploded ,['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tint n;\n\tcin >> n;\n\tset<int> s;\n\twhile (n--) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (x)\n\t\t\ts.insert(x);\n\t}\n\tcout << s.size();\n}'],"['implementation', 'sortings']",800
https://codeforces.com//contest/747/problem/B,B. Mammoth s Genome Decoding,The process of mammoth s genome decoding in Berland comes to its end One of the few remaining tasks is to restore unrecognized nucleotides in a found chain Each nucleotide is coded with a capital letter of English alphabet or Unrecognized nucleotides are coded by a question mark Thus is a string consisting of letters and characters It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define ff first\n#define ss second\nusing namespace std;\nconst int N=200005;\nconst int inf=1e9+7;\ntypedef long long ll;\ntypedef long double lb;\ninline void read(int &x){x=0; char ch=getchar();while(ch<\'0\') ch=getchar();while(ch>=\'0\'){x=x*10+ch-48; ch=getchar();}}\n//------------------------------------------head---------------------------------------------------//\nint cnt[5];\nchar s[N];\nint main()\n{\n\tint n; scanf(""%d"",&n);\n\tif(n%4!=0)return puts(""===""),0;\n\tscanf(""%s"",s); cnt[0]=cnt[1]=cnt[2]=cnt[3]=n/4;\n\trep(i,0,n-1)\n\t{\n\t\tif(s[i]==\'A\') --cnt[0];\n\t\telse if(s[i]==\'C\') --cnt[1];\n\t\telse if(s[i]==\'G\') --cnt[2];\n\t\telse if(s[i]==\'T\') --cnt[3];\n\t}\n\tif(cnt[0]<0 || cnt[1]<0 || cnt[2]<0 || cnt[3]<0) return puts(""===""),0;\n\trep(i,0,n-1)\n\t{\n\t\tif(s[i]==\'?\')\n\t\t{\n\t\t\tif(cnt[0])\n\t\t\t{\n\t\t\t\t--cnt[0];\n\t\t\t\ts[i]=\'A\';\n\t\t\t}\n\t\t\telse if(cnt[1])\n\t\t\t{\n\t\t\t\t--cnt[1];\n\t\t\t\ts[i]=\'C\';\n\t\t\t}\n\t\t\telse if(cnt[2])\n\t\t\t{\n\t\t\t\t--cnt[2];\n\t\t\t\ts[i]=\'G\';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--cnt[3];\n\t\t\t\ts[i]=\'T\';\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%s\\n"",s);\n\treturn 0;\n}']","['implementation', 'strings']",900
https://codeforces.com//contest/521/problem/C,C. Pluses everywhere,Vasya is sitting on an extremely boring math class To have fun he took a piece of paper and wrote out numbers on a single line After that Vasya began to write out different ways to put pluses in the line between certain digits in the line so that the result was a correct arithmetic expression formally no two pluses in such a partition can stand together between any two adjacent pluses there must be at least one digit and no plus can stand at the beginning or the end of a line For example in the string ways add no pluses or are correct and ways or are incorrect The lesson was long and Vasya has written all the correct ways to place exactly pluses in a string of digits At this point he got caught having fun by a teacher and he was given the task to calculate the sum of all the resulting arithmetic expressions by the end of the lesson when calculating the value of an expression the leading zeros should be ignored As the answer can be large Vasya is allowed to get only its remainder modulo Help him ,"['#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint mo=1e9+7,nI[110000],I[110000],n,m;\nchar ch[110000];\nint quick(int k1,int k2){\n    int k3=1;\n    while (k2){\n        if (k2&1) k3=1ll*k3*k1%mo; k1=1ll*k1*k1%mo; k2>>=1;\n    }\n    return k3;\n}\nint C(int k1,int k2){\n    if (k2>k1) return 0;\n    return 1ll*I[k1]*nI[k2]%mo*nI[k1-k2]%mo;\n}\nint main(){\n    scanf(""%d%d"",&n,&m); scanf(""%s"",ch+1);\n    if (m==0){\n        int ans=0;\n        for (int i=1;i<=n;i++) ans=(1ll*ans*10+ch[i]-\'0\')%mo;\n        cout<<ans<<endl; return 0;\n    }\n    for (int i=1;i<=n;i++) nI[i]=quick(i,mo-2); nI[0]=1;\n    for (int i=1;i<=n;i++) nI[i]=1ll*nI[i]*nI[i-1]%mo;\n    I[0]=1; for (int i=1;i<=n;i++) I[i]=1ll*I[i-1]*i%mo;\n    int ans=0,num=0,pre=1;\n    for (int i=n;i;i--){\n        int k1=(num+1ll*pre*C(i-1,m))%mo;\n        ans=(ans+1ll*k1*(ch[i]-\'0\'))%mo;\n        num=(num+1ll*pre*C(i-2,m-1))%mo; pre=1ll*pre*10%mo;\n    }\n    cout<<ans<<endl;\n    return 0;\n}']","['combinatorics', 'dp', 'math', 'number theory']",2200
https://codeforces.com//contest/1181/problem/D,D. Irrigation,Misha was interested in water delivery from childhood That s why his mother sent him to the annual Innovative Olympiad in Irrigation IOI Pupils from all Berland compete there demonstrating their skills in watering It is extremely expensive to host such an olympiad so after the first n olympiads the organizers introduced the following rule of the host city selection The host cities of the olympiads are selected in the following way There are m cities in Berland wishing to host the olympiad they are numbered from 1 to m The host city of each next olympiad is determined as the city that hosted the olympiad the number of times before If there are several such cities the city with the index is selected among them Misha s mother is interested where the olympiad will be held in some specific years The only information she knows is the above selection rule and the host cities of the first n olympiads Help her and if you succeed she will ask Misha to avoid flooding your house ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=5e5;\nint n, m, q, c[mxN];\nset<int> s;\nar<ll, 2> a[2*mxN];\nvector<int> tr[mxN+1];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> m >> q;\n\tfor(int i=0, a; i<n; ++i)\n\t\tcin >> a, ++c[a-1];\n\tfor(int i=0; i<m; ++i) {\n\t\tif(c[i])\n\t\t\ts.insert(i);\n\t\ttr[c[i]].push_back(i);\n\t}\n\ts.insert(m);\n\tint jj=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tint la=-1;\n\t\tauto it=s.begin();\n\t\twhile(it!=s.end()) {\n\t\t\tif(*it-la-1)\n\t\t\t\ta[jj++]={*it-la-1, la+1};\n\t\t\tla=*it;\n\t\t\t++it;\n\t\t}\n\t\tfor(int u : tr[i])\n\t\t\ts.erase(u);\n\t}\n\tfor(int i=1; i<jj; ++i)\n\t\ta[i][0]+=a[i-1][0];\n\twhile(q--) {\n\t\tll k;\n\t\tcin >> k, k-=n+1;\n\t\tif(k>=a[jj-1][0]) {\n\t\t\tk-=a[jj-1][0];\n\t\t\tcout << k%m+1 << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tint p=lower_bound(a, a+jj, ar<ll, 2>{k, m})-a;\n\t\tll ss=p?a[p-1][0]:0;\n\t\tcout << k-ss+a[p][1]+1 << ""\\n"";\n\t}\n}']","['binary search', 'data structures', 'implementation', 'sortings', 'trees', 'two pointers']",2200
https://codeforces.com//contest/167/problem/D,D. Wizards and Roads,In some country live wizards They love to build cities and roads The country used to have cities the th city was located at a point It was decided to create another cities And the th one was created at a point with coordinates Here are primes Also After the construction of all cities the wizards have noticed something surprising It turned out that for every two different cities and and holds The cities are built it s time to build roads It was decided to use the most difficult and of course the most powerful spell for the construction of roads Using this spell creates a road between the towns of if and only if for any city which lies strictly inside the corner at the point see below there is a city that does not lie in the corner which is located along the coordinate strictly between and and simultaneously A on the points is the set of points for which at least one of the two conditions is fulfilled and and In order to test the spell the wizards will apply it to all the cities that lie on the coordinate in the interval After the construction of roads the national government wants to choose the maximum number of pairs of cities connected by the road so that no city occurs in two or more pairs Your task is for each offered variants of values to calculate the maximum number of such pairs after the construction of the roads Please note that the cities that do not lie in the interval on the coordinate do not affect the construction of roads in any way ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#ifdef ONLINE_JUDGE\n\n#define fin cin\n#define fout cout\n\n#else\n\nfstream fin(""input.txt"", fstream::in);\nfstream fout(""output.txt"", fstream::out);\n\n#endif\n\nstruct TCartNode {\n\tint x, y;\n\tint w;\n\tTCartNode *left, *right;\n\tint used, nused;\n\n\tTCartNode(int _x, int _y);\n};\n\nTCartNode *null;\n\nTCartNode::TCartNode(int _x, int _y)\n\t: x(_x)\n\t, y(_y)\n\t, w(1)\n\t, left(null)\n\t, right(null)\n\t, used(0)\n\t, nused(0)\n{\n}\n\nvoid relax(TCartNode *node) {\n\tif (node == null) {\n\t\treturn;\n\t}\n\n\tnode->w = 1 + node->left->w + node->right->w;\n\tnode->used = node->left->nused + node->right->nused;\n\tnode->nused = max(node->used, 1 + max(node->left->used + node->right->nused, node->left->nused + node->right->used));\n}\n\nvoid split(TCartNode *node, int x, TCartNode **left, TCartNode **right) {\n\tif (node == null) {\n\t\t*left = *right = null;\n\t\treturn;\n\t}\n\n\tif (node->x > x) {\n\t\tsplit(node->left, x, left, right);\n\t\tnode->left = *right;\n\t\t*right = node;\n\t} else {\n\t\tsplit(node->right, x, left, right);\n\t\tnode->right = *left;\n\t\t*left = node;\n\t}\n\trelax(node);\n}\n\nTCartNode *merge(TCartNode *left, TCartNode *right) {\n\tif (left == null) {\n\t\treturn right;\n\t}\n\tif (right == null) {\n\t\treturn left;\n\t}\n\n\tif (left->y > right->y) {\n\t\tleft->right = merge(left->right, right);\n\t\trelax(left);\n\t\treturn left;\n\t} else {\n\t\tright->left = merge(left, right->left);\n\t\trelax(right);\n\t\treturn right;\n\t}\n}\n\nTCartNode *insert(TCartNode\t*root, TCartNode *node) {\n\tTCartNode *left, *right;\n\tsplit(root, node->x, &left, &right);\n\treturn merge(left, merge(node, right));\n}\n\nconst long long P = 1000000000 + 9;\n\nint main() {\n\tfout.precision(10);\n\tfout << fixed;\n\n\tnull = new TCartNode(0, 0);\n\tnull->w = 0;\n\tnull->left = null->right = null;\n\tnull->used = -1;\n\tnull->nused = 0;\n\n\tint N, K;\n\tfin >> N >> K;\n\tlong long x, y;\n\tlong long a, b, c, d;\n\n\tvector<TCartNode *> nodes(N);\n\tTCartNode *root = null;\n\n\tfor (int i = 0; i < K; ++i) {\n\t\tfin >> x >> y;\n\t\tnodes[i] = new TCartNode(x, y);\n\t\troot = insert(root, nodes[i]);\n\t}\n\t\n\tfin >> a >> b >> c >> d;\n\tfor (int i = K; i < N; ++i) {\n\t\tx = (a * x + b) % P;\n\t\ty = (c * y + d) % P;\n\t\tnodes[i] = new TCartNode(x, y);\n\t\troot = insert(root, nodes[i]);\n\t}\n\n\tint M;\n\tfin >> M;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint l, r;\n\t\tfin >> l >> r;\n\t\tTCartNode *left, *middle, *right;\n\t\tsplit(root, l - 1, &left, &middle);\n\t\tsplit(middle, r, &middle, &right);\n\t\tfout << middle->nused << \'\\n\';\n\t\troot = merge(left, merge(middle, right));\n\t}\n\n\treturn 0;\n}\n']","['data structures', 'divide and conquer', 'graph matchings', 'graphs', 'greedy']",3000
https://codeforces.com//contest/696/problem/E,E. ...Wait for it...,Barney is searching for his dream girl He lives in NYC NYC has junctions numbered from to and roads connecting them We will consider the NYC as a rooted tree with root being junction girls live in NYC th of them lives along junction and her weight initially equals pounds Barney consider a girl to be than a girl if and only if girl has weight strictly less than girl or girl and girl have equal weights and index of girl living junction index is strictly less than girl living junction index i e Thus for any two girls one of them is always better than another one For the next days one event happens each day There are two types of events Barney goes from junction to junction As a result he picks at most from junctions on his way and invites them to his house to test if one of them is his dream girl If there are less than not invited girls on his path he invites all of them Girls living along junctions in subtree of junction including itself put on some weight As result their weights increase by pounds Your task is for each event of first type tell Barney the indices of girls he will invite to his home in this event ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nconst ll inf=1ll<<60;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n \nconst int N=201000;\nint q[N],hs[N],hv[N],dep[N],id[N],l[N],r[N],bel[N],s[N],f[N],pos[N],vl[N];\nint n,m,Q,tot,u,v,k,ty;\nVI e[N],vec[N],ret;\npair<ll,PII> ind[N],z;\nstruct node {\n\tll fg;\n\tpair<ll,PII> s;\n}nd[4*N];\nvoid upd(int p) {\n\tnd[p].s=min(nd[p+p].s,nd[p+p+1].s);\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v; nd[p].s.fi+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t\tnd[p].s=ind[l];\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\npair<ll,PII> query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return min(query(p+p,l,md,tl,md),query(p+p+1,md+1,r,md+1,tr));\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n \nvoid dfs(int u,int f) {\n\tid[l[u]=++tot]=u; ind[tot]=mp(inf,mp(0,0));\n\tfor (auto v:vec[u]) {\n\t\tind[++tot]=mp(v,mp(u,v));\n\t\tpos[v]=tot;\n\t}\n\tvl[u]=tot;\n\tdep[u]=dep[f]+1;\n\tif (hv[u]) dfs(hv[u],u);\n\trep(j,0,SZ(e[u])) if (e[u][j]!=f&&e[u][j]!=hv[u])\n\t\tdfs(e[u][j],u);\n\tr[u]=tot;\n}\nvoid HLDoT(int rt) {\n\tint t=1;\n\tq[0]=rt;\n\trep(i,0,n) {\n\t\tint u=q[i];\n\t\trep(j,0,SZ(e[u])) if (e[u][j]!=f[u])\n\t\t\tf[e[u][j]]=u,dep[q[t++]=e[u][j]]=dep[u]+1;\n\t}\n\tper(i,0,n) {\n\t\tint u=q[i],p=f[u];\n\t\ts[u]++,s[p]+=s[u];\n\t\tif (!l[u]) l[u]=1;\n\t\tif (hs[p]<s[u]) hs[p]=s[u],hv[p]=u,l[p]=l[u]+1;\n\t}\n\trep(i,0,n) {\n\t\tint u=q[i];\n\t\tif (!bel[u]) bel[u]=u;\n\t\tif (hv[u]) bel[hv[u]]=bel[u];\n\t}\n\tdfs(rt,0);\n}\nvoid query(int u,int v) {\n\twhile (1) {\n\t\tif (bel[u]==bel[v]) {\n\t\t\tif (dep[u]<dep[v]) swap(u,v);\n\t\t\tz=min(z,query(1,1,m,l[v],vl[u]));\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (dep[bel[u]]<dep[bel[v]]) swap(u,v);\n\t\t\tz=min(z,query(1,1,m,l[bel[u]],vl[u]));\n\t\t\tu=f[bel[u]];\n\t\t}\n\t}\n}\n \nint main() {\n\tscanf(""%d%d%d"",&n,&m,&Q);\n\trep(i,1,n) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\trep(i,0,m) {\n\t\tscanf(""%d"",&u);\n\t\tvec[u].pb(i+1);\n\t}\n\tHLDoT(1);\n\tm=tot;\n\tbuild(1,1,m);\n\trep(i,0,Q) {\n\t\tscanf(""%d"",&ty);\n\t\tif (ty==1) {\n\t\t\tscanf(""%d%d%d"",&u,&v,&k);\n\t\t\tret.clear();\n\t\t\twhile (k>0) {\n\t\t\t\tz=mp(inf,mp(0,0));\n\t\t\t\tquery(u,v);\n\t\t\t\tif (z.fi>=1ll<<50) break;\n\t\t\t\t--k;\n\t\t\t\tret.pb(z.se.se);\n\t\t\t\tmodify(1,1,m,pos[z.se.se],pos[z.se.se],inf);\n\t\t\t}\n\t\t\tprintf(""%d"",SZ(ret));\n\t\t\tfor (auto u:ret) printf("" %d"",u);\n\t\t\tputs("""");\n\t\t} else {\n\t\t\tscanf(""%d%d"",&u,&k);\n\t\t\tmodify(1,1,m,l[u],r[u],k);\n\t\t}\n\t}\n}']","['data structures', 'dsu', 'trees']",3000
https://codeforces.com//contest/1670/problem/F,"F. Jee, You See ",You are given 4 integers n l r and z Count the number of arrays a of length n containing non negative integers such that l le a 1 a 2 ldots a n le r and a 1 oplus a 2 oplus ldots oplus a n z where oplus denotes the bitwise XOR operation Since the answer can be large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint C[1005][1005],dp[70][1005][2],n,z;\ninline int cal(int x)\n{\n\tmemset(dp,0,sizeof dp);\n\tdp[0][0][1]=1;\n\tfor(int i=1;i<=61;i++)\n\t{\n\t\tint X=(x>>i-1)&1;\n\t\tfor(int j=0;j<=1000;j++)\n\t\t{\n\t\t\tif(!dp[i-1][j][0]&&!dp[i-1][j][1]) continue;\n\t\t\tfor(int k=(z>>i-1)%2;k<=1000;k+=2)\n\t\t\t{\n\t\t\t\tint nw=j+k;\n\t\t\t\tif(nw&1)\n\t\t\t\t{\n\t\t\t\t\tif(X==0)\n\t\t\t\t\t\tdp[i][nw/2][0]=((dp[i-1][j][0]+dp[i-1][j][1])*C[n][k]+dp[i][nw/2][0])%mod;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][nw/2][1]=(C[n][k]*dp[i-1][j][1]+dp[i][nw/2][1])%mod;\n\t\t\t\t\t\tdp[i][nw/2][0]=(C[n][k]*dp[i-1][j][0]+dp[i][nw/2][0])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(X==1)\n\t\t\t\t\t\tdp[i][nw/2][1]=((dp[i-1][j][0]+dp[i-1][j][1])*C[n][k]+dp[i][nw/2][1])%mod;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][nw/2][1]=(C[n][k]*dp[i-1][j][1]+dp[i][nw/2][1])%mod;\n\t\t\t\t\t\tdp[i][nw/2][0]=(C[n][k]*dp[i-1][j][0]+dp[i][nw/2][0])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[61][0][1];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor(int i=0;i<=1000;i++)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=0;j<i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint l,r;\n\tcin >> n >> l >> r >> z;\n\tcout << ((cal(r)-cal(l-1)+mod)%mod+mod)%mod ;\n\treturn 0;\n}']","['bitmasks', 'combinatorics', 'dp']",2400
https://codeforces.com//contest/1038/problem/A,A. Equality,You are given a string s of length n which consists only of the first k letters of the Latin alphabet All letters in string s are uppercase A of string s is a string that can be derived from s by deleting some of its symbols without changing the order of the remaining symbols For example and are subsequences of but is not A subsequence of s called if the number of occurences of each of the first k letters of the alphabet is the same Find the length of the longest good subsequence of s ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(""%lld"", &x); return x;}\nvoid read(char *s){scanf(""%s"", s);}\nvoid no(){printf(""NO""); exit(0);}\n\n#define maxn 120000\n#define maxm\n\nchar s[maxn];\nint c[maxn];\nint main(){\n\tint n = read(), k = read(), ans = n + 1;\n\tread(s);\n\tfor(int i = 0; i < n; i += 1) c[s[i] - \'A\'] += 1;\n\tfor(int i = 0; i < k; i += 1) ans = min(ans, c[i]);\n\tprintf(""%d"", ans * k);\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/1582/problem/D,"D. Vupsen, Pupsen and 0",Vupsen and Pupsen were gifted an integer array Since Vupsen doesn t like the number 0 he threw away all numbers equal to 0 from the array As a result he got an array a of length n Pupsen on the contrary likes the number 0 and he got upset when he saw the array without zeroes To cheer Pupsen up Vupsen decided to come up with another array b of length n such that sum i 1 n a i cdot b i 0 Since Vupsen doesn t like number 0 Also the numbers in that array must not be huge so Please help Vupsen to find any such array b ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve(int a, int b, int c, int& x, int &y, int &z) {\n\tif (a == b) {\n\t\tx = c; y = -2 * c;\n\t\tz = a;\n\t\treturn;\n\t}\n\tif (a + b == 0) {\n\t\tx = c; y = 2 * c;\n\t\tz = a;\n\t\treturn;\n\t}\n\tif (b + c == 0 || b == c || c + a == 0 || c == a) {\n\t\tsolve(b, c, a, y, z, x);\n\t\treturn;\n\t}\n\tx = b + c;\n\ty = -(a + c);\n\tz = b - a;\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""d.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> r(n);\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\t\tr[i + 1] = -a[i];\n\t\t\t\tr[i] = a[i + 1];\n\t\t\t}\n\t\t} else {\n\t\t\tsolve(a[0], a[1], a[2], r[0], r[1], r[2]);\n\t\t\tfor (int i = 3; i < n; i += 2) {\n\t\t\t\tr[i + 1] = -a[i];\n\t\t\t\tr[i] = a[i + 1];\n\t\t\t}\n\t\t}\n\t\tlong long s = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tassert(r[i]);\n\t\t\ts += (long long)a[i] * r[i];\n\t\t}\n\t\tassert(s == 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tprintf(""%d "", r[i]);\n\t\t}\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'math']",1600
https://codeforces.com//contest/811/problem/A,A. Vladik and Courtesy,At regular competition Vladik and Valera won and candies respectively Vladik offered his candy to Valera After that Valera gave Vladik his candies so that no one thought that he was less generous Vladik for same reason gave candies to Valera in next turn More formally the guys take turns giving each other one candy more than they received in the previous turn This continued until the moment when one of them couldn t give the right amount of candy Candies which guys got from each other they You need to know who is the first who can t give the right amount of candy ,"['#include<bits/stdc++.h>\n#define rep(i,j,k) for((i)=(j);(i)<=(k);++i)\n#define per(i,j,k) for((i)=(j);(i)>=(k);--i)\nusing namespace std;\ntypedef long long ll;\ninline void cmin(int &x,int y){if(y<x)x=y;}\ninline void cmax(int &x,int y){if(y>x)x=y;}\nint inline read(){\n\tchar ch=getchar();int z=0,f=1;\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){z=z*10+ch-\'0\';ch=getchar();}\n\treturn z*f;\n}\nint main(){\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint n,m,i;\n\tn = read(); m = read();\n\trep(i,1,1000000000){\n\t\tif(i & 1){\n\t\t\tn -= i;\n\t\t\tif(n < 0){puts(""Vladik""); return 0;}\n\t\t}else{\n\t\t\tm -= i;\n\t\t\tif(m < 0){puts(""Valera""); return 0;}\n\t\t}\n\t}\n\treturn 0;\n}\n']","['brute force', 'implementation']",800
https://codeforces.com//contest/581/problem/F,F. Zublicanes and Mumocrates,It s election time in Berland The favorites are of course parties of zublicanes and mumocrates The election campaigns of both parties include numerous demonstrations on main squares of the capital of Berland Each of the squares certainly can have demonstrations of only one party otherwise it could lead to riots On the other hand both parties have applied to host a huge number of demonstrations so that on all squares demonstrations must be held Now the capital management will distribute the area between the two parties Some pairs of squares are connected by bidirectional roads such that between any pair of squares there is a unique way to get from one square to another Some squares are on the outskirts of the capital meaning that they are connected by a road with only one other square such squares are called squares The mayor of the capital instructed to distribute all the squares between the parties so that the squares had the same number of demonstrations of the first and the second party It is guaranteed that the number of dead end squares of the city is even To prevent possible conflicts between the zublicanes and the mumocrates it was decided to minimize the number of roads connecting the squares with the distinct parties You as a developer of the department of distributing squares should determine this smallest number ,"[""#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint dp[5010][5010][2];\nstruct Bian\n{\n    int s,t,last;\n}bian[10010];\nint last[5010],maxbian=0,d[10010],v[10010],sz[10010];\nvoid addbian(int s,int t)\n{\n    maxbian++;\n    bian[maxbian].s=s;\n    bian[maxbian].t=t;\n    bian[maxbian].last=last[s];\n    last[s]=maxbian;\n    d[s]++;\n    d[t]++;\n}\nvoid dfs(int i)\n{\n    v[i]=1;\n    int f=0;\n    for(int j=0;j<=5000;j++)\n        dp[i][j][1]=dp[i][j][0]=inf;\n    for(int j=last[i];j;j=bian[j].last)\n        if(!v[bian[j].t])\n        {\n            f++;\n            if(f==1)\n            dp[i][0][0]=dp[i][0][1]=0;\n            dfs(bian[j].t);\n            for(int k=sz[i];k>=0;k--)\n                for(int l=sz[bian[j].t];l>=0;l--)\n                    if(k==sz[i]||l==0)\n                    {\n                        dp[i][k+l][0]=min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]);\n                        dp[i][k+l][1]=min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]);\n                    }\n                    else\n                    {\n                        dp[i][k+l][0]=min(dp[i][k+l][0],min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]));\n                        dp[i][k+l][1]=min(dp[i][k+l][1],min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]));\n                    }   \n            sz[i]+=sz[bian[j].t];\n        }\n    if(f==0)\n    {\n        dp[i][1][1]=dp[i][0][0]=0;\n        sz[i]=1;\n    }\n//  for(int j=0;j<=sz[i];j++)\n    //  for(int k=0;k<=1;k++)\n        //  cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n}\nint main()\n{\n    int n,n1,t1,t2;\n    cin>>n;\n    if(n==2)\n    {\n        cout<<1;\n        return 0;\n    }\n    for(n1=1;n1<n;n1++)\n    {\n        cin>>t1>>t2;\n        addbian(t1,t2);\n        addbian(t2,t1);\n    }\n    int f=0;\n    for(n1=1;n1<=n;n1++)\n    {\n        if(d[n1]==2)\n            f++;\n    }\n    for(n1=1;n1<=n;n1++)\n        if(d[n1]>2)\n        {\n            dfs(n1);\n            cout<<min(dp[n1][f/2][0],dp[n1][f/2][1]);\n            return 0;\n        }\n}\n""]","['dp', 'trees', 'two pointers']",2400
https://codeforces.com//contest/1882/problem/E1,E1. Two Permutations  Easy Version ,You have two permutations dagger p 1 p 2 ldots p n of integers 1 to n and q 1 q 2 ldots q m of integers 1 to m Initially p i a i for i 1 2 ldots n and q j b j for j 1 2 ldots m You can apply the following operation on the permutations several possibly zero times In one operation p and q will change according to the following three steps You choose integers i j which satisfy 1 le i le n and 1 le j le m Permutation p is partitioned into three parts using p i as a pivot the left part is formed by elements p 1 p 2 ldots p i 1 this part may be empty the middle part is the single element p i and the right part is p i 1 p i 2 ldots p n this part may be empty To proceed swap the left and the right parts of this partition Formally after this step p will become p i 1 p i 2 ldots p n p i p 1 p 2 ldots p i 1 The elements of the newly formed p will be reindexed starting from 1 Perform the same transformation on q with index j Formally after this step q will become q j 1 q j 2 ldots q m q j q 1 q 2 ldots q j 1 The elements of the newly formed q will be reindexed starting from 1 Your goal is to simultaneously make p i i for i 1 2 ldots n and q j j for j 1 2 ldots m Find any valid way to achieve the goal using at most 10 000 operations or say that none exists Please note that you minimize the number of operations It can be proved that if it is possible to achieve the goal then there exists a way to do so using at most 10 000 operations dagger A permutation of length k is an array consisting of k distinct integers from 1 to k in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation k 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T;\nint a[maxn],b[maxn],c[maxn],d[maxn];\nvector<int>ans[2];\nvector< pair<int,int> >res;\nvoid opt(int n,int p,int o){\n\tint ds=0;\n\tans[o].emplace_back(p);\n\tfor(int i=p+1;i<=n;i++)\n\t\td[++ds]=c[i];\n\td[++ds]=c[p];\n\tfor(int i=1;i<=p-1;i++)\n\t\td[++ds]=c[i];\n\tfor(int i=1;i<=n;i++)\n\t\tc[i]=d[i];\n}\nvoid solve(int n,int o){\n//\tfor(int i=1;i<=n;i++)\n//\t\tprintf(""%d%c"",c[i],i==n? \'\\n\':\' \');\n\tfor(int p=n;p>=1;p--){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(c[i]==p){\n\t\t\t\topt(n,i,o);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(c[i]==p){\n\t\t\t\tif(i>1)\n\t\t\t\t\topt(n,i-1,o);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++)\n//\t\tprintf(""%d%c"",c[i],i==n? \'\\n\':\' \');\n//\tfor(int i=0;i<ans[o].size();i++)\n//\t\tprintf(""%d%c"",ans[o][i],i==ans[o].size()-1? \'\\n\':\' \');\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(""%d"",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(""%d"",&b[i]);\n\tmemcpy(c,a,sizeof(c)),solve(n,0),memcpy(c,b,sizeof(c)),solve(m,1);\n\tif((ans[0].size()&1)!=(ans[1].size()&1)&&(n&1)==1)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[0].emplace_back(1);\n\tif((ans[0].size()&1)!=(ans[1].size()&1)&&(m&1)==1)\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tans[1].emplace_back(1);\n\tif((ans[0].size()&1)!=(ans[1].size()&1)){\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\tres.resize(max(ans[0].size(),ans[1].size()));\n\tfor(int i=0,p=0,q=0;i<res.size();i++){\n\t\tint u,v;\n\t\tif(i<ans[0].size())\n\t\t\tu=ans[0][i];\n\t\telse u=p==0? 1:n,p^=1;\n\t\tif(i<ans[1].size())\n\t\t\tv=ans[1][i];\n\t\telse v=q==0? 1:m,q^=1;\n\t\tres[i]=make_pair(u,v);\n\t}\n\tprintf(""%d\\n"",res.size());\n\tfor(int i=0;i<res.size();i++)\n\t\tprintf(""%d %d\\n"",res[i].first,res[i].second);\n\t/*memcpy(c,a,sizeof(c));\n\tfor(int i=0;i<res.size();i++)\n\t\topt(n,res[i].first,0);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(""%d%c"",c[i],i==n? \'\\n\':\' \'),assert(c[i]==i);\n\tmemcpy(c,b,sizeof(c));\n\tfor(int i=0;i<res.size();i++)\n\t\topt(m,res[i].second,1);\n\tfor(int i=1;i<=m;i++)\n\t\tprintf(""%d%c"",c[i],i==m? \'\\n\':\' \'),assert(c[i]==i);*/\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'number theory']",2400
https://codeforces.com//contest/1936/problem/B,B. Pinball,There is a one dimensional grid of length n The i th cell of the grid contains a character s i which is either or When a pinball is placed on one of the cells it moves according to the following rules If the pinball is on the i th cell and s i is the pinball moves one cell to the left in the next second If s i is it moves one cell to the right After the pinball has moved the character s i is inverted i e if s i used to be it becomes and vice versa The pinball stops moving when it leaves the grid either from the left border or from the right one You need to answer n queries In the i th query a pinball will be placed on the i th cell Note that we always place a pinball on the initial grid For each query calculate how many seconds it takes the pinball to leave the grid It can be shown that the pinball will always leave the grid within a finite number of steps ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nvector<pll> lew, pra;\n\nll wyn[nax];\n\nll suma(vector<pll> &wek, int ile)\n{\n\tint r=wek.size();\n\treturn wek.back().second-wek[r-ile-1].second;\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tlew.clear();\n\tpra.clear();\n\tlew.push_back({0, 0});\n\tpra.push_back({n+1, 0});\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (wcz[i]==\'<\')\n\t\t{\n\t\t\tll x=i+pra.back().second;\n\t\t\tpra.push_back({i, x});\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (pra.back().first==i)\n\t\t\tpra.pop_back();\n\t\tint l=(int)lew.size()-1;\n\t\tint p=(int)pra.size()-1;\n\t\tif (wcz[i]==\'<\')\n\t\t{\n\t\t\tif (l<=p)\n\t\t\t{\n\t\t\t\twyn[i]=i+suma(pra, l)*2-suma(lew, l)*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn[i]=n+1+i+suma(pra, p)*2-suma(lew, p+1)*2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l>=p)\n\t\t\t{\n\t\t\t\twyn[i]=n+1-i+suma(pra, p)*2-suma(lew, p)*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn[i]=-i+suma(pra, l+1)*2-suma(lew, l)*2;\n\t\t\t}\n\t\t}\n\t\tif (wcz[i]==\'>\')\n\t\t{\n\t\t\tll x=i+lew.back().second;\n\t\t\tlew.push_back({i, x});\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%lld "", wyn[i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['binary search', 'data structures', 'implementation', 'math', 'two pointers']",2000
https://codeforces.com//contest/1758/problem/C,C. Almost All Multiples,Given two integers n and x a permutation dagger p of length n is called if p i is a multiple of i for all 1 leq i leq n 1 p n 1 and p 1 x Find the lexicographically minimal ddagger funny permutation or report that no such permutation exists dagger A permutation of length n is an array consisting of each of the integers from 1 to n exactly once ddagger Let a and b be permutations of length n Then a is lexicographically smaller than b if in the first position i where a and b differ a i b i A permutation is lexicographically minimal if it is lexicographically smaller than all other permutations ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=998244353;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n,a[N];\nV input(){\n\tint x;\n\tn = getint(), x = getint();\n\ta[1] = x, a[n] = 1;\n\tif(n%x!=0)\n\t\treturn void(cout<<""-1\\n"");\n\tFOR(i,2,n-1)a[i] = i;\n\t// x 放 n -> x 放最小的 n 的约数\n\tint p = 2;\n\twhile(x!=n){\n\t\tint d= n/x;\n\t\twhile(d%p!=0)p++;\n\t\ta[x] = x *p, x*=p;\n\t}\n\tFOR(i,1,n)cout<<a[i]<<"" \\n""[i==n];\n\n\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n']","['greedy', 'number theory']",1400
https://codeforces.com//contest/1201/problem/B,B. Zero Array,You are given an array a 1 a 2 ldots a n In one operation you can choose two elements a i and a j i ne j and decrease each of them by one You need to check whether it is possible to make all the elements equal to zero or not ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nint a[maxn];\n\nint main() {\n    int n; scanf(""%d"", &n);\n    for (int i = 0; i < n; ++i) scanf(""%d"", &a[i]);\n    sort(a, a + n);\n\n    if (accumulate(a, a + n, 0ll) & 1) {\n        puts(""NO"");\n        return 0;\n    }\n\n    long long sum = 0;\n    for (int i = 0; i < n - 1; ++i) sum += a[i];\n    if (sum >= a[n - 1]) puts(""YES"");\n    else puts(""NO"");\n}\n\n']","['greedy', 'math']",1500
https://codeforces.com//contest/1388/problem/C,C. Uncle Bogdan and Country Happiness,There are n cities and n 1 undirected roads connecting pairs of cities Citizens of any city can reach any other city traveling by these roads Cities are numbered from 1 to n and the city 1 is a capital In other words the country has a tree structure There are m citizens living in the country A p i people live in the i th city but all of them are working in the capital At evening all citizens return to their home cities using the shortest paths Every person has its own mood somebody leaves his workplace in good mood but somebody are already in bad mood Moreover any person can ruin his mood on the way to the hometown Happiness detectors are installed in each city to monitor the happiness of person who visits the city The detector in the i th city calculates a happiness index h i as the number of people in good mood minus the number of people in bad mood Let s say for the simplicity that Happiness detector is still in development so there is a probability of a mistake in judging a person s happiness One late evening when all citizens successfully returned home the government asked uncle Bogdan the best programmer of the country to check the correctness of the collected happiness indexes Uncle Bogdan successfully solved the problem Can you do the same More formally ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 200000\n\nlong long h[N];\nlong long a[N];\nvector<long long>e[N];\nbool used[N];\nbool v;\n\nlong long dfs(long long k) {\n\tused[k] = true;\n\tlong long re = 0;\n\tlong long s = 0;\n\tlong long sz = e[k].size();\n\tf(i, sz) {\n\t\tif (!used[e[k][i]]) {\n\t\t\tre += dfs(e[k][i]);\n\t\t\ts += h[e[k][i]];\n\t\t}\n\t}\n\tre += a[k];\n    s-=a[k];\n\tif (s > h[k])v = false;\n\telse if (re < h[k])v = false;\n\telse if ((re - h[k]) % 2 != 0)v = false;\n\treturn re;\n}\n\n\nint main() {\n\n\tf(i, N) {\n\t\ta[i] = 0;\n\t\th[i] = 0;\n\t}\n\tlong long n, m,k, t;\n\tlong long x, y, z;\n\tlong long s, ans;\n\tans = 0;\n\tscanf(""%lld"", &t);\n\tf(tt, t) {\n\t\tscanf(""%lld %lld"", &n, &m);\n\t\tf(i, n) {\n\t\t\tscanf(""%lld"", &a[i]);\n\t\t}\n\t\tf(i, n) {\n\t\t\tscanf(""%lld"", &h[i]);\n\t\t}\n\t\tf(i, n-1) {\n\t\t\tscanf(""%lld %lld"", &x, &y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tv = true;\n\t\tf(i, n)used[i] = false;\n\t\tdfs(0);\n\t\tif (v)printf(""YES\\n"");\n\t\telse printf(""NO\\n"");\n\t\tf(i, n)e[i].clear();\n\t}\n\n\treturn 0;\n}']","['dfs and similar', 'greedy', 'math', 'trees']",1800
https://codeforces.com//contest/1248/problem/D1,D1. The World Is Just a Programming Task  Easy Version ,This is an easier version of the problem In this version n le 500 Vasya is an experienced developer of programming competitions problems As all great minds at some time Vasya faced a creative crisis To improve the situation Petya gifted him a string consisting of opening and closing brackets only Petya believes that the beauty of the bracket string is a number of its cyclical shifts which form a correct bracket sequence To digress from his problems Vasya decided to select two positions of the string and swap characters located at this positions with each other Vasya will apply this operation exactly once He is curious what is the maximum possible beauty he can achieve this way Please help him We remind that bracket sequence s is called correct if s is empty s is equal to t where t is correct bracket sequence s is equal to t 1 t 2 i e concatenation of t 1 and t 2 where t 1 and t 2 are correct bracket sequences For example are correct while and are not The cyclical shift of the string s of length n by k 0 leq k n is a string formed by a concatenation of the last k symbols of the string s with the first n k symbols of string s For example the cyclical shift of string by 2 equals Cyclical shifts i and j are considered different if i ne j ,"['// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast,no-stack-protector"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC optimize(""unroll-loops"")\n \n#include <bits/stdc++.h>\n \n#define debug(x) std::cerr << (#x) << "":\\t"" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n \ntypedef long long ll;\ntypedef long double ld;\n \nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n \nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 1 << 19;\n \nint n;\nchar str[N];\nint bal[N];\nint q[N];\n \nint getAns() {\n\tfor (int i = 0; i <= 3 * n; ++i) {\n\t\tbal[i] = 0;\n\t\tq[i] = 0;\n\t}\n \n\t// std::map<int, int> q;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tbal[i + 1] += bal[i];\n \n\t\tif (str[i] == \'(\') {\n\t\t\t++bal[i + 1];\n\t\t} else {\n\t\t\t--bal[i + 1];\n\t\t}\n\t}\n \n\tif (bal[0] != bal[n]) {\n\t\treturn 0;\n\t}\n \n\tfor (int i = 0; i < n; ++i) {\n\t\t++q[bal[i] + n];\n\t}\n \n \tfor (int i = 0; i < N; ++i) {\n \t\tif (q[i] != 0) {\n \t\t\treturn q[i];\n \t\t}\n \t}\n\n \tthrow 228;\n\t// return q.begin()->second;\n}\n \nint main(void) {\n\tscanf(""%d\\n%s"", &n, str);\n \n\tint ans = getAns();\n\tint fi = 0;\n\tint se = 0;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (str[i] != str[j]) {\n\t\t\t\tstd::swap(str[i], str[j]);\n \n\t\t\t\tint curAns = getAns();\n\t\t\t\tif (curAns > ans) {\n\t\t\t\t\tans = curAns;\n\t\t\t\t\tfi = i;\n\t\t\t\t\tse = j;\n\t\t\t\t}\n \n\t\t\t\tstd::swap(str[i], str[j]);\n\t\t\t}\n\t\t}\n\t}\t\n \n\tprintf(""%d\\n%d %d\\n"", ans, fi + 1, se + 1);\n \n\treturn 0;\n}']","['brute force', 'dp', 'greedy', 'implementation']",2000
https://codeforces.com//contest/797/problem/E,E. Array Queries,is an array of positive integers all of which are not greater than You have to process queries to this array Each query is represented by two numbers and Several operations are performed in each query each operation changes to There operations are applied until becomes greater than The answer to the query is the number of performed operations ,"[""// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e5 + 5, sq = 330, mod = (int) 0;\nint dp[sq + 2][N], a[N];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tfor (int j = 0; j < n; ++j)\n\t\tcin >> a[j];\n\tfor (int jump = 1; jump <= sq; ++jump) {\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tint nxt = j + a[j] + jump;\n\t\t\tif (nxt >= n) {\n\t\t\t\tdp[jump][j] = 1;\n\t\t\t} else {\n\t\t\t\tdp[jump][j] = dp[jump][nxt] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint res = 0, pos, k;\n\t\tcin >> pos >> k;\n\t\t--pos;\n\t\tif (k <= sq) {\n\t\t\tcout << dp[k][pos] << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\twhile (pos < n) {\n\t\t\t++res;\n\t\t\tpos = pos + a[pos] + k;\n\t\t}\n\t\tcout << res << '\\n';\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n""]","['brute force', 'data structures', 'dp']",2000
https://codeforces.com//contest/1447/problem/B,B. Numbers Box,You are given a rectangular grid with n rows and m columns The cell located on the i th row from the top and the j th column from the left has a value a ij written in it You can perform the following operation any number of times possibly zero Choose any two adjacent cells and multiply the values in them by 1 Two cells are called adjacent if they share a side Note that you can use a cell more than once in different operations You are interested in X the of all the numbers in the grid What is the maximum X you can achieve with these operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T,N,M;\nint a[110][110];\n\nint solve(vector<int> &v, int d) {\n    sort(v.begin(), v.end());\n    int N = v.size();\n    int max_delta = 0, S = 0;\n    if (d == 1) {\n        S = v[0];\n        max_delta = -2 * v[0];\n    }\n    for (int i=d;i<N;i+=2) {\n        S += v[i];\n        if (i == N - 1) continue;\n        S += v[i + 1];\n        max_delta = max(max_delta, -2 * S);\n    }\n    //printf(""%d %d\\n"",d,max_delta);\n    return S + max_delta;\n}\n\nint main() {\n    scanf(""%d"",&T);\n    while(T--) {\n        scanf(""%d%d"",&N,&M);\n        vector<int>v1,v2;\n        for (int i=1;i<=N;i++) {\n            for (int j=1;j<=M;j++) {\n                scanf(""%d"",&a[i][j]);\n                if ((i + j) % 2 == 1) {\n                    v1.push_back(a[i][j]);\n                } else {\n                    v2.push_back(a[i][j]);\n                }\n            }\n        }\n        printf(""%d\\n"", max(solve(v1, 0) + solve(v2, 0), solve(v1, 1) + solve(v2, 1)));\n    }\n}']","['greedy', 'math']",1000
https://codeforces.com//contest/487/problem/D,D. Conveyor Belts,Automatic Bakery of Cyberland ABC recently bought an rectangle table To serve the diners ABC placed seats around the table The size of each seat is equal to a unit square so there are seats in total ABC placed conveyor belts on each unit square on the table There are three types of conveyor belts and A belt can bring things upwards can bring leftwards and can bring rightwards Let s number the rows with to from top to bottom the columns with to from left to right We consider the seats above and below the top of the table are rows and respectively Also we define seats to the left of the table and to the right of the table to be column and Due to the conveyor belts direction restriction there are currently no way for a diner sitting in the row to be served Given the initial table there will be events in order There are two types of events A means a piece of bread will appear at row and column we will denote such position as The bread will follow the conveyor belt until arriving at a seat of a diner It is possible that the bread gets stuck in an infinite loop Your task is to simulate the process and output the final position of the bread or determine that there will be an infinite loop C means that the type of the conveyor belt at is changed to Queries are performed separately meaning that even if the bread got stuck in an infinite loop it won t affect further queries ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n\nconst int maxn=200000+5;\n\nint n,m,q;\nchar a[maxn][10];\nint tree[1<<20][10];\nint b[maxn][10];\n\nvoid solveb(int p)\n{\n\tfor (int i=0;i<m;i++) b[p][i]=-1;\n\tfor (int i=0;i<m && a[p][i]==\'<\';i++) b[p][i]=1;\n\tfor (int i=m-1;i>=0 && a[p][i]==\'>\';i--) b[p][i]=2;\n}\nvoid combine(int p)\n{\n\tfor (int i=0;i<m;i++) tree[p][i]=(tree[p*2+2][i]<0)?-1:tree[p*2+1][tree[p*2+2][i]];\n}\nvoid bruteforce(int p,int s)\n{\n\tfor (int i=0;i<m;i++) tree[p][i]=-1;\n\tfor (int i=0;i<m;i++) if (a[s][i]==\'^\') tree[p][i]=i;\n\tfor (int i=0;i+1<m;i++) if (tree[p][i]>=0 && a[s][i+1]==\'<\') tree[p][i+1]=tree[p][i];\n\tfor (int i=m-1;i>0;i--) if (tree[p][i]>=0 && a[s][i-1]==\'>\') tree[p][i-1]=tree[p][i];\n}\nvoid init(int p,int s,int t)\n{\n\tif (s==t)\n\t{\n\t\tbruteforce(p,s);\n\t\treturn;\n\t}\n\tint m=(s+t)/2;\n\tinit(p*2+1,s,m);\n\tinit(p*2+2,m+1,t);\n\tcombine(p);\n}\nvoid update(int p,int s,int t,int key)\n{\n\tif (s==t)\n\t{\n\t\tbruteforce(p,s);\n\t\treturn;\n\t}\n\tint m=(s+t)/2;\n\tif (key<=m)\n\t\tupdate(p*2+1,s,m,key);\n\telse\n\t\tupdate(p*2+2,m+1,t,key);\n\tcombine(p);\t\n}\n\nvoid solve(int p,int s,int t,int &x,int &y)\n{\n\tif (x==t && tree[p][y]>=0)\n\t{\n\t\tx=s-1;\n\t\ty=tree[p][y];\n\t\treturn;\n\t}\n\tif (s==t) return;\n\tint m=(s+t)/2;\n\tif (x>m) solve(p*2+2,m+1,t,x,y);\n\tif (x<=m) solve(p*2+1,s,m,x,y);\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""input.txt"",""r"",stdin);\n#endif\n\tscanf(""%d%d%d"",&n,&m,&q);\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tchar s[32];\n\t\tscanf(""%s"",s);\n\t\tfor (int j=0;j<m;j++) a[i][j]=s[j];\n\t}\n\tinit(0,0,n-1);\n\tfor (int i=0;i<n;i++) solveb(i);\n\tfor (;q>0;q--)\n\t{\n\t\tchar s[32];\n\t\tscanf(""%s"",s);\n\t\tif (s[0]==\'A\')\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(""%d%d"",&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tsolve(0,0,n-1,x,y);\n\t\t\tif (x>=0)\n\t\t\t\tif (b[x][y]>0)\n\t\t\t\t\ty=((b[x][y]==1)?0:m+1),x++;\n\t\t\t\telse\n\t\t\t\t\tx=y=-1;\n\t\t\telse\n\t\t\t\tx++,y++;\n\t\t\tprintf(""%d %d\\n"",x,y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x,y;\n\t\t\tchar d[32];\n\t\t\tscanf(""%d%d%s"",&x,&y,d);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\ta[x][y]=d[0];\n\t\t\tsolveb(x);\n\t\t\tupdate(0,0,n-1,x);\n\t\t}\n\t}\n\treturn 0;\n}\n\n']",['data structures'],2700
https://codeforces.com//contest/1199/problem/A,A. City Day,For years the Day of city N was held in the most rainy day of summer New mayor decided to break this tradition and select a day for the celebration The mayor knows the weather forecast for the n days of summer On the i th day a i millimeters of rain will fall All values a i are distinct The mayor knows that citizens will watch the weather x days before the celebration and y days after Because of that he says that a day d is if a d is smaller than rain amounts at each of x days before day d and and each of y days after day d In other words a d a j should hold for all d x le j d and d j le d y Citizens only watch the weather during summer so we only consider such j that 1 le j le n Help mayor find the day of summer ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\n#define isNum(a) (a >= \'0\' && a <= \'9\')\n#define SP putchar(\' \')\n#define EL putchar(\'\\n\')\n#define File(a) freopen(a "".in"", ""r"", stdin), freopen(a "".out"", ""w"", stdout)\n\ntemplate<class T>\ninline void read(T&);\ntemplate<class T>\ninline void write(const T&);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef const int& ci;\ntypedef std::pair<int, int> pii;\nconst int iinf = 2147483647;\nconst ll llinf = 9223372036854775807ll;\nusing std::min;\nusing std::max;\nusing std::abs;\nusing std::sort;\nconst int N = 100005;\n\nint a[N];\n\nint main () {\n    int n, x, y;\n    read(n), read(x), read(y);\n    for (int i = 1; i <= n; ++i) {\n        read(a[i]);\n    }\n    for (int i = 1; i <= n; ++i) {\n        bool flag = true;\n        for (int j = max(i - x, 1); j <= min(i + y, n); ++j) {\n            if (i ^ j) {\n                if (a[j] <= a[i]) {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n        if (flag) {\n            write(i), EL;\n            return 0;\n        }\n    }\n    return 0;\n}\n\ntemplate<class T>\nvoid read(T &Re) {\n    T k = 0;\n    char ch = getchar();\n    int flag = 1;\n    while (!isNum(ch)) {\n        if (ch == \'-\') {\n            flag = -1;\n        }\n        ch = getchar();\n    }\n    while (isNum(ch)) {\n        k = (k << 1) + (k << 3) + ch - \'0\';\n        ch = getchar();\n    }\n    Re = flag * k;\n}\ntemplate<class T>\nvoid write(const T &Wr) {\n    if (Wr < 0) {\n        putchar(\'-\');\n        write(-Wr);\n    } else {\n        if (Wr < 10) {\n            putchar(Wr + \'0\');\n        } else {\n            write(Wr / 10);\n            putchar((Wr % 10) + \'0\');\n        }\n    }\n}\n']",['implementation'],1000
https://codeforces.com//contest/917/problem/A,A. The Monster,As Will is stuck in the Upside Down he can still communicate with his mom Joyce through the Christmas lights he can turn them on and off with his mind He can t directly tell his mom where he is because the monster that took him to the Upside Down will know and relocate him Thus he came up with a puzzle to tell his mom his coordinates His coordinates are the answer to the following problem A string consisting only of parentheses and is called a bracket sequence Some bracket sequence are called correct bracket sequences More formally Empty string is a correct bracket sequence if is a correct bracket sequence then is also a correct bracket sequence if and are correct bracket sequences then concatenation of and is also a correct bracket sequence A string consisting of parentheses and question marks is called pretty if and only if there s a way to replace each question mark with either or such that the resulting string is a correct bracket sequence Will gave his mom a string consisting of parentheses and question marks using Morse code through the lights and his coordinates are the number of pairs of integers such that and the string is pretty where is th character of Joyce doesn t know anything about bracket sequences so she asked for your help ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=5010;\nchar s[10100];\nint n,win[N][N];\nint main() {\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\trep(i,0,n) {\n\t\tint cnt=0;\n\t\trep(j,i,n) {\n\t\t\tif (s[j]==\'(\'||s[j]==\'?\') cnt++;\n\t\t\t\telse cnt--;\n\t\t\tif (cnt>=0) win[i][j]++;\n\t\t\telse break;\n\t\t}\n\t}\n\tper(i,0,n) {\n\t\tint cnt=0;\n\t\tper(j,0,i+1) {\n\t\t\tif (s[j]==\')\'||s[j]==\'?\') cnt++;\n\t\t\t\telse cnt--;\n\t\t\tif (cnt>=0) win[j][i]++;\n\t\t\telse break;\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,0,n) rep(j,i,n) if ((i+j)%2==1&&win[i][j]==2) cnt++;\n\tprintf(""%d\\n"",cnt);\n}\n']","['dp', 'greedy', 'implementation', 'math']",1800
https://codeforces.com//contest/1602/problem/B,B. Divine Array,Black is gifted with a Divine array a consisting of n 1 le n le 2000 integers Each position in a has an initial value After shouting a curse over the array it becomes angry and starts an unstoppable transformation The transformation consists of infinite steps Array a changes at the i th step in the following way for every position j a j becomes equal to the number of occurrences of a j in a before starting this step Here is an example to help you understand the process better Initial array 2 1 1 4 3 1 2After the 1 st step 2 3 3 1 1 3 2After the 2 nd step 2 3 3 2 2 3 2After the 3 rd step 4 3 3 4 4 3 4 In the initial array we had two 2 s three 1 s only one 4 and only one 3 so after the first step each element became equal to the number of its occurrences in the initial array all twos changed to 2 all ones changed to 3 four changed to 1 and three changed to 1 The transformation steps continue You have to process q queries in each query Black is curious to know the value of a x after the k th step of transformation ,"['#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n\tint ret=0;bool f=0;char c=getchar();\n\twhile(c>\'9\'||c<\'0\')f|=(c==\'-\'),c=getchar();\n\twhile(c>=\'0\'&&c<=\'9\')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\treturn f?-ret:ret;\n}\nint T;\nconst int maxn=2e3+5;\nint n,q;\nint a[maxn][maxn];\nint cnt[maxn];\nint main()\n{\n\tT=read();\n\twhile(T--)\n\t{\n\t\tgenerate_n(a[0]+1,n=read(),read);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)cnt[a[i][j]]++;\n\t\t\tfor(int j=1;j<=n;j++)a[i+1][j]=cnt[a[i][j]];\n\t\t\tfor(int j=1;j<=n;j++)cnt[a[i][j]]--;\n\t\t}\n\t\tq=read();\n\t\twhile(q--)\n\t\t{\n\t\t\tint x=read(),k=min(n,read());\n\t\t\tprintf(""%d\\n"",a[k][x]);\n\t\t}\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/723/problem/E,E. One-Way Reform,There are cities and two way roads in Berland each road connects two cities It is known that there is no more than one road connecting each pair of cities and there is no road which connects the city with itself It is possible that there is no way to get from one city to some other city using only these roads The road minister decided to make a reform in Berland and to orient all roads in the country i e to make each road one way The minister wants to the number of cities for which the number of roads that begins in the city to the number of roads that ends in it ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int N(222);\n\nint n, m;\nint adj[N][N], visit[N], deg[N];\nvector<pair<int, int> > answer;\nset<pair<int, int> > baned;\n\nvoid dfs(int x) {\n\tvisit[x] = 1;\n\tfor (int y = 1; y <= n; y++) {\n\t\twhile (adj[x][y]) {\n\t\t\tadj[x][y]--;\n\t\t\tadj[y][x]--;\n\t\t\tdfs(y);\n\t\t\tanswer.push_back({x, y});\n\t\t}\n\t}\n}\n\nint main() {\n\tint test;\n\tscanf(""%d"", &test);\n\twhile (test--) {\n\t\tscanf(""%d %d"", &n, &m);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvisit[i] = 0;\n\t\t\tdeg[i] = 0;\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tadj[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tbaned.clear();\n\t\tanswer.clear();\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint u, v;\n\t\t\tscanf(""%d %d"", &u, &v);\n\t\t\tadj[u][v] = adj[v][u] = 1;\n\t\t\tdeg[v]++;\n\t\t\tdeg[u]++;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (deg[i] % 2 == 1) {\n\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\tif (deg[j] % 2 == 1) {\n\t\t\t\t\t\tbaned.insert({i, j});\n\t\t\t\t\t\tadj[i][j]++;\n\t\t\t\t\t\tadj[j][i]++;\n\t\t\t\t\t\tdeg[i]++;\n\t\t\t\t\t\tdeg[j]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!visit[i]) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdeg[i] = 0;\n\t\t}\n\t\tvector<pair<int, int> > result;\n\t\tfor (auto p : answer) {\n\t\t\tint a = p.first, b = p.second;\n\t\t\tif (baned.count({a, b}) || baned.count({b, a})) {\n\t\t\t\tbaned.erase({min(a, b), max(a, b)});\n\t\t\t} else {\n\t\t\t\tdeg[a]++;\n\t\t\t\tdeg[b]--;\n\t\t\t\tresult.push_back({a, b});\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (deg[i] == 0) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", cnt);\n\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\tprintf(""%d %d\\n"", result[i].first, result[i].second);\n\t\t}\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'dfs and similar', 'flows', 'graphs', 'greedy']",2200
https://codeforces.com//contest/1494/problem/E,E. A-Z Graph,You are given a directed graph consisting of n vertices Each directed edge or arc labeled with a single character Initially the graph is empty You should process m queries with it Each query is one of three types add arc from u to v with label c It s guaranteed that there is no arc u v in the graph at this moment erase arc from u to v It s guaranteed that the graph contains arc u v at this moment find the sequence of k vertices v 1 v 2 dots v k such that there exist both routes v 1 to v 2 to dots to v k and v k to v k 1 to dots to v 1 and if you write down characters along both routes you ll get the same string You can visit the same vertices any number of times ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nset<pair<int, int>> edges;\n\nmap<pair<int, int>, char> mapka;\n\nset<pair<int, int>> double_edges;\n\nset<pair<int, int>> good_double_edges;\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n, m; cin>>n>>m;\n\n    while (m--)\n    {\n        string op; cin>>op;\n        if (op==""+"")\n        {\n            int u, v; char c; cin>>u>>v>>c;\n            edges.insert(mp(u, v)); mapka[mp(u, v)] = c;\n            if (edges.count(mp(v, u)))\n            {\n                double_edges.insert(mp(min(u, v), max(u, v)));\n                if (mapka[mp(u, v)] == mapka[mp(v, u)]) good_double_edges.insert(mp(min(u, v), max(u, v)));\n            }\n        }\n        if (op==""-"")\n        {\n            int u, v; cin>>u>>v; edges.erase(mp(u, v));\n\n            if (edges.count(mp(v, u)))\n            {\n                double_edges.erase(mp(min(u, v), max(u, v)));\n                if (mapka[mp(u, v)] == mapka[mp(v, u)]) good_double_edges.erase(mp(min(u, v), max(u, v)));\n            }\n\n        }\n        if (op==""?"")\n        {\n            int k; cin>>k;\n            if (k%2)\n            {\n                if (double_edges.size()) cout<<""YES""<<endl; else cout<<""NO""<<endl;\n            }\n            else\n            {\n                if (good_double_edges.size()) cout<<""YES""<<endl; else cout<<""NO""<<endl;\n            }\n        }\n\n        /*cout<<""ITERATION: ""<<endl;\n        for (auto it: double_edges) cout<<it.first<<\' \'<<it.second<<endl;*/\n\n    }\n}']","['constructive algorithms', 'data structures', 'graphs', 'hashing']",2400
https://codeforces.com//contest/1117/problem/A,A. Best Subsegment,You are given array a 1 a 2 dots a n Find the subsegment a l a l 1 dots a r 1 le l le r le n with maximum arithmetic mean frac 1 r l 1 sum limits i l r a i in floating point numbers i e without any rounding If there are many such subsegments find the one ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nint A[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tint ma=-1;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tma=max(ma,A[i]);\n\t}\n\tint cur=0,ret=0;\n\tFOR(i,N) {\n\t\tif(A[i]==ma) cur++;\n\t\telse cur=0;\n\t\tret=max(ret,cur);\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n""]","['implementation', 'math']",1100
https://codeforces.com//contest/1071/problem/A,A. Cram Time,In a galaxy far far away Lesha the student has just got to know that he has an exam in two days As always he hasn t attended any single class during the previous year so he decided to spend the remaining time wisely Lesha knows that today he can study for at most a hours and he will have b hours to study tomorrow Note that it is possible that on his planet there are more hours in a day than on Earth Lesha knows that the quality of his knowledge will only depend on the number of lecture notes he will read He has access to an infinite number of notes that are enumerated with positive integers but he knows that he can read the first note in one hour the second note in two hours and so on In other words Lesha can read the note with number k in k hours Lesha can read the notes in arbitrary order however he can t start reading a note in the first day and finish its reading in the second day Thus the student has to fully read several lecture notes today spending at most a hours in total and fully read several lecture notes tomorrow spending at most b hours in total What is the maximum number of notes Lesha can read in the remaining time Which notes should he read in the first day and which in the second ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nll a, b;\n\nint main()\n{\n\tscanf(""%lld%lld"", &a, &b);\n\tll w=0;\n\tll s=0;\n\twhile(s+w+1<=a+b)\n\t{\n\t\tw++;\n\t\ts+=w;\n\t}\n\tvll raz, dwa;\n\tfor (ll i=w; i; i--)\n\t{\n\t\tif (a>=i)\n\t\t{\n\t\t\traz.push_back(i);\n\t\t\ta-=i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(b>=i);\n\t\t\tdwa.push_back(i);\n\t\t\tb-=i;\n\t\t}\n\t}\n\tprintf(""%d\\n"", raz.size());\n\tfor (ll i : raz)\n\t\tprintf(""%lld "", i);\n\tprintf(""\\n"");\n\tprintf(""%d\\n"", dwa.size());\n\tfor (ll i : dwa)\n\t\tprintf(""%lld "", i);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']",['greedy'],1600
https://codeforces.com//contest/675/problem/C,C. Money Transfers,There are banks in the city where Vasya lives they are located in a circle such that any two banks are neighbouring if their indices differ by no more than Also bank and bank are neighbours if No bank is a neighbour of itself Vasya has an account in each bank Its balance may be negative meaning Vasya owes some money to this bank There is only one type of operations available transfer some amount of money from any bank to account in any bank There are no restrictions on the size of the sum being transferred or balance requirements to perform this operation Vasya doesn t like to deal with large numbers so he asks you to determine the minimum number of operations required to change the balance of each bank account to zero It s guaranteed that this is possible to achieve that is the total balance of Vasya in all banks is equal to zero ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e16;\n\nll p[200200], a[200200];\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    p[0] = a[0];\n    for (int i = 1; i < n; i++)\n        p[i] = a[i] + p[i - 1];\n    sort(p, p + n);\n    p[n] = INF;\n    int ans = 0;\n    int i = 0;\n    while (i < n)\n    {\n        int j = i;\n        while (p[j] == p[i])\n            j++;\n        ans = max (ans, j - i);\n        i = j;\n    }\n    cout << n - ans;\n    return 0;\n}\n']","['constructive algorithms', 'data structures', 'greedy', 'sortings']",2100
https://codeforces.com//contest/1381/problem/A2,A2. Prefix Flip  Hard Version ,There are two binary strings a and b of length n a binary string is a string consisting of symbols 0 and 1 In an operation you select a prefix of a and simultaneously invert the bits in the prefix 0 changes to 1 and 1 changes to 0 and reverse the order of the bits in the prefix For example if a 001011 and you select the prefix of length 3 it becomes 011011 Then if you select the entire string it becomes 001001 Your task is to transform the string a into b in at most 2n operations It can be proved that it is always possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n;\nstr a,b;\n\nvi nor(str& x) {\n\tvi res;\n\tint ind = 0;\n\twhile (1) {\n\t\twhile (ind < n-1 && x[ind] == x[ind+1]) ind ++;\n\t\tif (ind == n-1) return res;\n\t\tres.pb(ind+1);\n\t\tx[ind] = \'0\'+\'1\'-x[ind];\n\t}\n}\n\nvoid solve() {\n\tre(n); re(a,b);\n\tvi x = nor(a);\n\tvi y = nor(b);\n\tif (a[n-1] != b[n-1]) {\n\t\tx.pb(n);\n\t}\n\treverse(all(y)); trav(t,y) x.pb(t);\n\tpr(sz(x),\' \'); ps(x);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","['constructive algorithms', 'data structures', 'implementation', 'strings', 'two pointers']",1700
https://codeforces.com//contest/1778/problem/D,D. Flexible String Revisit,You are given two binary strings a and b of length n In each move the string a is modified in the following way An index i 1 leq i leq n is chosen uniformly at random The character a i will be flipped That is if a i is 0 it becomes 1 and if a i is 1 it becomes 0 What is the expected number of moves required to make both strings equal A binary string is a string in which the character is either tt 0 or tt 1 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\nconst int N=1e6+5,mod=998244353;\nint f[N],g[N],F[N],T,n;\nchar s[N],t[N];\ninline int fastpow(int x, int y){\n\tint z=1;\n\tfor (; y; y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) z=1ll*z*x%mod;\n\treturn z;\n}\nint main(){\n\tfor (cin>>T; T; T--){\n\t\tscanf(""%d%s%s"",&n,s+1,t+1);\n\t\tint Invn=fastpow(n,mod-2);\n\t\tf[1]=1ll*(n-1)*Invn%mod; g[1]=1;\n\t\tfor (int i=2; i<n; i++){\n\t\t\tint I=fastpow((1+mod-1ll*Invn*i%mod*f[i-1]%mod)%mod,mod-2);\n\t\t\tf[i]=1ll*I*Invn%mod*(n-i)%mod;\n\t\t\tg[i]=1ll*I*(1+1ll*i*Invn%mod*g[i-1]%mod)%mod;\n\t\t}\n\t\tF[n]=1ll*(g[n-1]+1)*fastpow((1+mod-f[n-1])%mod,mod-2)%mod;\n\t\tfor (int i=n-1; i>=1; i--) F[i]=(1ll*f[i]*F[i+1]+g[i])%mod;\n\t\tint c=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tif (s[i]!=t[i]) c++;\n\t\tif (n==1) printf(""%d\\n"",c);\n\t\telse printf(""%d\\n"",F[c]);\n\t\tfor (int i=0; i<=n; i++) f[i]=g[i]=F[i]=0;\n\t}\n}\n/*\n1\n4\n1000\n1110\n*/']","['combinatorics', 'dp', 'math', 'probabilities']",2100
https://codeforces.com//contest/1194/problem/F,F. Crossword Expert,Today Adilbek is taking his probability theory test Unfortunately when Adilbek arrived at the university there had already been a long queue of students wanting to take the same test Adilbek has estimated that he will be able to start the test only T seconds after coming Fortunately Adilbek can spend time without revising any boring theorems or formulas He has an app on this smartphone which contains n Japanese crosswords to solve Adilbek has decided to solve them all one by one in the order they are listed in the app without skipping any crossword For each crossword a number t i is given that represents the time it takes an average crossword expert to solve this crossword the time is given in seconds Adilbek is a true crossword expert but unfortunately he is sometimes unlucky in choosing the way to solve the crossword So it takes him either t i seconds or t i 1 seconds to solve the i th crossword equiprobably with probability frac 1 2 he solves the crossword in exactly t i seconds and with probability frac 1 2 he has to spend an additional second to finish the crossword All these events are independent After T seconds pass or after solving the last crossword if he manages to do it in less than T seconds Adilbek closes the app if he finishes some crossword at the same moment that crossword is considered solved otherwise Adilbek does not finish solving the current crossword at all He thinks it would be an interesting probability theory problem to calculate E the expected number of crosswords he will be able to solve completely Can you calculate it Recall that the expected value of a discrete random variable is the probability weighted average of all possible values in this problem it means that the expected value of the number of solved crosswords can be calculated as E sum limits i 0 n i p i where p i is the probability that Adilbek will solve exactly i crosswords We can represent E as rational fraction frac P Q with Q 0 To give the answer you should print P cdot Q 1 bmod 10 9 7 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>\n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= pow(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<MX> C;\n\nint n;\nll T;\n\nint main() {\n    setIO(); C.init();\n    re(n,T);\n    vl t(n); re(t);\n    mi ans = 0, sum = 1;\n    int r = 0;\n    F0R(i,n) {\n    \tT -= t[i]; if (T < 0) break;\n    \tsum = 2*sum-C.comb(i,r);\n    \twhile (r < min((ll)i+1,T)) {\n    \t\tsum += C.comb(i+1,++r);\n    \t}\n    \twhile (r > T) {\n    \t\tsum -= C.comb(i+1,r--);\n    \t}\n    \tans += sum/pow(mi(2),i+1);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/']","['combinatorics', 'dp', 'number theory', 'probabilities', 'two pointers']",2400
https://codeforces.com//contest/1485/problem/A,A. Add and Divide,You have two positive integers a and b You can perform two kinds of operations a lfloor frac a b rfloor replace a with the integer part of the division between a and b b b 1 increase b by 1 Find the minimum number of operations required to make a 0 ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint t,x,y,ans;\nint get(int x,int y){\n\tif(y==1) return orz;\n\tint cnt=0;\n\twhile(x)x/=y,++cnt;\n\treturn cnt;\n}\nint main(){\n\tscanf(""%d"",&t);\n\twhile(t--){\n\t\tscanf(""%d%d"",&x,&y);\n\t\tans=orz;\n\t\tfor(int i=0;i<ans;++i)ans=min(ans,i+get(x,y+i));\n\t\tprintf(""%d\\n"",ans);\n\t}\n    return 0;\n}\n']","['brute force', 'greedy', 'math', 'number theory']",1000
https://codeforces.com//contest/759/problem/E,E. Byteland coins,There are types of coins in Byteland Conveniently the denomination of the coin type divides the denomination of the coin type the denomination of the coin type equals tugrick The ratio of the denominations of coin types and equals It is known that for each there are at most coin types of denomination Byteasar has coins of type with him and he needs to pay exactly tugricks It is known that Byteasar never has more than coins with him Byteasar want to know how many ways there are to pay exactly tugricks Two ways are different if there is an integer such that the amount of coins of type differs in these two ways As all Byteland citizens Byteasar wants to know the number of ways modulo ,"['#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, ""/stack:16777216"")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <assert.h>\n#include <time.h>\n#include <complex.h>\n\n\n#include <fstream>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<Int, Int> PII;\n\nconst int INF = 1000000000;\nconst int MAX = 300007;\nconst int MAXD = 20;\nconst int MOD = 1000000007;\n\nconst int BASE = 1000*1000*1000;\n\nVI read(string s)\n{\n    VI a;\n    for (int i=(int)s.length(); i>0; i-=9)\n        if (i < 9)\n            a.push_back (atoi (s.substr (0, i).c_str()));\n        else\n            a.push_back (atoi (s.substr (i-9, 9).c_str()));\n    return a;\n}\n\nint div(VI & a, int b)\n{\n    if (b == 1)\n    {\n        return 0;\n    }\n        \n    \n    if (b == BASE)\n    {\n        int carry = a[0];\n        if (SZ(a) > 0)\n        {\n            a.erase(a.begin());\n        }\n        return carry;\n    }\n    \n    int carry = 0;\n    for (int i=(int)a.size()-1; i>=0; --i) {\n        long long cur = a[i] + carry * 1ll * BASE;\n        a[i] = int (cur / b);\n        carry = int (cur % b);\n    }\n    while (a.size() > 1 && a.back() == 0)\n        a.pop_back();\n    return carry;\n}\n\nVI A[MAX];\nVI C;\nint a[MAX];\nVI B;\n\nint dp[2][MAX];\nint b[MAX];\n\n\nint main()\n{\n    //freopen(""in.txt"" , ""r"" , stdin);\n    //freopen(""out.txt"" , ""w"" , stdout);\n    \n    int n;\n    cin >> n;\n    FOR(i,1,n)\n    {\n        scanf(""%d"", &a[i]);\n    }\n\n    \n    \n    FOR(i,0,n)\n    {\n        scanf(""%d"", &b[i]);\n    }\n    \n    string s;\n    cin >> s;\n    VI num = read(s);\n    FOR(i,1,n)\n    {\n        B.push_back(div(num , a[i]));\n    }\n    if (SZ(num) > 1)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    B.push_back(num[0]);\n    \n    int sz = b[0] + 1;\n    int prev = 0;\n    int next = 1;\n    FOR(i,0,sz)\n    {\n        dp[prev][i] = 1;\n    }\n    \n    FOR(i,0,n - 1)\n    {\n        VI t;\n        int idd = 0;\n        for(int j = B[i]; j < sz; j += a[i + 1])\n        {\n            dp[next][idd ++] = dp[prev][j];\n        }\n        if (idd == 0)\n        {\n            cout << 0 << endl;\n            return 0;\n        }\n        sz = idd;\n        swap(prev , next);\n        int x = b[i + 1];\n        \n        FOR(j,0,sz + b[i + 1])\n        {\n            dp[next][j] = 0;\n            if (j) dp[next][j] = dp[next][j - 1];\n            if (j < sz)\n            {\n                dp[next][j] += dp[prev][j];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n            if (j - x - 1 >= 0)\n            {\n                dp[next][j] += MOD - dp[prev][j - x - 1];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n        }\n        swap(prev , next);\n        sz += x;\n        \n    }\n    \n    if (B[n - 1] >= sz)\n    {\n        cout << 0 << endl;\n    }\n    else\n    {\n        cout << dp[prev][B[n - 1]] << endl;\n    }\n        \n    \n    \n    return 0;\n}\n']","['dp', 'math']",3200
https://codeforces.com//contest/1538/problem/D,D. Another Problem About Dividing Numbers,You are given two integers a and b In one turn you can do one of the following operations Take an integer c c 1 and and replace a with frac a c Take an integer c c 1 and and replace b with frac b c Your goal is to make a equal to b using exactly k turns For example the numbers a 36 and b 48 can be made equal in 4 moves c 6 divide b by c Rightarrow a 36 b 8 c 2 divide a by c Rightarrow a 18 b 8 c 9 divide a by c Rightarrow a 2 b 8 c 4 divide b by c Rightarrow a 2 b 2 For the given numbers a and b determine whether it is possible to make them equal using exactly k turns ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nint cnt(int x)\n{\n    int res=0,i;\n    for (i=2;i*i<=x;i++)\n    {\n        while(x%i==0)\n        {\n            x/=i;\n            res++;\n        }\n    }\n    if (x>1) res++;\n    return res;\n}\nint n,m,i,j,k,t,t1,u,v,a,b;\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>a>>b>>k;\n        u=cnt(a);\n        v=cnt(b);\n        if (k>u+v)\n        {\n            cout<<""No\\n"";\n        }\n        else\n        {\n            if (k>1)\n            {\n                cout<<""Yes\\n"";\n            }\n            else\n            {\n                if (((a%b==0)or(b%a==0))and(a-b))\n                {\n                    cout<<""Yes\\n"";\n                }\n                else\n                {\n                    cout<<""No\\n"";\n                }\n            }\n        }\n    }\n}\n']","['constructive algorithms', 'math', 'number theory']",1700
https://codeforces.com//contest/1715/problem/B,B. Beautiful Array,Stanley defines the beauty of an array a of length n which contains as follows sum limits i 1 n left lfloor frac a i k right rfloor which means that we divide each element by k round it down and sum up the resulting values Stanley told Sam the integer k and asked him to find an array a of n non negative integers such that the beauty is equal to b and the sum of elements is equal to s Help Sam find any of the arrays satisfying the conditions above ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(""%d"",&x);\n\treturn x;\n}\ntypedef long long ll;\nint n,k,b;\nll s;\nll a[100005];\nvoid solve(){\n\tn=in(),k=in(),b=in();scanf(""%lld"",&s);\n\tfor(int i=1;i<=n;i++)a[i]=0;\n\ta[1]=(ll)k*b;s-=a[1];\n\tif(s<0){\n\t\tputs(""-1"");\n\t\treturn;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tll v=min((ll)k-1,s);\n\t\ts-=v;a[i]+=v;\t\n\t}\n\tif(s!=0){\n\t\tputs(""-1"");\n\t\treturn;\t\n\t}\n\tfor(int i=1;i<=n;i++)printf(""%lld "",a[i]),a[i]=0;\n\tputs("""");\n}\nint main(){\n\tint t=in();\n\twhile(t--)solve();\n\treturn 0;\n}']","['constructive algorithms', 'greedy', 'math']",1000
https://codeforces.com//contest/884/problem/A,A. Book Reading,Recently Luba bought a very interesting book She knows that it will take seconds to read the book Luba wants to finish reading as fast as she can But she has some work to do in each of next days The number of seconds that Luba has to spend working during th day is If some free time remains she can spend it on reading Help Luba to determine the minimum number of day when she finishes reading ,"['#include <functional>\n#include <utility>\n#include <map>\n#include <array>\n#include <cstdio>\n#include <iterator>\n#include <vector>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,""%s"")DEF(int,""%d"")DEF(double,""%lf"")DEF(float,""%f"")DEF(char,""%c"")DEF(const char*,""%s"")DEF(unsigned long,""%lu"")DEF(unsigned int, ""%u"")DEF(long double, ""%Lf"")\n#ifdef _MSC_VER\nDEF(long long int,""%I64d"")\n#else\nDEF(long long int,""%lld"")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(""%s"", arg);}\nint RD(char* arg){return std::scanf(""%s"", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf("" %c"", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(""(""); WT(arg.first); std::printf("", ""); WT(arg.second); std::printf("")"");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf("" ""): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(""\\n""); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf("" ""): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(""\\n""); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == \'""\' || #_1[0] == \'\\\'\'? WT("""", _1, """"): WT(\'[\', #_1, \'=\', _1, \']\'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(""(%03d) "", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(""""))\n\n\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main()\n{\n    int N, T;\n    RD(N, T);\n    \n    int ans = 0;\n    int alc = 0;\n    for(int i: RG(N))\n    {\n        ans++;\n        int a;\n        RD(a);\n\n        if((alc += 86400 - a) >= T)\n            break;\n    }\n    WTL(ans);\n\n}\n\n\n\n\n']",['implementation'],800
https://codeforces.com//contest/1246/problem/D,D. Tree Factory,Bytelandian Tree Factory produces trees for all kinds of industrial applications You have been tasked with optimizing the production of a certain type of tree for an especially large and important order The tree in question is a rooted tree with n vertices labelled with distinct integers from 0 to n 1 The vertex labelled 0 is the root of the tree and for any non root vertex v the label of its parent p v is less than the label of v All trees at the factory are made from bamboo blanks A is a rooted tree such that each vertex has exactly one child except for a single leaf vertex with no children The vertices of a bamboo blank can be labelled arbitrarily before its processing is started To process a bamboo into another tree a single type of operation can be made choose an arbitrary non root vertex v such that its parent p v is not a root either The operation consists of changing the parent of v to its parent s parent p p v Note that parents of all other vertices remain unchanged in particular the subtree of v does not change Efficiency is crucial hence you have to minimize the number of operations to make the desired tree from a bamboo blank Construct any optimal sequence of operations to produce the desired tree Note that the labelling of the resulting tree has to coincide with the labelling of the desired tree Formally the labels of the roots have to be equal and for non root vertices with the same label the labels of their parents should be the same It is guaranteed that for any test present in this problem an answer exists and further an optimal sequence contains at most 10 6 operations Note that ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n, p[MX], des[MX], depth[MX], maxDepth[MX];\nvi child[MX];\nvi boo, op;\n\nvoid dfs(int x) {\n\tmaxDepth[x] = depth[x];\n\ttrav(c,child[x]) {\n\t\tdepth[c] = depth[x]+1; dfs(c);\n\t\tckmax(maxDepth[x], maxDepth[c]);\n\t}\n}\n\nvoid mov(int x) {\n\tassert(p[x] != -1);\n\tp[x] = p[p[x]]; op.pb(x);\n}\n\nvoid genBoo(int x) {\n\tif (sz(boo)) p[x] = boo.back();\n\telse p[x] = -1;\n\tboo.pb(x);\n\twhile (p[x] != des[x]) mov(x);\n\ttrav(c,child[x]) genBoo(c);\n}\n\nint main() {\n\tsetIO(); re(n); \n\tdes[0] = -1;\n\tFOR(i,1,n) {\n\t\tre(des[i]);\n\t\tchild[des[i]].pb(i);\n\t}\n\tdfs(0);\n\tF0R(i,n) sort(all(child[i]),[](int a, int b) { return maxDepth[a] < maxDepth[b]; });\n\t\n\tgenBoo(0);\n\tFOR(i,1,n) assert(p[i] == des[i]);\n\ttrav(t,boo) pr(t,\' \');\n\tps();\n\tps(sz(op));\n\ttrav(t,op) pr(t,\' \');\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']","['constructive algorithms', 'divide and conquer', 'greedy', 'trees']",2500
https://codeforces.com//contest/776/problem/F,F. Sherlock's bet to Moriarty,Sherlock met Moriarty for a final battle of wits He gave him a regular sided convex polygon In addition to it he gave him certain diagonals to form regions on the polygon It was guaranteed that the diagonals did not intersect in interior points He took each of the region and calculated its importance value Importance value for a region formed by vertices of the polygon will be given by Then he sorted these regions on the basis of their importance value in ascending order After that he assigned each region an index from to where is the number of regions and index of region is its position in the sorted array calculated above He wants Moriarty to color the regions using not more than colors such that two regions have same color only if all the simple paths between these two regions have at least one region with color value less than the color value assigned to these regions Simple path between two regions and is a sequence of regions such that for each regions and share an edge and if and only if Moriarty couldn t answer and asks Sherlock to solve it himself Help Sherlock in doing so ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define pii pair<int,int>\nusing namespace std;\nint n, m, cc, cnt, AL;\nvector<pii>E[101000];\nvector<int>G[201000], F[201000];\nint Num[501000], Col[201000];\nvoid Go(int b, int e){\n    G[cnt].push_back(e);\n    int t = lower_bound(E[e].begin(),E[e].end(), pii(b,0)) - E[e].begin();\n    pii tp = E[e][(t+1)%E[e].size()];\n    if(Num[tp.second])return;\n    Num[tp.second] = cnt;\n    Go(e, tp.first);\n}\nint chk[201000], C[201000];\nvoid DFS(int a, int pp){\n    int i, x;\n    C[a] = 1;\n    for(i=0;i<F[a].size();i++){\n        x = F[a][i];\n        if(chk[x] || x==pp)continue;\n        DFS(x, a);\n        C[a] += C[x];\n    }\n}\nint DFS2(int a, int pp, int MM){\n    int i, x;\n    for(i=0;i<F[a].size();i++){\n        x = F[a][i];\n        if(chk[x] || x==pp)continue;\n        if(C[x] * 2 > MM)return DFS2(x, a, MM);\n    }\n    return a;\n}\nint get_mid(int a){\n    DFS(a,0);\n    if(C[a]==1)return 0;\n    return DFS2(a,0,C[a]);\n}\nvoid Do(int a, int dep){\n    int mid = get_mid(a);\n    if(!mid){\n        Col[a] = dep;\n        return;\n    }\n    Col[mid] = dep;\n    int i;\n    chk[mid] = 1;\n    for(i=0;i<F[mid].size();i++){\n        if(!chk[F[mid][i]]) Do(F[mid][i], dep+1);\n    }\n    chk[mid] = 0;\n}\nstruct AA{\n    long long g;\n    int num;\n    bool operator<(const AA &p)const{\n        return g<p.g;\n    }\n}ord[201000];\nint main(){\n    int i, a, b, j;\n    scanf(""%d%d"",&n,&m);\n    for(i=1;i<=m;i++){\n        scanf(""%d%d"",&a,&b);\n        E[a].push_back(pii(b,cc++));\n        E[b].push_back(pii(a,cc++));\n    }\n    for(i=1;i<=n;i++){\n        E[i].push_back(pii(i%n+1,cc++));\n        E[i%n+1].push_back(pii(i,cc++));\n    }\n    for(i=1;i<=n;i++){\n        sort(E[i].begin(),E[i].end());\n    }\n    for(i=1;i<=n;i++){\n        for(j=0;j<E[i].size();j++){\n            if(!Num[E[i][j].second]){\n                cnt++;\n                Num[E[i][j].second] = cnt;\n                Go(i,E[i][j].first);\n            }\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(G[i].size() == n && !AL)AL = i;\n    }\n    for(i=0;i<cc;i++){\n        if(Num[i]!=AL && Num[i^1]!=AL)F[Num[i]].push_back(Num[i^1]);\n    }\n    int rt = 1;\n    if(AL==1)rt++;\n    Do(rt, 1);\n    int ccc = 0;\n    for(i=1;i<=cnt;i++){\n        if(i==AL)continue;\n        sort(G[i].begin(),G[i].end());\n        long long ss = 0;\n        for(j=0;j<2;j++){\n            ss *= 1000000;\n            ss += G[i][G[i].size()-j-1];\n        }\n        ord[ccc++]={ss,i};\n    }\n    sort(ord,ord+ccc);\n    for(i=0;i<ccc;i++){\n        printf(""%d "",Col[ord[i].num]);\n    }\n}']","['constructive algorithms', 'data structures', 'divide and conquer', 'geometry', 'graphs', 'implementation', 'trees']",2800
https://codeforces.com//contest/768/problem/G,G. The Winds of Winter,Given a rooted tree with nodes The Night King removes exactly one node from the tree and all the edges associated with it Doing this splits the tree and forms a forest The node which is removed is not a part of the forest The root of a tree in the forest is the node in that tree which does not have a parent We define the strength of the forest as the size of largest tree in forest Jon Snow wants to minimize the strength of the forest To do this he can perform the following operation at most once For each node you need to find the minimum value of strength of the forest formed when node is removed ,"['#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n#define tm tm1\n#define y1 y11\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define NAME """"\n\nusing namespace std;\n\t\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\n\nstruct node\n{\n\tnode *l;\n\tnode *r;\n\tint sm;\n};\n\ntypedef node* pnode;\n\n\nconst int MAXN = 600020;\n\nint sz[MAXN];\t\nvector <int> e[MAXN];\nint p[MAXN];\nint l[MAXN], r[MAXN];\nint tm = 0;\npnode root[MAXN];\nint n;\nint ans[MAXN];\n\npnode create_rmq(int cn)\n{\n\tpnode cur = new node();\n\tcur->sm = 0;\n\tif (cn == 1)\n\t{\n\t\tcur->l = cur->r = NULL;\n\t}\n\telse cur->l = create_rmq((cn + 1) / 2), cur->r = create_rmq(cn / 2);\n\treturn cur;\n}\n\nint lv, rv = 1;\n\npnode modify_rmq(pnode t, int l, int r)\n{\n\tpnode an = new node();\n\tan->sm = t->sm + rv;\n\tif (l == r)\n\t{\n\t\tan->l = an->r = NULL;\n\t}\n\telse\n\t{\n\t\tint md = (l + r) / 2;\n\t\tif (lv <= md) an->l = modify_rmq(t->l, l, md), an->r = t->r;\n\t\telse an->l = t->l, an->r = modify_rmq(t->r, md + 1, r);\n\t}\n\treturn an;\n}\n\nvoid modify_rmq2(pnode t, int l, int r)\n{\n\tt->sm += rv;\n\tif (l != r)\n\t{\n\t\tint md = (l + r) / 2;\n\t\tif (lv <= md) modify_rmq2(t->l, l, md);\n\t\telse modify_rmq2(t->r, md + 1, r);\n\t}\n}\n\ntypedef vector <pair <pnode, int> > vectt;\n\n\nvectt vts[MAXN];\n\nbool go_rmq(int l, int r, int level = 0)\n{\n\tint vc = vts[0].size();\n\tif ((lv <= l) && (r <= rv))\n\t{\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vc; i++)\n\t\t\tcur += (vts[level][i].first -> sm) * vts[level][i].second;\n\t\treturn (cur > 0);\n\t}\n\tint md = (l + r) / 2;\n\tvts[level + 1] = vts[level];\n\tif (lv <= md)\n\t{\n\t\tfor (int i = 0; i < vc; i++)\n\t\t{\n\t\t\tvts[level + 1][i].first = vts[level][i].first -> l;\n\t\t}\n\t\tif (go_rmq(l, md, level + 1)) return true;\n\t}\n\tif (md < rv)\n\t{\n\t\tfor (int i = 0; i < vc; i++)\n\t\t{\n\t\t\tvts[level + 1][i].first = vts[level][i].first -> r;\n\t\t}\n\t\tif (go_rmq(md + 1, r, level + 1)) return true;\n\t}\n\treturn false;\n}\n\nvoid dfs1(int v)\n{\n\tl[v] = tm;\n\tsz[v] = 1;\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tdfs1(e[v][i]);\n\t\tsz[v] += sz[e[v][i]];\n\t}\n\tr[v] = ++tm;\n\tlv = sz[v];\n\trv = 1;\n\troot[tm] = modify_rmq(root[tm - 1], 0, n);\n}\n\npnode del;\n\nint rt;\n\nvector <pair <int, int> > cur;\n\nvoid dfs2(int v)\n{\n\tcur.clear();\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tcur.push_back(mp(sz[e[v][i]], e[v][i]));\n\t}\n\tif (v != rt) cur.push_back(mp(n - sz[v], 0));\n\tsort(cur.begin(), cur.end());\n\tint cs = cur.size();\n\tif (cs == 1) ans[v] = n - 1;\n\telse\n\t{\n\t\tvectt vt;\n\t\tvt.clear();\n\t\tvectt vt2;\n\t\tvt2.clear();\n\t\tvt2.push_back(mp(del, 1));\n\t\tint ls = cur[cs - 1].second;\n\t\tif (ls == 0)\n\t\t{\n\t\t\tvt.push_back(mp(root[l[v]], 1));\n\t\t\tvt.push_back(mp(root[r[v]], -1));\n\t\t\tvt.push_back(mp(root[n], 1));\n\t\t\tvt.push_back(mp(del, -1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvt.push_back(mp(root[l[ls]], -1));\n\t\t\tvt.push_back(mp(root[r[ls]], 1));\n\t\t}\n\t\tint lg = cur[cs - 2].first, rg = cur[cs - 1].first;\n\t\twhile (lg < rg)\n\t\t{\n\t\t\tint md = (lg + rg) / 2;\n\t\t\tlv = cur[cs - 1].first - md;\n\t\t\trv = md - cur[0].first;\n\t\t\tif (lv > rv)\n\t\t\t{\n\t\t\t\tlg = md + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvts[0] = vt;\n\t\t\tbool ok = go_rmq(0, n);\n\t\t\tif (ls == 0)\n\t\t\t{\n\t\t\t\tlv += sz[v];\n\t\t\t\trv += sz[v];\n\t\t\t\trv = min(rv, n);\n\t\t\t\tif (lv <= rv)\n\t\t\t\t{\n\t\t\t\t\tvts[0] = vt2;\n\t\t\t\t\tok |= go_rmq(0, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) rg= md;\n\t\t\telse lg = md + 1;\n\t\t}\n\t\tans[v] = lg;\n\t}\n\tlv = sz[v], rv = 1;\n\tmodify_rmq2(del, 0, n);\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tdfs2(e[v][i]);\n\t}\n\tlv = sz[v], rv = -1;\n\tmodify_rmq2(del, 0, n);\n}\n\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\t\n\tcin >> n;\n\tif (n == 1)\n\t{\n\t\tcout << 0;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <=  n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (u == 0)\n\t\t{\n\t\t\tp[v] = v;\n\t\t\trt = v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp[v] = u;\n\t\t\te[u].push_back(v);\n\t\t}\n\t}\n\troot[0] = create_rmq(n + 1);\n\tdel = create_rmq(n + 1);\n\tdfs1(rt);\n\tdfs2(rt);\n\tfor (int i = 1; i <= n; i++) cout << ans[i] << "" "";\n\tcout << ""\\n"";\n\treturn 0;\n}\n\n\n']","['binary search', 'data structures']",3300
https://codeforces.com//contest/616/problem/E,E. Sum of Remainders,Calculate the value of the sum As the result can be very large you should print the value modulo the remainder when divided by The modulo operator stands for the remainder after dividing by For example ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\nconst ll MOD = 1000000007;\nconst ll SQ = 2000000;\n\nll n, m;\n\n\nint main() {\n\tcin >> n >> m;\n\tll sum = (n % MOD) * (m % MOD);\n\tsum %= MOD;\n\tm = min(n, m);\n\tll lst = m + 1;\n\tfor (int i = 1; i <= min(SQ, n); ++i) {\n\t\tll r = n / i;\n\t\tll l = n / (i + 1) + 1;\n\t\tr = min(r, m);\n\t\tif (l > r)\n\t\t\tcontinue;\n\t\tlst = min(lst, l);\n\t\tll ss = l + r;\n\t\tll cc = r - l + 1;\n\t\tif ((ss & 1) == 0)\n\t\t\tss /= 2;\n\t\telse\n\t\t\tcc /= 2;\n\t\tss %= MOD;\n\t\tcc %= MOD;\n\t\tss = (ss * cc) % MOD;\n\t\tss = (ss * i) % MOD;\n\t\tsum -= ss;\n\t\tif (sum < 0)\n\t\t\tsum += MOD;\n\t}\n\tfor (int i = 1; i < lst; ++i) {\n\t\tsum -= (n - n % i);\n\t\tsum %= MOD;\n\t\tif (sum < 0)\n\t\t\tsum += MOD;\n\t}\n\tcout << sum << ""\\n"";\n\treturn 0;\n}\n\n\n']","['implementation', 'math', 'number theory']",2200
https://codeforces.com//contest/1842/problem/E,E. Tenzing and Triangle,There are n points and a line x y k on a two dimensional plane The i th point is at x i y i All points have non negative coordinates and are strictly below the line Alternatively 0 leq x i y i x i y i k Tenzing wants to erase all the points He can perform the following two operations Draw triangle Tenzing will choose two non negative integers a b that satisfy a b k then all points inside the triangle formed by lines x a y b and x y k will be erased It can be shown that this triangle is an isosceles right triangle Let the side lengths of the triangle be l l and sqrt 2 l respectively Then the cost of this operation is l cdot A The blue area of the following picture describes the triangle with a 1 b 1 with cost 1 cdot A Erase a specific point Tenzing will choose an integer i that satisfies 1 leq i leq n and erase the point i The cost of this operation is c i Help Tenzing find the minimum cost to erase all of the points ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:36:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    long long mx = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mx += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  long long A;\n  cin >> n >> k >> A;\n  vector<int> l(n), r(n);\n  vector<long long> cost(n);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y >> cost[i];\n    l[i] = x;\n    r[i] = k - y;\n    total += cost[i];\n  }\n  vector<vector<int>> at(k + 1);\n  for (int i = 0; i < n; i++) {\n    at[r[i]].push_back(i);\n  }\n  segtree st(k + 1);\n  long long dp = 0;\n  for (int i = 1; i <= k; i++) {\n    for (int id : at[i]) {\n      st.modify(0, l[id], +cost[id]);\n    }\n    dp = max(dp, -A * i + st.get(0, i - 1).mx);\n    st.modify(i, i, dp + A * i);\n  }\n  cout << total - dp << \'\\n\';\n  return 0;\n}\n']","['data structures', 'dp', 'geometry', 'greedy', 'math']",2300
https://codeforces.com//contest/1560/problem/A,A. Dislike of Threes,Polycarp doesn t like integers that are divisible by 3 or end with the digit 3 in their decimal representation Integers that meet both conditions are disliked by Polycarp too Polycarp starts to write out the positive greater than 0 integers which he likes 1 2 4 5 7 8 10 11 14 16 dots Output the k th element of this sequence the elements are numbered from 1 ,"['/*#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n \n#include <bits/stdc++.h>\n  \n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n \n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n \n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n\nusing namespace std;\n\nsigned main() {\n    \n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(""cf.inp"", ""r"", stdin);\n    // freopen(""cf.out"", ""w"", stdout);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, cur = 0;\n        cin >> n;\n        for1(i,1,100000000) {\n            if (i % 3 && i % 10 != 3) cur++;\n            if (cur == n) {\n                cout << i << ""\\n"";\n                break;\n            }\n        }\n    }\n    \n}']",['implementation'],800
https://codeforces.com//contest/1842/problem/A,A. Tenzing and Tsondu,Tsondu and Tenzing are playing a card game Tsondu has n monsters with ability values a 1 a 2 ldots a n while Tenzing has m monsters with ability values b 1 b 2 ldots b m Tsondu and Tenzing take turns making moves with Tsondu going first In each move the current player chooses two monsters one on their side and one on the other side Then these monsters will fight each other Suppose the ability values for the chosen monsters are x and y respectively then the ability values of the monsters will become x y and y x respectively If the ability value of any monster is smaller than or equal to 0 the monster dies The game ends when at least one player has no monsters left alive The winner is the player with at least one monster left alive If both players have no monsters left alive the game ends in a draw Find the result of the game when both players play optimally ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:07:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    long long x = 0;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      x += a[i];\n    }\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n      x -= b[i];\n    }\n    cout << (x > 0 ? ""Tsondu"" : (x == 0 ? ""Draw"" : ""Tenzing"")) << \'\\n\';\n  }\n  return 0;\n}\n']","['games', 'math']",800
https://codeforces.com//contest/1783/problem/A,A. Make it Beautiful,An array a is called if it contains element which is equal to the If the array is not ugly it is For example the array 6 3 9 6 is ugly the element 9 is equal to 6 3 the array 5 5 7 is ugly the element 5 the second one is equal to 5 the array 8 4 10 14 is beautiful 8 ne 0 4 ne 8 10 ne 8 4 14 ne 8 4 10 so there is no element which is equal to the sum of all elements before it You are given an array a such that 1 le a 1 le a 2 le dots le a n le 100 You have to the elements of a in such a way that the resulting array is beautiful Note that you are not allowed to insert new elements or erase existing ones you can only change the order of elements of a You are allowed to keep the array a unchanged if it is beautiful ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    if (a[0] == a[n - 1]) {\n        std::cout << ""NO\\n"";\n    } else {\n        std::cout << ""YES\\n"";\n        std::reverse(a.begin() + 1, a.end());\n        for (int i = 0; i < n; i++) {\n            std::cout << a[i] << "" \\n""[i == n - 1];\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'math', 'sortings']",800
https://codeforces.com//contest/1618/problem/G,G. Trader Problem,Monocarp plays a computer game yet again This game has a unique trading mechanics To trade with a character Monocarp has to choose one of the items he possesses and trade it for some item the other character possesses Each item has an integer price If Monocarp s chosen item has price x then he can trade it for any item with price not greater than x k Monocarp initially has n items the price of the i th item he has is a i The character Monocarp is trading with has m items the price of the i th item they have is b i Monocarp can trade with this character as many times as he wants possibly even zero times each time exchanging one of his items with one of the other character s items according to the aforementioned constraints Note that if Monocarp gets some item during an exchange he can trade it for another item since now the item belongs to him and vice versa if Monocarp trades one of his items for another item he can get his item back by trading something for it You have to answer q queries Each query consists of one integer which is the value of k and asks you to calculate the maximum possible total cost of items Monocarp can have after some sequence of trades assuming that he can trade an item of cost x for an item of cost not greater than x k during each trade Note that the queries are independent the trades do not actually occur Monocarp only wants to calculate the maximum total cost he can get ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,h,t) for (int i=h;i<=t;i++)\n#define dep(i,t,h) for (int i=t;i>=h;i--)\n#define ll long long\nconst int N=5e5;\nint n,m,q;\nint fa[N];\nint find(int x)\n{\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nstruct re{\n\tint a,b;\n};\nre a[N],c[N];\nll ans[N],v[N],v2[N],v3[N],sum[N];\nbool cmp(re x,re y)\n{\n\treturn x.a<y.a;\n}\nset<pair<int,int> >S; \nint main()\n{\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>n>>m>>q;\n\tll now=0;\n\trep(i,1,n)\n\t{ \n\t  cin>>a[i].a; a[i].b=1;\n\t  now+=a[i].a;\n    }\n    rep(i,n+1,n+m)\n    {\n    \tcin>>a[i].a; a[i].b=0; \n    }\n    rep(i,1,n+m) fa[i]=i;\n    sort(a+1,a+n+m+1,cmp);\n    rep(i,1,n+m)\n\t{\n\t\tsum[i]=sum[i-1]+a[i].a;\n\t\tv[i]=a[i].a*a[i].b,v2[i]=a[i].b;\n\t\tv3[i]=i;\n    }\n    rep(i,2,n+m)\n      S.insert(make_pair(a[i].a-a[i-1].a,i));\n    rep(i,1,q) { cin>>c[i].a; c[i].b=i;}\n    sort(c+1,c+q+1,cmp);\n    rep(i,1,q)\n    {\n    \twhile (!S.empty()&&(*S.begin()).first<=c[i].a)\n    \t{\n    \t\tint h=(*S.begin()).second;\n    \t\tint f1=find(h),f2=find(h-1);\n    \t\tnow-=v[f1]; now-=v[f2];\n    \t\tfa[f1]=f2;\n    \t\tv2[f2]+=v2[f1];\n    \t\tv3[f2]=max(v3[f2],v3[f1]);\n    \t\tv[f2]=sum[v3[f2]]-sum[v3[f2]-v2[f2]];\n    \t\tnow+=v[f2];\n    \t\tS.erase(S.begin());\n    \t}\n    \tans[c[i].b]=now;\n    }\n    rep(i,1,q) cout<<ans[i]<<""\\n"";\n\treturn 0;\n}']","['data structures', 'dsu', 'greedy', 'sortings']",2200
https://codeforces.com//contest/235/problem/C,C. Cyclical Quest,Some days ago WJMZBMR learned how to answer the query how many times does a string occur in a string quickly by preprocessing the string But now he wants to make it harder So he wants to ask how many consecutive substrings of are cyclical isomorphic to a given string You are given string and strings for each string find how many consecutive substrings of are cyclical isomorphic to Two strings are called if one can rotate one string to get the other one Rotate here means to take some consecutive chars maybe none from the beginning of a string and put them back at the end of the string in the same order For example string can be rotated to string We can take characters from the beginning and put them at the end of ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nchar buf[1000010];\nstring s,t;\n\n#define MAXN 1000000\nstruct state {int parent, maxlen; map <char, int> edge;};\nint S;\nstate node[2*MAXN+10];\n\nvoid suffix_automaton(void){\n    int i,j;\n    \n    node[0].parent = -1;\n    S = 1;\n    int prev = 0;\n    \n    REP(i,s.length()){\n        char c = s[i];\n        \n        int cur = S; S++;\n        node[cur].maxlen = i + 1;\n        \n        int p = prev;\n        while(p != -1){\n            if(node[p].edge.find(c) != node[p].edge.end()) break;\n            node[p].edge[c] = cur;\n            p = node[p].parent;\n        }\n        \n        if(p != -1){\n            int q = node[p].edge[c];\n            \n            if(node[q].maxlen == node[p].maxlen + 1){\n                node[cur].parent = q;\n            } else {\n                int q2 = S; S++;\n                node[q2].parent = node[q].parent;\n                node[q2].maxlen = node[p].maxlen + 1;\n                node[q2].edge = node[q].edge;\n                node[cur].parent = node[q].parent = q2;\n                \n                int r = p;\n                while(r != -1){\n                    if(node[r].edge.find(c) == node[r].edge.end() || node[r].edge[c] != q) break;\n                    node[r].edge[c] = q2;\n                    r = node[r].parent;\n                }\n            }\n        }\n        \n        prev = cur;\n    }\n}\n\nvector <int> child[2000010];\nint cnt[2000010];\nint minlen[2000010];\n\nvoid dfs(int x){\n    int i;\n    \n    REP(i,child[x].size()){\n        dfs(child[x][i]);\n        cnt[x] += cnt[child[x][i]];\n    }\n}\n\nint func(void){\n    int i;\n    \n    REP(i,S) if(node[i].parent != -1) minlen[i] = node[node[i].parent].maxlen + 1;\n    REP(i,S) if(node[i].parent != -1) child[node[i].parent].push_back(i);\n    \n    int x = 0;\n    REP(i,s.length()){\n        x = node[x].edge[s[i]];\n        cnt[x]++;\n    }\n    \n    dfs(0);\n}\n\nint query(int cycle){\n    int N=t.length(),i=0,j=0,x=0,ans=0;\n    \n    while(1){\n        char c = t[j%N];\n        while(i < j && node[x].edge.find(c) == node[x].edge.end()){\n            if(minlen[x] == j-i) x = node[x].parent;\n            i++;\n        }\n        \n        if(node[x].edge.find(c) == node[x].edge.end()){\n            i++; j++;\n        } else {\n            x = node[x].edge[c];\n            j++;\n        }\n        \n        if(j >= N + cycle) break;\n        if(j >= N && j-i >= N){\n            while(j-i > N){\n                if(minlen[x] == j-i) x = node[x].parent;\n                i++;\n            }\n            ans += cnt[x];\n        }\n    }\n    \n    return ans;\n}\n\nint fail[1000010],pre[1000010];\n\nvoid failure(void){\n    int i,j=-1;\n    fail[0] = -1;\n    REP(i,t.length()){\n        while(j >= 0 && t[i] != t[j]) j = fail[j];\n        j++;\n        fail[i+1] = j;\n    }\n}\n\nint kmp(void){ // [i-pre[i], i) matches\n    int N=t.length(),i,j=0;\n    for(i=0;;i++){\n        while(j == N || (j >= 0 && t[i%N] != t[j])) j = fail[j];\n        j++;\n        if(j == N && i+1 > N) return i+1-N;\n    }\n}\n\nint min_cycle(void){\n    failure();\n    return kmp();\n}\n\nint main(void){\n    int Q,i;\n    \n    scanf(""%s"",buf); s = buf;\n    suffix_automaton();\n    func();\n    \n    scanf(""%d"",&Q);\n    REP(i,Q){\n        scanf(""%s"",buf); t = buf;\n        int cycle = min_cycle();\n        int ans = query(cycle);\n        printf(""%d\\n"", ans);\n    }\n    \n    return 0;\n}\n']","['data structures', 'string suffix structures', 'strings']",2700
https://codeforces.com//contest/1282/problem/C,C. Petya and Exam,Petya has come to the math exam and wants to solve as many problems as possible He prepared and carefully studied the rules by which the exam passes The exam consists of n problems that can be solved in T minutes Thus the exam begins at time 0 and ends at time T Petya can leave the exam at any integer time from 0 to T inclusive All problems are divided into two types easy problems Petya takes exactly a minutes to solve any easy problem hard problems Petya takes exactly b minutes b a to solve any hard problem Thus if Petya starts solving an easy problem at time x then it will be solved at time x a Similarly if at a time x Petya starts to solve a hard problem then it will be solved at time x b For every problem Petya knows if it is easy or hard Also for each problem is determined time t i 0 le t i le T at which it will become required If Petya leaves the exam at time s and there is such a problem i that t i le s and he didn t solve it then he will receive 0 points for the whole exam Otherwise i e if he has solved all such problems for which t i le s he will receive a number of points equal to the number of solved problems Note that leaving at time s Petya can have both mandatory and non mandatory problems solved For example if n 2 T 5 a 2 b 3 the first problem is hard and t 1 3 and the second problem is easy and t 2 2 Then if he leaves at time s 0 then he will receive 0 points since he will not have time to solve any problems if he leaves at time s 1 he will receive 0 points since he will not have time to solve any problems if he leaves at time s 2 then he can get a 1 point by solving the problem with the number 2 it must be solved in the range from 0 to 2 if he leaves at time s 3 then he will receive 0 points since at this moment both problems will be mandatory but he will not be able to solve both of them if he leaves at time s 4 then he will receive 0 points since at this moment both problems will be mandatory but he will not be able to solve both of them if he leaves at time s 5 then he can get 2 points by solving all problems Thus the answer to this test is 2 Help Petya to determine the maximal number of points that he can receive before leaving the exam ,"['#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nll b[MAXN], c[MAXN];\npii a[MAXN];\nvector<ll> f;\nvector<ll> g[MAXN];\nvoid solve() {\n    ll n, T, x, y;\n    cin >> n >> T >> x >> y;\n    ll sum1 = 0, sum2 = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].Y;\n        if (a[i].Y) {\n            sum2++;\n        } else {\n            sum1++;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].X;\n    }\n    if (sum1 * x + sum2 * y <= T) {\n        cout << n << ""\\n"";\n        return;\n    }\n    sort(a, a+n);\n    ll totsum1 = sum1;\n    ll totsum2 = sum2;\n    sum1 = 0;\n    sum2 = 0;\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (i > 0) {\n            if (a[i - 1].Y) {\n                sum2++;\n            } else {\n                sum1++;\n            }\n        }\n        if (a[i].X - 1 >= sum1 * x + sum2 * y) {\n            ll lft = a[i].X - 1 - (sum1 * x + sum2 * y);\n            ll lft1 = totsum1 - sum1;\n            ll lft2 = totsum2 - sum2;\n            ll sum = sum1 + sum2;\n            if (lft1 * x >= lft) {\n                sum += lft / x;\n            } else {\n                sum += lft1 + min(lft2, (lft - lft1 * x) / y);\n            }\n            ans = max(ans, sum);\n        }\n    }\n    cout << ans << ""\\n"";\n\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n    return 0;\n}']","['greedy', 'sortings', 'two pointers']",1800
https://codeforces.com//contest/56/problem/D,D. Changing a String,There is a string consisting of capital Latin letters Let s denote its current length as During one move it is allowed to apply one of the following operations to it insert a letter in the string in the position The letter becomes the th symbol of the string at that the letters shift aside and the length of the string increases by 1 delete a character number from the string At that the letters shift together and the length of the string decreases by 1 the letter in the position of the line is replaced by At that the length of the string does not change Your task is to find in which minimal number of moves one can get a string from an string You should also find the sequence of actions leading to the required results ,"['//#pragma comment(linker,""/STACK:256000000"")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\n\n#define ldb long double\n#define LL long long\n#define nextline() {int c; while ((c = getchar()) != 10 && c != EOF);}\n\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n\n#define sqr(x) ((x) * (x))\n#define ABS(a) ((a)<0?-(a):(a))\n#define EQ(a,b) (ABS((a)-(b))<EPS)\n\n#define all(a) a.begin(), a.end()\n#define two(i) (1 << (i))\n#define has(mask, i) ((((mask) & two(i)) == 0) ? false : true)\n\nconst int inf = 1000 * 1000 * 1000;\nconst LL inf64 = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;\n\n\n#define MAXN 1000\n\nstring a, b;\nint n, m;\nint dp[2000][2000];\nint wh[2000][2000];\n\nvoid Load()\n{\t\n\tcin >> a >> b;\n}\n\nint rec (int pos, int s)\n{\n\n\tif (s == n && pos == m)\n\t\treturn 0;\n\tif (s > n)\n\t\treturn inf;\n\n\tif (pos == m)\n\t{\n\t\tassert (n > s);\n\t\treturn n - s;\n\t}\n\tif (dp[pos][s] != -1)\n\t\treturn dp[pos][s];\n\n\tint cur = inf;\n\tint mn = inf;\n\tint w = -1;\n\n\tif (b[pos] == a[s])\n\t\tcur =  rec (pos + 1, s + 1);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 0;\n\t}\n\n\tcur = 1 + rec (pos, s + 1);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 1;\n\t}\n\n\tcur = 1 + rec (pos + 1, s + 1);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 2;\n\t}\n\tcur = 1 + rec (pos + 1, s);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 3;\n\t}\n\tdp[pos][s] = mn;\n\twh[pos][s] = w;\n\treturn mn;\n}\n\nvoid out (int pos, int s)\n{\n\tcerr << pos << "" "" << s << "" -> "" << wh[pos][s] << ""\\n"" ;\n\tif (s == n && m == pos)\n\t\treturn;\n\n\tif (pos == m)\n\t{\n\t\tfor (int i = 0; i < n - s; i++)\n\t\t\tprintf (""DELETE %d\\n"", m + 1);\n\t\treturn;\n\t}\n\tif (wh[pos][s] == 0)\n\t\tout (pos + 1, s + 1);\n\tif (wh[pos][s] == 1)\n\t{\n\t\tprintf (""DELETE %d\\n"", pos + 1);\n\t\tout (pos, s + 1);\n\t}\n\tif (wh[pos][s] == 2)\n\t{\n\t\tprintf (""REPLACE %d %c\\n"", pos + 1, b[pos]);\n\t\tout (pos + 1, s + 1);\n\t}\n\tif (wh[pos][s] == 3)\n\t{\n\t\tprintf (""INSERT %d %c\\n"" , pos + 1, b[pos]);\n\t\tout (pos + 1, s);\n\t}\n\n}\n\nvoid Solve()\n{\n\tn = a.size();\n\tm = b.size();\n\tmemset (dp, 0xFF, sizeof (dp));\n\tcout << rec (0, 0) << ""\\n"";\n\tout (0, 0);\n}\n                \nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n#ifndef ONLINE_JUDGE\n\tfreopen(""in"", ""rt"", stdin);\n\tfreopen(""out"", ""wt"", stdout);\n#endif\n\n\tLoad();\n\tSolve();\n\treturn 0;\n}\n']",['dp'],2100
https://codeforces.com//contest/1920/problem/D,D. Array Repetition,Jayden has an array a which is initially empty There are n operations of two types he must perform in the given order Jayden appends an integer x 1 leq x leq n to the end of array a Jayden appends x copies of array a to the end of array a In other words array a becomes a underbrace a ldots a x It is guaranteed that he has done at least one operation of the first type before this Jayden has q queries For each query you must tell him the k th element of array a The elements of the array are numbered from 1 ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int N=1e5+1, inf=2e18;\nint n, q, cnt[N];\npair<int, int> a[N];\npair<int, vector<int>> b[N];\n\nvoid solve(){\n   cin >> n >> q;\n   int m=0, sz=0;\n   for (int i=1; i<=n; ++i){\n      cin >> a[i].first >> a[i].second;\n      if (m && b[m].first==1 && a[i].first==1) b[m].second.push_back(a[i].second);\n      else b[++m]={a[i].first, {a[i].second}};\n   }\n   for (int i=1; i<=m; ++i){\n      if (b[i].first==1){\n         sz=min(sz+isz(b[i].second), inf);\n      }else{\n         if (sz>=inf/(b[i].second[0]+1)) sz=inf;\n         else sz*=(b[i].second[0]+1);\n      }\n      cnt[i]=sz;\n   }\n   int m2=m;\n   while (cnt[m-1]==inf) --m;\n   for (int i=1; i<=q; ++i){\n      int idx; cin >> idx;\n      int ans=-1;\n      for (int j=m; j>=1; --j){\n         if (b[j].first==1){\n            if (cnt[j]-idx+1<=isz(b[j].second)){\n               ans=b[j].second[idx-(cnt[j]-isz(b[j].second))-1];\n               break;\n            }\n         }else{\n            int prev_sz=cnt[j-1];\n            idx=(idx-1)%prev_sz+1;\n         }\n      }\n      cout << ans << ' ';\n   }\n   cout << '\\n';\n   for (int i=1; i<=m2; ++i) b[i]={0, {}};\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n""]","['binary search', 'brute force', 'dsu', 'implementation', 'math']",1900
https://codeforces.com//contest/1005/problem/D,D. Polycarp and Div 3,Polycarp likes numbers that are divisible by 3 He has a huge number s Polycarp wants to cut from it the maximum number of numbers that are divisible by 3 To do this he makes an arbitrary number of vertical cuts between pairs of adjacent digits As a result after m such cuts there will be m 1 parts in total Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by 3 For example if the original number is s 3121 then Polycarp can cut it into three parts with two cuts 3 1 21 As a result he will get two numbers that are divisible by 3 Polycarp can make an arbitrary number of vertical cuts where each cut is made between a pair of adjacent digits The resulting numbers cannot contain extra leading zeroes that is the number can begin with if and only if this number is exactly one character For example and are not valid numbers but and are valid What is the maximum number of numbers divisible by 3 that Polycarp can obtain ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    string s;\n    cin >> s;\n    int sc = 0;\n\n    set<int> A;\n\n    for (int i: s) {\n        set<int> B;\n        i -= \'0\';\n        bool cut = 0;\n\n        for (int j: A) {\n            B.in(j+i);\n        }\n        B.in(i);\n        set<int> C;\n        for (int j: B) {\n            if (j % 3) {\n                C.in(j % 3);\n            } else {\n                cut = 1;\n            }\n        }\n\n        if (!cut) {\n            swap(A, C);\n        } else {\n            A.clear();\n            sc++;\n        }\n\n    }\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n']","['dp', 'greedy', 'number theory']",1500
https://codeforces.com//contest/1000/problem/C,C. Covered Points Count,You are given n segments on a coordinate line each endpoint of every segment has integer coordinates Some segments can degenerate to points Segments can intersect with each other be nested in each other or even coincide Your task is the following for every k in 1 n calculate the number of points with integer coordinates such that the number of segments that cover these points equals k A segment with endpoints l i and r i covers point x if and only if l i le x le r i ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 200100;\nconst long long Q = 2e18;\nconst long long mod = 1e9 + 7;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nlong long d[N];\nvector < pair < long long, int > > v;\n\nvoid solve()\n{\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                long long l, r;\n                cin >> l >> r;\n                v.push_back({l, 1});\n                v.push_back({r + 1, -1});\n        }\n        sort(v.begin(), v.end());\n        long long cnt = 0;\n        for(int i = 0; i < v.size(); i++){\n                cnt += v[i].se;\n                if(i + 1 < v.size() && v[i].fi != v[i + 1].fi){\n                        d[cnt] += v[i + 1].fi - v[i].fi;\n                }\n        }\n        for(int i = 1; i <= n; i++){\n                cout << d[i] << "" "";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","['data structures', 'implementation', 'sortings']",1700
https://codeforces.com//contest/613/problem/B,B. Skills,Lesha plays the recently published new version of the legendary game hacknet In this version character skill mechanism was introduced Now each player character has exactly skills Each skill is represented by a non negative integer the current skill level All skills have the same maximum level Along with the skills global ranking of all players was added Players are ranked according to the so called Force The of a player is the sum of the following values The number of skills that a character has perfected i e such that multiplied by coefficient The minimum skill level among all skills multiplied by coefficient Now Lesha has hacknetian currency units which he is willing to spend Each currency unit can increase the current level of any skill by if it s not equal to yet Help him spend his money in order to achieve the maximum possible value of the Force ,"['#include<cassert>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A, cf, cm;\n\nlong long m;\n\nint a[N], b[N], ord[N];\n\nlong long sum[N];\n\nbool byA(const int &i, const int &j) {\n    return a[i] < a[j];\n}\n\nint main() {\n    scanf(""%d%d%d%d"", &n, &A, &cf, &cm);\n    cin >> m;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", a + i);\n        b[i] = a[i];\n        ord[i] = i;\n    }\n    sort(ord, ord + n, byA);\n    sort(a, a + n);\n    for (int i = 0; i < n; ++i) {\n        sum[i + 1] = sum[i] + a[i];\n    }\n    long long ans = -1, ansi = -1, ansm = -1;\n    for (int i = 0, j = 0; i <= n; ++i) {\n        //i to n - 1 shall be all perfect then maxmize the minimum among 0 to i - 1\n        long long cost = 0, tmp = 0;\n        cost = (long long)A * (n - i) - (sum[n] - sum[i]);\n        if (cost > m) {\n            continue;\n        }\n        tmp += (n - i) * cf;\n        long long left = m - cost;\n        while (j < i && (long long)j * a[j] - sum[j] <= left) {\n            ++j;\n        }\n        int mins = 0;\n        if (j) {\n            mins = min((long long)A, (left + sum[j]) / j);\n        } else {\n            mins = A;\n        }\n        tmp += (long long)mins * cm;\n        if (tmp > ans) {\n            ans = tmp;\n            ansi = i;\n            ansm = mins;\n        }\n    }\n    cout << ans << endl;\n    long long cost = 0, mins = A, maxs = 0;\n    for (int i = 0; i < n; ++i) {\n        int delta = 0, u = b[ord[i]];\n        if (i >= ansi) {\n            delta = A - u;\n        } else {\n            delta = max(0ll, ansm - u);\n        }\n        b[ord[i]] += delta;\n        cost += delta;\n        mins = min(mins, (long long)b[ord[i]]);\n        maxs += b[ord[i]] == A;\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(""%d%c"", b[i], i == n - 1 ? \'\\n\' : \' \');\n    }\n    assert(cost <= m && mins * cm + maxs * cf == ans);\n    return 0;\n}']","['binary search', 'brute force', 'dp', 'greedy', 'sortings', 'two pointers']",1900
https://codeforces.com//contest/1304/problem/F2,F2. Animal Observation  hard version ,k Gildong loves observing animals so he bought two cameras to take videos of wild animals in a forest The color of one camera is red and the other one s color is blue Gildong is going to take videos for n days starting from day 1 to day n The forest can be divided into m areas numbered from 1 to m He ll use the cameras in the following way On every odd day 1 st 3 rd 5 th bring the red camera to the forest and record a video for 2 days On every even day 2 nd 4 th 6 th bring the blue camera to the forest and record a video for 2 days If he starts recording on the n th day with one of the cameras the camera records for only one day Each camera can observe k consecutive areas of the forest For example if m 5 and k 3 he can put a camera to observe one of these three ranges of areas for two days 1 3 2 4 and 3 5 Gildong got information about how many animals will be seen in each area on each day Since he would like to observe as many animals as possible he wants you to find the best way to place the two cameras for n days ,"['#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N , M , K , dp[53][20003] , sum[503][20003];\n\nint main(){\n\tcin>>N>>M>>K;\n\tfor(int i = 1 ; i <= N ; ++i)\n\t\tfor(int j = 1; j <= M ; ++j){\n\t\t\tcin>>sum[i][j]; sum[i][j] += sum[i][j -1 ];\n\t\t}\n\tmemset(dp , -0x1f , sizeof(dp));\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) dp[1][i] = sum[1][i + K - 1] - sum[1][i - 1] + sum[2][i + K - 1] - sum[2][i - 1];\n\tfor(int i = 2 ; i <= N ; ++i){\n\t\tdeque < int > q;\n\t\tfor(int j = 1 ; j <= K && j <= M - K + 1 ; ++j){\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][j] + sum[i][j - 1]) q.pop_back();\n\t\t\tq.push_back(j);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] + sum[i][q.front() - 1] - sum[i][j - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j + K <= M - K + 1){\n\t\t\t\tint t = j + K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][t] + sum[i][t - 1]) q.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tq.clear();\n\t\tfor(int j = 1 ; j <= M - K + 1 && j <= K ; ++j){\n\t\t\tint t = M - K + 2 - j;\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\tq.pop_back();\n\t\t\tq.push_back(t);\n\t\t}\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] - sum[i][q.front() + K - 1] + sum[i][j + K - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j - K > 0){\n\t\t\t\tint t = j - K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\t\tq.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tfor(int j = 1 ; j <= M - K + 1; ++j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j + K <= M - K + 1) dp[i][j + K] = max(dp[i][j + K] , mx + sum[i][j + K + K - 1] - sum[i][j + K - 1]);\n\t\t}\n\t\tmx = 0;\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j - K > 0) dp[i][j - K] = max(dp[i][j - K] , mx + sum[i][j - 1] - sum[i][j - K - 1]);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j)\n\t\t\tdp[i][j] += sum[i + 1][j + K - 1] - sum[i + 1][j - 1];\n\t}\n\tint mx = 0;\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) mx = max(mx , dp[N][i]);\n\tcout << mx;\n\treturn 0;\n}\n']","['data structures', 'dp', 'greedy']",2400
https://codeforces.com//contest/800/problem/A,A. Voltage Keepsake,You have devices that you want to use simultaneously The th device uses units of power per second This usage is continuous That is in seconds the device will use units of power The th device currently has units of power stored All devices can store an arbitrary amount of power You have a single charger that can plug to any single device The charger will add units of power per second to a device This charging is continuous That is if you plug in a device for seconds it will gain units of power You can switch which device is charging at any arbitrary unit of time including real numbers and the time it takes to switch is negligible You are wondering what is the maximum amount of time you can use the devices until one of them hits units of power If you can use the devices indefinitely print Otherwise print the maximum amount of time before any one device hits power ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\n\nstruct Input {\n\tint n, p;\n\tint a[N], b[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> p)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d%d"", &a[i], &b[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tld ans;\n\t\n\tvoid write () {\n\t\tif (ans == -1) {\n\t\t\tputs(""-1"");\n\t\t\treturn;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\n\t\tbool check (ld x) {\n\t\t\tld sum = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tsum += max<ld>(0, a[i] * x - b[i]);\n\t\t\t}\n\t\t\treturn p * x > sum;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tll sum = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\tif (sum <= p) {\n\t\t\t\tans = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tld l = 0, r = 1e18;\n\t\t\tforn (i, 100) {\n\t\t\t\tld md = (l + r) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\tl = md;\n\t\t\t\t} else {\n\t\t\t\t\tr = md;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (l + r) / 2;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + "".in"").c_str(), ""r"", stdin);\n//\t\tfreopen((problemname + "".out"").c_str(), ""w"", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n']","['binary search', 'greedy']",1800
https://codeforces.com//contest/1537/problem/E1,E1. Erase and Extend  Easy Version ,You have a string s and you can do two types of operations on it Delete the last character of the string Duplicate the string s s s where denotes concatenation You can use each operation any number of times possibly none Your task is to find the lexicographically smallest string of length exactly k that can be obtained by doing these operations on string s A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b In the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include ""map""\ntypedef double ld;\ntypedef long long ll;\n#define all(x) x.begin(), x.end()\nusing namespace std;\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int ind = 0;\n    string s2;\n    s2 += s[0];\n    // 4 3 4 2 4 4\n    for (int i = 1; i < n; ++i) {\n        if (s[i] > s[ind])\n            break;\n        s2 += s[i];\n        if (s[i] == s[ind]) {\n            ind++;\n        } else {\n            ind = 0;\n        }\n    }\n    while (ind != 0) {\n        s2.pop_back();\n        ind--;\n    }\n    for (int i = 0; i < k; ++i) {\n        cout << s2[i % s2.size()];\n    }\n    cout << \'\\n\';\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q = 1;\n    while (q--) solve();\n}\n']","['binary search', 'brute force', 'dp', 'greedy', 'hashing', 'implementation', 'string suffix structures', 'strings', 'two pointers']",1600
https://codeforces.com//contest/378/problem/B,B. Semifinals,Two semifinals have just been in the running tournament Each semifinal had participants There are participants advancing to the finals they are chosen as follows from each semifinal we choose people who showed the best result in their semifinals and all other places in the finals go to the people who haven t ranked in the top in their semifinal but got to the of the best among the others The tournament organizers hasn t yet determined the value so the participants want to know who else has any chance to get to the finals and who can go home ,"['#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nchar A[200000];\nchar B[200000];\nint n;\nint C[200000];\nint D[200000];\n\nint main() {\n  scanf (""%d"", &n);\n  for (int i = 0; i < n; ++i) scanf (""%d %d"", C + i, D + i);\n\n  A[n] = 0;\n  B[n] = 0;\n  for (int i = 0; i < n/2; ++i) A[i] = B[i] = \'1\';\n  for (int i = n/2; i < n; ++i) A[i] = B[i] = \'0\';\n\n  int a = 0, b = 0;\n  for (int i = 0; i < n; ++i) {\n    if (C[a] < D[b]) {A[a] = \'1\'; ++a;}\n    else {B[b] = \'1\'; ++b;}\n  }\n\n  printf(""%s\\n%s\\n"", A, B);\n\n  return 0;\n}']","['implementation', 'sortings']",1300
https://codeforces.com//contest/1809/problem/F,F. Traveling in Berland,There are n cities in Berland arranged in a circle and numbered from 1 to n in clockwise order You want to travel all over Berland starting in some city visiting all the other cities and returning to the starting city Unfortunately you can only drive along the Berland Ring Highway which connects all n cities The road was designed by a very titled and respectable minister so it is one directional it can only be traversed clockwise only from the city i to the city i bmod n 1 i e from 1 to 2 from 2 in 3 from n to 1 The fuel tank of your car holds up to k liters of fuel To drive from the i th city to the next one a i liters of fuel are needed and are consumed in the process Every city has a fuel station a liter of fuel in the i th city costs b i burles Refueling between cities is not allowed if fuel has run out between cities then your journey is considered incomplete For each city calculate the minimum cost of the journey if you start and finish it in that city ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    \n    std::vector<i64> f(2 * n + 1);\n    for (int i = 0; i < 2 * n; i++) {\n        f[i + 1] = f[i] + a[i % n];\n    }\n    \n    int last = -1;\n    std::vector<int> pre(2 * n);\n    for (int i = 0; i < 2 * n; i++) {\n        if (b[i % n] == 1) {\n            last = i;\n        }\n        pre[i] = last;\n    }\n    \n    std::vector<i64> ans(n);\n    ans[0] += sum;\n    for (int i = 0; i < 2 * n - 1; i++) {\n        if (b[i % n] == 2) {\n            if (pre[i] == -1) {\n                ans[std::max(0, i - n + 1)] += a[i % n];\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            } else {\n                int v = std::max(0LL, std::min(1LL * a[i % n], f[i + 1] - f[pre[i]] - k));\n                ans[std::max(0, i - n + 1)] += v;\n                if (pre[i] + 1 < n) {\n                    ans[pre[i] + 1] += a[i % n] - v;\n                }\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        ans[i] += ans[i - 1];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['binary search', 'data structures', 'graphs', 'greedy', 'implementation']",2500
https://codeforces.com//contest/752/problem/A,A. Santa Claus and a Place in a Class,Santa Claus is the first who came to the Christmas Olympiad and he is going to be the first to take his place at a desk In the classroom there are lanes of desks each and there are two working places at each of the desks The lanes are numbered from to from the left to the right the desks in a lane are numbered from to starting from the blackboard Note that the lanes go perpendicularly to the blackboard not along it see picture The organizers numbered all the working places from to The places are numbered by lanes i e all the places of the first lane go first then all the places of the second lane and so on in a lane the places are numbered starting from the nearest to the blackboard i e from the first desk in the lane at each desk the place on the left is numbered before the place on the right Santa Clause knows that his place has number Help him to determine at which lane at which desk he should sit and whether his place is on the left or on the right ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N, M, K;\n\nint main () {\n\tscanf(""%d %d %d"", &N, &M, &K);\n\tint R = (K-1) / (2*M) + 1;\n\tint C = (((K-1) % (2*M))/2) + 1;\n\tprintf(""%d %d %c\\n"", R, C, (K&1) ? \'L\' : \'R\');\n\treturn 0;\n}\n']","['constructive algorithms', 'math']",800
https://codeforces.com//contest/1829/problem/C,C. Mr. Perfectly Fine,Victor wants to become For that he needs to acquire a certain set of skills More precisely he has 2 skills he needs to acquire Victor has n books Reading book i takes him m i minutes and will give him some possibly none of the required two skills represented by a binary string of length 2 What is the minimum amount of time required so that Victor acquires all of the two skills ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n#define fi first\n#define se second\n\nint n;\npair<int, string> a[N];\n\nvoid solve() {\n    cin >> n;\n    bool f1 = 0, f2 = 0;\n    rep(i, 1, n) {\n        cin >> a[i].fi >> a[i].se;\n        if (a[i].se[0] == \'1\') f1 = 1;\n        if (a[i].se[1] == \'1\') f2 = 1;\n    }\n\n    if (!f1 || !f2) {\n        cout << ""-1\\n"";\n        return;\n    }\n\n    int res = 1e9, t1 = 1e9, t2 = 1e9;\n    rep(i, 1, n) {\n        if (a[i].se == ""11"") res = min(res, a[i].fi);\n        if (a[i].se[0] == \'1\') t1 = min(t1, a[i].fi);\n        if (a[i].se[1] == \'1\') t2 = min(t2, a[i].fi);\n    }\n    res = min(res, t1 + t2);\n    cout << res << \'\\n\';\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","['bitmasks', 'greedy', 'implementation']",800
https://codeforces.com//contest/1540/problem/A,A. Great Graphs,Farmer John has a farm that consists of n pastures connected by one directional roads Each road has a weight representing the time it takes to go from the start to the end of the road The roads could have negative weight where the cows go so fast that they go back in time However Farmer John guarantees that it is impossible for the cows to get stuck in a time loop where they can infinitely go back in time by traveling across a sequence of roads Also each pair of pastures is connected by at most one road in each direction Unfortunately Farmer John lost the map of the farm All he remembers is an array d where d i is the smallest amount of time it took the cows to reach the i th pasture from pasture 1 using a sequence of roads The cost of his farm is the sum of the weights of each of the roads and Farmer John needs to know the cost of a farm that is consistent with his memory ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//デバッグ実行でオーバーフローするとコアダンプしがち\n\nusing int128=__int128_t;\nusing uint128=unsigned __int128_t;\n\nistream& operator>>(istream&is,int128&res){\n\tres=0;\n\tstring s;is>>s;\n\tint head=0;\n\tint128 w=1;\n\tif(s[0]==\'-\'){\n\t\tw=-1;\n\t\thead++;\n\t}\n\twhile(head<int(s.size())){\n\t\tres=res*10+s[head++]-\'0\';\n\t}\n\tres*=w;\n\treturn is;\n}\nostream& operator<<(ostream&os,int128 i){\n\tif(i==0)\n\t\treturn os<<0;\n\tstatic char buf[100];\n\tif(i<0){\n\t\tos<<""-"";\n\t\ti=-i;\n\t}\n\tint p=0;\n\twhile(i){\n\t\tbuf[p++]=\'0\'+i%10;\n\t\ti/=10;\n\t}\n\treverse(buf,buf+p);\n\tbuf[p]=0;\n\treturn os<<buf;\n}\nint128 abs128(int128 a){\n\treturn a<0?-a:a;\n}\nint botbit(int128 a){\n\tconst int128 m=(int128(1)<<64)-1;\n\tif(a&m)return __builtin_ctzll(ll(a));\n\telse return __builtin_ctzll(ll(a>>64));\n}\nint128 gcd(int128 a,int128 b){\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tint128 s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\treturn a<<s;\n}\nconst int128 inf128=int128(1)<<122;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tsort(all(a));\n\tint128 ans=0;\n\t\n\tint sum=0;\n\trep(i,n){\n\t\tans+=a[i]*i-sum;\n\t\tsum+=a[i];\n\t}\n\tans-=a[n-1];\n\t\n\tcout<<-ans<<endl;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['constructive algorithms', 'graphs', 'greedy', 'shortest paths', 'sortings']",1400
https://codeforces.com//contest/256/problem/E,E. Lucky Arrays,Little Maxim loves interesting problems He decided to share one such problem with you Initially there is an array consisting of zeroes The elements of the array are indexed starting from 1 Then follow queries to change array Each query is characterized by two integers In the answer to the query we should make the th array element equal Maxim thinks that some pairs of integers are good and some are not Maxim thinks that array consisting of integers is lucky if for all integer the pair of integers is good Note that the order of numbers in the pairs is important that is specifically After each query to change array Maxim wants to know how many ways there are to replace all zeroes in array with integers from one to three so as to make the resulting array without zeroes lucky Of course distinct zeroes can be replaced by distinct integers Maxim told you the sequence of queries and all pairs of integers he considers lucky Help Maxim solve this problem for him ,"['/*\n * cd2.cpp\n *\n *  Created on: 2012-12-17\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 77777 + 10;\nconst int MOD = 777777777;\n\nint n, nQ;\nint w[3][3];\n\ntypedef long long int64;\n\nstruct Tree {\n\tint c[3][3];\n\tTree*pl, *pr;\n\tint l, r;\n\n\tvoid update() {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tint64 k = 0;\n\t\t\t\tfor (int pi = 0; pi < 3; ++pi) {\n\t\t\t\t\tfor (int pj = 0; pj < 3; ++pj)\n\t\t\t\t\t\tif (w[pi][pj]) {\n\t\t\t\t\t\t\tk += 1LL * pl->c[i][pi] * pr->c[pj][j];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i][j] = k % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tTree(int l, int r) :\n\t\t\tl(l), r(r) {\n\t\tmemset(c, 0, sizeof c);\n\t\tif (l + 1 == r) {\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tc[i][i] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl = new Tree(l, l + r >> 1);\n\t\tpr = new Tree(l + r >> 1, r);\n\t\tupdate();\n\t}\n\n\tvoid change(int i, int x) {\n\t\tif (i < l || i >= r)\n\t\t\treturn;\n\t\tif (l + 1 == r) {\n\t\t\tif (x == 0) {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\tc[j][j] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tc[x - 1][x - 1] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl->change(i, x);\n\t\tpr->change(i, x);\n\t\tupdate();\n\t}\n}*root;\n\nint main() {\n\tcin >> n >> nQ;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tcin >> w[i][j];\n\t\t}\n\t}\n\troot = new Tree(0, n);\n\tfor (int i = 0; i < nQ; ++i) {\n\t\tint a, x;\n\t\tscanf(""%d%d"", &a, &x);\n\t\t--a;\n\t\troot->change(a, x);\n\t\tint ans = 0;\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tans += root->c[j][k];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}\n']",['data structures'],2400
https://codeforces.com//contest/1915/problem/C,C. Can I Square ,Calin has n buckets the i th of which contains a i wooden squares of side length 1 Can Calin build a square using the given squares ,"['#include ""bits/stdc++.h""\nusing namespace std;       \n\n// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\nusing ll = long long;\nusing ld = long double;\n#define pb push_back\n#define ff first\n#define ss second\n#define sz(x) (ll)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nvoid freopen(string s) { freopen((s+"".in"").c_str(), ""r"", stdin); freopen((s+"".out"").c_str(), ""w"", stdout); }\nvoid IOIGold2024_InshAllah() { ios_base::sync_with_stdio(false); cin.tie(NULL); }\nll binmul(ll a, ll b, ll c) { ll res = 0; while(b) { if(b&1) (res += a) %= c; (a += a) %= c; b >>= 1; } return res; }\nll binpow(ll a, ll b, ll c) { ll res = 1; while(b) { if(b&1) (res *= a) %= c; (a *= a) %= c; b >>= 1; } return res; }\ntemplate<typename T> T gcd(T a, T b) { if(b==0) return a; return gcd(b, a%b); }\ntemplate<typename T> T lcm(T a, T b) { return a/gcd(a, b)*b; }\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nld rnd() { return rng()%INT_MAX*1.0/INT_MAX; }\n\nconst ll inf = 1e18+7, MX = LLONG_MAX, MN = LLONG_MIN;\nconst ll mod = 1e9+7, N = 3e5+5;\n\nvoid kigash() {\n    ll n, sum = 0;\n    cin>>n;\n    for(ll i=1; i<=n; i++) {\n        ll x;\n        cin>>x;\n        sum += x;\n    }\n    if(ll(sqrt(sum))*ll(sqrt(sum))==sum) cout<<""YES\\n"";\n    else cout<<""NO\\n"";\n    return;\n}\n\nsigned main(/*Kigash Amir*/) {\n    // freopen("""");\n    IOIGold2024_InshAllah();\n    ll tt = 1;\n    cin>>tt;\n    for(ll i=1; i<=tt; i++) {\n        kigash();\n    }\n}']","['binary search', 'implementation']",800
https://codeforces.com//contest/341/problem/D,D. Iahub and Xors,Iahub does not like background stories so he ll tell you exactly what this problem asks you for You are given a matrix with rows and columns Initially all values of the matrix are zeros Both rows and columns are 1 based that is rows are numbered 1 2 and columns are numbered 1 2 Let s denote an element on the th row and th column as We will call a submatrix such elements for which two inequalities hold Write a program to perform two following operations Query print the xor sum of the elements of the submatrix Update each element from submatrix gets xor ed by value ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nclass fenv_tree_2d {\n  inline static int f(int x) { return x & -x; }\n  vector<vector<ll> > tr;\n\n  public:\n  fenv_tree_2d(int n = 0) : tr(n + 1, vector<ll>(n + 1, 0)) {}\n  void update(int x0, int y0, ll v) {\n    for (int y = y0 + 1; y < sz(tr); y += f(y))\n    for (int x = x0 + 1; x < sz(tr[y]); x += f(x))\n      tr[y][x] ^= v;\n  }\n  ll get(int x0, int y0) {\n    ll res = 0;\n    for (int y = y0 + 1; y > 0; y -= f(y))\n    for (int x = x0 + 1; x > 0; x -= f(x))\n      res ^= tr[y][x];\n    return res;\n  }\n};\n\nclass Solver {\n  fenv_tree_2d trs[2][2];\n  int n, n2;\n\n  public:\n  Solver(int n) : n(n), n2((n + 1) / 2) {\n    for (int a = 0; a < 2; a++)\n    for (int b = 0; b < 2; b++)\n      trs[a][b] = fenv_tree_2d(n2);\n  }\n  void update(int x, int y, ll v) {\n    trs[x & 1][y & 1].update(x >> 1, y >> 1, v);\n  }\n  ll get(int x, int y) {\n    return trs[x & 1][y & 1].get(x >> 1, y >> 1);\n  }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(""%d%d"", &n, &m) >= 1) {\n    Solver tr(n);\n    while (m --> 0) {\n      int ty;\n      int x1, y1, x2, y2;\n      scanf(""%d"", &ty);\n      scanf(""%d%d%d%d"", &x1, &y1, &x2, &y2);\n      x1--, y1--, x2--, y2--;\n\n      if (ty == 1) {\n        // query\n        ll ans = tr.get(x2, y2);\n        if (x1) ans ^= tr.get(x1 - 1, y2);\n        if (y1) ans ^= tr.get(x2, y1 - 1);\n        if (x1 && y1) ans ^= tr.get(x1 - 1, y1 - 1);\n        printf(""%I64d\\n"", ans);\n      } else {\n        // change\n        assert(ty == 2);\n        ll val;\n        scanf(""%I64d"", &val);\n        tr.update(x1, y1, val);\n        if (x2 < n) tr.update(x2 + 1, y1, val);\n        if (y2 < n) tr.update(x1, y2 + 1, val);\n        if (x2 < n && y2 < n) tr.update(x2 + 1, y2 + 1, val);\n      }\n    }\n  }\n  return 0;\n}\n']",['data structures'],2500
https://codeforces.com//contest/1879/problem/A,A. Rigged ,Monocarp organizes a weightlifting competition There are n athletes participating in the competition the i th athlete has strength s i and endurance e i The 1 st athlete is Monocarp s friend Polycarp and Monocarp really wants Polycarp to win The competition will be conducted as follows The jury will choose a positive integer w which denotes the weight of the barbell that will be used in the competition The goal for each athlete is to lift the barbell as many times as possible The athlete who lifts the barbell the most amount of times will be declared the winner If the barbell s weight w is than the strength of the i th athlete s i then the i th athlete will be unable to lift the barbell even one single time Otherwise the i th athlete will be able to lift the barbell and the number of times he does it will be equal to his endurance e i For example suppose there are 4 athletes with parameters s 1 7 e 1 4 s 2 9 e 2 3 s 3 4 e 3 6 s 4 2 e 4 2 If the weight of the barbell is 5 then the first athlete will be able to lift the barbell 4 times the second athlete will be able to lift the barbell 3 times the third athlete will be unable to lift the barbell the fourth athlete will be unable to lift the barbell Monocarp wants to choose w in such a way that Polycarp the 1 st athlete wins the competition Help him to choose the value of w or report that it is impossible ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    int S[N], E[N]; F0R(i, N) cin >> S[i] >> E[i];\n    FOR(i, 1, N) {\n        if (S[i] >= S[0] && E[i] >= E[0]) {\n            cout << -1 << nl; return;\n        }\n    }\n    cout << S[0] << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']",['greedy'],800
https://codeforces.com//contest/1864/problem/H,H. Asterism Stream,Bogocubic is playing a game with amenotiomoi First Bogocubic fixed an integer n and then he gave amenotiomoi an integer x which is initially equal to 1 In one move amenotiomoi performs of the following operations with the same probability increase x by 1 multiply x by 2 Bogocubic wants to find the expected number of moves amenotiomoi has to do to make x greater than or equal to n Help him find this number modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer y that 0 le y M and y cdot q equiv p pmod M ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst ll o2=(mod+1)/2;\nconst int d=64;\n//~ const int d=5;\n\n//~ map<ll,ll> mapa;\n\n//~ ll solve(ll n)\n//~ {\n\t//~ if (n==1)\n\t\t//~ return 0;\n\t//~ if (mapa.count(n))\n\t\t//~ return mapa[n];\n\t//~ ll ret=solve(n-1)+solve((n+1)/2);\n\t//~ ret*=o2;\n\t//~ ret++;\n\t//~ ret%=mod;\n\t//~ return mapa[n]=ret;\n//~ }\n\nstruct mac\n{\n\tll w[d][d];\n\tmac()\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tw[i][j]=0;\n\t}\n\tmac(ll v)\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tw[i][j]=(i==j)*v;\n\t}\n\tvoid wypisz()\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tdebug() << range(w[i], w[i]+d);\n\t\tdebug();\n\t}\n};\n\nmac operator *(mac a, mac b)\n{\n\tmac ret=mac();\n\tfor (int i=0; i<d; i++)\n\t\tfor (int j=0; j<d; j++)\n\t\t\tfor (int l=0; l<d; l++)\n\t\t\t\tret.w[i][l]=(ret.w[i][l]+a.w[i][j]*b.w[j][l])%mod;\n\treturn ret;\n}\n\nvector<mac> kolejne;\nvector<mac> pref;\n\nll dpn[nax];\nll dps[nax];\n\nvoid przyloz(mac &v)\n{\n\tfor (int i=0; i<d; i++)\n\t{\n\t\tdps[i]=dpn[i];\n\t\tdpn[i]=0;\n\t}\n\tfor (int i=0; i<d; i++)\n\t\tfor (int j=0; j<d; j++)\n\t\t\tdpn[j]=(dpn[j]+dps[i]*v.w[i][j])%mod;\n}\n\nvoid zrob(ll n)\n{\n\tif (!n)\n\t\treturn;\n\tint kt=0;\n\tll x=1;\n\twhile(2*x<=n)\n\t{\n\t\tkt++;\n\t\tx*=2;\n\t}\n\tif (kt)\n\t\tprzyloz(pref[kt-1]);\n\tprzyloz(kolejne[kt]);\n\tzrob(n-x);\n}\n\nvoid test()\n{\n\tll n;\n\tscanf(""%lld"", &n);\n\tfor (int i=0; i<d; i++)\n\t\tdpn[i]=0;\n\tdpn[d-1]=1;\n\tzrob(n-1);\n\tprintf(""%lld\\n"", dpn[0]);\n\t//~ mac pus=mac(1);\n\t//~ for (ll i=1; i<n; i++)\n\t//~ {\n\t\t//~ int x=__builtin_ctz(i);\n\t\t//~ pus=pus*kolejne[x];\n\t//~ }\n\t//~ printf(""%lld\\n"", pus.w[d-1][0]);\n}\n\nint main()\n{\n\tfor (int i=0; i+1<d; i++)\n\t{\n\t\tmac tu=mac(1);\n\t\ttu.w[i][i]=o2;\n\t\ttu.w[i+1][i]=o2;\n\t\ttu.w[d-1][i]=1;\n\t\tif (i)\n\t\t\ttu=tu*kolejne.back();\n\t\tkolejne.push_back(tu);\n\t\t//~ debug() << imie(i);\n\t\t//~ kolejne[i].wypisz();\n\t}\n\tfor (int i=0; i+1<d; i++)\n\t{\n\t\tif (!i)\n\t\t{\n\t\t\tpref.push_back(kolejne[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmac tu=(pref.back()*kolejne[i])*pref.back();\n\t\t\tpref.push_back(tu);\n\t\t}\n\t}\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['dp', 'math', 'matrices']",3200
https://codeforces.com//contest/300/problem/A,A. Array,Vitaly has an array of distinct integers Vitaly wants to divide this array into three sets so as the following conditions hold The product of all numbers in the first set is less than zero The product of all numbers in the second set is greater than zero The product of all numbers in the third set is equal to zero Each number from the initial array must occur in exactly one set Help Vitaly Divide the given array ,"['//program 300-A\n\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint Get()\n{\n  char c;\n  while(c=getchar(),c<\'0\'||c>\'9\');\n  int X=0;\n  while(c>=\'0\'&&c<=\'9\')\n    {\n      X=X*10+c-48;\n      c=getchar();\n    }\n  return X;\n}\n\nint main()\n{\n  int N=Get();\n  static int A[100000];\n  for(int i=0;i<N;i++)\n    scanf(""%d"",&A[i]);\n  static bool Flag[100000];\n  memset(Flag,0,sizeof(Flag));\n  int P=0;\n  while(A[P]>=0)\n    P++;\n  Flag[P]=true;\n  printf(""1 %d\\n"",A[P]);\n  int Q=0;\n  while(Q<N&&A[Q]<=0)\n    Q++;\n  if(Q==N)\n    {\n      int Q0=P+1;\n      while(A[Q0]>=0)\n        Q0++;\n      int Q1=Q0+1;\n      while(A[Q1]>=0)\n        Q1++;\n      Flag[Q0]=Flag[Q1]=true;\n      printf(""2 %d %d\\n"",A[Q0],A[Q1]);\n    }\n  else\n    {\n      printf(""1 %d\\n"",A[Q]);\n      Flag[Q]=true;\n    }\n  int Count=0;\n  for(int i=0;i<N;i++)\n    if(!Flag[i])\n      Count++;\n  printf(""%d"",Count);\n  for(int i=0;i<N;i++)\n    if(!Flag[i])\n      printf("" %d"",A[i]);\n  putchar(\'\\n\');\n  return 0;\n}\n']","['brute force', 'constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/976/problem/A,A. Minimum Binary Number,String can be called if it consists of characters and and there are no redundant leading zeroes Here are some examples You are given a string You can perform two different operations on this string swap any pair of adjacent characters for example replace with for example Let be such a number that is its binary representation string is less than some other string iff Your task is to find the minimum string that you can obtain from the given one using the operations described above You can use these operations any number of times in any order or even use no operations at all ,"['#include <stdio.h>\n#include <algorithm>\n#include <time.h>\n#include <string>\n#include <set>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nchar in[100050];\nint main() {\n\tint N, i;\n\tscanf(""%d %s"", &N, in);\n\tif (N == 1) return !printf(""%s\\n"", in);\n\n\tint c0 = 0, c1 = 0;\n\tfor (i = 0; i < N; i++) {\n\t\tif (in[i] == \'0\') c0++;\n\t\telse c1++;\n\t}\n\tprintf(""1"");\n\tfor (i = 1; i <= c0; i++) printf(""0"");\n\treturn !printf(""\\n"");\n}']",['implementation'],800
https://codeforces.com//contest/946/problem/A,A. Partition,You are given a sequence consisting of integers You may partition this sequence into two sequences and in such a way that every element belongs exactly to one of these sequences Let be the sum of elements belonging to and be the sum of elements belonging to if some of these sequences is empty then its sum is What is the maximum possible value of ,"['// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored ""-Wunused-result""\n#pragma GCC diagnostic ignored ""-Wunused-function""\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(""%d"", &x); }\nvoid _R(int64_t &x) { scanf(""%"" SCNd64, &x); }\nvoid _R(double &x) { scanf(""%lf"", &x); }\nvoid _R(char &x) { scanf("" %c"", &x); }\nvoid _R(char *x) { scanf(""%s"", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(""%d"", x); }\nvoid _W(const int64_t &x) { printf(""%"" PRId64, x); }\nvoid _W(const double &x) { printf(""%.16f"", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(""%s"", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(\' \'); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? \' \' : \'\\n\'); W(tail...); }\n\n#ifdef SHIK\n#include ""dump.hpp""\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=110;\nint n,a[N];\nvoid main() {\n    R(n);\n    REP(i,n) R(a[i]);\n    int s=0;\n    REP(i,n) s+=abs(a[i]);\n    W(s);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n']",['greedy'],800
https://codeforces.com//contest/1946/problem/B,B. Maximum Sum,You have an array a of n integers You perform exactly k operations on it In one operation you select any contiguous subarray of the array a possibly empty and insert the sum of this subarray anywhere in the array Your task is to find the maximum possible sum of the array after k such operations As this number can be very large output the answer modulo 10 9 7 Reminder the remainder of a number x modulo p is the smallest non negative y such that there exists an integer q and x p cdot q y ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=2e5+5;\nconst int MOD=1e9+7;\nll n,k,a[MAXN];\nll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}\nvoid solve(){\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i],a[i]+=a[i-1];\n\tll s=0,mn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tmn=min(mn,a[i]);\n\t\ts=max(s,a[i]-mn);\n\t}\n\tcout<<((a[n]+s%MOD*(ksm(2,k)-1))%MOD+MOD)%MOD<<\'\\n\';\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(""Otomachi_Una.in"",""r"",stdin);\n\t// freopen(""Otomachi_Una.out"",""w"",stdout);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}']","['dp', 'greedy', 'math']",1100
https://codeforces.com//contest/1322/problem/D,D. Reality Show,A popular reality show is recruiting a new cast for the third season n candidates numbered from 1 to n have been interviewed The candidate i has aggressiveness level l i and recruiting this candidate will cost the show s i roubles The show host reviewes applications of all candidates from i 1 to i n by increasing of their indices and for each of them she decides whether to recruit this candidate or not If aggressiveness level of the candidate i is strictly higher than that of any candidates then the candidate i will definitely be rejected Otherwise the host may accept or reject this candidate at her own discretion The host wants to choose the cast so that to maximize the total The show makes revenue as follows For each aggressiveness level v a corresponding profitability value c v is specified which can be positive as well as negative All recruited participants enter the stage one by one by increasing of their indices When the participant i enters the stage events proceed as follows The show makes c l i roubles where l i is initial aggressiveness level of the participant i If there are two participants with the same aggressiveness level on stage they immediately start a fight The outcome of this is the defeated participant is hospitalized and leaves the show aggressiveness level of the victorious participant is increased by one and the show makes c t roubles where t is the new aggressiveness level The fights continue until all participants on stage have distinct aggressiveness levels It is allowed to select an empty set of participants to choose neither of the candidates The host wants to recruit the cast so that the total profit is maximized The profit is calculated as the total revenue from the events on stage less the total expenses to recruit all accepted participants that is their total s i Help the host to make the show as profitable as possible ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=5005;\nint n,m,l[N],s[N],c[N];\nint mx[N],top[N],ans;\nint q[N][N],qq[N],f[N][N];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tFor(i,1,n) scanf(""%d"",&l[i]);\n\tFor(i,1,n) scanf(""%d"",&s[i]);\n\tFor(i,1,n+m) scanf(""%d"",&c[i]);\n\tFor(i,1,n) s[i]=c[l[i]]-s[i];\n\tint ans=0;//-(1<<30);\n\tmemset(f,233,sizeof(f));\n\tFor(i,1,n+m) f[i][0]=0;\n\tRep(i,n,1){\n\t\tint L=l[i];\n\t\tRep(j,mx[L],0){\n\t\t\tint val=f[L][j]+s[i],t=j+1;\n\t\t\t//cout<<L<<\' \'<<j<<\' \'<<t<<\' \'<<val<<endl;\n\t\t\tfor (int p=L;t;){\n\t\t\t\tmx[p]=max(mx[p],t);\n\t\t\t\tf[p][t]=max(f[p][t],val);\n\t\t\t\tp++; t/=2; val+=c[p]*t;\n\t\t\t}\n\t\t\tans=max(ans,val);\n\t\t}\n\t\tFor(j,1,n+m) f[j][0]=max(f[j][0],max(f[j-1][0],f[j-1][1]));\n\t\t/*q[L][++top[L]]=s[i]; ++mx[L];\n\t\tsort(q[L]+1,q[L]+top[L]+1,greater<int>());\n\t\tRep(j,mx[L]-1,0) f[L][j+1]=max(f[L][j+1],f[L][j]+s[i]);\n\t\tFor(j,L+1,n+m){\n\t\t\tint p1=0,p2=0,l1=mx[j-1]/2,l2=top[j];\n\t\t\tFor(k,0,l1) qq[k]=0;\n\t\t\tFor(k,0,mx[L-1]) qq[k/2]=max(qq[k/2],f[j-1][k]);\n\t\t\tFor(k,0,l1) qq[k]+=1ll*c[j]*k;\n\t\t\tint S=qq[0];\n\t\t\tfor (;p1<=l1||p2<=l2;){\n\t\t\t\tf[j][p1+p2]=S;\n\t\t\t\tif (p1==l1&&p2==l2) break;\n\t\t\t\tif (p2==l2||(p1<l1&&qq[p1+1]-qq[p1]>q[j][p2+1]))\n\t\t\t\t\tS+=qq[p1+1]-qq[p1],++p1;\n\t\t\t\telse S+=q[j][++p2];\n\t\t\t}\n\t\t\tmx[j]=l1+l2;\n\t\t\t//cout<<""len ""<<i<<\' \'<<j<<\' \'<<mx[j]<<\' \'<<f[j][0]<<\' \'<<f[j][1]<<endl;\n\t\t}*/\n\t}\n\tprintf(""%d\\n"",ans);\n} ']","['bitmasks', 'dp']",2800
https://codeforces.com//contest/318/problem/C,C. Perfect Pair,Let us call a pair of integer numbers if at least one number in the pair is greater than or equal to Thus the pairs 3 3 and 0 2 are 2 perfect while the pair 1 1 is not Two integers are written on the blackboard It is allowed to erase one of them and replace it with the sum of the numbers What is the minimum number of such operations one has to perform in order to make the given pair of integers perfect ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tlong long n,m,r;\n\tcin >> n >> m >> r;\n\tlong long ans = 0;\n\tif(max(n,m) >= r) {\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tif(n <= 0 && m <= 0) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tif(n > m) swap(n,m);\n\tif(n < 0) {\n\t\tans += (-n) / m;\n\t\tn += ans * m;\n\t}\n\twhile(max(n,m) < r) {\n\t\tans ++;\n\t\tif(n > m) swap(n,m);\n\t\tn += m;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","['greedy', 'math']",1600
https://codeforces.com//contest/1406/problem/D,D. Three Sequences,You are given a sequence of n integers a 1 a 2 ldots a n You have to construct two sequences of integers b and c with length n that satisfy for every i 1 leq i leq n b i c i a i b is non decreasing which means that for every 1 i leq n b i geq b i 1 must hold c is non increasing which means that for every 1 i leq n c i leq c i 1 must hold You have to minimize max b i c i In other words you have to minimize the maximum number in sequences b and c Also there will be q changes the i th change is described by three integers l r x You should add x to a l a l 1 ldots a r You have to find the minimum possible value of max b i c i for the initial sequence and for sequence after each change ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl '\\n'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\n\nstruct LAZY{\nvector<ll> tree,lazy;\nint n;\nLAZY(){}\nLAZY(int _n){ // pass a vector/array if needed\n  n = _n;\n  tree.resize(4*n + 100,0);\n  lazy.resize(4*n + 100,0);\n}\n\nll f(ll a,ll b){\n   return (a>b ? a : b); // max/min (a>b ? a : b)\n}\nvoid build(int no,int i,int j){\n  if(i==j){\n    tree[no] = 0;\n  }else{\n    int m = (i+j)/2;\n    int l = 2*no,r=2*no+1;\n    build(l,i,m);\n    build(r,m+1,j);\n    tree[no] = f(tree[l],tree[r]);\n  }\n}\n\nvoid propagate(int no,int i,int j){\n  if(lazy[no]==0)return;\n  tree[no]+=lazy[no];\n  if(i!=j){\n    lazy[2*no]+=lazy[no];\n    lazy[2*no+1]+=lazy[no];\n  }\n  lazy[no] = 0;\n}\n\nvoid update(int no,int i,int j,int a,int b,ll v){\n  propagate(no,i,j);\n  if(i>b || j<a || i>j)return;\n  if(a<=i && j<=b){\n    tree[no] += v;\n    if(i!=j){\n      lazy[2*no]+=v;\n      lazy[2*no+1]+=v;\n    }\n    return;\n  }\n  int m = (i+j)/2;\n  int l = 2*no,r=2*no+1;\n  update(l,i,m,a,b,v);\n  update(r,m+1,j,a,b,v);  \n  tree[no] = f(tree[l],tree[r]);\n}\n\nconst ll inf = 1e18;\nll query(int no,int i,int j,int a,int b){\n  if(i>b || j<a || i>j)return -inf;\n  \n  propagate(no,i,j);\n  \n  if(a<=i && j<=b)return tree[no];\n  \n  int m = (i+j)/2;\n  int l = 2*no,r=2*no+1;\n  \n  return f(query(l,i,m,a,b),query(r,m+1,j,a,b));\n}\n\n\n ll get(int x){\n  if(x == 1)return 0;\n  return max(0ll,query(1,1,n,x,x) - query(1,1,n,x-1,x-1));\n }\n\n};\n\n\nconst int N = 100100;\nll a[N];\n\nll get(ll X){\n  ll r = (X+1)/2 - 5;\n  while(r*2 < X)r++;\n  assert(2*r >= X);\n  return r;\n}\n\nint32_t main(){\n  FASTIO;\n  int n;\n  cin >> n;\n  LAZY L(n);\n  ll d=0;\n  for(int i=1;i<=n;i++){\n    cin >> a[i];\n    L.update(1,1,n,i,i,a[i]);\n    if(i!=1){\n      d+=max(0ll,a[i] - a[i-1]);\n    }\n  }\n  int q;\n  cin >> q;\n  cout << get(d + a[1]) << endl;\n  while(q--){\n    int l,r,x;\n    \n    cin >> l >> r >> x;\n    if(l==1)a[1]+=x;\n    pii c1 = pii(0,0),c2 = pii(0,0);\n    c1.ff = L.get(l);\n    c2.ff = L.get(r+1);\n    L.update(1,1,n,l,r,x);\n    c1.ss = L.get(l);\n    c2.ss = L.get(r+1);\n    //\n    d+=c1.ss - c1.ff;\n    d+=c2.ss - c2.ff;\n    //\n    ll res = get(d + a[1]);\n    cout << res << endl;\n  }\n}""]","['constructive algorithms', 'data structures', 'greedy', 'math']",2200
https://codeforces.com//contest/668/problem/B,B. Little Artem and Dance,Little Artem is fond of dancing Most of all dances Artem likes rueda Cuban dance that is danced by pairs of boys and girls forming a circle and dancing together More detailed there are pairs of boys and girls standing in a circle Initially boy number dances with a girl number boy number dances with a girl number and so on Girls are numbered in the clockwise order During the dance different moves are announced and all pairs perform this moves While performing moves boys move along the circle while girls always stay at their initial position For the purpose of this problem we consider two different types of moves Value and some direction are announced and all boys move positions in the corresponding direction Boys dancing with even indexed girls swap positions with boys who are dancing with odd indexed girls That is the one who was dancing with the girl swaps with the one who was dancing with the girl number while the one who was dancing with girl number swaps with the one who was dancing with the girl number and so one It s guaranteed that is even Your task is to determine the final position of each boy ,"['#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nint main() {\n\tint n; int q;\n\twhile(~scanf(""%d%d"", &n, &q)) {\n\t\tvector<bool> swapseq;\n\t\tint rot = 0;\n\t\trep(i, q) {\n\t\t\tint ty;\n\t\t\tscanf(""%d"", &ty);\n\t\t\tif(ty == 1) {\n\t\t\t\tint x;\n\t\t\t\tscanf(""%d"", &x);\n\t\t\t\trot = ((rot - x) % n + n) % n;\n\t\t\t} else if(ty == 2) {\n\t\t\t\tswapseq.push_back(rot % 2 != 0);\n\t\t\t\tif(swapseq.size() >= 2 && swapseq.end()[-1] == swapseq.end()[-2])\n\t\t\t\t\tswapseq.resize(swapseq.size() - 2);\n\t\t\t} else abort();\n\t\t}\n\t\tvi ans(n);\n\t\tint t = swapseq.size() % n;\n\t\trep(i, n) {\n\t\t\tint j = (i + (swapseq.empty() ? 0 : swapseq[0])) % 2 == 0 ? i + t : i - t;\n\t\t\tj = (j % n + n) % n;\n\t\t\tans[j] = i + 1;\n\t\t}\n\t\trotate(ans.begin(), ans.begin() + rot, ans.end());\n\t\tfor(int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif(i != 0) putchar(\' \');\n\t\t\tprintf(""%d"", ans[i]);\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']",['implementation'],1800
https://codeforces.com//contest/670/problem/D1,D1. Magic Powder - 1,Waking up in the morning Apollinaria decided to bake cookies To bake one cookie she needs ingredients and for each ingredient she knows the value how many grams of this ingredient one needs to bake a cookie To prepare one cookie Apollinaria needs to use all ingredients Apollinaria has gram of the th ingredient Also she has grams of a magic powder Each gram of magic powder can be turned to exactly gram of any of the ingredients and can be used for baking cookies Your task is to determine the maximum number of cookies which Apollinaria is able to bake using the ingredients that she has and the magic powder ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\n    int n, k;\n    vector <int> a, b;\n\nbool can(ll x) {\n    ll need = 0;\n    for (int i = 0; i < n; ++i) {\n        need += max(0LL, a[i] * 1LL * x - b[i]);\n        if (need >k) return false;\n    }\n    return need <= k;\n}\n\nint main() {\n\n  //  freopen(""input.txt"", ""r"", stdin);\n  //  freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    a.resize(n);\n    b.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n\n    ll l = 0, r = 4LL * INF;\n    for (int iter = 0; iter < 50; ++iter) {\n        ll m = (l + r) / 2;\n        if (can(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    cout << l << \'\\n\';\n    return 0;\n}\n']","['binary search', 'brute force', 'implementation']",1400
https://codeforces.com//contest/757/problem/C,C. Felicity is Coming ,It s that time of the year Felicity is around the corner and you can see people celebrating all around the Himalayan region The Himalayan region has gyms The th gym has Pokemon in it There are distinct Pokemon types in the Himalayan region numbered from to There is a special evolution camp set up in the fest which claims to evolve any Pokemon The type of a Pokemon could change after evolving subject to the constraint that if two Pokemon have the same type before evolving they will have the same type after evolving Also if two Pokemon have different types before evolving they will have different types after evolving It is also possible that a Pokemon has the same type before and after evolving Formally an is a permutation of such that means that a Pokemon of type evolves into a Pokemon of type The gym leaders are intrigued by the special evolution camp and all of them plan to evolve their Pokemons The protocol of the mountain states that in each gym for every type of Pokemon the number of Pokemon of that type before evolving any Pokemon should be equal the number of Pokemon of that type after evolving all the Pokemons according to the evolution plan They now want to find out how many distinct exist which satisfy the protocol Two evolution plans and are distinct if they have at least one Pokemon type evolving into a different Pokemon type in the two plans i e there exists an such that Your task is to find how many distinct are possible such that if all Pokemon in all the gyms are evolved the number of Pokemon of each type in each of the gyms remains the same As the answer can be large output it modulo ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\nconst int N = 1234567;\n\nvector <int> a[N];\n\nint main() {\n  int n, m;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    while (foo--) {\n      int bar;\n      scanf(""%d"", &bar);\n      a[bar].push_back(i);\n    }\n  }\n  sort(a + 1, a + m + 1);\n  int ans = 1;\n  int t = 1;\n  for (int i = 2; i <= m; i++) {\n    if (a[i] == a[i - 1]) {\n      t++;\n      ans = (long long) ans * t % md;\n    } else {\n      t = 1;\n    }\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","['data structures', 'hashing', 'sortings', 'strings']",1900
https://codeforces.com//contest/1352/problem/F,F. Binary String Reconstruction,For some binary string s i e each character s i is either or all pairs of consecutive adjacent characters were written In other words all substrings of length 2 were written For each pair substring of length 2 the number of ones in it was calculated You are given three numbers n 0 the number of such pairs of consecutive characters substrings where the number of ones equals 0 n 1 the number of such pairs of consecutive characters substrings where the number of ones equals 1 n 2 the number of such pairs of consecutive characters substrings where the number of ones equals 2 For example for the string s the following substrings would be written Thus n 0 1 n 1 3 n 2 5 Your task is to restore suitable binary string s from the given values n 0 n 1 n 2 It is guaranteed that at least one of the numbers n 0 n 1 n 2 is greater than 0 Also it is guaranteed that a solution exists ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n    void solve () {\n       \n       \n         /* --------- */\n       \n    int a00,a10,a11;\n    cin>>a00>>a10>>a11;\n    \n    if (a00!=0) {\n        for (int i=1;i<=a00+1;i++) cout<<""0""; \n    }\n    if(a10!=0) for (int i=1;i<=a10+(a00==0);i++) {\n        if (i%2==1) cout<<""1""; else cout<<""0""; \n        if (i==1) for (int j=1;j<=a11;j++) cout<<""1"";     }\n     if (a10==0 && a11) for (int i=1;i<=a11+1;i++) cout<<""1""; \n   cout<<""\\n""; return; \n        /* --------- */   \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(false);\n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n       \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","['constructive algorithms', 'dfs and similar', 'math']",1500
https://codeforces.com//contest/1827/problem/B1,B1. Range Sorting  Easy Version ,You are given an array a consisting of n distinct integers a 1 a 2 ldots a n Define the of an array p 1 p 2 ldots p k as the minimum amount of time needed to sort this array using an arbitrary number of operations In each range sort operation you will do the following Choose two integers l and r 1 le l r le k Sort the subarray p l p l 1 ldots p r in r l seconds Please calculate the sum of beauty over all subarrays of array a A subarray of an array is defined as a sequence of consecutive elements of the array ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor(int& x : A) cin >> x;\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tvector<pair<int,int> > cur = {};\n\t\tfor(int j = i; j < N; j++){\n\t\t\tpair<int, int> v = {A[j], A[j]};\n\t\t\twhile(!cur.empty() && cur.back().second >= v.first){\n\t\t\t\tv.first = min(v.first, cur.back().first);\n\t\t\t\tv.second = max(v.second, cur.back().second);\n\t\t\t\tcur.pop_back();\n\t\t\t}\n\t\t\tcur.push_back(v);\n\t\t\tans += (j-i+1) - (int)cur.size();\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['binary search', 'dp', 'dsu', 'greedy', 'trees', 'two pointers']",2000
https://codeforces.com//contest/1322/problem/B,B. Present,Catherine received an array of integers as a gift for March 8 Eventually she grew bored with it and she started calculated various useless characteristics for it She succeeded to do it for each one she came up with But when she came up with another one of all pairwise sums of elements in the array she realized that she couldn t compute it for a very large array thus she asked for your help Can you do it Formally you need to compute a 1 a 2 oplus a 1 a 3 oplus ldots oplus a 1 a n oplus a 2 a 3 oplus ldots oplus a 2 a n ldots oplus a n 1 a n Here x oplus y is a bitwise XOR operation i e x y in many modern programming languages You can read about it in Wikipedia https en wikipedia org wiki Exclusive or Bitwise operation ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=400005;\nint n,a[N],b[N],ans;\nint main(){\n\tscanf(""%d"",&n);\n\tFor(i,1,n) scanf(""%d"",&a[i]);\n\tfor (int B=1;B<2e7;B<<=1){\n\t\tFor(j,1,n) b[j]=a[j]&(B-1);\n\t\tint sum=0;\n\t\tFor(j,1,n) sum+=((a[j]&B)!=0);\n\t\tif ((sum&1)&&((n-1)&1)) ans^=B;\n\t\tsort(b+1,b+n+1);\n\t\tint p=n; sum=0;\n\t\tFor(j,1,n){\n\t\t\tp=max(p,j);\n\t\t\tfor (;p>j&&b[j]+b[p]>=B;--p);\n\t\t\tsum^=(n-p);\n\t\t}\n\t\tif (sum&1) ans^=B; \n\t}\n\tprintf(""%d\\n"",ans);\n}']","['binary search', 'bitmasks', 'constructive algorithms', 'data structures', 'math', 'sortings']",2100
https://codeforces.com//contest/1921/problem/D,D. Very Different Array,Petya has an array a i of n integers His brother Vasya became envious and decided to make his own array of n integers To do this he found m integers b i m ge n and now he wants to choose some n integers of them and arrange them in a certain order to obtain an array c i of length n To avoid being similar to his brother Vasya wants to make his array as different as possible from Petya s array Specifically he wants the total difference D sum i 1 n a i c i to be as large as possible Help Vasya find the maximum difference D he can obtain ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,m,ans=0;\n    cin>>n>>m;\n    ll a[n+1],b[m+1];\n    for(ll i=1;i<=n;i++) cin>>a[i];\n    for(ll i=1;i<=m;i++) cin>>b[i];\n    sort(a+1,a+n+1);\n    reverse(a+1,a+n+1);\n    sort(b+1,b+m+1);\n    ll s=0;\n    for(ll i=1;i<=n;i++) s+=abs(a[i]-b[i]);\n    ans=s;\n    for(ll i=n;i>=1;i--){\n        s-=abs(a[i]-b[i]);\n        s+=abs(a[i]-b[m-n+i]);\n        ans=max(ans,s);\n    }\n    cout<<ans;\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","['data structures', 'greedy', 'sortings', 'two pointers']",1100
https://codeforces.com//contest/1336/problem/A,A. Linova and Kingdom,Writing light novels is the most important thing in Linova s life Last night Linova dreamed about a fantastic kingdom She began to write a light novel for the kingdom as soon as she woke up and of course she is the queen of it There are n cities and n 1 two way roads connecting pairs of cities in the kingdom From any city you can reach any other city by walking through some roads The cities are numbered from 1 to n and the city 1 is the capital of the kingdom So the kingdom has a tree structure As the queen Linova plans to choose k cities developing industry while the other cities will develop tourism The capital also can be either industrial or tourism city A meeting is held in the capital once a year To attend the meeting each sends an envoy All envoys will follow the shortest path from the departure city to the capital which is unique Traveling in tourism cities is pleasant For each envoy his is equal to the number of on his path In order to be a queen loved by people Linova wants to choose k cities which can maximize the sum of of all envoys Can you calculate the maximum sum for her ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 223456;\nint n, k, u, v;\nvector<int> e[maxN];\nint sz[maxN], dep[maxN], f[maxN];\ni64 ans;\nvoid dfs(int u, int f)\n{\n\tsz[u] = 1;\n\tdep[u] = dep[f] + 1;\n\tfor (auto v : e[u])\n\t{\n\t\tif (v == f)\n\t\t\tcontinue;\n\t\tdfs(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tscanf(""%d%d"", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = dep[i] - sz[i];\n\tsort(f + 1, f + n + 1);\n\tfor (int i = 0; i < k; i++)\n\t\tans += f[n - i];\n\tprintf(""%lld\\n"", ans);\n}']","['dfs and similar', 'dp', 'greedy', 'sortings', 'trees']",1600
https://codeforces.com//contest/1810/problem/B,B. Candies,This problem is about candy Initially you only have 1 candy and you want to have exactly n candies You can use the two following spells in any order at most 40 times in total Assume you have x candies now If you use the first spell then x candies become 2x 1 candies Assume you have x candies now If you use the second spell then x candies become 2x 1 candies Construct a sequence of spells such that after using them in order you will have n candies or determine it s impossible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    if (n % 2 == 0) {\n        std::cout << -1 << ""\\n"";\n        return;\n    }\n    \n    std::vector<int> ans;\n    while (n != 1) {\n        if ((n + 1) / 2 % 2 == 1) {\n            n += 1;\n            ans.push_back(1);\n        } else {\n            n -= 1;\n            ans.push_back(2);\n        }\n        n /= 2;\n    }\n    \n    std::reverse(ans.begin(), ans.end());\n    std::cout << ans.size() << ""\\n"";\n    for (int i = 0; i < ans.size(); i++) {\n        std::cout << ans[i] << "" \\n""[i == ans.size() - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'math', 'number theory']",800
https://codeforces.com//contest/1249/problem/C1,C1. Good Numbers  easy version , You are given a positive integer number n You really love so you want to find the smallest greater than or equal to n The positive integer is called if it can be represented as a sum of powers of 3 i e no duplicates of powers of 3 are allowed For example 30 is a 30 3 3 3 1 1 is a 1 3 0 12 is a 12 3 2 3 1 but 2 is a you can t represent it as a sum of distinct powers of 3 2 3 0 3 0 19 is a you can t represent it as a sum of distinct powers of 3 for example the representations 19 3 2 3 2 3 0 3 2 3 1 3 1 3 1 3 0 are invalid 20 is also a you can t represent it as a sum of distinct powers of 3 for example the representation 20 3 2 3 2 3 0 3 0 is invalid Note that there exist other representations of 19 and 20 as sums of powers of 3 but none of them consists of powers of 3 For the given positive integer n find such smallest m n le m that m is a You have to answer q independent queries ,"['#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<\'0\'||c>\'9\');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>=\'0\'&&c<=\'9\');\n\treturn res;\n}\nint s[51];\nvoid to3(long long x){\n\tlong long t=0;\n\twhile(x){\n\t\ts[t++]=x%3;\n\t\tx/=3;\n\t}\n}\nlong long tox(){\n\tlong long t=1, ans=0;\n\tfor(int i=0;; i++){\n\t\tans+=t*s[i];\n\t\tif(3.0l*t>2e18)break;\n\t\tt*=3;\n\t}\n\treturn ans;\n}\nint main() {\n\tint T=read();\n\twhile(T--){\n\t\tmemset(s, 0, sizeof s);\n\t\tlong long N;\n\t\tscanf(""%lld"", &N);\n\t\tto3(N);\n\t\tfor(int i=50; i>=0; i--){\n\t\t\tif(s[i]==2){\n\t\t\t\tfor(int j=i+1;; j++){\n\t\t\t\t\tif(s[j]==0){\n\t\t\t\t\t\ts[j]=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts[j]=0;\n\t\t\t\t}\n\t\t\t\ts[i]=0;\n\t\t\t\tfor(int j=i-1; j>=0; j--)s[j]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<tox()<<endl;\n\t}\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation']",1300
https://codeforces.com//contest/991/problem/A,A. If at first you don t succeed...,Each student eagerly awaits the day he would pass the exams successfully Thus Vasya was ready to celebrate but alas he didn t pass it However many of Vasya s fellow students from the same group were more successful and celebrated after the exam Some of them celebrated in the BugDonalds restaurant some of them in the BeaverKing restaurant the most successful ones were fast enough to celebrate in both of restaurants Students which didn t pass the exam didn t celebrate in any of those restaurants and elected to stay home to prepare for their reexamination However this quickly bored Vasya and he started checking celebration photos on the Kilogramm He found out that in total BugDonalds was visited by A students BeaverKing by B students and C students visited both restaurants Vasya also knows that there are N students in his group Based on this info Vasya wants to determine either if his data contradicts itself or if it doesn t how many students in his group didn t pass the exam Can you help him so he won t waste his valuable preparation time ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint A, B, C, N;\n\tcin >> A >> B >> C >> N;\n\tint x = A + B - C;\n\tif (N - x > 0 && C <= A && C <= B) {\n\t\tcout << N - x << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}""]",['implementation'],1000
https://codeforces.com//contest/1228/problem/D,D. Complete Tripartite,You have a simple undirected graph consisting of n vertices and m edges The graph doesn t contain self loops there is at most one edge between a pair of vertices The given graph can be disconnected Let s make a definition Let v 1 and v 2 be two some nonempty subsets of vertices that do not intersect Let f v 1 v 2 be true if and only if all the conditions are satisfied There are no edges with both endpoints in vertex set v 1 There are no edges with both endpoints in vertex set v 2 For every two vertices x and y such that x is in v 1 and y is in v 2 there is an edge between x and y Create three vertex sets v 1 v 2 v 3 which satisfy the conditions below All vertex sets should not be empty Each vertex should be assigned to only one vertex set f v 1 v 2 f v 2 v 3 f v 3 v 1 are all true Is it possible to create such three vertex sets If it s possible print matching vertex set for each vertex ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100010, M = 300010;\n\nint n, m;\nint u[M], v[M];\nint color[N];\nset<int> g[N];\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  scanf(""%d%d"", &n, &m);\n  for (int i = 1; i <= m; ++i) {\n    scanf(""%d%d"", &u[i], &v[i]);\n    g[u[i]].insert(v[i]);\n    g[v[i]].insert(u[i]);\n  }\n  int a = 1, b = -1, c = -1;\n  for (int i = 1; i <= m; ++i)\n    if (u[i] == 1) {\n      color[v[i]] = -1;\n    }\n  for (int i = 1; i <= m; ++i)\n    if (color[u[i]] == -1 && color[v[i]] == -1) {\n      b = u[i];\n      c = v[i];\n      break;\n    }\n#define GG do{puts(""-1""); return 0;}while(false)\n  if (b == -1) {\n    GG;\n  }\n  for (int i = 1; i <= n; ++i) {\n    bool fa = g[i].count(a), fb = g[i].count(b), fc = g[i].count(c);\n    if (fa + fb + fc != 2)\n      GG;\n    if (!fa)\n      color[i] = 1;\n    else if (!fb)\n      color[i] = 2;\n    else\n      color[i] = 3;\n  }\n  for (int i = 1; i <= m; ++i)\n    if (color[u[i]] == color[v[i]]) {\n      GG;\n    }\n  int ta= count(color + 1, color + n + 1, 1), tb=count(color + 1, color + n + 1, 2), tc=count(color + 1, color + n + 1, 3);\n  if (m != ta*(ll)tb+tb*(ll)tc+tc*(ll)ta)\n    GG;\n  for (int i = 1; i <= n; ++i)\n    printf(""%d "", color[i]);\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']","['brute force', 'constructive algorithms', 'graphs', 'hashing', 'implementation']",1900
https://codeforces.com//contest/283/problem/C,C. Coin Troubles,In the Isle of Guernsey there are different types of coins For each coin of type is worth cents It is possible that for some and Bessie has some set of these coins totaling cents She tells Jessie pairs of integers For each the pair tells Jessie that Bessie has a strictly greater number of coins of type than coins of type It is known that all are distinct and all are distinct Help Jessie find the number of possible combinations of coins Bessie could have Two combinations are considered different if there is some such that the number of coins Bessie has of type is different in the two combinations Since the answer can be very large output it modulo If there are no possible combinations of coins totaling cents that satisfy Bessie s conditions output 0 ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint N,Q;\nlng T;\nlng src0[310];\nint next[310];\nint prev[310];\nlng dp[110000];\nconst lng mod=INF+7;\n\nvector<lng> ar;\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tclr(next,-1);\n\tclr(prev,-1);\n\t\n\tcin>>N>>Q>>T;\n\tforn(i,N){\n\t\tcin>>src0[i];\n\t}\n\tforn(i,Q){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tnext[a]=b;\n\t\tprev[b]=a;\n\t}\n\t\n\tforn(v0,N){\n\t\tif(prev[v0]!=-1)\n\t\t\tcontinue;\n\t\tint v=v0;\n\t\tlng s=0;\n\t\twhile(v!=-1){\n\t\t\tT-=s;\n\t\t\ts+=src0[v];\n\t\t\tar.pb(s);\n\t\t\tv=next[v];\n\t\t}\n\t}\n\t\n\tif(sz(ar)<N || T<0){\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\t\n\tdp[0]=1;\n\tforn(i,N){\n\t\tfor(lng j=0;j+ar[i]<=T;++j){\n\t\t\tdp[j+ar[i]]=(dp[j+ar[i]]+dp[j])%mod;\n\t\t}\n\t}\n\t\n\tcout<<dp[T];\n\n\treturn 0;\n}']",['dp'],2100
https://codeforces.com//contest/1437/problem/E,E. Make It Increasing,You are given an array of n integers a 1 a 2 a n and a set b of k distinct integers from 1 to n In one operation you may choose two integers i and x 1 le i le n x can be any integer and assign a i x This operation can be done only if i does not belong to the set b Calculate the minimum number of operations you should perform so the array a is increasing that is a 1 a 2 a 3 dots a n or report that it is impossible ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int INF = (int)1e9 + (int)1e8;\nconst int N = 500500;\nint a[N];\nint c[N];\nint n;\n\nint solve(int L, int R) {\n\t/*\n\teprintf(""solve\\n"");\n\tfor (int i = L; i <= R; i++)\n\t\teprintf(""%d "", a[i]);\n\teprintf(""\\n"");\n\t*/\n\tif (a[L] > a[R]) return N;\n\tint len = R - L;\n\tfor (int i = 0; i < len; i++)\n\t\tc[i] = INF;\n\tc[0] = 0;\n\tfor (int i = L + 1; i < R; i++) {\n\t\tif (a[i] < a[L] || a[i] > a[R]) continue;\n\t\tint p = upper_bound(c, c + len, a[i]) - c;\n\t\tc[p] = a[i];\n\t}\n\tint ans = len - 1;\n\twhile(c[ans] == INF) ans--;\n\treturn len - 1 - ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint k;\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\ta[i] += n - i;\n\t}\n\ta[0] = 0;\n\ta[n + 1] = INF - 2;\n\tn += 2;\n\tint ans = 0;\n\tint lst = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tans += solve(lst, x);\n\t\tif (ans >= N) {\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tlst = x;\n\t}\n\tans += solve(lst, n - 1);\n\tif (ans >= N) {\n\t\tprintf(""-1\\n"");\n\t} else {\n\t\tprintf(""%d\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']","['binary search', 'constructive algorithms', 'data structures', 'dp', 'implementation']",2200
https://codeforces.com//contest/1016/problem/F,F. Road Projects,There are n cities in the country of Berland Some of them are connected by bidirectional roads in such a way that there exists path which visits each road no more than once between every pair of cities Each road has its own length Cities are numbered from 1 to n The travelling time between some cities v and u is the total length of the roads on the shortest path from v to u The two most important cities in Berland are cities 1 and n The Berland Ministry of Transport decided to build a single new road to decrease the traffic between the most important cities However lots of people are used to the current travelling time between the most important cities so the new road shouldn t change it too much The new road can only be built between such cities v and u that v neq u and v and u aren t already connected by some road They came up with m possible projects Each project is just the length x of the new road Polycarp works as a head analyst at the Berland Ministry of Transport and it s his job to deal with all those m projects For the i th project he is required to choose some cities v and u to build the new road of length x i between such that the travelling time between the most important cities is Unfortunately Polycarp is not a programmer and no analyst in the world is capable to process all projects using only pen and paper Thus he asks you to help him to calculate the maximal possible travelling time between the most important cities for each project Note that the choice of v and u can differ for different projects ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=303030;\nint n, m;\nvector<pair<LL,LL>> v[N];\nvector<int> cen;\nvector<LL> dst;\nbool on_cen[N];\nbool go(int now, int prt, LL cur=0){\n  if(now == n){\n    cen.push_back(now);\n    dst.push_back(cur);\n    return true;\n  }\n  for(auto e: v[now]){\n    int son=e.first;\n    if(son == prt) continue;\n    if(go(son, now, cur+e.second)){\n      cen.push_back(now);\n      dst.push_back(cur);\n      return true;\n    }\n  }\n  return false;\n}\nvoid gogo(int now, int prt, LL cur, int& who, LL& dd){\n  if(now != prt){\n    if(who){\n      who=-1;\n      dd=0;\n      return;\n    }\n    who=now;\n    dd=cur;\n  }\n  for(auto e: v[now]){\n    int son=e.first;\n    if(on_cen[son] or son==prt) continue;\n    gogo(son, now, cur+e.second, who, dd);\n  }\n}\nbool flag;\nint nei[N];\nLL dei[N], bst=-1e16;\nvoid upd(LL con){\n  bst=max(bst, con);\n}\nint main(){\n  scanf(""%d%d"", &n, &m);\n  for(int i=1; i<n; i++){\n    int ui, vi, wi;\n    scanf(""%d%d%d"", &ui, &vi, &wi);\n    v[ui].push_back({vi, wi});\n    v[vi].push_back({ui, wi});\n  }\n  assert(go(1, 1));\n  reverse(cen.begin(), cen.end());\n  reverse(dst.begin(), dst.end());\n  for(int i: cen) on_cen[i]=true;\n  for(int i: cen){\n    gogo(i, i, 0, nei[i], dei[i]);\n    if(nei[i] == -1) flag=true;\n  }\n  for(size_t i=0; i<cen.size(); i++){\n    if(i > 1) upd(-(dst[i]-dst[i-2]));\n    if(nei[cen[i]]){\n      if(i) upd(dei[cen[i]]-(dst[i]-dst[i-1]));\n      if(i+1<cen.size()) upd(dei[cen[i]]-(dst[i+1]-dst[i]));\n      if(i and nei[cen[i-1]])\n        upd(dei[cen[i]]+dei[cen[i-1]]-(dst[i]-dst[i-1]));\n    }\n  }\n  while(m --){\n    LL x; scanf(""%lld"", &x);\n    LL ans=dst.back();\n    if(not flag)\n      ans=min(ans, ans+bst+x);\n    printf(""%lld\\n"", ans);\n  }\n}\n']","['dfs and similar', 'dp', 'trees']",2600
https://codeforces.com//contest/1165/problem/B,B. Polycarp Training,Polycarp wants to train before another programming competition During the first day of his training he should solve exactly 1 problem during the second day exactly 2 problems during the third day exactly 3 problems and so on During the k th day he should solve k problems Polycarp has a list of n contests the i th contest consists of a i problems During each day Polycarp has to choose of the contests he didn t solve yet and solve it He solves Other problems are discarded from it If there are no contests consisting of at least k problems that Polycarp didn t solve yet during the k th day then Polycarp stops his training How many days Polycarp can train if he chooses the contests optimally ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N =2e5+10;\nint a[N];\nint main(){\n\tint n;\n\tscanf(""%d"",&n);\n\tfor(int i=0;i<n;i++)scanf(""%d"",&a[i]);\n\tsort(a,a+n);\n\tint ans=0;\n\tfor(int i=0;i<n;i++)if(a[i]>=ans+1)ans++;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","['data structures', 'greedy', 'sortings']",1000
https://codeforces.com//contest/906/problem/B,B. Seating of Students,Students went into a class to write a test and sat in some way The teacher thought Probably they sat in this order to copy works of each other I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating The class can be represented as a matrix with rows and columns with a student in each cell Two students are neighbors if cells in which they sit have a common side Let s enumerate students from to in order of rows So a student who initially sits in the cell in row and column has a number You have to find a matrix with rows and columns in which all numbers from to appear exactly once and adjacent numbers in the original matrix are not adjacent in it or determine that there is no such matrix ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,p[N],px[N],py[N],q[N];\n\nbool adj(int u,int v) {\n\tif (u>v) swap(u,v);\n\tif (px[u]==px[v]&&py[u]+1==py[v]) return 1;\n\tif (py[u]==py[v]&&px[u]+1==px[v]) return 1;\n\treturn 0;\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,n*m) px[i]=i/m,py[i]=i%m;\n\twhile (clock()<=1.9*CLOCKS_PER_SEC) {\n\t\trep(i,0,n*m) p[i]=i;\n\t\trandom_shuffle(p,p+n*m);\n\t\tset<PII> hs;\n\t\trep(i,0,n*m) hs.insert(mp(p[i],i));\n\t\tbool val=1;\n\t\trep(i,0,n*m) {\n\t\t\tint x=i/m,y=i%m;\n\t\t\tauto it=hs.begin();\n\t\t\tbool suc=0;\n\t\t\twhile (1) {\n\t\t\t\tsuc=1;\n\t\t\t\tq[i]=it->se;\n\t\t\t\tif (y&&adj(q[i],q[i-1])) { suc=0; }\n\t\t\t\tif (x&&adj(q[i],q[i-m])) { suc=0; }\n\t\t\t\tif (suc) { hs.erase(it); break; }\n\t\t\t\tit++;\n\t\t\t\tif (it==hs.end()) break;\n\t\t\t}\n\t\t\tif (suc==0) { val=0; break; }\n\t\t}\n\t\tif (val) {\n\t\t\tputs(""YES"");\n\t\t\trep(i,0,n*m) {\n\t\t\t\tprintf(""%d "",q[i]+1);\n\t\t\t\tif (i%m==m-1) puts("""");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""NO"");\n}\n']","['brute force', 'constructive algorithms', 'math']",2200
https://codeforces.com//contest/907/problem/B,B. Tic-Tac-Toe,Two bears are playing tic tac toe via mail It s boring for them to play usual tic tac toe game so they are a playing modified version of this game Here are its rules The game is played on the following field Players are making moves by turns At first move a player can put his chip in any cell of any small field For following moves there are some restrictions if during last move the opposite player put his chip to cell with coordinates in some small field the next move should be done in one of the cells of the small field with coordinates For example if in the first move a player puts his chip to lower left cell of central field then the second player on his next move should put his chip into some cell of lower left field pay attention to the first test case If there are no free cells in the required field the player can put his chip to any empty cell on any field You are given current state of the game and coordinates of cell in which the last move was done You should find all cells in which the current player can put his chip A hare works as a postman in the forest he likes to foul bears Sometimes he changes the game field a bit so the current state of the game could be unreachable However after his changes the cell where the last move was done is not empty You don t need to find if the state is unreachable or not just output possible next moves according to the rules ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define _USE_MATH_DEFINES\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef complex<ld> pt;\ntypedef vector<pt> pol;\n#define nl \'\\n\'\n\n///* advent of code\ntypedef istringstream iss;\n#define pb push_back\n#define ins insert\n#define multiset mset\n#define getl(A) getline(cin, A)\n//*/\n\nconst ll INF = 0x3f3f3f3f;\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tstring grid[3][3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tcin >> grid[i][k][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint a, b;\n\tcin >> a >> b;\n\n\tint gi = (a-1)%3;\n\tint gj = (b-1)%3;\n\n\tbool shit = true;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (grid[gi][gj][i][j] == \'.\')\n\t\t\t\tshit = false;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (shit || i == gi && k == gj) {\n\t\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\t\tif (grid[i][k][j][l] == \'.\')\n\t\t\t\t\t\t\tcout << ""!"";\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcout << grid[i][k][j][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << "" "";\n\t\t\t\t} else {\n\t\t\t\t\tcout << grid[i][k][j] << "" "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << nl;\n\t\t}\n\t\tcout << nl;\n\t}\n\n\treturn 0;\n}\n']",['implementation'],1400
https://codeforces.com//contest/1486/problem/F,F. Pairs of Paths,You are given a tree consisting of n vertices and m simple vertex paths Your task is to find how many pairs of those paths intersect at exactly one vertex More formally you have to find the number of pairs i j 1 leq i j leq m such that path i and path j have exactly one vertex in common ,"['//#pragma GCC target(""avx,avx2"")\t\n#include<bits/stdc++.h>\n//#include<immintrin.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nchar readc()\n{\n\tchar c;\n\twhile(isspace(gc));\n\treturn c;\n}\nint read()\n{\n\tchar c;\n\twhile(gc<\'-\');\n\tif(c==\'-\')\n\t{\n\t\tint x=gc-\'0\';\n\t\twhile(gc>=\'0\')x=x*10+c-\'0\';\n\t\treturn -x;\n\t}\n\tint x=c-\'0\';\n\twhile(gc>=\'0\')x=x*10+c-\'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N=3e5+5;\nvector<int>lk[N];\nvector<pii>lk_q[N];\nint fa[N],sz[N],dep[N],son[N],top[N];\nint s[N],cnt[N];\n\nnamespace BING\n{\nint fa[N];\nint find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n\t}\t\n};\n\nvoid dfs(int x,int fr)\n{\n\tsz[x]=1;\n\tdep[x]=dep[fr]+1;\n\tfa[x]=fr;\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tdfs(y,x);\n\t\tsz[x]+=sz[y];\n\t\tif(sz[y]>sz[son[x]])son[x]=y;\n\t}\n}\nint get_lca(int x,int y)\n{\n\twhile(top[x]!=top[y])\n\tif(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];\n\treturn dep[x]<dep[y]?x:y;\n}\ns64 ans;\nvoid work(int x)\n{\n\tfor(auto y:lk[x])\n\tif(y!=fa[x])\n\t{\n\t\twork(y);\n\t\ts[x]+=s[y];\n\t}\n\tmap<pii,int>c;int tot=0;\n\tfor(auto p:lk_q[x])\n\t{\n\t\tint x1,y1;\n\t\ttie(x1,y1)=p;\n\t\tx1=BING::find(x1);\n\t\ty1=BING::find(y1);\n\t\tif(x1==x)x1=0;\n\t\telse --s[x1];\n\t\tif(y1==x)y1=0;\n\t\telse --s[y1];\n\t\tif(x1>y1)swap(x1,y1);\n\t\t\n\t\tif(x1)\n\t\t\tans+=tot-cnt[x1]-cnt[y1]+c[pii(x1,y1)];\n\t\telse \n\t\tif(y1)\n\t\t\tans+=tot-cnt[y1];\n\t\telse \n\t\t\tans+=tot;\n\t\t\n\t\t++tot;\n\t\t++c[pii(x1,y1)];\n\t\t++cnt[x1];++cnt[y1];\n\t}\n\tans+=s64(s[x])*tot;\n\t\n\tfor(auto y:lk[x])\n\tif(y!=fa[x])\n\t{\n\t\tBING::fa[y]=x;\n\t\tans+=s64(s[y])*(-cnt[y]);\n\t}\n}\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(""1.in"",""r"",stdin);//freopen(""1.out"",""w"",stdout);\n#endif\t\n\tint n=read();\n\trep(i,1,n)BING::fa[i]=i;\n\trep(i,1,n-1)\n\t{\n\t\tint x=read(),y=read();\n\t\tlk[x].push_back(y);\n\t\tlk[y].push_back(x);\n\t}\n\tdfs(1,0);\n\trep(x,1,n)\n\tif(x!=son[fa[x]])\n\t\tfor(int y=x;y;y=son[y])top[y]=x;\n\tint m=read();\n\trep(i,1,m)\n\t{\n\t\tint x=read(),y=read();\n\t\tint lca=get_lca(x,y);\n\t\t++s[x];++s[y];\n\t\ts[lca]-=2;\n\t\tlk_q[lca].push_back({x,y});\n\t}\n\twork(1);\n\tcout<<ans<<endl;\n}\n']","['combinatorics', 'data structures', 'dfs and similar', 'dp', 'trees']",2600
https://codeforces.com//contest/1469/problem/B,B. Red and Blue,Monocarp had a sequence a consisting of n m integers a 1 a 2 dots a n m He painted the elements into two colors red and blue n elements were painted red all other m elements were painted blue After painting the elements he has written two sequences r 1 r 2 dots r n and b 1 b 2 dots b m The sequence r consisted of all red elements of a similarly the sequence b consisted of all blue elements of a Unfortunately the original sequence was lost and Monocarp only has the sequences r and b He wants to restore the original sequence In case there are multiple ways to restore it he wants to choose a way to restore that maximizes the value of f a max 0 a 1 a 1 a 2 a 1 a 2 a 3 dots a 1 a 2 a 3 dots a n m Help Monocarp to calculate the maximum possible value of f a ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        int mx0 = 0, mx1 = 0, s = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            std::cin >> x;\n            s += x;\n            mx0 = std::max(mx0, s);\n        }\n        s = 0;\n        int m;\n        std::cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int x;\n            std::cin >> x;\n            s += x;\n            mx1 = std::max(mx1, s);\n        }\n        std::cout << mx0 + mx1 << ""\\n"";\n    }\n    return 0;\n}']","['dp', 'greedy']",1000
https://codeforces.com//contest/507/problem/B,B. Amr and Pins,Amr loves Geometry One day he came up with a very interesting problem Amr has a circle of radius and center in point He wants the circle center to be in new position In one step Amr can put a pin to the border of the circle in a certain point then rotate the circle around that pin by any angle and finally remove the pin Help Amr to achieve his goal in minimum number of steps ,"['#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint sgn(double x) {\n    if (fabs(x) < 1e-8) {\n        return 0;\n    }\n    return x > 0 ? 1 : -1;\n}\n\nint main() {\n    int r, x, y, a, b;\n    scanf(""%d%d%d%d%d"", &r, &x, &y, &a, &b);\n    double dis = (x * 1.0 - a) * (x * 1.0 - a) + (y * 1.0 - b) * (y * 1.0 - b);\n    dis = sqrt(dis);\n    int cnt = 0;\n    while (sgn(dis) > 0) {\n        dis -= 2 * r;\n        cnt ++;\n    }\n    printf(""%d\\n"", cnt);\n    return 0;\n}']","['geometry', 'math']",1400
https://codeforces.com//contest/1039/problem/C,C. Network Safety,The Metropolis computer network consists of n servers each has an encryption key in the range from 0 to 2 k 1 assigned to it Let c i be the encryption key assigned to the i th server Additionally m pairs of servers are directly connected via a data communication channel Because of the encryption algorithms specifics a data communication channel can only be considered safe if the two servers it connects have encryption keys The initial assignment of encryption keys is guaranteed to keep all data communication channels safe You have been informed that a new virus is actively spreading across the internet and it is capable to change the encryption key of any server it infects More specifically the virus body contains some unknown number x in the same aforementioned range and when server i is infected its encryption key changes from c i to c i oplus x where oplus denotes the bitwise XOR operation Sadly you know neither the number x nor which servers of Metropolis are going to be infected by the dangerous virus so you have decided to count the number of such situations in which all data communication channels remain safe Formally speaking you need to find the number of pairs A x where A is some possibly empty subset of the set of servers and x is some number in the range from 0 to 2 k 1 such that when all servers from the chosen subset A and none of the others are infected by a virus containing the number x all data communication channels remain safe Since this number can be quite big you are asked to find its remainder modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 500500;\nint n, m, k;\nll a[N];\nll p2[N];\nmap<ll, vector<pii>> G;\nint par[N];\nint sz[N];\n\nmap<int, int> toId;\nint getId(int v) {\n\tif (toId.count(v) > 0) return toId[v];\n\ttoId[v] = m;\n\tpar[m] = -1;\n\tsz[m] = 1;\n\treturn m++;\n}\n\nint getPar(int v) {\n\treturn par[v] == -1 ? v : par[v] = getPar(par[v]);\n}\nbool unite(int v, int u) {\n\tv = getPar(v);\n\tu = getPar(u);\n\tif (v == u) return false;\n\tif (sz[v] < sz[u]) swap(v, u);\n\tsz[v] += sz[u];\n\tpar[u] = v;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\t}\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tll ans = p2[n + k];\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tG[a[v] ^ a[u]].push_back(mp(v, u));\n\t}\n\tfor (auto t : G) {\n\t\tvector<pii> g = t.second;\n\t\tm = 0;\n\t\ttoId.clear();\n\t\tint C = n;\n\t\tfor (pii s : g) {\n\t\t\tint v = getId(s.first), u = getId(s.second);\n\t\t\tif (unite(v, u)) C--;\n\t\t}\n\t\tans = sub(ans, p2[n]);\n\t\tans = add(ans, p2[C]);\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['dfs and similar', 'dsu', 'graphs', 'math', 'sortings']",2200
https://codeforces.com//contest/670/problem/D2,D2. Magic Powder - 2,The term of this problem is the same as the previous one the only exception increased restrictions ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\n    int n, k;\n    vector <int> a, b;\n\nbool can(ll x) {\n    ll need = 0;\n    for (int i = 0; i < n; ++i) {\n        need += max(0LL, a[i] * 1LL * x - b[i]);\n        if (need >k) return false;\n    }\n    return need <= k;\n}\n\nint main() {\n\n  //  freopen(""input.txt"", ""r"", stdin);\n  //  freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    a.resize(n);\n    b.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n\n    ll l = 0, r = 4LL * INF;\n    for (int iter = 0; iter < 50; ++iter) {\n        ll m = (l + r) / 2;\n        if (can(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    cout << l << \'\\n\';\n    return 0;\n}\n']","['binary search', 'implementation']",1500
https://codeforces.com//contest/1383/problem/D,D. Rearrange,Koa the Koala has a matrix A of n rows and m columns Elements of this matrix are distinct integers from 1 to n cdot m each number from 1 to n cdot m appears exactly once in the matrix For any matrix M of n rows and m columns let s define the following The i th row of M is defined as R i M M i1 M i2 ldots M im for all i 1 le i le n The j th column of M is defined as C j M M 1j M 2j ldots M nj for all j 1 le j le m Koa defines S A X Y as the spectrum of A where X is the set of the maximum values in rows of A and Y is the set of the maximum values in columns of A More formally X max R 1 A max R 2 A ldots max R n A Y max C 1 A max C 2 A ldots max C m A Koa asks you to find some matrix A of n rows and m columns such that each number from 1 to n cdot m appears exactly once in the matrix and the following conditions hold S A S A R i A is bitonic for all i 1 le i le n C j A is bitonic for all j 1 le j le m An array t t 1 t 2 ldots t k is called bitonic if it first increases and then decreases More formally t is bitonic if there exists some position p 1 le p le k such that t 1 t 2 ldots t p t p 1 ldots t k Help Koa to find such matrix or to determine that it doesn t exist ,"['/**\n *    author:  tourist\n *    created: 24.07.2020 18:10:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h, w;\n  cin >> h >> w;\n  vector<vector<int>> a(h, vector<int>(w));\n  vector<pair<int, int>> pos(h * w);\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> a[i][j];\n      --a[i][j];\n      pos[a[i][j]] = make_pair(i, j);\n    }\n  }\n  vector<vector<int>> b(h, vector<int>(w, -1));\n  int pi = -1;\n  int pj = -1;\n  vector<pair<int, int>> cells;\n  int ptr = 0;\n  for (int val = h * w - 1; val >= 0; val--) {\n    for (int i = 0; i < h; i++) debug(b[i]);\n    debug(pi, pj, cells);\n    auto& at = pos[val];\n    int vi = at.first;\n    int vj = at.second;\n    bool row_max = true;\n    for (int j = 0; j < w; j++) {\n      row_max &= (a[vi][j] <= val);\n    }\n    bool col_max = true;\n    for (int i = 0; i < h; i++) {\n      col_max &= (a[i][vj] <= val);\n    }\n    debug(val, vi, vj, row_max, col_max);\n    if (row_max && col_max) {\n      b[++pi][++pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    if (row_max) {\n      b[++pi][pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      continue;\n    }\n    if (col_max) {\n      b[pi][++pj] = val;\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    assert(ptr < (int) cells.size());\n    b[cells[ptr].first][cells[ptr].second] = val;\n    ++ptr;\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (j > 0) {\n        cout << "" "";\n      }\n      cout << b[i][j] + 1;\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'constructive algorithms', 'graphs', 'greedy', 'sortings']",2800
https://codeforces.com//contest/1025/problem/B,B. Weakened Common Divisor,During the research on properties of the greatest common divisor of a set of numbers Ildar a famous mathematician introduced a brand new concept of the weakened common divisor of a list of pairs of integers For a given list of pairs of integers a 1 b 1 a 2 b 2 a n b n their is arbitrary integer greater than 1 such that it divides at least one element in each pair WCD may not exist for some lists For example if the list looks like 12 15 25 18 10 24 then their WCD can be equal to 2 3 5 or 6 each of these numbers is strictly greater than 1 and divides at least one number in each pair You re currently pursuing your PhD degree under Ildar s mentorship and that s why this problem was delegated to you Your task is to calculate efficiently ,"['#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<""=""<<h<<""\\n""; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != \',\')cerr<<*sdbg++; cerr<<""=""<<h<<"",""; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<"" = ""; FORE(itt, (x)) cerr <<*itt <<"", ""; cerr <<""\\n""; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << ""("" << pair.first << "", "" << pair.second << "")"";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << ""("" << t.st << "", "" << t.nd << "", "" << t.rd << "")""; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\n\nconst int N = 1e6 + 5;\nint a[N], b[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  int g = 0;\n  RE (i, n) {\n    cin>>a[i]>>b[i];\n    g = __gcd(g, a[i] * b[i]);\n  }\n  if (g == 1) {\n    cout<<""-1\\n"";\n    return 0;\n  }\n  RE (i, n) {\n    int cand = __gcd(g, a[i]);\n    if (cand > 1) {\n      g = cand;\n    }\n    cand = __gcd(g, b[i]);\n    if (cand > 1) {\n      g = cand;\n    }\n  }\n  cout<<g<<endl;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n']","['brute force', 'greedy', 'number theory']",1600
https://codeforces.com//contest/1750/problem/C,C. Complementary XOR,You have two binary strings a and b of length n You would like to make all the elements of both strings equal to 0 Unfortunately you can modify the contents of these strings using only the following operation You choose two indices l and r 1 le l le r le n For every i that respects l le i le r change a i to the opposite That is a i 1 a i For every i that respects either 1 le i l or r i le n change b i to the opposite That is b i 1 b i Your task is to determine if this is possible and if it is to find such an appropriate chain of operations The number of operations n 5 It can be proven that if such chain of operations exists one exists with at most n 5 operations ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tints(N);\n\tstr A, B;\n\tre(A, B);\n\tbool neq = 0;\n\tif (A != B) {\n\t\tneq = 1;\n\t\teach(c, B) c = \'0\' + \'1\' - c;\n\t}\n\tif (A != B) {\n\t\tps(""NO"");\n\t\treturn;\n\t}\n\tps(""YES"");\n\tvpi op;\n\tbool cur_xo = 0;\n\tR0F(i, sz(A)) {\n\t\tif (A[i] != (\'0\' + cur_xo)) {\n\t\t\top.pb({0, i});\n\t\t\tcur_xo ^= 1;\n\t\t}\n\t}\n\tif ((sz(op) & 1) != neq) {\n\t\top.pb({0, 1});\n\t\top.pb({0, 0});\n\t\top.pb({1, 1});\n\t}\n\tps(sz(op));\n\tfor (auto [l, r] : op) ps(l + 1, r + 1);\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['constructive algorithms', 'implementation']",1400
https://codeforces.com//contest/1121/problem/A,A. Technogoblet of Fire,Everybody knows that the m coder Tournament will happen soon m schools participate in the tournament and only one student from each school participates There are a total of n students in those schools Before the tournament all students put their names and the names of their schools into the Technogoblet of Fire After that Technogoblet selects the strongest student from each school to participate Arkady is a hacker who wants to have k Chosen Ones selected by the Technogoblet Unfortunately not all of them are the strongest in their schools but Arkady can make up some new school names and replace some names from Technogoblet with those You can t use each made up name more than once In that case Technogoblet would select the strongest student in those made up schools too You know the power of each student and schools they study in Calculate the minimal number of schools Arkady has to make up so that k Chosen Ones would be selected by the Technogoblet ,"['#include <bits/stdc++.h>                                                                                                                                                                                                                                                                                             //YaMeshok\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace std;\n\nconst int MXN = 5e5 + 30;\n\nint n, m, k;\n\nint a[MXN];\nint b[MXN];\n\nint x;\n\nint ans = 0;\n\nint main(){\n    #ifdef DIAS\n        freopen(""input.txt"", ""r"", stdin);\n        //freopen(""output.txt"", ""w"", stdout);\n    #elif NAME \n    \tfreopen(fn"".in"", ""r"", stdin);\n    \tfreopen(fn"".out"", ""w"", stdout);\n    #endif\n\tcin >> n >> m >> k;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> b[i];\n\t}\n\tfor(int i = 1; i <= k; i++){\n\t\tcin >> x;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(b[i] == b[x] && a[i] > a[x]){\n\t\t\t\tans ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n}\n']","['implementation', 'sortings']",1100
https://codeforces.com//contest/1626/problem/B,B. Minor Reduction,You are given a decimal representation of an integer x without leading zeros You have to perform the following reduction on it take two neighboring digits in x and replace them with their sum without leading zeros if the sum is 0 it s represented as a single 0 For example if x 10057 the possible reductions are choose the first and the second digits 1 and 0 replace them with 1 0 1 the result is 1057 choose the second and the third digits 0 and 0 replace them with 0 0 0 the result is also 1057 choose the third and the fourth digits 0 and 5 replace them with 0 5 5 the result is still 1057 choose the fourth and the fifth digits 5 and 7 replace them with 5 7 12 the result is 10012 What s the largest number that can be obtained ,"['#pragma region Macros\n//#pragma GCC target(""avx2"")\n// #pragma GCC optimize(""O3"")\n// #pragma comment(linker, ""/stack:200000000"")\n#ifdef ONLINE_JUDGE\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2"")\n// #pragma GCC target(""avx2"")\n#endif\n#pragma GCC optimize(""Ofast"")\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl \'\\n\'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= b; i -= c)\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define rng(v, l, r) v.begin() + l, v.begin() + r\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {""NO"", ""YES""};\nconst string YesNo[2] = {""No"", ""Yes""};\nconst string yesno[2] = {""no"", ""yes""};\nconst string firstsecond[2] = {""second"", ""first""};\nconst string FirstSecond[2] = {""Second"", ""First""};\nconst string possiblestr[2] = {""impossible"", ""possible""};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\n\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\n// bit 演算系\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - \'0\'; }\n    }\n    if(s[0] == \'-\') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << ""0""); }\n    i128 num = v;\n    if(v < 0) {\n        os << \'-\';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + \'0\'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? "", "" : "" "");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << \'(\'; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << \')\'; }\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << ""("" << p.first << "", "" << p.second << "")""; }\n    return os << p.first << "" "" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << ""["";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? """" : "", "") << y;\n        else\n            os << (f ? """" : "" "") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << ""]"";\n    return os;\n}\n\n#ifdef noimi\n#undef endl\nvoid debug() { cerr << endl; }\nvoid debug(bool) { cerr << endl; }\ntemplate <class Head, class... Tail> void debug(bool is_front, Head head, Tail... tail) {\n    if(!is_front) cerr << "", "";\n    cerr << head;\n    debug(false, tail...);\n}\n\n#define dump(args...)                                                                                                                                          \\\n    {                                                                                                                                                          \\\n        vector<string> _debug = _split(#args, \',\');                                                                                                            \\\n        err(true, begin(_debug), args);                                                                                                                        \\\n    }\n\nvector<string> _split(const string &s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while(getline(ss, x, c)) {\n        if(empty(v))\n            v.eb(x);\n        else {\n            bool flag = false;\n            for(auto [c, d] : {pair(\'(\', \')\'), pair(\'[\', \']\'), pair(\'{\', \'}\')}) {\n                if(count(all(v.back()), c) != count(all(v.back()), d)) flag = true;\n            }\n            if(flag)\n                v.back() += "","" + x;\n            else\n                v.eb(x);\n        }\n    }\n    return move(v);\n}\n\nvoid err(bool, vector<string>::iterator) { cerr << endl; }\ntemplate <typename T, typename... Args> void err(bool is_front, vector<string>::iterator it, T a, Args... args) {\n    if(!is_front) cerr << "", "";\n    cerr << it->substr((*it)[0] == \' \', (*it).size()) << "" = "" << a, err(false, ++it, args...);\n}\n\n// #define dump(...) cerr << #__VA_ARGS__ << "" : "", debug(true, __VA_ARGS__)\n#else\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n#endif\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << \' \';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(std::forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, std::forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nint toint(const char &c, const char start = \'a\') { return c - start; }\nint toint(const char &c, const string &chars) { return find(all(chars), c) - begin(chars); }\nint alphabets_to_int(const char &c) { return (islower(c) ? c - \'a\' : c - \'A\' + 26); }\ntemplate <typename T> auto toint(const T &v, const char &start = \'a\') {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\ntemplate <typename T> auto toint(const T &v, const string &start) {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\n// a -> 0, A -> 26\ntemplate <typename T> auto alphabets_to_int(const T &s) {\n    vector<decltype(alphabets_to_int(s[0]))> res;\n    res.reserve(s.size());\n    for(auto &&e : s) { res.emplace_back(alphabets_to_int(e)); }\n    return res;\n}\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        T mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#pragma endregion\n\nint main() {\n    TEST {\n        STR(s);\n        auto a = toint(s, \'0\');\n        bool flag = false;\n        rep(i, si(a) - 1) if(a[i] + a[i + 1] > 9) flag = true;\n        if(flag) {\n            per(i, si(a)) {\n                if(a[i] + a[i - 1] > 9) {\n                    int x = a[i] + a[i - 1];\n                    a[i - 1] = 1;\n                    a[i] = x % 10;\n                    break;\n                }\n            }\n        } else {\n            a[1] += a[0];\n            a.erase(begin(a));\n        }\n        fore(e, a) cout << e;\n        OUT();\n    }\n}']","['greedy', 'strings']",1100
https://codeforces.com//contest/1093/problem/B,B. Letters Rearranging,You are given a string s consisting only of lowercase Latin letters You can rearrange all letters of this string as you wish Your task is to obtain a string by rearranging the letters of the given string or report that it is impossible to do it Let s call a string if it is not a palindrome Palindrome is a string which is read from left to right the same as from right to left For example strings and are palindromes and strings are not You have to answer t queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    while (t--) {\n        string s; cin >> s;\n        sort(s.begin(), s.end());\n        string t = s;\n        reverse(t.begin(), t.end());\n        if (s == t) cout << -1 << endl;\n        else cout << s << endl;\n    }\n}\n']","['constructive algorithms', 'greedy', 'sortings', 'strings']",900
https://codeforces.com//contest/137/problem/A,A. Postcards and photos,Polycarpus has postcards and photos hung in a row on the wall He decided to put them away to the closet and hang on the wall a famous painter s picture Polycarpus does it like that he goes from the left to the right and removes the objects consecutively As Polycarpus doesn t want any mix ups to happen he will not carry in his hands objects of two different types In other words Polycarpus can t carry both postcards and photos simultaneously Sometimes he goes to the closet and puts the objects there thus leaving his hands free Polycarpus must put the postcards and photos to the closet He cannot skip objects What minimum number of times he should visit the closet if he cannot carry more than 5 items ,"['#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nint main(){\n    char s[200];\n    int ans=1,cnt=1;\n    gets(s);\n    for(int i=1;s[i];i++){\n        if(s[i]==s[i-1] && cnt<5) cnt++;\n        else{\n            cnt=1;\n            ans++;\n        }\n    }\n    printf(""%d\\n"",ans);\n}\n']",['implementation'],900
https://codeforces.com//contest/1003/problem/F,F. Abbreviation,You are given a text consisting of n space separated words There is exactly one space character between any pair of adjacent words There are no spaces before the first word and no spaces after the last word The length of text is the number of letters and spaces in it w i is the i th word of text All words consist only of lowercase Latin letters Let s denote a segment of words w i j as a sequence of words w i w i 1 dots w j Two segments of words w i 1 j 1 and w i 2 j 2 are considered if j 1 i 1 j 2 i 2 j 1 ge i 1 j 2 ge i 2 and for every t in 0 j 1 i 1 w i 1 t w i 2 t For example for the text the segments w 1 2 and w 5 6 are equal they correspond to the words An abbreviation is a replacement of some segments of words with their first letters In order to perform an abbreviation you have to choose non intersecting equal segments of words and replace each chosen segment with the string consisting of first letters of the words in the segment written in uppercase For example for the text you can replace segments of words w 2 4 and w 6 8 with an abbreviation and obtain the text or you can replace segments of words w 2 5 and w 6 9 with an abbreviation and obtain the text What is the minimum length of the text after at most one abbreviation ,"['#include ""bits/stdc++.h""\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<""----------------""<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<"" = ""<< x<<endl;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nconst int N=303;\nint par[N][N];\nint sz[N];\nchar s[N][MAXN];\nbool h[N][N][N],ok[N][N];\nint mod(ll x){\n\treturn (x%INF);\n}\nbool equal(int x,int y){\n\tif(sz[x]!=sz[y])\n\t\treturn 0;\n\tfor(int i=0;i<sz[x];i++)\n\t\tif(s[x][i]!=s[y][i])\n\t\t\treturn 0;\n\treturn 1;\t\t\n}\nint main(){\n    //~ freopen(""file.in"", ""r"", stdin);\n    int n;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++){\n\t\tscanf(""%s"",s[i]);\n\t\tsz[i]=strlen(s[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tpar[i][i]=sz[i];\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tpar[i][j]=par[i][j-1]+sz[j]+1;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tok[i][j]=equal(i,j);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(j+k>n or i+k>n or !ok[i+k-1][j+k-1])\n\t\t\t\t\tbreak;\n\t\t\t\th[i][j][k]=1;\t\n\t\t\t}\n\tint ans=par[0][n-1];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j+i<=n;j++){\n\t\t\tint now=j+i,cnt=1;\n\t\t\twhile(now+i<=n){\n\t\t\t\tif(h[j][now][i])\n\t\t\t\t\tnow+=i,cnt++;\n\t\t\t\telse\n\t\t\t\t\tnow++;\n\t\t\t\tif(cnt>=2)\n\t\t\t\t\tumin(ans,par[0][n-1]-cnt*par[j][j+i-1]+cnt*i);\t\n\t\t\t}\n\t\t}\n\tprintf(""%d\\n"",ans);\t\n\treturn 0;\n}\n']","['dp', 'hashing', 'strings']",2200
https://codeforces.com//contest/1608/problem/F,F. MEX counting,For an array c of nonnegative integers MEX c denotes the smallest nonnegative integer that doesn t appear in it For example MEX 0 1 3 2 MEX 42 0 You are given integers n k and an array b 1 b 2 ldots b n Find the number of arrays a 1 a 2 ldots a n for which the following conditions hold 0 le a i le n for each i for each i from 1 to n MEX a 1 a 2 ldots a i b i le k for each i from 1 to n As this number can be very big output it modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nconst int nmax=2010;\nmint dp[2][nmax][nmax];\nint len[2][nmax];\nint cur,nx;\nvoid clear(){\n\tzero(dp[nx]);\n\tzero(len[nx]);\n}\nvoid add(int i,int j,mint v){\n\tdp[nx][i][j]+=v;\n\tchmax(len[nx][i],j+1);\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvc<pi> lr(n+1);\n\tlr[0]=pi(0,1);\n\trep(i,n){\n\t\tint b;cin>>b;\n\t\tlr[i+1]=pi(max(b-k,0),min(b+k,n)+1);\n\t}\n\trep(i,n)chmax(lr[i+1].a,lr[i].a);\n\tper(i,n)chmin(lr[i].b,lr[i+1].b);\n\trep(i,n+1)if(lr[i].a>=lr[i].b){\n\t\treturn print(0);\n\t}\n\tdmp(lr);\n\tnx=1;\n\trng(i,lr[n].a,lr[n].b)\n\t\tadd(i,1,1);\n\tswap(cur,nx);\n\tper(step,n){\n\t\tclear();\n\t\trng(i,max(lr[step+1].a,1),lr[step+1].b){\n\t\t\trep(j,len[cur][i]){\n\t\t\t\tadd(i-1,j+1,dp[cur][i][j]);\n\t\t\t}\n\t\t}\n\t\tgnr(i,lr[step].a+1,lr[step+1].b){\n\t\t\trep(j,len[nx][i]){\n\t\t\t\tadd(i-1,j,dp[nx][i][j]);\n\t\t\t\tadd(i-1,j+1,-dp[nx][i][j]);\n\t\t\t}\n\t\t}\n\t\trng(i,lr[step+1].a,lr[step+1].b){\n\t\t\trep(j,len[cur][i]){\n\t\t\t\tadd(i,j,dp[cur][i][j]*(n+1-j));\n\t\t\t}\n\t\t}\n\t\tswap(cur,nx);\n\t}\n\tmint ans=0;\n\trep(j,len[cur][0])\n\t\tans+=dp[cur][0][j];\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['combinatorics', 'dp', 'implementation']",3200
https://codeforces.com//contest/1073/problem/B,B. Vasya and Books,Vasya has got n books numbered from 1 to n arranged in a stack The topmost book has number a 1 the next one a 2 and so on The book at the bottom of the stack has number a n Vasya wants to move all the books to his backpack in n steps During i th step he wants to move the book number b i into his backpack If the book with number b i is in the stack he takes this book and all the books the book b i and puts them into the backpack otherwise he does nothing and begins the next step For example if books are arranged in the order 1 2 3 book 1 is the topmost and Vasya moves the books in the order 2 1 3 then during the first step he will move two books 1 and 2 during the second step he will do nothing since book 1 is already in the backpack and during the third step one book the book number 3 Help Vasya Tell him the number of books he will put into his backpack during each step ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", &a[i]);\n    a[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", &b[i]);\n    b[i]--;\n  }\n  vector<bool> in(n);\n  int j = 0;\n  for (int i = 0; i < n; i++) {\n    int ans = 0;\n    while (!in[b[i]]) {\n      in[a[j++]] = true;\n      ans++;\n    }\n    printf(""%d "", ans);\n  }\n  putchar(\'\\n\');\n}\n\n']","['implementation', 'math']",1000
https://codeforces.com//contest/558/problem/D,D. Guess Your Way Out  II,Amr bought a new video game Guess Your Way Out II The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node Let s index all the nodes of the tree such that The root is number Each internal node will have a left child with index and a right child with index The level of a node is defined as for a root or level of parent of the node otherwise The vertices of the level are called leaves The exit to the maze is located at some leaf node the player doesn t know where the exit is so he has to guess his way out In the new version of the game the player is allowed to ask questions on the format Does the node number belong to the range Here is the ancestor of a node that located in the level The game will answer with Yes or No only The game is designed such that it doesn t always answer correctly and sometimes it cheats to confuse the player Amr asked a lot of questions and got confused by all these answers so he asked you to help him Given the questions and its answers can you identify whether the game is telling contradictory information or not If the information is not contradictory and the exit node can be determined uniquely output its number If the information is not contradictory but the exit node isn t defined uniquely output that the number of questions is not sufficient Otherwise output that the information is contradictory ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n#define pii pair< int , int >\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\n#define int ll\n\nll i, j, k, n, m, h, q, x, y, z, dp[N], dp2[N], t, q1;\n\nll tt[N];\n\nmap< ll , int > hh, w;\n\nvector< pair< pii , int > > v;\n\nll L(ll x,ll y) { FOR(i,x+1,h) y *= 2; return y; } \nll R(ll x, ll y) { FOR(i,x+1,h) y = y * 2 + 1; return y; }\n\nmultiset< pair< ll , ll > > S;\n\nmultiset< pair< ll , ll > > :: iterator it, it2;\n\nvoid add(int x,int y,int l,int r) {\n    if(l <= x && y <= r) return ;\n    if(x > r || y < l) { S.insert(mp(x,y)); return ; } \n    if(x < l) S.insert(mp(x,l-1));\n    if(y > r) S.insert(mp(r+1,y));\n}\n\nvoid rem(int x,int y) {\n    it = S.lower_bound(mp(x,0)); \n    if(it != S.begin()) it--;\n    for(;it != S.end() && it->st <= y;){\n        it2 = it; it2++;\n        add(it->st,it->nd,x,y);\n        S.erase(it);it = it2;       \n    }    \n}\n\n main() {\n       \n   scanf(""%lld %lld"",&h,&q);\n   \n   hh[1LL<<h-1LL] = 1; hh[(1ll << h) - 1] = 1;\n   hh[(1LL<<h-1LL)-1] = 1; hh[(1ll << h)] = 1;\n   \n   S.insert(mp(1ll<<h-1,(1ll<<h)-1));\n   \n   \n   FOR(i,1,q) {\n       \n       scanf(""%lld %lld %lld %lld"",&x,&y,&z,&t);\n       ll l = L(x,y);\n       ll r = R(x,z);\n       \n      if(t == 0) rem(l,r);\n      else rem(0,l-1), rem(r+1,1ll<<h);\n       \n   }\n   \n   if(!S.size()) cout << ""Game cheated!"" << endl;\n   else if(S.size() != 1 || S.begin()->st != S.begin()->nd) { cout << ""Data not sufficient!\\n""; }\n   else cout << S.begin()->st << endl;\n    \n}']","['data structures', 'implementation', 'sortings']",2300
https://codeforces.com//contest/1498/problem/A,A. GCD Sum,The text gcdSum of a positive integer is the gcd of that integer with its sum of digits Formally text gcdSum x gcd x text sum of digits of x for a positive integer x gcd a b denotes the greatest common divisor of a and b the largest integer d such that both integers a and b are divisible by d For example text gcdSum 762 gcd 762 7 6 2 gcd 762 15 3 Given an integer n find the smallest integer x ge n such that text gcdSum x 1 ,"['#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\ninline int gcd(re int x,re int y){return y?gcd(y,x%y):x;}\ninline bool check(re int x){\n\tre int y=x,s=0;\n\twhile(x)s+=x%10,x/=10;\n\tif(gcd(y,s)>1)return 1;\n\treturn 0;\n}\nsigned main(){\n\tt=read();\n\twhile(t--){\n\t\tn=read();\n\t\twhile(!check(n))++n;\n\t\tprintf(""%lld\\n"",n);\n\t}\n}\n']","['brute force', 'math']",800
https://codeforces.com//contest/1165/problem/C,C. Good String,Let s call yet again a string if its length is even and every character in odd position of this string is different from the next character the first character is different from the second the third is different from the fourth and so on For example the strings and are good strings and the strings and are not good You are given a string s you have to delete minimum number of characters from this string so that it becomes good ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst int N=3e6+7,mod=1e9+7,INF=1e9;\nint n,m,x,y;\nchar a[N],b[N];\nchar s[N],ss[N];\nint main()\n{\n    int cnt=0;\n    cin>>n;\n    scanf(""%s"",a+1);\n    for(int i=1;i<=n;i++){\n        if(a[i]==a[i+1]&&cnt%2==0){\n            continue;\n        }\n        else{\n            b[cnt++]=a[i];\n        }\n    }\n    if(cnt&1)cnt--;\n    cout<<n-cnt<<endl;\n    for(int i=0;i<cnt;i++){\n        printf(""%c"",b[i]);\n    }cout<<endl;\n    return 0;\n}\n\n']",['greedy'],1300
https://codeforces.com//contest/283/problem/B,B. Cow Program,Farmer John has just given the cows a program to play with The program contains two integer variables and and performs the following operations on a sequence of positive integers Initially and If after any step or the program immediately terminates The program increases both and by a value equal to simultaneously The program now increases by while decreasing by The program executes steps 2 and 3 first step 2 then step 3 repeatedly until it terminates it may never terminate So the sequence of executed steps may start with step 2 step 3 step 2 step 3 step 2 and so on The cows are not very good at arithmetic though and they want to see how the program works Please help them You are given the sequence Suppose for each we run the program on the sequence For each such run output the final value of if the program terminates or if it does not terminate ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nlng src[210000];\n\nlng yval[210000];\nint dest[210000];\nbool inside[210000];\nint n;\n\nvoid doit(lng a){\n\tif(dest[a])\n\t\treturn;\n\t\n\tif(inside[a]){\n\t\tdest[a]=-1;\n\t\treturn;\n\t}\n\n\tinside[a]=true;\n\tdo{\n\t\tyval[a]=src[a];\n\t\tlng aa=a-src[a];\n\t\tif(aa==1){\n\t\t\tdest[a]=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(aa<=0 || aa>n){\n\t\t\tdest[a]=2;\n\t\t\tbreak;\n\t\t}\n\t\tyval[a]+=src[aa];\n\t\taa+=src[aa];\n\t\tif(aa==1){\n\t\t\tdest[a]=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(aa<=0 || aa>n){\n\t\t\tdest[a]=2;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdoit(aa);\n\t\t\n\t\tdest[a]=dest[aa];\n\t\tyval[a]+=yval[aa];\n\t}while(false);\n\tinside[a]=false;\n}\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tcin>>n;\n\tforn(i,n-1){\n\t\tscanf(""%d"",src+i+2);\n\t}\n\t\n\tfor(lng v=1;v<n;++v){\n\t\tdoit(v+1);\n\t\tif(dest[v+1]==-1 || dest[v+1]==1)\n\t\t\tcout<<-1;\n\t\telse\n\t\t\tcout<<yval[v+1]+v;\n\t\tcout<<\'\\n\';\n\t}\n\n\treturn 0;\n}']","['dfs and similar', 'dp', 'graphs']",1700
https://codeforces.com//contest/1837/problem/B,B. Comparison String,You are given a string s of length n where each character is either or An array a consisting of n 1 elements is compatible with the string s if for every i from 1 to n the character s i represents the result of comparing a i and a i 1 i e s i is if and only if a i a i 1 s i is if and only if a i a i 1 For example the array 1 2 5 4 2 is compatible with the string There are other arrays with are compatible with that string for example 13 37 42 37 13 The of the array is the number of different elements in it For example the cost of 1 2 5 4 2 is 4 the cost of 13 37 42 37 13 is 3 You have to calculate the minimum cost among all arrays which are compatible with the given string s ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int c = 1, ans = 2;\n    for (int j = 1; j < n; j++){\n      if (s[j] == s[j - 1]){\n        c++;\n        ans = max(ans, c + 1);\n      } else {\n        c = 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n']",['greedy'],900
https://codeforces.com//contest/228/problem/A,A. Is your horseshoe on the other hoof ,Valera the Horse is going to the party with friends He has been following the fashion trends for a while and he knows that it is very popular to wear all horseshoes of different color Valera has got four horseshoes left from the last year but maybe some of them have the same color In this case he needs to go to the store and buy some few more horseshoes not to lose face in front of his stylish comrades Fortunately the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them However in order to save the money he would like to spend as little money as possible so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party ,"['// AntiFate\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define fab(i,a,b) for(int i=(a);i<=(b);++i)\n#define fba(i,b,a) for(int i=(b);i>=(a);--i)\n#define clr(a) memset(a,0,sizeof(a))\n#define fec(i,a) for(__typeof((a).end())i=(a).begin();i!=(a).end();++i)\n#define fpc(i,j,v) for(int i=a[v],j;j=to[i],i;i=nx[i])\n\n#define N 111111\n\n\nint main()\n{\n    int a[4];\n    scanf(""%d%d%d%d"", a,a+1,a+2,a+3);\n    sort(a,a+4);\n    cout << 4-(unique(a,a+4)-a) << endl;\n\n    \n    \n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/152/problem/A,A. Marks,Vasya or Mr Vasily Petrov is a dean of a department in a local university After the winter exams he got his hands on a group s gradebook Overall the group has students They received marks for subjects Each student got a mark from to inclusive for each subject Let s consider a student the if there is no student who got a higher mark for this subject Let s consider a student if there exists a subject he is the Your task is to find the number of students in the group ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\nstring s[110];\n\nint main(){\n\tint n, m;\n\twhile( cin>>n>>m){\n\t\trep(i, 0, n) cin>>s[i];\n\t\tint ans=0;\n\t\trep(i, 0, n){\n\t\t\tbool can=false;\n\t\t\trep(j, 0, m){\n\t\t\t\tbool big=false;\n\t\t\t\trep(k, 0, n) if( k!=i ){\n\t\t\t\t\tif( s[k][j]>s[i][j] ) big=true;\n\t\t\t\t}\n\t\t\t\tif( big==false ) can=true;\n\t\t\t}\n\t\t\tif( can ) ans++;\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n}\n\n']",['implementation'],900
https://codeforces.com//contest/1569/problem/D,D. Inconvenient Pairs,There is a city that can be represented as a square grid with corner points in 0 0 and 10 6 10 6 The city has n vertical and m horizontal streets that goes across the whole city i e the i th vertical streets goes from x i 0 to x i 10 6 and the j th horizontal street goes from 0 y j to 10 6 y j All streets are bidirectional Borders of the city are streets as well There are k persons staying the p th person at point x p y p so either x p equal to some x i or y p equal to some y j or both Let s say that a pair of persons form an if the shortest path from one person to another going only by streets is than the Manhattan distance between them Calculate the number of inconvenient pairs of persons pairs x y and y x are the same pair Let s recall that Manhattan distance between points x 1 y 1 and x 2 y 2 is x 1 x 2 y 1 y 2 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\n\nvoid solve() {\n    int N, M, K; cin >> N >> M >> K;\n    set<int> st[2];\n    F0R(i, N) {\n        int X; cin >> X; st[0].ins(X);\n    }\n    F0R(i, M) {\n        int X; cin >> X; st[1].ins(X);\n    }\n\n    map<int, int> cnt[2];\n    map<pi, int> cnt2[2];\n    st[0].ins(-1); st[1].ins(-1);\n    F0R(i, K) {\n        int X, Y; cin >> X >> Y;\n        if (!st[0].count(X)) {\n            auto it = --(st[0].lb(X));\n            cnt[0][*it]++;\n            cnt2[0][{*it, Y}]++;\n        }\n        if (!st[1].count(Y)) {\n            auto it = --(st[1].lb(Y));\n            cnt[1][*it]++;\n            cnt2[1][{*it, X}]++;\n        }\n    }\n    ll ans = 0;\n    F0R(i, 2) {\n        trav(a, cnt[i]) {\n            ll cur = a.s; ans += cur * (cur - 1) / 2;\n            //dbg(i, a.f, a.s);\n        }\n        trav(a, cnt2[i]) {\n            ll cur = a.s; ans -= cur * (cur - 1) / 2;\n        }\n    }\n    cout << ans << nl;\n\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']","['binary search', 'data structures', 'implementation', 'sortings', 'two pointers']",1900
https://codeforces.com//contest/1195/problem/C,C. Basketball Exercise,Finally a basketball court has been opened in SIS so Demid has decided to hold a basketball exercise session 2 cdot n students have come to Demid s exercise session and he lined up them into two rows of the same size there are exactly n people in each row Students are numbered from 1 to n in each row in order from left to right Now Demid wants to choose a team to play basketball He will choose players from left to right and the index of each chosen player excluding the first one will be strictly greater than the index of the previously chosen player To avoid giving preference to one of the rows Demid chooses students in such a way that no consecutive chosen students belong to the same row The first student can be chosen among all 2n students there are no additional constraints and a team can consist of any number of students Demid thinks that in order to compose a perfect team he should choose students in such a way that the total height of all chosen students is maximum possible Help Demid to find the maximum possible total height of players in a team he can choose ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100005;\n\nint a[2][N];\nLL f[2][N];\n\nint main() {\n    int n;\n    scanf(""%d"", &n);\n    for (int i = 1; i <= n; i++) scanf(""%d"", a[0]+i);\n    for (int i = 1; i <= n; i++) scanf(""%d"", a[1]+i);\n    f[0][0] = f[1][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 1; j++) {\n            int k = j ^ 1;\n            f[j][i] = max(f[j][i-1], f[k][i-1] + a[j][i]);\n        }\n    }\n    printf(""%lld\\n"", max(f[0][n], f[1][n]));\n}']",['dp'],1400
https://codeforces.com//contest/1758/problem/D,D. Range = √Sum,You are given an integer n Find a sequence of n integers a 1 a 2 dots a n such that 1 leq a i leq 10 9 for all i and max a 1 a 2 dots a n min a 1 a 2 dots a n sqrt a 1 a 2 dots a n It can be proven that there exists a sequence of integers that satisfies all the conditions above ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=4e5+1,mod=998244353;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n,a[N];\nV input(){\n\t// 怎么全是构造题\n\tn = getint();\n\t// 最大减最小为根号？\n\t// ai 还得互不相同\n\t// 吐血\n\t// 居然还保证存在\n\t// \n\t// return 0;\n\tif(n%2==0){\n\t\tFOR(i,1,n/2)\n\t\t\tcout<<n+i<<\' \'<<n-i<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n\telse{\n\t\tint d = n/2;\n\t\tFOR(i,0,d-1)\n\t\t\tcout<<n-i<<\' \';\n\t\tFOR(i,0,d)\n\t\t\tcout<<n+3+i<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n\t// FOR(i,1,10)\n\t// \tFOR(j,i+1,10)\n\t\t\t// FOR(k,1,10)\n\t\t\t// \tFOR(o,k+1,10)\n\t\t\t// \t\tFOR(p,o+1,10){\n\t\t\t// \tif((p-k)*(p-k) == (k+o+p)){\n\t\t\t// \t\tcout<<k<<\' \' <<o<<\' \' <<p<<\'\\n\';\n\t\t\t// \t\t// cout<<i<<\' \'<<j<<\' \'<<k<<\' \' <<o<<\' \' <<p<<\'\\n\';\n\t\t\t// \t\t// return 0;\n\t\t\t// \t}\n\t\t\t\t\t\n\n\t\t\t// }\n\n\t// return 0;\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n']","['binary search', 'brute force', 'constructive algorithms', 'math', 'two pointers']",1800
https://codeforces.com//contest/1526/problem/B,B. I Hate 1111,You are given an integer x Can you make x by summing up some number of 11 111 1111 11111 ldots You can use any number among them any number of times For instance 33 11 11 11 144 111 11 11 11 ,"['//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>\'9\'||ch<\'0\') {\n\t\t\tch=getchar();\n\t\t\tif(ch==\'-\')fu=1;\n\t\t}\n\t\twhile(ch<=\'9\'&&ch>=\'0\') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>\'9\'||ch<\'0\') {\n\t\t\tch=getchar();\n\t\t\tif(ch==\'-\')fu=1;\n\t\t}\n\t\twhile(ch<=\'9\'&&ch>=\'0\') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0){\n\t\t\tputchar(\'0\');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar(\'-\') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + \'0\' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\ninline bool check(int x){\n\tF(i,0,11){\n\t\tif(x>=111*i&&(x-111*i)%11==0)return 1;\n\t}return 0;\n}\nint main() {\nF(iakioi,1,read()){\n\tri x=read();\n\tif(check(x))puts(""yes"");\n\telse puts(""no"");\n}\n\treturn 0;\n}\n']","['dp', 'math', 'number theory']",1400
https://codeforces.com//contest/1407/problem/C,C. Chocolate Bunny,We hid from you a permutation p of length n consisting of the elements from 1 to n You want to guess it To do that you can give us 2 different indices i and j and we will reply with p i bmod p j remainder of division p i by p j We have enough patience to answer at most 2 cdot n queries so you should fit in this constraint Can you do it As a reminder a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1E4 + 5;\n\nint n, a[N];\n\nint ask(int x, int y) {\n    cout << ""? "" << x << "" "" << y << endl;\n    int ret; cin >> ret; return ret;\n}\n\nint main() {\n    cin >> n;\n    int cur = 1;\n    for (int i = 2; i <= n; i++) {\n        int le = ask(cur, i), ri = ask(i, cur);\n        if (le < ri) {\n            a[i] = ri;\n        } else {\n            a[cur] = le;\n            cur = i;\n        }\n    }\n    a[cur] = n;\n    cout << ""!"";\n    for (int i = 1; i <= n; i++) {\n        cout << "" "" << a[i];\n    }\n    cout << endl;\n}\n']","['constructive algorithms', 'interactive', 'math', 'two pointers']",1600
https://codeforces.com//contest/1132/problem/G,G. Greedy Subsequences,For some array c let s denote a as a sequence of indices p 1 p 2 p l such that 1 le p 1 p 2 dots p l le c and for each i in 1 l 1 p i 1 is the minimum number such that p i 1 p i and c p i 1 c p i You are given an array a 1 a 2 dots a n For each its subsegment of length k calculate the length of its longest greedy subsequence ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 1000 * 1000 + 7;\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nint t[4 * MX];\nint md[4 * MX];\n\nvoid push(int v) {\n    md[v + v] += md[v];\n    md[v + v + 1] += md[v];\n    md[v] = 0;\n}\n\nint gv(int v) {\n    return t[v] + md[v];\n}\n\nvoid pop(int v) {\n    t[v] = max(gv(v + v), gv(v + v + 1));\n}\n\nvoid ad(int v, int tl, int tr, int l, int r, int x) {\n    if (r < tl || l > tr) {\n        return;\n    }\n    if (tl >= l && tr <= r) {\n        md[v] += x;\n    } else {\n        push(v);\n        int tm = (tl + tr) >> 1;\n        ad(v + v, tl, tm, l, r, x);\n        ad(v + v + 1, tm + 1, tr, l, r, x);\n        pop(v);\n    }\n}\n\nvector<int> g[MX];\nint tin[MX], tout[MX];\nint timer = 1;\nint a[MX];\n\nvoid dfs(int v) {\n    tin[v] = timer;\n    timer++;\n    for (int to : g[v]) {\n        dfs(to);\n    }\n    tout[v] = timer - 1;\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<pair<int, int> > st;\n    st.emplace_back(INF, n + 1);\n    for (int i = n; i >= 1; i--) {\n        while (!st.empty() && st.back().first <= a[i]) {\n            st.pop_back();\n        }\n        if (st.back().second != n + 1) {\n            g[st.back().second].push_back(i);\n        }\n        st.emplace_back(a[i], i);\n    }\n    for (int i = n; i >= 1; i--) {\n        if (tin[i] == 0) {\n            dfs(i);\n        }\n    }\n    int l = 1, r = 1;\n    auto mvr = [&]() {\n        ad(1, 1, n, tin[r], tout[r], 1);\n        r++;\n    };\n    auto mvl = [&]() {\n        ad(1, 1, n, tin[l], tin[l], -INF);\n        l++;\n    };\n    for (int i = 1; i + k - 1 <= n; i++) {\n        int gl = i, gr = i + k;\n        while (r < gr) {\n            mvr();\n        }\n        while (l < gl) {\n            mvl();\n        }\n        cout << gv(1) << ""\\n"";\n    }\n    return 0;\n}\n\n']","['data structures', 'dp', 'trees']",2400
https://codeforces.com//contest/1477/problem/C,C. Nezzar and Nice Beatmap,Nezzar loves the game osu osu is played on beatmaps which can be seen as an array consisting of points on a plane A beatmap is called nice if for any three consecutive points A B C listed in order the angle between these three points centered at B is 90 degrees Now Nezzar has a beatmap of n points A 1 A 2 ldots A n Nezzar would like to reorder these n points so that the resulting beatmap is nice Formally you are required to find a permutation p 1 p 2 ldots p n of integers from 1 to n such that beatmap A p 1 A p 2 ldots A p n is nice If it is impossible you should determine it ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nint dist(pi a,pi b){\n\treturn sq(a.a-b.a)+sq(a.b-b.b);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> xy(n);\n\trep(i,n)xy[i]=readpi();\n\tvi used(n);\n\tused[0]=1;\n\tvi ans{0};\n\trep(i,n-1){\n\t\tint cur=ans[i];\n\t\tint f=-1;\n\t\trep(nx,n)if(!used[nx]){\n\t\t\tif(f==-1||dist(xy[cur],xy[f])<dist(xy[cur],xy[nx]))\n\t\t\t\tf=nx;\n\t\t}\n\t\tused[f]=1;\n\t\tans.pb(f);\n\t}\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['constructive algorithms', 'geometry', 'greedy', 'math', 'sortings']",2200
https://codeforces.com//contest/543/problem/C,C. Remembering Strings,You have multiset of strings of the same length consisting of lowercase English letters We will say that those strings are easy to remember if for each string there is some position and some letter of the English alphabet such that this string is the only string in the multiset that has letter in position For example a multiset of strings abc aba adc ada are not easy to remember And multiset abc ada ssa is easy to remember because the first string is the only string that has character in position the second string is the only string that has character in position the third string is the only string that has character in position You want to change your multiset a little so that it is easy to remember For coins you can change character in the th position of the th string into any other lowercase letter of the English alphabet Find what is the minimum sum you should pay in order to make the multiset of strings easy to remember ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(""rdtsc"" : ""=A""(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME ""text""\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nconst int maxn = 20;\nchar s[maxn + 5][maxn + 5];\nint a[maxn + 5][maxn + 5];\nint n, m;\n\nbool read() {\n  if (scanf(""%d%d"", &n, &m) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(""%s"", s[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      scanf(""%d"", &a[i][j]);\n    }\n  }\n  return 1;\n}\n\nconst int maxc = 26;\n\npair<int, int> masks[maxn * maxn + maxn + 5];\n\nint d[1 << maxn];\n\nvoid solve() {\n  int cnt = 0;\n  for (int c = 0; c < m; ++c) {\n    for (int ch = 0; ch < maxc; ++ch) {\n      int mx = -1;\n      int sum = 0;\n      int mask = 0;\n      for (int r = 0; r < n; ++r) {\n        if (s[r][c] != ch + \'a\') {\n          continue;\n        }\n        mask ^= (1 << r);\n        sum += a[r][c];\n        mx = max(mx, a[r][c]);\n      }\n      if (mask) {\n        masks[cnt++] = mp(sum - mx, mask);\n        //eprintf(""c = %d, ch = %c, (%d, %d)\\n"", c, ch + \'a\', masks[cnt - 1].first, masks[cnt - 1].second);\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int mn = INF;\n    for (int j = 0; j < m; ++j) {\n      mn = min(mn, a[i][j]);\n    }\n    masks[cnt++] = mp(mn, 1 << i);\n  }\n  sort(masks, masks + cnt);\n\n  int mask0 = 0;\n  int l = 0;\n  for (; l < cnt && masks[l].first == 0; ++l) {\n    mask0 |= masks[l].second;\n  }\n\n  for (int i = 0; i < (1 << n); ++i) {\n    d[i] = INF;\n  }\n  d[mask0] = 0;\n  for (; l < cnt; ++l) {\n    int mask = masks[l].second, price = masks[l].first;\n    for (int m = mask0; m < (1 << n); ++m) {\n      int nm = (m | mask);\n      int nprice = d[m] + price;\n      if (nm == m || d[nm] <= nprice) {\n        continue;\n      }\n      d[nm] = nprice;\n    }\n  }\n  printf(""%d\\n"", d[(1 << n) - 1]);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME"".out"", ""w"", stdout);\n  assert(freopen(TASKNAME"".in"", ""r"", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""%.18lf\\n"", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']","['bitmasks', 'dp']",2500
https://codeforces.com//contest/1381/problem/A1,A1. Prefix Flip  Easy Version ,There are two binary strings a and b of length n a binary string is a string consisting of symbols 0 and 1 In an operation you select a prefix of a and simultaneously invert the bits in the prefix 0 changes to 1 and 1 changes to 0 and reverse the order of the bits in the prefix For example if a 001011 and you select the prefix of length 3 it becomes 011011 Then if you select the entire string it becomes 001001 Your task is to transform the string a into b in at most 3n operations It can be proved that it is always possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n;\nstr a,b;\n\nvi nor(str& x) {\n\tvi res;\n\tint ind = 0;\n\twhile (1) {\n\t\twhile (ind < n-1 && x[ind] == x[ind+1]) ind ++;\n\t\tif (ind == n-1) return res;\n\t\tres.pb(ind+1);\n\t\tx[ind] = \'0\'+\'1\'-x[ind];\n\t}\n}\n\nvoid solve() {\n\tre(n); re(a,b);\n\tvi x = nor(a);\n\tvi y = nor(b);\n\tif (a[n-1] != b[n-1]) {\n\t\tx.pb(n);\n\t}\n\treverse(all(y)); trav(t,y) x.pb(t);\n\tpr(sz(x),\' \'); ps(x);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","['constructive algorithms', 'data structures', 'strings']",1300
https://codeforces.com//contest/1512/problem/G,G. Short Task,Let us denote by d n the sum of all divisors of the number n i e d n sum limits k n k For example d 1 1 d 4 1 2 4 7 d 6 1 2 3 6 12 For a given number c find the minimum n such that d n c ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=10000010;\nconst int mod=1000000007;\nusing namespace std;\n\nll ans[def],sum[def];\n\nint main()\n{\tint _=1,__=1,n;\n\tfor(int i=1;i<def;i++)\n\t\tfor(int j=1;i*j<def;j++)\n\t\t\tsum[i*j]+=i;\n\tfor(int i=1;i<def;i++)\n\t\tif(sum[i]<def&&!ans[sum[i]])ans[sum[i]]=i;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tprintf(""%lld\\n"",ans[n]?ans[n]:-1);\n\t}\n\treturn 0;\n}']","['brute force', 'dp', 'math', 'number theory']",1700
https://codeforces.com//contest/741/problem/B,B. Arpa s weak amphitheater and Mehrdad s valuable Hoses,Mehrdad wants to invite some Hoses to the palace for a dancing party Each Hos has some weight and some beauty Also each Hos may have some friends Hoses are divided in some friendship groups Two Hoses and are in the same friendship group if and only if there is a sequence of Hoses such that and are friends for each and and Arpa allowed to use the amphitheater of palace to Mehrdad for this party Arpa s amphitheater can hold at most weight on it Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than and sum of their beauties is as large as possible Along with that from each friendship group he can either invite all Hoses or no more than one Otherwise some Hoses will be hurt Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn t exceed ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,m,v,w[N],b[N],f[N],u,vv;\nint dp[N],pd[N];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&v);\n\trep(i,1,n+1) scanf(""%d"",w+i);\n\trep(i,1,n+1) scanf(""%d"",b+i);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&vv);\n\t\tf[find(u)]=find(vv);\n\t}\n\trep(i,1,n+1) if (find(i)==i) {\n\t\tVI itm; int sw=0,sb=0;\n\t\trep(j,1,n+1) if (find(j)==i) itm.pb(j),sw+=w[j],sb+=b[j];\n\t\trep(j,0,v+1) pd[j]=dp[j];\n\t\tfor (auto p:itm) {\n//\t\t\tprintf(""%d %d\\n"",w[p],b[p]);\n\t\t\trep(j,w[p],v+1) dp[j]=max(dp[j],pd[j-w[p]]+b[p]);\n\t\t}\n\t\trep(j,sw,v+1) dp[j]=max(dp[j],pd[j-sw]+sb);\n//\t\tprintf(""%d %d\\n"",sw,sb);\n//\t\tputs("""");\n//\t\tprintf(""%d\\n"",i);\n\t}\n\tprintf(""%d\\n"",dp[v]);\n}\n']","['dfs and similar', 'dp', 'dsu']",1600
https://codeforces.com//contest/1087/problem/A,A. Right-Left Cipher,Polycarp loves ciphers He has invented his own cipher called Right Left Right Left cipher is used for strings To encrypt the string s s 1 s 2 dots s n Polycarp uses the following algorithm he writes down s 1 he appends the current word with s 2 i e writes down s 2 to the right of the current result he prepends the current word with s 3 i e writes down s 3 to the left of the current result he appends the current word with s 4 i e writes down s 4 to the right of the current result he prepends the current word with s 5 i e writes down s 5 to the left of the current result and so on for each position until the end of s For example if s the process is to to to to to So the encrypted s is Given string t the result of encryption of some string s Your task is to decrypt it i e find the string s ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define ff first\n#define ss second\n#define all(X) begin(X), end(X)\nvector<vector<int>>dp,s;\nvector<int>x,sum;\nsigned main(){\n\tstring s,t = """";\n\tcin >> s;\n\tint n = s.size(),l = 0, r = n-1;\n\tfor(int i = 0; i < n; i++){\n\t\tif(n%2 == i%2)t += s[r--];\n\t\telse t += s[l++];\n\t}\n\treverse(all(t));\n\tcout << t << endl;\n} \n']","['implementation', 'strings']",800
https://codeforces.com//contest/1167/problem/B,B. Lost Numbers,You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 The jury guessed some array a consisting of 6 integers There are 6 special numbers 4 8 15 16 23 42 and each of these numbers occurs in a exactly once so a is some permutation of these numbers You don t know anything about their order but you are allowed to ask In each query you may choose two indices i and j 1 le i j le 6 i and j are not necessarily distinct and you will get the value of a i cdot a j in return Can you guess the array a ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint pyt(int a, int b)\n{\n\tprintf(""? %d %d\\n"", a, b);\n\tff();\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvi wek{4, 8, 15, 16, 23, 42};\n\npii daj(int v)\n{\n\tfor (int i=0; i<6; i++)\n\t\tfor (int j=0; j<i; j++)\n\t\t\tif (wek[i]*wek[j]==v)\n\t\t\t\treturn {wek[i], wek[j]};\n\tassert(0);\n}\n\nint wyn;\n\nint main()\n{\n\tpii a=daj(pyt(1, 2));\n\tpii b=daj(pyt(3, 4));\n\tpii c=daj(pyt(1, 3));\n\tif (c.second==a.first || c.second==a.second)\n\t\tswap(c.first, c.second);\n\tif (a.second==c.first)\n\t\tswap(a.second, a.first);\n\tif (b.second==c.second)\n\t\tswap(b.second, b.first);\n\tint x=pyt(1, 5)/a.first;\n\tint y=1;\n\tfor (int i : wek)\n\t\ty*=i;\n\ty/=a.first;\n\ty/=a.second;\n\ty/=b.first;\n\ty/=b.second;\n\ty/=x;\n\tprintf(""! %d %d %d %d %d %d\\n"", a.first, a.second, b.first, b.second, x, y);\n\tff();\n\treturn 0;\n}\n']","['brute force', 'divide and conquer', 'interactive', 'math']",1400
https://codeforces.com//contest/218/problem/A,A. Mountain Scenery,Little Bolek has found a picture with mountain peaks painted on it The painted peaks are represented by a non closed polyline consisting of segments The segments go through points with coordinates with the th segment connecting the point and the point For any even the following condition holds and We shall call a vertex of a polyline with an even coordinate a Bolek fancied a little mischief He chose exactly mountain peaks rubbed out the segments that went through those peaks and increased each peak s height by one that is he increased the coordinate of the corresponding points Then he painted the missing segments to get a new picture of mountain peaks Let us denote the points through which the new polyline passes on Bolek s new picture as Given Bolek s final picture restore the initial one ,"['/*\n * =====================================================================================\n *\n *         Author:  KissBuaa.DS(AC)\n *        Company:  BUAA-ACMICPC-Group\n *\n * =====================================================================================\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n//#include <stdbool.h>\n#include <math.h>\n#define LL long long\n#define CLR(x) memset(x,0,sizeof(x))\n#define typec double\n#define sqr(x) ((x)*(x))\n#define abs(x) ((x)<0?(-(x)):(x))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define PI acos(-1.0)\n#define lowbit(x) ((x)&(-(x)))\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\n#define inf 100000000\n//For C++\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <list>\n#include <iostream>\nusing namespace std;\nconst double eps=1e-10;\nint dblcmp(typec d) {\n    if (fabs(d)<eps)\n       return 0;\n    return (d>0)?1:-1;\n}\nint n,m,T;\nconst int N=1000;\nint a[N],p;\nint main(){\n    cin>>n>>m;\n    for (int i=0;i<2*n+1;++i)\n        cin>>a[i];\n    p=0;\n    for(int i=0;i<2*n+1;++i)\n        if (a[i]>a[p]) p=i;\n    p=a[p];\n    while(m){\n        for (int i=0;i<2*n+1 && m;++i){\n            if(!(i&1)) continue;\n            if (a[i] && (i==0 || a[i-1]<a[i]-1) && (i==2*n || a[i]-1>a[i+1])){\n                m--;\n                a[i]--;\n            }\n        }\n    }\n    for (int i=0;i<2*n+1;++i){\n        if (i) printf("" "");\n        printf(""%d"",a[i]);\n    }\n    printf(""\\n"");\n}\n']","['brute force', 'constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/1862/problem/E,E. Kolya and Movie Theatre,Recently Kolya found out that a new movie theatre is going to be opened in his city soon which will show a new movie every day for n days So on the day with the number 1 le i le n the movie theatre will show the premiere of the i th movie Also Kolya found out the schedule of the movies and assigned the entertainment value to each movie denoted by a i However the longer Kolya stays without visiting a movie theatre the larger the decrease in entertainment value of the next movie That decrease is equivalent to d cdot cnt where d is a predetermined value and cnt is the number of days since the last visit to the movie theatre It is also known that Kolya managed to visit another movie theatre a day before the new one opened the day with the number 0 For example if d 2 and a 3 2 5 4 6 then by visiting movies with indices 1 and 3 cnt value for the day 1 will be equal to 1 0 1 and cnt value for the day 3 will be 3 1 2 so the total entertainment value of the movies will be a 1 d cdot 1 a 3 d cdot 2 3 2 cdot 1 5 2 cdot 2 2 Unfortunately Kolya only has time to visit Help him create a plan to visit the cinema in such a way that the total entertainment value of all the movies he visits is maximized ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY long long\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e18)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,m,d,a[MAXN];\npriority_queue<TY> q;\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tTY ans=0,sum=0;\n\t\twhile(!q.empty())q.pop();\n\t\tn=qr();m=qr();d=qr();\n\t\tFor(i,1,n){\n\t\t\ta[i]=qr();\n\t\t\tif(a[i]>0){\n\t\t\t\tif(q.size()<m||-q.top()<a[i]){\n\t\t\t\t\tq.push(-a[i]);sum+=a[i];\n\t\t\t\t\tif(q.size()>m)sum-=-q.top(),q.pop();\n\t\t\t\t}\n\t\t\t}ans=max(ans,sum-i*d);\n\t\t}qw(ans,\'\\n\');\n\t}\n    return 0;\n}']","['constructive algorithms', 'data structures', 'greedy']",1600
https://codeforces.com//contest/1633/problem/C,C. Kill the Monster,Monocarp is playing a computer game In this game his character fights different monsters A fight between a character and a monster goes as follows Suppose the character initially has health h C and attack d C the monster initially has health h M and attack d M The fight consists of several steps the character attacks the monster decreasing the monster s health by d C the monster attacks the character decreasing the character s health by d M the character attacks the monster decreasing the monster s health by d C the monster attacks the character decreasing the character s health by d M and so on until the end of the fight The fight ends when someone s health becomes non positive i e 0 or less If the monster s health becomes non positive the character wins otherwise the monster wins Monocarp s character currently has health equal to h C and attack equal to d C He wants to slay a monster with health equal to h M and attack equal to d M Before the fight Monocarp can spend up to k coins to upgrade his character s weapon and or armor each upgrade costs exactly one coin each weapon upgrade increases the character s attack by w and each armor upgrade increases the character s health by a Can Monocarp s character slay the monster if Monocarp spends coins on upgrades optimally ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    i64 hc, dc, hm, dm;\n    std::cin >> hc >> dc >> hm >> dm;\n    \n    i64 k, w, a;\n    std::cin >> k >> w >> a;\n    \n    for (int i = 0; i <= k; i++) {\n        i64 h = hc + a * i;\n        i64 d = dc + w * (k - i);\n        \n        i64 cm = (hm + d - 1) / d;\n        i64 mc = (h + dm - 1) / dm;\n        \n        if (cm <= mc) {\n            std::cout << ""YES\\n"";\n            return;\n        }\n    }\n    \n    std::cout << ""NO\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['brute force', 'math']",1100
https://codeforces.com//contest/129/problem/A,A. Cookies,Olga came to visit the twins Anna and Maria and saw that they have many cookies The cookies are distributed into bags As there are many cookies Olga decided that it s no big deal if she steals a bag However she doesn t want the sisters to quarrel because of nothing when they divide the cookies That s why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even that is so that Anna and Maria could evenly divide it into two even 0 remaining cookies will do just as any other even number How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <sstream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <iterator>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair< int, int > PRII;\ntypedef pair< double, double > PRDD;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\n\n#define x first\n#define y second\n#define p_b push_back\n#define m_p make_pair\n#define oo 1000000000\n\n#define sqr(x) ((x)*(x))\n#define Size(a) ((int)a.size())\n#define forn(i,n) for( i = 0 ; i < n ; ++i )\n\nconst double pi = acos(-1);\n#define maxn 100 + 10\n\nint n,a[maxn],sum = 0,ans = 0;\n\nint main()\n{\n    int i;\n    \n    scanf(""%d"",&n);\n    for( i = 1 ; i <= n ; ++i )\n        {\n            scanf(""%d"",&a[i]);\n            sum += a[i];\n        }\n    for( i = 1 ; i <= n ; ++i )\n        if( (sum-a[i]) % 2 == 0 )\n            ++ans;\n    printf(""%d\\n"",ans);\n    \n    return 0;\n}\n']",['implementation'],900
https://codeforces.com//contest/1245/problem/C,C. Constanze s Machine,Constanze is the smartest girl in her village but she has bad eyesight One day she was able to invent an incredible machine When you pronounce letters the machine will inscribe them onto a piece of paper For example if you pronounce c o d and e in that order then the machine will inscribe onto the paper Thanks to this machine she can finally write messages without using her glasses However her dumb friend Akko decided to play a prank on her Akko tinkered with the machine so that if you pronounce w it will inscribe instead of and if you pronounce m it will inscribe instead of Since Constanze had bad eyesight she was not able to realize what Akko did The rest of the letters behave the same as before if you pronounce any letter besides w and m the machine will just inscribe it onto a piece of paper The next day I received a letter in my mailbox I can t understand it so I think it s either just some gibberish from Akko or Constanze made it using her machine But since I know what Akko did I can just list down all possible strings that Constanze s machine would have turned into the message I got and see if anything makes sense But I need to know how much paper I will need and that s why I m asking you for help Tell me the number of strings that Constanze s machine would ve turned into the message I got But since this number can be quite large tell me instead its remainder when divided by 10 9 7 If there are no strings that Constanze s machine would ve turned into the message I got then print 0 ,"['#include<bits/stdc++.h>\nusing namespace std;\nchar s[101010];\nint dp[101010];\nconst int MOD = 1e9+7;\nint main()\n{\n    dp[0] = 1;\n    scanf(""%s"", s+1);\n    int N = strlen(s+1);\n    for(int i=1; i<=N; ++i)\n    {\n        if(s[i] == \'m\' || s[i] == \'w\')\n        {\n            puts(""0"");\n            return 0;\n        }\n        dp[i] = dp[i-1];\n        if(i!=1&&(s[i] == \'n\'&&s[i-1]==\'n\' || s[i]==\'u\'&&s[i-1]==\'u\'))\n            dp[i] = (dp[i-2]+dp[i])%MOD;\n    }\n    printf(""%d\\n"", dp[N]);\n}']",['dp'],1400
https://codeforces.com//contest/1494/problem/D,D. Dogeforces,The Dogeforces company has k employees Each employee except for lower level employees has at least 2 subordinates Lower level employees have no subordinates Each employee except for the head of the company has exactly one direct supervisor The head of the company is a direct or indirect supervisor of all employees It is known that in Dogeforces each supervisor receives a salary strictly more than all his subordinates The full structure of the company is a secret but you know the number of lower level employees and for each pair of lower level employees the salary of their common supervisor is known if there are several such supervisors then the supervisor with the minimum salary You have to restore the structure of the company ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nint n;\nvector<vector<int>> a;\n\nvector<pair<int, int>> edges;\n\n\nvector<int> vals;\nint idx;\n\n\nint solve(vector<int> cur)\n{\n\n    //cout<<""Solving for: ""; for (auto it: cur) cout<<it<<\' \'; cout<<endl;\n\n    if (cur.size()==1)\n    {\n        vals[cur[0]] = a[cur[0]][cur[0]];\n        return cur[0];\n    }\n\n    int maxx = 0;\n    int k = cur.size();\n    for (int i = 0; i<k; i++)\n        for (int j = 0; j<k; j++) maxx = max(maxx, a[cur[i]][cur[j]]);\n\n    vals.push_back(maxx);\n\n    int cur_idx = idx;\n    idx++;\n\n\n    vector<vector<int>> vecs;\n    for (auto it: cur)\n    {\n        bool found = false;\n        for (auto &vec: vecs)\n        {\n            if (a[vec.back()][it] < maxx)\n            {\n                found = true; vec.push_back(it); break;\n            }\n        }\n        if (!found)\n        {\n            vecs.push_back({it});\n        }\n    }\n\n    for (auto vec: vecs)\n    {\n        int son_idx = solve(vec);\n        edges.push_back(mp(son_idx, cur_idx));\n    }\n\n\n    return cur_idx;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    cin>>n;\n\n    idx = n;\n    vals.resize(n);\n\n    a = vector<vector<int>>(n, vector<int>(n));\n    for (int i = 0; i<n; i++)\n    {\n        for (int j = 0; j<n; j++) cin>>a[i][j];\n    }\n\n    vector<int> guys(n); for (int i = 0; i<n; i++) guys[i] = i;\n\n    int root = solve(guys);\n\n    cout<<vals.size()<<endl;\n    for (auto it: vals) cout<<it<<\' \';\n    cout<<endl;\n    cout<<root+1<<endl;\n    for (auto it: edges) cout<<it.first+1<<\' \'<<it.second+1<<endl;\n\n\n\n\n\n\n}']","['constructive algorithms', 'data structures', 'dfs and similar', 'divide and conquer', 'dsu', 'greedy', 'sortings', 'trees']",2300
https://codeforces.com//contest/888/problem/A,A. Local Extrema,You are given an array Some element of this array is a iff it is strictly less than both of its neighbours that is and Also the element can be called iff it is strictly greater than its neighbours that is and Since and have only one neighbour each they are neither local minima nor local maxima An element is called a iff it is either local maximum or local minimum Your task is to calculate the number of local extrema in the given array ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 1021\nint n , a[ N ];\nvoid init(){\n  n = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    a[ i ] = getint();\n}\nvoid solve(){\n  int ans = 0;\n  for( int i = 1 ; i + 1 < n ; i ++ )\n    ans += ( a[ i - 1 ] < a[ i ] and a[ i ] > a[ i + 1 ] ) or\n           ( a[ i - 1 ] > a[ i ] and a[ i ] < a[ i + 1 ] );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","['brute force', 'implementation']",800
https://codeforces.com//contest/1707/problem/A,A. Doremy s IQ,Doremy is asked to test n contests Contest i can only be tested on day i The difficulty of contest i is a i Initially Doremy s IQ is q On day i Doremy will choose whether to test contest i or not She can only test a contest if her current IQ is strictly greater than 0 If Doremy chooses to test contest i on day i the following happens if a i q Doremy will feel she is not wise enough so q decreases by 1 otherwise nothing changes If she chooses not to test a contest nothing changes Doremy wants to test as many contests as possible Please give Doremy a solution ,"['#include <cstdio>\n\nint n,t,a[100001],q;\nbool vis[100001];\nint main(){\n\tscanf(""%d"",&t);\n\tfor(int fd=1;fd<=t;++fd){\n\t\tscanf(""%d%d"",&n,&q);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tscanf(""%d"",a+i);\n\t\t\tvis[i]=0;\n\t\t}\n\t\tfor(int i=n,t=0;i;--i){\n\t\t\tif(t<q&&a[i]>=t+1)++t,vis[i]=1;\n\t\t\telse if(a[i]<=t)vis[i]=1;\n\t\t}\n\t\tfor(int i=1;i<=n;++i)printf(""%d"",vis[i]);putchar(\'\\n\');\n\t}\n}']","['binary search', 'constructive algorithms', 'greedy', 'implementation']",1600
https://codeforces.com//contest/831/problem/B,B. Keyboard Layouts,There are two popular keyboard layouts in Berland they differ only in letters positions All the other keys are the same In Berland they use alphabet with letters which coincides with English alphabet You are given two strings consisting of distinct letters each all keys of the first and the second layouts in the same order You are also given some text consisting of small and capital English letters and digits It is known that it was typed in the first layout but the writer intended to type it in the second layout Print the text if the same keys were pressed in the second layout Since all keys but letters are the same in both layouts the capitalization of the letters should remain the same as well as all other characters ,"['#include<cstdio>\nchar s1[1007],s2[1007],s3[100007],tr[256];\nint main(){\n\tfor(int i=0;i<256;++i)tr[i]=i;\n\tscanf(""%s%s%s"",s1,s2,s3);\n\tfor(int i=0;i<26;++i)tr[s1[i]]=s2[i],tr[s1[i]-32]=s2[i]-32;\n\tfor(int i=0;s3[i];++i)s3[i]=tr[s3[i]];\n\tputs(s3);\n\treturn 0;\n}\n']","['implementation', 'strings']",800
https://codeforces.com//contest/1396/problem/C,C. Monster Invaders,Ziota found a video game called Monster Invaders Similar to every other shooting RPG game Monster Invaders involves killing monsters and bosses with guns For the sake of simplicity we only consider two different types of monsters and three different types of guns Namely the two types of monsters are a normal monster with 1 hp a boss with 2 hp And the three types of guns are Pistol deals 1 hp in damage to one monster r 1 reloading time Laser gun deals 1 hp in damage to all the monsters in the current level including the boss r 2 reloading time AWP instantly kills any monster r 3 reloading time The levels of the game can be considered as an array a 1 a 2 ldots a n in which Due to the nature of the game If Ziota damages the boss but does not kill it immediately adjacent levels of level i 1 i n are levels i 1 and i 1 the only adjacent level of level 1 is level 2 the only adjacent level of level n is level n 1 Ziota can also choose to move to an adjacent level at any time In order not to disrupt the space time continuum within the game Ziota starts the game at level 1 The objective of the game is rather simple to kill all the bosses in all the levels He is curious about the minimum time to finish the game assuming it takes no time to shoot the monsters with a loaded gun and Ziota has infinite ammo on all the three guns Please help him find this value ,"['/**\n *    author:  tourist\n *    created: 30.08.2020 18:01:47       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst long long inf = (long long) 4e18;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long r1, r2, r3, d;\n  cin >> n >> r1 >> r2 >> r3 >> d;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  long long dp0 = 0;\n  long long dp1 = inf;\n  for (int i = 0; i < n; i++) {\n    long long cost1 = a[i] * r1 + r3;\n    long long cost2 = min(cost1, min(a[i] * r1 + r1 + r1, r2 + r1));\n    long long new_dp0 = inf;\n    long long new_dp1 = inf;\n    new_dp0 = min(new_dp0, dp0 + cost1);\n    new_dp1 = min(new_dp1, dp0 + cost2 + d);\n    new_dp0 = min(new_dp0, dp1 + cost2 + d);\n    if (i == n - 1) {\n      new_dp0 = min(new_dp0, dp1 + cost1);\n    }\n    dp0 = new_dp0;\n    dp1 = new_dp1;\n    debug(i, cost1, cost2, dp0, dp1);\n  }\n  cout << min(dp0, dp1 + d) + d * (n - 1) << \'\\n\';\n  return 0;\n}\n']","['dp', 'greedy', 'implementation']",2300
https://codeforces.com//contest/228/problem/D,D. Zigzag,The court wizard Zigzag wants to become a famous mathematician For that he needs his own theorem like the Cauchy theorem or his sum like the Minkowski sum But most of all he wants to have his sequence like the Fibonacci sequence and his function like the Euler s totient function The Zigag s sequence with the zigzag factor z is an infinite sequence that is determined as follows when when when Operation means taking the remainder from dividing number by number For example the beginning of sequence zigzag factor 3 looks as follows 1 2 3 2 1 2 3 2 1 Let s assume that we are given an array consisting of integers Let s define element number of the array as The Zigzag function is function where satisfy the inequalities To become better acquainted with the Zigzag sequence and the Zigzag function the wizard offers you to implement the following operations on the given array The assignment operation The operation parameters are The operation denotes assigning value to the th array element After the operation is applied the value of the array element equals The Zigzag operation The operation parameters are The operation denotes calculating the Zigzag function Explore the magical powers of zigzags implement the described operations ,"['// AntiFate\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define fab(i,a,b) for(int i=(a);i<=(b);++i)\n#define fba(i,b,a) for(int i=(b);i>=(a);--i)\n#define clr(a) memset(a,0,sizeof(a))\n#define fec(i,a) for(__typeof((a).end())i=(a).begin();i!=(a).end();++i)\n#define fpc(i,j,v) for(int i=a[v],j;j=to[i],i;i=nx[i])\n\n#define N 111111\n\nint n, a[N];\n\nll s[7][13][N];\n\n\nvoid add(int x, ll y)\n{\n    fab(i,2,6)\n        rep(j,2*(i-1))\n        {\n            int zd = (x+2*(i-1)-j) % (2*(i-1));\n\n            if (zd == 0)\n                zd = 2; else\n            if (zd > i)\n                zd = 2*i-zd;\n            \n            for (int t=x;t<N;t+=t-(t&(t-1)))\n                s[i][j][t] += y*zd;\n        }\n}\n\nll ask(int x, int z, int d)\n{\n    ll ret = 0;\n    for(;x;x&=x-1)\n        ret += s[z][d][x];\n    return ret;\n}\n\nint main()\n{\n    scanf(""%d"", &n);\n    fab(i,1,n)\n    {\n        scanf(""%d"", a+i);\n        add(i,a[i]);\n    }\n    int q;\n    scanf(""%d"", &q);\n\n    rep(qq,q)\n    {\n        int t,x,y,z;\n        scanf(""%d"", &t);\n        if (t == 1)\n        {\n            scanf(""%d%d"", &x, &y);\n            add(x,-a[x]);\n            a[x]=y;\n            add(x,a[x]);\n        }\n        else\n        {\n            scanf(""%d%d%d"", &x, &y, &z);\n            int m = 2*(z-1);\n            int j;\n            rep(jj,m)\n            {\n                int zd = (x+m-jj) % m;\n                if (zd == 0)\n                    zd = 2; else\n                if (zd > z)\n                    zd = 2*z-zd;\n                if (zd == 1)\n                {\n                    j=jj;\n                    break;\n                }\n            }\n            printf(""%I64d\\n"", ask(y, z, j) - ask(x-1, z, j));\n        }\n    }\n    \n    return 0;\n}\n']",['data structures'],2100
https://codeforces.com//contest/1396/problem/D,D. Rainbow Rectangles,Shrimpy Duc is a fat and greedy boy who is always hungry After a while of searching for food to satisfy his never ending hunger Shrimpy Duc finds M M candies lying unguarded on a L times L grid There are n M M candies on the grid the i th M M is currently located at x i 0 5 y i 0 5 and has color c i out of a total of k colors the size of M Ms are insignificant Shrimpy Duc wants to steal a of M Ms specifically he wants to select a rectangle with coordinates within the grid and steal all candies within the rectangle Shrimpy Duc doesn t need to steal every single candy however he would like to steal In other words he wants to select a rectangle whose sides are parallel to the coordinate axes and whose left bottom vertex X 1 Y 1 and right top vertex X 2 Y 2 are points with integer coordinates satisfying 0 le X 1 X 2 le L and 0 le Y 1 Y 2 le L so that for every color 1 le c le k there is at least one M M with color c that lies within that rectangle How many such rectangles are there This number may be large so you only need to find it modulo 10 9 7 ,"['/**\n *    author:  tourist\n *    created: 30.08.2020 18:09:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nstruct Point {\n  int x;\n  int y;\n  int c;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, L;\n  cin >> n >> k >> L;\n  vector<Point> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].x >> p[i].y >> p[i].c;\n    --p[i].c;\n  }\n  sort(p.begin(), p.end(), [&](const Point& a, const Point& b) {\n    return a.y < b.y;\n  });\n  long long c2 = (long long) L * (L + 1) / 2;\n  auto C2 = [&](int x, int y) -> long long {\n    if (x >= y) {\n      return 0;\n    }\n    return ((long long) (y - x) * (y - x + 1)) >> 1;\n  };\n  Mint ans = 0;\n  for (int start = 0; start <= n - k; start++) {\n    int coeff = p[start].y - (start == 0 ? -1 : p[start - 1].y);\n    if (coeff == 0) {\n      continue;\n    }\n    vector<multiset<int>> s(k);\n    for (int i = 0; i < k; i++) {\n      s[i].insert(-1);\n      s[i].insert(L);\n    }\n    for (int i = start; i < n; i++) {\n      s[p[i].c].insert(p[i].x);\n    }\n    set<pair<int, int>> segs;\n    long long value = 0;\n    auto Modify = [&](set<pair<int, int>>::iterator it, int q) {\n      if (it != segs.begin()) {\n        value -= q * C2(it->first, abs(prev(it)->second));\n      }\n      if (next(it) != segs.end()) {\n        value -= q * C2(next(it)->first, abs(it->second));\n      }\n      if (it != segs.begin() && next(it) != segs.end()) {\n        value += q * C2(next(it)->first, abs(prev(it)->second));\n      }\n      value += q * C2(it->first, abs(it->second));\n    };\n    auto Erase = [&](set<pair<int, int>>::iterator it) {\n      Modify(it, -1);\n      segs.erase(it);\n    };\n    auto Add = [&](int from, int to) {\n      if (from >= to) {\n        return;\n      }\n      pair<int, int> seg = make_pair(from, -to);\n      auto it = segs.lower_bound(seg);\n      while (it != segs.end() && abs(it->second) <= to) {\n        Erase(it);\n        it = segs.lower_bound(seg);\n      }\n      if (it != segs.begin()) {\n        it = prev(it);\n        if (abs(it->second) >= to) {\n          return;\n        }\n      }\n      auto ret = segs.insert(seg);\n      assert(ret.second);\n      it = ret.first;\n      Modify(it, 1);\n    };\n    bool have_all = true;\n    for (int i = 0; i < k; i++) {\n      if (s[i].size() == 2) {\n        have_all = false;\n        break;\n      }\n      auto it = s[i].begin();\n      while (*it < L) {\n        int me = *it;\n        ++it;\n        int nxt = *it;\n        Add(me + 1, nxt);\n      }\n    }\n    if (!have_all) {\n      break;\n    }\n    for (int finish = n - 1; finish >= start; finish--) {\n      int coeff2 = (finish == n - 1 ? L : p[finish + 1].y) - p[finish].y;\n      ans += Mint(coeff) * coeff2 * (c2 - value);\n      int col = p[finish].c;\n      auto it = s[col].find(p[finish].x);\n      assert(it != s[col].end());\n      auto pr = prev(it);\n      auto nx = next(it);\n      Add((*pr) + 1, *nx);\n      s[col].erase(it);\n      if (value == c2) {\n        break;\n      }\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","['data structures', 'sortings', 'two pointers']",3300
https://codeforces.com//contest/560/problem/A,A. Currency System in Geraldion,A magic island Geraldion where Gerald lives has its own currency system It uses banknotes of several values But the problem is the system is not perfect and sometimes it happens that Geraldionians cannot express a certain sum of money with any set of banknotes Of course they can use any number of banknotes of each value Such sum is called Gerald wondered what is the minimum sum ,['#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    int res = 1;\n    while(N) {\n        int v;\n        cin >> v;\n        if(v == 1) res = -1;\n        N--;\n    }\n    cout << res << endl;\n    return 0;\n}\n'],"['implementation', 'sortings']",1000
https://codeforces.com//contest/1539/problem/C,C. Stable Groups,There are n students numerated from 1 to n The level of the i th student is a i You need to split the students into A group of students is called if in the sorted array of their levels no two neighboring elements differ by more than x For example if x 4 then the group with levels 1 10 8 4 4 is stable because 4 1 le x 4 4 le x 8 4 le x 10 8 le x while the group with levels 2 10 10 7 is not stable 7 2 5 x Apart from the n given students teachers can invite at most k additional students with levels at teachers choice Find the minimum number of stable groups teachers can form from all students including the newly invited For example if there are two students with levels 1 and 5 x 2 and k ge 1 then you can invite a new student with level 3 and put all the students in one stable group ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\nconst int MAXN=200005;\n\nint n;\nll k,x,a[MAXN];\nvector<ll> b;\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\treadint(n),readint(k),readint(x);\n\tfor(int i=1;i<=n;++i)readint(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<n;++i)b.pb(max(a[i+1]-a[i]-1,0ll)/x);\n\tsort(b.begin(),b.end());\n\tint cnt=n;\n\tfor(auto i:b)if(k>=i)k-=i,--cnt;\n\tcout<<cnt<<endl;\n\treturn 0;\n}\n']","['greedy', 'sortings']",1200
https://codeforces.com//contest/1213/problem/C,C. Book Reading,Polycarp is reading a book consisting of n pages numbered from 1 to n Every time he finishes the page with the number divisible by m he writes down the last digit of this page number For example if n 15 and m 5 pages divisible by m are 5 10 15 Their last digits are 5 0 5 correspondingly their sum is 10 Your task is to calculate the sum of all digits Polycarp has written down You have to answer q independent queries ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint a[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int q;\n    cin >> q;\n    while(q--) {\n        ll x, m;\n        cin >> x >> m;\n        int k = x / m;\n        m %= 10;\n        int cyc = 1;\n        int val = m % 10;\n        int s = 0;\n        while(val != 0) {\n            s += val;\n            val = (val + m) % 10;\n            cyc++;\n        }\n        // cout << m << "" "" << cyc << "" "" << s << endl;\n        int ans = (k / cyc) * s;\n        k %= cyc;\n        for(int i = 1; i <= k; i++) {\n            ans += (i * m) % 10;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}']",['math'],1200
https://codeforces.com//contest/1827/problem/C,C. Palindrome Partition,A is a continuous and non empty segment of letters from a given string without any reorders An is a string that reads the same backward as forward and has an even length For example strings are even palindromes but strings are not A is an even palindrome or a string that can be partitioned into some smaller even palindromes You are given a string s consisting of n lowercase Latin letters Count the number of of s ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\narray<vi, 2> manacher(const string& s) {\n\tint n = sz(s);\n\tarray<vi,2> p = {vi(n+1), vi(n)};\n\trep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {\n\t\tint t = r-i+!z;\n\t\tif (i<r) p[z][i] = min(t, p[z][l+t]);\n\t\tint L = i-p[z][i], R = i+p[z][i]-!z;\n\t\twhile (L>=1 && R+1<n && s[L-1] == s[R+1])\n\t\t\tp[z][i]++, L--, R++;\n\t\tif (R>r) l=L, r=R;\n\t}\n\treturn p;\n}\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tstring S;\n\tcin >> S;\n\tvector<ll> dp(N+1, 1);\n\tauto z = manacher(S)[0];\n\tvector<vector<int >> ins(N+1);\n\tvector<vector<int> > del(N+1);\n\tmultiset<int> cur;\n\tfor(int i = 0; i <= N; i++){\n\t\tif(z[i]){\n\t\t\tins[i+1].push_back(-i);\n\t\t\tdel[i+z[i]].push_back(-i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int x : ins[i]){\n\t\t\tcur.insert(x);\n\t\t}\n\t\tif(!cur.empty()){\n\t\t\tint l = i + *cur.begin();\n\t\t\tdp[i] += dp[i - 2 * l];\n\t\t}\n\t\tfor(int x : del[i]){\n\t\t\tcur.erase(cur.find(x));\n\t\t}\n\t}\n\tll ans = accumulate(dp.begin(), dp.end(), ll(0)) - (N+1);\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['binary search', 'brute force', 'data structures', 'dp', 'hashing', 'strings']",2600
https://codeforces.com//contest/1928/problem/B,B. Equalize,Vasya has two hobbies adding permutations dagger to arrays and finding the most frequently occurring element Recently he found an array a and decided to find out the maximum number of elements equal to the same number in the array a that he can obtain after adding some permutation to the array a More formally Vasya must choose exactly one permutation p 1 p 2 p 3 ldots p n of length n and then change the elements of the array a according to the rule a i a i p i After that Vasya counts how many times each number occurs in the array a and takes the maximum of these values You need to determine the maximum value he can obtain dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"[""#include<bits/stdc++.h>\n\nint main() {\n        std::cin.tie(nullptr)->sync_with_stdio(false);\n\n        int t;\n        std::cin >> t;\n        while (t--) {\n                int n;\n                std::cin >> n;\n                std::vector<int> a(n);\n                for (auto& i : a) std::cin >> i;\n                std::sort(a.begin(), a.end());\n                a.resize(std::unique(a.begin(), a.end()) - a.begin());\n                int ans = 0;\n                for (int i = 0; i < a.size(); ++i) {\n                        ans = std::max(ans, (int)(std::upper_bound(a.begin(), a.end(), a[i] + n - 1) - a.begin() - i));\n                }\n                std::cout << ans << '\\n';\n        }\n}""]","['binary search', 'greedy', 'sortings', 'two pointers']",1200
https://codeforces.com//contest/1783/problem/D,D. Different Arrays,You are given an array a consisting of n integers You perform the sequence of n 2 operations on this array during the first operation you either add a 2 to a 1 and subtract a 2 from a 3 or add a 2 to a 3 and subtract a 2 from a 1 during the second operation you either add a 3 to a 2 and subtract a 3 from a 4 or add a 3 to a 4 and subtract a 3 from a 2 during the last operation you either add a n 1 to a n 2 and subtract a n 1 from a n or add a n 1 to a n and subtract a n 1 from a n 2 So during the i th operation you add the value of a i 1 to one of its neighbors and subtract it from the other neighbor For example if you have the array 1 2 3 4 5 one of the possible sequences of operations is subtract 2 from a 3 and add it to a 1 so the array becomes 3 2 1 4 5 subtract 1 from a 2 and add it to a 4 so the array becomes 3 1 1 5 5 subtract 5 from a 3 and add it to a 5 so the array becomes 3 1 4 5 10 So the resulting array is 3 1 4 5 10 An array is if it can be obtained by performing the aforementioned sequence of operations on a You have to calculate the number of reachable arrays and print it modulo 998244353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int sum = std::accumulate(a.begin(), a.end(), 0);\n    std::vector<Z> dp(2 * sum + 1);\n    dp[a[1] + sum] = 1;\n    \n    for (int i = 2; i < n; i++) {\n        std::vector<Z> g(2 * sum + 1);\n        for (int j = 0; j <= 2 * sum; j++) {\n            if (!dp[j].val()) continue;\n            g[sum + a[i] - (j - sum)] += dp[j];\n            if (j != sum) g[sum + a[i] + (j - sum)] += dp[j];\n        }\n        std::swap(dp, g);\n    }\n    \n    auto ans = std::accumulate(dp.begin(), dp.end(), Z(0));\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['brute force', 'dp', 'implementation']",2000
https://codeforces.com//contest/724/problem/D,D. Dense Subsequence,You are given a string consisting of lowercase English letters and the integer One should choose some symbols from the given string so that any contiguous subsegment of length has at least one selected symbol Note that here we choose positions of symbols not the symbols themselves Then one uses the chosen symbols to form All symbols from the chosen position should be used but we are allowed to rearrange them in any order Formally we choose a subsequence of indices The selected sequence must meet the following condition for every such that there must be at least one selected index that belongs to the segment i e there should exist a from to such that Then we take any permutation of the selected indices and form a new string Find the lexicographically smallest string that can be obtained using this procedure ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nchar s[N];\nint m,v[30],n;\n\nint gao(int c) {\n\tint pre=-1,cand=-1,ret=0;\n\trep(i,0,n) {\n\t\tif (s[i]<\'a\'+c) pre=i,cand=i;\n\t\tif (s[i]==\'a\'+c) cand=i;\n\t\tif (i-pre==m) {\n\t\t\tif (cand>pre) {\n\t\t\t\tret++; pre=cand;\n\t\t\t} else return -1;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(""%d"",&m);\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\trep(i,0,n) v[s[i]-\'a\']++;\n\trep(i,0,26) {\n\t\tint c=gao(i);\n\t\tif (c!=-1) {\n\t\t\trep(j,0,i) rep(k,0,v[j]) putchar(\'a\'+j);\n\t\t\trep(k,0,c) putchar(\'a\'+i);\n\t\t\tputs("""");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(0);\n}\n']","['data structures', 'greedy', 'strings']",1900
https://codeforces.com//contest/911/problem/D,D. Inversion Counting,A permutation of size is an array of size such that each integer from to occurs exactly once in this array An inversion in a permutation is a pair of indices such that and For example a permutation contains inversions You are given a permutation of size and queries to it Each query is represented by two indices and denoting that you have to reverse the segment of the permutation For example if and a query is applied then the resulting permutation is After each query you have to determine whether the number of inversions is odd or even ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    vi a(N);\n    for (int i = 0; i < N; i++)\n        cin >> a[i];\n    int swap = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = i + 1; j < N; j++)\n            if (a[i] > a[j])\n                swap++;\n    swap &= 1;\n    int M;\n    cin >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        ll s = r - l + 1;\n        ll c = s * (s - 1) / 2;\n        swap ^= c & 1;\n        cout << (swap ? ""odd\\n"" : ""even\\n"");\n    }\n\n    return 0;\n}\n']","['brute force', 'math']",1800
https://codeforces.com//contest/691/problem/F,F. Couple Cover,Couple Cover a wildly popular luck based game is about to begin Two players must work together to construct a rectangle A bag with balls each with an integer written on it is placed on the table The first player reaches in and grabs a ball randomly all balls have equal probability of being chosen the number written on this ball is the rectangle s width in meters This ball is not returned to the bag and the second player reaches into the bag and grabs another ball the number written on this ball is the rectangle s height in meters If the area of the rectangle is greater than or equal some threshold square meters the players win Otherwise they lose The organizers of the game are trying to select an appropriate value for so that the probability of a couple winning is not too high and not too low but they are slow at counting so they have hired you to answer some questions for them You are given a list of the numbers written on the balls the organizers would like to know how many winning pairs of balls exist for different values of Note that two pairs are different if either the first or the second ball is different between the two in pair and two different balls with the same number are considered different ,"['/*\nOne, two, three, four, five against one\nFive, five, against one\nSaid one, two, three, four, five against one\nFive, five, five, five, five against one\n\nTorture from you to me\nAbducted from the street\n\nI\'d rather be\nI\'d rather be with\nI\'d rather be with an animal\n\nWhy would you wanna hurt me? Oh\nOh, so frightened of your pain\n\nI\'d rather be\nI\'d rather be with\nI\'d rather be with an animal\nI\'d rather be\nI\'d rather be\nI\'d rather be with an animal\n\nI\'d rather be\nI\'d rather be with\nI\'d rather be with an animal\nI\'d rather be\nI\'d rather be\nI\'d rather be with an animal\n\nSaid one, two, three, four, five against one\nFive, five, five, five, five against one\nOne, two, three, four, five against one\nFive, five, five, five, five against one\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 3000031;\n\nint n, ar[N];\nint cnt[N];\nlong long total[N], below[N];\nint tests, val;\n\nint main(){\n\t//freopen(""fabro.in"",""r"",stdin);\n\t//freopen(""fabro.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"", ""r"", stdin);\n\t//freopen(""F:/output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tcnt[ar[i]]++;\n\t}\n\n\tfor (int i = 1; i <= 3000000; i++)\n\t{\n\t\tif (cnt[i] == 0)\n\t\t\tcontinue;\n\n\t\tfor (int j = 1; j*i <= 3000000; j++)\n\t\t{\n\t\t\ttotal[i*j] += 1ll*cnt[i] * cnt[j];\n\t\t\tif (i == j)\n\t\t\t\ttotal[i*j] -= cnt[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3000000; i++)\n\t{\n\t\tbelow[i] = below[i - 1] + total[i - 1];\n\t}\n\n\tlong long RES = 1ll * n*(n - 1);\n\n\tcin >> tests;\n\tfor (; tests; --tests)\n\t{\n\t\tcin >> val;\n\t\tcout << RES - below[val] << ""\\n"";\n\t}\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']","['brute force', 'dp', 'number theory']",2200
https://codeforces.com//contest/367/problem/E,E. Sereja and Intervals,Sereja is interested in intervals of numbers so he has prepared a problem about intervals for you An interval of numbers is a pair of integers Interval belongs to interval if the following condition is met Sereja wants to write out a sequence of intervals on a piece of paper At that no interval in the sequence can belong to some other interval of the sequence Also Sereja loves number very much and he wants some at least one interval in the sequence to have Sereja wonders how many distinct ways to write such intervals are there Help Sereja and find the required number of ways modulo Two ways are considered distinct if there is such that the th intervals in two corresponding sequences are not equal ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007\n\nint N,M,X;\nint dp[2][320][320];\n\nint main(void){\n    int i,j,x;\n    \n    cin >> N >> M >> X;\n    X--;\n    \n    if(N > M){\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    dp[0][0][0] = 1;\n    \n    REP(x,M){\n        int cur = x%2, next = (x+1)%2;\n        \n        REP(i,N+1) REP(j,N+1) dp[next][i][j] = 0;\n        \n        REP(i,N+1) REP(j,N+1) if(dp[cur][i][j] != 0){\n            if(x != X) dp[next][i][j] = (dp[next][i][j] + dp[cur][i][j]) % MOD;\n            if(x != X && i >= j+1) dp[next][i][j+1] = (dp[next][i][j+1] + dp[cur][i][j]) % MOD;\n            dp[next][i+1][j] = (dp[next][i+1][j] + dp[cur][i][j]) % MOD;\n            dp[next][i+1][j+1] = (dp[next][i+1][j+1] + dp[cur][i][j]) % MOD;\n        }\n    }\n    \n    ll ans = dp[M%2][N][N];\n    REP(i,N) ans = ans * (i+1) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']","['combinatorics', 'dp']",2700
