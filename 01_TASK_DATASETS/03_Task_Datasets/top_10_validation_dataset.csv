problem_statement,problem_solution,problem_tags,problem_dificulty,problem_editorial
You and Your SubmissionA tree is a connected undirected graph without cycles A weighted tree has a weight assigned to each edge The degree of a vertex is the number of edges connected to this vertex You are given a weighted tree with n vertices each edge has a weight of 1 Let L be the set of vertices with degree equal to 1 You have to answer q queries In the i th query You are given a positive integer x i For all u v in L such that u v add edge u v with weight x i to the graph initially the given tree Find the diameter of the resulting graph The diameter of a graph is equal to max limits 1 le u v le n operatorname d u v where operatorname d u v is the length of the shortest path between vertex u and vertex v ,"['#pragma GCC optimize(""Ofast"")\n#include<bits/stdc++.h>\nusing namespace std;\n#define end ed\n#define N 1000005\nint fa[N],f1[N],qwq,f2[N],f3[N],fir[N],end[N],dep[N],tot,rmq[N<<1],D[N<<1][21],lg[N<<1],LG;\nvector<int>son[N];\nstruct node{\n\tint x,y;\n}f[N];\nint Dis(int x,int y){\n\tLG=lg[y-x+1];\n\treturn min(D[x][LG],D[y-(1<<LG)+1][LG]);\n}\nint dis(int x,int y){\n\tif(fir[x]<=end[y]){\n\t\treturn dep[x]+dep[y]-(Dis(fir[x],end[y])<<1);\n\t}\n\treturn dep[x]+dep[y]-(Dis(fir[y],end[x])<<1);\n}\ninline bool cmp(node aa,node bb){\n\treturn aa.y<bb.y;\n}\nvoid dfs(int now){\n\tif(son[now].size()==0)f1[now]=0;\n\telse f1[now]=1e9;\n\tf2[now]=1e9;\n\trmq[++tot]=now;fir[now]=end[now]=tot;\n\tfor(int T,i=0;i<son[now].size();++i){\n\t\tdfs(T=son[now][i]);\n\t\tif(f1[T]+1<f1[now])f2[now]=f1[now],f1[now]=f1[T]+1;\n\t\telse f2[now]=min(f2[now],f1[T]+1);\n\t\trmq[++tot]=now;\n\t\tend[now]=tot;\n\t}\n}\nnamespace IO{\n\tchar ibuf[1<<20],*ip1=0,*ip2=0;\n\tchar gc(){if(ip1==ip2)ip1=ibuf,ip2=ibuf+fread(ibuf,1,1<<20,stdin);return ip1==ip2?EOF:*ip1++;}\n\tchar obuf[1<<20],*op1=obuf,*op2=obuf+(1<<20);\n\tvoid flush(){fwrite(obuf,1,op1-obuf,stdout);}\n\tvoid pc(char c){*op1++=c;if(op1==op2)flush(),op1=obuf;}\n\tstruct ioo{ioo(){}~ioo(){flush();}}ioo;\n};\nusing namespace IO;\nint read(){\n\tint ret=0,t=1;char c=gc();\n\twhile((c<\'0\'||c>\'9\')&&c!=\'-\')c=gc();if(c==\'-\')t=-1,c=gc();\n\twhile(c>=\'0\'&&c<=\'9\')ret=ret*10+c-\'0\',c=gc();return ret*t;\n}\nvoid dfs_(int now){\n\tfor(int T,i=0;i<son[now].size();++i){\n\t\tT=son[now][i];dep[T]=dep[now]+1;\n\t\tif(f1[now]==f1[T]+1)f3[T]=f2[now]+1;\n\t\telse f3[T]=f1[now]+1;\n\t\tf3[T]=min(f3[T],f3[now]+1);\n\t\tdfs_(T);\n\t}\n}\nint n,i,j,g[N][2],diss[N],l,r,mid,q,x,len;\nint check(int ans){\n\tj=n;\n\tif(qwq>=(n>>2)&&n==1000000){\n\t\tfor(i=1;diss[i]>=ans;++i){\n\t\t\twhile(j&&f[i].y+f[j].y+x>=ans)--j;\n\t\t\tif(j!=n){\n\t\t\t\tif(dis(f[i].x,g[j+1][0])>=ans){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif(dis(f[i].x,g[j+1][1])>=ans){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=n;++i){\n\t\twhile(j&&f[i].y+f[j].y+x>=ans)--j;\n\t\tif(j>=i&&diss[i]<ans)continue;\n\t\tif(j!=n){\n\t\t\tif(dis(f[i].x,g[j+1][0])>=ans){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(dis(f[i].x,g[j+1][1])>=ans){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tn=read();\n\tfor(i=2;i<=n;++i)fa[i]=read(),son[fa[i]].push_back(i),qwq+=fa[i]==i-1;\n\tdfs(1);\n\tif(son[1].size()==1)f3[1]=0;\n\telse f3[1]=1e9;\n\tdfs_(1);\n\tlg[1]=0;\n\tfor(i=2;i<(n<<1);++i){\n\t\tlg[i]=lg[i-1]+((i&-i)==i);\n\t}\n\tfor(i=1;i<=n;++i)f1[i]=min(f1[i],f3[i]),f[i].x=i,f[i].y=f1[i];\n\tsort(f+1,f+n+1,cmp);\n\tfor(i=1;i<=tot;++i){\n\t\tD[i][0]=dep[rmq[i]];\n\t}\n\tfor(i=0;(1<<i+1)<tot;++i){\n\t\tfor(j=1;j<=tot-(1<<i);++j){\n\t\t\tif(D[j][i]<=D[j+(1<<i)][i])D[j][i+1]=D[j][i];\n\t\t\telse D[j][i+1]=D[j+(1<<i)][i];\n\t\t}\n\t\tfor(;j<=tot;++j)D[j][i+1]=D[j][i];\n\t}\n\tg[n][0]=f[n].x;\n\tg[n][1]=f[n].x;\n\tdiss[n]=0;\n\tg[n-1][0]=f[n-1].x;\n\tg[n-1][1]=f[n-1].x;\n\tdiss[n-1]=dis(f[n].x,f[n-1].x);\n\tfor(i=n-2;i;--i){\n\t\tint d1=dis(f[i].x,g[i+1][0]),d2=dis(f[i].x,g[i+1][1]);\n\t\tg[i][0]=g[i+1][0];\n\t\tg[i][1]=g[i+1][1];\n\t\tdiss[i]=diss[i+1];\n\t\tif(d1>=d2&&d1>diss[i+1]){\n\t\t\tdiss[i]=d1;\n\t\t\tg[i][1]=f[i].x;\n\t\t}\n\t\tif(d2>d1&&d2>diss[i+1]){\n\t\t\tdiss[i]=d2;\n\t\t\tg[i][0]=f[i].x;\n\t\t}\n\t}\n\tq=read();\n\twhile(q--){\n\t\tx=read();\n\t\tl=0;\n\t\tfor(i=1;i<=n;++i)l=max(l,min(diss[i],f1[g[i][0]]+f1[g[i][1]]+x));\n\t\tr=min(diss[1],f[n].y+f[n-1].y+x);\n\t\twhile(l<r){\n\t\t\tmid=r-(r-l>>1);\n\t\t\tif(check(mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tcout<<l<<\'\\n\';\n\t}\n} ']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0]",3200,We will solve the problem independently times Let be the distance to the closest leaf from vertex can be found using a simple bfs with multiple start sources Let be the distance in the resulting graph Then A short proof we ll either go through an edge between two leaves or we won t In the second case the answer is clearly In the first case our objective is to get to a leaf as fast as possible use an edge with weight and then move to the destination vertex We want to find the maximum possible value of As is pretty standard in tree problems we can do small to large merging Let s maintain the max value of over all in the subtree of with We have a variable initially For some we will first merge all the subtrees and then add to the merged We will also update during this The final answer will be Merging two subtrees Suppose we are merging subtree into subtree with some current First of all iterate from to For every do this cycle if and then do and continue else break and continue to the next Why does this work Because all arrays are sorted in decreasing order Why Because for some vertex with there is always a vertex in it s subtree with After we are done with that update for every Adding to the merged When we are adding to we update the answer in almost the same way only we set to and to After that we either do or if just append to the back of Complexity This particular variant of small to large merging works in since when merging two structures of size and the new size is You can find the proof here Since we increase at most times and we can calculate for all vertices in the complexity is per query so for all queries Note that doing small to large merging once and updating answers simultaneously is much faster that doing small to large merging times In the first case you can even get away with using binary search to update the answer in the second case you cannot 
Getting closer and closer to a mathematician Serval becomes a university student on math major in Japari University On the Calculus class his teacher taught him how to calculate the expected length of a random subsegment of a given segment Then he left a bonus problem as homework with the award of a garage kit from IOI The bonus is to extend this problem to the general case as follows You are given a segment with length l We randomly choose n segments by choosing two points maybe with non integer coordinates from the given segment equiprobably and the interval between the two points forms a segment You are given the number of random segments n and another integer k The 2n endpoints of the chosen segments split the segment into 2n 1 intervals Your task is to calculate the expected total length of those intervals that are covered by at least k segments of the n random segments You should find the answer modulo 998244353 ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e3;\nconst int MOD = 998244353;\n\nint n, k, l;\n\nll inverse[2*MAXN+2], factorial[2*MAXN+2], inversefactorial[2*MAXN+2], power2[2*MAXN+2], dp[MAXN+1];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n >> k >> l;\n\t\n\tinverse[1]=1;\n\tfor(int i=2; i<2*MAXN+2; ++i)\n\t\tinverse[i]=MOD-MOD/i*inverse[MOD%i]%MOD;\n\n\tfactorial[0]=inversefactorial[0]=power2[0]=1;\n\tfor(int i=1; i<2*MAXN+2; ++i) {\n\t\tfactorial[i]=factorial[i-1]*i%MOD;\n\t\tinversefactorial[i]=inversefactorial[i-1]*inverse[i]%MOD;\n\t\tpower2[i]=power2[i-1]*2%MOD;\n\t}\n\n\tfor(int i=n; i>=k; --i) {\n\t\tdp[i] = factorial[i]*factorial[i]%MOD*power2[i]%MOD*inversefactorial[2*i+1]%MOD;\n\t\tdp[i] = dp[i]*factorial[n]%MOD*inversefactorial[i]%MOD*inversefactorial[n-i]%MOD;\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tdp[i] = (dp[i]-factorial[j]*inversefactorial[i]%MOD*inversefactorial[j-i]%MOD*dp[j]%MOD+MOD)%MOD;\n\t\t}\n\t}\n\n\tll ans=0;\n\tfor(int i=k; i<=n; ++i)\n\t\tans=(ans+dp[i])%MOD;\n\tcout << ans*l%MOD << endl;\n\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2600,EditorialWithout loss of generality assume that For a segment covering the total length of the legal intervals is the probability that we choose another point on this segment randomly such that it is in the legal intervals Since all points and the endpoints of each segment are chosen randomly and independently we only need to find the probability that point is in the legal intervals Note that only the order of these points make sense Because the points are chosen in the segment the probability that some of them coincide is so we can assume that all points do not coincide Now the problem is how to calculate the number of arrangements that is between at least pairs of endpoints It can be solved by dynamic programming in time complexity of We define as the number of arrangements for the first positions with points haven t been matched and appeared times obviously or So we can get three different types of transition for the th position below Place at th position if Start a new segment if Match a started segment note that we have choices of segments Then is the number of legal arrangements Obviously the total number of arrangements is However there are pairs of endpoints whose indices can be swapped and the indices segments can be rearranged So the final answer is 
During the latest mission of the starship U S S Coder Captain Jan Bitovsky was accidentally teleported to the surface of an unknown planet Trying to find his way back Jan found an artifact from planet Earth s ancient civilization a mobile device capable of interstellar calls created by Byterola Unfortunately there was another problem Even though Jan as a representative of humans knew perfectly the old notation of the cell phone numbers the symbols on the device s keyboard were completely worn down and invisible to the human eye The old keyboards had exactly m 1 buttons one for each digit from the base m numerical system and one single backspace button allowing one to erase the last written digit if nothing was written on the screen then this button does nothing but it s still counted as pressed Jan would like to communicate with his crew He needs to type a certain number also from the base m numerical system that is digits from 0 to m 1 He wants to know the expected number of button presses necessary to contact the U S S Coder Jan always chooses the most optimal buttons based on his current knowledge Buttons are indistinguishable until pressed Help him ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 1000000007;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = 1010;\nInverses I(N);\nFactorials F(N);\nMint dp[N][N];\nbool used[N];\nMint w[N];\nMint dp2[N][N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int k = 1; k < N; k++)\n\t\tfor (int n = k; n < N; n++) {\n\t\t\tdp[n][k] = dp[n - 1][k - 1] + Mint(k - 1) * (dp[n - 1][k - 1] + Mint(2));\n\t\t\tif (n > k) dp[n][k] += Mint(n - k) * (dp[n - 1][k] + Mint(2));\n\t\t\tdp[n][k] *= I.inv(n);\n\t\t}\n\tfor (int k = 0; k < N; k++)\n\t\tfor (int n = k; n < N; n++) {\n\t\t\tdp2[n][k] = dp[n][k];\n\t\t\tif (k > 0) dp2[n][k] += Mint(k) * (dp2[n - 1][k - 1] + Mint(2));\n\t\t\tif (n > k) dp2[n][k] += Mint(n - k) * (dp2[n - 1][k] + Mint(2));\n\t\t\tdp2[n][k] *= I.inv(n + 1);\n\t\t}\n\n\n\tint n, m;\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tused[x] = 1;\n\t}\n\tint k = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tk += used[i];\n\n\tMint ans = n;\n\tfor (int i = 0; i <= m + 1; i++)\n\t\tw[i] = F.fi[m + 1] * F.f[m + 1 - i];\n\tfor (int i = 0; i < k; i++) {\n\t\tif (i == 0) {\n\t\t\tans += w[i + 1] * (dp[m - i][k - i] + 1);\n\t\t} else {\n\t\t\tans += w[i + 1] * (dp[m - i][k - i] + 2);\n\t\t}\n\t\tans += w[i + 1] * Mint(k - i - 1) * (dp2[m - i - 1][k - i - 1] + Mint(2));\n\t\tans += w[i + 1] * Mint(m - k) * (dp2[m - i - 1][k - i] + Mint(2));\n\t}\n\tprintf(""%u\\n"", ans.x);\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3500,Let us make some observations First of them is that if a phone number consists of two or more of the same kind then we will always pay exactly click for each but the first occurrence of it it follows from the fact that we have to already the key responsible for this digit This is why we can reduce the problem to finding a solution for a phone number with unique digits Secondly since all the buttons are indistinguishable at the beginning then the order of digits in the input does not matter This leads to the conclusion that what we want to compute is some kind of which stands for expected time of completing number if buttons that we have to eventually click are not yet discovered and buttons that we don t need are also not yet discovered Unfortunately the BackSpace key and necessity of clearing incorrect prefix of the phone number complicates things significantly We will create additional dimension of the responsible for the state of the prefix and the information about if we have already clicked backspace Those four states will be empty prefix of digits on the screen non empty correct prefix of digits on the screen non empty prefix that is not prefix of the phone number when we have already found a backspace we assume prefix is correct or in other words paid in advance Let us first compute If then Else we try to click new buttons If we guess correctly exactly the next button then we get Otherwise we could guess one of the remaining good buttons with probability Since we already know backspace location we can remove it and in future we will pay only for this digit We hence get operations Similarly if we guess bad button we get Rest of the states can be computed using similar approach Even though transitions may look scary they are similar for different dimensions and common implementation can be used 
In the country there are exactly cities numbered with positive integers from to In each city there is an airport is located Also there is the only one airline which makes flights Unfortunately to use them you need to be a regular customer of this company namely you have the opportunity to enjoy flight from city to city only if you have already made at least flights before that Please note that flight flies exactly from city to city It can not be used to fly from city to city An interesting fact is that there may possibly be recreational flights with a beautiful view of the sky which begin and end in the same city You need to get from city to city Unfortunately you ve never traveled by plane before What minimum number of flights you have to perform in order to get to city Note that the same flight can be used multiple times ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 151\nint n,m;\nstruct mac{\n  bitset<MAX> t[MAX];\n  void dod(int a,int b){\n    t[a][b] = 1;\n  }\n  mac(){};\n  mac(mac& a,mac& b){\n    R(i,n){\n      R(j,n){\n      if(a.t[i][j])\n        t[i] |= b.t[j];\n      }\n    }\n  }\n}ak,dm;\nvector<mac> lo;\nint t = 0;\nint odp(int i){\n  while(i){\n    i--;\n    mac kan(dm,lo[i]);\n    if(kan.t[0][n-1] == 0){\n      dm = kan;\n      t+=1<<i;\n    }\n  }\n  printf(""%d\\n"",t+1);\n  exit(0);\n}\nvector<pair<int,PI> > w;\nvoid pot(int wyk){\n  lo.clear();\n  lo.PB(ak);\n  int i = 0;\n  while(wyk){\n    if(wyk&1){\n      mac kan(dm,lo[i]);\n      if(kan.t[0][n-1]){\n        odp(i);\n      }\n      dm = kan;\n      t+=1<<i;\n    }\n    wyk/=2;\n    lo.PB(mac(lo[i],lo[i]));\n    i++;\n  }\n}\nmain(){\n  make(n);\n  make(m);\n  ak.dod(n-1,n-1);\n  R(i,n){\n    dm.dod(i,i);\n  }\n  R(i,m){\n    int a,b,d;\n    make2(a,b);\n    a--;b--;\n    make(d);\n    w.PB({d,MP(a,b)});\n  }\n  sort(ALL(w));\n  int i = 0;\n  w.PB({(int)1e9+200,{0,0}});\n  while(i<m){\n    while(i < m && w[i].FI == t){\n      ak.dod(w[i].SE.FI,w[i].SE.SE);\n      i++;\n    }\n    pot(w[i].FI-t);\n  }\n  puts(""Impossible"");\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2700,Let s optimize the first solution that comes to mind O m dmax let s calculate can t v can we get to the vertice v while passing exactly t edges Now it s easy to find out that the set of edges we are able to go through changed only m times Let s sort these edges in increasing order of di that means for each i di di 1 Let s calculate can t v only for t di We can calculate can di 1 using can di by raising the adjacency matrix to the di 1 di power and applying it to can di Next step is to fix an edge with maximal di on our shortest path let it be i We know all the vertices we can be at moment di so we need to calculate the shortest path to n 1 using edges we can go through We can even use Floyd algorithm to calculate that The complexity of this solution is O m n3 log dmax and it s not enough Next observation is that adjacency matrix contains only zeroes or ones so we can multiply these matrixes using bitsets in O n3 32 
You are given an array a 1 a 2 ldots a n consisting of n positive integers and a positive integer m You should divide elements of this array into some arrays You can order the elements in the new arrays as you want Let s call an array m divisible if for each two adjacent numbers in the array two numbers on the positions i and i 1 are called adjacent for each i their sum is divisible by m An array of one element is m divisible Find the smallest number of m divisible arrays that a 1 a 2 ldots a n is possible to divide into ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n, m;\n        cin >> n >> m;\n        vector<ll> a(n);\n        map<ll, ll> q;\n        ll ans = 0;\n        bool k = 0;\n        for (int i = 0; i < n; ++i) {\n            ll x;\n            cin >> x;\n            x %= m;\n            if (!x) {\n                k = 1;\n                continue;\n            }\n            ++q[x];\n            ++q[m - x];\n            --q[m - x];\n        }\n        if (k) ++ans;\n        for (auto &elem : q) {\n            ll c = m - elem.fi;\n            if (elem.fi <= c) {\n                if (elem.fi == c) ans += 1;\n                else ans += max(1ll, (max(elem.se, q[c]) - min(elem.se, q[c])));\n            }\n        }\n        cout << ans << \'\\n\';\n    }\n}\n']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1200,Let s take each number modulo Now let be the amount of in array If then all should be put in a single array answer increases by For each number we put it in an array In this array the amount of and the amount of should differ not more than by that s why we need to make arrays containing a single number or that is more common 
You are given an initially empty undirected graph with n nodes numbered from 1 to n i e n nodes and 0 edges You want to add m edges to the graph so the graph won t contain any self loop or multiple edges If an edge connecting two nodes u and v is added its weight must be equal to the greatest common divisor of u and v i e gcd u v In order to add edges to the graph you can repeat the following process any number of times possibly zero choose an integer k ge 1 add exactly k edges to the graph each having a weight equal to k 1 Adding these k edges costs k 1 in total Note that you can t create self loops or multiple edges Also if you can t add k edges of weight k 1 you can t choose such k For example if you can add 5 more edges to the graph of weight 6 you may add them and it will cost 6 for the whole pack of 5 edges But if you can only add 4 edges of weight 6 to the graph you can t perform this operation for k 5 Given two integers n and m find the minimum total cost to form a graph of n vertices and exactly m edges using the operation above If such a graph can t be constructed output 1 Note that the final graph may consist of several connected components ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nnamespace Prime\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll M=(ll)(N-1)*(N-1);\n\tui pr[N],mn[N],phi[N],cnt;\n\tint mu[N];\n\tvoid init_prime()\n\t{\n\t\tui i,j,k;\n\t\tphi[1]=mu[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tif (!mn[i])\n\t\t\t{\n\t\t\t\tpr[cnt++]=i;\n\t\t\t\tphi[i]=i-1; mu[i]=-1;\n\t\t\t\tmn[i]=i;\n\t\t\t}\n\t\t\tfor (j=0; (k=i*pr[j])<N; j++)\n\t\t\t{\n\t\t\t\tmn[k]=pr[j];\n\t\t\t\tif (i%pr[j]==0)\n\t\t\t\t{\n\t\t\t\t\tphi[k]=phi[i]*pr[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tphi[k]=phi[i]*(pr[j]-1);\n\t\t\t\tmu[k]=-mu[i];\n\t\t\t}\n\t\t}\n\t\t//for (i=2;i<N;i++) if (mu[i]<0) mu[i]+=p;\n\t}\n\ttemplate<typename T> T getphi(T x)\n\t{\n\t\tassert(M>=x);\n\t\tT r=x;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\tif (x>=N) return r/x*(x-1);\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<typename T> vector<pair<T,ui>> getw(T x)\n\t{\n\t\tassert(M>=x);\n\t\tvector<pair<T,ui>> r;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\tif (x>=N)\n\t\t{\n\t\t\tr.push_back({x,1});\n\t\t\treturn r;\n\t\t}\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\treturn r;\n\t}\n}\nusing Prime::pr,Prime::phi,Prime::getw;\nusing Prime::mu,Prime::init_prime;\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tinit_prime();\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j;\n\t\tll m;\n\t\tcin>>n>>m;\n\t\tvector<ll> cnt(n+1);\n\t\tfor (i=1; i<=n; i++) cnt[i]=(ll)(n/i)*(n/i);\n\t\tfor (i=1; i<=n; i++) for (j=2; j*i<=n; j++) cnt[i]+=cnt[j*i]*mu[j];\n\t\tfor (i=2; i<=n; i++) cnt[i]=(cnt[i]-1>>1)/(i-1);\n\t\tll res=0;\n\t\t// dbg(cnt);\n\t\tfor (i=n; i>=2; i--)\n\t\t{\n\t\t\tll d=min(cnt[i],m/(i-1));\n\t\t\tm-=d*(i-1);\n\t\t\tres+=d*i;\n\t\t\t// dbg(m,res,i);\n\t\t}\n\t\tif (m) cout<<""-1\\n"";\n\t\telse cout<<res<<\'\\n\';\n\t}\n}\n']","[1, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2000,In each step adding edges to the graph with weights costs one more than the number of edges added So the total cost of adding edges in steps will be Since the number of edges is given i e fixed to find the minimum cost we need to minimize the number of steps Firstly let s calculate the number of pairs where with for each in time It can be solved in a standard way using the M bius function or using Dynamic Programming where is the required number that can be calculated as Knowing all we can calculate the maximum number of steps we can perform using edges of weight And Note that array is non increasing and if we have at least one pack of size then we have at least one pack of each size where So our task is an extension of the task where you need to take a subset of of minimum size with sum equal to and can be solved with the same greedy strategy Let s just take packs greedily starting from weight down to weight We ll take packs as many packs as possible For a fixed weight we can calculate the maximum number of packs we can take as If edges can t be constructed then we return Otherwise we return where is the total number of packs Time Complexity 
You have a large electronic screen which can display up to 998244353 decimal digits The digits are displayed in the same way as on different electronic alarm clocks each place for a digit consists of 7 segments which can be turned on and off to compose different digits The following picture describes how you can display all 10 decimal digits As you can see different digits may require different number of segments to be turned on For example if you want to display 1 you have to turn on 2 segments of the screen and if you want to display 8 all 7 segments of some place to display a digit should be turned on You want to display a really large integer on the screen Unfortunately the screen is bugged no more than n segments can be turned on simultaneously So now you wonder what is the greatest integer that can be displayed by turning on no more than n segments Your program should be able to process t different test cases ,"[""// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nint main() {\n    int t = read();\n    while (t--) {\n        int n = read();\n        int cnt = n >> 1;\n        if (n & 1) {\n            putchar('7');\n            --cnt;\n        }\n        while (cnt--) {\n            putchar('1');\n        }\n        putchar('\\n');\n    }\n    return 0;\n}\n""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900,First of all we don t need to use any digits other than and If we use any other digit it consists of or more segments so it can be replaced by two s and the number will become greater For the same reason we don t need to use more than one if we have two we can replace them with three s Obviously it is always optimal to place before So our number is either a sequence of s or a and a sequence of s We should use only if is odd because if is even it will decrease the number of digits in the result 
There s a table of n times m cells n rows and m columns The value of n cdot m is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to find out whether it is possible to place frac nm 2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n,m,k;\n    cin >> n >> m >> k;\n    if(n % 2 == 0 && m % 2 == 0)\n    {\n        if(k % 2 == 0)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    else if(n % 2 == 1 && m % 2 == 0)\n    {\n        k -= m/2;\n        if(k >= 0 && k % 2 == 0)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    else if(n % 2 == 0 && m % 2 == 1)\n    {\n        if(k % 2 == 0 && k <= n * m / 2 - n / 2)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1700,Suppose n and m are even A necessary and sufficient condition of existence of the answer is that k is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size 2 2 the number of the vertical dominoes is even too if k is even If n and m are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter a and the other one with the letter b If a cell of the board is white let s mark one of the dominoes of the block with the letter c and the other one with the letter d There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column n is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose n is odd hence m is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to 0 Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out m cells and m2 dominoes So the necessary condition is that the number of horizontal dominoes k is at least m2 Let s extend the necessary condition with the following condition the value of k m2 is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both n and m The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of k m2 is even Let s build an answer if the conditions k m2 and k m2 is even are met Let s place in the topmost row m2 horizontal dominoes and mark their cells as follows the first domino will be marked with x the second one with y the third one with x and so on As the result the region of n 1 rows and m columns will be unfilled Both values are even and the value of k m2 is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd m hence n is even is similar to the previous one let s transpose the table it will have m rows and n columns swap the values of k and nm2 k solve the case above and transpose the table back to have n rows and m columns 
You are given an integer n For each m k such that 3 leq m leq n 1 and 0 leq k leq n 1 count the permutations of 1 2 n such that p i p i 1 geq m for exactly k indices i modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic constexpr int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\n//size of input must be a power of 2\n//output elements are in the range [0,mod*4)\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\n#ifdef USE_GOOD_MOD\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tstatic vc<mint> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\ntemplate<class mint>\nvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint s=si(x);\n\tassert(ispow2(s));\n\tassert(si(y));\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tstatic vc<mint> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);\n\treturn x;\n}\n\n#else\n\n//59501818244292734739283969-1=5.95*10^25 までの値を正しく計算\n//最終的な列の大きさが 2^24 までなら動く\n//最終的な列の大きさが 2^20 以下のときは，下の 3 つの素数を使ったほうが速い（は？）\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\tconstexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\tconstexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\tconstexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\t//extern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\t//extern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class t,class mint>\n\tvc<t>&sub_givenlength(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint s=si(x);\n\t\tassert(ispow2(s));\n\t\tassert(si(y)==s);\n\t\tstatic vc<t> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tstatic vc<t> w;\n\t\t\tw.clear();w.resize(s);\n\t\t\trep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\t\tauto&d0=sub_givenlength<mint0>(x,y,same);\n\t\tauto&d1=sub_givenlength<mint1>(x,y,same);\n\t\tauto&d2=sub_givenlength<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tx.resize(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tx[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn x;\n\t}\n}\nusing arbitrary_convolution::multiply;\nusing arbitrary_convolution::multiply_givenlength;\n\n#endif\n\n//UTPC2021 C\nnamespace integer_convolution{\n\textern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\textern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base0{469762049,3};//2^26 * 7 + 1\n\t//extern constexpr modinfo base1{754974721,11};//2^24 * 45 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\ttemplate<class t>\n\tvc<t> sub(const vi&x,const vi&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i];\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i];\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\tvi multiply(const vi&x,const vi&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tconst mint1 r=mint1(mint0::mod).inv();\n\t\tconst ll v=ll(mint0::mod)*mint1::mod;\n\t\tint n=si(d0);\n\t\tvi res(n);\n\t\trep(i,n){\n\t\t\tres[i]=d0[i].v+(r*(d1[i]-d0[i].v)).v*(ull)mint0::mod;\n\t\t\tif(res[i]>v/2)res[i]-=v;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n//最大で 1<<mx のサイズの fft が登場！\ntemplate<class mint>\nvc<mint> large_convolution(const vc<mint>&a,const vc<mint>&b,int mx){\n\tint n=si(a),m=si(b);\n\tvc<mint> c(n+m-1);\n\tint len=1<<(mx-1);\n\tfor(int i=0;i<n;i+=len){\n\t\tfor(int j=0;j<n;j+=len){\n\t\t\tint x=min(len,n-i),y=min(len,m-j);\n\t\t\tauto d=multiply(vc<mint>(a.bg+i,a.bg+i+x),vc<mint>(b.bg+j,b.bg+j+y));\n\t\t\trep(k,si(d))\n\t\t\t\tc[i+j+k]+=d[k];\n\t\t}\n\t}\n\treturn c;\n}\n\n//input A: N 次,B ?,M\n//output D: M 次多項式\n//C を M 次多項式として\n//[x^N] A*B*C = [x^M] D*C\n//となるような D を返す\n//CF796F\ntemplate<class mint>\nvc<mint> transpose_advance(const vc<mint>&a,const vc<mint>&b,int m){\n\tint n=si(a)-1;\n\tauto d=multiply(a,b);\n\tvc<mint> res(m+1);\n\tif(n>=m){\n\t\trep(i,m+1)res[i]=d[i+n-m];\n\t}else{\n\t\trng(i,m-n,m+1)res[i]=d[i+n-m];\n\t}\n\treturn res;\n}\n\n//Yukicoder 2166\ntemplate<class mint>\nvoid chmult(vc<mint>&x,const vc<mint>&y,int s){\n\tx=multiply(move(x),y);\n\tx.resize(s);\n}\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base107{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\nusing mint107=modular<base107>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//対角線を超えず (x,y) に至る方法の数\nmint catalan(int x,int y){\n\tassert(y<=x);\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n//y=x+c を超えず (x,y) に至る方法の数\nmint catalan(int x,int y,int c){\n\tassert(y<=x+c);\n\treturn binom(x,y)-binom(x+c+1,y-c-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nbool dbg=false;\n\nconst int nmax=4010;\n\nmint paths[nmax][nmax];\nmint ans[nmax][nmax];\n\nvoid slv(){\n\tint n;cin>>n;\n\t\n\trep(ini,2){\n\t\trep(m,n+1)rep(c,m+1)paths[m][c]=0;\n\t\t\n\t\tpaths[ini][ini]=1;\n\t\t\n\t\trep(m,n){\n\t\t\tif(m%2==ini){\n\t\t\t\trep(c,m+1){\n\t\t\t\t\tpaths[m+1][c+1]+=paths[m][c];\n\t\t\t\t\tpaths[m+1][c]+=paths[m][c]*(2*c);\n\t\t\t\t\tif(c)paths[m+1][c-1]+=paths[m][c]*c*(c-1);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(c,m+1){\n\t\t\t\t\tpaths[m+1][c+1]+=paths[m][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//dmp(paths[2][2]);\n\t\t//dmp(paths[3][1]);\n\t\t\n\t\trng(m,1,n)if(m%2!=ini){\n\t\t\tvc<mint> now(m+1);\n\t\t\trep(c,m+1)now[m-c]=paths[m][c]*binom(n-m,c)*fact[n-m]*fact[c];\n\t\t\t//dmp(now);\n\t\t\t\n\t\t\trep(c,m+1)now[c]*=fact[c];\n\t\t\trein(now);\n\t\t\tvc<mint> z(m+1);\n\t\t\trep(c,m+1)z[c]=finv[c]*parity(c);\n\t\t\tchmult(now,z,m+1);\n\t\t\trein(now);\n\t\t\trep(c,m+1)now[c]*=finv[c];\n\t\t\t\n\t\t\trep(c,m+1){\n\t\t\t\t//(n-1-c)\n\t\t\t\tint k=n-1-c;\n\t\t\t\t//dmp2(m,k,now[c]);\n\t\t\t\t\n\t\t\t\tans[m][k]=now[c];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmint107 x;cin>>x;\n\tmint107 res;\n\trng(m,1,n){\n\t\tmint107 w=x.pow((m+2)*n);\n\t\trep(k,n){\n\t\t\tres+=mint107(ans[m][k].v)*w;\n\t\t\tw*=x;\n\t\t}\n\t}\n\tprint(res);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1900,SolutionLet s solve for a single Suppose is even Start from an empty array and insert the elements in the order At any moment all the elements are concatenated and you can insert new elements either at the beginning at the end or between two existing elements When you insert an element the sum with any of the previous inserted elements is Otherwise the sum is So you can calculate number of ways to insert the first elements of and make good pairs with sum You can split the ordering into two parts small and big elements alternate there are only small elements For the second part you don t need DP Suppose you have already inserted elements and there are good pairs but when you will have inserted all elements you want good pairs The number of ways to insert the remaining elements can be computed with combinatorics in after precomputing factorials and inverses you have to choose which pairs to break and use stars and bars we skip exact formulas because they are relatively easy to find If you rearrange the factorials correctly you can get that all the answers for a fixed can be computed by multiplying two polynomials one of which contains the where is equal to the length of the alternating prefix NTT is fast enough Complexity 
For an arbitrary binary string t text let f t be the number of non empty subsequences text of t that contain only mathtt 0 and let g t be the number of non empty subsequences of t that contain at least one mathtt 1 Note that for f t and for g t each subsequence is counted as many times as it appears in t E g f mathtt 000 7 g mathtt 100 4 We define the of the binary string t to be f t g t where for an arbitrary integer z z represents the absolute value of z You are given a positive integer n Find a binary string s of length n such that its is as small as possible If there are multiple strings you can print any of them text A binary string is a string that only consists of characters texttt 0 and texttt 1 text A sequence a is a subsequence of a sequence b if a can be obtained from b by the deletion of several possibly zero or all elements For example subsequences of mathtt 1011101 are mathtt 0 mathtt 1 mathtt 11111 mathtt 0111 but not mathtt 000 nor mathtt 11100 ,"['#include ""bits/stdc++.h""using namespace std;using ll = long long;using vi = vector<int>;\xa0#define endl \'\\n\'#define pb emplace_back#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()#define make_unique(x) sort(all(x)), x.resize(unique(all(x)) - begin(x))#define debug(x) cerr << ""["" << __LINE__ << ""] ""#x"" = "" << (x) << endl\xa0int a[1005];\xa0void solve() {\t\tint n;\t\tcin >> n;\tfor (int i = 0; i < n - 1; i ++) cout << \'0\';\tcout << ""1\\n""; \xa0}int main() {#ifndef ONLINE_JUDGE\tfreopen(""in.txt"", ""r"", stdin);//\tfreopen(""out.txt"", ""w"", stdout);#endif\xa0\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\xa0\tint tc = 1;\tcin >> tc;\twhile (tc --) solve();\xa0\treturn 0;}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",800,Problem Credits Proof by QED Analysis Proof by QED Solution Observation is odd Proof is the set of all non empty subsets of which is which is odd The sum and difference of two integers has the same parity so is always odd By including exactly one in the string we can make and or by the multiplication principle Clearly this is the best we can do So we print out any string with exactly one 
You are given three integers a b and x Your task is to construct a binary string s of length n a b such that there are exactly a zeroes exactly b ones and exactly x indices i where 1 le i n such that s i ne s i 1 It is guaranteed that the answer always exists For example for the string there are four indices i such that 1 le i n and s i ne s i 1 i 1 2 3 4 For the string there are two such indices i i 3 5 Recall that binary string is a non empty sequence of characters where each character is either or ,"['#include ""bits/stdc++.h""\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<""----------------""<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<"" = ""<< x<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\n\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nint a,b,x;\n\nint main()\n{\n    //~ freopen(""file.in"", ""r"", stdin);\n    scanf(""%d%d%d"", &a,&b,&x);\n    string s=""0"";a --;\n    if(a < b)\n    \ts[0] ++, b --, a ++;\n    for(int i = 1; i <= x; i ++){\n    \ts.pb(\'1\' - s[i - 1] + \'0\');\n    \tif(s[i] == \'1\')\n    \t\tb --;\n    \telse\n    \t\ta --;\n    }\n    for(int i = 0; i <= x; i ++){\n    \tcout << s[i];\n        while(s[i] == \'0\' && a){\n            cout << 0;\n            a --;\n        }\n        while(s[i] == \'1\' && b){\n            cout << 1;\n            b --;\n        }\n    }\t\n\treturn 0;\n}\n\n\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1300,This problem has several general cases is even and then the answer is repeated times then ones and zeroes is even and then the answer is repeated times then zeroes and ones is odd and then the answer is repeated times then zeroes and ones is odd and then the answer is repeated times then ones and zeroes I am sure that there are other more beautiful solution but for me the easiest way to solve this problem is to extract general cases and handle it Overall complexity is 
ChthollyNotaSeniorious gives DataStructures a number axis with m distinct segments on it Let f l r be the number of ways to choose an even number of segments such that the union of them is exactly l r and g l r be the number of ways to choose an odd number of segments such that the union of them is exactly l r ChthollyNotaSeniorious asked DataStructures q questions In each query ChthollyNotaSeniorious will give DataStructures two numbers l r and now he wishes that you can help him find the value f l r g l r modulo 998 244 353 so that he wouldn t let her down ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint n, m;\npii a[N];\npii b[N];\nint cntBad[N];\nint par[N][LOG];\nint h[N];\n\nint up(int v, int dh) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((dh >> k) & 1)\n\t\t\tv = par[v][k];\n\treturn v;\n}\nint LCA(int v, int u) {\n\tif (h[v] > h[u]) swap(v, u);\n\tu = up(u, h[u] - h[v]);\n\tif (v == u) return v;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (par[v][k] != par[u][k]) {\n\t\t\tv = par[v][k];\n\t\t\tu = par[u][k];\n\t\t}\n\t}\n\treturn par[v][0];\n}\nbool isPar(int v, int u) {\n\treturn h[v] <= h[u] && up(u, h[u] - h[v]) == v;\n}\n\nint solve(int l, int r) {\n\tint v = lower_bound(a, a + n, mp(l, -1)) - a;\n\tif (v == n || a[v].first != l) return 0;\n\tint u = lower_bound(b, b + n, mp(r, -1)) - b;\n\tif (u == n || b[u].first != r) return 0;\n\teprintf(""go %d %d\\n"", v, u);\n\tif (cntBad[v] != cntBad[u]) return 0;\n\tif (u < v) return 0;\n\tif (v == u) return -1;\n\tif (LCA(v, v + 1) <= u) return 0;\n\tif (isPar(u, v)) return -1;\n\tif (isPar(u, v + 1)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d%d"", &a[i].first, &a[i].second);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (m > 0 && a[i].first == b[m - 1].first) continue;\n\t\twhile(m > 0 && a[i].second <= b[m - 1].second) m--;\n\t\tb[m++] = a[i];\n\t}\n\tn = m;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = b[i];\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""(%d %d)\\n"", a[i].first, a[i].second);\n\tfor (int i = 1; i < n; i++) {\n\t\tassert(a[i - 1].first < a[i].first);\n\t\tassert(a[i - 1].second < a[i].second);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = mp(a[i].second, a[i].first);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tcntBad[i] = cntBad[i - 1];\n\t\tif (a[i].first > a[i - 1].second) cntBad[i]++;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tpar[i][k] = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = lower_bound(a, a + n, mp(a[i].second + 1, -1)) - a;\n\t\tif (v == n) continue;\n\t\tif (cntBad[v] != cntBad[i]) continue;\n\t\teprintf(""par[%d] = %d\\n"", i, v);\n\t\tpar[i][0] = v;\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t\th[i] = h[par[i][0]] + 1;\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tpar[v][k + 1] = par[par[v][k]][k];\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tint ans = solve(l, r);\n\t\tif (ans < 0) ans += 998244353;\n\t\tprintf(""%d\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 1, 1, 0, 0, 0]",3200,SolutionThis picture shows what the segments eventually are like For we can find the lowest such that and construct a tree by linking such and Then the LCA of and will be where the answer becomes 0 So we can get the answer of quickly by simply finding the LCA of two segments the segment starting with if no segment starts with the answer is and the first segment whose is greater than if it do not intersect with the previous segment the answer is And find the segment ending with If it is on the path of the two segments the answer will be Else the answer will be 
You are given an array a consisting of n integers a 1 a 2 dots a n Your problem is to find such pair of indices i j 1 le i j le n that lcm a i a j is minimum possible lcm x y is the least common multiple of x and y minimum positive number such that both x and y are divisors of this number ,"[""// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nconst size_t N = 1e7 + 5;\nconst size_t M = 1e6 + 5;\n\nint mnp[N], pri[N];\nbool npr[N];\n\nvoid prep() {\n  int cnt = 0;\n  for (int i = 2; i < N; ++i) {\n    if (!npr[i]) {\n      pri[cnt++] = i;\n      mnp[i] = i;\n    }\n    for (int j = 0, k; (k = i * pri[j]) < N; ++j) {\n      npr[k] = true;\n      mnp[k] = pri[j];\n      if (i % pri[j] == 0) break;\n    }\n  }\n}\n\nint a[M];\n\nstruct Data {\n  int mn = 0, se = 0;\n\n  void update(int v) {\n    if (a[v] < a[mn]) {\n      se = mn;\n      mn = v;\n    } else if (a[v] < a[se]) {\n      se = v;\n    }\n  }\n} dat[N];\n\nconst size_t T = 32;\nint pp[T], pw[T], cntp;\n\nvoid dfs(int i, int id, int cur = 1) {\n  if (i == cntp) {\n    return dat[cur].update(id);\n  }\n  for (int j = 0; j < pw[i]; ++j) {\n    dfs(i + 1, id, cur);\n    cur *= pp[i];\n  }\n  dfs(i + 1, id, cur);\n}\n\nvoid frac(int x, int id) {\n  cntp = 0;\n  while (x > 1) {\n    pp[cntp] = mnp[x];\n    pw[cntp] = 0;\n    for (; mnp[x] == pp[cntp]; x /= mnp[x]) {\n      ++pw[cntp];\n    }\n    ++cntp;\n  }\n  dfs(0, id);\n}\n\nint main() {\n  prep();\n  int n = read();\n  // int n = 1e6;\n  a[0] = INT_MAX;\n  for (int i = 1; i <= n; ++i) {\n    // frac(a[i] = 8648640, i);\n    frac(a[i] = read(), i);\n  }\n  pair<LL, pair<int, int> > ans = {1e18, {-1, -1}};\n  for (int i = 1; i < N; ++i) {\n    if (dat[i].se) {\n      int x = dat[i].mn, y = dat[i].se;\n      if (x > y) swap(x, y);\n      ans = min(ans, {(LL) a[x] * a[y] / i, {x, y}});\n    }\n  }\n  cout << ans.second.first << ' ' << ans.second.second << '\\n';\n  return 0;\n}\n""]","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0]",2200,I ve heard about some very easy solutions with time complexity where is the maximum value of but I will describe my solution with time complexity where is the maximum number of divisors of A very good upper bound approximation of the number of divisors of is so my solution works in Firstly let s talk about the idea The main idea is the following for each number from to we want to find two minimum numbers in the array which are divisible by this number Then we can find the answer among all such divisors that have at least two multiples in the array Let s write a function which will try to add the number to all its divisors The easiest way to do it is iterate over all divisors in time and add it somehow But it is too slow Let s improve it somehow How can we skip numbers that aren t divisors of Let s build an Eratosthenes sieve I highly recommended one with time complexity because the sieve with time complexity is about twice slower on such constraints which will maintain the minimum divisor for each number from to the linear sieve builds this array automatically in its implementation Then we can factorize the number in and iterate over all its divisors using simple recursive function And the last thing I should notice this solution can give TLE and require some constant optimizations I recommended to use pair of integers or arrays of size two for each divisor and to add numbers using a few statements 
Valera is a coder Recently he wrote a funny program The pseudo code for this program is given below input integers x k pa x for step 1 step k step step 1 rnd random integer from 1 to 100 if rnd p a a 2 else a a 1 s 0 while remainder after dividing a by 2 equals 0 a a 2 s s 1 Now Valera wonders given the values and what is the expected value of the resulting number ,"['#include <cstdio>\n\nint count(int x) {\n    if (x == 0)\n        return 0;\n    int ret = 0;\n    for (; x % 2 == 0; x /= 2)\n        ++ ret;\n    return ret;\n}\n\nint get(int x) {\n    int ret = count(x);\n    if (ret > 0)\n        return 50 + ret;\n    else\n        return 51 - count(x + 1);\n}\n\ndouble dp[201][300][256];\n\nint add(int x) {\n    if (x > 50)\n        return 50;\n    else {\n        x = 51 - x;\n        return x + 50;\n    }\n}\n\nint mul(int x, int y) {\n    y /= 128;\n    if (y == 0) {\n        if (x <= 50)\n            return 51;\n        else\n            return x + 1;\n    } else {\n        if (x <= 50)\n            return x - 1;\n        else\n            return 50;\n    }\n}\n\nint main() {\n    int x, k, p;\n    scanf(""%d%d%d"", &x, &k, &p);\n    if (x < 256)\n        x += 1 << 20;\n    dp[0][get(x / 256)][x % 256] = 1;\n    for (int i = 0; i < k; ++ i)\n        for (int j = 0; j < 300; ++ j) {\n            for (int l = 0; l < 256; ++ l)\n                if (dp[i][j][l] > 0) {\n                    if (l >= 128)\n                        dp[i + 1][mul(j, l)][l * 2 - 256] += p / 100.0 * dp[i][j][l];\n                    else\n                        dp[i + 1][mul(j, l)][l * 2] += p / 100.0 * dp[i][j][l];\n                    if (l == 255)\n                        dp[i + 1][add(j)][0] += (100 - p) / 100.0 * dp[i][j][l];\n                    else\n                        dp[i + 1][j][l + 1] += (100 - p) / 100.0 * dp[i][j][l];\n                }\n        }\n    double ans = 0;\n    for (int j = 0; j <= 50; ++ j)\n        ans += dp[k][j][0] * 8;\n    for (int j = 51; j < 300; ++ j)\n        ans += dp[k][j][0] * (8 + j - 50);\n    for (int i = 1; i < 256; ++ i) {\n        int cnt = count(i);\n        for (int j = 0; j < 300; ++ j)\n            ans += dp[k][j][i] * cnt;\n    }\n    printf(""%.12f\\n"", ans);\n    return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2400,We will solve the task by calculating dynamic possibility of getting which last bits equals 9th bit equals number of consecutive bits following 9th bit and equal to after steps Good but why we left other bits It s clear that using operation we can change only first 0 bit with index Transitions is pretty obvious we add 1 or multiply by 2 it s recommended to see them in jury s solution Perhaps you should ask following question For example we have number in binary representation And at this moment we make According to all above we must go to condition but we can t do that because we don t have any information about in 10th position But as we can not change any bit with index we make transition to Jury s solution 6850523 Bonus Let us have other pseudocode As before you must find expected value of How effectively you can solve this problem Can you prove your solution Your corrections of my bad English are welcome thank you 
A Young BoyYou are given an array of n integers a 1 a 2 ldots a n In one operation you do the following Choose integer x For all i such that a i x do a i 0 assign 0 to a i Find the minimum number of operations required to sort the array in non decreasing order ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define int long long\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n\nint T,n,ans,i,j,k,a[N],c[N],pos[N],gg,tot; \nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tc[i]=0;pos[i]=0;\n\t\t}\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i],pos[a[i]]=max(i,pos[a[i]]);\n\t\t}\n\t\ta[0]=1e9;\n\t\tfor(i=n;~i;--i)if(a[i]<a[i-1]){gg=i-1;break;}\n\t\tif(gg==0){\n\t\t\tcout<<0<<""\\n"";\n\t\t}\n\t\telse{\n\t\t\ttot=0;\n\t\t\tfor(i=1;i<=n;++i){\n\t\t\t\tif(!c[a[i]])++tot,c[a[i]]=1,gg=max(gg,pos[a[i]]);\n\t\t\t\tif(i>=gg){cout<<tot<<""\\n"";break;}\n\t\t\t}\n\t\t}\n\t}\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1100,An array is sorted in non decreasing order if and only if there is no index such that This leads to a strategy while there is at least one such index apply one operation with Why is this optimal Since our operation can only decrease values and we must decrease so that is no longer true this leaves us no choice but to use the operation with You can simulate this strategy by maintaining a set of bad indices since if an index becomes bad after you apply an operation with it can never become bad again So in total there are at most operations with the set Complexity or depending on which set you use Note you can solve the problem in by noticing that if an index is bad we need to apply the operation for all unique non zero values in This is also quite a bit shorter to code 
There are n chefs numbered 1 2 ldots n that must prepare dishes for a king Chef i has skill i and initially has a dish of tastiness a i where a i leq i Each chef has a list of other chefs that he is allowed to copy from To stop chefs from learning bad habits the king makes sure that chef i can only copy from chefs of larger skill There are a sequence of days that pass during which the chefs can work on their dish During each day there are two stages during which a chef can change the tastiness of their dish At the beginning of each day each chef can to work or not work on their own dish thereby multiplying the tastiness of their dish of their skill a i i cdot a i or doing nothing After all chefs who wanted worked on their own dishes each start observing the other chefs In particular for each chef j on chef i s list chef i can to copy or not copy j s dish thereby adding the tastiness of the j s dish to i s dish a i a i a j or doing nothing It can be assumed that all copying occurs simultaneously Namely if chef i chooses to copy from chef j he will copy the tastiness of chef j s dish at the end of stage 1 All chefs work to maximize the tastiness of their dish in order to please the king Finally you are given q queries Each query is one of two types 1 k l r find the sum of tastiness a l a l 1 ldots a r after the k th day Because this value can be large find it modulo 10 9 7 2 i x the king adds x tastiness to the i th chef s dish before the 1 st day begins a i a i x Note that because the king wants to see tastier dishes he only adds positive tastiness x 0 Note that queries of type 1 are independent of each all other queries Specifically each query of type 1 is a and does not change the initial tastiness a i of any dish for future queries Note that queries of type 2 are cumulative and only change the initial tastiness a i of a dish See notes for an example of queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nconst int nmax=305;\nconst int kmax=1005;\nmint ps[nmax][kmax],is[nmax][kmax];\nvoid init(){\n\trng(i,1,nmax)rep(j,kmax){\n\t\tps[i][j]=mint(i).pow(j);\n\t\tis[i][j]=ps[i][j].inv();\n\t}\n}\n\n//XXII Opencup GP of Siberia 6\n//左c列をsweepしする\n//aの先頭rank行に要素が入っている感じ\n//掃き出しに使った列の番号が返る\nvi sweep(vvc<mint>&a,int c=-1){\n\tif(a.empty())return {};\n\tif(c==-1)c=a[0].size();\n\tint h=a.size(),w=a[0].size(),r=0;\n\tvi res;\n\trep(i,c){\n\t\tif(r==h)break;\n\t\trng(j,r,h)if(a[j][i].v){\n\t\t\tswap(a[r],a[j]);\n\t\t\tbreak;\n\t\t}\n\t\tif(a[r][i].v==0)continue;\n\t\trep(j,h)if(j!=r){\n\t\t//rng(j,r+1,h){ //for speed up (sweep に使った列に複数の non-zero があっても良い場合)\n\t\t\tmint z=-a[j][i]/a[r][i];\n\t\t\trng(k,i,w)\n\t\t\t\ta[j][k]+=a[r][k]*z;\n\t\t}\n\t\tres.pb(i);\n\t\tr++;\n\t}\n\treturn res;\n}\n\nvvc<mint> inverse(vvc<mint> a){\n\tint n=si(a);\n\trep(i,n){\n\t\tassert(si(a[i])==n);\n\t\ta[i].resize(2*n);\n\t\ta[i][n+i]=1;\n\t}\n\tauto tmp=sweep(a,n);\n\tassert(si(tmp)==n);\n\tvvc<mint> b(n,vc<mint>(n));\n\trep(i,n){\n\t\tmint w=a[i][i].inv();\n\t\trep(j,n)b[i][j]=a[i][n+j]*w;\n\t}\n\treturn b;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\t\n\tvi a=readvi(n);\n\t\n\tvvc<int> g(n);\n\trep(i,n){\n\t\tint c;cin>>c;\n\t\trep(_,c){\n\t\t\tint j;cin>>j;j--;\n\t\t\tg[j].pb(i);\n\t\t}\n\t}\n\t\n\tvvc<mint> p(n,vc<mint>(n));\n\trep(r,n){\n\t\tvc<mint> x(n);\n\t\tper(i,r+1){\n\t\t\tif(i==r){\n\t\t\t\tx[i]=1;\n\t\t\t}else{\n\t\t\t\tx[i]/=r-i;\n\t\t\t}\n\t\t\tfor(auto j:g[i])\n\t\t\t\tx[j]+=x[i]*(i+1);\t\n\t\t}\n\t\trep(i,n)p[i][r]=x[i];\n\t}\n\tauto pinv=inverse(p);\n\tvvc<mint> psum(n+1,vc<mint>(n));\n\trep(i,n)rep(j,n)psum[i+1][j]=psum[i][j]+p[i][j];\n\t\n\tvc<mint> buf(n);\n\t\n\tvvc<mint> bit(n,vc<mint>(n));\n\t\n\tauto add=[&](int i){\n\t\tfor(;i<n;i+=(i+1)&(-i-1))\n\t\t\trep(j,n)bit[i][j]+=buf[j];\n\t};\n\tauto getsum=[&](int i){\n\t\tchmin(i,n-1);\n\t\tfill(all(buf),0);\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\trep(j,n)buf[j]+=bit[i][j];\n\t};\n\t\n\tvi d(n,inf);\n\tauto work=[&](int i,mint w){\n\t\tif(d[i]<n){\n\t\t\trep(j,n){\n\t\t\t\tbuf[j]=w*pinv[j][i]*is[j+1][d[i]];\n\t\t\t}\n\t\t\tadd(d[i]);\n\t\t}\n\t};\n\tauto dfs=[&](auto self,int i,int v)->void{\n\t\tif(d[i]>v){\n\t\t\twork(i,-a[i]);\n\t\t\td[i]=v;\n\t\t\twork(i,a[i]);\n\t\t\tfor(auto j:g[i])\n\t\t\t\tself(self,j,v+1);\n\t\t}\n\t};\n\trep(i,n)if(a[i]>0){dfs(dfs,i,0);}\n\t\n\tint q;cin>>q;\n\trep(_,q){\n\t\tint t;cin>>t;\n\t\tif(t==1){\n\t\t\tint k,l,r;cin>>k>>l>>r;\n\t\t\tl--;\n\t\t\tgetsum(k);\n\t\t\tmint ans=0;\n\t\t\trep(i,n){\n\t\t\t\tans+=(psum[r][i]-psum[l][i])*ps[i+1][k]*buf[i];\n\t\t\t}\n\t\t\trng(i,l,r)if(d[i]>k)\n\t\t\t\tans+=a[i];\n\t\t\tprint(ans);\n\t\t}else if(t==2){\n\t\t\tint i,x;cin>>i>>x;\n\t\t\ti--;\n\t\t\twork(i,x);\n\t\t\ta[i]+=x;\n\t\t\tif(a[i]>0)dfs(dfs,i,0);\n\t\t}else assert(false);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinit();\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3500,All operations are conducted under a modulo it can be proven that each operation we conduct is valid within the modulo It s optimal to perform each operation if the number being added multiplied is strictly positive Specifically it s optimal to do and iif and respectively A chef s dish becomes positive after the th day where is the closest distance of chef from a positive element We call this value for the th chef Initial observations there are only pairs of where is not infinite never reaches positive value and thus never changes We refer to a vector of length with zeros and a single at the th index as If we assume that all chefs are currently positive then every chef takes every opportunity copy and the transition matrix is well defined and obvious We can represent the final array at time as This immediately offers a potential solution with very good constant Because is diagonal its inverse can with respect to a vector be calculated in So we can precalculate for all valid numbers in In fact this ends up being total operations if optimized We can then answer each query in by simply iterating over each chef and finding it s contribution to the answer Multiplying a matrix will be explained later With some special hacks it even be possible to get this to pass An arbitrary matrix has eigenvalues and their paired eigenvectors Ignoring how we find eigenvectors and eigenvalues the point of the two is that they are pairs such that Notably given a eigenvector and its respective eigenvalue we can calculate in In our case the transition matrix is a diagonal matrix A basic result in linear algebra is that the eigenvalues of a diagonal matrix is exactly the numbers on it s diagonal In our case this means that for Finding the eigenvectors is left as an exercise to the reader We henceforth denote the eigenvector paired with the th eigenvalue as Decompose into a linear combination of eigenvectors This can be precalculated in Let s denote another vector as this linear combination i e satisfies In fact this is almost all we need Let s return to to the second part can be trivially calculated We can calculate almost separately for each eigenvector In fact the contribution of the th eigenvector from the th chef after the th day is Let s store in a segment tree BIT on We can extract in total or for a single eigenvector then find the total contribution by multiplying by and using prefix sums on the eigenvector to extract the relevant range We can also process per update if stays constant trivially This is more than enough to pass but a further optimization is that the array only changes at most time whenever a new element becomes positive So we can simply rebuild our segment tree BIT in to reach complexity Final complexity It s also worth noting that several nonoptimal solutions can pass We attempted to cut off any solutions that explicitly use matrix multiplication However solutions with complexity such as can pass in 64 bit C if only additions are used The only way we found to do only additions was by making the same eigenvector reduction so we were not too worried It seems impossible to fail such solutions while maintaining a reasonable TL 
You are given an array a of n elements Your can perform the following operation no more than n times Select three indices x y z 1 leq x y z leq n and replace a x with a y a z After the operation a x need to be less than 10 18 Your goal is to make the resulting array If there are multiple solutions you can output any If it is impossible to achieve you should report it as well ,"['// Problem: C. Differential Sorting\n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nint a[1000003];\nint x[1000003],y[1000003],z[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tfor(int i=1; i<=n; ++i) a[i]=read();\n\t\tint v=-999,pos=n,ans=0;\n\t\tfor(int i=n-1; i>=1; --i)\n\t\t{\n\t\t\tif(v>=0)\n\t\t\t{\n\t\t\t\t++ans;\n\t\t\t\tx[ans]=i,y[ans]=i+1,z[ans]=pos;\n\t\t\t\ta[i]=a[i+1]-v;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a[i]>a[i+1])\n\t\t\t{\n\t\t\t\tans=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[i+1]>v)\n\t\t\t{\n\t\t\t\tpos=i+1,v=a[i+1];\n\t\t\t} \n\t\t}\n\t\tif(ans==-1)\n\t\t{\n\t\t\tputs(""-1"");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t\tfor(int i=1; i<=ans; ++i) printf(""%lld %lld %lld\\n"",x[i],y[i],z[i]);\n\t\t\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1200,First of all if then the answer is since we can t change the last two elements If there exists a simple solution perform the operation for each Otherwise the answer exists if and only if the initial array is sorted Proof Assume that and we can sort the array after operations Consider the last operation we performed Since all elements should be negative after the last operation so should hold before the last operation But after this so the array isn t sorted in the end By contradiction we have proved that we can t perform any operations as long as 
Arthur is giving a lesson to his famous 2 n knights Like any other students they re sitting at the desks in pairs but out of habit in a circle The knight 2 i 1 is sitting at the desk with the knight 2 i Each knight has which can be measured by an integer Let s denote the intelligence of the i th knight as a i Arthur wants the maximal difference in total intelligence over all pairs of desks to be as small as possible More formally he wants to minimize max limits 1 le i le n a 2 i 1 a 2 i min limits 1 le i le n a 2 i 1 a 2 i However the Code of Chivalry only allows swapping the opposite knights in the circle i e Arthur can simultaneously perform a i a i n a i n a i for any 1 le i le n Arthur can make any number of such swaps What is the best result he can achieve ,"[""// superyijin AK IOI// wangsiyuanZP AK IOI#pragma GCC optimize(2)#pragma GCC optimize(3)#include <bits/stdc++.h>#define int long longusing namespace std;int n, a[4010], b[8010], dp[4010][2][2];int f(int x){\tif (x <= n) return x + n;\telse return x - n;}int fff(int x){\tif (x & 1) return x + 1;\telse return x + n + 1;}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0), cout.tie(0);\tint t;\tcin >> t;\twhile (t--)\t{\t\tint m = 0;\t\tcin >> n;\t\tfor (int i = 1; i <= 2 * n; i++) cin >> a[i];\t\tfor (int i = 2; i <= 2 * n; i += 2)\t\t{\t\t\tb[++m] = a[i - 1] + a[i];\t\t\tb[++m] = a[f(i - 1)] + a[i];\t\t\tb[++m] = a[i - 1] + a[f(i)];\t\t\tb[++m] = a[f(i - 1)] + a[f(i)];\t\t}\t\tsort(b + 1, b + m + 1);\t\tint ans = 1e18;\t\tfor (int i = 1; i <= m; i++)\t\t{\t\t\tint x = b[i];\t\t\tfor (int j = 0; j <= n; j++) for (int i1 = 0; i1 <= 1; i1++) for (int i2 = 0; i2 <= 1; i2++) dp[j][i1][i2] = 1e18;\t\t\tif (n % 2 == 0)\t\t\t{\t\t\t\tdp[0][0][0] = 0;\t\t\t\tfor (int j = 2; j <= n; j += 2)\t\t\t\t{\t\t\t\t\tint x1 = a[j - 1] + a[j], x2 = a[f(j - 1)] + a[j], x3 = a[j - 1] + a[f(j)], x4 = a[f(j - 1)] + a[f(j)];\t\t\t\t\tif (min(x1, x4) >= x) dp[j][0][0] = min(dp[j][0][0], max(dp[j - 2][0][0], max(x1, x4)));\t\t\t\t\tif (min(x2, x3) >= x) dp[j][0][0] = min(dp[j][0][0], max(dp[j - 2][0][0], max(x2, x3)));\t\t\t\t}\t\t\t\tans = min(ans, dp[n][0][0] - x);\t\t\t}\t\t\telse\t\t\t{\t\t\t\tdp[0][0][0] = dp[0][1][1] = 0;\t\t\t\tfor (int j = 1; j <= n - 1; j++)\t\t\t\t{\t\t\t\t\tfor (int i1 = 0; i1 <= 1; i1++) for (int i2 = 0; i2 <= 1; i2++) for (int i3 = 0; i3 <= 1; i3++)\t\t\t\t\t{\t\t\t\t\t\tint k1 = fff(j) - 1, k2 = fff(j);\t\t\t\t\t\tif (i2) k1 = f(k1);\t\t\t\t\t\tif (i3) k2 = f(k2);\t\t\t\t\t\tif (a[k1] + a[k2] < x) continue;\t\t\t\t\t\tdp[j][i1][i3] = min(dp[j][i1][i3], max(dp[j - 1][i1][i2], a[k1] + a[k2]));\t\t\t\t\t}\t\t\t\t}\t\t\t\tfor (int i1 = 0; i1 <= 1; i1++) for (int i2 = 0; i2 <= 1; i2++)\t\t\t\t{\t\t\t\t\tint k1 = n, k2 = n + 1;\t\t\t\t\tif (i1) k2 = f(k2);\t\t\t\t\tif (i2) k1 = f(k1);\t\t\t\t\tif (a[k1] + a[k2] < x) continue;\t\t\t\t\tans = min(ans, max(dp[n - 1][i1][i2], a[k1] + a[k2]) - x);\t\t\t\t}\t\t\t}\t\t}\t\tcout << ans << '\\n';\t}\treturn 0;}// superyijin AK IOI// wangsiyuanZP AK IOI""]","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2700,Why independently Let a desk have knights with intelligence and the opposite one with Since the minimal total intelligence on these desks is greater iff the maximal total intelligence is less 
Alice has a cake and she is going to cut it She will perform the following operation n 1 times choose a piece of the cake initially the cake is all one piece with weight w ge 2 and cut it into two smaller pieces of weight lfloor frac w 2 rfloor and lceil frac w 2 rceil lfloor x rfloor and lceil x rceil denote floor and ceiling functions respectively After cutting the cake in n pieces she will line up these n pieces on a table in an arbitrary order Let a i be the weight of the i th piece in the line You are given the array a Determine whether there exists an initial weight and sequence of operations which results in a ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<long long> a(n);\n\tgenerate(all(a), nxt);\n\tlong long s = accumulate(all(a), 0ll);\n\tmultiset<long long> S(all(a));\n\tvector<long long> cur = {s};\n\tint rem = n - 1;\n\twhile (!cur.empty()) {\n\t\tauto x = cur.back();\n\t\tcur.pop_back();\n\t\tif (auto it = S.find(x); it != S.end()) {\n\t\t\tS.erase(it);\n\t\t} else if (rem == 0 || x == 1) {\n\t\t\tcout << ""No\\n"";\n\t\t\treturn;\n\t\t} else {\n\t\t\tcur.push_back(x / 2);\n\t\t\tcur.push_back((x + 1) / 2);\n\t\t\t--rem;\n\t\t}\n\t}\n\tcout << ""Yes\\n"";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 1, 0, 0, 0, 1, 0]",1400,SolutionFirst let s find the initial weight When a piece of cake is split the sum of weights is if is even if is odd Therefore the sum of weights is constant and the initial weight is the sum of the final weights Now let s start from a cake of weight split it into pieces of weight and try to make it equal to At any moment it s convenient to consider the largest because you can determine if you can split it or not More specifically if is not in you have to split it if for some you can only match with or with a such that because there doesn t exist any larger that s equivalent to removing and from respectively Notice that if at any moment the maximum element of is smaller than the maximum element of the answer is NO If can keep and in any data structure that supports inserting an integer asking for the maximum and removing the maximum e g multiset or priority queue the following algorithm works While either or is not empty if the maximum element of is smaller than the maximum element of print NO and break if the maximum element of is equal to the maximum element of remove it from both and if the maximum element of is larger than the maximum element of remove it from and split the piece of cake i e insert and into If or are both empty at the end the answer is YES Complexity 
There is a grid consisting of 2 rows and m columns The rows are numbered from 1 to 2 from top to bottom The columns are numbered from 1 to m from left to right The robot starts in a cell 1 1 In one second it can perform either of two actions move into a cell adjacent by a side up right down or left remain in the same cell The robot is not allowed to move outside the grid Initially all cells except for the cell 1 1 are locked Each cell i j contains a value a i j the moment that this cell gets unlocked The robot can only move into a cell i j if at least a i j seconds have passed before the move The robot should visit all cells cell 1 1 is considered entered at the start It can finish in any cell What is the fastest the robot can achieve that ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[2][N];\nint b[2][N];\nint c[2][N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(""%d"", &a[i][j]);\n\t\t\tif (i + j > 0) a[i][j]++;\n\t\t}\n\tb[0][n] = b[1][n] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tb[k][i] = max(max(a[k ^ 1][i], a[k][i] + 2 * (n - i) - 1), b[k][i + 1] + 1);\n\t\t}\n\t}\n\tint ans = (int)1e9 + (int)1e8;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k = i & 1;\n\t\tans = min(ans, max(cur, b[k][i]));\n\t\tcur = max(cur, a[k][i] + 2 * (n - i) - 1);\n\t\tcur = max(cur, a[k ^ 1][i] + 2 * (n - i) - 2);\n\t}\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","[1, 0, 1, 1, 1, 0, 0, 0, 0, 0]",2000,Let s first consider the possible paths across the grid that visit all cells You can immediately think of two of them The first one is go right to the wall turn into the other row and return Let s call it a hook The second one is go down go right go up go right and so on Let s call it a snake Turns out these two are basically the two extremes of all paths You can start with a snake and turn into a hook when you wish You can see that once you move right twice in a row you can only continue with a hook And as long as you didn t move right twice you are just doing a snake Let s fix some path across the grid What will its minimum time be Calculate it iteratively If you want to enter the next cell and it s still locked wait until it isn t So there are some seconds of waiting possibly zero before each cell However why not instead do the following Let s calculate the sum of waiting time required and wait for that amount of seconds before starting to move All cells will be visited at the same time as before or even later Thus they will surely be unlocked if they were in the original plan So the goal is to calculate the minimum amount of time required to wait in the start then add the movement time to it Once again the path is fixed Let the th cell of the path be If you start after waiting for seconds then you reach the th cell at time is indexed Thus the th cell should have If all cells satisfy this condition then the path can be done after waiting for seconds at the start Let s rewrite it into So the condition tells us that should be greater or equal than this value for all cells In other words should be greater or equal than the maximum of the values over all cells Study the formula Imagine we have some path with a known length and want to append a cell to it That s pretty simple Just update the maximum with the value with the corresponding cell and increase the length What if we wanted to prepend a cell to it Turns out it s not that hard as well Every cell in the path gets its value increased by From the formula you can see that this actually decreases the value of each cell by So the maximum decreases by as well The only thing left is to update the maximum with the value of the new first cell Well and increase the length again Finally let s learn how to choose the best path We can iterate over the length of the snake part The hook part is determined uniquely It s easy to maintain the maximum on the snake Just append the new cell to the path How to glue up the hook part to that Well actually realize that the formula allows us to glue up two paths into one Let path have length and maximum and path have length and maximum To make path start after path we just decrease its maximum by The resulting path has length and maximum Let s look closer into what the hooks look like They start in some column traverse all the way right then left up to the same column If the snake part took both cells in its last column then that s it Otherwise the hook has to take the final cell in the last column column If we manage to precalculate something for hooks that start in some column and end in column then we will be able to use that Appending the final cell is not a hard task since we know its index in the path Let be the waiting time required for a hook that starts in cell and ends in a cell as if the path started with the hook cell is the first one can be calculated from Prepend it with a cell and append it with a cell The only thing left is to find the best answer I found the most convenient to start with a snake of length only cell and progress it two steps at the time update the answer progress the snake to the other cell of the current column update the answer progress the snake into the next column Overall complexity per testcase 
William has two numbers a and b initially both equal to William mastered performing three different operations with them quickly Before performing each operation some positive integer k is picked which is then used to perform one of the following operations note that for each operation you can choose a positive integer k add number k to both a and b or add number k to a and subtract k from b or add number k to b and subtract k from a Note that after performing operations numbers a and b may become negative as well William wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nset<int> r[maxn];\nint ans = 0;\nbool chk(int a) {\n    if (r[a].empty()) return 1;\n    if (*r[a].rbegin() <= a) return 1;\n    return 0;\n}\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        int c, d;\n        scanf(""%d%d"", &c, &d);\n        int ans = -1;\n        if ((c % 2) != (d % 2)) ans = -1;\n        else if (c == d) ans = 1;\n        else ans = 2;\n        if (c == 0 && d == 0) ans = 0;\n        printf(""%d\\n"", ans);\n    }\n    return (0-0); //<3\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Note that after any of the operations the parity of the expression does not change so if the initial difference of the pair is odd then it is impossible to get this pair Now note that if we can get a pair then it can be obtained in no more than operations To do this consider three cases in this case answer is because initial pair is in this case answer is For this it is enough for us to use the operation of the first type with in this case answer is For this we can use the operations of the first type with After that it is enough for us to use either an operation of the second type with if or an operation of the third type with otherwise 
He loves this sequence very much and wants to play with it Let f 1 f 2 ldots f i ldots be an infinite sequence of positive integers Bob knows that for i k f i can be obtained by the following recursive equation f i left f i 1 b 1 cdot f i 2 b 2 cdot cdots cdot f i k b k right bmod p which in short isf i left prod j 1 k f i j b j right bmod p where p 998 244 353 a widely used prime b 1 b 2 ldots b k are known integer constants and x bmod y denotes the remainder of x divided by y Bob lost the values of f 1 f 2 ldots f k which is extremely troublesome these are the basis of the sequence Luckily Bob remembers the first k 1 elements of the sequence f 1 f 2 ldots f k 1 1 and the n th element f n m Please find any possible value of f k If no solution exists just tell Bob that it is impossible to recover his favorite sequence regardless of Bob s sadness ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110;\nconst int P = 998244353;\n\nint D[N][N], E[N][N], F[N][N];\n\nint k;\n\nvoid mul(int A[N][N], int B[N][N], int C[N][N]) {\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = 0; j < k; j++) D[i][j] = A[i][j], E[i][j] = B[i][j];\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tlong long val = 0;\n\t\t\tfor (int l = 0; l < k; l++) {\n\t\t\t\tval += 1LL * D[i][l] * E[l][j];\n\t\t\t\tval %= (P - 1);\n\t\t\t}\n\t\t\tC[i][j] = val;\n\t\t}\n\t}\n}\n\nvoid pow(int A[N][N], int n, int B[N][N]) {\n\tif (n == 0) {\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (i == j) B[i][j] = 1;\n\t\t\t\telse B[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint hn = n / 2;\n\tpow(A, hn, B);\n\tmul(B, B, B);\n\tif (n & 1) mul(B, A, B);\n}\n\nint modExp(int a, long long n, int p) {\n\tint ret = 1; ((a %= p) < 0) && (a += p);\n\tfor (; n; n >>= 1, a = (long long)a * a % p)\n\t\tif (n & 1) ret = (long long)ret * a % p;\n\treturn ret;\n}\n\nmap<int, int> M;\n\ntemplate<typename T>\nT mod_inv(T a, T mod) {\n\tif (__gcd(a, mod) != 1) return -1;\n\tT b = mod, s = 1, t = 0;\n\twhile (b) {\n\t\tT q = a / b;\n\t\tswap(a -= q * b, b);\n\t\tswap(s -= q * t, t);\n\t}\n\treturn s < 0 ? s + mod : s;\n}\n\nint L = 100000;\n\nint A[N][N], B[N][N];\nint b[N];\n\nint main() {\n\tcin >> k;\n\tfor (int i = 0; i < k; i++) cin >> b[i];\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0, j = 1; i < L; i++, j = 1LL * j * 3 % P) {\n\t\tM[j] = i;\n\t}\n\tint PJ = modExp(3, P-1-L, P);\n\tint pm;\n\tfor (int add = 0, cur = m; ; add += L, cur = 1LL * cur * PJ % P) {\n\t\tif (M.count(cur)) {\n\t\t\tpm = M[cur] + add;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(modExp(3, pm, P) == m);\n\tmemset(A, 0, sizeof A);\n\tfor (int i = 0; i < k; i++) A[0][i] = b[i];\n\tfor (int i = 1; i < k; i++) {\n\t\tA[i][i-1] = 1;\n\t}\n\tpow(A, n - k, B);\n\tint a = B[0][0];\n\tint d = __gcd(a, P - 1);\n\tif (pm % d != 0) return puts(""-1""), 0;\n\ta /= d, pm /= d;\n\tint p = (P - 1) / d;\n\tint x = 1LL * mod_inv(a, p) * pm % p;\n\tcout << modExp(3, x, P) << endl;\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2400,This problem seems weird first looking at it but we can rewrite it into a linear recursive equation The most important thing you should know is that is a primitive root of Briefly speaking the primitive is called a primitive root of if and only if the following two constraints are satisfied shown by Fermat s little theorem The two constraints shown above imply that The proof is simple If we have However it violates the second constraint since Thus the function defined by is a bijection We can recover from using and get from using Now we construct a new sequence where Then we can derive the equation that should satisfy which yields applying Fermat s little theorem Since is a primitive root of the equation satisfied if and only if the exponents are the same ThusYou may obtain the same equation by applying discrete logarithm on both sides of the equation of Note that the equation of is a normal linear recursive equation which can be solved using matrix exponentiation to get the relationship between and To obtain just apply the and the relationship between and can be represented by a congruence equation In this equation is the corresponding coefficient of obtained by matrix exponentiation Note that which yields Therefore we just ignore those items leaving alone This congruence equation can be solved by Extended Euclidean algorithm If no solution exists for this equation the original problem has no solution as well After obtaining can be recovered using Now I would add some details about those two algorithms matrix exponentiation and baby step giant step algorithm Suppose that we have a linear recursive equationwhere are known constants Then the following equation of matrices holds for some Let s call the matrix transition matrix whereandTherefore the equation shown above can be rewritten aswhich yieldsSo we can obtain in time since a single matrix multiplication takes time There are two problems that you may consider as your further research on linear recursive equations Solve this linear recursive equation in time or if you apply Fast Fourier Transform Solve the following linear recursive equation in time or faster where is a constant Consider the following congruence equation where is a prime for convenience and are known constants The intuition of the baby step giant step algorithm is meet in the middle Let s write for convenience In this representation We store in a map Then we try every possible from to Since which yields Therefore the result of can be found in the map in time So the overall time complexity is 
Students Vasya and Petya are studying at the BSU Byteland State University At one of the breaks they decided to order a pizza In this problem pizza is a circle of some radius The pizza was delivered already cut into pieces The th piece is a sector of angle equal to Vasya and Petya want to divide all pieces of pizza into two sectors in such way that the difference between angles of these sectors is minimal Sector angle is sum of angles of all pieces in it Pay attention that one of sectors can be empty ,"['#include""bits/stdc++.h""\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch==\'-\')f=-1;}while(ch<\'0\'||ch>\'9\');do x=x*10+ch-\'0\',ch=getchar();while(ch<=\'9\'&&ch>=\'0\');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,A[400];\n\nint main(){\n\tread(n);\n\tREP(i,1,n){read(A[i]);\n\t}\n\tint ans=360;\n\tREP(i,1,n)REP(j,i,n){\n\t\tint t=0;\n\t\tREP(k,i,j)t+=A[k];\n\t\tans=min(ans,abs(t-(360-t)));\n\t}\n\tiout(ans);\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1200,We can notice that if one of the sectors is continuous then all the remaining pieces also form a continuous sector If angle of the first sector is equal to then difference between angles of first and second sectors is So for each possible continuous sector we can count it s angle and update answer Time complexity or Solution 
Seniorious is made by linking special talismans in particular order After over 500 years the carillon is now in bad condition so Willem decides to examine it thoroughly Seniorious has pieces of talisman Willem puts them in a line the th of which is an integer In order to maintain it Willem needs to perform operations There are four types of operations For each such that assign to For each such that assign to Print the th smallest number in the index range i e the element at the th position if all the elements such that are taken and sorted into an array of non decreasing integers It s guaranteed that Print the sum of the th power of such that modulo i e ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#define _CRT_SECURE_NO_WARNINGS\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n\n#ifdef LOCAL\n# include <opencv2/core/core.hpp>\n# include <opencv2/highgui/highgui.hpp>\n# include <opencv2/imgproc/imgproc.hpp>\n#endif\n\nusing namespace std;\n\n// Let\'s define unordered map\n# ifdef __GNUC__\n# if __cplusplus > 199711L\n# include <unordered_set>\n# include <unordered_map>\n# else\n# include <tr1/unordered_map>\n# include <tr1/unordered_set>\nusing namespace tr1;\n# endif\n# else\n# include <unordered_map>\n# include <unordered_set>\n# endif\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define DBN1(a)           cerr<<#a<<""=""<<(a)<<""\\n""\n#define DBN2(a,b)         cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<""\\n""\n#define DBN3(a,b,c)       cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<""\\n""\n#define DBN4(a,b,c,d)     cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<""\\n""\n#define DBN5(a,b,c,d,e)   cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<""\\n""\n#define DBN6(a,b,c,d,e,f) cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<"", ""<<#f<<""=""<<(f)<<""\\n""\n#define DBN(...) macro_dispatcher(DBN, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,n) cerr<<#a<<""=[""; printarray(a,n); cerr<<""]\\n""\n#define DAR(a,n,s) cerr<<#a<<""[""<<s<<""-""<<n-1<<""]=[""; printarray(a,n,s); cerr<<""]\\n""\n\n#ifdef _MSC_VER\n#define PREFETCH(ptr, rw, level) ((void)0)\n#else\n#define PREFETCH(ptr, rw, level) __builtin_prefetch(ptr, rw, level)\n#endif\n\n#ifdef LOCAL\n#define CURTIME() cerr << clock() * 1.0 / CLOCKS_PER_SEC << endl\n#else\n#define CURTIME()\n#endif\n\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef int itn;\n\ntemplate<class T1, class T2, class T3>\nstruct triple{ T1 a; T2 b; T3 c; triple() : a(T1()), b(T2()), c(T3()) {}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };\ntemplate<class T1, class T2, class T3>\nbool operator<(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a<t2.a;else if(t1.b!=t2.b)return t1.b<t2.b;else return t1.c<t2.c;}\ntemplate<class T1, class T2, class T3>\nbool operator>(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a>t2.a;else if(t1.b!=t2.b)return t1.b>t2.b;else return t1.c>t2.c;}\n#define tri triple<int,int,int>\n#define trll triple<ll,ll,ll>\n\n#define FI(n) for(int i=0;i<(n);++i)\n#define FJ(n) for(int j=0;j<(n);++j)\n#define FK(n) for(int k=0;k<(n);++k)\n#define FL(n) for(int l=0;l<(n);++l)\n#define FQ(n) for(int q=0;q<(n);++q)\n#define FOR(i,a,b) for(int i = (a), __e = (int) (b); i < __e; ++i)\n#define all(a) std::begin(a), std::end(a)\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(1.0 * (x))\n#define pow(x, n) pow(1.0 * (x), n)\n\n#define COMPARE(obj) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b)\n#define COMPARE_BY(obj, field) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b) { return a.field < b.field; }\n\n#define checkbit(n, b) (((n) >> (b)) & 1)\n#define setbit(n, b) ((n) | (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define removebit(n, b) ((n) & ~(static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define flipbit(n, b) ((n) ^ (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\ninline int countBits(uint v){v=v-((v>>1)&0x55555555);v=(v&0x33333333)+((v>>2)&0x33333333);return((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24;}\ninline int countBits(ull v){uint t=v>>32;uint p=(v & ((1ULL << 32) - 1)); return countBits(t) + countBits(p); }\ninline int countBits(ll v){return countBits((ull)v); }\ninline int countBits(int v){return countBits((uint)v); }\nunsigned int reverseBits(uint x){ x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }\ntemplate<class T> inline int sign(T x){ return x > 0 ? 1 : x < 0 ? -1 : 0; }\ninline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }\nconstexpr ll power(ll x, int p) { return p == 0 ? 1 : (x * power(x, p - 1)); }\ntemplate<class T1, class T2, class T3> T1 inline clamp(T1 x, const T2& a, const T3& b) { if (x < a) return a; else if (x > b) return b; else return x; }\nunsigned long long rdtsc() { unsigned long long ret = 0;\n#ifdef __clang__\n    return __builtin_readcyclecounter();\n#endif\n#ifndef _MSC_VER\n    asm volatile(""rdtsc"" : ""=A"" (ret) : :);\n#endif\n    return ret; }\n// Fast IO ********************************************************************************************************\nconst int __BS = 4096;\nstatic char __bur[__BS + 16], *__er = __bur + __BS, *__ir = __er;\ntemplate<class T = int> T readInt() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && (*__ir < \'0\' || *__ir > \'9\') && *__ir != \'-\') ++__ir; c();\n    bool m = false; if (*__ir == \'-\') ++__ir, c(), m = true;\n    T r = 0; while (*__ir >= \'0\' && *__ir <= \'9\') r = r * 10 + *__ir - \'0\', ++__ir, c();\n    ++__ir; return m ? -r : r;\n}\nstatic char __buw[__BS + 20], *__iw = __buw, *__ew = __buw + __BS;\ntemplate<class T>\nvoid writeInt(T x, char endc = \'\\n\') {\n    if (x < 0) *__iw++ = \'-\', x = -x; if (x == 0) *__iw++ = \'0\';\n    char* s = __iw;\n    while (x) { T t = x / 10; char c = x - 10 * t + \'0\'; *__iw++ = c; x = t; }\n    char* f = __iw - 1; while (s < f) swap(*s, *f), ++s, --f;\n    if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw;\n    *__iw++ = endc;\n}\ntemplate<class T>\nvoid writeStr(const T& str) {\n    int i = 0; while (str[i]) { *__iw++ = str[i++]; if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw; }\n}\nstruct __FL__ { ~__FL__() { if (__iw != __buw) cout.write(__buw, __iw - __buw); } };\nstatic __FL__ __flushVar__;\n\n//STL output *****************************************************************************************************\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p);\nTT1 ostream& operator << (ostream& os, const vector<T>& v);\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, const multiset<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v);\nTT1T2T3 ostream& operator << (ostream& os, const map<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const multimap<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t);\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<""(""<<p.first<<"", ""<< p.second<<"")""; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << ""[""; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << "", ""; f = 0; os << x; } return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t){ return os << ""("" << t.a << "", "" << t.b << "", "" << t.c << "")""; }\nTT1T2 void printarray(const T1& a, T2 sz, T2 beg = 0){ for (T2 i = beg; i<sz; i++) cout << a[i] << "" ""; cout << endl; }\n\n//STL input *****************************************************************************************************\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t);\nTT1T2 inline istream& operator >> (istream& os, pair<T1, T2>& p) { return os >> p.first >> p.second; }\nTT1 inline istream& operator >> (istream& os, vector<T>& v) {\n    if (v.size()) for (T& t : v) os >> t; else {\n        string s; T obj; while (s.empty()) {getline(os, s); if (!os) return os;}\n        stringstream ss(s); while (ss >> obj) v.push_back(obj);\n    }\n    return os;\n}\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t) { return os >> t.a >> t.b >> t.c; }\n\n//Pair magic *****************************************************************************************************\n#define PT1T2 pair<T1, T2>\nTT1T2 inline PT1T2 operator+(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first + p2.first, p1.second + p2.second); }\nTT1T2 inline PT1T2& operator+=(PT1T2 &p1 , const PT1T2 &p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\nTT1T2 inline PT1T2 operator-(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first - p2.first, p1.second - p2.second); }\nTT1T2 inline PT1T2& operator-=(PT1T2 &p1 , const PT1T2 &p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\n\n#undef TT1\n#undef TT1T2\n#undef TT1T2T3\n\n#define FREIN(FILE) freopen(FILE, ""rt"", stdin)\n#define FREOUT(FILE) freopen(FILE, ""wt"", stdout)\n#ifdef LOCAL\n#define BEGIN_PROFILE(idx, name) int profileIdx = idx; profileName[profileIdx] = name; totalTime[profileIdx] -= rdtsc() / 1e3;\n#define END_PROFILE totalTime[profileIdx] += rdtsc() / 1e3; totalCount[profileIdx]++;\n#else\n#define BEGIN_PROFILE(idx, name)\n#define END_PROFILE\n#endif\n\ntemplate<class T> inline void normmod(T &x, T m) { x %= m; if (x < 0) x += m; }\ntemplate<class T1, class T2> inline T2 summodfast(T1 x, T1 y, T2 m) { T2 res = x + y; if (res >= m) res -= m; return res; }\ntemplate<class T1, class T2, class T3> inline void addmodfast(T1 &x, T2 y, T3 m) { x += y; if (x >= m) x -= m; }\ntemplate<class T1, class T2, class T3> inline void submodfast(T1 &x, T2 y, T3 m) { x -= y; if (x < 0) x += m; }\n#if INTPTR_MAX == INT32_MAX or !defined(__SIZEOF_INT128__)\ninline ll mulmod(ll x, ll n, ll m){ ll r = 0; normmod(x, m); normmod(n, m); while (n) { if (n & 1) r += x; x += x; if (r >= m) r -= m; if (x >= m) x -= m; n /= 2; } return r; }\n#else\nusing int128 = __int128;\ninline ll mulmod(ll x, ll n, ll m){ return __int128(x) * n % m; }\n#endif\ninline ll powmod(ll x, ll n, ll m){ ll r = 1; normmod(x, m); while (n){ if (n & 1)r = (r*x) % m; x = (x*x) % m; n /= 2; }return r; }\ninline ll powmulmod(ll x, ll n, ll m) { ll res = 1; normmod(x, m); while (n){ if (n & 1)res = mulmod(res, x, m); x = mulmod(x, x, m); n /= 2; } return res; }\ntemplate<class T> inline T gcd(T a, T b) { while (b) { a %= b; T t = a; a = b; b = t; } return a; }\ninline ll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntemplate<class T> inline T gcd(T a, T b, T c){ return gcd(gcd(a, b), c); }\nll gcdex(ll a, ll b, ll& x, ll& y) {\n    if (!a) { x = 0; y = 1; return b; }\n    ll y1; ll d = gcdex(b % a, a, y, y1); x = y1 - (b / a) * y;\n    return d;\n}\ntemplate<class T> bool isPrime(T x) { if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n    for (T i = 5; i * i <= x; i += 6) if (x % i == 0 || x % (i + 2) == 0) return 0; return 1; }\nbool millerRabin(long long n) {\n    if (n <= 1000) return isPrime(n);\n    long long s = n - 1; int t = 0; while (s % 2 == 0) s /= 2, ++t;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) { if (!(a %= n)) return true;\n        long long f = powmulmod(a, s, n); if (f == 1 || f == n - 1) continue;\n        for (int i = 1; i < t; ++i) if ((f = mulmod(f, f, n)) == n - 1) goto nextp;\n        return false; nextp:;\n    } return true;\n}\n\n// Useful constants\n\n//int some_primes[7] = {24443, 100271, 1000003, 1000333, 5000321, 98765431, 1000000123};\n#define T9          1000000000\n#define T18         1000000000000000000LL\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define mod         1000000007\n#define EPS         (double)1e-10\n#define PI          3.14159265358979323846264\n#define link        asaxlajrewqwe\n#define rank        wahayawehasdakw\n//*************************************************************************************\n\nint32_t solve();\nint32_t main(int argc, char** argv) {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef LOCAL\n        FREIN(""input.txt"");\n//        FREOUT(""out.txt"");\n#endif\n    return solve();\n}\nint ap[101010];\nint seed;\nint rnd() {\n    int res = seed;\n    seed = (seed * 7LL + 13) % mod;\n    return res;\n}\nstruct Node {\n    ll same;\n};\nNode tr[404040];\nvoid build(int cur, int l, int r) {\n    if (l == r) {\n        tr[cur].same = ap[l];\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        build(dcur, l, m);\n        build(dcur + 1, m + 1, r);\n    }\n}\nvoid push(int cur, int l, int r) {\n    if (l == r) {\n        return;\n    }\n    if (tr[cur].same) {\n        for (int to : {cur + cur, cur + cur + 1}) {\n            tr[to].same = tr[cur].same;\n        }\n        tr[cur].same = 0;\n    }\n}\nvoid assign(int cur, int l, int r, int x, int y, int val) {\n    if (x > r || y < l) return;\n    if (x <= l && r <= y) {\n        tr[cur].same = val;\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        assign(dcur, l, m, x, y, val);\n        assign(dcur + 1, m + 1, r ,x, y, val);\n    }\n}\nvoid add(int cur, int l, int r, int x, int y, int val) {\n    if (x > r || y < l) return;\n    if (x <= l && r <= y && tr[cur].same) {\n        tr[cur].same += val;\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        add(dcur, l, m, x, y, val);\n        add(dcur + 1, m + 1, r ,x, y, val);\n    }\n}\nll getAns(int cur, int l, int r, int x, int y, int t, int p) {\n    if (x > r || y < l) return 0;\n    if (x <= l && r <= y && tr[cur].same) {\n        return powmod(tr[cur].same % p, t, p) * (r - l + 1LL) % p;\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        return (getAns(dcur, l, m, x, y, t, p) + getAns(dcur + 1, m + 1, r, x, y, t, p)) % p;\n    }\n    \n}\nvector<pair<ll, int>> st;\nvoid go(int cur, int l, int r, int x, int y) {\n    if (x > r || y < l) return;\n    if (tr[cur].same) {\n        st.push_back({tr[cur].same, min(r, y) - max(l, x) + 1});\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        go(dcur, l, m, x, y);\n        go(dcur + 1, m + 1, r, x, y);\n    }\n}\n\n\nint solve() {\n    int n, m, v;\n    n = readInt();\n    m = readInt();\n    seed = readInt();\n    v = readInt();\n    FI(n) {\n        ap[i] = rnd() % v + 1;\n    }\n    build(1, 0, n - 1);\n    FI(m) {\n        int t = rnd() % 4 + 1;\n        int l = rnd() % n + 1;\n        int r = rnd() % n + 1;\n        if (l > r) {\n            swap(l, r);\n        }\n        int x, y = 0;\n        if (t == 3) {\n            x = rnd() % (r - l + 1) + 1;\n        } else {\n            x = rnd() % v + 1;\n        }\n        if (t == 4) {\n            y = rnd() % v + 1;\n        }\n        --l; --r;\n        if (t == 1) {\n            add(1, 0, n - 1, l, r, x);\n        } else if (t == 2) {\n            assign(1, 0, n - 1, l, r, x);\n        } else if (t == 3) {\n            st.clear();\n            go(1, 0, n - 1, l, r);\n            sort(all(st));\n            for (auto p : st) {\n                if (x <= p.second) {\n                    writeInt(p.first);\n                    break;\n                }\n                x -= p.second;\n            }\n        } else if (t == 4) {\n            auto res = getAns(1, 0, n - 1, l, r, x, y);\n            writeInt(res);\n        }\n    }\n    \n    return 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2600,This is an interesting algorithm which can easily deal with many data structure problems if the data is random I initially named it as Old Driver Tree Which is my codeforces ID But now I call it Chtholly Tree We can find that there is an operation that makes a range of number the same We can use an interval tree std set is enough to maintain every interval that consists of the same number And for operation we destory all the intervals in range and put in a new interval into the interval tree For operations we can brute forcely walk on the tree find every interval in range and do the required operation on it Proof of time complexity We suppose that we have a randomly selected range now and we randomly choose which operation it is suppose that there are intervals in this range 1 4 possibility we use time to erase nodes 2 4 possibility we use time to erase nothing 1 4 possibility we use time to erase nothing and add 2 new nodes into the tree So we are expected to use time to erase nodes By using interval tree to maintain the time complexity of this problem is If operation and are changed into output the sum of for every range it seems that the time complexity may change into but I do not know how to prove it Solution using map 
You are given two strings a and b consisting of lowercase Latin letters A template t is string consisting of lowercase Latin letters and asterisks character A template is called if the number of asterisks in it is less than or equal to the number of letters in it A string s is said to be matching a template t if you can replace each asterisk in t with a string of lowercase Latin letters possibly an empty string so that it becomes equal to s Find an template such that both a and b match it or report that such a template doesn t exist If there are multiple answers print any of them ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nint n,a[2000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring s,t;\n\t\tcin >> s >> t;\n\t\tif(s[0]==t[0])\n\t\t{\n\t\t\tcout << ""YES\\n"" << s[0] << ""*\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tif(s.back()==t.back())\n\t\t{\n\t\t\tcout << ""YES\\n"" << ""*"" << s.back() << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tint flag=0;\n\t\tfor(int i=1;i<s.size();i++)\n\t\t{\n\t\t\tfor(int j=1;j<t.size();j++)\n\t\t\t{\n\t\t\t\tif(s.substr(i-1,2)==t.substr(j-1,2))\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcout << ""YES\\n"" << ""*"" << s.substr(i-1,2) << ""*\\n"";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tif(!flag) cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1000,What s the reason behind authors specifically asking for templates that have less or equal asterisks than letters Well without that the problem would be kind of trivial A template is matched by every string so it would always work Hmm let s try to make something similar to that template then We basically have to find some part of that occurs in both strings that we can use letters on to get some freedom to use asterisks There are some easy cases If the first letters of both strings are the same then the template can be that letter followed by an asterisk There s a symmetrical case for the last letter By studying the examples you can also notice the final case a common substring of both strings of length at least two surrounded by two asterisks Moreover since we only use two asterisks we can find a substring of length exactly two which always exists if a longer common substring exists Turns out that s it If a template exists one of these three kinds also exists This is not that hard to show If the first two kinds don t work then you have to use asterisks on both sides of the template In order for the template with asterisks on both sides to work there have to be adjacent letters in it at least once otherwise it s like and there are more asterisks than letters And since at least one such substring exists we can just remove everything other than this substring and the asterisks on the sides Overall complexity per testcase 
Paprika loves permutations She has an array a 1 a 2 dots a n She wants to make the array a of integers 1 to n In order to achieve this goal she can perform operations on the array In each operation she can choose two integers i 1 le i le n and x x 0 then perform a i a i bmod x that is replace a i by the remainder of a i divided by x In different operations the chosen i and x Determine the minimum number of operations needed to make the array a permutation of integers 1 to n If it is impossible output 1 A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\t//b < a / 2\n\t\tint n;\n\t\tcin >> n;\n\t\tset<int> s;\n\t\tfor (int i = 1; i <= n; i += 1) s.insert(i);\n\t\tvector<int> v;\n\t\tfor (int i = 1, a; i <= n; i += 1) {\n\t\t\tcin >> a;\n\t\t\tif (s.contains(a)) s.erase(a);\n\t\t\telse v.push_back(a);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ok = 1;\n\t\tfor (int i = 0; int x : s)\n\t\t\tif (x * 2 >= v[i ++]) ok = 0;\n\t\tif (ok) cout << v.size() << ""\\n"";\n\t\telse cout << ""-1\\n"";\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 1, 1, 0]",1300,SolutionKey observation if and if Notice that the bigger the the bigger the range of values that can be obtained after one operation So intuitively we want to assign smaller to smaller numbers in the resulting permutation However if satisfies we can just leave it there and use it in the resulting permutation if multiple satisfy and have the same value just choose one Let s suppose in the optimal solution we change to and change to for some are values not indices Then changing to i e doing nothing and changing to uses less operation And if it is possible to change to then it must be possible to change to However if it is not possible to change to it might still be possible to change to Therefore the solution is as follows Sort the array For each element in the sorted array If and it is the first occurrence of element with value leave it there Else let the current least unassigned value in the resulting permutation be if we can assign the current element to value and add the number of operations by Else output directly The solution works in 
Your friend Jeff Zebos has been trying to run his new online company but it s not going very well He s not getting a lot of sales on his website which he decided to call His big problem you think is that he s not ranking high enough on the search engines If only he could rename his products to have better names than his competitors then he ll be at the top of the search results and will be a millionaire After doing some research you find out that search engines only sort their results lexicographically If your friend could rename his products to lexicographically smaller strings than his competitor s then he ll be at the top of the rankings To make your strategy less obvious to his competitors you decide to swap no more than two letters of the product names Please help Jeff to find improved names for his products that are lexicographically smaller than his competitor s Given the string s representing Jeff s product name and the string c representing his competitor s product name find a way to swap of characters in s that is find two distinct indices i and j and swap s i and s j such that the resulting new name becomes strictly lexicographically smaller than c or determine that it is impossible String a is than string b if and only if one of the following holds a is a of b that is a is a of b such that a neq b There exists an integer 1 le i le min a b such that a i b i and a j b j for 1 le j i ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    for (int tt = 0; tt < t; tt++) {\n        string s, c;\n        cin >> s >> c;\n        if (s < c) {\n            cout << s << ""\\n"";\n            continue;\n        }\n        string t = s;\n        sort(t.begin(), t.end());\n        int a = 0;\n        for (int i = 0; i < (int) s.size(); i++) {\n            if (s[i] > t[i]) {\n                for (int j = i + 1; j < (int) s.size(); j++) {\n                    swap(s[i], s[j]);\n                    if (s < c) {\n                        cout << s << ""\\n"";\n                        a = 1;\n                        i = s.size();\n                        break;\n                    }\n                    swap(s[i], s[j]);\n                }\n            }\n        }\n        if (a == 0) {\n            cout << ""---\\n"";\n        }\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600,The problem becomes a bit easier if we try to answer a different question We then simply compare this string with This works because if the string we can form is not smaller than then clearly no other string we can form will be smaller than To find the lexicographically smallest string we can form we can be greedy We sort and find the first letter that isn t in its correct sorted position In other words find the first position where and doesn t match We then find the letter that should be in that position and put it in its correct position If there are multiple choices it is better to take the one that occurs last since it makes the resulting string smallest A special case is when is already sorted In this case we can t make any smaller so we should not swap at all The solution runs in but solutions running in are also accepted There are other different solutions that run in This can be improved to by replacing the sorting step with simpler operations since we don t actually need the full sorted version of 
You are given an array of integers a 1 a 2 ldots a n of length n and an integer k Two players are playing a game The first player chooses an index 1 le i le n Then the second player chooses a different index 1 le j le n i neq j The first player wins if a i a j is not divisible by k Otherwise the second player wins We play as the first player Determine whether it is possible to win and if so which index i should be chosen The absolute value of a number x is denoted by x and is equal to x if x ge 0 and x otherwise ,"['#include <bits/stdc++.h>using namespace std;\xa0using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>;\xa0constexpr int MOD = 1e9 + 7;constexpr int INF = 1e9;constexpr ll LINF = 1e18;constexpr ld EPS = 1e-9;\xa0#define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define pb push_back#define eb emplace_back#define fi first#define se second#define sz(x) ((int)(x).size())#define dbg(x) cerr << #x << "" = "" << (x) << \'\\n\'\xa0void solve() {    int n, k;    cin >> n >> k;    vi a(n);    for(auto &x: a) cin >> x;    vi cnt(k, 0);    for(auto x: a) cnt[x % k]++;    int res = -1;    for(int i=0; i<n; ++i){        if(cnt[a[i] % k] == 1){            res = i+1;            break;        }    }    if(res != -1){        cout << ""YES\\n"" << res << ""\\n"";    }    else{        cout << ""NO\\n"";    }}\xa0int main() {    fast_io();    int t = 1;    cin >> t;    while (t--) solve();    return 0;}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,is divisible by if and only if Let s split all numbers into groups according to the value The second player wins if he chooses a number from the same group This means that the first player must choose the number that is the only one in its group 
Recall that the sequence b is a a subsequence of the sequence a if b can be derived from a by removing zero or more elements without changing the order of the remaining elements For example if a 1 2 1 3 1 2 1 then possible subsequences are 1 1 1 1 3 and 1 2 1 3 1 2 1 but not 3 2 3 and 1 1 1 1 2 You are given a sequence a consisting of n positive and negative elements there is no zeros in the sequence Your task is to choose length subsequence of the given sequence i e the sign of each next element is the opposite from the sign of the current element like positive negative positive and so on or negative positive negative and so on Among all such subsequences you have to choose one which has the of elements In other words if the maximum length of subsequence is k then your task is to find the of elements of some subsequence of length k You have to answer t independent test cases ,"['#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<\'0\') || (ch>\'9\')) {if (ch==\'-\') f=-1;ch=getchar();}\n    while ((ch>=\'0\') && (ch<=\'9\')) {x=x*10+(ch-\'0\');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nint n,a[200100];\n\nint calc(int x)\n{\n\tif (x>0) return 1;else return -1;\n}\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();\n\t\trep(i,1,n) a[i]=read();\n\t\tll ans=0,sum=0;\n\t\tint pos=1,mx=a[1];\n\t\trep(i,2,n)\n\t\t{\n\t\t\tif (calc(a[i])==calc(a[pos]))\n\t\t\t{\n\t\t\t\tmx=max(mx,a[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//cout << ""range "" << pos << "" "" << i-1 << endl;\n\t\t\t\tans+=mx;pos=i;mx=a[i];\n\t\t\t}\n\t\t}\n\t\tans+=mx;\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1200,Firstly let s extract maximum by inclusion segments of the array that consists of the numbers with the same sign For example if the array is then these segments are and We can do it with any two pointers like algorithm The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block And as we want to maximize the sum we need to take the maximum element from each block Time complexity 
Jeevan has two arrays a and b of size n He is fond of performing weird operations on arrays This time he comes up with two types of operations Choose any i 1 le i le n and increment a j by 1 for every j which is a multiple of i and 1 le j le n Choose any i 1 le i le n and decrement a j by 1 for every j which is a multiple of i and 1 le j le n He wants to convert array a into an array b using the minimum total number of operations However Jeevan seems to have forgotten the value of b 1 So he makes some guesses He will ask you q questions corresponding to his q guesses the i th of which is of the form If b 1 x i what is the minimum number of operations required to convert a to b Help him by answering each question ,"['// Problem: E. Array Equalizer\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nint a[1000003],b[1000003];\nint f[1000003];\nvector<int> d[200003];\nint prim[1000003];\nint mu[1000003],cnt=0;\nbool vis[1000003];\nvoid init()\n{\n    mu[1]=1;\n    for(int i=2;i<=200000;i++)\n    {\n        if(!vis[i]) prim[++cnt]=i,mu[i]=-1;\n        for(int j=1; j<=cnt&&prim[j]*i<=200000; j++)\n        {\n            vis[prim[j]*i]=1;\n            if(i%prim[j]==0) break; \n            else mu[i*prim[j]]=-mu[i];\n        }\n    }\n    for(int i=1; i<=200000; ++i)\n    \tfor(int j=1; i*j<=200000; ++j)\n    \t\td[i*j].push_back(i);\n}\nint A[1000003],sa;\nint pa[1000003];\nint B[1000003],sb;\nint pb[1000003];\nsigned main()\n{\n\tinit();\n\tint n=read();\n\tfor(int i=1; i<=n; ++i) a[i]=read();\n\tfor(int i=1; i<=n; ++i) b[i]=read();\n\tfor(int i=2; i<=n; ++i) f[i]=a[i]-b[i];\n\tint ans=0;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tint t=0;\n\t\tfor(int j:d[i]) t+=f[j]*mu[i/j];\n\t\tif(mu[i]==1) A[++sa]=t;\n\t\telse if(mu[i]==-1) B[++sb]=t;\n\t\telse ans+=abs(t);\n\t}\n\tsort(A+1,A+sa+1);sort(B+1,B+sb+1);\n\tfor(int i=1; i<=sa; ++i) pa[i]=pa[i-1]+A[i];\n\tfor(int i=1; i<=sb; ++i) pb[i]=pb[i-1]+B[i];\n\tfor(int T=read();T--;)\n\t{\n\t\tint x=a[1]-read();\n\t\tint posa=lower_bound(A+1,A+sa+1,-x)-A-1;\n\t\tint posb=lower_bound(B+1,B+sb+1,x)-B-1;\n\t\tint ans1=-posa*x-pa[posa];\n\t\tint ans2=(pa[sa]-pa[posa])+(sa-posa)*x;\n\t\tint ans3=-posb*(-x)-pb[posb];\n\t\tint ans4=(pb[sb]-pb[posb])+(sb-posb)*(-x);\n\t\tprintf(""%lld\\n"",ans+ans1+ans2+ans3+ans4);\n\t}\n\treturn 0;\n}']","[1, 1, 1, 0, 0, 0, 0, 1, 1, 0]",2400,Firstly let s observe that only the differences matter and not the individual values of and So let us create two more arrays and where initially and for all The problem reduces to making equal to Let s have a few definitions for ease of explanation We define operation add to as perform the increment operation at and multiples of times if otherwise perform the decrement operation at and multiples of times In both cases the number of operations performed is Let s first solve the problem for only one value of We notice that problem can be solved using a simple greedy approach We iterate over the elements from left to right Let the index of the current element be Initial arrays 123456add At Applying the operation at alone can change the value of Thereby we add at to make The remaining array also gets modified accordingly Resulting arrays 123456add At Applying the operation at and only can change the value of But since we have already made we will only apply operations at We add at Resulting arrays 123456add At Applying the operation at and only can change the value of But since we have already made we will only apply operations at We add at Resulting arrays 123456add At Applying the operation at and only can change the value of But since we have already made and B 2 we will only apply operations at We add at Resulting arrays 123456add And so on So we iterate from left to right and at every index we add current value of at The final answer will be summation of absolute value of these values i e the values written in the add row However in the original problem we have to solve the problem for multiple values of So let us assume the value of to be equal to some variable say Let us try to use the same approach with the variable Initial arrays 123456add At We add at Resulting arrays 123456add At We add at Resulting arrays 123456add At We add at Resulting arrays 123456add At We add at Resulting arrays 123456add And so on Every cell in the add row here will be of the form The final answer will be the summation of absolute values of these values written in the add row Also we know Note that the above equalities hold only when So if is negative in any term then we can multiply the entire term with to make it positive since Now we can store the values of for each index in sorted order And for each query we can find out using binary search which of the absolute value terms will have a positive sign and which of those will have a negative sign So we can finally calculate the answer using prefix and suffix sums Bonus It turns out that the value of coefficient of in the add value for the th index is where is the mobious function So 
You have array that contains all integers from to twice You can arbitrary permute any numbers in Let number be in positions in the permuted array Let s define the value the distance between the positions of the number Permute the numbers in array to minimize the value of the sum ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n\nvoid print_array(vector<int>&arr){\n    REP(i,SZ(arr)){\n        if(i)printf("" "");\n        printf(""%d"",arr[i]);\n    }\n    puts("""");\n}\nint main(){\n    VI an;\n    DRI(n);\n    for(int i=n%2==0?1:2;i<n;i+=2){\n        an.PB(i);\n    }\n    for(int i=n-1;i>0;i-=2){\n        an.PB(i);\n    }\n    an.PB(n);\n    for(int i=n%2==0?2:1;i<n;i+=2){\n        an.PB(i);\n    }\n    an.PB(n);\n    for(int i=n-2;i>0;i-=2){\n        an.PB(i);\n    }\n    print_array(an);\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1900,This problem was suggested by Aleksa Plavsic allllekssssa Let s build the answer with the sum equal to zero Let be even Let s place odd numbers in the first half of the array the number in the positions and the number in the positions and and so on Similarly let s place even numbers in the second half the number in the position and the number in the positions and and so on We can place the number in the leftover positions We can build the answer for odd in a similar way Easy to see that our construction will give zero sum C solution Complexity 
Petya has a simple graph that is a graph without loops or multiple edges consisting of n vertices and m edges The weight of the i th vertex is a i The weight of the i th edge is w i A subgraph of a graph is some set of the graph vertices and some set of the graph edges The set of edges must meet the condition both ends of each edge from the set must belong to the chosen set of vertices The weight of a subgraph is the sum of the weights of its edges minus the sum of the weights of its vertices You need to find the maximum weight of subgraph of given graph ,"['/*\nI\'m just a man and I am what I am, yeah\nNobody will ever change my ways\nI don\'t need money and I don\'t need no lies, yeah\nI only need to live for today\nBut I\'d like to talk things over with you\nI want to hear the things you say, today\nAlthough you won\'t change me anyway, oh no way\n\nI wish you\'d come and see me, I\'d like to hold you\nI want to set my mind all free\nYou understand me woman, you give me time, yeah\nBut I don\'t need no sympathy\nStill I wonder what it\'s like to be loved\nInstead of hiding in myself\nNobody will change me anyway, no no way\n\nNobody\'s gonna change my world\nThat\'s something too unreal\nNobody will change the way I feel\n\nSo listen to me now, hear what I say, yeah\nPlease give me time and maybe love\nIf there\'s a God up there, well I hope he helps me\nI need him now to set me free\n\'Cause it may be that it\'s over for me\nIf you don\'t hear the things that I say, today\nNobody will change me anyway, no no way\n\nNobody\'s gonna change my world\nThat\'s something too unreal\nNobody will change the way I feel\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nlong long n,m,s,t;\n\nstruct edge {\n\tint a, b;\n\tlong long cap, flow;\n};\n\nconst int MAXN = N;\n\nlong long d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n\nvoid add_edge (int a, int b, long long cap) {\n\tedge e1 = { a, b, cap, 0 };\n\tedge e2 = { b, a, 0, 0 };\n\tg[a].push_back ((int) e.size());\n\te.push_back (e1);\n\tg[b].push_back ((int) e.size());\n\te.push_back (e2);\n}\n\nbool bfs() {\n\tint qh=0, qt=0;\n\tq[qt++] = s;\n\tmemset (d, -1, n * sizeof d[0]);\n\td[s] = 0;\n\twhile (qh < qt && d[t] == -1) {\n\t\tint v = q[qh++];\n\t\tfor (size_t i=0; i<g[v].size(); ++i) {\n\t\t\tint id = g[v][i],\n\t\t\t\tto = e[id].b;\n\t\t\tif (d[to] == -1 && e[id].flow < e[id].cap) {\n\t\t\t\tq[qt++] = to;\n\t\t\t\td[to] = d[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t] != -1;\n}\n\nlong long dfs (int v, long long flow) {\n\tif (!flow)  return 0;\n\tif (v == t)  return flow;\n\tfor (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n\t\tint id = g[v][ptr[v]],\n\t\t\tto = e[id].b;\n\t\tif (d[to] != d[v] + 1)  continue;\n\t\tint pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n\t\tif (pushed) {\n\t\t\te[id].flow += pushed;\n\t\t\te[id^1].flow -= pushed;\n\t\t\treturn pushed;\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long dinic() {\n\tlong long flow = 0;\n\tfor (;;) {\n\t\tif (!bfs())  break;\n\t\tfor (int i=0;i<=n;i++)\n\t\t\tptr[i]=0;\n\t\twhile (true){\n\t\t\tlong long pushed = dfs (s, 1000000000000000ll);\n\t\t\tif (pushed==0)\n\t\t\t\tbreak;\n\t\t\tflow += pushed;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>m;\n\ts=0;\n\tt=n+m+1;\n\tfor (int i=1;i<=n;i++){\n\t\tint val;\n\t\tcin>>val;\n\t\tadd_edge(s,i,val);\n\t}\n\n\tlong long ttl=0;\n\n\tfor (int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tint val;\n\t\tcin>>a>>b>>val;\n\t\tadd_edge(a,i+n,1e15);\n\t\tadd_edge(b,i+n,1e15);\n\t\tadd_edge(i+n,t,val);\n\t\tttl+=val;\n\t}\n\n\t// some magic shit happens.\n\tn=t+1;\n\tlong long here=dinic();\n\n\tcout<<ttl-here<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2400,This problem can be reduced to one of well known flow problems Projects and Instruments In this problem we have a set of projects we can do each with its cost and a set of instruments each also having some cost Each project depends on some instruments and each instrument can be used any number of times We have to choose a subset of projects and a subset of instruments so that if a project is chosen all instruments that this project depends on are also chosen and we have to maximize the difference between the sum of costs of chosen projects and the sum of costs of chosen instruments The problem about projects and instruments can be solved with the following flow network for each project create a vertex and add a directed edge from the source to this vertex with capacity equal to the cost of this project for each instrument create a vertex and add a directed edge from this vertex to the sink with capacity equal to the cost of this instrument for each project create edges with infinite capacity from the vertex denoting this project to all vertices denoting the required instruments for this project Let s analyze an cut between the source and the sink in this vertex and construct some answer based on this cut as follows if a project vertex belongs to then we take this project if an instrument vertex belongs to then we take this instrument all other projects and instruments are discarded If an edge between some project and some instrument is cut then it means that the answer is incorrect we try to take a project requiring some instrument we don t take and the cut value is infinite Otherwise the value of the cut is equal to the total cost of taken instruments and discarded projects and we need to minimize it So the minimum cut in this network denotes the best answer Reducing the given problem to this problem is easy edges of the given graph are projects vertices of the given graph are instruments Regarding implementation any flow algorithm using capacity scaling should be sufficient It seems that Dinic also passes even though its complexity is 
You ve got string consisting of small English letters Some of the English letters are the rest are A substring of string where is the length of string is string The substring is if among the letters there are ones look at the sample s explanation to understand it more clear Your task is to find the number of distinct good substrings of the given string Two substrings and are considered distinct if their content is different i e ,"['#include<cstdio>\n#include<cstring>\nint ans,n,k;\nchar    a[50],C[2000];\nint T[1200000][26];\nint main(){\n    gets(C);n=strlen(C);\n    for(int i=0;i<26;i++){\n        char    c;\n        for(c=getchar();c!=\'0\'&&c!=\'1\';c=getchar());\n        a[i]=c;\n    }\n    scanf(""%d"",&k);\n    for(int i=0;i<n;i++){\n        int x=0,cnt=0;\n        for(int j=i;j<n;j++){\n            if(a[C[j]-\'a\']==\'0\')cnt++;\n            if(cnt>k)break;\n            if(!T[x][C[j]-\'a\'])T[x][C[j]-\'a\']=++ans;\n            x=T[x][C[j]-\'a\'];\n        }\n    }\n    printf(""%d"",ans);\n    getchar(),getchar();\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1800,At first build a trie containing all suffixes of given string this structure is also called explicit suffix tree Let s iterate over all substrings in order of indexes increasing i e first then Note that moving from a substring to the next one is just adding a single character to the end So we can easily maintain the number of bad characters and also the current node in the trie If the number of bad characters doesn t exceed then the substring is good And we need to mark the corresponding node of trie if we never did this before The answer will be the number of marked nodes in the trie There is also an easier solution where instead of trie we use Rabin Karp rolling hash to count substrings that differ by content Just sort the hashes of all good substrings and find the number of unique hashes equal hashes will be on adjacent positions after sort But these hashes are unreliable in general so it s always better to use precise algorithm 
Inzane finally found Zane with a lot of money to spare so they together decided to establish a country of their own Ruling a country is not an easy job Thieves and terrorists are always ready to ruin the country s peace To fight back Zane and Inzane have enacted a very effective law from each city it must be possible to reach a police station by traveling at most kilometers along the roads There are cities in the country numbered from to connected only by exactly roads All roads are kilometer long It is initially possible to travel from a city to any other city using these roads The country also has police stations located in some cities In particular the city s structure satisfies the requirement enforced by the previously mentioned law Also note that there can be multiple police stations in one city However Zane feels like having as many as roads is unnecessary The country is having financial issues so it wants to minimize the road maintenance cost by shutting down as many roads as possible Help Zane find the maximum number of roads that can be shut down without breaking the law Also help him determine such roads ,"['#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > a[300020];\nqueue<int> q;\nbool v[300020];\nbool f[300020];\nint n, k, d, x, y;\nint main() {\n\tscanf(""%d%d%d"", &n, &k, &d);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tq.push(x);\n\t\tv[x] = true;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(""%d%d"", &x, &y);\n\t\ta[x].push_back(make_pair(y, i));\n\t\ta[y].push_back(make_pair(x, i));\n\t}\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < a[u].size(); i++) {\n\t\t\tif (!v[a[u][i].first]) {\n\t\t\t\tf[a[u][i].second] = true;\n\t\t\t\tq.push(a[u][i].first);\n\t\t\t\tv[a[u][i].first] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint nitamashabiba = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (!f[i]) {\n\t\t\tnitamashabiba++;\n\t\t}\n\t}\n\tprintf(""%d\\n"", nitamashabiba);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (!f[i]) {\n\t\t\tprintf(""%d "", i);\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 1]",2100,A greedy solution shutting down either every d roads or when a police station is encountered although seems pretty nice turns out to be incorrect Consider performing a breadth first search BFS with cities with a police station as starting vertices and shutting down the road when it leads to a visited vertex city This will leave every bad city connected either directly or indirectly with one of its nearest police stations and thus will not break the law With this method you can see that exactly roads will be shut down where is the number of cities that have a police station in them Suppose this is not optimal and roads can be shut down The tree will break into components while there are only cities with a police station so this is a contradiction since there will be at least one component without any police station Hence shutting down roads is optimal 
You are given a tree with n vertices labeled 1 2 ldots n The length of a simple path in the tree is the number of vertices in it You are to select a set of simple paths of length at least 2 each but you cannot simultaneously select two distinct paths contained one in another Find the largest possible size of such a set Formally a set S of vertices is called a if it contains and coincides with the set of vertices of a simple path in the tree A collection of distinct routes is called a A route S in a timetable T is called if there is a different route S in T such that S subset S A timetable is called if it contains no redundant routes Find the largest possible number of routes in an efficient timetable ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nconst int nax=3007;\nconst int vax=nax*nax/2;\n\nint n;\n\nvi graf[nax];\n\nint k;\nint num[nax][nax];\n\nint ojf[vax];\nint roz[vax];\n\nint wstro[nax][nax];\n\nint korz;\n\nvi drz[vax];\n\nint fin(int v)\n{\n\tif (ojf[v]!=v)\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nvoid dfs1(int v, int c)\n{\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==wstro[c][v])\n\t\t\tcontinue;\n\t\twstro[c][i]=v;\n\t\tdfs1(i, c);\n\t}\n}\n\nint dfs2(int v)\n{\n\tint ret=0;\n\tfor (int i : drz[v])\n\t\tret+=dfs2(i);\n\treturn max(ret, roz[v]);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tk++;\n\t\t\tnum[i][j]=k;\n\t\t\tnum[j][i]=k;\n\t\t\tojf[k]=k;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tdfs1(i, i);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (wstro[i][j]!=i)\n\t\t\t\tuni(num[i][wstro[i][j]], num[j][wstro[j][i]]);\n\tfor (int i=1; i<=k; i++)\n\t\troz[fin(i)]++;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (wstro[i][j]==i)\n\t\t\t\tkorz=fin(num[i][j]);\n\tvector<pii> kra;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tif (wstro[i][j]==i)\n\t\t\t\tcontinue;\n\t\t\tint x=fin(num[i][j]);\n\t\t\tint y=fin(num[i][wstro[i][j]]);\n\t\t\tkra.push_back({y, x});\n\t\t}\n\t}\n\tsort(kra.begin(), kra.end());\n\tkra.resize(unique(kra.begin(), kra.end())-kra.begin());\n\tfor (pii i : kra)\n\t\tdrz[i.first].push_back(i.second);\n\tprintf(""%d\\n"", dfs2(korz));\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0]",3500,Let s call two paths adjacent if one can be obtained from the other by adding an edge to one end and removing an edge from the other end There exists an optimal solution in which each pair of adjacent paths is either simultaneously chosen or simultaneously not chosen Consider an optimal solution that maximizes the total length of paths in it Let s assume that in such a solution we have taken some path but its adjacent path is not included here assume and Why can t we add If contains a shorter path it must end at since all other paths are also contained in In that case we can extend the shorter path to which contradicts the maximization of the sum of lengths If is contained within a longer path it must start at since all other paths are also contained in In this case we can extend We will refer to classes of adjacent paths as simply classes Each class will either be taken in its entirety or not taken at all and according to the proposition above an optimal solution can always be found In the rooted tree we ll call a class if it contains at least one vertical path To reduce the number of vertical classes we ll root the tree by the midpoint of its diameter if the diameter is of odd length consider the root as an edge Now all vertical paths of the same length are equivalent since a vertical path can always be moved to another subtree of the root Thus for each length there is at most one vertical class How do we determine if a path belongs to some vertical class We ll attempt to greedily pull the path first lower one end of the path to the deepest available vertex then the other end and so on In the end either the path becomes vertical or we encounter an obstacle of the following form the endpoints are in non intersecting subtrees of the same depth whose roots are at distance apart and the path length is Moreover any such pair of subtrees describes a non vertical class of paths and no other classes exist as paths from a non vertical class must hit such an obstacle A class doesn t necessarily consist of all paths between subtrees of length This is because an obstacle might exist lower down for some of these paths Nonetheless at least one representative for any pair of subtrees will definitely exist for instance the root of one subtree and the deepest leaf of the other Let s define non vertical classes with a pair of root vertices of subtrees with the convention and define the class length as We ll introduce a forest structure on non vertical classes a pair is an ancestor of if is an ancestor of and is an ancestor of All classes together with this forest can be constructed using DFS in time simultaneously traversing and Moreover we can quickly compute the size of each such class Let denote the number of paths of length between subtrees and Then the size of class is where the summation is over all classes that are proper descendants of such that Thus we need to compute all If we compute this for each class in time the total time will be exercise for the reader Which non vertical classes can t be taken simultaneously If between classes and neither is an ancestor of the other then nested paths can t exist in them due to the construction of the forest there s a branching somewhere that s common to all paths Let class be an ancestor of class Then a pair of nested paths between them can exist if and only if for all classes on the path between and including but excluding Paths within cannot come out of subtrees If then a path of length containing something from must also go between subtrees but it can t extend beyond subtrees since shorter paths from can t Thus it can t belong to Otherwise if we attempt to pull a path of length nested within upwards until encountering an obstacle at this can only happen if is the first significant obstacle How do we include vertical classes Clearly we can take at most one vertical class Using similar reasoning as above if is a non vertical class and is the length of a vertical class then can be taken with a vertical class if there are no classes among the ancestors of including with Constructing a bamboo structure out of all vertical classes shorter classes on top and attaching the roots from the forest of non vertical classes at the bottom of this bamboo the criterion remains the same as in the proposition Now we can forget about the original problem and solve a new one given a rooted tree with numbers and assigned to each vertex we need to select a set of vertices to maximize the sum of while satisfying the criterion Consider the vertex with the minimum among all vertices considering the deepest among such vertices if there are several options It s easy to see that Vertices outside the subtree rooted at cannot prevent us from choosing vertices within the subtree rooted at If we choose we can t choose anything else in its subtree Divide the set of all vertices into and where is the subtree rooted at and solve the problem independently for them The final answer will be This process can be conveniently done in reverse for instance using DSU It s also possible to carefully determine during the forest construction which components will merge and solve the problem in time using just bucket sort without any additional data structures or sorting 
Vasya has items lying in a line The items are consecutively numbered by numbers from to in such a way that the leftmost item has number the rightmost item has number Each item has a weight the th item weights kilograms Vasya needs to collect all these items however he won t do it by himself He uses his brand new robot The robot has two different arms the left one and the right one The robot can consecutively perform the following actions Take the leftmost item with the left hand and spend energy units is a weight of the leftmost item is some parameter If the previous action was the same left hand then the robot spends extra energy units Take the rightmost item with the right hand and spend energy units is a weight of the rightmost item is some parameter If the previous action was the same right hand then the robot spends extra energy units Naturally Vasya wants to program the robot in a way that the robot spends as little energy as possible He asked you to solve this problem Your task is to find the minimum number of energy units robot spends to collect all items ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint N;\nint w[100010];\n\nint main(void){\n    int i;\n    ll l,r,Ql,Qr;\n    \n    cin >> N >> l >> r >> Ql >> Qr;\n    REP(i,N) scanf(""%d"", &w[i]);\n    \n    ll S = 0;\n    REP(i,N) S += w[i];\n    \n    ll ans = (1ll<<60);\n    ll L = 0;\n    \n    REP(i,N+1){\n        if(i != 0) L += w[i-1];\n        ll R = S - L;\n        ll tmp = L * l + R * r;\n        int j = N - i;\n        if(i > j) tmp += (i - j - 1) * Ql;\n        if(i < j) tmp += (j - i - 1) * Qr;\n        ans = min(ans, tmp);\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0]",1500,Brute force how many times we will use operation from the left So if we use it times then it s clear that we will take first items by the left operations and last items by the right operations So robot will spend energy plus some penalty for the same operations To minimize this penalty we should perform the operations in the following order LRLRL RLRLLLLL starting from the bigger set For example if we should perform operations in this order LRLRLRLRL LL So we will have to pay the penalty two times sum of first weights sum of last weights Solution in pseudocode Time complexity 
You are given an integer value x and a string s consisting of digits from 1 to 9 inclusive A substring of a string is a contiguous subsequence of that string Let f l r be the sum of digits of a substring s l r Let s call substring s l 1 r 1 if f l 1 r 1 x there are no values l 2 r 2 such that l 1 le l 2 le r 2 le r 1 f l 2 r 2 neq x x is divisible by f l 2 r 2 You are allowed to erase some characters from the string If you erase a character the two resulting parts of the string are concatenated without changing their order What is the minimum number of characters you should erase from the string so that there are no substrings in it If there are no substrings in the given string s then print 0 ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << \'{\'; string sep; for (const auto &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << \'{\'; string sep; for (const auto &x : arr) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n// This version of aho_corasick uses more memory and depends on a small alphabet, but it provides O(1) suffix links.\ntemplate<char MIN_CHAR = \'a\', int ALPHABET = 26>\nstruct aho_corasick {\n    struct node {\n        // suff = the index of the node of the longest strict suffix of the current node that\'s also in the tree.\n        //   Also see ""blue arcs"" on Wikipedia: https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\n        // dict = the index of the node of the longest strict suffix of the current node that\'s in the word list.\n        //   Also see ""green arcs"" on Wikipedia.\n        // depth = normal trie depth (root is 0). Can be removed to save memory.\n        // word_index = the index of the *first* word ending at this node. -1 if none.\n        // word_count = the total number of words ending at this node. Used in count_total_matches().\n        // link = the trie connections and/or suffix connections from this node.\n        int suff = -1, dict = -1, depth = 0;\n        int word_index = -1, word_count = 0;\n        int link[ALPHABET];\n\n        node() {\n            fill(link, link + ALPHABET, -1);\n        }\n\n        int& operator[](char c) {\n            return link[c - MIN_CHAR];\n        }\n    };\n\n    vector<node> nodes;\n    int W;\n    vector<int> word_location;\n    vector<int> word_indices_by_depth;\n    vector<int> defer;\n\n    aho_corasick(const vector<string> &words = {}) {\n        if (!words.empty())\n            build(words);\n    }\n\n    // Builds the adj list based on suffix parents. Often we want to perform DP and/or queries on this tree.\n    vector<vector<int>> build_suffix_adj() const {\n        vector<vector<int>> adj(nodes.size());\n\n        for (int i = 1; i < int(nodes.size()); i++)\n            adj[nodes[i].suff].push_back(i);\n\n        return adj;\n    }\n\n    int get_or_add_child(int current, char c) {\n        if (nodes[current][c] >= 0)\n            return nodes[current][c];\n\n        int index = int(nodes.size());\n        nodes[current][c] = index;\n        nodes.emplace_back();\n        nodes.back().depth = nodes[current].depth + 1;\n        return index;\n    }\n\n    int add_word(const string &word, int word_index) {\n        assert(!nodes.empty());\n        int current = 0;\n\n        for (char c : word)\n            current = get_or_add_child(current, c);\n\n        if (nodes[current].word_index < 0)\n            nodes[current].word_index = word_index;\n\n        nodes[current].word_count++;\n        return current;\n    }\n\n    // Returns where in the trie we should end up after starting at `location` and adding char `c`. Runs in O(1).\n    int get_suffix_link(int location, char c) const {\n        if (location >= 0)\n            location = nodes[location].link[c - MIN_CHAR];\n\n        return max(location, 0);\n    }\n\n    void build(const vector<string> &words) {\n        nodes = {node()};\n        W = int(words.size());\n        word_location.resize(W);\n        defer.resize(W);\n        int max_depth = 0;\n\n        for (int i = 0; i < W; i++) {\n            word_location[i] = add_word(words[i], i);\n            max_depth = max(max_depth, int(words[i].size()));\n            defer[i] = nodes[word_location[i]].word_index;\n        }\n\n        // Create a list of word indices in decreasing order of depth, in linear time via counting sort.\n        word_indices_by_depth.resize(W);\n        vector<int> depth_freq(max_depth + 1, 0);\n\n        for (int i = 0; i < W; i++)\n            depth_freq[words[i].size()]++;\n\n        for (int i = max_depth - 1; i >= 0; i--)\n            depth_freq[i] += depth_freq[i + 1];\n\n        for (int i = 0; i < W; i++)\n            word_indices_by_depth[--depth_freq[words[i].size()]] = i;\n\n        // Solve suffix parents by traversing in order of depth (BFS order).\n        vector<int> q = {0};\n\n        for (int i = 0; i < int(q.size()); i++) {\n            int current = q[i];\n\n            for (char c = MIN_CHAR; c < MIN_CHAR + ALPHABET; c++) {\n                int &index = nodes[current][c];\n\n                if (index >= 0) {\n                    // Find index\'s suffix parent by traversing suffix parents of current until one of them has a child c.\n                    int suffix_parent = get_suffix_link(nodes[current].suff, c);\n                    nodes[index].suff = suffix_parent;\n                    nodes[index].word_count += nodes[suffix_parent].word_count;\n                    nodes[index].dict = nodes[suffix_parent].word_index < 0 ? nodes[suffix_parent].dict : suffix_parent;\n                    q.push_back(index);\n                } else {\n                    index = get_suffix_link(nodes[current].suff, c);\n                }\n            }\n        }\n    }\n\n    // Counts the number of matches of each word in O(text length + num words).\n    vector<int> count_matches(const string &text) const {\n        vector<int> matches(W, 0);\n        int current = 0;\n\n        for (char c : text) {\n            current = get_suffix_link(current, c);\n            int dict_node = nodes[current].word_index < 0 ? nodes[current].dict : current;\n\n            if (dict_node >= 0)\n                matches[nodes[dict_node].word_index]++;\n        }\n\n        // Iterate in decreasing order of depth.\n        for (int word_index : word_indices_by_depth) {\n            int location = word_location[word_index];\n            int dict_node = nodes[location].dict;\n\n            if (dict_node >= 0)\n                matches[nodes[dict_node].word_index] += matches[word_index];\n        }\n\n        for (int i = 0; i < W; i++)\n            matches[i] = matches[defer[i]];\n\n        return matches;\n    }\n\n    // Counts the number of matches over all words at each ending position in `text` in O(text length).\n    vector<int> count_matches_by_position(const string &text) const {\n        vector<int> matches(text.size());\n        int current = 0;\n\n        for (int i = 0; i < int(text.size()); i++) {\n            current = get_suffix_link(current, text[i]);\n            matches[i] = nodes[current].word_count;\n        }\n\n        return matches;\n    }\n\n    // Counts the total number of matches of all words within `text` in O(text length).\n    int64_t count_total_matches(const string &text) const {\n        int64_t matches = 0;\n        int current = 0;\n\n        for (char c : text) {\n            current = get_suffix_link(current, c);\n            matches += nodes[current].word_count;\n        }\n\n        return matches;\n    }\n};\n\n\nconst int INF = 1e9 + 5;\n\nint N, X;\nstring S;\nvector<string> prime;\naho_corasick<\'1\', 9> AC;\n\nbool check(string str) {\n    int n = int(str.size());\n\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n\n        for (int j = i; j < n; j++) {\n            sum += str[j] - \'0\';\n\n            if (sum < X && X % sum == 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nvoid generate(string str, int sum) {\n    if (sum > X)\n        return;\n\n    if (sum == X) {\n        if (check(str))\n            prime.push_back(str);\n\n        return;\n    }\n\n    for (int d = 1; d <= 9 && sum + d <= X; d++)\n        generate(str + char(d + \'0\'), sum + d);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> S >> X;\n    N = int(S.size());\n    generate("""", 0);\n    dbg(prime);\n    AC.build(prime);\n    int ST = int(AC.nodes.size());\n    vector<int> dp(ST, INF);\n    dp[0] = 0;\n\n    for (auto &ch : S) {\n        vector<int> next_dp(ST, INF);\n\n        for (int state = 0; state < ST; state++)\n            if (dp[state] < INF) {\n                next_dp[state] = min(next_dp[state], dp[state] + 1);\n                int transition = AC.get_suffix_link(state, ch);\n\n                if (AC.nodes[transition].word_index < 0)\n                    next_dp[transition] = min(next_dp[transition], dp[state]);\n            }\n\n        swap(dp, next_dp);\n    }\n\n    cout << *min_element(dp.begin(), dp.end()) << \'\\n\';\n}\n']","[0, 0, 0, 1, 0, 1, 0, 0, 0, 0]",2800,The key observation is that since is only up to 20 there can t be that many different prime strings total turns out there are only about 2400 for the worst case of So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match We can do this by building a trie of all of the prime strings We then need to be able to transition around in this trie it turns out this is exactly what Aho Corasick does for us In particular knowing which node of the Aho Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later This leads to a fairly simple DP 90977148 
You are given an integer n and two sequences a 1 a 2 dots a n and b 1 b 2 dots b n Let s call a set of integers S such that S subseteq 1 2 3 dots n if for every element i of S the following condition is met for every j in 1 i 1 if a j divides a i then j is also included in S An empty set is always The of the set S is sum limits i in S b i You have to calculate the maximum possible of a set ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nconstexpr int inf = 1e9;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::mt19937 gen;\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    std::vector<int> last(101, -1);\n    Flow g(n + 2);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (b[i] > 0) {\n            ans += b[i];\n            g.addEdge(n, i, b[i]);\n        } else {\n            g.addEdge(i, n + 1, -b[i]);\n        }\n        for (int j = 1; j <= a[i]; j++) {\n            if (a[i] % j == 0 && last[j] != -1) {\n                g.addEdge(i, last[j], inf);\n            }\n        }\n        last[a[i]] = i;\n    }\n    ans -= g.maxFlow(n, n + 1);\n    std::cout << ans << ""\\n"";\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2700,We will model the problem as the minimum cut in a flow network Build a network as follows create a source node a sink node and a vertex for every number from to Let s say that we are going to find the minimum cut in this network and the vertices belonging to the same cut part with represent the numbers that are taken into the answer Using the edges of the network we should model these constraints taking an element that depends on another element should force us to take as well taking an element with should add to our score taking an element with should subtract from our score Constraint can be modeled in the following way for every pair such that element depends on element and add a directed edge with infinite capacity from to That way if is taken and is not the value of the cut will be infinite because of this edge and this cut cannot be minimum Constraint is modeled in the following way for every such that add a directed edge with capacity from to That way if we take some element with into the answer is added to the value of the cut And for constraint for every such that add a directed edge with capacity from to That way if we take some element with is added to the value of the cut It s now easy to see that the answer is since it is exactly the sum of elements that were taken for positive elements we add them all up and then subtract the ones that don t belong to the answer for negative ones we just subtract those which belong to the answer To find a minimum cut just run maximum flow in this network There s one caveat though If for example all are equal or many are divisible by many other values in this network can contain edges To reduce the number of edges let s see that if for some index there exist two equal divisors of to the left of it let s say that these divisors are and then we only need to add an edge from to because taking also should force taking into the answer So for every divisor of we are interested in only one closest occurrence of this divisor to the left and we need to add a directed edge only to this occurrence and ignore all other occurrences That way for every vertex we add at most edges to other vertices where is the number of divisors of It can be proven that any maximum flow algorithm that relies on augmenting paths will finish after iterations in this network so it won t work longer than and both and are proportional to so any maximum flow solution will run in 
The Berland State University is hosting a ballroom dance in celebration of its 100500 th anniversary boys and girls are already busy rehearsing waltz minuet polonaise and quadrille moves We know that several boy girl pairs are going to be invited to the ball However the partners dancing skill in each pair must differ by at most one For each boy we know his dancing skills Similarly for each girl we know her dancing skills Write a code that can determine the largest possible number of pairs that can be formed from boys and girls ,"['#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nconst int MAX = 100 + 10;\nint a[MAX], b[MAX];\nint main(){\n    int n;\n    scanf(""%d"", &n);\n    for(int i = 0 ; i < n ;i++)\n        scanf(""%d"", &a[i]);\n    int m;\n    scanf(""%d"", &m);\n    for(int i = 0 ; i < m ; i++){\n        scanf(""%d"", &b[i]);\n    }\n    sort(a, a+n);\n    sort(b, b+m);\n    int i = 0, j = 0, ans = 0;\n    while(i < n && j < m){\n        if(abs(a[i] - b[j]) <= 1){\n            i++,j++,ans++;\n        }else if(a[i] < b[j]) i++;\n        else j++;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 1, 0]",1200,There are about 100500 ways to solve the problem You can find maximal matching in a bipartite graph boys girls write dynamic programming or just use greedy approach Let s sort boys and girls by skill If boy with lowest skill can be matched it is good idea to match him It can t reduce answer size Use girl with lowest skill to match So you can use code like 
William has a favorite bracket sequence Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c 1 c 2 dots c n where c i is the number of consecutive brackets if i is an odd number or the number of consecutive brackets if i is an even number For example for a bracket sequence a corresponding sequence of numbers is 3 2 1 3 You need to find the total number of continuous subsequences subsegments l r l le r of the original bracket sequence which are regular bracket sequences A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 1005;\nint x[maxn];\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) scanf(""%d"", &x[i]);\n    ll ans = 0;\n    for (int i = 1; i <= n; i += 2) {\n        ll sum = 0, lb = 0;\n        for (int j = i + 1; j <= n; j++) {\n            if (j % 2 == 0) {\n                ll dif = -sum;\n                ll l = -lb;\n                chkmax(l, 1ll);\n                chkmax(l, 1 + dif);\n                ll r = x[i];\n                chkmin(r, x[j] + dif);\n                if (r >= l) ans += r - l + 1;\n            }\n            if (j % 2) sum += x[j];\n            else sum -= x[j];\n            chkmin(lb, sum);\n            if (j % 2) continue;\n        }\n    }\n    cout << ans << endl;\n    return (0-0); //<3\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1800,Let s examine a compressed sequence and fix two indexes l r l 2 0 r 2 1 Note that it makes no sense to examine other indexes because the correct bracket sequence always begins with the opening bracket and ends with the closing one Next we can calculate the minimum bracket balance on the segment from l 1 to r 1 The minimum bracket balance is the minimum number of opening brackets that we must put before the sequence of brackets in order for it to be regular provided that we can put any number of closing brackets at the end Let s denote this number as minBalance and denote the sum of cl 1 cl 2 cl 2 as balance The next observation is that if we fix the number of opening brackets taken from cl then we can count the number of brackets that we should take from cr Using these observations we can calculate the answer for l r using the following formula min cl cr balance max 1 minBalance 1 Note that this problem could also be solved in O n but this was not required 
You are given a matrix of size n times n filled with lowercase English letters You can change no more than k letters in this matrix Consider all paths from the upper left corner to the lower right corner that move from a cell to its neighboring cell to the right or down Each path is associated with the string that is formed by all the letters in the cells the path visits Thus the length of each string is 2n 1 Find the lexicographically smallest string that can be associated with a path after changing letters in at most k cells of the matrix A string a is lexicographically smaller than a string b if the first different letter in a and b is smaller in a ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=2007;\nconst int inf=1e9;\n\nint n, k;\n\nchar tab[nax][nax];\n\nint dp[nax][nax];\nvector <pii> war[nax*2];\n\nvoid zbi(int &a, int b)\n{\n\ta=min(a, b);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%s"", tab[i]+1);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tdp[i][j]=inf;\n\tdp[1][1]=0;\n\tif (k && tab[1][1]!=\'a\')\n\t{\n\t\tk--;\n\t\ttab[1][1]=\'a\';\n\t}\n\tprintf(""%c"", tab[1][1]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\twar[i+j].push_back({i, j});\n\tfor (int i=2; i<2*n; i++)\n\t{\n\t\tchar mini=\'z\';\n\t\tfor (pii j : war[i])\n\t\t{\n\t\t\tint a=j.first;\n\t\t\tint b=j.second;\n\t\t\tif (dp[a][b]<=k)\n\t\t\t{\n\t\t\t\tif (a<n)\n\t\t\t\t\tmini=min(mini, tab[a+1][b]);\n\t\t\t\tif (b<n)\n\t\t\t\t\tmini=min(mini, tab[a][b+1]);\n\t\t\t}\n\t\t\tif (dp[a][b]<k)\n\t\t\t{\n\t\t\t\tmini=\'a\';\n\t\t\t}\n\t\t}\n\t\tprintf(""%c"", mini);\n\t\tfor (pii j : war[i])\n\t\t{\n\t\t\tint a=j.first;\n\t\t\tint b=j.second;\n\t\t\tif (dp[a][b]<=k)\n\t\t\t{\n\t\t\t\tif (a<n)\n\t\t\t\t\tzbi(dp[a+1][b], dp[a][b]+(tab[a+1][b]!=mini));\n\t\t\t\tif (b<n)\n\t\t\t\t\tzbi(dp[a][b+1], dp[a][b]+(tab[a][b+1]!=mini));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1900,First let s find the number of a s in the beginning of the answer To do this one can calculate dp i j standing for the minimal number of non a s among all paths from the initial corner to i j The number of a s is simply the greatest i j among all pairs i j such that dp i j k or 0 if there are no Consider all cells where we can go right after obtaining the prefix of a s Now we repeat the following append the minimal symbol in these cells to the answer choose those cells and go from them in both possible directions to obtain the new set of cells One can see that the answer we obtain is indeed the required answer 
You might have remembered Theatre square from the problem 1A Now it s finally getting repaved The square still has a rectangular shape of n times m meters However the picture is about to get more complicated now Let a i j be the j th square in the i th row of the pavement You are given the picture of the squares if a i j then the j th square in the i th row should be if a i j then the j th square in the i th row should be The black squares are paved already You have to pave the white squares There are two options for pavement tiles 1 times 1 tiles each tile costs x burles and covers exactly 1 square 1 times 2 tiles each tile costs y burles and covers exactly 2 adjacent squares of the What is the smallest total price of the tiles needed to cover all the white squares ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 1005;\nchar c[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n, m;\n        cin >> n >> m;\n        int x, y;\n        cin >> x >> y;\n        y = min(y, 2 * x);\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                cin >> c[i][j];\n                if (c[i][j] == \'.\') {\n                    if (j != 1 && c[i][j - 1] == \'.\' && c[i][j] == \'.\') {\n                        c[i][j] = \'*\';\n                        c[i][j - 1] = \'*\';\n                        ans += y;\n                    }\n                }\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (c[i][j] == \'.\') ans += x;\n            }\n        }\n        cout << ans << \'\\n\';\n    }\n    return 0;\n}']","[1, 0, 1, 1, 0, 1, 0, 0, 0, 0]",1000,Notice that rows can be solved completely separately of each other Each tile takes either one or two squares but it s always in the same row So let s take a look at a single row There are sequences of dot characters separated by some asterisks Once again each of these sequences can be solved independently of the others Thus we have these empty strips of empty squares which when solved can be summed up into the whole answer There are two cases depending on if a is cheaper than two tiles If it is then we want to use of many tiles as possible So given we can place tiles and cover the rest squares with tiles If it isn t cheaper then we want to cover everything with tiles and never use ones So all should be The easier way to implement this might be the following Let s update the price of the tile with the minimum of and This way the first algorithm will produce exactly the same result of the second one in the case when a tile isn t cheaper than two ones Overall complexity per testcase 
Berland is a tourist country At least it can become such the government of Berland is confident about this There are cities in Berland some pairs of which are connected by two ways roads Each road connects two different cities In Berland there are no roads which connect the same pair of cities It is possible to get from any city to any other city using given two ways roads According to the reform each road will become one way It will be oriented to one of two directions To maximize the tourist attraction of Berland after the reform for each city the value will be calculated It will equal to the number of cities for which there is an oriented path from the city to the city In other words will equal the number of cities which can be reached from the city by roads The government is sure that tourist s attention will be focused on the minimum value of Help the government of Berland make the reform to maximize the minimum of ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 404040;\nint n , m , u[N] , v[N];\nvector<pii> g[N];\npii ans[N];\n\nnamespace BCC{\n    vi key;\n    vector<pii> bcc[N];\n    int dfn[N] , low[N] , id[N] , st[N] , _st , _;\n    void dfs(int c,int dep,vector<pii> g[]){\n        int cc=0;st[_st++]=c;\n        dfn[c]=low[c]=dep;\n        //cout << c << "" "" << dep << endl;\n        for(auto e:g[c]){\n            int t=e.fi;\n            if(!dfn[t]){\n                ans[e.se] = mp(c,t);\n                dfs(t,dep+1,g);\n                low[c]=min(low[c],low[t]);\n                if(low[t]>dfn[c]) key.pb(e.se);\n            } else if(dfn[t] != dfn[c] - 1 || cc++){\n                low[c] = min(low[c] , dfn[t]);\n                if(dfn[t] < dfn[c]) ans[e.se] = mp(c , t);\n            }\n        }\n        if(low[c]==dfn[c]){\n            do{id[st[--_st]]=_;}while(st[_st]!=c);\n            _++;\n        }\n    }\n    int sz[N];\n    void dfs(int c,int fa){\n        for(auto t : bcc[c]) if(t.fi != fa){\n            int a = u[t.se] , b = v[t.se];\n            if(id[a] == c) swap(a , b);\n            ans[t.se] = mp(a , b);\n            //ans[t.se] = mp(0 , 0);\n            dfs(t.fi , c);\n        }\n    }\n    int solve(int n,vector<pii> g[]){\n        rep(i,0,n) if(!dfn[i]) dfs(i,1,g);\n        rep(i,0,n) sz[id[i]]++;\n        rep(i,0,n) for(auto j:g[i]) if(id[i]!=id[j.fi])\n            bcc[id[i]].pb(mp(id[j.fi],j.se));\n        int id = -1 , Max = -1;\n        rep(i,0,_) if(sz[i] > Max) Max = sz[i] , id = i;\n        dfs(id , -1);\n        printf(""%d\\n"",Max);\n        rep(i,0,m) printf(""%d %d\\n"",ans[i].fi + 1,ans[i].se + 1);\n        return _;\n    }\n};\n\nint main(){\n    scanf(""%d%d"",&n,&m);\n    rep(i,0,m){\n        scanf(""%d%d"",u + i , v + i);\n        --u[i];--v[i];\n        g[u[i]].pb(mp(v[i] , i));\n        g[v[i]].pb(mp(u[i] , i));\n    }\n    BCC::solve(n,g);\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2300,Firstly we have to find all the bridges and divide the graph into 2 edge connected components Then we calculate the size of each component It can be easily proved that the answer is equal to size of the largest component Then we need to orient the edges somehow Start DFS from any vertex of the largest component If we traverse the edge coming from vertex and it has not been oriented yet we orient it from to if it s a bridge so it leads to the largest component or from to otherwise When all vertices are visited and all edges are oriented we can print the answer Time complexity 
 There are n kids each of them is reading a unique book At the end of any day the i th kid will give his book to the p i th kid in case of i p i the kid will give his book to himself It is guaranteed that all values of p i are distinct integers from 1 to n i e p is a permutation The sequence p doesn t change from day to day it is fixed For example if n 6 and p 4 6 1 3 5 2 then at the end of the first day the book of the 1 st kid will belong to the 4 th kid the 2 nd kid will belong to the 6 th kid and so on At the end of the second day the book of the 1 st kid will belong to the 3 th kid the 2 nd kid will belong to the 2 th kid and so on Your task is to determine the number of the day the book of the i th child is returned back to him for the first time for every i from 1 to n Consider the following example p 5 1 2 4 3 The book of the 1 st kid will be passed to the following kids after the 1 st day it will belong to the 5 th kid after the 2 nd day it will belong to the 3 rd kid after the 3 rd day it will belong to the 2 nd kid after the 4 th day it will belong to the 1 st kid So after the fourth day the book of the first kid will return to its owner The book of the fourth kid will return to him for the first time after exactly one day You have to answer q independent queries ,"['#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<\'0\'||c>\'9\');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>=\'0\'&&c<=\'9\');\n\treturn res;\n}\nint s[100010], ans[100010], ans2[100010], Z, vis[100010], cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\tcnt++;\n\tif(!vis[s[x]])dfs(s[x]);\n\tans[Z]=cnt;\n\tans2[x]=Z;\n}\nint main() {\n\tint T=read();\n\twhile(T--){\n\t\tint N=read();\n\t\tfor(int i=1; i<=N; i++){\n\t\t\ts[i]=read();\n\t\t\tvis[i]=0;\n\t\t\tans[i]=0;\n\t\t\tans2[i]=0;\n\t\t}\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tif(!vis[i]){\n\t\t\t\tZ++;\n\t\t\t\tcnt=0;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\t//puts(""ANS"");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tprintf(""%d%c"", ans[ans2[i]], i==N?\'\\n\':\' \');\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1000,In this problem you just need to implement what is written in the problem statement For the kid the following pseudocode will calculate the answer indices of the array and its values are indexed pos p i ans 1while pos i ans 1 pos p pos 
Dedicated to pushing himself to his limits Penchick challenged himself to survive the midday sun in the Arabian Desert While trekking along a linear oasis Penchick spots a desert rabbit preparing to jump along a line of palm trees There are n trees each with a height denoted by a i The rabbit can jump from the i th tree to the j th tree if exactly one of the following conditions is true j i and a j a i the rabbit can jump backward to a taller tree j i and a j a i the rabbit can jump forward to a shorter tree For each i from 1 to n determine the maximum height among all trees that the rabbit can reach if it starts from the i th tree ,"['#include<bits/stdc++.h>//#pragma GCC optimize(""Ofast,no-stack-protector,unroll-loops,fast-math"")//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native"")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());ll rint(ll l,ll r){return uniform_int_distribution<ll>(l,r)(rnd);}const int maxn=5e5+5;int T,n,a[maxn],ans[maxn];int t[maxn];void in(int x,int k){\twhile(x<=n) t[x]=max(t[x],k),x+=lb(x);}int find(int x){\tint rt=0;\twhile(x) rt=max(t[x],rt),x-=lb(x);\treturn rt;}int main(){    scanf(""%d"",&T);    while(T--)    {        scanf(""%d"",&n);        memset(t,0,(n+1)<<2);        for(int i=1;i<=n;i++)        {            scanf(""%d"",&a[i]);            ans[i]=max(ans[i-1],a[i]);        }        for(int i=n;i;i--)        {            ans[i]=max(ans[i],find(ans[i]-1));            in(a[i],ans[i]);        }        for(int i=1;i<=n;i++) printf(""%d "",ans[i]);        putchar(\'\\n\');    }    return 0;}']","[1, 0, 1, 1, 1, 0, 0, 1, 0, 0]",1700,SolutionFirst observe that a rabbit at tree can reach the highest tree if the tree has index then the rabbit can jump from tree to Let denote the tallest height reachable from tree then We iteratively look at trees to Suppose we have found the tallest height reachable from tree Note that from tree we can reach the tallest tree with index between and and from tree we can reach the shortest tree with index between and Let and Then if then tree is reachable from tree by the sequence Thus any tree reachable from tree is reachable from tree and vice versa thus On the other hand if then for any and we have and Thus no tree between index and inclusive is reachable from any tree from and inclusive Similar to the first paragraph we have Time complexity Implementation by ACGN 291677082 
Let s call an array b 1 b 2 ldots b m m ge 2 if it can be split into two parts such that all elements in the left part are strictly smaller than all elements in the right part In other words there must exist an index 1 le i m such that every element from b 1 ldots b i is strictly smaller than every element from b i 1 ldots b m Given an array a 1 a 2 ldots a n consisting of integers from 1 to n There are q queries Each query consists of two numbers l and r For each query determine whether the array a l a l 1 ldots a r is good ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate <typename T>\nstruct Fenwick {\n    int n;\n    std::vector<T> a;\n    \n    Fenwick(int n_ = 0) {\n        init(n_);\n    }\n    \n    void init(int n_) {\n        n = n_;\n        a.assign(n, T{});\n    }\n    \n    void add(int x, const T &v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] = a[i - 1] + v;\n        }\n    }\n    \n    T sum(int x) {\n        T ans{};\n        for (int i = x; i > 0; i -= i & -i) {\n            ans = ans + a[i - 1];\n        }\n        return ans;\n    }\n    \n    T rangeSum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n    \n    int select(const T &k) {\n        int x = 0;\n        T cur{};\n        for (int i = 1 << std::__lg(n); i; i /= 2) {\n            if (x + i <= n && cur + a[x + i - 1] <= k) {\n                x += i;\n                cur = cur + a[x - 1];\n            }\n        }\n        return x;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), inva(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        inva[a[i]] = i;\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    std::vector<int> ans(q);\n    std::vector<std::vector<std::pair<int, int>>> qry(n);\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        std::cin >> l >> r;\n        l--, r--;\n        qry[l].emplace_back(r, i);\n    }\n    \n    std::vector<int> L(n), R(n), RR(n);\n    std::set<int> s{-1, n};\n    for (int i = n - 1; i >= 0; i--) {\n        int x = inva[i];\n        int l = *std::prev(s.lower_bound(x));\n        int r = *s.lower_bound(x);\n        s.insert(x);\n        L[x] = l, R[x] = r;\n    }\n    s = {-1, n};\n    for (int i = 0; i < n; i++) {\n        int x = inva[i];\n        if (R[x] < n) {\n            RR[x] = *s.lower_bound(R[x]);\n        }\n        s.insert(x);\n    }\n    std::vector<std::vector<std::pair<int, int>>> add(n);\n    for (int i = 0; i < n; i++) {\n        if (R[i] < n) {\n            add[L[i] + 1].emplace_back(R[i], 1);\n            add[L[i] + 1].emplace_back(RR[i], -1);\n            add[i + 1].emplace_back(R[i], -1);\n            add[i + 1].emplace_back(RR[i], 1);\n        }\n    }\n    Fenwick<int> fen(n);\n    for (int i = 0; i < n; i++) {\n        for (auto [x, y] : add[i]) {\n            fen.add(x, y);\n        }\n        for (auto [r, j] : qry[i]) {\n            if (fen.sum(r + 1) > 0) {\n                ans[j] = 1;\n            }\n        }\n    }\n    \n    for (int i = 0; i < q; i++) {\n        std::cout << (ans[i] ? ""Yes"" : ""No"") << ""\\n"";\n    }\n    \n    return 0;\n}\n']","[0, 1, 0, 0, 1, 0, 0, 1, 0, 0]",2700,Let s fix element Let s find all intervals for which this element can be the maximum in the left part of a valid cut Let be the nearest element to the left of greater than and be the nearest element to the right of greater than Then for to be the maximum element in the left part of the cut the following conditions must be satisfied But these conditions are obviously not enough as we need to guarantee that all elements in the right part of the cut are greater than all elements in the left part of the cut However since is the maximum element in the left part of the cut it is sufficient for all elements in the right part of the cut to be greater than Therefore if is the nearest element to the right of smaller than then Thus element can be the maximum element in the left part of the cut of interval the following conditions are satisfied For each element we can find and in time This can be done for example using a segment tree or std set if the elements are iterated in ascending order It only remains to notice that if we consider the queries as points then each element makes all points in some rectangle good Thus the problem reduces to checking whether a point lies in one of the rectangles This is a classic problem that can be solved using sweep line and for example a segment tree We obtained a solution with a time complexity of 
Today s morning was exceptionally snowy Meshanya decided to go outside and noticed a huge snowball rolling down the mountain Luckily there are two stones on that mountain Initially snowball is at height h and it has weight w Each second the following sequence of events happens snowball s weights increases by i where i is the current height of snowball then snowball hits the stone if it s present at the current height then snowball moves one meter down If the snowball reaches height zero it stops There are exactly two stones on the mountain First stone has weight u 1 and is located at height d 1 the second one u 2 and d 2 respectively When the snowball hits either of two stones it loses weight equal to the weight of that stone If after this snowball has negative weight then its weight becomes zero but the snowball continues moving as before Find the weight of the snowball when it stops moving that is it reaches height 0 ,"['#include <bits/stdc++.h>\n#define endl \'\\n\'\n\n//#pragma GCC optimize (""O3"")\n//#pragma GCC target (""sse4"")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nint w, h;\nint d1, d2, u1, u2;\n\nvoid read()\n{\n\tcin >> w >> h;\n\tcin >> u1 >> d1;\n\tcin >> u2 >> d2;\n}\n\nvoid solve()\n{\n\twhile(h)\n\t{\n\t\tw += h;\n\t\tif(h == d1) w -= u1, chkmax(w, 0); \n\t\tif(h == d2) w -= u2, chkmax(w, 0); \n\t\th--;\n\t}\n\n\tcout << w << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,This problem can be solved in many ways we will tell you one of them Let s just iterate through all the heights of from to Inside the loop we have to add to the weight of snowball and then check whether there is a stone at this height If there is then you need to check whether weight of snowball is more than weight of the stone If more then subtract the weight of the stone from weight of snowball if not then assign the weight of snowball value 0 Code ism OK tutorial 
You are given two integer numbers n and x You may perform several operations with the integer x Each operation you perform is the following one choose any digit y that occurs in the decimal representation of x at least once and replace x by x cdot y You want to make the length of decimal representation of x without leading zeroes equal to n What is the minimum number of operations required to do that ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:39:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long x;\n  cin >> n >> x;\n  vector<long long> p10(n);\n  p10[0] = 1;\n  for (int i = 1; i < n; i++) {\n    p10[i] = p10[i - 1] * 10;\n  }\n  long long goal = p10[n - 1];\n  const int inf = (int) 1e9;\n  int ans = inf;\n  function<void(int, long long)> Dfs = [&](int cnt, long long num) {\n    if (cnt >= ans) {\n      return;\n    }\n    if (num >= goal) {\n      ans = cnt;\n      return;\n    }\n    int need = 0;\n    long long tmp = num;\n    while (tmp < goal) {\n      tmp *= 9;\n      need += 1;\n    }\n    if (cnt + need >= ans) {\n      return;\n    }\n    array<bool, 10> has;\n    for (int d = 0; d < 10; d++) {\n      has[d] = false;\n    }\n    tmp = num;\n    while (tmp > 0) {\n      has[tmp % 10] = true;\n      tmp /= 10;\n    }\n    for (int d = 9; d >= 2; d--) {\n      if (has[d]) {\n        Dfs(cnt + 1, num * d);\n      }\n    }\n  };\n  Dfs(0, x);\n  cout << (ans == inf ? -1 : ans) << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 1, 0, 0, 0, 0]",1700,One of the possible approaches to this problem is to try multiplying only by the largest digit in it Unfortunately this doesn t work quite well since it gives WA on one of the examples That example is too big to consider but a smaller version of it can prove that this is an incorrect solution let If we multiply by we get and there s no way to obtain a number with digits using the next action But if we multiply by we get which can then be multiplied by to obtain a digit number So considering only the largest digit is not enough This implies that we somehow need to consider the options that are not optimal locally but optimal globally i e choose a lower digit right now to obtain a higher digit in the future Let s try to estimate the number of possible integers that can be obtained using these operations to see if we can consider all possible options The key observation is that each integer we obtain will have the form since only one digit primes can be added to the factorization Since we consider only numbers less than is not greater than is not greater than is not greater than and is not greater than and the number of reachable integers is about million note that this is a very generous bound since not all combinations of yield an integer less than and not all such integers can be reached with the operations This allows us to use BFS or dynamic programming to calculate the answer 
Vlad found a flowerbed with graphs in his yard and decided to take one for himself Later he found out that in addition to the usual graphs k flowers also grew on that flowerbed A graph is called a k flower if it consists of a simple cycle of length k through each vertex of which passes its own simple cycle of length k and these cycles do not intersect at the vertices For example 3 flower looks like this Note that 1 flower and 2 flower do not exist since at least 3 vertices are needed to form a cycle Vlad really liked the structure of the k flowers and now he wants to find out if he was lucky to take one of them from the flowerbed ,"['#define _CRT_SECURE_NO_WARNINGS//MSVC compiler\n#include <cstdio>//cstdio fan\n#include <cstring>//strlen\n#include <cstdint>\n#include <cmath>\n//#include <cstdlib>\n//#include <cctype>\n//#include <type_traits>\n//#include <string>\n//#include <iostream>\n#include <algorithm>\n#include <iterator>\n//#include <array>\n//#include <vector>\n#include <map>\n#include <numeric>\n#include <array>\n//#include <tuple>\n//#include <queue>\n//#include <set>\n//#include <bitset>\n#include <bit>\n#ifdef ON_PC\n#include <chrono>\n#include <cassert>\n#else\n#define assert(v) {}\n#endif//ON_PC    \n\nusing u = unsigned;\nusing u64 = uint64_t;\n\n#ifdef ON_PC\nconstexpr u N = u(500);\n#else\nconstexpr u N = u(2e5);\n#endif//ON_PC    \nconstexpr u N2 = std::bit_ceil(N);\nconstexpr u64 mod = u(1e9)+7;\n\nu n, m, k;\n\nu deg[N];\nbool vis[N];\n\nstd::vector<u> childs[N];\nstd::vector<u> main_cycle;\n\nvoid solve() {\n    scanf(""%u%u"", &n, &m);\n    k = std::sqrt(n);\n    if (k * k != n || (k+1)*k != m) { // invalid V|E count\n        for (u i = 0, u, v; i < m; i++) scanf(""%u%u"", &u, &v);\n        puts(""NO"");\n        return;\n    }\n    std::memset(deg, 0, sizeof(u) * n);\n    for (u i = 0; i < n; i++) childs[i].clear();\n    for (u i = 0, u, v; i < m; i++) scanf(""%u%u"", &u, &v), u--, v--, deg[u]++, deg[v]++, childs[u].push_back(v), childs[v].push_back(u);\n    main_cycle.clear();\n    for (u i = 0; i < n; i++) {\n        if (deg[i] != 2 && deg[i] != 4) { // invalid degree\n            puts(""NO"");\n            return;\n        }\n        if (deg[i] == 4) {\n            u cnt = 0;\n            for (u ch : childs[i]) {\n                cnt += deg[ch] == 4;\n            }\n            if (cnt != 2) { // invalid main cycle\n                puts(""NO"");\n                return;\n            }\n            main_cycle.push_back(i);\n        }\n    }\n    if (main_cycle.size() != k) { // invalid main cycle len\n        puts(""NO"");\n        return;\n    }\n\n    std::memset(vis, 0, n);\n    u cur = main_cycle[0]; // connected graph\n    u vis_cnt = 0;\n    while (!vis[cur]) {\n        vis[cur] = true;\n        vis_cnt += 1;\n        for (u ch : childs[cur]) {\n            if (deg[ch] == 4 && !vis[ch]) cur = ch;\n        }\n    }\n    if (vis_cnt != k) { // unconnected graph | more than 1 main cycle\n        puts(""NO"");\n        return;\n    }\n\n    for (u v : main_cycle) {\n        u prev = v;\n        u cur = 0;\n        u len = 1;\n        for (u ch : childs[v]) {\n            if (deg[ch] != 4) cur = ch;\n        }\n        while (deg[cur] == 2) {\n            u pp = cur;\n            cur = childs[cur][0] == prev ? childs[cur][1] : childs[cur][0];\n            len++;\n            prev = pp;\n        }\n        if (len != k || cur != v) { // invalid ""leaf"" cycle\n            puts(""NO"");\n            return;\n        }\n    }\n\n    puts(""YES"");\n}\n//*///*\n\nint main() {\n#ifdef ON_PC\n    freopen(""input.txt"",""r"",stdin);\n    //freopen(""t_output.txt"",""w"",stdout);\n    try{auto beg = std::chrono::steady_clock::now();\n#endif//ON_PC\n    unsigned q = 1;scanf(""%u"", &q);\n    //printf(""%u\\n"", q);\n    while(q--) solve();//for CF solution\n#ifdef ON_PC\n    printf(""\\nexecution time: %.8lf\\n"", std::chrono::duration<double>(std::chrono::steady_clock::now() - beg).count());\n    }catch(std::exception& ex){printf(""e: %s\\n"", ex.what());}catch(int i){printf(""e: %i\\n"", i);}catch(...){puts(""e: [inv]"");}\n#endif//ON_PC\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1]",2100,Note a few things There are exactly vertices in the flower since from each of the vertices of the main cycle comes another cycle of size in the flower all vertices have degree except for the vertices of the main cycle whose degrees are it follows that in flower edges The listed properties do not take into account only the connectivity of the graph and the sizes of our cycles To check connectivity we run a bfs or dfs from any vertex and check that all vertices have been visited To check the cycle lengths we cut out the edges of the main one and make sure that the graph has fell apart into components of size 
Consider a perfect binary tree with size 2 n 1 with nodes numbered from 1 to 2 n 1 and rooted at 1 For each vertex v 1 le v le 2 n 1 1 vertex 2v is its left child and vertex 2v 1 is its right child Each node v also has a value a v assigned to it Define the operation mathrm pop as follows initialize variable v as 1 repeat the following process until vertex v is a leaf i e until 2 n 1 le v le 2 n 1 among the children of v choose the one with the larger value on it and denote such vertex as x if the values on them are equal i e a 2v a 2v 1 you can choose any of them assign a x to a v i e a v a x assign x to v i e v x assign 1 to a v i e a v 1 Then we say the mathrm pop operation is deterministic if there is a unique way to do such operation In other words a 2v neq a 2v 1 would hold whenever choosing between them A binary tree is called a max heap if for every vertex v 1 le v le 2 n 1 1 both a v ge a 2v and a v ge a 2v 1 hold A max heap is deterministic if the mathrm pop operation is deterministic to the heap when we do it Initially a v 0 for every vertex v 1 le v le 2 n 1 and your goal is to count the number of different deterministic max heaps produced by applying the following operation mathrm add exactly k times Choose an integer v 1 le v le 2 n 1 and for every vertex x on the path between 1 and v add 1 to a x Two heaps are considered different if there is a node which has different values in the heaps Since the answer might be large print it modulo p ,"['#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<""=""<<x<<""\\n"";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+"".in"").c_str(),""r"",stdin);\tfreopen((s+"".out"").c_str(),""w"",stdout);}const int N=505;int n,k,p;int f[505][505],g[505][505];void run(){\tcin>>n>>k>>p;\trep(i,n+1)rep(j,k+1)f[i][j]=g[i][j]=0;\trep(i,k+1)f[0][i]=g[0][i]=1;\trep(i,n-1){\t\trep(j,k+1)rep(l,k+1)if(j+l<=k){\t\t\tif(j<l)(f[i+1][j+l]+=g[i][j]*f[i][l])%=p;\t\t\tif(j>l)(f[i+1][j+l]+=f[i][j]*g[i][l])%=p;\t\t\t(g[i+1][j+l]+=g[i][j]*g[i][l])%=p;\t\t}\t\trep(j,k)(f[i+1][j+1]+=f[i+1][j])%=p;\t\trep(j,k)(g[i+1][j+1]+=g[i+1][j])%=p;//\t\trep(j,k+1)cout<<""f ""<<i+2<<"" ""<<j<<"" ""<<f[i+1][j]<<""\\n"";//\t\trep(j,k+1)cout<<""g ""<<i+2<<"" ""<<j<<"" ""<<g[i+1][j]<<""\\n"";\t}\tcout<<f[n-1][k]<<""\\n"";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2400,idea solution Misuki SolutionConsider properties of the result sequence Since there may be multiple ways to apply operations to make the same heap let s consider the decision version of the problem instead of counting the operation sequence directly That is Given a sequence a resulting from k operations check whether such a is a deterministic max heap and try to figure out what properties are needed Rephrase of problem Let v 2 n 1 be the only leaf such that after popping one element from the top every element on the path between 1 and v would be moved upward then the condition of a deterministic max heap can be rephrased as follows a 1 k a v ge a 2v a 2v 1 for any v 1 le v 2 n 1 a 2 cdot 2 k a 2 cdot 2 k 1 for any k 0 le k le n 2 So we can see that for any k 0 le k le n 2 the number of operations done in the subtree of 2 cdot 2 k should be greater than the number of operations done in the subtree of 2 cdot 2 k 1 and we don t care much about how these operations distribute in the subtree of 2 cdot 2 k 1 as long as 3 holds Let s call such subtree uncritical Apply counting For any uncritical subtree with size sz if we do x operations under it there are binom x sz 1 x ways to do so Now we can use dp to consider all valid a we can get by enumerating the number of operation done on each vertex on the path from 1 to 2 n 1 and all uncritical subtree Let dp i j be the number of different a we can get by j operations on the subtree with size 2 i 1 then we havebase case dp 1 j 1 forall j in 0 k transition dp i 1 l text dp i j times binom x 2 i 2 x forall x in 0 j l in j x k using prefix sum we can optimize the above dp to O nk 2 and the number of deterministic max heap where vertex 2 n 1 would be pulled up is dp n k Make use of symmetry Finally due to the symmetry property of a perfect binary tree the number of deterministic max heap where v would be pulled are equal for all possible v so the final answer we want would be dp n k times 2 n 1 
Let s call a number good if it contains all digits not exceeding You ve got a number and an array containing numbers Find out how many good numbers are in count each number every time it occurs in array ,"['#include <stdio.h>\n#include <string.h>\n\nint main(){\n\n    int test;\n    int k;\n    bool flag[10];\n    int in,ans=0;\n\n    for( scanf(""%d%d"",&test,&k) ; test-- ; ){\n        memset(flag,0,sizeof(flag));\n        for( scanf(""%d"",&in); in ; in/=10 ){\n            flag[in%10]=1;  \n        }\n        \n        for( int i=0 ; i<=k ; i++ ) if(flag[i]==false ) goto fail;\n        \n        ans++;\n        fail:;\n        \n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100,Task was to find the least digit that is not contained in the given number and compare with given k 
Polycarp loves geometric progressions very much Since he was only three years old he loves only the progressions of length three He also has a favorite integer and a sequence consisting of integers He wants to know how many subsequences of length three can be selected from so that they form a geometric progression with common ratio A subsequence of length three is a combination of three such indexes that That is a subsequence of length three are such groups of three elements that are not necessarily consecutive in the sequence but their indexes are strictly increasing A geometric progression with common ratio is a sequence of numbers of the form Polycarp is only three years old so he can not calculate this number himself Help him to do it ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define ull unsigned long long\n#define pll pair < ll, ll >\n#define forit(s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it ++)\n#define all(s) s.begin(), s.end()\n\nconst int inf = (1ll << 31) - 1;\nconst int maxn = (int) 1e5 + 10;\n\nusing namespace std;\n\nint n;\nmap < int, ll > m[5];\nint k;\n\nint main () {\n    #ifdef LOCAL\n    freopen (""a.in"", ""r"", stdin);\n    freopen (""a.out"", ""w"", stdout);\n    #endif\n    scanf(""%d %d\\n"", &n, &k);\n    ll ans = 0;\n    for(int i = 0, x; i < n; i++){\n        scanf(""%d"", &x);\n        if(abs(x) % k != 0){\n            m[0][x]++;\n        }else {\n            ans += m[1][x/k];\n            m[1][x] += m[0][x/k];\n            m[0][x]++;\n        }\n    }\n    cout << ans << endl;\n\n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n    #endif\n    return 0;\n}\n\n']","[0, 0, 0, 1, 1, 0, 0, 1, 0, 0]",1700,Let s solve this problem for fixed middle element of progression This means that if we fix element then the progression must consist of and elements It could not be possible for example if is not divisible by For fixed middle element one could find the number of sequences by counting how many elements are placed left from fixed element and how many are placed right from it and then multiplying this numbers To do this one could use two associative arrays and where for each key will be stored count of occurences of placed left or right respectively from current element This could be done with map structure Sum of values calculated as described above will give the answer to the problem Author solution 
There are n officers in the Army of Byteland Each officer has some power associated with him The power of the i th officer is denoted by p i As the war is fast approaching the General would like to know the strength of the army The strength of an army is calculated in a strange way in Byteland The General selects a random subset of officers from these n officers and calls this subset a battalion All 2 n subsets of the n officers can be chosen equally likely including empty subset and the subset of all officers The strength of a battalion is calculated in the following way Let the powers of the chosen officers be a 1 a 2 ldots a k where a 1 le a 2 le dots le a k The strength of this battalion is equal to a 1a 2 a 2a 3 dots a k 1 a k If the size of Battalion is leq 1 then the strength of this battalion is 0 The strength of the army is equal to the expected value of the strength of the battalion As the war is really long the powers of officers may change Precisely there will be q changes Each one of the form i x indicating that p i is changed to x You need to find the strength of the army initially and after each of these q updates Note that the changes are permanent The strength should be found by modulo 10 9 7 Formally let M 10 9 7 It can be shown that the answer can be expressed as an irreducible fraction p q where p and q are integers and q not equiv 0 bmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 leq x M and x q equiv p bmod M ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int mod = (int )(1e9) + 7;\nint rev2;\nmt19937 rnd(998244353);\nstruct dx {\n\tint sz;\n\tint d, d2, d22;\n\tdx() {}\n\tdx(int sz, int d, int d2, int d22) : sz(sz), d(d), d2(d2), d22(d22) {}\n \n};\n \nstruct node{\n\tnode* son[2];\n\tdx x;\n\tint w;\n\tpair<int, int> d, mx;\n};\nnode STK[2000001], *head = STK;\nnode* root;\nint rev[600001];\nint n;\n \nnode* NewNode(pair<int, int> d) {\n\tnode* p = ++ head;\n\tp -> w = rnd();\n\tp -> d = d;\n\tp -> mx = d;\n\tp -> x = dx(1, 0, 1LL * rev2 * d.first % mod, 1LL * rev2 * d.first % mod);\n\treturn p;\n}\ndx operator + (const dx& p1, const dx& p2) {\n\tdx p;\n\tp.sz = p1.sz + p2.sz;\n\tp.d2 = (1LL * p1.d2 * rev[p2.sz] % mod + p2.d2) % mod; \n\tp.d22 = (p1.d22 + 1LL * rev[p1.sz] * p2.d22 % mod) % mod;\n\tp.d = (p1.d + p2.d + 1LL * p1.d2 * p2.d22) % mod;\n\treturn p;\n}\n \nvoid update(node* p) {\n\tp -> x = dx(1, 0, 1LL * rev2 * (p -> d).first % mod, 1LL * rev2 * (p ->d).first %  mod);\n\tp -> mx = p -> d;\n\tif (p -> son[0]) {\n\t\tp -> x = p -> son[0] -> x + p -> x;\n\t\tp -> mx = max(p -> mx, p -> son[0] -> mx);\n\t}\n\tif (p -> son[1]) {\n\t\tp -> x = p -> x + p -> son[1] -> x;\n\t\tp -> mx = max(p -> mx, p -> son[1] -> mx);\n\t}\n}\n \nnode* Merge(node* a, node* b) {\n\tif (!a) return b;\n\tif (!b) return a;\n\tif (a -> w > b -> w) {\n\t\ta -> son[1] = Merge(a -> son[1], b);\n\t\tupdate(a);\n\t}\n\telse {\n\t\tb -> son[0] = Merge(a, b -> son[0]);\n\t\tupdate(b);\n\t}\n\treturn a -> w > b -> w ? a : b;\n}\n \npair<node*, node*> Split(node* a, pair<int, int> rk) {\n\tpair<node*, node*> tmp;\n\tif (!a) return make_pair((node*)(0), (node*)(0));\n\tpair<int, int> leftsum = a -> son[0] ? max(a -> son[0] -> mx, a -> d) : a -> d;\n\tif (leftsum < rk) {\n\t\ttmp = Split(a -> son[1], rk);\n\t\ta -> son[1] = tmp.first;\n\t\tupdate(a);\n\t\treturn make_pair(a, tmp.second);\n\t}\n\telse {\n\t\ttmp = Split(a -> son[0], rk);\n\t\ta -> son[0] = tmp.second;\n\t\tupdate(a);\n\t\treturn make_pair(tmp.first, a);\n\t}\n}\npair<int, int> b[600001];\nint a[600001];\nint ksm(int x, int y) {\n\tint sum = 1;\n\tfor (; y; y >>= 1) {\n\t\tif (y & 1) sum = 1LL * sum * x % mod;\n\t\tx = 1LL * x * x % mod;\n\t}\n\treturn sum;\n}\n \nvoid gapprint(node* p) {\n\tprintf(""%d %d\\n"", (p ->d).first, (p ->d).second);\n\tif (p -> son[0]) gapprint(p -> son[0]);\n\tif (p -> son[1]) gapprint(p -> son[1]);\n}\n \nint main( ) {\n\tint x, y, q;\n\tscanf(""%d"", &n);\n\trev2 = ksm(2, mod - 2);\n\trev[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\trev[i] = 1LL * rev[i - 1] * rev2 % mod;\n \n \n\tfor (int i = 1; i <= n; i ++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tb[i] = make_pair(a[i], i);\n\t}\n\tsort(b + 1, b + 1 + n);\n\troot = 0;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tnode* tmp = NewNode(b[i]);\n\t\troot = Merge(root, tmp);\n\t}\n \n\tscanf(""%d"", &q);\n \n\tprintf(""%d\\n"", (root -> x).d);\n\twhile (q --) {\n\t\tscanf(""%d %d"", &x, &y);\n\t\tpair<node*, node*> l = Split(root, make_pair(a[x], x));\n\t\tpair<node*, node*> r = Split(l.second, make_pair(a[x], x + 1));\n\t\troot = Merge(l.first, r.second);\n\t\t\n\t\ta[x] = y;\n\t\tl = Split(root, make_pair(a[x], x + 1));\n\t\tnode* tmp = NewNode(make_pair(a[x], x));\n\t\troot = Merge(l.first, Merge(tmp, l.second));\n\t\tprintf(""%d\\n"", (root -> x).d);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2800,First lets try to find the initial strength of the army Let be the powers of officers in sorted order Consider a pair and find how much it contributes to the answer the term will be present in the strength of the subsets in which both and are present and there is no such that Probability of this happening is By linearity of expectation we can say that the contribution of to the strength of the army is So the strenth of the army can be written as where We can keep a sorted array having we can maintain a prefix sum of so But this will not help in handling the updtes To support updates we need to process queries offline and use coordinate compression such that all powers lie in range We can build a segment tree on the compressed powers For each node of the segment tree let its range be consider that powers mapped values by coordinate compression line in the range of this node At each node we need to maintain 4 values If we map each power to a unique value the computation for this values at leaf node is trivial If some power in the initial set is mapped to s then values for this node are as follows if no power in the initial set maps to s all these values are set to zero Lets try to compute these 4 values for non leaf nodes of the segment tree lc and rc denote left and right children of the current node If we try to write break these values in terms of their counterparts in lc and rc we can easily write them as Whenver we get a query we will need to update 2 leaves reduce count of the power for old and increase the count of the new power Answer to our problem would be at root node of the segment tree Time Complexity 
You are given a weighted directed graph with n vertices and m edges Each vertex in the graph can be either highlighted or normal Initially all vertices are normal The cost of the graph is defined as the minimum sum of edge weights that need to be selected so that from each normal vertex one can reach at least one highlighted vertex using the selected edges only If it is not possible to select the edges the cost is 1 instead Your task is to compute the cost of the graph after each of the q queries The queries can be of two types v i makes vertex v i highlighted it is guaranteed that the vertex is normal before the query v i makes vertex v i normal it is guaranteed that the vertex is highlighted before the query Output the cost of the graph after each of the q queries ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \n#define int long long \nusing namespace std;\nconst int N = 1 << 20;\n\n#define INF 1000000001\nint q; \nint pts[N];\nvi e[N];\n\nll val[N];\n\nnamespace lsq { // https://www.cnblogs.com/lsq147/p/17029129.html\n\nint n, m;\nconst int maxn=200005,maxm=400005;\nstruct Val{\n\tint u,v,w;\n\tVal(int u=0,int v=0,int w=0):\n\t\tu(u),v(v),w(w){}\n\tVal operator += (const int o){\n\t\tthis->w=this->w+o;return *this;\n\t}\n\tbool operator < (const Val o)const{\n\t\treturn w<o.w;\n\t}\n};\nstruct Node{\n\tint l,r,dis,laz;Val v;\n\tNode(int l=0,int r=0,int dis=0,int laz=0,Val v=Val()):\n\t\tl(l),r(r),dis(dis),laz(laz),v(v){}\n}P[maxm];\nint tot;\nvoid push(int x,int laz){\n\tP[x].laz+=laz;\n\tP[x].v+=laz;\n}\nvoid pushdown(int x){\n\tif(!P[x].laz)return;\n\tpush(P[x].l,P[x].laz);\n\tpush(P[x].r,P[x].laz);\n\tP[x].laz=0;\n}\nvoid pushup(int x){\n\tif(P[P[x].l].dis<P[P[x].r].dis)\n\t\tstd::swap(P[x].l,P[x].r);\n\tP[x].dis=P[P[x].r].dis+1;\n}\nint newnode(Val v){\n\tP[++tot]=Node(0,0,1,0,v);\n\treturn tot;\n}\nvoid merge(int&x,int l,int r){\n\tif(!l||!r)return x=l|r,void();\n\tpushdown(l);pushdown(r);\n\tif(P[r].v<P[l].v)l^=r^=l^=r;\n\tx=l;merge(P[x].r,P[l].r,r);\n\treturn pushup(x);\n}\nvoid pop(int&x){\n\tpushdown(x);\n\tmerge(x,P[x].l,P[x].r);\n}\nint rt[maxn*2];\nint fa[maxn*2];\nint vis[maxn*2],cnt;\nint st[maxn],tp;\nint rn;\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nint val[maxn*2];\nint son[maxn*2],bro[maxn*2],pa[maxn*2];\nvoid ade(int u,int v){\n//\tprintf(""ade %d %d %lld\\n"",u,v,val[v]);\n\tbro[v]=son[u],son[u]=v;pa[v]=u;\n}\nvoid dfs(int u){\n\tif(vis[u]&&vis[u]<cnt)return void();\n\tif(vis[u]==cnt){\n\t\t++rn;\n\t\twhile(st[tp+1]!=u){\n\t\t\tfa[st[tp]]=rn;ade(rn,st[tp]);\n\t\t\tmerge(rt[rn],rt[rn],rt[st[tp]]);\n\t\t\t--tp;\n\t\t}\n\t\tu=rn;\n\t}\n\tvis[u]=cnt,st[++tp]=u;\n\twhile(rt[u]&&find(P[rt[u]].v.v)==u)pop(rt[u]);\n\tif(!rt[u])return val[u]=INF,ade(0,u);\n\tVal tmp=P[rt[u]].v;val[u]=tmp.w;\n\tpop(rt[u]);push(rt[u],-tmp.w);\n\tdfs(find(tmp.v));\n\tif(find(u)==u)ade(0,u);\n\treturn;\n}\nconst int mod=998244353;\nint iac[maxn],fac[maxn];\nint getans(int u){\n\tint sz=(son[u]==0);\n\tfor(int v=son[u];v;v=bro[v]){\n\t\te[u].emplace_back(v);\n\t\tint o=getans(v);\n\t\tsz+=o;\n\t}\n\treturn sz;\n}\nvoid solve(void){\n\tcin >> n >> m >> q;\n\trn=n;\n\tfac[0]=fac[1]=iac[0]=iac[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t\tiac[i]=1ll*(mod-mod/i)*iac[mod%i]%mod;\n\tfor(int i=2;i<=n;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod,iac[i]=1ll*iac[i-1]*iac[i]%mod;\n\tfor(int i=1;i<=n*2;++i)fa[i]=i;\n\tfor(int i=1;i<=m;++i){\n\t\tint u,v,w;\n\t\tcin >> u >> v >> w;\n\t\tmerge(rt[u],rt[u],newnode(Val(u,v,w)));\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\t++cnt;dfs(i);tp=0;\n\t\t}\n\t}\n\tgetans(0);\n}\nint Main(){\n\tsolve();\n\treturn 0;\n}\n\n}\n\nint siz[N], dfn[N], en[N], mp[N], dep[N], hv[N], top[N], idt;\nint fa[N], total;\n \nvoid dfs1(int x) {\n\tsiz[x] = 1;\n\tfor(auto &v : e[x]) if(v != fa[x]) {\n\t\tfa[v] = x, dep[v] = dep[x] + 1, dfs1(v);\n\t\tsiz[x] += siz[v];\n\t\tif(siz[v] > siz[hv[x]]) \n\t\t\thv[x] = v;\n\t}\n}\n \nvoid dfs2(int x) {\n\tdfn[x] = ++idt;\n\tmp[idt] = x;\n\tif(hv[x]) {\n\t\ttop[hv[x]] = top[x];\n\t\tdfs2(hv[x]);\n\t}\n\tfor(auto&v : e[x]) if(v != fa[x] && v != hv[x]) {\n\t\ttop[v] = v, dfs2(v);\n\t}\n\ten[x] = idt;\n}\n\nvoid dfs(int x) {\n\ttotal = max(total, x);\n\tfor(auto &v : e[x]) {\n\t\tfa[v] = x;\n\t\tdfs(v); \n\t}\n}\n\nint mn[N], tag[N];\nll sum[N][2];\nvoid adt(int x, int w) {\n\ttag[x] += w;\n\tmn[x] += w; \n}\nvoid upd(int x) {\n\tmn[x] = min(mn[x * 2], mn[x * 2 + 1]);\n\tsum[x][0] = sum[x][1] = 0;\n\tL(o, 0, 1) {\n\t\tif(mn[x * 2] == mn[x]) sum[x][o] += sum[x * 2][o];\n\t\tif(mn[x * 2 + 1] == mn[x]) sum[x][o] += sum[x * 2 + 1][o];\n\t}\n}\nvoid push(int x) {\n\tif(tag[x]) adt(x * 2, tag[x]), adt(x * 2 + 1, tag[x]), tag[x] = 0;\n}\n \nvoid add(int x, int L, int R, int l, int r, int w) {\n\tif(l <= L && R <= r) {\n\t\tadt(x, w);\n\t\treturn ;\n\t}\n\tpush(x);\n\tint mid = (L + R) >> 1;\n\tif(l <= mid) add(x * 2, L, mid, l, r, w);\n\tif(r > mid) add(x * 2 + 1, mid + 1, R, l, r, w);\n\tupd(x);\n}\n \nvoid build(int x, int L, int R) {\n\tif(L == R) {\n\t\tsum[x][0] = val[L];\n\t\tsum[x][1] = val[L] == INF;\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tbuild(x * 2, L, mid);\n\tbuild(x * 2 + 1, mid + 1, R);\n\tupd(x);\n}\n\nint vis[N];\n\nint cnt[N];\nsigned main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tlsq :: Main();\n\tdfs(0);\n\t++total;\n\tdfs1(0);\n\tdfs2(0);\n\tL(i, 1, total) {\n\t\tval[i] = lsq :: val[mp[i]];\n\t}\n\tfa[0] = -1;\n\t\n\tbuild(1, 1, total);\n\tint scnt = 0;\n\twhile(q--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint pos;\n\t\tcin >> pos;\n\t\tint add = 0;\n\t\tif(s == ""+"") {\n\t\t\tadd = 1;\n\t\t\tvis[pos] = 1;\n\t\t} else {\n\t\t\tadd = -1;\n\t\t\tvis[pos] = 0;\n\t\t}\n\t\tscnt += add;\n\t\tfor(int x = pos; x != -1; x = fa[top[x]]) {\n\t\t\t::add(1, 1, total, dfn[top[x]], dfn[x], add);\n//\t\t\tL(i, dfn[top[x]], dfn[x]) {\n//\t\t\t\tcnt[i] += add;\n//\t\t\t}\n\t\t}\n\t\t\n//\t\tif(scnt == 0) {\n//\t\t\tcout << -1 << \'\\n\';\n//\t\t}\n\t\t\n\t\tif(mn[1] > 0) {\n\t\t\tcout << 0 << \'\\n\';\n\t\t} else if(sum[1][1]) {\n\t\t\tcout << -1 << \'\\n\';\n\t\t} else {\n\t\t\tcout << ::sum[1][0] << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 1]",3500,TutorialLet s unfold all the edges now we need to ensure that all regular vertices are reachable from the selected vertices First you should familiarize yourself with the algorithm for finding the ordered minimum spanning tree also known as the Edmonds algorithm I will refer to his work here and without knowledge of it the solution cannot be understood Next it is worth noting that the compressions in the process of this algorithm almost do not depend on the root and all compressions can be performed as if there is no root previously creating dummy edges from to for from to and from vertex to vertex with a cost of Then after all the compressions only one vertex will remain Note that the difference from Edmonds algorithm is that if at any step of the algorithm the minimum edge from a vertex leads to the root compression is not necessary So let s maintain a tree in which each vertex corresponds to its corresponding compressed vertex or to the original vertex and the children of vertex are all the vertices that we compressed to obtain vertex It is implied that with each compression we create a new vertex Let s call the cost of vertex the minimum cost of an edge leaving vertex in the process of Edmonds algorithm taking into account changes in edge costs during compression in Edmonds algorithm Then we need to maintain the sum of the costs of the vertices in the tree in the subtrees of which there are no selected vertices where the selected vertices can only be leaves This can be easily done using a segment tree 
Vlad went into his appartment house entrance now he is on the 1 th floor He was going to call the elevator to go up to his apartment There are only two elevators in his house Vlad knows for sure that the first elevator is currently on the floor a it is currently motionless the second elevator is located on floor b and goes to floor c b ne c Please note if b 1 then the elevator is already leaving the floor 1 and Vlad does not have time to enter it If you call the first elevator it will immediately start to go to the floor 1 If you call the second one then first it will reach the floor c and only then it will go to the floor 1 It takes x y seconds for each elevator to move from floor x to floor y Vlad wants to call an elevator that will come to him faster Help him choose such an elevator ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    int a, b, c;\n    cin >> a >> b >> c;\n\n    int t1 = a - 1;\n    int t2 = abs(b - c) + c - 1;\n\n\n    if(t1 < t2)\n        done(1);\n\n    if(t1 > t2)\n        done(2);\n\n    done(3);\n\n\n    \n    \n\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,You had to to calculate the time that each elevator would need and compare them Let the time required by the first elevator be and the time required by the second one be Then the answer is if if and if 
To play the game Alice draws a straight line and marks n points on it indexed from 1 to n Initially there are no arcs between the points so they are all disjoint After that Alice performs m operations of the following type She picks three integers a i d i 1 le d i le 10 and k i She selects points a i a i d i a i 2d i a i 3d i ldots a i k i cdot d i and connects each pair of these points with arcs After performing all m operations she wants to know the number of connected components dagger these points form Please help her find this number dagger Two points are said to be in one connected component if there is a path between them via several possibly zero arcs and other points ,"['#include <bits/stdc++.h>using namespace std;int f[200020];int z;int F(int x){\treturn f[x] != x ? f[x] = F(f[x]) : x;}void U(int x, int y){\tx = F(x);\ty = F(y);\tif (x != y)\t{\t\tz--;\t\tf[x] = y;\t}}int b[11][200020];int main(){\tint t;\tcin >> t;\tfor (int tt = 0; tt < t; tt++)\t{\t\tint n, m;\t\tcin >> n >> m;\t\tfor (int i = 0; i < n + 5; i++)\t\t{\t\t\tf[i] = i;\t\t\tfor (int d = 0; d < 11; d++)\t\t\t{\t\t\t\tb[d][i] = 0;\t\t\t}\t\t}\t\tz = n;\t\tfor (int i = 0; i < m; i++)\t\t{\t\t\tint a, d, k;\t\t\tcin >> a >> d >> k;\t\t\tb[d][a]++;\t\t\tb[d][a + d * k]--;\t\t}\t\tfor (int d = 1; d <= 10; d++)\t\t{\t\t\tfor (int i = 1; i <= d; i++)\t\t\t{\t\t\t\tint s = 0;\t\t\t\tfor (int j = i; j <= n; j += d)\t\t\t\t{\t\t\t\t\ts += b[d][j];\t\t\t\t\tif (s > 0)\t\t\t\t\t{\t\t\t\t\t\tU(j, j + d);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tcout << z << endl;\t}\treturn 0;}']","[0, 1, 0, 1, 0, 1, 0, 0, 0, 1]",1800,The main idea is to take advantage of the low upper bound of and apply the Disjoint Set Union We will consider which denotes the number of ranges that contain the node in connection by the triplets ranges with as and is not and which denotes the node that represents an overall connected component of which node is part of for now The size of both and is We will maintain two other arrays and which store the number of triplets with as and respectively and with as to help us maintain the beginning and end of ranges We will now apply Disjoint Set Union For each th triplet we assume will be the parent node of the Set created by The transitions of are as follows 1 if max of for all are the same as just with some possible changes These changes are due to being the start or the end of some triplet with as So let us start with as If is non zero then perform a union operation of DSU between the node and increment by and assign as This unites the ranges over the node 2 if max of we do the same as above rather than doing for all we would restrict ourselves with from to The net time complexity updation of value by and union operations due to union of with over all incrementing values by copying values in worst case 
Ron is a happy owner of a permutation a of length n A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array Ron s permutation is subjected to m experiments of the following type r i p i This means that elements in range 1 r i in other words the prefix of length r i have to be sorted in ascending order with the probability of p i All experiments are performed in the same order in which they are specified in the input data As an example let s take a look at a permutation 4 2 1 5 3 and an experiment 3 0 6 After such an experiment with the probability of 60 ,"['//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<"" "";cout<<""\\n"";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int t;\n    cin>>t;\n    while(t--)\n    {\n       int n, m;\n       cin>>n>>m;\n       int ar[n+1];\n       for(int i=1;i<=n;i++)\n       cin>>ar[i];\n       int l=0;\n       for(int i=n;i>0;i--)\n       {\n           if(ar[i]!=i)\n           {\n               l=i;\n               break;\n           }\n       }\n       lld ans=1.0, ad=1.0;\n       while(m--)\n       {\n           int r;\n           lld p;\n           cin>>r>>p;\n           if(r>=l)\n           ans*=(ad-p);\n       }\n       if(l==0)\n       cout<<1<<""\\n"";\n       else\n       cout<<ad-ans<<""\\n"";\n    }\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1500,Let s first define some variable which will be equal to the last unsorted number the largest for which Now we can see that we are not interested in experiments with To get the answer we just need to multiply the remaining This number will indicate the probability that all the remaining experiments failed Since we need to deduce the probability of success we can subtract the resulting number from one 
Consider a hallway which can be represented as the matrix with 2 rows and n columns Let s denote the cell on the intersection of the i th row and the j th column as i j The distance between the cells i 1 j 1 and i 2 j 2 is i 1 i 2 j 1 j 2 There is a cleaning robot in the cell 1 1 Some cells of the hallway are clean other cells are dirty the cell with the robot is clean You want to clean the hallway so you are going to launch the robot to do this After the robot is launched it works as follows While at least one cell is dirty the robot chooses among those which are dirty moves there and cleans it so the cell is no longer dirty After cleaning a cell the robot again finds the closest dirty cell and so on This process repeats until the whole hallway is clean However there is a critical bug in the robot s program If at some moment there are multiple closest to the robot s current position dirty cells the robot malfunctions You want to clean the hallway in such a way that the robot doesn t malfunction you can clean some possibly zero of the dirty cells yourself However you don t want to do too much dirty work yourself while you have this nice smart yet buggy robot to do this Note that you cannot make a clean cell dirty Calculate the maximum possible number of cells you can leave dirty before launching the robot so that it doesn t malfunction ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include ""library/debug.cpp""\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<string> s(2);\n    for (int i = 0; i < 2; i++) {\n        cin >> s[i];\n        s[i] += ""0"";\n    }\n    vector dp(2, vector<int>(2, -10101010));\n    dp[0][0] = 0;\n    dp[0][s[1][0] - \'0\'] = 0;\n    for (int i = 0; i < n; i++) {\n        vector new_dp(2, vector<int>(2, -10101010));\n        for (int x = 0; x < 2; x++) {\n            new_dp[x][s[x ^ 1][i + 1] - \'0\'] = max(new_dp[x][s[x ^ 1][i + 1] - \'0\'], dp[x][0] + (s[x][i + 1] - \'0\'));\n            new_dp[x][0] = max(new_dp[x][0], dp[x][0] + (s[x][i + 1] - \'0\'));\n            new_dp[x ^ 1][0] = max(new_dp[x ^ 1][0], dp[x][1] + 1 + (s[x ^ 1][i + 1] - \'0\'));\n        }\n        swap(dp, new_dp);\n    }\n    int ans = -1;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    cout << ans << \'\\n\';\n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2400,Why did the author choose the width of the hallway to be only Well in that case you can show that the robot will never move to the left while cleaning That is not true on width already When does the robot break Let the robot currently be in the cell indexed and the next column with a dirty cell be possibly The robot breaks only if both and are dirty That helps us to do a dynamic programming solution Since we can only care about next columns we would want to have some the largest number of dirty cells we can leave to the robot if we processed the first columns of the hallway and are currently standing in the th row of the th column Maybe with some additional states of the current or the next columns We want the dp to maintain the invariant that everything to the left of the th column is cleaned in such a way the robot can reach the cell We can choose when to fix the th column either maintain it being correct prior to entering the state or handling it in the transition to the next one I chose the former option There probably exists a million different dps that work I ll describe the one I did Let be the largest number of dirty cells that we can leave to the robot if we fixed which of the dirty cells in the first columns inclusive are cleaned by hand the robot reaches the cell from the left is true if the cell in the opposite row of the th column is dirty The transitions handle what to do with the dirty cells in the st column and where the robot goes based on that In particular there are the following transitions if is true then we have to clean the cell and the robot will move into otherwise the robot breaks from having two options if is false then let s say that the robot doesn t break immediately but moves into the next column in a unique way it moves horizontally first then possibly vertically we can leave the next column as is and the robot will move into if the cell is clean or if it s dirty if is false then we can clean the cell and the robot will move into Since we maintained the invariant that the th column is valid we can update the answer from all four states in the last column Overall complexity 
One morning Polycarp woke up and realized that 1543 is the most favorite number in his life The first thing that Polycarp saw that day as soon as he opened his eyes was a large wall carpet of size n by m cells n and m are even integers Each cell contains one of the digits from 0 to 9 Polycarp became curious about how many times the number 1543 would appear in all layers text of the carpet when traversed text The first layer of a carpet of size n times m is defined as a closed strip of length 2 cdot n m 2 and thickness of 1 element surrounding its outer part Each subsequent layer is defined as the first layer of the carpet obtained by removing all previous layers from the original carpet ,"['#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;const int N = 1010;char e[N][N];void solve() {\tint n, m;\tcin >> n >> m;\tfor (int i = 1; i <= n; i++) {\t\tfor (int j = 1; j <= m; j++) {\t\t\tcin >> e[i][j];\t\t}\t}\tint ans = 0;\tfor (int x = 1; x <= min(n, m) / 2; x++) {\t\tvector <char> v;\t\tfor (int j = x; j <= m + 1 - x; j++) {\t\t\tv.push_back(e[x][j]);\t\t}\t\tfor (int j = x + 1; j <= n + 1 - x; j++) {\t\t\tv.push_back(e[j][m + 1 - x]);\t\t}\t\tfor (int j = m - x; j >= x; j--) {\t\t\tv.push_back(e[n + 1 - x][j]);\t\t}\t\tfor (int j = n - x; j > x; j--) {\t\t\tv.push_back(e[j][x]);\t\t}\t\tfor (int i = 0; i < (int)v.size(); i++) {\t\t\tvector<int> a(4);\t\t\ta[0] = i;\t\t\tfor (int j = 1; j < 4; j++) {\t\t\t\ta[j] = (a[j - 1] + 1) % (int)v.size();\t\t\t}\t\t\tif (v[a[0]] == \'1\' && v[a[1]] == \'5\' &&\t\t\t\tv[a[2]] == \'4\' && v[a[3]] == \'3\') {\t\t\t\t\tans++;\t\t\t\t}\t\t}\t}\tcout << ans << ""\\n"";}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1300,TutorialWe will go through all layers of the carpet adding to the answer the number of records encountered on each layer To do this we can iterate over for example the top left cells of each layer having the form for all in the range and then traverse the layer with a naive algorithm writing the encountered digits into some array Then traverse the array and count the occurrences in that layer Also when traversing the array we should take into account the cyclic nature of the layer remembering to check for possible occurrences of containing a starting cell Complexity 
You are given a tree consisting exactly of n vertices Tree is a connected undirected graph with n 1 edges Each vertex v of this tree has a value a v assigned to it Let dist x y be the distance between the vertices x and y The distance between the vertices is the number of edges on the simple path between them Let s define the cost of the tree as the following value firstly let s fix some vertex of the tree Let it be v Then the cost of the tree is sum limits i 1 n dist i v cdot a i Your task is to calculate the of the tree if you can choose v arbitrarily ,"['#include<cstdio>\n#include<vector>\nusing namespace std;\nvector<int>e[200001];\nlong long dp0[200001],s[200001];\nlong long a[200001];\nvoid dfs0(int x,int lt){\n    s[x]=a[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs0(y,x);\n        dp0[x]+=dp0[y]+s[y];\n        s[x]+=s[y];\n    }\n}\nlong long an;\nvoid dfs(int x,int lt,long long v){\n    if(v+dp0[x]>an)an=v+dp0[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs(y,x,v+dp0[x]-dp0[y]-s[y]*2+s[1]);\n    }\n}\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++)scanf(""%lld"",&a[i]);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(""%d%d"",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs0(1,1);\n    dfs(1,1,0);\n    printf(""%lld\\n"",an);\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1900,Firstly let s calculate the answer let it be for some fixed vertex Let this vertex be the vertex Just run simple and calculate the result using the formula from the problem statement Also let s calculate the sum of values let the sum in the subtree of the vertex be in each subtree of the given tree if its root is the vertex It can be easily done with simple dynamic programming And now the magic part let s apply the technique which is called at least we called it so Let s maintain the correct values in subtrees at each step of our algorithm How will values and the answer change if we will go through the edge The following sequence of changes will change all values correctly Firstly it can be seen that will decrease by because the distance to each vertex in this subtree will decrease by one then will decrease by because we change the root of the tree we need this step to maintain the correct values then will increase by because the distance to each vertex in this subtree will increase by one and then will increase by because we change the root of the tree we need this step to maintain the correct values So we can recalculate all the values we need if we go through the edge So now we can write another one to try to update the answer for each vertex as a root as the chosen vertex 
There is a positive integer 1 le x le 10 9 that you have to guess In one query you can choose two positive integers a neq b As an answer to this query you will get gcd x a x b where gcd n m is the greatest common divisor of the numbers n and m To guess one hidden number x you are allowed to make no more than 30 queries ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nconst int TEST=0;\nint x;\ninline int ask(int a,int b)\n{\n\tcout << ""? "" << a << "" "" << b << endl;\n\tint k;\n\tif(!TEST)\n\t{\n\t\tcin >> k;\n\t\treturn k;\n\t}\n\tif(TEST)\n\t{\n\t\tcout << __gcd(x+a,x+b) << endl;\n\t\treturn __gcd(x+a,x+b);\n\t}\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tif(TEST) cin >> x;\n\t\tint now=0;\n\t\tfor(int i=0;i<=29;i++)\n\t\t{\n\t\t\tint a=1<<i,b=(3<<i);\n\t\t\tint x=ask(a-now,b-now);\n\t\t\tif(x%(a+a)==0) now+=a;\n\t\t}\n\t\tcout << ""! "" << now << endl;\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",2000,EditorialSolution 1Let s iteratively find the remainder of each power of Initially we know that If we know that then how do we find To do that let s ask If then else Using this algorithm we will find which is just It takes exactly queries Solution 2Let s consider a set of pairwise coprime numbers Their that s why Let s find each of these numbers To do that for each we can ask the query is If the is a multiple of some number from our set then this number is After that we can use the chinese remainder theorem to find that gives the same remainders for numbers from the set This solution asks only queries Observation 1 It s enough to make only queries because if we did not find anything for then we can guarantee that will do Observation 2 All moduli are small that s why it is possible to use a simplified CRT check the implementation 
You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>haveInt;\nvector<int>need;\nvector<int>answer;\n\nvoid prnt() {\n\tfor (auto x : answer)cout << x;\n\texit(0);\n}\n\nvoid formAll() {\n\twhile (!haveInt.empty()) {\n\t\tmap<int, int>::iterator it = haveInt.end();\n\t\tit--;\n\t\tanswer.push_back(it->first);\n\t\tit->second -= 1;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t}\n\tprnt();\n}\n\nvoid tryNum(int a) {\n\tif (haveInt.size()==0)\n\t\tprnt();\n\tmap<int, int>::iterator it = haveInt.lower_bound(need[a]);\n\tif (it != haveInt.end() && it->first == need[a]) {\n\t\tint x = it->first;\n\t\tit->second--;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t\tanswer.push_back(x);\n\t\ttryNum(a + 1);\n\t\thaveInt[x]++;\n\t\tanswer.pop_back();\n\t}\n\tit = haveInt.lower_bound(need[a]);\n\tif (it == haveInt.begin())return;\n\tit--;\n\tanswer.push_back(it->first);\n\tit->second--;\n\tif (it->second == 0)\n\t\thaveInt.erase(it);\n\tformAll();\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tswap(s1, s2);\n\tfor (auto x : s2)\n\t\thaveInt[x - \'0\']++;\n\tif (s2.length() < s1.length())\n\t\tformAll();\n\tfor (auto x : s1)\n\t\tneed.push_back(x - \'0\');\n\ttryNum(0);\n\n\t\n\treturn 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1700,Let s construct the answer digit by digit starting from the leftmost Obviously we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step Precalc number of digits in number Iterate over all possible digits starting from the greatest For each digit check if it s possible to put it in this position For this you construct minimal suffix greedily put the lowest digit and compare the resulting number with number If it became less or equal then proceed to the next digit Overall complexity where is digits from to 
It was the third month of remote learning Nastya got sick of staying at dormitory so she decided to return to her hometown In order to make her trip more entertaining one of Nastya s friend presented her an integer array a Several hours after starting her journey home Nastya remembered about the present To entertain herself she decided to check are there four indices x y z w such that a x a y a z a w Her train has already arrived the destination but she still hasn t found the answer Can you help her unravel the mystery ,"['/**\n *    author:  tourist\n *    created: 13.03.2021 12:04:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  int mx = *max_element(a.begin(), a.end()) + 1;\n  vector<int> p1(mx, -1);\n  vector<int> p2(mx, -1);\n  vector<int> p3(mx, -1);\n  for (int i = 0; i < n; i++) {\n    if (p1[a[i]] == -1) {\n      p1[a[i]] = i;\n      continue;\n    }\n    if (p2[a[i]] == -1) {\n      p2[a[i]] = i;\n      continue;\n    }\n    if (p3[a[i]] == -1) {\n      p3[a[i]] = i;\n      continue;\n    }\n    cout << ""YES"" << \'\\n\';\n    cout << p1[a[i]] + 1 << "" "" << p2[a[i]] + 1 << "" "" << p3[a[i]] + 1 << "" "" << i + 1 << \'\\n\';\n    return 0;\n  }\n  vector<int> ind;\n  int two = -1;\n  for (int i = 0; i < mx; i++) {\n    if (p1[i] == -1) {\n      continue;\n    }\n    ind.push_back(p1[i]);\n    if (p2[i] == -1) {\n      continue;\n    }\n    if (two != -1) {\n      cout << ""YES"" << \'\\n\';\n      cout << p1[two] + 1 << "" "" << p1[i] + 1 << "" "" << p2[two] + 1 << "" "" << p2[i] + 1 << \'\\n\';\n      return 0;\n    }\n    two = i;\n  }\n  vector<pair<int, int>> met(2 * mx, make_pair(-1, -1));\n  sort(ind.begin(), ind.end());\n  if (two != -1) {\n    met[two + two] = make_pair(p1[two], p2[two]);\n  }\n  for (int i = 0; i < (int) ind.size(); i++) {\n    for (int j = i + 1; j < (int) ind.size(); j++) {\n      int sum = a[ind[i]] + a[ind[j]];\n      if (met[sum].first != -1) {\n        cout << ""YES"" << \'\\n\';\n        cout << met[sum].first + 1 << "" "" << met[sum].second + 1 << "" "" << ind[i] + 1 << "" "" << ind[j] + 1 << \'\\n\';\n        return 0;\n      }\n      met[sum] = make_pair(ind[i], ind[j]);\n    }\n  }\n  cout << ""NO"" << \'\\n\';\n  return 0;\n}\n']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",1800,Let s prove that if there re at least four different pairs indices with the common sum then there necessarily will be two pairs such that all four indices in them are unique Let s analyze some cases There re four pairs of the form with sum Then from which we can conclude that and it means that pairs and are suitable as answer There re three pairs of the form and the fourth pair doesn t contain index Then whatever the fourth pair is it necessarily doesn t contain index and at least one of indices which means we can take as answer pairs and one of three that contain Other cases are analyzed in the same way To make sure that answer always exists among such four pairs we can imagine graph where vertices are indices and there is an edge between two vertices if the corresponding pair of indices has sum If such a graph has at least four edges and the degree of all vertices is at most two we excluded the larger degrees by examining the previous cases then there will always be two edges with disjoint ends How to find answer using this Let s launch simple bruteforce which for every sum will save all found pairs with such sum and for each pair check if there s another already found pair with the same sum and such indices that all four indices in these two pairs are unique Let s notice it works in because once for some sum we find the fourth pair we can immediately print the answer And if the answer is then we ve done no more than iterations of bruteforce 
Hu Tao being the little prankster she is has tried to scare you with this graph problem You are given a connected undirected graph of n nodes with m edges You also have q queries Each query consists of two nodes a and b Initially all edges in the graph have a weight of 0 For each query you must choose a simple path starting from a and ending at b Then you add 1 to every edge along this path Determine if it s possible after processing all q queries for all edges in this graph to have an even weight If so output the choice of paths for each query If it is not possible determine the smallest number of extra queries you could add to make it possible It can be shown that this number will not exceed 10 18 under the given constraints A simple path is defined as any path that does not visit a node more than once An edge is said to have an even weight if its value is divisible by 2 ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q, qu[300005], qv[300005], par[300005], dep[300005], C[300005];\nvector<int> G[300005];\nbool vis[300005];\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\trep(i, G[v].size()) {\n\t\tint u = G[v][i];\n\t\tif(!vis[u]) {\n\t\t\tpar[u] = v; dep[u] = dep[v] + 1; dfs(u);\n\t\t}\n\t}\n}\n\nvector<int> A0, A1;\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, m) {\n\t\tint u, v;\n\t\tscanf(""%d%d"", &u, &v);\n\t\tG[v].push_back(u); G[u].push_back(v);\n\t}\n\tdfs(1);\n\t\n\tscanf(""%d"", &q);\n\trep(i, q) {\n\t\tscanf(""%d%d"", &qu[i], &qv[i]);\n\t\tC[qu[i]] ^= 1; C[qv[i]] ^= 1;\n\t}\n\tint tot = 0;\n\trep1(i, n) tot += C[i];\n\tif(tot != 0) {\n\t\tprintf(""NO\\n%d\\n"", tot / 2); return 0;\n\t}\n\tprintf(""YES\\n"");\n\trep(i, q) {\n\t\tint x = qu[i], y = qv[i];\n\t\tA0.clear(); A1.clear();\n\t\twhile(x != y) if(dep[x] > dep[y]) {\n\t\t\tA0.push_back(x); x = par[x];\n\t\t} else {\n\t\t\tA1.push_back(y); y = par[y];\n\t\t}\n\t\treverse(A1.begin(), A1.end());\n\t\tprintf(""%d\\n"", (int)A0.size() + (int)A1.size() + 1);\n\t\trep(j, A0.size()) printf(""%d "", A0[j]);\n\t\tprintf(""%d"", x);\n\t\trep(j, A1.size()) printf("" %d"", A1[j]);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 1]",2200,Let be the number of times appears in the queries If is odd for any then there does not exist an assignment of paths that will force all even edge weights To see why notice that one query will correspond to exactly one edge adjacent to If an odd number of paths are adjacent to this implies that at least one edge adjacent to will have an odd degree It turns out that this is the only condition that we need to check In other words if is even for all then there will exist an assignment of paths that will force all edge weights to be even Let s assume all is even We can find a solution by doing the following take any spanning tree of the graph and assign each query to be the path from to in this tree An intuitive way of thinking about this is the following Consider the case if the spanning tree is a line Then each query becomes a range and we re checking if all points in this range are covered an even number of times For all points to be covered an even number of times every point should occur an even number of times in the queries To generalize this to a tree when the first path to is incremented in order to make these values even again we will need later paths to also overlap the segment from to One way this can be done is if we use two paths to and to Notice that even if a new segment that makes the to path even makes some other edges odd the later queries will always fix these edges 
There is a country with n citizens The i th of them initially has a i money The government strictly controls the wealth of its citizens Whenever a citizen makes a purchase or earns some money they must send a receipt to the social services mentioning the amount of money they currently have Sometimes the government makes payouts to the poor all citizens who have strictly less money than x are paid accordingly so that after the payout they have exactly x money In this case the citizens don t send a receipt You know the initial wealth of every citizen and the log of all events receipts and payouts Restore the amount of money each citizen has after all events ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\nint tab[nax];\n\nmap <int,vector<pii>> mapa;\n\npii wyn[nax];\n\nvoid przepisz(vector <pii> &a, vector <pii> &b)\n{\n\tif ((int)a.size()>(int)b.size())\n\t\ta.swap(b);\n\tfor (pii i : a)\n\t\tb.push_back(i);\n\ta.clear();\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &tab[i]);\n\t\tmapa[tab[i]].push_back({0, i});\n\t}\n\tscanf(""%d"", &q);\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tint typ;\n\t\tscanf(""%d"", &typ);\n\t\tif (typ==1)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(""%d%d"", &a, &b);\n\t\t\tmapa[b].push_back({i, a});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(""%d"", &a);\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tauto it=mapa.begin();\n\t\t\t\tif ((*it).first>=a)\n\t\t\t\t\tbreak;\n\t\t\t\tprzepisz((*it).second, mapa[a]);\n\t\t\t\tmapa.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : mapa)\n\t\tfor (pii j : i.second)\n\t\t\twyn[j.second]=max(wyn[j.second], {j.first, i.first});\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%d "", wyn[i].second);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 1, 0, 1, 1, 0]",1600,For every citizen only the last query of type matters Moreover all queries before don t matter at all So the answer for each citizen is maximum of for last query of type for this citizen and maximum of all for queries of type after that We can calculate maximum for all suffices of queries of type and remember the last query of type for each citizen It can be implemented in time 
The Little Elephant very much loves sums on intervals This time he has a pair of integers and The Little Elephant has to find the number of such integers that the first digit of integer equals the last one in decimal notation For example such numbers as or will be included in the answer and or will not Help him and count the number of described numbers for a given pair and ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nll p[22];\nll f(ll n){\n\tstringstream ss;\n\tss<<n;\n\tstring s = ss.str();\n\tll res =  0;\n\tFOR(i,1,s.size()){\n\t\tint len = i;\n\t\tlen -= 2;\n\t\tif(len<0) len = 0;\n\t\tres += p[len]*9;\n\t}\n\tstring t = s;\n\tFOR(i,1,10){\n\t\tif(s[0]-\'0\' < i) break;\n\t\tif(s[0]-\'0\' == i){\n\t\t\tll val = 0;\n\t\t\tFOR(j,1,s.size()-1) val = 10 * val + s[j]-\'0\';\n\t\t\tval ++;\n\t\t\tif(s[s.size()-1]-\'0\' < i) val--;\n\t\t\tres += val;\n\t\t}else res += p[max(0,(int)s.size()-2)];\n\t}\n\treturn res;\n}\n\nbool good(ll n){\n\tstringstream ss;\n\tss<<n;\n\tstring s = ss.str();\n\treturn s[0]==s[s.size()-1];\n}\nll stupid(ll l,ll r){\n\tll res = 0;\n\tfor(ll i = l;i<=r;i++)\n\t\tif(good(i)) res++;\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tp[0]=1;\n\tFOR(i,1,20) p[i]=p[i-1]*10;\n\tll l,r;\n\tcin>>l>>r;\n\tif(l>r) swap(l,r);\n\tcout<<f(r)-f(l-1)<<endl;\n//\tcout<<f(r)<<\' \'<<f(l-1)<<endl;\n//\tcout<<stupid(l,r)<<endl;\n\t//if(f(r)-f(l-1)==stupid(l,r)) goto start;\n\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",1500,It is well known that for such problem you need to write function F x which solves the problem for the interval 0 x and the answer then is F r F l 1 Now you need to write F x function If x 10 then answer is of course equal to x Otherwise let len be the length of x x the integer x but without first and last digits xi the i th digit of integer x from left to right starting from 0 Interate through all possible first digit d which is the last at the same time and through the length i of the number Then if i len 2 or i len 2 and d x0 you need to add 10i to the answer Otherwise if i len 2 and d x0 you need to add x to the answer Finally if i len 2 and d x0 and xlen 1 d add 1 to the answer This problems also can be solved using DP 
You are given a multiset consisting of n integers You have to process queries of two types add integer k into the multiset find the k th order statistics in the multiset and remove it k th order statistics in the multiset is the k th element in the sorted list of all elements of the multiset For example if the multiset contains elements 1 4 2 1 4 5 7 and k 3 then you have to find the 3 rd element in 1 1 2 4 4 5 7 which is 2 If you try to delete an element which occurs multiple times in the multiset only one occurence is removed After processing all queries print number belonging to the multiset or say that it is empty ,"['#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int lim = 1048576;\nint bit[1048588];\nvoid add(int pos, int val) {\n\tfor (int i = pos; i <= lim; i += i & (-i)) {\n\t\tbit[i] += val;\n\t}\n}\nint bsearch(int x) {\n\tif (x == 0) return 0;\n\tint ptr = 0;\n\tfor (int i = lim / 2; i >= 1; i >>= 1) {\n\t\tif (bit[ptr + i] < x) {\n\t\t\tx -= bit[ptr + i];\n\t\t\tptr += i;\n\t\t}\n\t}\n\treturn ptr + 1;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, Q;\n\tcin >> N >> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tadd(x, 1);\n\t}\n\tint cnt = N;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (x >= 0) add(x, 1), ++cnt;\n\t\telse {\n\t\t\tint ptr = bsearch(-x);\n\t\t\tadd(ptr, -1);\n\t\t\t--cnt;\n\t\t}\n\t}\n\tif (cnt == 0) {\n\t\tcout << 0 << endl;\n\t}\n\telse {\n\t\tcout << bsearch(1) << endl;\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0]",1900,First solution write some data structure that would simulate the operations as they are given for example a segment tree or a Fenwick tree Probably will require optimization since the limits are strict Second solution notice that we have to find only one number belonging to the multiset For example let s find the minimum element We can do it with binary search as follows let s write a function that for a given element tells the number of elements not greater than in the resulting multiset To implement it use the fact that all elements are indistinguishable and all elements are indistinguishable too so the multiset can be maintained with just two counters Okay how does this function help The minimum in the resulting multiset is the minimum such that this function returns non zero for it and since the function is monotonous we can find the answer with binary search 
Little09 and his friends are playing a game There are n players and the temperature value of the player i is i The types of environment are expressed as 0 or 1 When two players fight in a specific environment if its type is 0 the player with a lower temperature value in this environment always wins if it is 1 the player with a higher temperature value in this environment always wins The types of the n 1 environments form a binary string s with a length of n 1 If there are x players participating in the game there will be a total of x 1 battles and the types of the x 1 environments will be the first x 1 characters of s While there is more than one player left in the tournament choose any two remaining players to fight The player who loses will be eliminated from the tournament The type of the environment of battle i is s i For each x from 2 to n answer the following question if all players whose temperature value does not exceed x participate in the game how many players have a chance to win ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 500500;\nint n;\nchar s[N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tscanf(""%s"", s);\n\tint ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (i == 0 || s[i] != s[i - 1])\n\t\t\tans = 1;\n\t\telse\n\t\t\tans++;\n\t\tprintf(""%d "", 2 + i - ans);\n\t}\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0, 0, 1, 0, 0, 0]",1300,SolutionWe define to mean that the maximum satisfies It can be proved that for players players are bound to lose and the rest have a chance to win So the answer to the first battles is Next we prove this conclusion Suppose there are players and battles and and there are consecutive at the end If then obviously only the th player can win Otherwise must be 0 Consider the following facts Players to have no chance to win If the player can win he must defeat the player whose temperature value is lower than him in the last battles However in total only the player s temperature value is lower than his Because the th player cannot win Players from to have a chance to win For the player we can construct in the first battles we let all players whose temperature value in except the player fight so that only one player will remain In the th battle we let the remaining player fight with the player Since the player will win Then there are only the first players and the player in the remaining battles so the player can win For the situation is similar and it will not be repeated here 
You are playing the game Arranging The Sheep The goal of this game is to make the sheep line up The level in the game is described by a string of length n consisting of the characters empty space and sheep In one move you can move any sheep one square to the left or one square to the right if the corresponding square The game ends as soon as the sheep are lined up that is there should be no empty cells between any sheep For example if n 6 and the level is described by the string then the following game scenario is possible the sheep at the 4 position moves to the right the state of the level the sheep at the 2 position moves to the right the state of the level the sheep at the 1 position moves to the right the state of the level the sheep at the 3 position moves to the right the state of the level the sheep at the 2 position moves to the right the state of the level the sheep are lined up and the game ends For a given level determine the minimum number of moves you need to make to complete the level ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl ""\\n""\n\n#define sz(x) int((x).size())\n\nvoid solve() {\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tif(s.find(\'*\') == string::npos) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tvector<int> arr;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == \'*\'){\n\t\t\tarr.push_back(i);\n\t\t}\n\t}\n\tint m = n;\n\tn = sz(arr);\n\tint change[m] {};\n\tfor(int i = 0; i < n; i++) {\n\t\tchange[arr[i] - i]++;\n\t}\n\tlong ans = 1e18, cur = 0, lo = 0, hi = n;\n\tfor(int i = 0; i < n; i++) {\n\t\tdbg(arr[i], i);\n\t\tcur += abs(arr[i] - i);\n\t}\n\tfor(int i = 0; i <= m - n; i++) {\n\t\tdbg(i, ans, cur);\n\t\tans = min(ans, cur);\n\t\tlo += change[i];\n\t\thi -= change[i];\n\t\tcur += lo;\n\t\tcur -= hi;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1400,Let s denote by the number of sheep in the string and by their positions in the string Note that in the optimal solution the sheep with the number will not make moves This can be proved by considering the optimal solution in which the sheep with the number makes at least one move and come to the conclusion that this solution is not optimal Consider sheep with numbers from to Then the final position of the th sheep will be and the answer will be 
There are n players sitting at the card table Each player has a favorite number The favorite number of the j th player is f j There are k cdot n cards on the table Each card contains a single integer the i th card contains number c i Also you are given a sequence h 1 h 2 dots h k Its meaning will be explained below The players have to distribute all the cards in such a way that each of them will hold exactly k cards After all the cards are distributed each player counts the number of cards he has that contains his favorite number The joy level of a player equals h t if the player holds t cards containing his favorite number If a player gets no cards with his favorite number i e t 0 his joy level is 0 Print the maximum possible total joy levels of the players after the cards are distributed Note that the sequence h 1 dots h k is the same for all the players ,"['#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl \'\\n\'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, k;\nint a[MAXN], cnt1[MAXN], cnt2[MAXN], f[MAXN], h[MAXN];\n\nbool read() {\n    if (!(cin >> n >> k))\n        return false;\n\n    forn (i, n * k)\n        cin >> a[i];\n\n    forn (i, n)\n        cin >> f[i];\n\n    forn (i, k)\n        cin >> h[i + 1];\n\n    return true;\n}\n\nvoid solve() {\n    forn (i, n * k)\n        ++cnt1[a[i]];\n\n    forn (i, n)\n        ++cnt2[f[i]];\n\n    ll ans = 0;\n\n    for (int x = 1; x <= 100000; ++x)\n        if (cnt2[x] != 0) {\n            vector< vector<int> > dp(cnt2[x] + 1, vector<int>(cnt1[x] + 1, 0));\n\n            for (int i = 0; i < cnt2[x]; ++i)\n                for (int j = 0; j <= cnt1[x]; ++j)\n                    for (int dj = 0; dj <= k && j + dj <= cnt1[x]; ++dj)\n                        dp[i + 1][j + dj] = max(dp[i + 1][j + dj], dp[i][j] + h[dj]);\n\n            ans += dp[cnt2[x]][cnt1[x]];\n        }\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand(\'S\' + \'E\' + \'R\' + \'E\' + \'Z\' + \'H\' + \'K\' + \'A\');\n\n#ifdef SEREZHKA\n    freopen(""file.in"", ""r"", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000,It is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number and if the player gets a card not having his favorite number his joy will not change Let be the maximum possible total joy of players with the same favorite number it doesn t matter which one and cards containing their favorite number if the cards are distributed among the players optimally Note that and At the beginning all entries of the table are zeroes The transition in this dynamic programming depends on how many cards the th player will receive which is between and In other words the dynamic programming transition will look like for int i 0 i k i dp x 1 y i max dp x 1 y i dp x y h i where is the joy of the player if he receives exactly cards containing his favorite number Note that After filling the table the answer can be calculated very easily where is the number of players with favorite number and is the number of cards containing the number Time complexity is 
Lakhesh loves to make movies so Nephren helps her run a cinema We may call it No 68 Cinema However one day the No 68 Cinema runs out of changes they don t have 50 notes currently but Nephren still wants to start their business Assume that is a kind of currency in Regulu Ere There are three types of customers some of them bring exactly a 50 note some of them bring a 100 note and Nephren needs to give a 50 note back to him her some of them bring VIP cards so that they don t need to pay for the ticket Now customers are waiting outside in queue Nephren wants to know how many possible queues are there that they are able to run smoothly i e every customer can receive his her change and that the number of 50 notes they have after selling tickets to all these customers is between and inclusive Two queues are considered different if there exists a customer whose type is different in two queues As the number can be large please output the answer modulo ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n// Undefined sign for negative inputs\ntemplate<typename T>\nstatic T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n// m must be positive\ntemplate<typename T>\nstatic T mod(T a, T m)\n{\n    a %= m;\n    if (a < 0)\n        a += m;\n    return a;\n}\n\n// a must be relatively prime to m\ntemplate<typename T>\nstatic T inverse(T a, T m)\n{\n    a = mod(a, m);\n    if (a <= 1)\n        return a;\n    return mod((1 - inverse(m, a) * m) / a, m);\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic ll P;\nstatic vi F;\n\nstatic ll pmod(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    else if (b & 1)\n        return a * pmod(a, b - 1) % P;\n    else\n    {\n        ll t = pmod(a, b / 2);\n        return t * t % P;\n    }\n}\n\nstruct number\n{\n    ll rel;\n    array<int, 10> ex;\n\n    number() : rel(1), ex{{}} {}\n\n    number operator *(const number &b) const\n    {\n        number out;\n        out.rel = rel * b.rel % P;\n        for (int i = 0; i < SZ(F); i++)\n            out.ex[i] = ex[i] + b.ex[i];\n        return out;\n    }\n\n    number operator /(const number &b) const\n    {\n        number out;\n        out.rel = rel * inverse(b.rel, P) % P;\n        for (int i = 0; i < SZ(F); i++)\n            out.ex[i] = ex[i] - b.ex[i];\n        return out;\n    }\n\n    ll eval() const\n    {\n        ll ans = rel;\n        for (int i = 0; i < SZ(F); i++)\n        {\n            ll f = pmod(F[i], ex[i]);\n            ans = ans * f % P;\n        }\n        return ans;\n    }\n};\n\nstatic vi factors(int P)\n{\n    int s = int(sqrt(P) + 1);\n    vi ans;\n    for (int i = 2; i <= s; i++)\n    {\n        if (P % i == 0)\n        {\n            ans.push_back(i);\n            while (P % i == 0)\n                P /= i;\n        }\n    }\n    if (P > 1)\n        ans.push_back(P);\n    return ans;\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    ll N, l, r;\n    cin >> N >> P >> l >> r;\n\n    F = factors(P);\n    vector<int> d1(N + 1, -1);\n    for (int i = 0; i < SZ(F); i++)\n        for (int j = F[i]; j <= N; j += F[i])\n            d1[j] = i;\n\n    vector<number> fact(N + 1);\n    for (int i = 2; i <= N; i++)\n    {\n        number cur;\n        ll rel = i;\n        while (d1[rel] != -1)\n        {\n            cur.ex[d1[rel]]++;\n            rel /= F[d1[rel]];\n        }\n        cur.rel = rel % P;\n        assert(gcd(rel, P) == 1);\n        fact[i] = fact[i - 1] * cur;\n    }\n\n    auto choose = [&](ll n, ll r)\n    {\n        number ans = fact[n] / (fact[r] * fact[n - r]);\n        return ans.eval();\n    };\n\n    ll ans = 0;\n    for (int k = l; k <= N; k++)\n    {\n        ll x = (k - l) / 2;\n        ll y = (k - r + 1) / 2;\n        ll term = choose(k, x);\n        if (y > 0)\n            term -= choose(k, y - 1);\n        term %= P;\n        term = term * choose(N, k) % P;\n        ans = (ans + term) % P;\n    }\n    ans %= P;\n    if (ans < 0)\n        ans += P;\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2900,First let s consider a simpler problem that there are no customers with VIP cards and there are no 50 notes left For convinence we suppose that is an even number The situation that is an odd number will be similar By defining points number of customers currently number of 50 note left on a 2d plane the answer to our second question is the ways of drawing lines from 0 0 to n 0 such that two adjacent points y axis have a difference of 1 and that all the points are above the x axis The total routes will be but some of them are invalid Consider another route starting from 0 2 For each invalid way in the previous route consider the first point x y that y 0 y 1 By creating a symmetry route with y 1 for the route before this point this route will become exactly one route starting from 0 2 and every route starting from 0 2 will become an invalid route in a similar way So the number of invalid routes is that is the number of routes from 0 2 to n 0 Thus the answer will be Similarly if there are l r 50 notes left the answer will be Now let s enumerate how many customers are there with VIP cards If there are of them the answer will time a factor One last question is about the modulo number First separate it into forms like where are primes We can calculate how many factor are there in and the modulo value of the remaining ones Each time we take out a facter in and it becomes some product of numbers that are not divisble by as well as a remaining part For example we want to calculate the number of factor 3 in 16 and the product of numbers that are not divisble by 3 in 16 mod 3 2 Then we have 16 1 2 4 5 7 8 10 11 13 14 16 1 2 3 4 5 3 5 The first part are not divisble by 3 so we can calculate their value mod 3 2 in advance the second part is a smaller problem 5 so we can solve it recursively For the number of factor 3 just add 5 in this case and solve it recursively After calculating how many factor in and the modulo value of the remaining ones we can calculate the combnation numbers correctly Finally use Chinese Remainder Algorithm to combine them 
Serval loves Brain Power and his brain power problem Serval defines that a string T is iff T can be obtained by concatenating some string T multiple times Formally speaking T is powerful iff there exist a string T and an integer k geq 2 such that T underbrace T T dots T k text times For example is powerful because it can be obtained by concatenating three times but is not powerful Serval has a string S consists of lowercase English letters He is curious about the longest powerful subsequence of S and he only needs you to find out the length of it If all the non empty subsequences of S is not powerful the answer is considered to be 0 A string a is a subsequence of a string b if a can be obtained from b by the deletion of several possibly zero or all characters ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\n\nstring s;\nint n;\nstring cur;\nint ans = 0;\nconst int K = 16;\n\nbool check() {\n    if (cur.empty()) return true;\n    int j = 0;\n    int sz = (int) cur.size();\n    int cnt = 0;\n    for (auto &x: s) {\n        if (x == cur[j]) {\n            j++;\n            if (j == sz) {\n                cnt++;\n                j = 0;\n            }\n        }\n    }\n    if (cnt >= 2) {\n        ans = max(ans, cnt * sz);\n        return true;\n    }\n    return false;\n}\n\nvoid chkmx(int &x, int y) { x = max(x, y); }\n\nvoid relax(string x, string y, string z) {\n    int nx = x.size();\n    int ny = y.size();\n    int nz = z.size();\n    vector<vector<vector<int>>> dp(nx + 1, vector<vector<int>>(ny + 1, vector<int>(nz + 1)));\n    int res = 0;\n    for (int i = 0; i <= nx; ++i) {\n        for (int j = 0; j <= ny; ++j) {\n            for (int e = 0; e <= nz; ++e) {\n                if (i + 1 <= nx) chkmx(dp[i + 1][j][e], dp[i][j][e]);\n                if (j + 1 <= ny) chkmx(dp[i][j + 1][e], dp[i][j][e]);\n                if (e + 1 <= nz) chkmx(dp[i][j][e + 1], dp[i][j][e]);\n                if (i < nx && j < ny && e < nz && x[i] == y[j] && x[i] == z[e])\n                    chkmx(dp[i + 1][j + 1][e + 1], dp[i][j][e] + 1);\n                chkmx(res, dp[i][j][e]);\n            }\n        }\n    }\n    ans = max(ans, res * 3);\n}\n\n\nvoid relax(string x, string y) {\n    int nx = x.size();\n    int ny = y.size();\n    vector<vector<int>> dp(nx + 1, vector<int>(ny + 1));\n    int res = 0;\n    for (int i = 0; i <= nx; ++i) {\n        for (int j = 0; j <= ny; ++j) {\n            if (i + 1 <= nx) chkmx(dp[i + 1][j], dp[i][j]);\n            if (j + 1 <= ny) chkmx(dp[i][j + 1], dp[i][j]);\n            if (i < nx && j < ny && x[i] == y[j])\n                chkmx(dp[i + 1][j + 1], dp[i][j] + 1);\n            chkmx(res, dp[i][j]);\n        }\n    }\n    ans = max(ans, res * 2);\n}\n\nvoid solve() {\n    cin >> s;\n    n = (int) s.size();\n    for (int i = 0; i < n; ++i) {\n        for (int mask = 1; mask < (1 << K); mask += 2) {\n            for (int j = 0; j < K; ++j) {\n                if (mask & (1 << j)) cur.push_back(s[i + j]);\n            }\n            check();\n            cur.clear();\n        }\n    }\n    // 3\n    for (int l = K + 1; l < n; ++l) {\n        for (int r = l + K + 1; r + K < n; ++r) {\n            relax(s.substr(0, l), s.substr(l, r - l), s.substr(r, n));\n        }\n        relax(s.substr(0, l), s.substr(l, n));\n    }\n    cout << ans << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}']","[1, 0, 1, 1, 0, 1, 0, 0, 0, 0]",2700,Assume that the longest powerful subsequence of the given string is which can be obtained by concatenating copies of string Noticing that we have the observation that so it is impossible that both and is large When we only need to consider the case and the case The case is covered by case since For the case we split into two parts then calculate the maximal length of by dynamic programming over all the possible splits This case can be solved in time where is a small constant It is similar to solve the case We split into three parts then calculate the maximal length of over all the possible splits This case can be solved in time where is a small constant We will estimate later When we have It can be shown that if we split into parts will be the subsequence of at least one of them We can split into equal lengths then enumerate all the subsequences of these substrings as the possible For a possible we can find out corresponding by matching and greedily This case can be solved in Now let us roughly estimate how small could be The time that dynamic programming consumed for certain is Since we have Recall that there are possible splits then holds Time complexity 
You are given an integer array a of length n A subarray of a is one of its contiguous subsequences i e an array a l a l 1 dots a r for some integers l and r such that 1 le l r le n Let s call a subarray if there is an integer that occurs exactly once in the subarray You can perform the following operation any number of times possibly zero choose an element of the array and replace it with any integer Your task is to calculate the minimum number of aforementioned operation in order for all the subarrays of the array a to be unique ,"['#include ""bits/stdc++.h""#pragma GCC optimize (""O3"")#pragma GCC target (""sse4"") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\xa0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\xa0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}void __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}void __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}void __print(bool x) {cerr << (x ? ""true"" : ""false"");}\xa0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}template<typename T>void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}void _print() {cerr << ""]\\n"";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;#else#define dbg(x...)#endif\xa0\xa0const int MOD = 1000000007;const char nl = \'\\n\';const int MX = 100001; \xa0\xa0const ll identity = 0;const ll SZ = 131072*4;\xa0pl sum[2*SZ]; ll lazy[2*SZ];\xa0pl combine(pl A, pl B) {    return min(A, B);}\xa0pl combineUpd(pl A, ll B) {    return {A.f+B, A.s};}\xa0void push(int index, ll L, ll R) {    sum[index] = combineUpd(sum[index], lazy[index]);    if (L != R) lazy[2*index] += lazy[index], lazy[2*index+1] += lazy[index];    lazy[index] = identity;}\xa0void pull(int index) {    sum[index] = combine(sum[2*index], sum[2*index+1]);}\xa0pl query(int lo, int hi, int index = 1, ll L = 0, ll R = SZ-1) {    push(index, L, R);    if (lo > R || L > hi) return {MOD, -1};    if (lo <= L && R <= hi) return sum[index];\xa0    int M = (L+R) / 2;    return combine(query(lo, hi, 2*index, L, M), query(lo, hi, 2*index+1, M+1, R));}\xa0void update(int lo, int hi, ll increase, int index = 1, ll L = 0, ll R = SZ-1) {    push(index, L, R);    if (hi < L || R < lo) return;    if (lo <= L && R <= hi) {        lazy[index] = increase;        push(index, L, R);        return;    }\xa0    int M = (L+R) / 2;    update(lo, hi, increase, 2*index, L, M); update(lo, hi, increase, 2*index+1, M+1, R);    pull(index);}\xa0void solve() {    int N; cin >> N;    vi A(N); F0R(i, N) cin >> A[i];    int nxtOcc[N+1]; F0R(i, N+1) nxtOcc[i] = N;    int twoOcc[N+1]; F0R(i, N+1) twoOcc[i] = N;    int nxtBad[N];    F0Rd(i, N) {        int v = A[i];        if (nxtOcc[v] != N) {            //dbg(nxtOcc[v], twoOcc[v] - 1, ""MINUS"");            update(nxtOcc[v], twoOcc[v] - 1, -1);        }        //dbg(i, nxtOcc[v] - 1, ""PLUS"");        update(i, nxtOcc[v] - 1, 1);        twoOcc[v] = nxtOcc[v];        nxtOcc[v] = i;        nxtBad[i] = query(i, N).s;        ckmin(nxtBad[i], N);        if (i < N-1) {            ckmin(nxtBad[i], nxtBad[i+1]);        }        //dbg(i, nxtBad[i], query(i, N), query(N, N));    }\xa0    int v = 0;    int ans = 0;    while (v < N && nxtBad[v] < N) {        ans++;        v = nxtBad[v] + 1;    }    cout << ans << nl;\xa0\xa0    F0R(i, N+10) {        update(i, i, -query(i, i).f);    }\xa0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\xa0    FOR(i, SZ, 2*SZ) {        sum[i].s = i-SZ;    }    F0Rd(i, SZ) {        pull(i);    }    int T = 1;    cin >> T;    while(T--) {        solve();    }\xa0\treturn 0;}\xa0\xa0']","[1, 0, 0, 1, 1, 0, 0, 1, 0, 0]",2400,When we replace an element we can always choose an integer that is not present in the array So if we replace the th element every subarray containing it becomes unique and the problem can be reformulated as follows consider all non unique subarrays of the array and calculate the minimum number of elements you have to choose so that for every non unique subarray at least one of its elements is chosen We can use the following greedy strategy to do it go through the array from left to right maintaining the index of the last element we replaced When we consider the th element of the array if there is a non unique subarray with we replace the th element otherwise we don t replace anything Why is it optimal Essentially this greedy approach always finds a non unique subarray with the lowest value of and replaces the th element We obviously have to replace at least one element from the subarray but replacing the th element is optimal since we picked the lowest value of so every non unique subarray which contains any element from also contains the th element Okay but we need to make this greedy solution work fast When we consider the th element how do we check that there s a non unique subarray starting after the element and ending at the th element Suppose we go from the th element to the left and maintain a counter when we meet an element for the first time we increase this counter when we meet an element for the second time we decrease this counter If this counter is equal to then the current subarray is non unique every element appears at least twice Otherwise at least one element has exactly one occurrence Suppose we maintain an array where for each integer present in the original array we put in the last position we ve seen this element and in the second to last position we ve seen this element i e for every element we consider its two last occurrences among the first positions in the array put in the last of them and in the second to last of them Then if we go from to and maintain the counter in the same way as we described in the previous paragraph the value of this counter will be equal to the sum of the corresponding segment in this array So we want to check if there s a segment in the array such that its left border is greater than the last position where we made a replacement the right border is and the sum is We can show that the sum on any segment ending in the th position is currently non negative so we actually want to find the segment with the minimum sum We can store a segment tree that for every position from to maintains the sum on segment then changing an element is just performing the query add on segment and finding the minimum sum is just performing the query minimum on segment This allows us to get a solution with complexity of 
The Little Elephant has got a problem somebody has been touching his sorted by non decreasing array of length and possibly swapped some elements of the array The Little Elephant doesn t want to call the police until he understands if he could have accidentally changed the array himself He thinks that he could have accidentally changed array only if array can be sorted in no more than one operation of swapping elements not necessarily adjacent That is the Little Elephant could have accidentally swapped some two elements Help the Little Elephant determine if he could have accidentally changed the array sorted by non decreasing himself ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\nint in[100010];\nint i2[101000];\nint main(){\n    int n,i,j;\n    scanf(""%d"",&n);\n    for(i=0;i<n;i++){\n        scanf(""%d"",&in[i]);\n        i2[i]=in[i];\n    }\n    sort(in,in+n);\n    int c=0;\n    for(i=0;i<n;i++){\n        if(i2[i]!=in[i])c++;\n    }\n    puts(c<=2?""YES"":""NO"");\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",1300,There are multiple possible solutions for this problem For example the following Find the last index such that there exists some minimal possible that Then you just need to try two possibilities either swap and or don t change anything 
Pasha has two hamsters Arthur and Alexander Pasha put apples in front of them Pasha knows which apples Arthur likes Similarly Pasha knows which apples Alexander likes Pasha doesn t want any conflict between the hamsters as they may like the same apple so he decided to distribute the apples between the hamsters on his own He is going to give some apples to Arthur and some apples to Alexander It doesn t matter how many apples each hamster gets but it is important that each hamster gets only the apples he likes It is possible that somebody doesn t get any apples Help Pasha distribute all the apples between the hamsters Note that Pasha wants to distribute all the apples not just some of them ,"[""#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\n#define ms(x) memset(x,0,sizeof(x)) \n#define For(a,b,c) for(int a = b ; a <= c ; a ++ )\n#define int64 long long \n#define real long double\n#define SZ size()\n\nint getint(){\n    char ch = getchar() ; int ret = 0 ; bool flag = true ; \n    while(( ch < '0' || ch > '9' ) && ch != '-' ) ch = getchar() ; \n    if( ch == '-' ) flag = false , ch = getchar() ; \n    while( ch >= '0' && ch <= '9' ) ret = ret * 10 + ch - '0' , ch = getchar() ;  \n    return flag ? ret : - ret ; \n}\n\nusing namespace std ; \n\nint v[200] , n , a , b , x ; \n\nint main(){\n\n     \n   cin >> n >> a >> b ; \n   for(int i = 1 ; i <= a ; i ++ ) cin >> x , v[x] = 1 ; \n   for(int i = 1 ; i <= b ; i ++ ) cin >> x , v[x] = 2 ; \n   \n   for(int i = 1 ; i <= n ; i ++ ) cout << v[i] << ' ' ;  \n   return 0 ; \n}\n""]","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",800,For each apple you just need to determine who like it If Alexander likes apple then he should eat it if Artur likes the apple then he should eat it If they both like the apply anyone can eat the apple 
Let s look at the following process initially you have an empty stack and an array s of the length l You are trying to push array elements to the stack in the order s 1 s 2 s 3 dots s l Moreover if the stack is empty or the element at the top of this stack is not equal to the current element then you just push the current element to the top of the stack Otherwise you don t push the current element to the stack and moreover pop the top element of the stack If after this process the stack remains empty the array s is considered There are samples of stack exterminable arrays 1 1 2 1 1 2 1 1 2 2 1 3 3 1 2 2 3 1 3 3 1 3 3 3 3 3 3 3 5 1 2 2 1 4 4 5 Let s consider the changing of stack more details if s 5 1 2 2 1 4 4 5 the top of stack is highlighted after pushing s 1 5 the stack turn into textbf 5 after pushing s 2 1 the stack turn into 5 textbf 1 after pushing s 3 2 the stack turn into 5 1 textbf 2 after pushing s 4 2 the stack turn into 5 textbf 1 after pushing s 5 1 the stack turn into textbf 5 after pushing s 6 4 the stack turn into 5 textbf 4 after pushing s 7 4 the stack turn into textbf 5 after pushing s 8 5 the stack is empty You are given an array a 1 a 2 ldots a n You have to calculate the number of its subarrays which are stack exterminable Note that you have to answer q independent queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=301000;\n\nstruct node {\n\tmap<int,node*> go;\n\tint cnt;\n\tnode *p;\n}pool[N],*cur,*rt;\nint top,s[N],x,n,_;\nll ans;\n\nnode *newnode(node *f) {\n\tnode *q=cur++;\n\tq->go.clear(); q->cnt=0; q->p=f;\n\treturn q;\n}\n\nvoid solve() {\n\tscanf(""%d"",&n);\n\tcur=pool;\n\trt=newnode(0);\n\ttop=0;\n\tnode *p=rt;\n\tp->cnt++;\n\tans=0;\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",&x);\n\t\tif (top==0||s[top-1]!=x) {\n\t\t\ts[top++]=x;\n\t\t\tif (!p->go.count(x)) p->go[x]=newnode(p);\n\t\t\tp=p->go[x];\n\t\t\tans+=p->cnt;\n\t\t\tp->cnt++;\n\t\t} else {\n\t\t\t--top;\n\t\t\tp=p->p;\n\t\t\tans+=p->cnt;\n\t\t\tp->cnt++;\n\t\t}\n//\t\tprintf(""%d %d %d\\n"",i,ans,p-pool);\n\t}\n\tprintf(""%lld\\n"",ans);\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2600,Let s understand how calculate the array nxt such that nxtl is equal to the minimum index r l such that subarray al r is stack exterminable If there is no such index then nxtl 1 If we calculate this array then we solve this task by simple dynamic programming Let s calculate it in order nxtn nxtn 1 nxt1 by dynamic programming At first consider simple case If ai ai 1 then nxti i 1 Otherwise we have to add the block ai 1 anxti 1 of course nxti 1 should be not equal to 1 and check that ai a1 nxti 1 If this ai a1 nxti 1 also is not true then you have to add a new block a1 nxti 1 anxt1 nxti 1 and check the condition ai a1 nxt1 nxti 1 If this condition also is not try then you have to add a new block and so on It is correct solution but it can be too slowly Let s understand that we add blocks to ai until condition ai a1 nxt is holds Let s assume that we have an array nxtX this array contains a hashMaps for example you can use map in C such that nxtXi x is is equal to the minimum index r l such that subarray al r is stack exterminable and x ar 1 Then we can easily calculate the value nxti nxtXi 1 ai 1 Remains to understand how to calculate nxtXi For this we just can make an assignment nxtXi nxtXnxti 1 And then update nxtXi anxti 1 nxti 1 But I deceived you a little We can t make an assignment nxtXi nxtXnxti 1 because it is to slow Instead that you need to swap elements nxtXi and nxtXnxti 1 this can be done using the function swap in C or Java time complexity of swap if O 1 
A palindrome is a string t which reads the same backward as forward formally t i t t 1 i for all i in 1 t Here t denotes the length of a string t For example the strings and are palindromes You have n binary strings s 1 s 2 dots s n each s i consists of zeroes and or ones You can swap any pair of characters any number of times possibly zero Characters can be either from the same string or from different strings there are no restrictions Formally in one move you choose four integer numbers x a y b such that 1 le x y le n and 1 le a le s x and 1 le b le s y where x and y are string indices and a and b are positions in strings s x and s y respectively swap exchange the characters s x a and s y b What is the maximum number of strings you can make palindromic simultaneously ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid solve_case() {\n    int N;\n    cin >> N;\n    vector<string> strings(N);\n    bool odd = false;\n    int counts[2] = {0, 0};\n\n    for (string &str : strings) {\n        cin >> str;\n        odd = odd || str.size() % 2 != 0;\n\n        for (char c : str)\n            counts[c - '0']++;\n    }\n\n    int answer = (odd || counts[0] % 2 == 0) ? N : N - 1;\n    cout << answer << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int Q;\n    cin >> Q;\n\n    while (Q-- > 0)\n        solve_case();\n}\n""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400,Let s make several observations At first note that the lengths of the strings doesn t change At second note that if the string has even length then being palindromic is the same as having even number of zeroes and even number of ones But if the string has odd length then it always is palindromic So the question is how to fix bad strings with even length but with odd number of zeroes and ones If we have at least one string with odd length then you can trade between bad string and odd string either zero to one or one to zero fixing the bad string Otherwise you can fix two bad strings swapping appropriate characters In result we can either make all strings palindromic or all strings except one in case of absence of odd strings and having odd number of bad strings 
The decreasing coefficient of permutation is the number of such that You have numbers and Your task is to print the permutation of length with decreasing coefficient ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint n,d;\nint main()\n{\n\tint i,j,k;\n\tcin>>n>>d;k=n;\n\tfor (i=n;i>=n-d+1;i--)\n\t{\n\t\tprintf(""%d "",i);\n\t\tk--;\n\t}\n\tfor (i=1;i<=k;i++)printf(""%d "",i);\n\tputs("""");\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100,As the answer you can print such permutation For example if then the answer is If you should print Such solution can be written in two loops 
You are the gym teacher in the school There are n students in the row And there are two rivalling students among them The first one is in position a the second in position b Positions are numbered from 1 to n from left to right Since they are rivals you want to maximize the distance between them If students are in positions p and s respectively then distance between them is p s You can do the following operation at most x times choose two students and swap them Calculate the maximum distance between two rivalling students after at most x swaps ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0) {\n        int N, X, A, B;\n        cin >> N >> X >> A >> B;\n        cout << min(abs(A - B) + X, N - 1) << '\\n';\n    }\n}\n""]","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
A string is called if it contains consecutive adjacent letters of the Latin alphabet and each letter occurs exactly once For example the following strings are diverse and The following string are diverse and Note that the letters and are not adjacent Formally consider positions of all letters in the string in the alphabet These positions should form contiguous segment i e they should come one by one without any gaps And all letters in the string should be distinct duplicates are not allowed You are given a sequence of strings For each string if it is diverse print Otherwise print ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 10;\ntypedef long long ll;\nint a[30];\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>>s;\n        memset(a,0,sizeof(a));\n        for(int i=0;i<s.size();i++) a[s[i]-\'a\'+1]++;\n        int cnt = 0;\n        for(int i=1;i<30;i++){\n            if(a[i]&&a[i-1]==0) cnt++;\n            if(a[i]>1) cnt = 10;\n        }\n        if(cnt==1){\n            cout<<""Yes""<<endl;\n        }\n        else{\n            cout<<""No""<<endl;\n        }\n    }\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,The string is diverse if it is a permutation of some substring of the Latin alphabet In other words the string is diverse if all letters in it are distinct we can check it using some structure like or array of used elements and if the number of letters between the letter with the maximum alphabet position and the letter with the minimum alphabet position plus one is exactly the length of the string For example the position in alphabet of letter is one the position of letter is six and so on 
Vanya really likes math One day when he was solving another math problem he came up with an interesting tree This tree is built as follows Initially the tree has only one vertex with the number 1 the root of the tree Then Vanya adds two children to it assigning them consecutive numbers 2 and 3 respectively After that he will add children to the vertices in increasing order of their numbers starting from 2 assigning their children the minimum unused indices As a result Vanya will have an infinite tree with the root in the vertex 1 where each vertex will have exactly two children and the vertex numbers will be arranged sequentially by layers Vanya wondered what the sum of the vertex numbers on the path from the vertex with number 1 to the vertex with number n in such a tree is equal to Since Vanya doesn t like counting he asked you to help him find this sum ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint ans;\nvoid solve()\n{\n\tll n;\tll ans=0;\n\tcin>>n;\n\twhile(n)\n\t{\n\t\tans+=n;\n\t\tn>>=1;\n\t}\n\tprintf(""%lld\\n"",ans);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,It is easy to notice that the children of the vertex with number have numbers and So the ancestor of the vertex has the number Note that based on this formula the size of the path from the root to the vertex with number equals Therefore with given constraints we can write out the path to the root explicitly and calculate the sum of vertex numbers on it in Total complexity for the test case 
You are given a string consisting only of characters and A substring of is a string and its length equals to A substring is called if the number of zeroes equals to the number of ones in this substring You have to determine the length of the longest substring of ,"['#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(""input.txt"");\n\t//ofstream cout(""output.txt"");\n\n\tint n;\n\tcin >> n;\n\n\tmap<int, int> mapa;\n\tstring s;\n\tcin >> s;\n\n\tint x = 0, y = 0;\n\tmapa[0] = -1;\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == \'0\') {\n\t\t\t++x;\n\t\t} else {\n\t\t\t++y;\n\t\t}\n\t\tif (mapa.count(y - x)) {\n\t\t\tans = max(ans, i - mapa[y - x]);\n\t\t} else {\n\t\t\tmapa[y - x] = i;\n\t\t}\t\t\n\t}\n\n\tcout << ans << ""\\n"";\n\n}']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0]",1500,Let be the number of zeroes and the number of ones on prefix of length also let The interesting property of is that the substring is balanced iff That leads to a solution for each value of maintain the minimum where this is obtained let it be called and for each index in the string update answer with 
Let s call yet again a string if its length is even and every character in odd position of this string is different from the next character the first character is different from the second the third is different from the fourth and so on For example the strings and are good strings and the strings and are not good You are given a string s you have to delete minimum number of characters from this string so that it becomes good ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst int N=3e6+7,mod=1e9+7,INF=1e9;\nint n,m,x,y;\nchar a[N],b[N];\nchar s[N],ss[N];\nint main()\n{\n    int cnt=0;\n    cin>>n;\n    scanf(""%s"",a+1);\n    for(int i=1;i<=n;i++){\n        if(a[i]==a[i+1]&&cnt%2==0){\n            continue;\n        }\n        else{\n            b[cnt++]=a[i];\n        }\n    }\n    if(cnt&1)cnt--;\n    cout<<n-cnt<<endl;\n    for(int i=0;i<cnt;i++){\n        printf(""%c"",b[i]);\n    }cout<<endl;\n    return 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300,The following greedy solution works let s iterate over all characters of the string from left to right and if the last block of two consecutive characters in the resulting string is full just add the current character to the resulting string otherwise add this character if it is not equal to the first character of the last block And don t forget about the parity of length remove last character if the length is odd 
Let s introduce a number system which is based on a roman digits There are digits which correspond to the numbers 1 5 10 and 50 respectively The use of other roman digits is not allowed Numbers in this system are written as a sequence of one or more digits We define the value of the sequence simply as the sum of digits in it For example the number evaluates to 35 and the number to 12 Pay attention to the difference to the traditional roman system in our system any sequence of digits is valid moreover the order of digits doesn t matter for example means 11 not 9 One can notice that this system is ambiguous and some numbers can be written in many different ways Your goal is to determine how many distinct integers can be represented by n roman digits ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nset<int> r[2333];\nll f[2333];\nint main()\n{\n\tr[0].insert(0);\n\tvector<int> v;\n\tfor(int i=0;i<50;++i)\n\t{\n\t\tfor(auto x:r[i])\n\t\t\tr[i+1].insert(x+1),\n\t\t\tr[i+1].insert(x+5),\n\t\t\tr[i+1].insert(x+10),\n\t\t\tr[i+1].insert(x+50);\n\t\tf[i]=r[i].size();\n\t}\n\tll n; cin>>n;\n\tif(n<=20)\n\t{\n\t\tcout<<f[n]<<""\\n"";\n\t\treturn 0;\n\t}\n\tcout<<f[20]+(f[21]-f[20])*(n-20)<<""\\n"";\n}\n']","[1, 1, 0, 1, 0, 1, 0, 0, 0, 0]",2000,among all the sequences select the one which contains the maximum number of in case of tie select one with largest number of Bruteforce all configurations in such way that each number is counted only in it s maximum configuration Since the length of sequence is fixed we can solve problem not for digits but for digits Let s solve the problem for digits first We have a problem that some numbers have many representations But this in fact is easy to deal with if we have at least nine digits 4 than we can convert them no some number of 9 digits and fill the rest with zeroes In this case the solution is to bruteforce the number of 4 from to and then from the remaining digits select any arbitrary number of 9 each such choice leads to an unique number Let s return to the original problem with In this case we can also face the situation when the number of can be increased We need to identify all pairs where such that they can be transformed to other pair with detachment of few We can bruteforce all with four nested for loops and check that the sum of first differs from sum of latter by few number of removed in such case we mark the pair as broken We can also note that if some pair is marked as broken than all dominating pairs also marked as broken When we discovered which pairs are good we can simply for number of 4for number of 9if pair is goodcount the answer all remaining digits are either 0 or 49 and all such alternatives are unique if you examine the solution above precisely you will notice that starting some reasonable you can easy proof a lowerbound like or but it is in fact the function grows linearly So if you count the answer in any stupid way and otherwise simply approximate it linearly using and 
Amr lives in Lala Land Lala Land is a very beautiful country that is located on a coordinate line Lala Land is famous with its apple trees growing everywhere Lala Land has exactly apple trees Tree number is located in a position and has apples growing on it Amr wants to collect apples from the apple trees Amr currently stands in position At the beginning he can choose whether to go right or left He ll continue in his direction until he meets an apple tree he didn t visit before He ll take all of its apples and then reverse his direction continue walking in this direction until he meets another apple tree he didn t visit before and so on In the other words Amr reverses his direction when visiting each new apple tree Amr will stop collecting apples when there are no more trees he didn t visit in the direction he is facing What is the maximum number of apples he can collect ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 1e5+5;\n\nint i, j, k, n, m;\n\nint x, y;\n\nvector< pii > l, r;\n\nint main(){\n\n\tcin >> n;\n\n\tFOR(i,1,n) {\n\t\t\n\t\tcin >> x >> y;\n\t\t\n\t\tif(x < 0) l.pb(mp(x,y));\n\t\telse r.pb(mp(x,y));\n\n\t}\n\n\tsort(l.begin(),l.end(),greater< pii > ());\n\n\tsort(r.begin(),r.end());\n\n\tint mn = min(l.size(), r.size());\n\n\tmn--;\n\n\tint ans = 0;\n\n\tFOR(i,0,mn) ans += l[i].nd + r[i].nd;\n\n\tint t = 0;\n\n\tif(l.size() > mn + 1) t = max(t, l[mn + 1].nd);\n\tif(r.size() > mn + 1) t = max(t, r[mn + 1].nd);\n\n\tcout << ans + t << endl;\n\n   return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 1, 0]",1100,Let s divide all the trees into two different groups trees with a positive position and trees with a negative position Now There are mainly two cases So we can sort each group of trees by the absolute value of the trees position and calculate the answer as mentioned above Time complexity Implementation 
Given an integer r find the number of lattice points that have a Euclidean distance from 0 0 r but than r 1 A is a point with integer coordinates The from 0 0 to the point x y is sqrt x 2 y 2 ,"['#include <iostream>#include <set>#include <map>#include <vector>#include <algorithm>#include <cmath>using namespace std;typedef long long ll;const int N = 5e5 + 10;ll a[N], b[N];void solve() {\tll r;\tcin >> r;\tll ans = 0;\tfor (ll x = -r; x <= r; x++) {\t\tll w = r * r - x * x;\t\tll u = (r + 1) * (r + 1) - x * x - 1;\t\tll qwe = sqrtl(u) - ceil(sqrtl(w)) + 1;\t\tans += (2 * qwe);\t}\tcout << ans - 2 << ""\\n"";}int main() {\tint t = 1;\tcin >> t;\twhile (t--) {\t\tsolve();\t} }']","[0, 1, 1, 0, 0, 1, 0, 1, 0, 0]",1600,There are many solutions to this problem some of which involve binary search but we will present a solution that doesn t use it In fact our solution is basically just brute force but with some small observations that make it pass See the implementation for more detail First we can only count points such that and we can multiply by at the end to get points in all four quadrants by symmetry Let s store a variable initially equal to It will tell us the maximum value to look at Iterate through all values of from to For each decrease until the distance of to the origin is Then brute force all values of from downwards until we hit a point whose distance to the origin is at this point we break and add the number of valid points to our total Note that we essentially only look at points whose distance to the origin is between and that is we brute force over all valid points How many valid points are there Well we can roughly estimate the number of points as the area of the region which is This means we only visit points per test case which is fast enough 
You found a map of a weirdly shaped labyrinth The map is a grid consisting of n rows and n columns The rows of the grid are numbered from 1 to n from bottom to top The columns of the grid are numbered from 1 to n from left to right The labyrinth has n layers The first layer is the bottom left corner cell 1 1 The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner And so on The labyrinth with 5 layers for example is shaped as follows The layers are separated from one another with walls However there are doors in these walls Each layer except for layer n has exactly two doors to the next layer One door is placed on the top wall of the layer and another door is placed on the right wall of the layer For each layer from 1 to n 1 you are given positions of these two doors The doors can be passed in both directions either from layer i to layer i 1 or from layer i 1 to layer i If you are standing in some cell you can move to an adjacent by a side cell if a wall doesn t block your move e g you can t move to a cell in another layer if there is no door between the cells Now you have m queries of sort what s the minimum number of moves one has to make to go from cell x 1 y 1 to cell x 2 y 2 ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:54:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nvector<array<array<int, 2>, 2>> dist;\n\nclass segtree {\n public:\n  struct node {\n    array<long long, 4> a;\n    int L;\n    int R;\n\n    void apply(int l, int r, array<long long, 4> v) {\n      a = v;\n      L = l;\n      R = r;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.L = a.L;\n    res.R = b.R;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        long long best = (long long) 1e18;\n        for (int k = 0; k < 2; k++) {\n          for (int t = 0; t < 2; t++) {\n            long long cur = a.a[i * 2 + k] + b.a[t * 2 + j];\n            cur += dist[b.L][k][t];\n            best = min(best, cur);\n          }\n        }\n        res.a[i * 2 + j] = best;\n      }\n    }\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<pair<int, int>> bot(n - 1);\n  vector<pair<int, int>> lft(n - 1);\n  vector<pair<int, int>> top(n - 1);\n  vector<pair<int, int>> rgt(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> bot[i].first >> bot[i].second >> lft[i].first >> lft[i].second;\n    top[i] = bot[i];\n    top[i].first += 1;\n    rgt[i] = lft[i];\n    rgt[i].second += 1;\n  }\n  vector<array<long long, 4>> p(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    int d = abs(bot[i].first - lft[i].first) + abs(bot[i].second - lft[i].second);\n    p[i] = {1, d + 1, d + 1, 1};\n  }\n  dist.resize(n - 1);\n  for (int q = 1; q < n - 1; q++) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        auto ga = (i == 0 ? top[q - 1] : rgt[q - 1]);\n        auto gb = (j == 0 ? bot[q] : lft[q]);\n        dist[q][i][j] = abs(ga.first - gb.first) + abs(ga.second - gb.second);\n      }\n    }\n  }\n  segtree st(p);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int ia = max(xa, ya) - 1;\n    int ib = max(xb, yb) - 1;\n    if (ia > ib) {\n      swap(xa, xb);\n      swap(ya, yb);\n      swap(ia, ib);\n    }\n    if (ia == ib) {\n      cout << abs(xa - xb) + abs(ya - yb) << \'\\n\';\n      continue;\n    }\n    auto nd = st.get(ia, ib - 1);\n    long long ans = (long long) 1e18;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        auto ga = (i == 0 ? bot[ia] : lft[ia]);\n        int da = abs(ga.first - xa) + abs(ga.second - ya);\n        auto gb = (j == 0 ? top[ib - 1] : rgt[ib - 1]);\n        int db = abs(gb.first - xb) + abs(gb.second - yb);\n        ans = min(ans, da + db + nd.a[i * 2 + j]);\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2600,WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity 
Some programming website is establishing a secure communication protocol For security reasons they want to choose several more or less random strings Initially they have a string s consisting of lowercase English letters Now they want to choose q strings using the following steps and you are to help them A string x consisting of lowercase English letters and integers l and r 1 leq l leq r leq s are chosen Consider all non empty distinct substrings of the s l s l 1 ldots s r that is all distinct strings s i s i 1 ldots s j where l le i le j le r Among all of them choose all strings that are lexicographically greater than x If there are no such strings you should print 1 Otherwise print the lexicographically smallest among them String a is lexicographically less than string b if either a is a prefix of b and a ne b or there exists such a position i 1 le i le min a b such that a i b i and for all j 1 le j i a j b j Here a denotes the length of the string a ,"['/**\n *    author:  tourist\n *    created: 02.09.2018 18:26:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1000010;\n\nstring to_string(string s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// http://e-maxx.ru/algo/ukkonen\n\nstring s;\nint n;\n \nstruct node {\n\tint l, r, par, link;\n\tmap<char,int> next;\n \n\tnode (int l=0, int r=0, int par=-1)\n\t\t: l(l), r(r), par(par), link(-1) {}\n\tint len()  {  return r - l;  }\n\tint &get (char c) {\n\t\tif (!next.count(c))  next[c] = -1;\n\t\treturn next[c];\n\t}\n};\nnode t[MAXN];\nint sz;\n \nstruct state {\n\tint v, pos;\n\tstate (int v, int pos) : v(v), pos(pos)  {}\n};\nstate ptr (0, 0);\n \nstate go (state st, int l, int r) {\n\twhile (l < r)\n\t\tif (st.pos == t[st.v].len()) {\n\t\t\tst = state (t[st.v].get( s[l] ), 0);\n\t\t\tif (st.v == -1)  return st;\n\t\t}\n\t\telse {\n\t\t\tif (s[ t[st.v].l + st.pos ] != s[l])\n\t\t\t\treturn state (-1, -1);\n\t\t\tif (r-l < t[st.v].len() - st.pos)\n\t\t\t\treturn state (st.v, st.pos + r-l);\n\t\t\tl += t[st.v].len() - st.pos;\n\t\t\tst.pos = t[st.v].len();\n\t\t}\n\treturn st;\n}\n \nint split (state st) {\n\tif (st.pos == t[st.v].len())\n\t\treturn st.v;\n\tif (st.pos == 0)\n\t\treturn t[st.v].par;\n\tnode v = t[st.v];\n\tint id = sz++;\n\tt[id] = node (v.l, v.l+st.pos, v.par);\n\tt[v.par].get( s[v.l] ) = id;\n\tt[id].get( s[v.l+st.pos] ) = st.v;\n\tt[st.v].par = id;\n\tt[st.v].l += st.pos;\n\treturn id;\n}\n \nint get_link (int v) {\n\tif (t[v].link != -1)  return t[v].link;\n\tif (t[v].par == -1)  return 0;\n\tint to = get_link (t[v].par);\n\treturn t[v].link = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));\n}\n \nvoid tree_extend (int pos) {\n\tfor(;;) {\n\t\tstate nptr = go (ptr, pos, pos+1);\n\t\tif (nptr.v != -1) {\n\t\t\tptr = nptr;\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = split (ptr);\n\t\tint leaf = sz++;\n\t\tt[leaf] = node (pos, n, mid);\n\t\tt[mid].get( s[pos] ) = leaf;\n \n\t\tptr.v = get_link (mid);\n\t\tptr.pos = t[ptr.v].len();\n\t\tif (!mid)  break;\n\t}\n}\n \nvoid build_tree() {\n\tsz = 1;\n\tfor (int i=0; i<n; ++i)\n\t\ttree_extend (i);\n}\n\nstruct stateX {\n  int v;\n  int l;\n  int r;\n\n  stateX() {\n    v = 0;\n    l = r = 0;\n  }\n\n  void go(char c) {\n    if (l == r) {\n      if (t[v].next.find(c) == t[v].next.end()) {\n        v = -1;\n      } else {\n        v = t[v].next[c];\n        l = t[v].l + 1;\n        r = t[v].r;\n      }\n    } else {\n      if (s[l] != c) {\n        v = -1;\n      } else {\n        l++;\n      }\n    }\n  }\n};\n\nstruct query {\n  int from;\n  int to;\n  int id;\n  int pos;\n  char ch;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> s;\n  s = s + ""$"";\n  n = (int) s.size();\n  build_tree();\n  int m;\n  cin >> m;\n  vector<string> xs(m);\n  vector<int> change_pos(m, -1);\n  vector<char> change_char(m, \'.\');\n  auto update = [&](int id, int pos, char ch) {\n    if (pos > change_pos[id] || (pos == change_pos[id] && ch < change_char[id])) {\n      change_pos[id] = pos;\n      change_char[id] = ch;\n    }\n  };\n  vector<vector<query>> qs(sz);\n  for (int i = 0; i < m; i++) {\n    int from, to;\n    cin >> from >> to >> xs[i];\n    from--; to--;\n    int len = to - from + 1;\n    stateX st;\n    for (int j = 0; j <= (int) xs[i].size(); j++) {\n      if (j + 1 > len) {\n        break;\n      }\n      char start = (j < (int) xs[i].size() ? (char) (xs[i][j] + 1) : \'a\');\n      for (char c = start; c <= \'z\'; c++) {\n        stateX st2 = st;\n        st2.go(c);\n        if (st2.v == -1) {\n          continue;\n        }\n        qs[st2.v].push_back({from, to - j, i, j, c});\n      }\n      if (j == (int) xs[i].size()) {\n        break;\n      }\n      st.go(xs[i][j]);\n      if (st.v == -1) {\n        break;\n      }\n    }\n  }\n  vector<set<int>> leafs(sz);\n  vector<int> depth(sz, 0);\n  function<void(int)> dfs = [&](int v) {\n    if (t[v].next.empty()) {\n      leafs[v].insert(n - depth[v]);\n    }\n    for (auto &p : t[v].next) {\n      int u = p.second;\n      depth[u] = depth[v] + (t[u].r - t[u].l);\n      dfs(u);\n      if (leafs[u].size() > leafs[v].size()) {\n        swap(leafs[u], leafs[v]);\n      }\n      for (int x : leafs[u]) {\n        leafs[v].insert(x);\n      }\n      set<int>().swap(leafs[u]);\n    }\n    for (auto &q : qs[v]) {\n      auto it = leafs[v].lower_bound(q.from);\n      if (it != leafs[v].end() && *it <= q.to) {\n        update(q.id, q.pos, q.ch);\n      }\n    }\n  };\n  dfs(0);\n  for (int i = 0; i < m; i++) {\n    if (change_pos[i] == -1) {\n      cout << -1 << \'\\n\';\n    } else {\n      cout << xs[i].substr(0, change_pos[i]) << change_char[i] << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",3200,The solution does the following 1 Build the suffix tree of the whole string we can construct a suffix tree in time using Suffix Array and LCP Array or in O using any well known algorithm like Ukkonen s algorithm 2 Note that in a suffix tree any path from root to leaf is a suffix of the given string Since we have appended an additional character at the end of S whose ascii value is smaller than all the literals of string we have leaves in our suffix tree 3 For example consider the suffix tree of It will look like image shown 4 Create appropriate type segment tree for the leaves from left to right storing starting position of that leaves i e segment tree for is starting positions are using 0 based indexing for string S 5 To answer the request start descending with this string in the suffix tree from root To make the larger string we can end the descent process and go on the other edge which contains a larger symbol to do this we need to have at least one valid suffix in this subtree Valid suffix it s beginning should be and if you stand in the vertex of subtree with length then that is So the request is too see if any leaf in subtree of matching character from current node has at least on value The rest is to handle the descent i e for example if going to a node with match character from current node in the middle if we encounter the character to be greater than corresponding character of X then we will stop the descent process or if the character of S is smaller than corresponding character of X then we must ascend till we find a node having valid suffix and matching character greater than corresponding character of S Complexity of the solution is per request Consider processing the query for 2 5 abcaModify for 0 based indexes i e 1 4 abca Matching character a The node 3 matches with a its subtree have leaves with 6 0 4 1 values and 1 4 are acceptable so we can ascend Matching character b The node 6 matches with b its subtree have leaves with 4 1 both are acceptable values for i so we can ascend to node 6 Matching character c The node 8 matches with c has leaf with value 1 and it is valid now we start matching subsequent characters to reach node 8 match c match a match can t match so start ascent process Current node 6 No node with character c exists so move to its parent 3 Current node 3 No node with character b exists so move to its parent 1 Current node 1 Node 9 has starting character b which is greater than a also the subtree of node 9 contains leaves with values 5 2 so we can take b and print the currently traversed string so far 
You are given an unweighted tree with n vertices Recall that a tree is a connected undirected graph without cycles Your task is to choose vertices a b c on this tree such that the number of edges which belong to one of the simple paths between a and b b and c or a and c is the maximum possible See the notes section for a better understanding The simple path is the path that visits each vertex at most once ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nint de[N];\nint fa[N];\nvector<int>G[N];\nint root;\nint ed;\nint vis[N];\nint d[N];\nvoid dfs(int x){\n    for(int i=0;i<G[x].size();i++){\n        int &y=G[x][i];\n        if(!de[y]){\n            fa[y]=x;\n            de[y]=de[x]+1;\n            dfs(y);\n        }\n    }\n}\nqueue<int>q;\nvoid dfs1(int x){\n    vis[x]=1;\n    q.push(x);\n    if(fa[x]<=0)return;\n    dfs1(fa[x]);\n}\nint main()\n{\n    cin>>n;\n    for(int i=1,u,v;i<n;i++){\n        scanf(""%d%d"",&u,&v);\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n    de[1]=1;\n    dfs(1);\n    for(int i=1;i<=n;i++){\n        if(de[i]>de[root])root=i;\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)de[i]=fa[i]=0;\n    de[root]=1;\n    dfs(root);\n    for(int i=1;i<=n;i++){\n        if(de[i]>de[ed])ed=i;\n    }\n    ans=de[ed]-1;\n    dfs1(ed);\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        for(int i=0;i<G[x].size();i++){\n            int &y=G[x][i];\n            if(!vis[y]){\n                vis[y]=1;\n                d[y]=d[x]+1;\n                q.push(y);\n            }\n        }\n    }\n    int mx=1;\n    while(mx==root||mx==ed)mx++;\n    for(int i=1;i<=n;i++)if(d[i]>d[mx])mx=i;\n    ans+=d[mx];\n    //cout<<root<<\' \'<<ed<<endl;\n    cout<<ans<<endl;\n    cout<<root<<\' \'<<mx<<\' \'<<ed<<endl;\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000,There is some obvious dynamic programming solution that someone can describe in the comments but I will describe another one that in my opinion much easier to implement Firstly let s find some diameter of the tree Let and be the endpoints of this diameter and first two vertices of the answer You can prove yourself why it is always good to take the diameter and why any diameter can be taken in the answer Then there are two cases the length of the diameter is or the length of the diameter is less than In the first case you can take any other vertex as the third vertex of the answer it will not affect the answer anyway Otherwise we can run multi source bfs from all vertices of the diameter and take the farthest vertex as the third vertex of the answer It is always true because we can take any diameter and the farthest vertex will increase the answer as much as possible Time complexity 
You are given a matrix a consisting of n rows by m columns Each element of the matrix is equal to 0 or 1 You can perform the following operation any number of times possibly zero choose an element of the matrix and replace it with either 0 or 1 You are also given two arrays A and B of length n and m respectively After you perform the operations the matrix should satisfy the following conditions the number of ones in the i th row of the matrix should be exactly A i for every i in 1 n the number of ones in the j th column of the matrix should be exactly B j for every j in 1 m Calculate the minimum number of operations you have to perform ,"['/**\n *    author:  tourist\n *    created: 18.12.2023 09:46:05       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\n#include <bits/extc++.h>\n\ntemplate <typename T, typename C>\nclass MCMF {\n public:\n  static constexpr T eps = (T) 1e-9;\n\n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n    C cost;\n  };\n\n  int n;\n  vector<vector<int>> g;\n  vector<edge> edges;\n  vector<C> d;\n  vector<C> pot;\n  __gnu_pbds::priority_queue<pair<C, int>> q;\n  vector<typename decltype(q)::point_iterator> its;\n  vector<int> pe;\n  const C INF_C = numeric_limits<C>::max() / 2;\n\n  explicit MCMF(int n_) : n(n_), g(n), d(n), pot(n, 0), its(n), pe(n) {}\n\n  int add(int from, int to, T forward_cap, T backward_cap, C edge_cost) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    assert(forward_cap >= 0 && backward_cap >= 0);\n    int id = static_cast<int>(edges.size());\n    g[from].push_back(id);\n    edges.push_back({from, to, forward_cap, 0, edge_cost});\n    g[to].push_back(id + 1);\n    edges.push_back({to, from, backward_cap, 0, -edge_cost});\n    return id;\n  }\n\n  void expath(int st) {\n    fill(d.begin(), d.end(), INF_C);\n    q.clear();\n    fill(its.begin(), its.end(), q.end());\n    its[st] = q.push({pot[st], st});\n    d[st] = 0;\n    while (!q.empty()) {\n      int i = q.top().second;\n      q.pop();\n      its[i] = q.end();\n      for (int id : g[i]) {\n        const edge &e = edges[id];\n        int j = e.to;\n        if (e.c - e.f > eps && d[i] + e.cost < d[j]) {\n          d[j] = d[i] + e.cost;\n          pe[j] = id;\n          if (its[j] == q.end()) {\n            its[j] = q.push({pot[j] - d[j], j});\n          } else {\n            q.modify(its[j], {pot[j] - d[j], j});\n          }\n        }\n      }\n    }\n    swap(d, pot);\n  }\n   \n  pair<T, C> max_flow_min_cost(int st, int fin) {\n    T flow = 0;\n    C cost = 0;\n    bool ok = true;\n    for (auto& e : edges) {\n      if (e.c - e.f > eps && e.cost + pot[e.from] - pot[e.to] < 0) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      expath(st);\n    } else {\n      vector<int> deg(n, 0);\n      for (int i = 0; i < n; i++) {\n        for (int eid : g[i]) {\n          auto& e = edges[eid];\n          if (e.c - e.f > eps) {\n            deg[e.to] += 1;\n          }\n        }\n      }\n      vector<int> que;\n      for (int i = 0; i < n; i++) {\n        if (deg[i] == 0) {\n          que.push_back(i);\n        }\n      }\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int eid : g[que[b]]) {\n          auto& e = edges[eid];\n          if (e.c - e.f > eps) {\n            deg[e.to] -= 1;\n            if (deg[e.to] == 0) {\n              que.push_back(e.to);\n            }\n          }\n        }\n      }\n      fill(pot.begin(), pot.end(), INF_C);\n      pot[st] = 0;\n      if (static_cast<int>(que.size()) == n) {\n        for (int v : que) {\n          if (pot[v] < INF_C) {\n            for (int eid : g[v]) {\n              auto& e = edges[eid];\n              if (e.c - e.f > eps) {\n                if (pot[v] + e.cost < pot[e.to]) {\n                  pot[e.to] = pot[v] + e.cost;\n                  pe[e.to] = eid;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        que.assign(1, st);\n        vector<bool> in_queue(n, false);\n        in_queue[st] = true;\n        for (int b = 0; b < (int) que.size(); b++) {\n          int i = que[b];\n          in_queue[i] = false;\n          for (int id : g[i]) {\n            const edge &e = edges[id];\n            if (e.c - e.f > eps && pot[i] + e.cost < pot[e.to]) {\n              pot[e.to] = pot[i] + e.cost;\n              pe[e.to] = id;\n              if (!in_queue[e.to]) {\n                que.push_back(e.to);\n                in_queue[e.to] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    while (pot[fin] < INF_C) {\n      T push = numeric_limits<T>::max();\n      int v = fin;\n      while (v != st) {\n        const edge &e = edges[pe[v]];\n        push = min(push, e.c - e.f);\n        v = e.from;\n      }\n      v = fin;\n      while (v != st) {\n        edge &e = edges[pe[v]];\n        e.f += push;\n        edge &back = edges[pe[v] ^ 1];\n        back.f -= push;\n        v = e.from;\n      }\n      flow += push;\n      cost += push * pot[fin];\n      expath(st);\n    }\n    return {flow, cost};\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  MCMF<int, int> g(n + m + 2);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int x;\n      cin >> x;\n      ans += x;\n      g.add(i, n + j, 1, 0, x == 1 ? -1 : 1);\n    }\n  }\n  vector<int> a(n);\n  vector<int> ea(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    ea[i] = g.add(n + m, i, a[i], 0, 0);\n  }\n  vector<int> b(m);\n  vector<int> eb(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n    eb[i] = g.add(n + i, n + m + 1, b[i], 0, 0);\n  }\n  auto res = g.max_flow_min_cost(n + m, n + m + 1);\n  for (int i = 0; i < n; i++) {\n    if (g.edges[ea[i]].f != a[i]) {\n      cout << -1 << \'\\n\';\n      return 0;\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    if (g.edges[eb[i]].f != b[i]) {\n      cout << -1 << \'\\n\';\n      return 0;\n    }\n  }\n  ans += res.second;\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2400,There are many ways to solve this problem even if all of them are based on minimum cost flows but in my opinion the most elegant one is the following one Let us build another matrix of size that meets the following requirements the sum in the th row of the matrix is the sum in the th column of the matrix is the number of cells such that is the maximum possible It s quite easy to see that this matrix is the one which we need to transform the matrix into the first two conditions are literally from the problem statement and the third condition ensures that the number of s we change into s is as small as possible and since we know the number of s in the matrix and we know that the number of s in the matrix should be exactly this also minimizes the number of times we change a into a So the third condition minimizes the number of operations we have to perform How can we build Let s model it with a flow network with costs We will need a source let s call it a sink let s call it a vertex for every row let s call it for the th row and a vertex for every column let s call it for the th column To model that we want the th row to have the sum let s add a directed edge from to with capacity of and cost of Some solutions will also need to make sure that this directed edge has a lower constraint on the flow equal to but we will show later why it s unnecessary in our method Similarly to model that the th column should have sum add a directed edge from to with capacity and cost To model that we can choose either or for the cell add a directed edge from to with capacity The value in the corresponding cell of the matrix will be equal to the flow along that edge The cost of this edge should reflect that we want to have as many cells such that To ensure that let s make its cost if or if That way the cost of the flow increases by each time we put a in a cell where and since the number of s in the matrix is fixed this means that we put a in a cell where so the number of cells such that gets reduced Now our network is ready In order to make sure that all edges connecting with and with are saturated we have to find the minimum cost flow in it Since the network has no negative cycles the number of vertices is the number of edges is and the maximum flow in the network is also any reasonable MCMF algorithm can be used After running MCMF let s check that the amount of the flow we pushed is equal both to and to If that s not the case then it is impossible to construct the matrix so the answer is Otherwise to calculate the number of operations we have to perform we can either restore the matrix from the flow we got and calculate the number of cells such that or derive a formula which can calculate the number of operations directly from the number of s in number of s in and the cost of the flow The model solution does the latter 
Alice and Bob are playing a game in the shop There are n items in the shop each item has two parameters a i item price for Alice and b i item price for Bob Alice wants to choose a subset possibly empty of items and buy them After that Bob does the following if Alice bought less than k items Bob can take all of them for free otherwise he will take k items for free that Alice bought Bob chooses which k items it will be and for the rest of the chosen items Bob will buy them from Alice and pay b i for the i th item Alice s profit is equal to sum limits i in S b i sum limits j in T a j where S is the set of items Bob buys from Alice and T is the set of items Alice buys from the shop In other words Alice s profit is the difference between the amount Bob pays her and the amount she spends buying the items Alice wants to maximize her profit Bob wants to minimize Alice s profit Your task is to calculate Alice s profit if both Alice and Bob act optimally ,"['#include ""bits/stdc++.h""#pragma GCC optimize (""O3"")#pragma GCC target (""sse4"") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\xa0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\xa0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}void __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}void __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}void __print(bool x) {cerr << (x ? ""true"" : ""false"");}\xa0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}template<typename T>void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}void _print() {cerr << ""]\\n"";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;#else#define dbg(x...)#endif\xa0\xa0const int MOD = 1000000007;const char nl = \'\\n\';const int MX = 100001; \xa0void solve() {    int N, K; cin >> N >> K;    vpl A(N); F0R(i, N) cin >> A[i].s;    F0R(i, N) cin >> A[i].f;    F0R(i, N) A[i].f *= -1;    sort(all(A));    F0R(i, N) A[i].f *= -1;    multiset<ll> cur;    ll ans = 0;    ll cans = 0;    F0R(i, K) {         cur.ins(A[i].s);        cans -= A[i].s;    }    FOR(i, K, N) {        cans += max(0ll, A[i].f - A[i].s);    }    ckmax(ans, cans);    FOR(i, K, N) {        cans -= max(0ll, A[i].f - A[i].s);        cur.ins(A[i].s);        cans -= A[i].s;        cans += *cur.rbegin();        cur.erase(cur.find(*cur.rbegin()));        ckmax(ans, cans);    }\xa0    cout << ans << nl;\xa0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\xa0    int T = 1;    cin >> T;    while(T--) {        solve();    }\xa0\treturn 0;}\xa0\xa0']","[1, 1, 0, 0, 1, 0, 0, 0, 1, 0]",1900,Let s sort the array in descending order based on the array For a fixed set of Alice s items Bob will take the first of them for free because they are the most expensive and pay for the rest Now we can iterate over the first item that Bob will pay denote it as Alice has to buy the cheapest items among denote the sum of these values as because Bob can take them for free Bob has to pay for each of the items among that Alice will buy So Alice will buy all the items with denote the sum of these values as Then the Alice s profit is Thus we got a solution that works in In order to speed up this solution we have to calculate the values and faster than We can do it as follows while iterating over the value of let s store free items in the ordered set and when the size of this set becomes larger than remove the most expensive element from it and the value of can be calculated using prefix sums over the values or maintaining a variable and update it when moving to the next value of 
Vasya likes to travel by train but doesn t like when the car he travels in is located in the tail of the train Vasya gets on the train at the station The train consists of n cars indexed from 1 to n counting from the locomotive head of the train Three types of events occur while the train is moving Some number of cars are added to the head of the train Some number of cars are added to the tail of the train Vasya recalculates the values of the convenience of the cars read more about it below At each moment of time we will index the cars from the head of the train starting from 1 Note that when adding new cars to the head of the train the indexing of the old ones may shift To choose which car to go in Vasya will use the value A i for each car where i is a car index which is calculated as follows At the beginning of the trip A i 0 as well as for the new cars at the time of their addition During the next recalculation Vasya chooses some integers b and s and adds to all A i value b i 1 cdot s Vasya hasn t decided yet where he will get on the train and where will get off the train so after each event of one of the three types he wants to know the least index of the car such that its value A i is minimal Since there is a lot of cars Vasya asked you to write a program that answers his question ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n  long long x, y;\n\n  point(long long x = 0, long long y = 0): x(x), y(y) {\n  }\n\n  point operator - (const point &b) const {\n    return point(x - b.x, y - b.y);\n  }\n};\n\nbool check(point p, point q, point r) {\n  point pp = p - q, rr = r - q;\n  return (long double) pp.x * rr.y >= (long double) pp.y * rr.x;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  int m;\n  cin >> n >> m;\n  long long add = 0, slope = 0;\n  vector<point> hull(1, point(0, 0));\n  while (m--) {\n    int type;\n    cin >> type;\n    if (type == 1) {\n      int cnt;\n      cin >> cnt;\n      hull.clear();\n      hull.push_back(point(0, 0));\n      n += cnt;\n      add = slope = 0;\n    } else if (type == 2) {\n      int cnt;\n      cin >> cnt;\n      while (hull.size() > 1 && check(point(n, -(n * slope + add)), hull[hull.size() - 2], hull[hull.size() - 1])) {\n        hull.pop_back();\n      }\n      hull.push_back(point(n, -(n * slope + add)));\n      n += cnt;\n    } else {\n      int b, s;\n      cin >> b >> s;\n      add += b;\n      slope += s;\n    }\n    while (hull.size() > 1 && slope * hull.back().x + hull.back().y >= slope * hull[hull.size() - 2].x + hull[hull.size() - 2].y) {\n      hull.pop_back();\n    }\n    cout << hull.back().x + 1 << "" "" << slope * hull.back().x + hull.back().y + add << ""\\n"";\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2700,There are many approaches to this problem many of them having time but we will describe a purely linear solution First notice that for every group of cars added together we need only to care about the first car in this group the remaining ones will never be the answer Second notice that there are some cars appended to the head of the train then all previous cars will never be answer again so we can simply replace them with cars with So now we only need to care about operations of adding cars to the tail and about adding the progression Suppose cars located at positions and have comfort Then observe the lower left convex hull of points One can see that the points not lying on this hull will never be an answer Also note that we can handle all progressions implicitly suppose the progressions are described with Then let s simply store current sums of and Then the operation of adding progression can be done by simply adding to those sums also we don t have to track the moment the cars are added since we can simply subtract from based on sums at the moment of So when we add cars to the end we simply need to add point to the end and possibly drop some points from the end of the current convex hull And when we add new progression we may also need to drop some elements from the hull but since it s the convex hull the line coefficients between neighboring points are monotonous so we need to drop only some points in the end of the hull 
Tokitsukaze has a permutation p She performed the following operation to p k times in one operation for each i from 1 to n 1 in order if p i p i 1 swap p i p i 1 After exactly k times of operations Tokitsukaze got a new sequence a obviously the sequence a is also a permutation After that Tokitsukaze wrote down the value sequence v of a on paper Denote the value sequence v of the permutation a of length n as v i sum j 1 i 1 a i a j where the value of a i a j define as if a i a j the value is 1 otherwise is 0 in other words v i is equal to the number of elements greater than a i that are to the left of position i Then Tokitsukaze went out to work There are three naughty cats in Tokitsukaze s house When she came home she found the paper with the value sequence v to be bitten out by the cats leaving several holes so that the value of some positions could not be seen clearly She forgot what the original permutation p was She wants to know how many different permutations p there are so that the value sequence v of the new permutation a after k operations is the same as the v written on the paper not taking into account the unclear positions Since the answer may be too large print it modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nmint p2[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi a=readvi(n);\n\tmint ans=1;\n\trep(i,n-k){\n\t\tint j=i+k;\n\t\tint w;\n\t\tif(a[i]==-1){\n\t\t\tw=j+1;\n\t\t}else if(a[i]==0){\n\t\t\tw=k+1;\n\t\t}else{\n\t\t\tw=1;\n\t\t}\n\t\tans*=w;\n\t}\n\trng(i,n-k,n){\n\t\tint j=i-(n-k);\n\t\tint w;\n\t\tif(a[i]==0||a[i]==-1){\n\t\t\tw=j+1;\n\t\t}else{\n\t\t\tw=0;\n\t\t}\n\t\tans*=w;\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2500,Tutorial Consider finding out the relationship between sequence and permutation It can be observed that the permutation have bijective relationship with sequence That is to say sequence will only correspond to one permutation as it can be proved Let and find that the last number can be determined through because there is no number after this position We observe that is the largest number in then delete from we can get So repeat the process we can get the whole permutation Consider counting we observe that each bubble sort will first make then the whole moves left is directly covered is set to Because each valued is preceded by a number larger than the current position then it will definitely be exchanged and moved forward minus For example if the current after once bubble sort To avoid confusion the array below is the in the input It s easy to count after knowing the above conclusion For the position it can be observed that after times of bubble sort it is directly covered so just multiply the answer by For the position if then obviously is uniquely determined If then has possible values multiply the answer by If then multiply the answer by Note that for the position should be or otherwise the answer must be Complexity 
A permutation scientist is studying a self transforming permutation a consisting of n elements a 1 a 2 ldots a n A permutation is a sequence of integers from 1 to n of length n containing each number exactly once For example 1 4 3 5 1 2 are permutations while 1 1 4 3 1 are not The permutation transforms day by day On each day each element x becomes a x that is a x becomes a a x Specifically on the first day the permutation becomes b where b x a a x on the second day the permutation becomes c where c x b b x ldots For example consider permutation a 2 3 1 On the first day it becomes 3 1 2 On the second day it becomes 2 3 1 You re given the permutation a on the k th day Define sigma x a x and define f x as the minimal positive integer m such that sigma m x x where sigma m x denotes underbrace sigma sigma ldots sigma m text times x ldots For example if a 2 3 1 then sigma 1 2 sigma 2 1 sigma sigma 1 sigma 2 3 sigma 3 1 sigma sigma sigma 1 sigma 3 1 so f 1 3 And if a 4 2 1 3 sigma 2 2 so f 2 1 sigma 3 1 sigma 2 3 4 sigma 3 3 3 so f 3 3 Find the initial permutation a such that sum limits n i 1 dfrac 1 f i is ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nconst int MAXN = 200005;\n\nlint ipow(lint x, lint p, lint m) {\n\tlint ret = 1, piv = x;\n\twhile (p) {\n\t\tif (p & 1)\n\t\t\tret = ret * piv % m;\n\t\tpiv = piv * piv % m;\n\t\tp >>= 1;\n\t}\n\treturn ret % m;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (auto &z : a)\n\t\t\tcin >> z, z--;\n\t\tvector<vector<vector<int>>> bySize(n + 1);\n\t\tvector<int> vis(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (vis[i])\n\t\t\t\tcontinue;\n\t\t\tvector<int> v;\n\t\t\tfor (int j = i; !vis[j]; j = a[j]) {\n\t\t\t\tv.push_back(j);\n\t\t\t\tvis[j] = 1;\n\t\t\t}\n\t\t\tbySize[sz(v)].push_back(v);\n\t\t}\n\t\tvector<int> ans(n);\n\t\tbool fail = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (sz(bySize[i]) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tint q = sz(bySize[i]);\n\t\t\t\tif (q & ((1 << min(k, 30)) - 1)) {\n\t\t\t\t\tfail = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint w = (1 << k);\n\t\t\t\tfor (int a = 0; a < q; a += w) {\n\t\t\t\t\tvector<int> pos;\n\t\t\t\t\tfor (int z = 0; z < i; z++) {\n\t\t\t\t\t\tfor (int b = a; b < a + w; b++) {\n\t\t\t\t\t\t\tpos.push_back(bySize[i][b][z]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int z = 0; z < sz(pos); z++)\n\t\t\t\t\t\tans[pos[z]] = pos[(z + 1) % sz(pos)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tint q = sz(bySize[i]);\n\t\t\t\tint ptr = min(k, 30);\n\t\t\t\tfor (int a = 0; a < q;) {\n\t\t\t\t\twhile ((1 << ptr) > q - a)\n\t\t\t\t\t\tptr--;\n\t\t\t\t\tint w = (1 << ptr);\n\t\t\t\t\tfor (int b = a; b < a + w; b++) {\n\t\t\t\t\t\tvector<int> v;\n\t\t\t\t\t\tint nxt = ipow((i + 1) / 2, k - ptr, i);\n\t\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\t\tv.push_back(bySize[i][b][1ll * j * nxt % i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbySize[i][b] = v;\n\t\t\t\t\t}\n\t\t\t\t\tvector<int> pos;\n\t\t\t\t\tfor (int z = 0; z < i; z++) {\n\t\t\t\t\t\tfor (int b = a; b < a + w; b++) {\n\t\t\t\t\t\t\tpos.push_back(bySize[i][b][z]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int z = 0; z < sz(pos); z++)\n\t\t\t\t\t\tans[pos[z]] = pos[(z + 1) % sz(pos)];\n\t\t\t\t\ta += w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fail) {\n\t\t\tcout << ""NO\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ""YES\\n"";\n\t\tfor (auto &z : ans)\n\t\t\tcout << z + 1 << "" "";\n\t\tcout << ""\\n"";\n\t}\n}\n']","[0, 1, 1, 0, 0, 0, 1, 0, 0, 0]",2500,Consider another question Given the initial permutation and find the permutation on the th day After a day element will become so we can consider the numbers as nodes and we add directed edges from to Note that is a permutation so the graph consists of several cycles After one day will become the second element after in the corresponding cycle Similarly we can conclude that will become the th element after If a cycle has an odd length Because the cycle will never split the element will become on the th day Otherwise if a cycle has an even length after the first day will become will become will become And so will the even indices that means the original cycle split into two small cycles of the So if a cycle of length will split into small cycles of length after exactly days Because the length of a cycle so we can perform the transformation for at least days to split all the cycles of even lengths into cycles of odd lengths Then we can use our conclusion to calculate the final permutation on the th day Now let s back to our question We observed that means the number of cycles in the original graph Then we need to construct the original permutation of the least possible cycle As we ve said before the cycle of length will split into small cycles of length after exactly days So we can count all the cycles in permutation For cycles of odd length we can combine some of them Specifically we can combine cycles into a cycle of length in the original permutation Note that must be less than or equal to And for cycles of even length we can also combine them But because they haven t been split on the th day we must combine exactly cycles So if the number of these cycles isn t a multiple of just print 
Dima has a birthday soon It s a big day Saryozha s present to Dima is that Seryozha won t be in the room and won t disturb Dima and Inna as they celebrate the birthday Inna s present to Dima is a stack a queue and a deck Inna wants her present to show Dima how great a programmer he is For that she is going to give Dima commands one by one There are two types of commands Add a given number into one of containers For the queue and the stack you can add elements only to the end For the deck you can add elements to the beginning and to the end Extract a number from each of at most three distinct containers Tell all extracted numbers to Inna and then empty all containers In the queue container you can extract numbers only from the beginning In the stack container you can extract numbers only from the end In the deck number you can extract numbers from the beginning and from the end You cannot extract numbers from empty containers Every time Dima makes a command of the second type Inna kisses Dima some possibly zero number of times Dima knows Inna perfectly well he is sure that this number equals the sum of numbers he extracts from containers during this operation As we ve said before Dima knows Inna perfectly well and he knows which commands Inna will give to Dima and the order of the commands Help Dima find the strategy that lets him give as more kisses as possible for his birthday ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define FI first\n#define SE second\n#define MP make_pair\n#define PII pair<int,int>\n#define flt double\n#define INF (0x3f3f3f3f)\n#define MaxN 1020304\n#define MaxNode 1020304\n#define MD 1000000007\n\nint n; PII cache[MaxN];\nint main() {\n    //freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);\n    cin >> n;\n    int Tot = 0;\n    For(i,1,n) {\n            int t;\n        scanf(""%d"",&t);\n        if (t) {\n            cache[++Tot] = MP(t,i);\n            continue ;\n        }\n        if (Tot <= 3) {\n            if (Tot) puts(""pushStack"");\n            if (Tot > 1) puts(""pushQueue"");\n            if (Tot > 2) puts(""pushFront"");\n            printf(""%d"",Tot);\n            if (Tot) printf("" popStack"");\n            if (Tot > 1) printf("" popQueue"");\n            if (Tot > 2) printf("" popFront"");\n            puts("""");\n            Tot = 0;\n            continue ;\n        }\n        sort(cache + 1,cache + Tot + 1);\n        reverse(cache + 1,cache + Tot + 1);\n        For(j,1,3) swap(cache[j].FI,cache[j].SE);\n        sort(cache + 1,cache + 4);\n        int cur = 0;\n        For(j,i - Tot,i - 1) {\n            if (!cur) {\n                puts(""pushStack""); \n                if (j == cache[1].FI) ++cur;\n                continue ;\n            }\n            if (cur == 1) {\n                if (j == cache[2].FI) {\n                    ++cur; puts(""pushQueue"");\n                } else {\n                    puts(""pushBack"");\n                }\n                continue ;\n            }\n            if (cur == 2) {\n                if (j == cache[3].FI) {\n                    ++cur; puts(""pushFront"");\n                } else {\n                    puts(""pushQueue"");\n                }\n                continue ;\n            }\n            puts(""pushQueue"");\n        }\n        printf(""3 popQueue popStack popFront\\n"");\n        Tot = 0;\n    }\n    if (Tot) For(i,1,Tot) puts(""pushStack"");\n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0]",2000,We know all the numbers at the beginning so it s clear that we want pop three maximums We can precalculate maximums with finding next zero and iterating through all numbers between two zeroes We should do pops from different containers so let s save maximums in the top of the stack in the beginning of the queue and on the beginning of the dek you can do this in some other way We should determine where will be stored the 1st 2nd and 3rd maximum For example the first the biggest one in the stack second in queue and the third in dek trash other numbers we can save into the end of the dek Also you need to catch cases when two or less numbers are between zeroes 
Pchelyonok decided to give Mila a gift Pchelenok has already bought an array a of length n but gifting an array is too common Instead of that he decided to gift Mila the segments of that array Pchelyonok wants his gift to be beautiful so he decided to choose k non overlapping segments of the array l 1 r 1 l 2 r 2 ldots l k r k such that the length of the first segment l 1 r 1 is k the length of the second segment l 2 r 2 is k 1 ldots the length of the k th segment l k r k is 1 for each i j the i th segment occurs in the array earlier than the j th i e r i l j the sums in these segments are strictly increasing i e let sum l ldots r sum limits i l r a i the sum of numbers in the segment l r of the array then sum l 1 ldots r 1 sum l 2 ldots r 2 ldots sum l k ldots r k Pchelenok also wants his gift to be as beautiful as possible so he asks you to find the maximal value of k such that he can give Mila a gift ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""e.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tvector<ll> s0(n + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\ts0[i + 1] = s0[i] + a[i];\n\t\t}\n\t\tauto s = [&](int i, int j) {\n\t\t\treturn s0[j + 1] - s0[i];\n\t\t};\n\t\tint m = 0;\n\t\twhile (m * (m + 1) / 2 <= n) {\n\t\t\t++m;\n\t\t}\n\t\tm += 2;\n\t\tconst ll INF = (1LL << 62);\n\t\tvector<vector<ll>> f(m + 1, vector<ll>(m));\n\t\tvector<vector<ll>*> g(n + 1);\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tg[i] = &f[i % (m + 1)];\n\t\t}\n\t\t(*g[n])[0] = INF;\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tauto& cur = (*g[i]);\n\t\t\tcur[0] = INF;\n\t\t\tauto& prev = (*g[i + 1]);;\n\t\t\tfor (int k = 1; k < m; ++k) {\n\t\t\t\tcur[k] = prev[k];\n\t\t\t\tif (i + k - 1 < n) {\n\t\t\t\t\tll s2 = s(i, i + k - 1);\n\t\t\t\t\tif (s2 < (*g[i + k])[k - 1]) {\n\t\t\t\t\t\tcur[k] = max(cur[k], s2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 1;\n\t\tfor (int k = 1; k < m; ++k) {\n\t\t\tif (f[0][k] > 0) {\n\t\t\t\tret = k;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ret);\n\t}\n\treturn 0;\n}\n']","[1, 1, 0, 1, 1, 0, 0, 1, 0, 0]",2000,Let s notice that can be the answer only if the sum of lengths of the segments does not exceed the number of elements in the array that is From this inequation we can get that is less than and when hits its maximal value it does not exceed Let be the maximal sum on the segment of length with that we have already considered all elements on the suffix that is elements with indices and have already chosen segments with lengths in which the sums increase Let s learn to recalculate the values of dynamics We can either not include the th element in the segment of length then we need refer to the value of dynamics or include the th element and then we are interested in the value of dynamics if it s greater than the sum on the segment then we can take segments with lengths from to on the suffix answ otherwise we cannot take such segments on the suffix We need to take the maximum among these two cases in order to maximize the sum To calculate the sum on a segment you can use prefix sums Asymptotic behavior of this solution 
You are given a string Find a string where is a palindrome and is a subsequence of A subsequence of a string is a string that can be derived from it by deleting some not necessarily consecutive characters without changing the order of the remaining characters For example is a subsequence of A palindrome is a string that reads the same forward or backward The length of string should be at most It is guaranteed that there always exists such string You do not need to find the shortest answer the only restriction is that the length of string should not exceed ,"['//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tstring p=s;\n\treverse(p.begin(), p.end());\n\tcout << s << p << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",800,Let be the reverse of string Now will always have as a subsequence as first half and it is a palindrome with size less than So it may be one of the possible solutions 
A number a 2 is said to be the arithmetic mean of two numbers a 1 and a 3 if the following condition holds a 1 a 3 2 cdot a 2 We define an arithmetic mean deviation of three numbers a 1 a 2 and a 3 as follows d a 1 a 2 a 3 a 1 a 3 2 cdot a 2 Arithmetic means a lot to Jeevan He has three numbers a 1 a 2 and a 3 and he wants to minimize the arithmetic mean deviation d a 1 a 2 a 3 To do so he can perform the following operation any number of times possibly zero Choose i j from 1 2 3 such that i ne j and increment a i by 1 and decrement a j by 1 Help Jeevan find out the minimum value of d a 1 a 2 a 3 that can be obtained after applying the operation any number of times ,"['// Problem: A. A.M. Deviation\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/A\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),m=read(),k=read();\n\t\tif((n+m+k)%3) puts(""1""); else puts(""0"");\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Applying the operation on and irrespective of which element is incremented and which one is decremented does not change the value of Incrementing or by and decrementing by causes the value of to increase by Decrementing or by and incrementing by causes the value of to decrease by This effectively means that we can add or subtract any multiple of by performing some number of operations Also the value of will never change modulo Thus If then the minimum value of If then the minimum value of If then the minimum value of In simpler words if is divisible by the answer is otherwise it is 
You have a malfunctioning microwave in which you want to put some bananas You have n time steps before the microwave stops working completely At each time step it displays a new operation Let k be the number of bananas in the microwave currently Initially k 0 In the i th operation you are given three parameters t i x i y i in the input Based on the value of t i you must do one of the following t i 1 x i y i pick an a i such that 0 le a i le y i and perform the following update a i times k lceil k x i rceil t i 2 x i y i pick an a i such that 0 le a i le y i and perform the following update a i times k lceil k cdot x i rceil Note that See input format for more details Also lceil x rceil is the smallest integer ge x At the i th time step you must apply the i th operation exactly once For each j such that 1 le j le m output the earliest time step at which you can create j bananas If you cannot create j bananas output 1 ,"['#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=1e9+7;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],b[1000002],c[1000002],ans[100002];\nlong double d[1000002];\nsigned main(){\n\tn=read(),m=read();\n\tfor(re int i=1;i<=n;++i)a[i]=read(),b[i]=read(),c[i]=read();\n\tmemset(ans,-1,sizeof(ans));ans[0]=0;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]==1){\n\t\t\tb[i]=(b[i]+99999)/100000;\n\t}\n\t\tfor(re int j=m;~j;--j)\n\t\t\tif(ans[j]>-1){\n\t\t\t\tif(j==0&&a[i]==2)continue;\n\t\t\t\tre int x=j;\n\t\t\t\tre int num=0;\n\t\t\t\twhile(1){\n\t\t\t\t\t++num;\n\t\t\t\t\tif(num>c[i])break;\n\t\t\t\t\tif(a[i]==1)x=x+b[i];\n\t\t\t\t\telse x=(x*b[i]+99999)/100000;\n\t\t\t\t\tre int tmp=x;x=tmp;\n\t\t\t\t\tif(tmp>m)break;\n\t\t\t\t\tif(ans[tmp]>-1)break;\n\t\t\t\t\tans[tmp]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t}\n\tfor(re int i=1;i<=m;++i)printf(""%lld "",ans[i]);\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 1]",2200,We have a brute force O N M2 solution At every timestep t for each banana bi that has already been reached previously apply this timestep s operation yt times on bi For all the yt bananas reachable from bi update their minimum reachability time if they hadn t been reached previously Why is this correct Simply because we are simulating each possible step of the algorithm exactly as it is described Therefore we cannot get an answer that s better or worse than that of the optimal solution 
Fishing Prince loves trees and he especially loves trees with only one centroid The tree is a connected graph without cycles A vertex is a of a tree only when you cut this vertex remove it and remove all edges from this vertex the size of the largest connected component of the remaining graph is the smallest possible For example the centroid of the following tree is 2 because when you cut it the size of the largest connected component of the remaining graph is 2 and it can t be smaller However in some trees there might be more than one centroid for example Both vertex 1 and vertex 2 are centroids because the size of the largest connected component is 3 after cutting each of them Now Fishing Prince has a tree He should cut one edge of the tree it means to remove the edge After that he should add one edge The resulting graph after these two operations should be a tree He can add the edge that he cut He wants the centroid of the resulting tree to be unique Help him and find any possible way to make the operations It can be proved that at least one such way always exists ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl \'\\n\'\n//#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\nconst int N = 100100;\nvi g[N];\nint tam[N];\n\n\nvi centroid;\nint n;\nvoid dfs1(int v,int p = -1){\n  tam[v] = 1;\n  bool is= 1;\n\n  for(int to : g[v])if(to!=p){\n    dfs1(to,v);\n    tam[v]+=tam[to];\n    if(tam[to] > n/2)is = 0;\n  }\n  if(n - tam[v] > n/2)is = 0;\n  if(is)centroid.pb(v);\n}\n\n\n\nvoid solve(){\n  cin >> n;\n  for(int i=1;i<=n;i++)g[i].clear(),tam[i] = 1;\n\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    g[a].pb(b);\n    g[b].pb(a);\n  } \n  centroid.clear();\n  dfs1(1);\n  vector<pii> ans;\n  if(sz(centroid) == 1){\n    int to = g[1][0];\n    ans.pb(pii(1,to));\n    ans.pb(pii(1,to));\n  }else{\n    for(int to : g[centroid[0]]){\n      if(to!=centroid[1]){\n        ans.pb(pii(centroid[0],to));\n        ans.pb(pii(to,centroid[1]));\n        break;\n      }\n    }\n  }\n  assert(sz(ans) == 2);\n  for(auto it : ans){\n    cout << it.ff<<"" ""<<it.ss<<endl;\n  }\n}\n\nint32_t main(){\n  FASTIO;\n  int t;\n  cin >> t;\n  while(t--){\n    solve();\n  }\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",1700,Let vertex be the root of the tree If there is only one centroid just cut any edge and link it back Otherwise there are two centroids Let them be and then there must be an edge connecting and If not choose any other vertex on the path from to and the size of the largest connected component after cutting it will be smaller than and Let be s father If not swap and Then just cut a leaf from s subtree and link it with After that becomes the only centroid Proof It s easy to see that the size of s subtree must be exactly After cutting and linking the maxinum component size of becomes while the maxinum component size of is still 
Sasha decided to give his girlfriend an array a 1 a 2 ldots a n He found out that his girlfriend evaluates the of the array as the sum of the values a i a i 1 for all integers i from 2 to n Help Sasha and tell him the maximum beauty of the array a that he can obtain if he can rearrange its elements in any way ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005];\nint main()\n{\n\tint t,n;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)a[i]=read();\n\t\tint maxn=a[1],minn=a[1];\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tmaxn=max(maxn,a[i]);\n\t\t\tminn=min(minn,a[i]);\n\t\t}\n\t\tprintf(""%d\\n"",maxn-minn);\n\t} \n}\n']","[1, 1, 0, 0, 0, 0, 1, 0, 1, 0]",800,a2 a1 a3 a2 an an 1 an a1 So we just need to maximize this value which means the answer is the maximum number in the array minus the minimum 
You are given a tree a connected acyclic undirected graph of vertices Vertices are numbered from to and each vertex is assigned a character from to A path in the tree is said to be palindromic if at least one permutation of the labels in the path is a palindrome For each vertex output the number of palindromic paths passing through it The path from vertex to vertex is considered to be the same as the path from vertex to vertex and this path will be counted only once for each of the vertices it passes through ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=210000;\nint head[N],np[N<<1],p[N<<1],tot;\nint n;\nchar _str[N];\nint col[N];\nint fa[N],size[N];\nbool vis[N],inq[N];\nint q[N];\nLL ans[N];\nint getRoot(int ss){\n\tq[q[0]=1]=ss;\n\tinq[ss]=1;\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfor(int u=head[x];u;u=np[u])if(!vis[p[u]])if(!inq[p[u]]){\n\t\t\tfa[p[u]]=x;\n\t\t\tq[++q[0]]=p[u];\n\t\t\tinq[p[u]]=1;\n\t\t}\n\t}\n\tint mi=1000000;\n\tint rp=0;\n\tper(i,q[0],1){\n\t\tint x=q[i];\n\t\tint ma=-1;\n\t\tsize[x]=1;\n\t\tfor(int u=head[x];u;u=np[u])if(!vis[p[u]])if(inq[p[u]])if(fa[p[u]]==x){\n\t\t\tsize[x]+=size[p[u]];\n\t\t\tma=max(ma,size[p[u]]);\n\t\t}\n\t\tma=max(ma,q[0]-size[x]);\n\t\tif(ma<mi){\n\t\t\tmi=ma;\n\t\t\trp=x;\n\t\t}\n\t}\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tsize[x]=fa[x];inq[x]=0;\n\t}\n\tq[0]=0;\n\treturn rp;\n}\nint val[N];\nvoid bfs1(int rt){\n\tq[q[0]=1]=rt;\n\tinq[rt]=1;\n\tval[rt]=(1<<col[rt]);\n\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfor(int u=head[x];u;u=np[u])if(!inq[p[u]])if(!vis[p[u]]){\n\t\t\tfa[p[u]]=x;\n\t\t\tinq[p[u]]=1;\n\t\t\tval[p[u]]=val[x]^(1<<col[p[u]]);\n\t\t\tq[++q[0]]=p[u];\n\t\t}\n\t}\n}\nint pp[1<<20];\nint ti[1<<20];\nint cnt[1<<20];\nint nowt;\nint meask(int t){\n\tif(ti[t]!=nowt){\n\t\tpp[t]=0;\n\t\tti[t]=nowt;\n\t}\n\treturn pp[t];\n}\nvoid meadd(int t,int v){\n\tif(ti[t]!=nowt){\n\t\tpp[t]=0;\n\t\tti[t]=nowt;\n\t}\n\tpp[t]+=v;\n}\nLL res=0;\nLL sb[N];\nvoid dfs1(int x,int ff){\n\tsb[x]=0;\n\tif(cnt[val[x]]<=1)++sb[x];\n\t//if(ff==2&&x==6)printf(""____________%d\\n"",sb[x]);\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tdfs1(p[u],x);\n\t\tsb[x]+=sb[p[u]];\n\t}\n\tans[x]+=sb[x];\n}\nint nowcol;\nvoid calc1(int x,int ff=-1){\n\tsb[x]=meask(val[x]^(1<<nowcol));\n\trep(i,0,19){\n\t\tint ot=(val[x]^(1<<nowcol));\n\t\tot^=(1<<i);\n\t\tsb[x]+=meask(ot);\n\t}\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tcalc1(p[u],x);\n\t\tsb[x]+=sb[p[u]];\n\t}\n\tans[x]+=sb[x];\n}\nvoid add1(int x,int ff=-1){\n\tmeadd(val[x],1);\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tadd1(p[u],x);\n\t}\n}\nint xp[N];\nvoid work(int ss){\n\tint rt=getRoot(ss);\n\tvis[rt]=1;\n\tbfs1(rt);\n\tnowt=rt;\n\tnowcol=col[rt];\n\t//root to it\n\tres=0;\n\tdfs1(rt,-1);\n\txp[0]=0;\n\t//rep(i,1,n)printf("".%d:%lld\\n"",i,ans[i]);\n\tfor(int u=head[rt];u;u=np[u])if(!vis[p[u]])if(inq[p[u]]){\n\t\tcalc1(p[u]);\n\t\tadd1(p[u]);\n\t\txp[++xp[0]]=p[u];\n\t\tans[rt]+=sb[p[u]];\n\t}\n\tnowt=n+rt;\n\tper(i,xp[0],1){\n\t\tint x=xp[i];\n\t\tcalc1(x);\n\t\tadd1(x);\n\t}\n\t//rep(i,1,n)printf(""%d:%lld\\n"",i,ans[i]);\n\t//rep(i,1,n)printf(""_%d:%d\\n"",i,val[i]);\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfa[x]=0;\n\t\tinq[x]=0;\n\t\tval[x]=0;\n\t\tsize[x]=0;\n\t}\n\tq[0]=0;\n\tfor(int u=head[rt];u;u=np[u])if(!vis[p[u]])work(p[u]);\n}\nint main(){\n\trep(i,1,(1<<20)-1)cnt[i]=cnt[i>>1]+(i&1);\n\tscanf(""%d"",&n);\n\trep(i,1,n-1){\n\t\tint a,b;scanf(""%d%d"",&a,&b);\n\t\t++tot;p[tot]=b;np[tot]=head[a];head[a]=tot;\n\t\t++tot;p[tot]=a;np[tot]=head[b];head[b]=tot;\n\t}\n\tscanf(""%s"",_str+1);\n\trep(i,1,n)col[i]=_str[i]-\'a\';\n\n\twork(1);\n\trep(i,1,n)printf(""%lld%c"",ans[i],i==n?\'\\n\':\' \');\n\treturn 0;\n}\n\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2400,The problem can be solved by centroid decomposition A path will be palindromic at most one letter appears odd number of times in the path We maintain a bitmask for each node where th bit is if the th character occurs odd number of times otherwise The path from to is valid if mask mask has at most one bit set to Consider a part as the subtree of the immediate children of the root of the the centroid tree For a node we need to consider the paths that go from its subtree to any other part We add the contribution of nodes in the subtree of a node using a simple dfs and propagating the values above and add the corresponding contribution to the answer of the node currently in consideration dfs Complexity is n log n 20 
A remote island chain contains islands labeled through Bidirectional bridges connect the islands to form a simple cycle a bridge connects islands and islands and and so on and additionally a bridge connects islands and The center of each island contains an identical pedestal and all but one of the islands has a fragile uniquely colored statue currently held on the pedestal The remaining island holds only an empty pedestal The islanders want to rearrange the statues in a new order To do this they repeat the following process First they choose an island directly adjacent to the island containing an empty pedestal Then they painstakingly carry the statue on this island across the adjoining bridge and place it on the empty pedestal Determine if it is possible for the islanders to arrange the statues in the desired order ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nint main()\n{\n\tint n;\n\trint(n);\n\tVI a(n), b(n);\n\tji(n) rint(a[i]);\t\n\tji(n) rint(b[i]);\n\ta.erase(find(a.begin(), a.end(), 0));\n\tb.erase(find(b.begin(), b.end(), 0));\n\tn--;\n\tint idx = 0;\n\twhile (b[idx] != a[0])\n\t\t++idx;\n\tji(n)\n\t{\n\t\tif (a[i] != b[(idx+i)%n])\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1300,Notice that as we move the empty pedestal around the circle we cyclically permute the statues and the empty pedestal can be anywhere Thus we can reach one state from another if and only if after removing the empty pedestal they are cyclic shifts of each other The starting and ending configurations are permutations so we can check this in linear time Runtime 
Consider an undirected connected graph consisting of n vertices and m edges Each vertex can be colored with one of three colors 1 2 or 3 Initially all vertices are uncolored Alice and Bob are playing a game consisting of n rounds In each round the following two step process happens Alice chooses two colors Bob chooses an uncolored vertex and colors it with one of the two colors chosen by Alice Alice wins if there exists an edge connecting two vertices of the same color Otherwise Bob wins You are given the graph Your task is to decide which player you wish to play as and win the game ,"['/** *    author:  tourist *    created: 28.07.2024 10:48:58**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0class dsu { public:  vector<int> p;  int n;\xa0  dsu(int _n) : n(_n) {    p.resize(n);    iota(p.begin(), p.end(), 0);  }\xa0  inline int get(int x) {    return (x == p[x] ? x : (p[x] = get(p[x])));  }\xa0  inline bool unite(int x, int y) {    x = get(x);    y = get(y);    if (x != y) {      p[x] = y;      return true;    }    return false;  }};\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n, m;    cin >> n >> m;    dsu d(2 * n);    for (int i = 0; i < m; i++) {      int a, b;      cin >> a >> b;      --a; --b;      d.unite(a, b + n);      d.unite(b, a + n);    }    bool non = false;    for (int i = 0; i < n; i++) {      if (d.get(i) == d.get(i + n)) {        non = true;        break;      }    }    if (non) {      cout << ""Alice"" << endl;      for (int i = 0; i < n; i++) {        cout << ""1 2"" << endl;        int a, b;        cin >> a >> b;      }    } else {      cout << ""Bob"" << endl;      vector<int> a, b;      for (int i = 0; i < n; i++) {        if (d.get(i) == d.get(0)) {          a.push_back(i);        } else {          b.push_back(i);        }      }      for (int it = 0; it < n; it++) {        int x, y;        cin >> x >> y;        if (x > y) {          swap(x, y);        }        int r = 6 - x - y;        if (a.empty()) {          cout << b.back() + 1 << "" "" << (r == 2 ? 3 : 2) << endl;          b.pop_back();          continue;        }        if (b.empty()) {          cout << a.back() + 1 << "" "" << (r == 1 ? 3 : 1) << endl;          a.pop_back();          continue;        }        if (r == 1) {          cout << b.back() + 1 << "" "" << 2 << endl;          b.pop_back();        } else {          cout << a.back() + 1 << "" "" << 1 << endl;          a.pop_back();        }      }    }  }  return 0;}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 1]",1900,If the graph is not bipartite Alice will win If the graph is bipartite Bob will win If the graph is not bipartite Alice can always choose colors 1 and 2 According to the definition of a non bipartite graph Bob cannot color the graph with two colors without having two adjacent vertices of the same color If the graph is bipartite it can be divided into two parts Part 1 and Part 2 with no edges within each part If the colors chosen by Alice include color 1 Bob can paint vertices in part 1 with color 1 If the colors chosen by Alice include color 2 Bob can paint vertices in part 2 with color 2 Once one part is completely painted Bob can use color 3 or continue using the original color of that part to paint the remaining vertices ensuring no two adjacent vertices have the same color In this way Bob will win 
You are given an array a with n non negative integers You can apply the following operation on it Choose two indices l and r 1 le l r le n If a l a r is odd do a r a l If a l a r is even do a l a r Find any sequence of at most n operations that makes a non decreasing It can be proven that it is always possible Note that you do not have to minimize the number of operations An array a 1 a 2 ldots a n is non decreasing if and only if a 1 le a 2 le ldots le a n ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint T;\n\nint n,m;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>a(n+1),vis(n+1);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin>>a[i];\n\t\tif(n==1)\n\t\t{\n\t\t\tcout<<0<<""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<n-1<<""\\n"";\n\t\tcout<<1<<"" ""<<n<<""\\n"";\n\t\tfor(int i=2;i<n;i++)\n\t\t\tif((a[i]+a[1])%2)\n\t\t\t\tcout<<1<<"" ""<<i<<""\\n"",vis[i]=1;\n\t\tfor(int i=n-1;i>1;i--)\n\t\t\tif(!vis[i])\n\t\t\t\tcout<<i<<"" ""<<n<<""\\n"";\n\t}\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 1, 0]",1300,SolutionIf do nothing Otherwise select indices and to make equal to first After that for each element select indices and if is odd and select indices and otherwise This process requires operations and make all elements equal which is also non decreasing 
You are given an array a of n positive integers In one operation you must pick some i j such that 1 leq i j leq a and append a i a j to the end of the a i e increase n by 1 and set a n to a i a j Your task is to minimize and print the minimum value of a after performing k operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 2007;\nint T, n, m, k;\nll a[N], b[N * N];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n >> k;\n\t\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\t\tif (k >= 3) {\n\t\t\tcout << ""0\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tll ans = 2e18;\n\t\t\tfor (int i = 1; i <= n; ++i) ans = min(ans, a[i]);\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\t\tans = min(ans, abs(a[i] - a[j]));\n\t\t\tcout << ans << \'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\tll ans = 2e18;\n\t\tfor (int i = 1; i <= n; ++i) ans = min(ans, a[i]);\n\t\tm = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\tb[++m] = abs(a[i] - a[j]);\n\t\tsort(b + 1, b + m + 1);\n\t\tans = min(ans, b[1]);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint p = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif (p <= m) ans = min(ans, b[p] - a[i]);\n\t\t\tif (p > 1) ans = min(ans, a[i] - b[p - 1]);\n\t\t}\n\t\tcout << ans << \'\\n\';\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 1, 0, 1, 1, 0]",1400,SolutionIf the answer is equal to since after performing an operation on the same pair twice performing an operation on the two new values which are the same results in Therefore let s consider the case for For it is sufficient to sort the array and output the minimum between and For let s brute force the first operation If the newly created value is then it is sufficient to find the smallest satisfying and greatest satisfying and relax the answer on Also remember to consider the cases of performing no operation or one operation This runs in There also exists a solution in using a two pointers approach 
Petya learned a new programming language CALPAS A program in this language always takes one non negative integer and returns one non negative integer as well In the language there are only three commands apply a bitwise operation AND OR or XOR with a given constant to the current integer A program can contain an arbitrary sequence of these operations with arbitrary constants from to When the program is run all operations are applied in the given order to the argument and in the end the result integer is returned Petya wrote a program in this language but it turned out to be too long Write a program in CALPAS that does the same thing as the Petya s program and consists of no more than lines Your program should return the same integer as Petya s program for all arguments from to ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n\nint v[10];\nint main() {\n\tint N, i, j;\n\tscanf(""%d"", &N);\n\n\tfor (i = 0; i < 10; i++) v[i] = 2;\n\twhile (N--) {\n\t\tchar c[2];\n\t\tint t;\n\t\tscanf(""%s %d"", c, &t);\n\n\t\tif (c[0] == \'|\') {\n\t\t\tfor (i = 0; i < 10; i++) if (t & (1 << i)) v[i] = 1;\n\t\t}\n\t\tif (c[0] == \'&\') {\n\t\t\tfor (i = 0; i < 10; i++) if (!(t & (1 << i))) v[i] = 0;\n\t\t}\n\t\tif (c[0] == \'^\') for (i = 0; i < 10; i++) if(t & (1<<i)) v[i] ^= 1;\n\t}\n\n\tint v1 = 0, v2 = 0, v3 = 0;\n\tfor (i = 0; i < 10; i++) {\n\t\tif (v[i] == 0) v1 |= (1 << i);\n\t\tif (v[i] == 1) v2 |= (1 << i);\n\t\tif (v[i] == 3) v3 |= (1 << i);\n\t}\n\tprintf(""3\\n"");\n\tprintf(""| %d\\n"", v2);\n\tprintf(""& %d\\n"", 1023 ^ v1);\n\tprintf(""^ %d\\n"", v3);\n\treturn 0;\n}\n\t']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1600,Let s see what happens with a single bit All operations work with each bit separately so each bit of output depends only on the corresponding bit of input There are only four options bit doesn t change bit always changes bit is set to 0 bit is set to 1 For each bit it s easy to find which of these options happens to it Now let s write a program of three lines Use XOR with a number that has ones in bits that must be reversed Use OR with a number that has ones in bits which must be set to 1 Use AND with a number that has zeroes in bits that must be set to 0 It s easy to see that this program is equivalent to Petya s program Depending on the implementation it may works in or BONUS solve a problem using at most two commands 
Chloe the same as Vladik is a competitive programmer She didn t have any problems to get to the olympiad like Vladik but she was confused by the task proposed on the olympiad Let s consider the following algorithm of generating a sequence of integers Initially we have a sequence consisting of a single element equal to Then we perform steps On each step we take the sequence we ve got on the previous step append it to the end of itself and insert in the middle the minimum positive integer we haven t used before For example we get the sequence after the first step the sequence after the second step The task is to find the value of the element with index the elements are numbered from in the obtained sequence i e after steps Please help Chloe to solve the problem ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,k;\n\nlong long get(long long n, long long k) {\n    long long length=(1ll<<n)-1;\n    if(length/2+1==k) return n;\n    else if(k<=length/2) return get(n-1,k);\n    else return get(n-1,k-length/2-1);\n}\n\nint main() {\n    scanf(""%lld %lld"", &n, &k);\n    printf(""%lld\\n"", get(n,k));\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 1, 0, 0]",1200,Consider the string after steps of algorithm We can split it into three parts string from previous step new character another one string from previous step Lets find the part where our th character is and reduce our string to the string from the previous step The complexity is 
You are given a tree with n vertices numbered 1 ldots n A tree is a connected simple graph without cycles Let mathrm dist u v be the number of edges in the unique simple path connecting vertices u and v Let mathrm diam l r max mathrm dist u v over all pairs u v such that l leq u v leq r Compute sum 1 leq l leq r leq n mathrm diam l r ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//Ofast,unroll-loops でちょい速くなる\n\n//VERIFY:\n//spaceships\n//do_use_segment_tree\n//CF679D\n//CF564E\n//TTPC2019M\n\n//splay tree の左側が根の方のノードに対応している\n//頂点と辺がそれぞれノードを持つ\n//light edge だけ特別扱いしている\n//それ以外のやつは，普通の頂点倍加 LCT のような感じ (c[0],c[1])\n//頂点由来のノードであれば，c[2] に light edges の情報が入る\n//light edge の部分のやつは，light edge 内の splay tree をつくる (c[0],c[2])\n//ただし c[1] にはぶら下がるパス部分の情報が入る\ntemplate<class N>\nstruct toptree{\n\tstruct node{\n\t\t//t==0 vertex\n\t\t//t==1 path edge\n\t\t//t==2 light edge\n\t\tN d;\n\t\tbool rev;\n\t\tint c[3],p;\n\t\tnode(char tt=-1):rev(false),c{-1,-1,-1},p(-1){d.t=tt;}\n\t\tvoid show(){\n\t\t\tcerr<<int(d.t)<<"" ""<<""(""<<c[0]<<"",""<<c[1]<<"",""<<c[2]<<"") ""<<p<<endl;\n\t\t}\n\t};\n\tusing np=node*;\n\tint n;\n\tvc<node> x;\n\t//unused に入ってるノードの情報は clean とは限らない\n\tvi unused;\n\ttoptree(int nn):n(nn),x(n*2-1){\n\t\tgnr(i,n,n*2-1)unused.pb(i);\n\t}\n\t//reverse が呼ばれるのは path node のみ\n\t//light edge なら rev は常に false\n\tinline void reverse(int v){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t<2);\n\t\tx[v].rev^=1;\n\t\tx[v].d.reverse();\n\t\tswap(x[v].c[0],x[v].c[1]);\n\t}\n\t//v は valid\n\t//link は張り替えるが update はしない\n\tinline void set_child(int v,int k,int c){\n\t\tassert(v!=-1);\n\t\tassert(inc(0,k,2));\n\t\tx[v].c[k]=c;\n\t\tif(c!=-1)x[c].p=v;\n\t}\n\tinline void set_light_left(int v,int c){set_child(v,0,c);}\n\tinline void set_light_right(int v,int c){set_child(v,2,c);}\n\tinline void set_path_left(int v,int c){set_child(v,0,c);}\n\tinline void set_path_right(int v,int c){set_child(v,1,c);}\n\t//v,c は valid\n\t//link は張り替えるが update はしない\n\tinline void insert_light(int v,int c){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t==0);\n\t\tassert(c!=-1);\n\t\tassert(x[c].d.t==2);\n\t\tset_light_right(c,x[v].c[2]);\n\t\tx[v].c[2]=c;\n\t\tx[c].p=v;\n\t}\n\tinline void make_path_vertex(int v){assert(inc(0,v,n-1));x[v].d.t=0;}\n\tinline void make_path_edge(int v){assert(inc(n,v,n*2-2));x[v].d.t=1;}\n\tinline void make_light(int v){assert(inc(n,v,n*2-2));assert(!x[v].rev);x[v].d.t=2;}\n\tvoid update(int v){\n\t\tassert(v!=-1);\n\t\tassert(!x[v].rev);\n\t\tx[v].d.single();\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].c[2]!=-1)x[v].d.update_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.update_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.update_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.update_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid downdate(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].rev){\n\t\t\t\tx[v].rev=false;\n\t\t\t\trep(k,2)if(x[v].c[k]!=-1)reverse(x[v].c[k]);\n\t\t\t}\n\t\t\tif(x[v].c[2]!=-1)x[v].d.push_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.push_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(!x[v].rev);\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.push_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.push_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t\tx[v].d.clear_lazy();\n\t}\n\t//0,z の辺を使って rotate\n\tvoid rotate(int v,int z){\n\t\tassert(v!=-1);\n\t\tint p=x[v].p,c;\n\t\tassert(p!=-1);\n\t\tif(x[p].c[0]==v){\n\t\t\tc=x[v].c[z];\n\t\t\tx[v].c[z]=p;\n\t\t\tx[p].c[0]=c;\n\t\t}else{\n\t\t\tc=x[v].c[0];\n\t\t\tx[v].c[0]=p;\n\t\t\tx[p].c[z]=c;\n\t\t}\n\t\tif(c!=-1)x[c].p=p;\n\t\tx[v].p=x[p].p;\n\t\tx[p].p=v;\n\t\tif(x[v].p!=-1){\n\t\t\trep(k,3)if(x[x[v].p].c[k]==p)\n\t\t\t\tx[x[v].p].c[k]=v;\n\t\t}\n\t\tupdate(p);\n\t\t//cerr<<""After Rotate ""<<v<<endl;\n\t\t//show();\n\t}\n\t//void rotate_path(int v){rotate(v,1);}\n\t//void rotate_light(int v){rotate(v,2);}\n\t//親を辿れるだけたどり，downdate する\n\t//このあと何らかの操作で頂点 v を上に持ってこないと，計算量が崩壊する\n\tvoid prepare(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].p!=-1)prepare(x[v].p);\n\t\tdowndate(v);\n\t}\n\t//prepare されていることが前提\n\t//path/light 内で回せるだけ回す\n\t//違う種類の親との間のリンクに注意しようね\n\tvoid splay(int v){\n\t\tassert(v!=-1);\n\t\tint z=x[v].d.t<2?1:2;\n\t\twhile(1){\n\t\t\tint p=x[v].p;\n\t\t\tif(p==-1||(x[p].d.t<2)^(x[v].d.t<2))break;\n\t\t\tint q=x[p].p;\n\t\t\tif(q==-1||(x[q].d.t<2)^(x[v].d.t<2)){\n\t\t\t\trotate(v,z);\n\t\t\t}else{\n\t\t\t\tif((x[p].c[0]==v&&x[q].c[0]==p)||(x[p].c[z]==v&&x[q].c[z]==p))\n\t\t\t\t\trotate(p,z);\n\t\t\t\telse\n\t\t\t\t\trotate(v,z);\n\t\t\t\trotate(v,z);\n\t\t\t}\n\t\t}\n\t\tupdate(v);\n\t}\n\tint go_deep(int v,int k){\n\t\tassert(v!=-1);\n\t\twhile(1){\n\t\t\tdowndate(v);\n\t\t\tif(x[v].c[k]!=-1)v=x[v].c[k];\n\t\t\telse return v;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid expose(int v){\n\t\tassert(v!=-1);\n\t\tprepare(v);\n\t\tfor(int a=v;a!=-1;a=x[a].p)\n\t\t\tsplay(a);\n\t\tfor(int a=v;a!=-1;a=x[a].p){\n\t\t\tif(x[a].d.t==2){\n\t\t\t\tint b=x[a].p;\n\t\t\t\tassert(b!=-1);\n\t\t\t\tif(x[b].c[1]==-1){\n\t\t\t\t\tint l=x[a].c[0],r=x[a].c[2];\n\t\t\t\t\tif(l!=-1){\n\t\t\t\t\t\tx[l].p=-1;\n\t\t\t\t\t\tl=go_deep(l,2);\n\t\t\t\t\t\tsplay(l);\n\t\t\t\t\t\tset_light_right(l,r);\n\t\t\t\t\t\tupdate(l);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl=r;\n\t\t\t\t\t}\n\t\t\t\t\tset_light_right(b,l);\n\t\t\t\t}else{\n\t\t\t\t\tint c=x[b].c[1];\n\t\t\t\t\tx[c].p=-1;\n\t\t\t\t\tc=go_deep(c,0);\n\t\t\t\t\tsplay(c);\n\t\t\t\t\tassert(!x[c].rev);\n\t\t\t\t\tmake_light(c);\n\t\t\t\t\tset_light_left(c,x[a].c[0]);\n\t\t\t\t\tset_light_right(c,x[a].c[2]);\n\t\t\t\t\tset_light_right(b,c);\n\t\t\t\t\t//b,c は子ノードの情報を反映していない\n\t\t\t\t\tupdate(c);\n\t\t\t\t\t//c は子ノードの情報を反映した\n\t\t\t\t}\n\t\t\t\tx[a].c[0]=x[a].c[2]=-1;\n\t\t\t\tmake_path_edge(a);\n\t\t\t\tset_path_right(b,a);\n\t\t\t}\n\t\t}\n\t\t//cerr<<""Before Splay ""<<v<<endl;\n\t\t//show();\n\t\tsplay(v);\n\t\t//cerr<<""After Expose ""<<v<<endl;\n\t\t//show();\n\t}\n\ttemplate<class...Args>\n\tvoid init_vertex(int v,Args&&...args){\n\t\tassert(inc(0,v,n-1));\n\t\tx[v]=node(0);\n\t\tx[v].d.init_vertex(v,forward<Args>(args)...);\n\t}\n\ttemplate<class...Args>\n\tvoid init_edge(int v,char t,int a,int b,Args&&...args){\n\t\tx[v]=node(t);\n\t\tx[v].d.init_edge(a,b,forward<Args>(args)...);\n\t}\n\tvoid evert(int v){\n\t\tassert(inc(0,v,n-1));\n\t\texpose(v);\n\t\tif(x[v].c[0]!=-1){\n\t\t\tint c=x[v].c[0];\n\t\t\tx[v].c[0]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,1);\n\t\t\tsplay(c);\n\t\t\treverse(c);\n\t\t\tassert(x[c].rev);\n\t\t\tx[c].rev=false;\n\t\t\treverse(x[c].c[1]);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(v,c);\n\t\t\t//v,c は子ノードの情報を反映していない\n\t\t\tupdate(c);\n\t\t\tupdate(v);\n\t\t\t//v,c は子ノードの情報を反映した\n\t\t}\n\t}\n\t//a と b を辺で結び (a が親側)，辺の index を返す\n\t//もしもともと連結であれば，-1 を返す\n\ttemplate<class...Args>\n\tint link(int a,int b,Args&&...args){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\tevert(b);\n\t\tif(x[a].p==-1){\n\t\t\tassert(si(unused));\n\t\t\tint e=unused.back();unused.pop_back();\n\t\t\tinit_edge(e,2,a,b,forward<Args>(args)...);\n\t\t\tset_path_right(e,b);\n\t\t\tinsert_light(a,e);\n\t\t\t//a,e は子ノードの情報を反映していない\n\t\t\tupdate(e);\n\t\t\tupdate(a);\n\t\t\t//a,e は子ノードの情報を反映した\n\t\t\treturn e;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t//cut したあとの木のノードのペア(親，子)を返す\n\tpi cut(int e){\n\t\tassert(inc(n,e,n*2-2));\n\t\texpose(e);\n\t\tpi res(x[e].c[0],x[e].c[1]);\n\t\tif(res.a!=-1)x[res.a].p=-1;\n\t\tif(res.b!=-1)x[res.b].p=-1;\n\t\tx[e].d.t=-1;\n\t\tunused.pb(e);\n\t\treturn res;\n\t}\n\tint lca(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\texpose(b);\n\t\tif(x[a].p==-1)return -1;\n\t\tint d=a;\n\t\twhile(a!=b){\n\t\t\tint p=x[a].p;\n\t\t\tif(x[a].d.t==2&&x[p].d.t<2)d=p;\n\t\t\telse if(p==b&&x[p].c[1]==a)d=b;\n\t\t\ta=p;\n\t\t}\n\t\tassert(inc(0,d,n-1));\n\t\treturn d;\n\t}\n\tvoid expose_path(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\tevert(a);\n\t\texpose(b);\n\t\tint c=x[b].c[1];\n\t\tif(c!=-1){\n\t\t\tx[b].c[1]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,0);\n\t\t\tsplay(c);\n\t\t\tassert(!x[c].rev);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(b,c);\n\t\t\tupdate(c);\n\t\t\tupdate(b);\n\t\t}\n\t}\n\tN&operator[](int i){return x[i].d;}\n\tvoid show(){\n\t\trep(i,n*2-1)if(x[i].d.t!=-1){\n\t\t\tcerr<<i<<"" "";\n\t\t\tx[i].show();\n\t\t}\n\t}\n\t//init_vertex は終了しているとする\n\t//E.idx が必要．これに従って辺に id を振る\n\ttemplate<class H> void init_from_hld(const H&hld){\n\t\tunused.clear();\n\t\tauto subtree=[&](auto subtree_self,int root)->int{\n\t\t\tauto path=[&](auto path_self,int l,int r)->int{\n\t\t\t\tif(r<l)return -1;\n\t\t\t\tconst int m=(l+r)/2;\n\t\t\t\tint v=hld.ni[(m+1)/2],z;\n\t\t\t\tif(m%2==0){\n\t\t\t\t\tz=v;\n\t\t\t\t\tauto light=[&](auto light_self,int a,int b)->int{\n\t\t\t\t\t\tif(b<a)return -1;\n\t\t\t\t\t\tconst int c=(a+b)/2;\n\t\t\t\t\t\tint u=hld.g[v][c],w=hld.pe[u].idx+n;\n\t\t\t\t\t\tinit_edge(w,2,v,u,hld.pe[u]);\n\t\t\t\t\t\tset_path_right(w,subtree_self(subtree_self,u));\n\t\t\t\t\t\tset_light_left(w,light_self(light_self,a,c-1));\n\t\t\t\t\t\tset_light_right(w,light_self(light_self,c+1,b));\n\t\t\t\t\t\tupdate(w);\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t};\n\t\t\t\t\tset_light_right(z,light(light,1,si(hld.g[v])-1));\n\t\t\t\t}else{\n\t\t\t\t\tz=hld.pe[v].idx+n;\n\t\t\t\t\tinit_edge(z,1,hld.par[v],v,hld.pe[v]);\n\t\t\t\t}\n\t\t\t\tset_path_left(z,path_self(path_self,l,m-1));\n\t\t\t\tset_path_right(z,path_self(path_self,m+1,r));\n\t\t\t\tupdate(z);\n\t\t\t\treturn z;\n\t\t\t};\n\t\t\treturn path(path,hld.in[root]*2,(hld.in[root]+hld.hei[root]-1)*2);\n\t\t};\n\t\tsubtree(subtree,hld.rt);\n\t}\n};\n\n//内部でグラフをいじるから in,out を使うときは注意\n//hei[v] -> heavy edge で潜っていった時，自分含めて何個あるか\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\tvi index;\n\t//vs を含む virtual tree を返す\n\t//返すのは virtual tree に使われた頂点と，辺の集合\n\t//辺の端点は，virtual tree における番号\n\t//元の木における番号を virtual tree の頂点番号に写すのが，index という変数\n\t//辺は ch->par の順\n\t//virtual tree は行き掛け順で番号がついている\n\t//特に，頂点 0 が根になるようにできている\n\tpair<vi,vc<pi>> tree_compress(vi vs){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tvc<pi> es;\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\treturn mp(vs,es);\n\t}\n};\n\n//Lyft Level 5 Challenge 2018 - Final F\n//CF635F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\nstruct E{\n\tint to,idx;\n\toperator int()const{return to;}\n};\n//init_from_hld(HLD<E>(t,0)) とかにつかう\n\n//まず rep(i,n)t.init_vertex(i) を最初にやる\n\n//init_vertex(v,...): 頂点に対応するノードを初期化する\n//init_edge(a,b,...): 辺に対応するノードを初期化する，a が親側\n//single(): そのノード単体だけの情報に更新する(部分木の情報を忘れる)\n//reverse(): 反転\n//update_path(k,N): path 上で，(k==0?左:右)に path ノードを追加する\n//=compress\n//update_light: light ツリー上でノードを追加する（原理的に左右の区別がない）\n//=rake\n//これは，頂点単体のノードにその部分木の情報を伝える際にも呼ばれる\n//これで実用上は困らないはずだけど，もしそうでなければ，ごめん\n//push_path(k,N), push_light(N): push する，update と同様\n//clear_lazy(): lazy 系のデータを clear する \n\n//木が固定されている場合\n//ノードのマージされ方が限定され，実装が楽になるケースがある\n//vertex は, light -> path の順でマージしてる\n//light edge は，path -> light の順でマージしてる\n\n//t がノードの状態を表す変数で，絶対必要\n//これをうっかり書き換えるなどのミスが予想される\n//t==0 vertex\n//t==1 path edge\n//t==2 light edge\n\n//CF691F\n//activeな頂点への距離の総和を求めるやつ\n//木が static だと思いこんでいる\n//flip のあと update しないとね\nstruct N{\n\tchar t;\n\tint rw,cnt,len[2];\n\tll ans,s[2];\n\tvoid init_vertex(int){\n\t\trw=0;\n\t\tsingle();\n\t}\n\tvoid init_edge(int,int){\n\t\trw=0;\n\t\tsingle();\n\t}\n\tvoid init_edge(int a,int b,const E&){\n\t\tinit_edge(a,b);\n\t}\n\tvoid single(){\n\t\tif(t==0){\n\t\t\tcnt=rw;\n\t\t\tlen[0]=len[1]=0;\n\t\t\tans=0;\n\t\t\ts[0]=s[1]=0;\n\t\t}\n\t\telse{\n\t\t\tcnt=rw;\n\t\t\tlen[0]=len[1]=1;\n\t\t\tans=0;\n\t\t\ts[0]=s[1]=cnt;\n\t\t}\n\t}\n\tvoid reverse(){assert(false);}\n\tvoid update_path(int dir,const N&x_){\n\t\tN x[2]{x_,*this};\n\t\tif(dir)swap(x[0],x[1]);\n\t\tcnt=x[0].cnt+x[1].cnt;\n\t\trep(k,2)len[k]=x[k].len[k];\n\t\tlen[dir]+=x[0].len[1]+x[1].len[0];\n\t\tans+=x[dir].s[dir^1]+ll(x[dir^1].len[dir])*x[dir].cnt;\n\t\trep(k,2)s[k]=x[k].s[k]+x[k^1].s[k]+ll(x[k].len[0]+x[k].len[1])*x[k^1].cnt;\n\t}\n\tvoid update_light(const N& x){\n\t\tcnt+=x.cnt;\n\t\tans+=x.s[0]+ll(len[0])*x.cnt;\n\t\ts[0]+=x.s[0];\n\t\ts[1]+=x.s[0]+ll(len[0]+len[1])*x.cnt;\n\t}\n\tvoid push_path(int,N&){\n\t}\n\tvoid push_light(N&){\n\t}\n\tvoid clear_lazy(){\n\t}\n\t\n\tvoid add(int v){\n\t\trw+=v;\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<E> t(n);\n\tvvc<int> dt(n*2-1);\n\trep(i,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb({b,i});\n\t\tt[b].pb({a,i});\n\t\tdt[a].pb(n+i);\n\t\tdt[b].pb(n+i);\n\t\tdt[n+i].pb(a);\n\t\tdt[n+i].pb(b);\n\t}\n\tdoubling<int> dd(dt,0);\n\ttoptree<N> x(n);\n\trep(i,n)x.init_vertex(i);\n\tx.init_from_hld(HLD<E>(t,0));\n\tll ans=0;\n\tauto mg=[&](pi a,pi b){\n\t\tint d=dd.len(a.a,b.a);\n\t\tif(a.b>=d+b.b)return a;\n\t\tif(b.b>=d+a.b)return b;\n\t\tint w=d+a.b+b.b;\n\t\tassert(w%2==0);\n\t\tw/=2;\n\t\tint z=w-a.b;\n\t\treturn pi(dd.jump(a.a,b.a,z),w);\n\t};\n\tauto getmax=[&](pi a,pi b){\n\t\tint d=dd.len(a.a,b.a);\n\t\treturn max({a.b*2,b.b*2,a.b+d+b.b});\n\t};\n\tvi unko(n*2-1);\n\tauto upd=[&](int v,int w){\n\t\tunko[v]+=w;\n\t\t\n\t\tx.expose(v);\n\t\tx[v].add(w);\n\t\tx.update(v);\n\t};\n\tauto getsum=[&](int v){\n\t\tx.expose(v);\n\t\t\n\t\t#ifdef LOCAL\n\t\tint res=0;\n\t\t{\n\t\t\tauto rec=[&](auto self,int i,int p,int d)->void{\n\t\t\t\tif(unko[i])res+=d*unko[i];\n\t\t\t\tfor(auto to:dt[i])if(to!=p)\n\t\t\t\t\tself(self,to,i,d+1);\n\t\t\t};\n\t\t\trec(rec,v,-1,0);\n\t\t}\n\t\tassert(res==x[v].ans);\n\t\t#endif\n\t\t\n\t\treturn x[v].ans;\n\t};\n\tvc<pi> w(n);\n\tvc<ll> sum(n+1);\n\tauto rec=[&](auto self,int l,int r)->void{\n\t\tif(l+1==r)return;\n\t\tint m=(l+r)/2;\n\t\tw[m]=pi(m,0);\n\t\trng(i,m+1,r)w[i]=mg(pi(i,0),w[i-1]);\n\t\tsum[m]=0;\n\t\trng(i,m,r)sum[i+1]=sum[i]+w[i].b;\n\t\tpi cur;\n\t\tint b=m,e=m;\n\t\tgnr(i,l,m){\n\t\t\tif(i==m-1){\n\t\t\t\tcur=pi(i,0);\n\t\t\t}else{\n\t\t\t\tcur=mg(pi(i,0),cur);\n\t\t\t}\n\t\t\twhile(e<r){\n\t\t\t\tif(getmax(cur,w[e])>w[e].b*2){\n\t\t\t\t\tupd(w[e++].a,1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(b<e){\n\t\t\t\tif(cur.b*2>=getmax(cur,w[b])){\n\t\t\t\t\tupd(w[b++].a,-1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=cur.b*2*ll(b-m);\n\t\t\tans+=cur.b*ll(e-b);\n\t\t\tans+=sum[e]-sum[b];\n\t\t\tans+=getsum(cur.a);\n\t\t\tans+=(sum[r]-sum[e])*2;\n\t\t\t/*vi baka(n*2-1);\n\t\t\trng(j,m,r){\n\t\t\t\tint val=getmax(cur,w[j]);\n\t\t\t\tans+=val;\n\t\t\t\tif(j<b){\n\t\t\t\t\tassert(val==cur.b*2);\n\t\t\t\t}else if(j<e){\n\t\t\t\t\tint tmp=cur.b+w[j].b+dd.len(cur.a,w[j].a);\n\t\t\t\t\tassert(val==tmp);\n\t\t\t\t\tans-=+dd.len(cur.a,w[j].a);\n\t\t\t\t\tbaka[w[j].a]=1;\n\t\t\t\t}else{\n\t\t\t\t\tassert(val==w[j].b*2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(unko!=baka){\n\t\t\t\tdmp2(b,e);\n\t\t\t\tdmp(unko);\n\t\t\t\tdmp(baka);\n\t\t\t}\n\t\t\tassert(unko==baka);*/\n\t\t}\n\t\twhile(b<e)upd(w[b++].a,-1);\n\t\tself(self,l,m);\n\t\tself(self,m,r);\n\t};\n\trec(rec,0,n);\n\tprint(ans/2);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",3500,Please bear with my formal style for this one as my hand waving skills are too weak to explain this properly We ll use the divide and conquer strategy Let us implement a recursive procedure that will compute the sum It will do so as follows If then answer is trivially Otherwise choose and compute the following sum The only entries that are not accounted for satisfy either or Compute their total as and return the total answer Of course is the tricky part We ll need some preparation to compute it To make arguments cleaner let us introduce an vertex in the middle of every edge subdividing it into two We ll refer to new vertices as vertices and the old vertices as vertices Since all distances are doubled we will have to divide the answer by two in the end We will define a in the tree as the set of all vertices at distance at most from the vertex We also assume that if there are at least vertices in exactly at distance from otherwise decrease accordingly For a set of vertices we define as a circle of smallest radius containing all vertices of If we assume that all vertices of are then is unique Indeed after subdividing all distances among are even thus in we must have and is the unique diameter midpoint We can see that if then has at least two vertices at distance from the covering circle center namely the diameter endpoints If a circle contains two proper vertices then it also contains the midpoint on the path between and further Say for the vertex we have This inequality is strict only when and are in the same subtree with respect to If we assume that respective inequalities for are both strict then both are in the same subtree of in which case can not be the midpoint Otherwise say for we have and by simple rearrangement An immediate of this lemma is this if a circle contains a set of proper vertices it also contains We apply the lemma to the midpoint of which is also the center of to establish Then for any vertex of we thus Let be two non empty sets of proper vertices Then the smallest covering circle can be found by only knowing and by the following rule If then If then Let none of and contain the other one Then has radius equal to which is asserted to be an integer and its center is located on the unique path at distance which is asserted to be an integer from The first two cases are somewhat easy Say in the first case has to contain then it must contain and then it contains by default Now assume the latter case Any two vertices satisfy thus Now let and be diameter endpoints of and respectively Here we can even choose say outside of since similarly choose We then must have thus has radius at least half of that and is the only possible center candidate When one or both of and has zero radius the claim can established pretty much directly The last lemma allows us to maintain for any set and further merge and to obtain since all we need is distances between vertices and finding a vertex on a at certain distance from We can also efficiently check if contains by verifying All of that can be done with binary lifting and LCA manipulations in per operation At last let s get back to the divide and conquer step Let us find circles and for all relevant We have and is a merge of and for any smaller similar for Now let s consider the sum for some is equal to twice the radius of the merge of and Consider increasing from to Since for any we have three interesting ranges for in order from left to right and are not contained in each other In the first range and in the third range If we know the boundaries and then these can be accounted for with prefix sums on and simple multiplcation for In the second range we have to sum up Again summands and are accounted in the same way Only remains Instead of computing this directly right now consider how and change as decreases from to We have thus we can conclude that and both and the range is a sliding window with both endpoints moving to the right Boundaries and can thus be maintained with the two pointers approach and vertices in the range can be maintained with a queue where vertices enter from the right and leave from the left On top of the queue that supports push back and pop front we d also like to query sum of distances from an arbitrary vertex to all vertices in the queue To this end and only this we will have to use in its most basic form It s fair to say that the margins of this explanation are already too crowded for a proper explanation of this In short we can add remove vertices and query the distance sum in time This concludes the divide and conquer step description With the usual divide and conquer time analysis we arrive at an solution 
Find the number of ways to divide an array a of n integers into any number of disjoint non empty segments so that in each segment there exist at most k distinct integers that appear exactly once Since the answer can be large find it modulo 998 244 353 ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int Mod = 998\'244\'353;\nconst int BlockLen = 170;\nconst int MaxN = 1e5 + 100;\nconst int NumBlocks = MaxN / BlockLen + 50;\n\nint values[MaxN];\nint dp[MaxN];\nint N, K;\n\nstruct Block {\n  int L, R;\n  vector<PII> pref_sums;\n  int ptr;\n  int increase;\n  VI num_incrs;\n\n  Block() : L(0), R(0), ptr(0), increase(0) {}\n  Block(int l, int r) : L(l), R(r), ptr(0), increase(0), num_incrs(r - l) {}\n\n  void IncrAll(int delta) { increase += delta; }\n\n  void Rebuild() {\n    VI order(SZ(num_incrs));\n    iota(ALL(order), 0);\n    sort(ALL(order), [&](int lhs, int rhs) {\n          return num_incrs[lhs] < num_incrs[rhs];\n        });\n\n    pref_sums.clear();\n    pref_sums.emplace_back((int)-1e9, 0);\n    pref_sums.emplace_back(num_incrs[order[0]], dp[order[0] + L]);\n\n    for (int i = 1; i < SZ(order); ++i) {\n      const int v = order[i];\n      LL val = (pref_sums.back().nd + dp[v + L]) % Mod;\n      if (num_incrs[v] == pref_sums.back().st) {\n        pref_sums.back().nd = val;\n      } else {\n        pref_sums.emplace_back(num_incrs[v], val);\n      }\n    }\n    ptr = 0;\n    debug(""Rebuild"", pref_sums);\n  }\n\n  void IncrSeg(int lft, int rgt, int delta) {\n    for (int i = 0; i < SZ(num_incrs); ++i) {\n      num_incrs[i] += increase;\n    }\n    increase = 0;\n    for (int i = lft - L; i < rgt - L; ++i) {\n      num_incrs[i] += delta;\n    }\n    debug(num_incrs);\n    Rebuild();\n  }\n\n  int GetAtMaxK() {\n    while (ptr > 0 && pref_sums[ptr].st + increase > K) { --ptr; }\n    while (ptr < SZ(pref_sums) - 1 && pref_sums[ptr + 1].st + increase <= K) { ++ptr; }\n    debug(""GetIn"", L, R, ptr, pref_sums, increase, K);\n    return pref_sums[ptr].nd;\n  }\n};\n\nBlock blocks[NumBlocks];\n\n\nvoid Increase(int L, int R, int delta) {\n  debug(""Increase"", L, R, delta);\n  for (int i = 0; i < NumBlocks; ++i) {\n    const int l_block = i * BlockLen;\n    const int r_block = min((i + 1) * BlockLen, N + 1);\n    if (l_block > N) { break; }\n    if (r_block <= L || l_block >= R) { continue; }\n    if (L <= l_block && r_block <= R) {\n      blocks[i].IncrAll(delta);\n    } else {\n      blocks[i].IncrSeg(max<int>(L, l_block), min<int>(R, r_block), delta);\n    }\n  }\n}\n\nint GetAtMaxK() {\n  int ans = 0;\n  for (int i = 0; i < NumBlocks; ++i) {\n    const int l_block = i * BlockLen;\n    if (l_block > N) { break; }\n    ans = (ans + blocks[i].GetAtMaxK()) % Mod;\n  }\n  debug(""Get"", ans);\n  return ans;\n}\n\nvoid BuildBlocks() {\n  for (int i = 0; i < NumBlocks; ++i) {\n    const int l_block = i * BlockLen;\n    const int r_block = min(N + 1, (i + 1) * BlockLen);\n    if (l_block > N) { break; }\n    debug(i, l_block, r_block);\n    blocks[i] = Block(l_block, r_block);\n    blocks[i].Rebuild();\n  }\n}\n\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> K;\n\n#ifdef TEST\n  for (int i = 0; i < N; ++i) { values[i] = i / 2 + 1; }\n  srand(69);\n  random_shuffle(values, values + N);\n#else\n  for (int i = 0; i < N; ++i) { cin >> values[i]; }\n#endif\n\n  dp[0] = 1;\n  BuildBlocks();\n\n  VI prev_occur(N + 1, 0), last_occur(N + 1, 0);\n\n  for (int i = 1; i <= N; ++i) {\n    const int v = values[i - 1];\n    if (last_occur[v]) {\n      Increase(prev_occur[v], last_occur[v], -1);\n    }\n    prev_occur[v] = last_occur[v];\n    last_occur[v] = i;\n    Increase(prev_occur[v], last_occur[v], 1);\n    dp[i] = GetAtMaxK();\n    blocks[i / BlockLen].Rebuild();\n  }\n\n  cout << dp[N] << ""\\n"";\n}\n\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2900,Let be the number of integers that appear exactly once in the segment We can use the following recurrence to compute the answer where A naive implementation will definitely be too slow To compute the said recurrence efficiently we will do as follows First let s design an array so that is the sum of elements in segment Ideally it should be easy i e require only a few operations to transform this array into another array that would work with instead One design is as follows First let each entry of be This array now works imaginarily when To make it work for consider the element If this value appeared before at least twice set where is the second last appearance of not counting the appearance at index If this value appeared before at least once set where is the last appearance of Finally set Now you can see that the sum in the segment correctly represents for any Let us divide the array into blocks so that each block contains elements assume for simplicity that divides Each block corresponding to some segment should store sum of elements in i e and for each sum of where is less than or equal to A modification to for some index will require an update With array ready for our we are ready to compute Let be a temporary variable initially equal to For each that belongs to the same block as add to if and also add to This runs in To account for the left possible endpoints from other blocks for each block starting from one directly to the left of the block that contains to the leftmost block Suppose this block corresponds to the segment Let If do nothing If add to If add to Add to The step above runs in That is our algorithm takes time to compute for some The time complexity is since there are values of that we need to compute for If we choose our solution would run in 
Imagine that your city is an infinite 2D plane with Cartesian coordinate system The only crime affected road of your city is the axis Currently there are criminals along the road No police station has been built on this road yet so the mayor wants to build one As you are going to be in charge of this new police station the mayor has asked you to choose a suitable position some integer point for building it You should choose the best position for the police station so that you could minimize the total time of your criminal catching mission Your mission of catching the criminals will operate only from this station The new station will have only patrol car You will go to the criminals by this car carry them on the car bring them back to the police station and put them in prison The patrol car can carry at most criminals at a time Note that the criminals don t know about your mission So they will stay where they are instead of running away Your task is to find the position for the police station so that total distance you need to cover to catch all the criminals will be minimum possible Note that you also can built the police station on the positions where one or more criminals already exist In such a case all these criminals are arrested instantly ,"['#include <stdio.h>\n#include <string.h>\n\ntypedef long long LL;\nconst int N = 1048576;\nint xi[N];\nLL cl[N];\nint nl[N];\nLL cr[N];\nint nr[N];\n\nint main()\n{\n  //freopen(""input.txt"", ""rt"", stdin);\n  //freopen(""output.txt"", ""wt"", stdout);\n\n  int n, m;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 0; i < n; i++)\n    scanf(""%d"", &xi[i]);\n\n  LL sum1 = 0, sum2 = 0;\n  int cnt = 0;\n  for (int i = 0; i < n; i++)\n  {\n    cl[i] = sum1;\n    nl[i] = cnt;\n    cr[n - i - 1] = sum2;\n    nr[n - i - 1] = cnt;\n    if ((i % m) == 0)\n      sum1 += xi[i], sum2 += xi[n - i - 1], cnt++;\n  }\n\n  LL best = -1;\n  for (int i = 0; i < n; i++)\n  {\n    LL cur = LL(nl[i]) * LL(xi[i]) - cl[i] +\n             cr[i] - LL(nr[i]) * LL(xi[i]);\n    if (best < 0 || cur < best)\n      best = cur;\n  }\n\n  printf(""%I64d"", best * 2);\n\n  return 0;\n}\n']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",2000,Trying to place the police station on existing criminal locations is the best strategy Calculate the cost from the leftmost criminal location then sweep over the next locations By doing some adjustments on the cost of the previous location will yield the cost of the current location Model solution 6546283 
You are playing a variation of game Initially you have a multiset s of n integers Every integer in this multiset is a power of two You may perform any number possibly zero operations with this multiset During each operation you choose two integers from s remove them from s and insert the number equal to their sum into s For example if s 1 2 1 1 4 2 2 and you choose integers 2 and 2 then the multiset becomes 1 1 1 4 4 2 You win if the number 2048 belongs to your multiset For example if s 1024 512 512 4 you can win as follows choose 512 and 512 your multiset turns into 1024 1024 4 Then choose 1024 and 1024 your multiset turns into 2048 4 and you win You have to determine if you can win this game You have to answer q independent queries ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nvoid solve() {\n    cin >> n;\n    vector < int > all;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        if (x > 2048) continue;\n        int y = 0;\n        while ((1 << y) < x) y++;\n        all.push_back(y);\n    }\n    sort(all.begin(), all.end());\n    reverse(all.begin(), all.end());\n    for (int i = 0; i < 11; i++) {\n        vector < int > nall;\n        int cnt = 0;\n        for (int j = 0; j < all.size(); j++) {\n            if (all[j] == i) cnt++;\n            else nall.push_back(all[j]);\n        }\n        for (int p = 0; p < cnt / 2; p++) nall.push_back(i + 1);\n        all = nall;\n    }\n    if (!all.empty()) cout << ""YES"" << \'\\n\';\n    else cout << ""NO"" << \'\\n\';\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    int q;\n    cin >> q;\n    while (q--) {\n        solve();\n    }\n    return 0;\n}']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0]",1000,It s obvious that we don t need elements that are larger than If the sum of the remaining elements is greater than or equal to 2048 then the answer is and otherwise It s true because for getting a integer that wasn t in the multiset initially we first need to get integer 
A little bear Limak plays a game He has five cards There is one number written on each card Each number is a positive integer Limak can discard throw out some cards His goal is to minimize the sum of numbers written on remaining not discarded cards He is allowed to discard two or three cards with the same number Of course he won t discard cards if it s impossible to choose two or three cards with the same number Given five numbers written on cards cay you find the minimum sum of numbers on remaining cards ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint sum[110] , x;\nint main(){\n    int all = 0;\n    rep(i,0,5) cin >> x , sum[x]++ , all += x;\n    int Max = 0;\n    rep(x,1,101) if(sum[x] >= 2) Max = max(Max , min(3 ,sum[x]) * x);\n    cout << all - Max << endl;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",800,Iterate over all pairs and triples of numbers and for each of them check if all two three numbers are equal If yes then consider the sum of remaining numbers as the answer the final answer will be the minimum of considered sums Below you can see two ways to implement the solution code1 
To destroy humanity The Monster Association sent n monsters to Earth s surface The i th monster has health h i and power p i With his last resort attack True Spiral Incineration Cannon Genos can deal k damage to all monsters alive In other words Genos can reduce the health of all monsters by k if k 0 with a single attack However after every attack Genos makes the monsters advance With their combined efforts they reduce Genos attack damage by the power of the daggerweakest monster ddaggeralive In other words the minimum p i among all currently living monsters is subtracted from the value of k after each attack daggerThe Weakest monster is the one with the least power ddaggerA monster is alive if its health is strictly greater than 0 Will Genos be successful in killing all the monsters ,"['#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\npair<int, int>a[100000];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> a[i].first;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> a[i].second;\n\t\tmultiset<int>s;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\ts.emplace(a[i].second);\n\t\tsort(a, a + n);\n\t\tint pre = k;\n\t\tfor (int i = 0; i < n && k > 0;) {\n\t\t\tint j = i;\n\t\t\tfor (; j < n && a[j].first <= pre; ++j)\n\t\t\t\ts.erase(s.find(a[j].second));\n\t\t\tif (s.size())\n\t\t\t\tk -= *s.begin();\n\t\t\tpre += k;\n\t\t\ti = j;\n\t\t}\n\t\tcout << (k <= 0 ? ""NO\\n"" : ""YES\\n"");\n\t}\n}']","[0, 1, 1, 0, 1, 1, 0, 1, 1, 0]",1200,Solution 1Sort the monsters in ascending order of their powers Now we iterate through the monsters while maintaining the current attack power and the total damage dealt Only the monsters with health greater than the total damage dealt are considered alive and every time we encounter such a monster it will be the weakest one at the current time thus we need to attack until the total damage dealt exceeds the current monster s health while lowering our attack power by its power each time If we can kill all the monsters in this way the answer is YES otherwise it is NO Time Complexity 
There are pearls in a row Let s enumerate them with integers from to from the left to the right The pearl number has the type Let s call a sequence of consecutive pearls a Let s call a segment if it contains two pearls of the same type Split the row of the pearls to the maximal number of good segments Note that each pearl should appear in exactly one segment of the partition As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint a[N], x[N], y[N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", a + i);\n  }\n  set <int> used;\n  int cnt = 0;\n  int from = 0;\n  for (int i = 0; i < n; i++) {\n    if (used.find(a[i]) != used.end()) {\n      x[cnt] = from;\n      y[cnt] = i;\n      cnt++;\n      used.clear();\n      from = i + 1;\n    } else {\n      used.insert(a[i]);\n    }\n  }\n  if (cnt == 0) {\n    printf(""%d\\n"", -1);\n    return 0;\n  }\n  y[cnt - 1] = n - 1;\n  printf(""%d\\n"", cnt);\n  for (int i = 0; i < cnt; i++) {\n    printf(""%d %d\\n"", 1 + x[i], 1 + y[i]);\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500,Let s solve the problem greedily Let s make the first segment by adding elements until the segment will be good After that let s make the second segment in the same way and so on If we couldn t make any good segment then the answer is Otherwise let s add all uncovered elements at the end to the last segment Easy to prove that our construction is optimal consider the first two segments of the optimal answer obviously we can extend the second segment until the first segment will be equal to the first segment in our construction C solution Complexity 
You have an image file of size 2 times 2 consisting of 4 pixels Each pixel can have one of 26 different colors denoted by lowercase Latin letters You want to recolor some of the pixels of the image In one move you can choose pixels and paint them into some other color What is the minimum number of moves you have to make in order to fulfill your goal ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::set<char> s;\n    for (int i = 0; i < 4; i++) {\n        char c;\n        std::cin >> c;\n        s.insert(c);\n    }\n    std::cout << s.size() - 1 << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present 
Senor Vorpal Kickass o invented an innovative method to encrypt integer sequences of length To encrypt a sequence one has to choose a secret sequence that acts as a key Vorpal is very selective so the key should be such a sequence that its cyclic shifts are linearly independent that is there is no non zero set of coefficients such that for all at the same time After that for a sequence you should build the following cipher In other words you are to compute the quadratic deviation between each cyclic shift of and the sequence The resulting sequence is the Kickass s cipher The cipher is in development right now and Vorpal wants to decipher a sequence after it has been encrypted You are to solve this problem for him You are given sequences and You are to find all suitable sequences ,"['//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==\' \'||c==\'\\n\')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(\' \')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar(\'\\n\')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!=\'-\'&&(c<\'0\'||c>\'9\'))c=_buff.get();\n\tif(c==\'-\')ng=1,c=_buff.get();\n\twhile(c>=\'0\'&&c<=\'9\')r=r*10+c-\'0\',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar(\'-\'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar(\'0\');\n\tfor(int i=sz-1;i>=0;i--)putchar(\'0\'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nint mod;\n\nconst int FFTpsz=1<<19;\nconst int FFTmx=FFTpsz+233;\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint FFTsz;\nconst double pi=acos(-1);\nstruct point\n{\n\tdouble x,y;\n\tpoint(double X=0,double Y=0){x=X;y=Y;}\n\tpoint operator+(const point &t)const{return point(x+t.x,y+t.y);}\n\tpoint operator-(const point &t)const{return point(x-t.x,y-t.y);}\n\tpoint operator*(const point &t)const{return point(x*t.x-y*t.y,x*t.y+y*t.x);}\n\tpoint operator*(const double &t)const{return point(x*t,y*t);}\n\tpoint conj()const{return point(x,-y);}\n};\npoint w_pre[FFTmx];\nint uptopow(int n)\n{\n\tint ret=1;\n\twhile(ret<n)ret<<=1;\n\treturn ret;\n}\nvoid FFTprecalc()\n{\n\tfor(int i=0;i<=FFTpsz;i++)w_pre[i]=point(cos(2*pi/FFTpsz*i),sin(2*pi/FFTpsz*i));\n}\nvoid FFTinit(int n)\n{\n\tFFTsz=uptopow(n);\n}\nvoid FFT(point a[],int coef)\n{\n\tfor(int i=0,j=0;i<FFTsz;i++)\n\t{\n\t\tif(i<j)swap(a[i],a[j]);\n\t\tfor(int t=FFTsz>>1;(j^=t)<t;t>>=1);\n\t}\n\tstatic point w[FFTmx];\n\tfor(int l=1;l<FFTsz;l<<=1)\n\t{\n\t\tint l2=l<<1;\n\t\tif(coef==1)for(int j=0;j<l;j++)w[j]=w_pre[FFTpsz/l2*j];\n\t\telse for(int j=0;j<l;j++)w[j]=w_pre[FFTpsz-FFTpsz/l2*j];\n\t\tfor(int i=0;i<FFTsz;i+=l2)\n\t\t{\n\t\t\tfor(int j=0;j<l;j++)\n\t\t\t{\n\t\t\t\tpoint tmp=a[i+j+l]*w[j];\n\t\t\t\ta[i+j+l]=a[i+j]-tmp;\n\t\t\t\ta[i+j]=a[i+j]+tmp;\n\t\t\t}\n\t\t}\n\t}\n\tif(coef==-1)\n\t{\n\t\tfor(int i=0;i<FFTsz;i++)a[i]=a[i]*(1.0/FFTsz);\n\t}\n}\nvoid FFT2(point a[],point b[],int coef)\n{\n\tstatic point A[FFTmx];\n\tif(coef==1)\n\t{\n\t\tfor(int i=0;i<FFTsz;i++)A[i]=point(a[i].x,b[i].x);\n\t\tFFT(A,1);\n\t\tA[FFTsz]=A[0];\n\t\tfor(int i=0;i<FFTsz;i++)\n\t\t{\n\t\t\ta[i]=(A[i]+A[FFTsz-i].conj())*point(0.5,0);\n\t\t\tb[i]=(A[i]-A[FFTsz-i].conj())*point(0,-0.5);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<FFTsz;i++)A[i]=a[i]+b[i]*point(0,1);\n\t\tFFT(A,-1);\n\t\tfor(int i=0;i<FFTsz;i++)a[i]=point(A[i].x,0),b[i]=point(A[i].y,0);\n\t}\n}\nvoid polymul(int a[],int an,int b[],int bn,int c[],int cn,int md)\n{\n\tmod=md;\n\tif(1ll*an*bn<10000)\n\t{\n\t\tstatic int mul_t[FFTmx];\n\t\tfor(int i=0;i<cn;i++)mul_t[i]=0;\n\t\tfor(int i=0;i<an;i++)\n\t\t{\n\t\t\tfor(int j=0;j<bn&&i+j<cn;j++)\n\t\t\t{\n\t\t\t\tmul_t[i+j]=(mul_t[i+j]+1ll*a[i]*b[j])%mod;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<cn;i++)c[i]=(mul_t[i]%mod+mod)%mod;\n\t\treturn;\n\t}\n\tstatic point mul_a0[FFTmx],mul_a1[FFTmx];\n\tstatic point mul_b0[FFTmx],mul_b1[FFTmx];\n\tFFTinit(an+bn);\n\tfor(int i=0;i<FFTsz;i++)mul_a0[i]=point(i<an?((a[i]%mod+mod)%mod)&32767:0,0);\n\tfor(int i=0;i<FFTsz;i++)mul_a1[i]=point(i<an?((a[i]%mod+mod)%mod)>>15:0,0);\n\tfor(int i=0;i<FFTsz;i++)mul_b0[i]=point(i<bn?((b[i]%mod+mod)%mod)&32767:0,0);\n\tfor(int i=0;i<FFTsz;i++)mul_b1[i]=point(i<bn?((b[i]%mod+mod)%mod)>>15:0,0);\t\n\tFFT2(mul_a0,mul_a1,1);\n\tFFT2(mul_b0,mul_b1,1);\n\tfor(int i=0;i<FFTsz;i++)\n\t{\n\t\tpoint t0=mul_a0[i]*mul_b0[i];\n\t\tpoint t1=mul_a0[i]*mul_b1[i]+mul_a1[i]*mul_b0[i];\n\t\tpoint t2=mul_a1[i]*mul_b1[i];\n\t\tmul_a0[i]=t0;\n\t\tmul_a1[i]=t1;\n\t\tmul_b0[i]=t2;\n\t}\n\tFFT2(mul_a0,mul_a1,-1);\n\tFFT(mul_b0,-1);\n\tfor(int i=0;i<cn;i++)\n\t{\n\t\tif(i<FFTsz)\n\t\t{\n\t\t\tll t0=ll(mul_a0[i].x+0.5)%mod;\n\t\t\tll t1=ll(mul_a1[i].x+0.5)%mod;\n\t\t\tll t2=ll(mul_b0[i].x+0.5)%mod; \n\t\t\tc[i]=((t0+(t1<<15)+(t2<<30))%mod+mod)%mod;\n\t\t}\n\t\telse c[i]=0;\n\t}\n}\nvoid CZT(int a[],int N,int w,int md,int coef)//here w should be the sqrt of original w  md should be prime\n{\n\tmod=md;\n\tif(coef==-1)w=qpow(w,mod-2);\n\tstatic int CZT_f[FFTmx],CZT_g[FFTmx],CZT_a[FFTmx];\n\tfor(int i=0;i<N;i++)CZT_f[i]=1ll*a[i]%mod*qpow(w,1ll*i*i%(mod-1))%mod;\n\tfor(int i=0;i<N+N;i++)CZT_g[i]=qpow(w,mod-1-1ll*(N-i)*(N-i)%(mod-1))%mod;\n\tpolymul(CZT_f,N,CZT_g,N+N,CZT_a,N+N,mod);\n\tfor(int i=0;i<N;i++)a[i]=1ll*qpow(w,1ll*i*i%(mod-1))*(CZT_a[i+N])%mod;\n\tif(coef==-1)\n\t{\n\t\tll inv=qpow(N,mod-2);\n\t\tfor(int i=0;i<N;i++)a[i]=a[i]*inv%mod;\n\t}\n}\nbool isp(int x)\n{\n\tfor(int i=2;1ll*i*i<=x;i++)if(x%i==0)return false;\n\treturn true;\n}\npair<int,int> calc_mod(int l)\n{\n\tint md=l+1;\n\twhile(md<2333333||!isp(md))md+=l;\n\tmod=md;\n\tfor(int pr=2;pr<md;pr++)\n\t{\n\t\tbool ok=1;\n\t\tfor(int j=2;j<=md-1;j++)\n\t\t{\n\t\t\tj=(md-1)/((md-1)/j);\n\t\t\tif((md-1)%j==0)\n\t\t\t{\n\t\t\t\tif(qpow(pr,(md-1)/j)==1)\n\t\t\t\t{\n\t\t\t\t\tok=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)return MP(pr,md);\n\t}\n\tassert(false);\n}\nint n,b0[FFTmx];\nint b[FFTmx],c[FFTmx],da[FFTmx],dc[FFTmx],sa[FFTmx];\nint main()\n{\n\tFFTprecalc();\n\tgeti(n);\n\tfor(int i=0;i<n;i++)geti(b0[i]);\n\tfor(int i=0;i<n;i++)b[i]=b0[(n-i)%n];\n\tfor(int i=0;i<n;i++)geti(c[i]);c[n]=c[0];\n\tfor(int i=0;i<n;i++)dc[i]=(c[i+1]-c[i])/(-2);\n\tpair<int,int> pp=calc_mod(2*n);\n\tint w=pp.FF,md=pp.SS;\n//\tcerr<<""w=""<<w<<"" md=""<<md<<endl;\n\tmod=md;\n\tw=qpow(w,(md-1)/2/n);\n\tCZT(dc,n,w,md,1);\n\tCZT(b,n,w,md,1);\n\tfor(int i=0;i<n;i++)da[i]=1ll*dc[i]*qpow(b[i],mod-2)%mod;\n\tCZT(da,n,w,md,-1);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(da[i]>mod/2)da[i]=da[i]-mod;\n\t}\n//\tcerr<<""da:""<<endl;\n//\tfor(int i=0;i<n;i++)cerr<<da[i]<<"" "";cerr<<endl;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tsa[i]=sa[i-1]+da[i-1];\n\t\tif(sa[i]<-5000||sa[i]>5000)\n\t\t{\n\t\t\tputs(""0"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tll C2=0,C1=0,C0=-c[0];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll tmp=b0[i]-sa[i];\n\t\tC2++;\n\t\tC1+=(-2)*tmp;\n\t\tC0+=tmp*tmp;\n\t}\n\tvector<int> v;\n\tfor(int i=-5000;i<=5000;i++)if(C2*i*i+C1*i+C0==0)v.PB(i);\n\tputsi(v.size());\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tputi(v[i]);\n\t\tfor(int j=1;j<n;j++)puti(v[i]+sa[j]);\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3300, hence Let Then This corresponds to cyclic convolution of polynomials and These polynomials uniquely determined by values in roots of unity of degree Thus we can divide values of by values of in this points and return to polynomials from values in roots of unity To do this one should compute discrete Fourier Transform in arbitrary length polynomial which can be done by Bluestein s algorithm Note that you can t use complex fft here because real values can be very close to zero leading to great precision issues Thus you should find some mod having root of unity of degree and compute discrete transform over it Thus we will find for each which will allow us to recover because It can be proven that values of polynomial in roots of unity are eigenvalues of matrix of linear system thus cyclic shifts are linearly independent iff there is such mod which has root of unity of degree and values of polynomial in all such roots doesn t equal zero If it s true for polynomial in field of real numbers there will be only finite number of mods in which this may not be true it only true if of polynomial and isn t equal in such mod 
Karen is getting ready for a new school day It is currently given in a 24 hour format As you know Karen loves and she believes that it is good luck to wake up when the time is a palindrome What is the minimum number of minutes she should sleep such that when she wakes up the time is a palindrome Remember that a palindrome is a string that reads the same forwards and backwards For instance is not a palindrome because backwards is On the other hand is a palindrome because backwards is ,"['//#pragma comment(linker,""/STACK:16777216"") /*16Mb*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <time.h>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\n\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define RFOR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))\n#define MP make_pair\n#define I insert\n#define mod 1000000007\n#define INF 2000000007\n#define PB push_back\n#define x0 sdfhrthrth\n#define x1 fdhttrlhn\n#define y0 kihrbdb\n#define y1 ugvrrtgtrg\n#define eps 1e-5\n#define X first\n#define Y second\n\nconst int MAXN = 10007;\n\nstring s;\nint h, m;\nchar ch;\n\nint main()\n{\n    cin >> h >> ch >> m;\n    int ans = 0;\n    while (h/10 != m%10 || h%10 != m/10)\n    {\n        m++;\n        if (m == 60) m = 0, h++;\n        if (h == 24) h = 0;\n        ans++;\n    }\n    cout << ans;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1000,This is a rather straightforward implementation problem The only observation here is that there are only different possible times It is enough to iterate through all of them until we encounter a palindromic time and count the number of times we had to check before we reached a palindromic time How do we iterate through them The most straightforward way is to simply convert the given string into two integers and We can do this manually or maybe use some functions specific to your favorite language It is good to be familiar with how your language deals with strings It is also possible though inadvisable to try to work with the string directly To go to the next time we simply increment If becomes then make it and increment If becomes then make it To check whether a given time is palindromic we simply need to check if the tens digit of is the same as the ones digit of and if the ones digit of is the same as the tens digit of This can be done like so check if and Another way is to simply cross check against a list of palindromic times Just be careful not to miss any of them and not to add any extraneous values There are palindromic times namely and 
Mahmoud was trying to solve the vertex cover problem on trees The problem statement is Given an undirected tree consisting of nodes find the minimum number of vertices that cover all the edges Formally we need to find a set of vertices such that for each edge that belongs to the tree either is in the set or is in the set Mahmoud has found the following algorithm Root the tree at node Count the number of nodes at an even depth Let it be Count the number of nodes at an odd depth Let it be The answer is the minimum between and The depth of a node in a tree is the number of edges in the shortest path between this node and the root The depth of the root is 0 Ehab told Mahmoud that this algorithm is wrong but he didn t believe because he had tested his algorithm against many trees and it worked so Ehab asked you to find 2 trees consisting of nodes The algorithm should find an incorrect answer for the first tree and a correct answer for the second one ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tif (n < 6)\n\t\tcout << ""-1\\n"";\n\telse{\n\t\tcout << ""1 2\\n"";\n\t\tint t = (n-2)/2;\n\t\tfor (int i = 3; i < 3+t; i++)\n\t\t\tcout << ""1 "" << i << ""\\n"";\n\t\tint temp = 3+t;\n\t\tt = (n-1)/2;\n\t\tfor (int i = temp; i < temp + t; i++)\n\t\t\tcout << ""2 "" << i << ""\\n"";\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tcout << i-1 << "" "" << i << ""\\n"";\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1500,The first tree For n 6 you can connect nodes 2 3 and 4 to node 1 and connect the rest of the nodes to node 2 The real vertex cover is the set 1 2 of size 2 while the found vertex cover will have size min 3 n 3 As n 6 that value will be 3 which is incorrect For n 6 the answer doesn t exist The second tree There are multiple ways to construct it One easy way is the star tree Connect all the nodes to node 1 The real and the found vertex cover will be simply 1 Another easy way is a path Connect node i to node i 1 for all 1 i n The real and the found vertex cover has size 
You are given a sequence a 1 ldots a n where each element a i is either 0 or 1 You can apply several possibly zero operations to the sequence In each operation you select two integers 1 le l le r le a where a is the current length of a and replace a l ldots a r with a single element x where x is the majority of a l ldots a r Here the majority of a sequence consisting of 0 and 1 is defined as follows suppose there are c 0 zeros and c 1 ones in the sequence respectively If c 0 ge c 1 the majority is 0 If c 0 c 1 the majority is 1 For example suppose a 1 0 0 0 1 1 If we select l 1 r 2 the resulting sequence will be 0 0 0 1 1 If we select l 4 r 6 the resulting sequence will be 1 0 0 1 Determine if you can make a 1 with a finite number of operations ,"['#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<""=""<<x<<""\\n"";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+"".in"").c_str(),""r"",stdin);\tfreopen((s+"".out"").c_str(),""w"",stdout);}void run(){\tint n;\tstring s;\tcin>>n>>s;\tint c=-(s[0]==\'0\')-(s[n-1]==\'0\');\trep(i,n-1)if(s[i]==s[i+1]&&s[i]==\'1\')c++;\tif(c>=0)cout<<""Yes\\n"";\telse cout<<""No\\n"";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}\xa0']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,We list some simple conditions for a string to be transformable If 111 exists somewhere as a substring in the string the string is always transformable If 11 appears at least twice in the string the string is always transformable If the string both begins and ends with 1 it is always transformable If the string begins or ends with 1 and 11 exists in the string it is always transformable These can be found by simulating the operation for short strings on paper Contrarily if a string does not meet any of the four items it is always not transformable This can be proved using induction as an exercise 
Natasha travels around Mars in the Mars rover But suddenly it broke down namely the logical scheme inside it The scheme is an undirected tree connected acyclic graph with a root in the vertex 1 in which every leaf excluding root is an input and all other vertices are logical elements including the root which is output One bit is fed to each input One bit is returned at the output There are four types of logical elements AND 2 inputs OR 2 inputs XOR 2 inputs NOT 1 input Logical elements take values from their direct descendants inputs and return the result of the function they perform Natasha knows the logical scheme of the Mars rover as well as the fact that only one input is broken In order to fix the Mars rover she needs to change the value on this input For each input determine what the output will be if Natasha changes this input ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin » t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nenum Type {\n  AND,\n  OR,\n  XOR,\n  NOT,\n  IN\n};\n\nvector<Type> types;\nvector<vector<int>> g;\nvector<int> val;\nvector<int> val_changed;\nvector<int> parent;\n\nint dfs(int v, int p) {\n  parent[v] = p;\n  if (types[v] == IN) {\n    return val[v];\n  }\n  if (types[v] == NOT) {\n    return val[v] = !dfs(g[v][0], v);\n  }\n  if (types[v] == AND) {\n    return val[v] = dfs(g[v][0], v) & dfs(g[v][1], v);\n  }\n  if (types[v] == OR) {\n    return val[v] = dfs(g[v][0], v) | dfs(g[v][1], v);\n  }\n  if (types[v] == XOR) {\n    return val[v] = dfs(g[v][0], v) ^ dfs(g[v][1], v);\n  }\n}\n\nvoid dfs_ans(int v) {\n  if (v == 0) {\n    val_changed[v] = val[v] ^ 1;\n  } else {\n    int p = parent[v];\n    int new_val = (val[v] ^ 1);\n    if (types[p] == NOT) {\n      val_changed[v] = val_changed[p];\n    } else {\n      int diff_val = ((g[p][0] == v) ? val[g[p][1]] : val[g[p][0]]);\n      int parent_val = val[p];\n      if (types[p] == AND) {\n        parent_val = diff_val & new_val;\n      }\n      if (types[p] == OR) {\n        parent_val = diff_val | new_val;\n      }\n      if (types[p] == XOR) {\n        parent_val = diff_val ^ new_val;\n      }\n      if (parent_val != val[p]) {\n        val_changed[v] = val_changed[p];\n      } else {\n        val_changed[v] = val[0];\n      }\n    }\n  }\n  for (int to : g[v]) {\n    dfs_ans(to);\n  }\n}\n\nvoid solve(bool read) {\n  int n;\n  cin >> n;\n  types.resize(n);\n  g.clear();\n  g.resize(n);\n  val.resize(n);\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    if (s == ""IN"") {\n      types[i] = IN;\n      cin >> val[i];\n    } else if (s == ""NOT"") {\n      types[i] = NOT;\n      int cur;\n      cin >> cur;\n      --cur;\n      g[i].push_back(cur);\n    } else {\n      switch(s[0]) {\n        case \'A\':\n          types[i] = AND;\n          break;\n        case \'O\':\n          types[i] = OR;\n          break;\n        case \'X\':\n          types[i] = XOR;\n          break;\n        default:\n          assert(false);\n      }\n      g[i].resize(2);\n      for (int j = 0; j < 2; ++j) {\n        cin >> g[i][j];\n        --g[i][j];\n      }\n    }\n  }\n  parent.resize(n);\n  dfs(0, 0);\n  val_changed.resize(n);\n  dfs_ans(0);\n\n  for (int i = 0; i < n; ++i) {\n    if (types[i] == IN) {\n      cout << val_changed[i];\n    }\n  }\n  cout << ""\\n"";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1]",2000,Let s count the bit at each vertex This can be done using depth first search on this tree Now for each vertex let s check whether the bit on the output of the scheme will change if the bit in the current vertex is changed If all the vertices on the path from this vertex to the output of the scheme If at least one of them does not change then the output of the scheme does not change and vice versa if the output of the scheme is changed then each vertex on the path under consideration will change Now the solution can be implemented as follows For each vertex let s make a note whether the bit on the output of the scheme will be changed if the bit on the current vertex is changed For output of the scheme this note is Now let s do the depth first search on this tree If note at the current vertex is equal to then at the inputs to it we make the note equal otherwise for each input to this vertex we do the following Let s see if the current vertex is changed if the current input is changed If it is changed then at this input we will make the note equal otherwise Complexity 
A country has cities Initially there is no road in the country One day the king decides to construct some roads connecting pairs of cities Roads can be traversed either way He wants those roads to be constructed in such a way that it is possible to go from each city to any other city by traversing at most two roads You are also given pairs of cities roads cannot be constructed between these pairs of cities Your task is to construct the minimum number of roads that still satisfy the above conditions The constraints will guarantee that this is always possible ,"['#include <stdio.h>\n#define N 1002\n\nbool vis[N][N];\n\nint main() {\n//\tfreopen (""in.txt"", ""r"", stdin);\n\tint n, m;\n\tint i, j, k;\n\tscanf (""%d %d"", &n, &m);\n\twhile (m--) {\n\t\tscanf (""%d %d"", &i, &j);\n\t\tvis[i][j] = 1;\n\t\tvis[j][i] = 1;\n\t}\n\n\tfor (i=1; i<=n; i++) {\n\t\tfor (j=1; j<=n; j++) {\n\t\t\tif (vis[i][j]) break;\n\t\t}\n\t\tif (j > n) break;\n\t}\n\n\tprintf (""%d\\n"", n-1);\n\tfor (j=1; j<=n; j++) {\n\t\tif (j == i) continue;\n\t\tprintf (""%d %d\\n"", i, j);\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",1300,Since m n 2 there exists at least one node that is not incident to any edge The constraints can be satisfied if and only if the graph is a star graph http en wikipedia org wiki Star graph theory We can just create a star graph centered with the node and connect it to all other nodes 
During the quarantine Sicromoft has more free time to create the new functions in The developers made a new function which infinitely fills an infinite table to the right and down from the upper left corner as follows The cell with coordinates x y is at the intersection of x th row and y th column Upper left cell 1 1 contains an integer 1 The developers of the function don t sleep either Because of the boredom they teamed up with the developers of the function so they added the ability to calculate the sum on an arbitrary path from one cell to another moving down or right Formally from the cell x y in one step you can move to the cell x 1 y or x y 1 After another Dinwows update Levian started to study because he wants to be an accountant After filling in the table with the function he asked you to calculate the quantity of possible different amounts on the path from a given cell x 1 y 1 to another given cell x 2 y 2 if you can only move one cell down or right Formally consider all the paths from the cell x 1 y 1 to cell x 2 y 2 such that each next cell in the path is located either to the down or to the right of the previous one Calculate the number of different sums of elements for all such paths ,"['// Author : PinkRabbit\n#include<bits/stdc++.h>\nusing namespace std;\n#define F(i,a,b) for(int i=a;i<=(b);++i)\n#define F2(i,a,b) for(int i=a;i<(b);++i)\n#define dF(i,a,b) for(int i=a;i>=(b);--i)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define Debug debug(""Passing [%s] in LINE %d\\n"",__FUNCTION__,__LINE__)\n#define MN 300005\n#define MM 600005\n#define ll long long\n#define mod 998244353\n#define inf 0x3f3f3f3f\n#define infll 0x3f3f3f3f3f3f3f3f\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mkp make_pair\n#define fi first\n#define se second\ninline int qpow(int b,ll e,int m=mod){int a=1;for(;e;e>>=1,b=(ll)b*b%m)if(e&1)a=(ll)a*b%m;return a;}\nint n,m,q,k;\nint a[MN],b[MN],f[MN],g[MN];\nvector<int>G[MN];\nint h[MN],nxt[MM],to[MM],tot;\ninline void ins(int x,int y){nxt[++tot]=h[x];to[tot]=y;h[x]=tot;}\nint main(){int tests=1;scanf(""%d"",&tests);\nwhile(tests--){\n\tint a,b,c,d,x,y;\n\tscanf(""%d%d%d%d"",&a,&b,&c,&d);\n\tx=c-a,y=d-b;\n\tprintf(""%lld\\n"",(ll)x*y+1);\n}\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600,Let s look at the way with the minimum sum first we go steps right and then steps down Let s look at such a change in the bends of the way After each step the sum on the way will increase by We re going to bend like this until we get to the maximum sum We re not going to miss any possible sum because we re incrementing the sum by 1 We started with the minimum sum and finished with the maximum sum so we can use these changes to get all possible sums In order for us to come from the minimum to the maximum way we must bend the way exactly 1 time per each cell of table except for the cells of the minimum way That is the number of changes equals the number of cells not belonging to the minimum way Then the number of different sums will be The overall compexity is per test 
You are given a string s of length n consisting of lowercase Latin letters You are allowed to replace at most one character in the string with an arbitrary lowercase Latin letter Print the lexicographically minimal string that can be obtained from the original string and contains the maximum number of palindromes as substrings Note that if a palindrome appears more than once as a substring it is counted the same number of times it appears The string a is lexicographically smaller than the string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b are different the string a contains a letter that appears earlier in the alphabet than the corresponding letter in b ,"['/**\n *    author:  tourist\n *    created: 18.12.2023 09:53:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> suffix_array(int n, const T &s, int char_bound) {\n  vector<int> a(n);\n  if (n == 0) {\n    return a;\n  }\n  if (char_bound != -1) {\n    vector<int> aux(char_bound, 0);\n    for (int i = 0; i < n; i++) {\n      aux[s[i]]++;\n    }\n    int sum = 0;\n    for (int i = 0; i < char_bound; i++) {\n      int add = aux[i];\n      aux[i] = sum;\n      sum += add;\n    }\n    for (int i = 0; i < n; i++) {\n      a[aux[s[i]]++] = i;\n    }\n  } else {\n    iota(a.begin(), a.end(), 0);\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\n  }\n  vector<int> sorted_by_second(n);\n  vector<int> ptr_group(n);\n  vector<int> new_group(n);\n  vector<int> group(n);\n  group[a[0]] = 0;\n  for (int i = 1; i < n; i++) {\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\n  }\n  int cnt = group[a[n - 1]] + 1;\n  int step = 1;\n  while (cnt < n) {\n    int at = 0;\n    for (int i = n - step; i < n; i++) {\n      sorted_by_second[at++] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      if (a[i] - step >= 0) {\n        sorted_by_second[at++] = a[i] - step;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      ptr_group[group[a[i]]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      int x = sorted_by_second[i];\n      a[ptr_group[group[x]]++] = x;\n    }\n    new_group[a[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (group[a[i]] != group[a[i - 1]]) {\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\n      } else {\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\n      }\n    }\n    swap(group, new_group);\n    cnt = group[a[n - 1]] + 1;\n    step <<= 1;\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<int> suffix_array(const T &s, int char_bound) {\n  return suffix_array((int) s.size(), s, char_bound);\n}\n\ntemplate <typename T>\nvector<int> build_lcp(int n, const T &s, const vector<int> &sa) {\n  assert((int) sa.size() == n);\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    pos[sa[i]] = i;\n  }\n  vector<int> lcp(max(n - 1, 0));\n  int k = 0;\n  for (int i = 0; i < n; i++) {\n    k = max(k - 1, 0);\n    if (pos[i] == n - 1) {\n      k = 0;\n    } else {\n      int j = sa[pos[i] + 1];\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n        k++;\n      }\n      lcp[pos[i]] = k;\n    }\n  }\n  return lcp;\n}\n\ntemplate <typename T>\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\n  return build_lcp((int) s.size(), s, sa);\n}\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  string u = s + ""#"" + string(s.rbegin(), s.rend());\n  auto sa = suffix_array(u, 256);\n  auto lcp = build_lcp(u, sa);\n  SparseTable<int> st(lcp, [&](int i, int j) { return min(i, j); });\n  vector<int> pos(sa.size());\n  for (int i = 0; i < (int) sa.size(); i++) {\n    pos[sa[i]] = i;\n  }\n  auto LCP = [&](int i, int j) {\n    i = n + 1 + (n - 1 - i);\n    i = pos[i];\n    j = pos[j];\n    if (i > j) {\n      swap(i, j);\n    }\n    return st.get(i, j - 1);\n  };\n  const int ALPHA = 26;\n  vector<vector<long long>> delta(n, vector<long long>(ALPHA));\n  vector<long long> broke_k(n + 1);\n  vector<long long> broke_b(n + 1);\n  auto Add = [&](int l, int r, int k, int b) {\n    broke_k[l] += k;\n    broke_k[r + 1] -= k;\n    broke_b[l] += b;\n    broke_b[r + 1] -= b;\n  };\n  long long init = 0;\n  for (int t = 0; t <= 2 * (n - 1); t++) {\n    int i = t >> 1;\n    int j = (t + 1) >> 1;\n    int v = LCP(i, j);\n    init += v;\n    if (i - v >= 0 && j + v < n) {\n      assert(s[i - v] != s[j + v]);\n      int add = 1;\n      if (i - v - 1 >= 0 && j + v + 1 < n) {\n        add += LCP(i - v - 1, j + v + 1);\n      }\n      delta[i - v][(int) (s[j + v] - \'a\')] += add;\n      delta[j + v][(int) (s[i - v] - \'a\')] += add;\n    }\n    if (i == j) {\n      i -= 1;\n      j += 1;\n      v -= 1;\n    }\n    if (v > 0) {\n      Add(i - v + 1, i, 1, -(i - v));\n      Add(j, j + v - 1, -1, j + v);\n    }\n  }\n  vector<long long> broke(n);\n  for (int i = 0; i < n; i++) {\n    broke[i] = broke_k[i] * i + broke_b[i];\n    broke_k[i + 1] += broke_k[i];\n    broke_b[i + 1] += broke_b[i];\n  }\n  auto Better = [&](pair<int, int> a, pair<int, int> b) {\n    assert(a.first <= b.first);\n    if (a.first == b.first) {\n      return a.second < b.second;\n    }\n    return a.second < (int) (s[a.first] - \'a\');\n  };\n  long long ans = init;\n  pair<int, int> p = {n, -1};\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = 0; j < 26; j++) {\n      if (j == (int) (s[i] - \'a\')) {\n        continue;\n      }\n      long long cur = init + delta[i][j] - broke[i];\n      pair<int, int> q = {i, j};\n      if (cur > ans || (cur == ans && Better(q, p))) {\n        ans = cur;\n        p = q;\n      }\n    }\n  }\n  cout << ans << \'\\n\';\n  if (p.first < n) {\n    s[p.first] = (char) (\'a\' + p.second);\n  }\n  cout << s << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0]",2800,Let s recall the algorithm for counting the number of palindromes in a string For each position we can calculate the longest odd and even palindromes with centers at that position the right one for even Then sum up all the values If we forget about the complexity we can consider the following algorithm for solving the full problem Iterate over the index of the change and the new letter Make the change count the number of palindromes and update the answer In case of equality choose the lexicographically minimal change Let s keep the first step and optimize the rest It won t be possible to count the number of palindromes from scratch for every change so let s try to calculate how much their number will change from the original It s also not feasible to compare all strings lexicographically naively so we have to come up with a faster way to compare Let s fix the change position Which of the longest palindromes change If for some center the longest palindrome included then we definitely know its new length Due to the change at the longest palindrome will stop at If the longest palindrome did not reach it will not change And only if it stopped at it can become longer and we don t know by how much yet But for each center and the parity of the palindrome there are only positions to the left and to the right where it stops So in total we will need to make such checks How to take into account the palindromes that become shorter We need to calculate the sum of the differences for all palindromes that include For an odd palindrome this change looks like this where is the center of the palindrome and the values show the difference in the number of palindromes for each position of the string For an even palindrome To calculate the sum at each position we can pre calculate a difference array based on these values The difference array usually implies first order changes write at write at then collect the prefix sum to get But we can also record second order changes For the odd construction we will write as follows Let the length of the palindrome be and the center be Then Then iterate from left to right maintaining two variables The current change and the current value At each add to the change add the change to the value and save the value to some array For the even case it is built similarly It is easy to see that such changes can be made at the same time Basically the same as the regular difference array Now in each position the total decrease in the length of the palindromes passing through that position is recorded The answer will decrease by almost this amount The only difference is the odd length palindromes with a center at this position They will not change at all and we accidentally subtracted them Thus let s save the longest odd palindrome for each position in advance and add it back Let s learn how to calculate the longest palindromes for each center Yes there is the Manacher s algorithm for a static string We can use it for counting at the very beginning but it s not really necessary Instead let s learn to count palindromes using suffix structures In particular with a suffix array It is known that with an additional sparse table we can query the longest common prefix of two suffixes in with pre calculation in Let s build a suffix array on the string Then we can query the LCP of both suffixes and reverse prefixes Then the longest odd palindrome with center at is LCP The even one is LCP So we can count the palindromes at the very beginning with pre calculation and extra calculations The following task remains For each position the centers of the palindromes that reach it are known For each such center we need to be able to recalculate how much longer the palindrome will become after changing the letter at that position Obviously even the new letter may still not match the letter on the other side If it does match we would like to know how many letters further match the opposite ones in the original string And we already have a tool for this It s still a simple LCP query on the suffix to the right of the right letter and the reverse prefix to the left of the left letter Now we have everything necessary to recalculate the number of palindromes If the new count is greater than the current maximum we will simply update the answer If it is equal we need to check the lexicographic order The following check works if one change increased the original letter and the other decreased it then the second one will definitely produce a smaller string if both changes decreased it then the more left one will produce a smaller string if both are in the same position the smaller letter will produce a smaller string if both changes increased it then the more right one will produce a smaller string if both are in the same position the smaller letter will produce a smaller string All these checks can be performed in Overall complexity 
You have two friends You want to present each of them several positive integers You want to present numbers to the first friend and numbers to the second friend Moreover you want all presented numbers to be distinct that also means that no number should be presented to both friends In addition the first friend does not like the numbers that are divisible without remainder by prime number The second one does not like the numbers that are divisible without remainder by prime number Of course you re not going to present your friends numbers they don t like Your task is to find such minimum number that you can form presents using numbers from a set Of course you may choose not to present some numbers at all A positive integer number greater than 1 is called if it has no positive divisors other than 1 and itself ,"['#include <bits/stdc++.h>\nusing namespace std;\nlong long a, b, x, y;\n\nlong long ok(long long n) {\n    long long oa = n / x;\n    long long ob = n / y;\n    long long oab = n / x / y;\n\n    long long com = n - oa - ob + oab;\n    long long ca = n - oa;\n    long long cb = n - ob;\n    return ca >= a && cb >= b && ca + cb - com >= a + b;\n}\n\nint main() {\n    cin >> a >> b >> x >> y;\n    long long l = max(a, b), r = 1e13;\n    while(l < r) {\n        long long m = (l + r) >> 1;\n        if(!ok(m)) l = m + 1;\n        else r = m;\n    }\n    cout << r << endl;\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1800,Problem author s solution is using binary search First you can notice that if you can make presents with numbers then you can make presents with numbers too Let be the function returning true or false is it right that you can make presents with numbers Let be the number of numbers divisible by the number of numbers divisible by and number of numbers divisible by and by as soon as and are primes it is equivalent to divisibility by Then to first friend at first we shold give numbers and to second friend numbers Then we must check could we give all other numbers divisible neither by nor by 
Nearly each project of the F company has a whole team of developers working on it They often are in different rooms of the office in different cities and even countries To keep in touch and track the results of the project the F company conducts shared online meetings in a Spyke chat One day the director of the F company got hold of the records of a part of an online meeting of one successful team The director watched the record and wanted to talk to the team leader But how can he tell who the leader is The director logically supposed that the leader is the person who is present at any conversation during a chat meeting In other words if at some moment of time at least one person is present on the meeting then the leader is present on the meeting You are the assistant director Given the user logged on user logged off messages of the meeting in the chronological order help the director determine who can be the leader Note that the director has the record of only a continuous part of the meeting probably it s not the whole meeting ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define N 100005\nusing namespace std;\n\nint n, m, cnt;\nint v[N], nod[N], a[N], L[N];\nchar op[N][5];\n\nint main(){\n\tscanf(""%d%d"", &n, &m);\n\tCLR(v, -1);\n\tFOR(i,0,m){\n\t\tscanf(""%s%d"", &op[i], &a[i]), --a[i];\n\t\tif (v[a[i]] == -1) v[a[i]] = (op[i][0] == \'+\' ? 1 : 0);\n\t}\n\t\n\tint sz = 0;\n\tFOR(i,0,n){\n\t\tif (v[i] == 0) ++cnt;\n\t\tif (v[i] == 1) L[sz++] = i;\n\t}\n\t\n\tif (cnt > 0){\n\t\twhile (sz) nod[L[--sz]] = 1;\n\t}\n\t\n\tFOR(i,0,m){\n\t\tif (op[i][0] == \'+\'){\n\t\t\tif (cnt > 0) nod[a[i]] = 1;\n\t\t\t++cnt;\n\t\t\twhile (sz){\n\t\t\t\t--sz;\n\t\t\t\tif (L[sz] != a[i]) nod[L[sz]] = 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t--cnt;\n\t\t\tif (cnt > 0) nod[a[i]] = 1;\n\t\t\tif (!nod[a[i]]) L[sz++] = a[i];\n\t\t}\n\t}\n\t\n\tint ret = n;\n\tFOR(i,0,n) ret -= nod[i];\n\tprintf(""%d\\n"", ret);\n\tFOR(i,0,n) if (!nod[i]) printf(""%d "", i + 1);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1800,Firstly lets add to the answer all the persons that didn t appear in the log messages Then we should consider two cases 1 If there is a person with number that the first log message with him is in form We will call such persons X persons Consider all X persons Pick the one from them that has the last first occurrence in the sequence of messages This person can be a leader all others cannot be Now we should check if the picked person is a leader or not For that reason we will use the algorithm that is described below This algorithm works fine only on special sequences of messages So we need to add all the X persons to the beginning of the our list in the order they appear in input in the resulting sequence the picked person should be the first 2 There is no X persons That case only the first person from the list can be a leader Others cannot be Check that person with the algorithm described below The Algorithm of check The algorithm is very simple Just to iterate throughout the sequence of messages and maintain structure for the persons that are currently on the meeting If we consider log on message add the person to the set if we consider log off message erase the person from the set Each time we perform an operation with set we should check either the set is empty or the leader is in set The most tricky cases are 33 and 34 Will look at them the 33 th test 4 4 2 1 3 2 Here the leader can be only 4 th person Others cannot be The 34 th test 3 3 2 1 2 The answer for that test is only the 3 rd participant 
Kijin Seija Shinmyoumaru has a mallet that can turn objects bigger or smaller She is testing it out on a sequence a and a number v whose initial value is 1 She wants to make v gcd limits i ne j a i cdot a j by 10 5 operations gcd limits i ne j a i cdot a j denotes the gcd of all products of two distinct elements of the sequence a In each operation she picks a subsequence b of a and does one of the followings v v cdot mathrm lcm b v frac v mathrm lcm b Note that she does need to guarantee that v is an integer that is v does need to be a multiple of mathrm lcm b when performing Reduce Moreover she wants to guarantee that the total length of b chosen over the operations does not exceed 10 6 Fine a possible operation sequence for her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint d[N];\nint cntDif[N];\nint c[N][3];\nbool u[N];\n\nvector<pair<vector<int>, int>> getGcd(int ban) {\n\tint g = 0;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tg = gcd(g, a[i]);\n\t}\n\tint gg = 0;\n\tvector<int> w;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tint ng = gcd(gg, a[i]);\n\t\tif (ng == gg) continue;\n\t\tif (gg == 0 || cntDif[gg / g] != cntDif[ng / g]) {\n\t\t\tw.push_back(i);\n\t\t}\n\t\tgg = ng;\n\t}\n\tvector<pair<vector<int>, int>> ans;\n\tint sz = (int)w.size();\n\tassert(sz > 0);\n\tfor (int mask = 1; mask < (1 << sz); mask++) {\n\t\tint t = 1;\n\t\tvector<int> cur;\n\t\tfor (int i = 0; i < sz; i++) if ((mask >> i) & 1) {\n\t\t\tt ^= 1;\n\t\t\tcur.push_back(w[i]);\n\t\t}\n\t\tans.push_back(mp(cur, t));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int x = 2; x < N; x++) {\n\t\tif (d[x] != 0) continue;\n\t\tc[x][0] = 0;\n\t\tc[x][1] = 30;\n\t\tc[x][2] = -1;\n\t\tfor (int y = x; y < N; y += x)\n\t\t\tif (d[y] == 0)\n\t\t\t\td[y] = x;\n\t}\n\tcntDif[1] = 0;\n\tfor (int x = 2; x < N; x++) {\n\t\tint y = x;\n\t\twhile(d[y] == d[x]) y /= d[x];\n\t\tcntDif[x] = cntDif[y] + 1;\n\t}\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tint x = a[i];\n\t\twhile(x > 1) {\n\t\t\tint p = d[x];\n\t\t\tint k = 0;\n\t\t\twhile(x % p == 0) {\n\t\t\t\tx /= p;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tc[p][0]++;\n\t\t\tif (k < c[p][1]) {\n\t\t\t\tc[p][1] = k;\n\t\t\t\tc[p][2] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int p = 2; p < N; p++) if (d[p] == p) {\n\t\tif (c[p][0] <= n - 2) continue;\n\t\tif (c[p][0] == n - 1) {\n\t\t\tint v = 0;\n\t\t\twhile(a[v] % p == 0) v++;\n\t\t\tu[v] = 1;\n\t\t} else {\n\t\t\tu[c[p][2]] = 1;\n\t\t}\n\t}\n\tvector<int> zz;\n\tfor (int i = 0; i < n; i++)\n\t\tif (u[i])\n\t\t\tzz.push_back(i);\n\tvector<pair<vector<int>, int>> ans;\n\tvector<pair<vector<int>, int>> ans0 = getGcd(-1);\n\tint w = 2 - (int)zz.size();\n\tif (w > 0) {\n\t\tfor (int it = 0; it < w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(z);\n\t} else {\n\t\tfor (int it = 0; it < -w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(mp(z.first, z.second ^ 1));\n\t}\n\tfor (int x : zz) {\n\t\tans0 = getGcd(x);\n\t\tfor (auto z : ans0)\n\t\t\tans.push_back(z);\n\t}\n\tprintf(""%d\\n"", (int)ans.size());\n\tfor (auto z : ans) {\n\t\tprintf(""%d %d"", z.second, (int)z.first.size());\n\t\tsort(all(z.first));\n\t\tfor (int id : z.first)\n\t\t\tprintf("" %d"", id + 1);\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0]",3500,Solution Let be the maximum integer satisfying For each prime WLOG assuming then Consider the Inclusion Exclusion Principle So Then We can solve the task by choosing a short subsequence satisfying and enumerating its subsets To fit in the constraint the length of should be no longer than Think of an easier task choosing a small subset satisfying If we can solve it we can construct by choosing if does not exceed First choose an arbitrary element in as the only element of and factorize into For each if then add an arbitrary element in satisfying to Now obviously but We can prove that and do not hold at the same time then we can solve the task by choosing Consider the necessary condition of According to how we choose so Since and But causing a conflict So does not hold The time complexity is Worth mentioning with this conclusion such small set exists we can solve it much more easier Just choose a small set by greedy and enumerate its subset of size 
You have a rooted tree consisting of vertices Let s number them with integers from to inclusive The root of the tree is the vertex For each direct parent of the vertex is We say that vertex is child for its direct parent You have initially painted all the vertices with red color You like to repaint some vertices of the tree To perform painting you use the function that you call with the root of the tree as an argument Here is the pseudocode of this function count 0 global integer variable rnd this function is used in paint code return 0 or 1 equiprobably paint s if count is even then paint s with white color else paint s with black color count count 1 if rnd 1 then children array of vertex s children in ascending order of their numbers else children array of vertex s children in descending order of their numbers for child in children iterating over children array if rnd 1 then paint child calling paint recursively As a result of this function some vertices may change their colors to white or black and some of them may remain red Your task is to determine the number of distinct possible colorings of the vertices of the tree We will assume that the coloring is possible if there is a nonzero probability to get this coloring with a single call of We assume that the colorings are different if there is a pair of vertices that are painted with different colors in these colorings Since the required number may be very large find its remainder of division by ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 200010;\n\nvector <int> g[N];\nint f[N][2];\nint aux[7][7], new_aux[7][7];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 1; i <= n; i++) {\n    g[i].clear();\n  }\n  for (int i = 2; i <= n; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    g[foo].push_back(i);\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int tot = 0; tot < 2; tot++) {\n      for (int all = 0; all < 4; all++) {\n        aux[tot][all] = 0;\n      }\n    }\n    aux[0][0] = 1;\n    int sz = g[i].size();\n    for (int j = 0; j < sz; j++) {\n      int u = g[i][j];\n      for (int tot = 0; tot < 2; tot++) {\n        for (int all = 0; all < 4; all++) {\n          new_aux[tot][all] = aux[tot][all];\n        }\n      }\n      for (int tot = 0; tot < 2; tot++) {\n        for (int all = 0; all < 4; all++) {\n          for (int cur = 0; cur < 2; cur++) {\n            add(new_aux[tot ^ cur][all | (1 << cur)], mul(aux[tot][all], f[u][cur]));\n          }\n        }\n      }\n      for (int tot = 0; tot < 2; tot++) {\n        for (int all = 0; all < 4; all++) {\n          aux[tot][all] = new_aux[tot][all];\n        }\n      }\n    }\n    f[i][0] = f[i][1] = 0;\n    for (int tot = 0; tot < 2; tot++) {\n      for (int all = 0; all < 4; all++) {\n        add(f[i][tot ^ 1], aux[tot][all]);\n        if (all == 3 || (all == 2 && tot == 0)) {\n          add(f[i][tot ^ 1], aux[tot][all]);\n        }\n      }\n    }\n  }\n  printf(""%d\\n"", (f[1][0] + f[1][1]) % md);\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2700,Let s calculate dynamics the answer for vertex with size of parity At first step to calculate this dynamic for vertex we should count all different paintings of a subtree visiting all children in increasing order of their numbers By multiplying this number by 2 we will get paintings visiting children in decreasing order Now some paintings may count twice To fix that let s have a look on a some subtree of a vertex Consider all the parities of children subtrees visited by our function 0 or 1 First thing to note is that among these parities exist two different values the subtree will have different paintings with different ordering you can prove it yourself Otherwise all our children sizes have the same parity If all sizes are even this subtree will be counted twice Otherwise if sizes are odd we are interested only in odd count of visited subtrees This way we must subtract from our dynamic the number of ways to paint any number of children with even subtree sizes and odd number of children with odd subtree sizes Jury s solution 8394936 
Niwel is a little golden bear As everyone knows bears live in forests but Niwel got tired of seeing all the trees so he decided to move to the city In the city Niwel took on a job managing bears to deliver goods The city that he lives in can be represented as a directed graph with nodes and edges Each edge has a weight capacity A delivery consists of a bear carrying weights with their bear hands on a simple path from node to node The total weight that travels across a particular edge must not exceed the weight capacity of that edge Niwel has bears In the interest of fairness no bear can rest and the weight that each bear carries must be exactly the same However each bear may take different paths if they like Niwel would like to determine what is the maximum amount of weight he can deliver it s the sum of weights carried by bears Find the maximum weight ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=0x20202020;\ntypedef int flowt;\nnamespace flow {\n\tconst int M=100000,N=1000;\n\tint y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\n\tflowt f[M];\n\tint S,T,tot,Tn;\n\tvoid init(int s,int t,int tn) {\n\t\ttot=1; assert(tn<N);\n\t\trep(i,0,tn) fst[i]=0;\n\t\tS=s;T=t;Tn=tn;\n\t}\n\tvoid add(int u,int v,flowt c1,flowt c2=0) {\n\t\ttot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\n\t\ttot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\n\t}\n\tflowt sap() {\n\t\tint u=S,t=1;flowt flow=0;\n\t\trep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\n\t\tq[0]=T;dis[T]=0;pre[S]=0;\n\t\trep(i,0,t) {\n\t\t\tint u=q[i];\n\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (dis[y[j]]>dis[u]+1&&f[j^1]) \n\t\t\t\tq[t++]=y[j],dis[y[j]]=dis[u]+1;\n\t\t}\n\t\trep(i,0,Tn) gap[dis[i]]++;\n\t\twhile (dis[S]<=Tn) {\n\t\t\twhile (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\n\t\t\tif (c[u]) {\n\t\t\t\tpre[y[c[u]]]=c[u]^1;\n\t\t\t\tu=y[c[u]];\n\t\t\t\tif (u==T) {\n\t\t\t\t\tflowt minf=inf;\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\n\t\t\t\t\tflow=min(flow+minf,inf);u=S;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(--gap[dis[u]])) break;\n\t\t\t\tint mind=Tn;\n\t\t\t\tc[u]=fst[u];\n\t\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind) \n\t\t\t\t\tmind=dis[y[j]],c[u]=j;\n\t\t\t\tdis[u]=mind+1;\n\t\t\t\tgap[dis[u]]++;\n\t\t\t\tif (u!=S) u=y[pre[u]];\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nconst int M=1010;\nint n,m,k,u[M],v[M],w[M];\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&k);\n\trep(i,0,m) {\n\t\tscanf(""%d%d%d"",u+i,v+i,w+i); --u[i],--v[i];\n\t}\n\tdouble l=1./k,r=1e6;\n\trep(rd,0,60) {\n\t\tdouble md=(l+r)*0.5;\n\t\tflow::init(0,n-1,n);\n\t\trep(i,0,m) {\n\t\t\tflow::add(u[i],v[i],(int)min(w[i]/md,(double)k+1e-10));\n\t\t}\n\t\tif (flow::sap()>=k) l=md; else r=md;\n\t}\n\tprintf(""%.10f\\n"",r*k);\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 1]",2200,Let s transform this into a flow problem Here we transform weight into flow and each bear becomes a path Suppose we just want to find the answer for a single We can do this binary search on the flow for each path To check if a particular flow of is possible reduce the capacity of each edge from to Then check if the max flow in this graph is at least The final answer is then multiplied by the flow value that we found MUCH HARDER VERSION you are also given an integer and your task is to find the answer for paths for paths and for paths There should be real values on the output The solution of the harder version However this is not fast enough when we have up to 10 4 values of x to check Instead we look at a fast way of getting the flow value for x 1 paths given a flow with x paths in only O m log m time Suppose we ve found the paths for x bears and we know that the number of bears who use edge number i is w i Also let f x be the weight that each bear carries given that there are x bears Then we can create a residual graph as follows For each edge u i v i with capacity c i create an edge in th residual graph from u i to v i with capacity c i 1 w i and if w i 0 a backward edge with capacity f x Then we can find the fattest path in this graph with a dijsktra s in O m log m giving us f x 1 This also allows us to update our paths In particular if we use a backwards edge we subtract the number of times the edge is used by 1 otherwise we increase it by 1 This allows us to construct a new residual graph It can be shown that this only results in at most one new path We can prove that this is correct by induction Suppose the answer is correct for x bears Now one observation is that f x 1 must be less than or equal to f x as any plan that x 1 bears follow will also be able to be executed with x bears Suppose the optimal solution for x 1 bears is actually g x 1 We just need to argue that f x 1 g x 1 and we are done In the optimal solution consider replacing each edge with capacity c i to floor c i g x 1 Now consider the optimal paths for x bears in this reduced capacity graph which we found through induction Since there are only x bears but we know we can support x 1 bears there exists a path in the residual graph from the source to the sink Let s look at the capacity of this path If we travel along any backward edge the capacity of that edge is f x which is at least g x 1 If we travel on a forward edge we have c i 1 w i g x 1 c i 1 w i g x 1 The second inequality follows from reversing the divide by g x 1 step Thus the overall running time is O mn 2 log m x k m log m where the first part comes from the initial binary search and the second part comes from doing k fattest path computations 
You are given an array a of n non negative integers In one operation you can change any number in the array to any other non negative integer Let s define the of the array as operatorname DIFF a operatorname MEX a where operatorname MEX of a set of non negative integers is the smallest non negative integer not present in the set and operatorname DIFF is the number of different numbers in the array For example operatorname MEX 1 2 3 0 operatorname MEX 0 1 2 4 5 3 You should find the minimal cost of the array a if you are allowed to make at most k operations ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 18:50:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> q(n);\n    for (int i = 0; i < n; i++) {\n      cin >> q[i];\n    }\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n      mp[q[i]] += 1;\n    }\n    multiset<int> a;\n    multiset<int> b;\n    for (auto& p : mp) {\n      b.insert(p.second);\n    }\n    int sum = 0;\n    int ans = (int) 1e9;\n    int holes = 0;\n    for (int mex = 0; mex <= n; mex++) {\n      while (!b.empty() && sum + (*b.begin()) <= k) {\n        sum += (*b.begin());\n        a.insert(*b.begin());\n        b.erase(b.begin());\n      }\n      if (holes <= k) {\n        ans = min(ans, (int) b.size());\n      }\n      auto it = mp.find(mex);\n      if (it == mp.end()) {\n        holes += 1;\n      } else {\n        if (a.find(it->second) != a.end()) {\n          sum -= it->second;\n          a.erase(a.find(it->second));\n        } else {\n          b.erase(b.find(it->second));\n        }\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 1, 1, 1, 1, 0, 0]",2100,Let s consider all possible after all operations It is from to and we can check them all in the increasing order Now let s fix some There should be all numbers from to in the array so there are some holes in the array that should be covered The hole is an integer from to which is not present in the array If there is at least one hole in the end it is not possible to obtain Now let s see how we should cover the holes We will do it greedily Firstly we will need to use integers that are greater than It is easy to see that they are always not worse to use than the integers which are already from to Moreover we should start from those integers that occur less times in the array It is because each time we cover a hole we increase at least by one we cover the holes in increasing order and the value of increases at most by and it does not increase when we change the last element of the same value After that if we used all integers that are greater than we should use those integers that are from to but only those that occur more than once By doing these operations we increase at least by and increase exactly by because we cover a hole Now let s notice that when considering each value in the increasing order we can simply maintain some information about the current state of the array a set that helps us find the elements greater than which occur less times in the array the amount of not covered holes the number of bonus elements from to the number of integers from to minus from those elements that are from to and it is easy to see how it is changed when we increase So in total we can calculate the answer for each for all from to 
The Little Elephant has two permutations and of length consisting of numbers from 1 to inclusive Let s denote the th element of the permutation as the th element of the permutation as The between permutations and is the minimum absolute value of the difference between the positions of the occurrences of some number in and in More formally it s such minimum that A number of permutation consisting from elements is a permutation Overall a permutation has cyclic shifts The Little Elephant wonders for all cyclic shifts of permutation what is the distance between the cyclic shift and permutation ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint to[101000];\nint dif[101000];\nint ans[101000];\ninline int ABS(int a){return a>0?a:-a;}\nint main(){\n    int n,i,j;\n    scanf(""%d"",&n);\n    for(i=1;i<=n;i++){\n        int a;\n        scanf(""%d"",&a);\n        to[a]=i;\n    }\n    for(i=1;i<=n;i++){\n        int a;\n        scanf(""%d"",&a);\n        dif[i]=to[a]-i;\n        ans[i]=101000;\n    }\n    ans[0]=101000;\n    set<int> XD;\n    for(i=1;i<=n;i++){\n        XD.insert(dif[i]);\n        set<int>::iterator it=XD.lower_bound(n-i);\n        if(it!=XD.end()){\n            ans[i]=min(ans[i],ABS(*it-(n-i)));\n        }\n        if(it!=XD.begin()){\n            it--;\n            ans[i]=min(ans[i],ABS(*it-(n-i)));\n        }\n    }\n    XD.clear();\n    for(i=n;i>=1;i--){\n        XD.insert(dif[i]);\n        set<int>::iterator it=XD.lower_bound(-(i-1));\n        if(it!=XD.end()){\n            ans[i-1]=min(ans[i-1],ABS(*it+(i-1)));\n        }\n        if(it!=XD.begin()){\n            it--;\n            ans[i-1]=min(ans[i-1],ABS(*it+(i-1)));\n        }\n    }\n    ans[0]=min(ans[0],ans[n]);\n    for(i=0;i<n;i++)printf(""%d\\n"",ans[i]);\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2100,Each of the shifts can be divided into two parts the right the one that starts from occurrence 1 and the left the rest of the elements If we could keep minimal distance for each part the minimal of these numbers will be the answers for the corresponding shift Lets solve the problems of the right part the left will be almost the same Let we have some shift for example and the permutation is and is then shifted is Let we keep two sets and The first will keep all the distances from integers in current left part to the corresponding positions in for the example above it is texttt 2 4 When you come to the next shift all integers in should be decreased by 1 that is because all distances are also decreased by 1 But now some integers in set may be negative when any negative integer occures it always will be 1 you need to delete it from and put 1 to the Also after shifting to the next shifts all integers in must be increase by 1 After that for any shift the answer will be minimum from the smallest numbers in and It was very useful to use standart set in C 
The number zero is called love or l oeuf to be precise literally means egg in French for example when denoting the zero score in a game of tennis Aki is fond of numbers especially those with trailing zeros For example the number 9200 has two trailing zeros Aki thinks the more trailing zero digits a number has the prettier it is However Aki believes that the number of trailing zeros of a number is not static but depends on the base radix it is represented in Thus he considers a few scenarios with some numbers and bases And now since the numbers he used become quite bizarre he asks you to help him to calculate the beauty of these numbers Given two integers n and b in decimal notation your task is to calculate the number of trailing zero digits in the b ary in the base radix of b representation of n factorial of n ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 1000500;\nconst int MOD = 1000000007;\n\nvoid bad() {\n  cout << ""No"" << endl;\n  exit(0);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  long long n;\n  long long b;\n  cin >> n >> b;\n\n  vector<pair<ll, int>> f;\n  for (ll x = 2; x * x  <= b; ++x) {\n    if (b % x == 0) {\n      f.emplace_back(x, 0);\n      while(b % x == 0) {\n        f.back().second++;\n        b /= x;\n      }\n    }\n  }\n  if (b > 1) {\n    f.emplace_back(b, 1);\n  }\n\n  long long ans = numeric_limits<ll>::max();\n  for (auto x : f) {\n    ll m = n;\n    long long res = 0;\n    while (m > 0) {\n      m /= x.first;\n      res += m;\n    }\n    ans = min(ans, res / x.second);\n  }\n  cout << ans << endl;\n  return 0;\n}']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",1700,TutorialThe problem can be reduced to the following finding the maximum that is divisible by By prime factorization we will have the following In a similar manner we will also have with being coprime to any presented above The process of finding can be done by normal prime factorization of the value The process of finding is a little bit more tricky since the integer they were originated is too huge to be factorized manually Still the factorial properties gave us another approach for each we can do the following Initially denote Repeatedly do the following add to then divide by The loop ends when is zero After all we can obtain the final value as of following Total complexity as the number of prime factors of an integer will not surpass 
The capital of Berland has multifloor buildings The architect who built up the capital was very creative so all the houses were built in one row Let s enumerate all the houses from left to right starting with one A house is considered to be if the number of floors in it is strictly greater than in all the houses with larger numbers In other words a house is luxurious if the number of floors in it is strictly greater than in all the houses which are located to the right from it In this task it is assumed that the heights of floors in the houses are the same The new architect is interested in questions th of them is about the following how many floors should be added to the th house to make it luxurious for all from to inclusive You need to help him cope with this task Note that all these questions are independent from each other the answer to the question for house does not affect other answers i e the floors to the houses are not actually added ,"['#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint num[100010],pr[100010];\nint main()\n{\n    int n,n1;\n    cin>>n;\n    for(n1=1;n1<=n;n1++)\n        scanf(""%d"",&num[n1]);\n    int mx=-inf;\n    for(n1=n;n1>=1;n1--)\n    {\n        pr[n1]=max(0,mx-num[n1]+1);\n        mx=max(num[n1],mx);\n    }\n    for(n1=1;n1<=n;n1++)\n        cout<<pr[n1]<<\' \';  \n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1100,This problem can be solved in the following way Let s iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered Then the answer to house number i is number max 0 maxH 1 hi where hi number of floors in house number i 
The store sells n types of candies with numbers from 1 to n One candy of type i costs b i coins In total there are a i candies of type i in the store You need to pack all available candies in packs each pack should contain only one type of candies Formally for each type of candy i you need to choose the integer d i denoting the number of type i candies in one pack so that a i is divided without remainder by d i Then the cost of one pack of candies of type i will be equal to b i cdot d i Let s denote this cost by c i that is c i b i cdot d i After packaging packs will be placed on the shelf Consider the cost of the packs placed on the shelf in order c 1 c 2 ldots c n Price tags will be used to describe costs of the packs One price tag can describe the cost of all packs from l to r inclusive if c l c l 1 ldots c r Each of the packs from 1 to n must be described by at least one price tag For example if c 1 ldots c n 4 4 2 4 4 to describe all the packs a 3 price tags will be enough the first price tag describes the packs 1 2 the second 3 the third 4 5 You are given the integers a 1 b 1 a 2 b 2 ldots a n b n Your task is to choose integers d i so that a i is divisible by d i for all i and the required number of price tags to describe the values of c 1 c 2 ldots c n is the minimum possible For a better understanding of the statement look at the illustration of the first test case of the first test Let s repeat the meaning of the notation used in the problem a i the number of candies of type i available in the store b i the cost of one candy of type i d i the number of candies of type i in one pack c i the cost of one pack of candies of type i is expressed by the formula c i b i cdot d i ,"['#pragma GCC optimization(""O3"")\n#pragma GCC optimization(""Ofast,unroll-loops"")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline ""\\n""                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<"" ""; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<""{""; _print(p.first);cerr<<"",""; _print(p.second);cerr<<""}"";}\ntemplate<class T>void _print(vector<T> v) {cerr<<"" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(set<T> v) {cerr<<"" [ ""; for (T i:v){_print(i); cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< "" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<"" [ ""; for(auto i:v) {_print(i);cerr<<"" "";} cerr<<""]"";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n; cin>>n;\n    vector<pair<ll,ll>> a(n);\n    for(auto &it:a){\n        cin>>it.f>>it.s;\n    }\n    ll ans=1;\n    ll num=a[0].f*a[0].s,den=a[0].f;\n    for(ll i=1;i<n;i++){\n        auto it=a[i];\n        ll now_num=it.f*it.s,now_den=it.f;\n        ll cur_check=__gcd(num,now_num);\n        ll lft=num/cur_check,rght=now_num/cur_check;\n        ll valid=1;\n        if(den%lft){\n            valid=0;\n        }\n        if(now_den%rght){  \n            valid=0;\n        }\n        if(valid){\n            den/=lft;\n            now_den/=rght;\n            den=__gcd(den,now_den);\n            num=cur_check;\n        }\n        else{\n            ans++;\n            num=now_num;\n            den=now_den;\n        }\n    }\n    cout<<ans<<nline; \n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(""input.txt"", ""r"", stdin);                                              \n    freopen(""output.txt"", ""w"", stdout);  \n    freopen(""error.txt"", ""w"", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}  ']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700,To begin with let s understand when 1 price tag will be enough Let the total cost of all packs of candies be Two conditions are imposed on The first condition must be divided by each of the numbers because This is equivalent to the fact that is divided by where denotes the least common multiple The second condition is divided by We want to somehow appear in this condition Therefore multiply both parts by and we get that is divisible by That is is divided by This is equivalent to is divided by Thus if one price tag is enough it is necessary that was divided by and was divided by So a necessary and sufficient condition for one price tag will be is divided by It is not difficult to understand that if one price tag is enough for a set of candies then if you remove any type of candy from this set one price tag will still be enough This means that a simple greedy algorithm will work Let s select the largest prefix of candies such that one price tag is enough for it paste a price tag on this prefix and repeat for the remaining candies until the array ends 
There is a grid with n rows and m columns and three types of cells An empty cell denoted with A stone denoted with An obstacle denoted with the lowercase Latin letter All stones fall down until they meet the floor the bottom row an obstacle or other stone which is already immovable In other words all the stones just fall down as long as they can fall Simulate the process What does the resulting grid look like ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n, m;\n  cin >> n >> m;\n  char c[n][m];\n  rep(i, n) rep(j, m) cin >> c[i][j];\n  for(int i = n - 1; i >= 0; --i){\n    for(int j = 0; j < m; ++j){\n      if(c[i][j] == \'.\'){\n        int k = i - 1;\n        while(k >= 0 and c[k][j] == \'.\') k--;\n        if(k < 0 || c[k][j] == \'o\') continue;\n        else{\n          c[k][j] = \'.\';\n          c[i][j] = \'*\';\n        }\n      }\n    }\n  }\n  rep(i, n){\n    rep(j, m) cout << c[i][j];\n    cout << \'\\n\';\n  }\n}\n\n\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << ""Case #"" << i << "": "";\n      solve();\n    }\n    return 0;\n}   ']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1200,Note that the columns don t affect each other so we can solve for each column by itself For each column go from the bottom to the top and keep track of the row of the last obstacle seen call it Note that initially since we treat the floor as the th row of obstacles Whenever we see a new obstacle we should update Now if we ever see a stone we should move it to row since it will be one row above the last obstacle seen it will fall on top of it Afterwards we should also decrease by because if any future stones fall on top of it they will land on the row above this stone This solution works in We also accepted slower solutions that run in that simulate each stone falling 
Let s name a pair of positive integers x y if the greatest common divisor of them is equal to 1 gcd x y 1 Let s define a induced by x y as a sequence of pairs x y x 1 y 1 x 2 y 2 dots x k y k for some integer k ge 0 The of the chain is the number of pairs it consists of or k 1 Let s name such chain if all pairs in the chain are lucky You are given n pairs x i y i Calculate for each pair the length of the longest lucky chain induced by this pair Note that if x i y i is not lucky itself the chain will have the length 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 10000000;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  vector<int> p(MAX, -1);\n  for (int i = 2; i < MAX; i++){\n    if (p[i] == -1){\n      for (int j = i * 2; j < MAX; j += i){\n        p[j] = i;\n      }\n    }\n  }\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    int x, y;\n    cin >> x >> y;\n    if (gcd(x, y) > 1){\n      cout << 0 << endl;\n    } else if (y == x + 1){\n      cout << -1 << endl;\n    } else {\n      int d = y - x;\n      vector<int> f;\n      while (p[d] != -1){\n        f.push_back(p[d]);\n        d /= p[d];\n      }\n      if (d > 1){\n        f.push_back(d);\n      }\n      sort(f.begin(), f.end());\n      f.erase(unique(f.begin(), f.end()), f.end());\n      int ans = MAX;\n      for (int a : f){\n        ans = min(ans, a - x % a);\n      }\n      cout << ans << ""\\n"";\n    }\n  }\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600,Suppose It means that is also divisible by or is divisible by And backward if then is also divisible by or is divisible by Since is divisible by and is divisible by so In other words we proved that Now knowing the equivalence above we can understand that we are looking for the smallest such that In other words we are searching such that is divisible by some where is some divisor of The problem is that there are a handful of divisors for some But we can note that we can consider only divisors of if and is composite then there is some prime thus It s easy to prove that there are no more than prime divisors of some Now the question is how to find all these prime divisors Note that if you know only one prime divisor for each value from to then you can find all prime divisors for all in The prime divisors are next and so on until The final step is to calculate a prime divisor for each value from to where or We can do it by slight modifications of Sieve of Eratosthenes at the step where you have some prime and want to throw out all values set for each plus set As a result we firstly calculate Sieve in and secondly calculate answer for each pair in Note that the input and output is large so you should you tricks to speed up your input and output 
A multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by That is there are no two integers and from the set such that You re given a set of distinct positive integers Your task is to find the size of it s largest multiple free subset ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nset <int> bad;\nint a[100010];\n\nint main(void){\n    int N,K,i;\n    \n    cin >> N >> K;\n    REP(i,N) scanf(""%d"", &a[i]);\n    sort(a, a+N);\n    \n    int ans = 0;\n    for(i=N-1;i>=0;i--){\n        if(bad.find(a[i]) == bad.end()){\n            ans++;\n            if(a[i] % K == 0) bad.insert(a[i] / K);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 1, 0]",1500,Consider an integer x which is divisible by k At most one of the integers x and x k can appear in the maximum k multiple free subset Also for any integer y at most one of the numbers y and yk appears in the answer If you look like this you can see the input as chains of numbers so that for each chain no two adjacent elements can appear in the output For example If k 2 then 6 12 24 48 96 forms a chain It s easy to see that from a chain of length l we can choose at most l 1 2 elements in the answer So the solution would be to compute the lengths of the chains and pick as much numbers as we can from each chain You can sort all the numbers and do binary search or similar things to find the length of chains Here s a cute greedy solution which picks numbers greedily from the chains First sort all the numbers Also consider an empty set of integers S which represents the output For each integer x in the sequence If it s not divisible by k just pick it and insert it into S Otherwise if it s divisible by k check if x k is in S or not If it s not in S insert x into S otherwise skip x I d also like to note that this problem comes from an old problem in UVa Online Judge with the same the name 
Consider a grid of size n times n The rows are numbered top to bottom from 1 to n the columns are numbered left to right from 1 to n The robot is positioned in a cell 1 1 It can perform two types of moves move one cell down move one cell right The robot is not allowed to move outside the grid You are given a sequence of moves s the initial path of the robot This path doesn t lead the robot outside the grid You are allowed to perform an arbitrary number of modifications to it possibly zero With one modification you can duplicate one move in the sequence That is replace a single occurrence of with or a single occurrence of with Count the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn t move outside the grid ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (""avx2"")\n#pragma GCC optimization (""O3"")\n#pragma GCC optimization (""unroll-loops"")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    ll n; cin>>n;\n    string s; cin>>s;\n    int cntr = 0; int cntd = 0;\n    for (auto c: s)\n    {\n        if (c==\'D\') cntd++;\n        else cntr++;\n    }\n\n\n    int x = 1; int y = 1;\n\n    map<int, int> xmap, ymap;\n\n    xmap[1] = 1;\n    ymap[1] = 1;\n\n    for (auto c: s)\n    {\n        if (c==\'D\') y++;\n        else x++;\n        xmap[x] = y;\n        ymap[y] = x;\n    }\n\n    ll leftr = n-x;\n    ll leftd = n-y;\n\n\n    ll ans = 1 + (int)s.size();\n    for (auto it: xmap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftd);\n    }\n\n    for (auto it: ymap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftr);\n    }\n\n    if (x>1 && y>1) ans+=1ll*min(n-x, leftr)*min(n-y, leftd);\n    cout<<ans<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n/*\n1\n3\nD\n */']","[0, 1, 1, 0, 1, 1, 0, 0, 0, 0]",1900,First get rid of the corner cases If the string doesn t contain either of the letters the answer is The general solution to the problem is to consider every single way to modify the path then find the union of them Well every single path is too much let s learn to reduce the number of different sequences of modifications that we have to consider The main observation is that all cells that the robot can visit are enclosed in the space formed by the following two paths the first R is duplicated the maximum number of times then the last D is duplicated the maximum number of times the first D is duplicated the maximum number of times then the last R is duplicated the maximum number of times You can realize that by drawing the visited cells for some large test To show that more formally you can consider the visited cells row by row Let s show that for every two different visited cells in the same row all cells in between them can also be visited In general case we want to show that we can take the prefix of the path to the left one of these cells and duplicate any R on it to reach the right cell The suffixes of the paths will remain the same as in the initial path If there exists an R on the prefix then we are good Otherwise the reason that it doesn t exist is that we duplicated D too many times Reduce that and there will be R immediately after reaching the cell or earlier We should also show that the number of R s on the path to the left cell won t reach the maximum allowed amount until reaching the right cell Use the fact that the number of D s on both prefixes of the paths is the same The other non obvious part is that you can t reach cells outside this space However that can also be shown by analyzing each row independently Finally about the way to calculate the area of this space The main idea is to calculate the total number of cells outside this area and subtract it from Notice that non visited cells form two separate parts the one above the first path and the one to the left of the second path These are pretty similar to each other Moreover you can calculate them with a same function If we replace all D s in the string with R and vice versa then these parts swap places So we can calculate the upper part swap them and calculate it again I think the algorithm is best described with a picture Consider test for example First there are some rows that only have one cell visited Then the first R in the string appears Since we duplicate it the maximum amount of times it produces a long row of visited cells The remaining part of the part becomes the outline of the area Note that the row that marks the end of the string always ends at the last column Thus only at most first rows matter To be exact the amount of rows that matter is equal to the number of letters D in the string For each letter D let s calculate the number of non visited cells in a row it goes down to I found the most convenient way is to go over the string backwards We start from the row corresponding to the number of letters D in the string It has zero non visited cells We can maintain the number of non visited cells in the current row If we encounter an R in the string we add to this number If we encounter a D we add the number to the answer We have to stop after the first R in the string The later well earlier since we are going backwards part corresponds to the prefix of letters D the starting column on the picture Each of these rows have visited cell so non visited So we can easily calculate this part as well Overall complexity per testcase 
Your friend is developing a computer game He has already decided how the game world should look like it should consist of n locations connected by m passages The passages are designed in such a way that it should be possible to get from any location to any other location Of course some passages should be guarded by the monsters if you just can go everywhere without any difficulties then it s not fun right Some crucial passages will be guarded by really fearsome monsters requiring the hero to prepare for battle and designing his own tactics of defeating them commonly these kinds of monsters are called And your friend wants you to help him place these bosses The game will start in location s and end in location t but these locations are not chosen yet After choosing these locations your friend will place a boss in each passage such that it is impossible to get from s to t without using this passage Your friend wants to place as much bosses as possible because more challenges means more fun right so he asks you to help him determine the maximum possible number of bosses considering that any location can be chosen as s or as t ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 300300;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint m;\nint tim;\nint d[N];\nint tin[N];\nint fin[N];\nbool mo[N];\nbool used[N];\nvector < pair < int, int > > v[N];\n\nvoid dfs(int x, int p)\n{\n        used[x] = 1;\n        fin[x] = tin[x] = ++tim;\n        for(auto pp: v[x]){\n                int y = pp.fi, h = pp.se;\n                if(y == p){\n                        continue;\n                }\n                if(used[y]){\n                        fin[x] = min(fin[x], tin[y]);\n                }\n                else{\n                        dfs(y, x);\n                        fin[x] = min(fin[x], fin[y]);\n                        if(fin[y] > tin[x]){\n                                mo[h] = 1;\n                        }\n                }\n        }\n}\n\nint bfs(int x)\n{\n        for(int i = 1; i <= n; i++){\n                d[i] = 1e9;\n        }\n        queue < int > q;\n        d[x] = 0;\n        q.push(x);\n        while(!q.empty()){\n                x = q.front();\n                q.pop();\n                for(auto pp: v[x]){\n                        int y = pp.fi, h = pp.se;\n                        if(d[x] + mo[h] < d[y]){\n                                d[y] = d[x] + mo[h];\n                                q.push(y);\n                        }\n                }\n        }\n        x = 1;\n        for(int i = 1; i <= n; i++){\n                if(d[i] > d[x]){\n                        x = i;\n                }\n        }\n        return x;\n}\n\nvoid solve()\n{\n        cin >> n >> m;\n        for(int i = 1; i <= m; i++){\n                int x, y;\n                cin >> x >> y;\n                v[x].push_back({y, i});\n                v[y].push_back({x, i});\n        }\n        for(int i = 1; i <= n; i++){\n                if(!used[i]){\n                        dfs(i, -1);\n                }\n        }\n        cout << d[bfs(bfs(1))] << ""\\n"";\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2100,It s quite obvious that we can place bosses only on the bridges of the given graph if an edge is not a bridge then removing it doesn t make the graph disconnected so there still exists a path between any pair of vertices And if we fix two vertices and and then find some simple path between them then we will place the bosses on all bridges belonging to this path since the set of bridges would stay the same no matter which simple path between and we choose If we find bridges in the given graph and compress all 2 edge connected components two vertices belong to the same 2 edge connected component iff there exists a path between these vertices such that there are no bridges on this path into single vertices we will obtain a special tree called bridge tree Every edge of a bridge tree corresponds to a bridge in the original graph and vice versa Since we want to find the path with maximum possible number of bridges we only need to find the diameter of the bridge tree and this will be the answer to the problem 
Iahub is a big fan of tourists He wants to become a tourist himself so he planned a trip There are destinations on a straight road that Iahub wants to visit Iahub starts the excursion from kilometer 0 The destinations are described by a non negative integers sequence The number represents that the th destination is at distance kilometers from the starting point No two destinations are located in the same place Iahub wants to visit each destination only once Note that crossing through a destination is not considered visiting unless Iahub explicitly wants to visit it at that point Also after Iahub visits his last destination he doesn t come back to kilometer 0 as he stops his trip at the last destination The distance between destination located at kilometer and next destination located at kilometer is kilometers We call a route an order of visiting the destinations Iahub can visit destinations in any order he wants as long as he visits all destinations and he doesn t visit a destination more than once Iahub starts writing out on a paper all possible routes and for each of them he notes the total distance he would walk He s interested in the average number of kilometers he would walk by choosing a route As he got bored of writing out all the routes he asks you to help him ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n;\n  while (scanf(""%d"", &n) >= 1) {\n    vi as(n);\n    for (int i = 0; i < n; i++)\n      scanf(""%d"", &as[i]);\n    sort(as.begin(), as.end());\n\n    ll suml = 0, sumr = 0;\n    for (int i = 0; i < n; i++) sumr += as[i];\n\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n      sumr -= as[i];\n\n      ll sumLen = 0;\n      sumLen += sumr - ll(n - i - 1) * as[i];\n      sumLen += ll(i) * as[i] - suml;\n//      eprintf(""%I64d (%I64d %I64d)\\n"", sumLen, suml, sumr);\n      ans += sumLen;\n\n      suml += as[i];\n    }\n//    eprintf(""%I64d %I64d\\n"", ans, ansb);\n    for (int i = 0; i < n; i++)\n      ans += as[i];\n    ll ansb = n;\n    ll x = gcd(ans, ansb);\n    ans /= x;\n    ansb /= x;\n    printf(""%I64d %I64d\\n"", ans, ansb);\n  }\n  return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600,Despite this is a math task the only math formula we ll use is that number of permutations with n elements is n From this one we can deduce the whole task The average formula is sum of all routes number of routes As each route is a permutation with n elements number of routes is n Next suppose you have a permutation of a p1 p2 pn The sum for it will be p1 p2 p1 pn pn 1 The sum of routes will be the sum for each possible permutation We can calculate sum of all routes in two steps first time we calculate sums like p1 and then we calculate sums like p2 p1 pn pn 1 for every existing permutation First step Each element of a1 a2 an can appear on the first position on the routes and needs to be added as much as it appears Suppose I fixed an element X for the first position I can fill positions 2 3 n 1 in n 1 ways Why It is equivalent to permuting n 1 elements all elements except X So sum of all a1 n 1 a2 n 1 an n 1 n 1 a1 a2 an Second step For each permutation for each position j between 1 and n 1 we need to compute pj p j 1 Similarly to first step we observe that only elements from a can appear on consecutive positions We fix 2 indices i and j We re interested in how many permutations do ai appear before aj We fix k such as on a permutation p ai appears on position k and aj appears on a position k 1 In how many ways can we fix this n 1 ways 1 2 n 1 What s left A sequence of n 2 elements which can be permuted independently So the sum of second step is ai aj n 1 n 2 for each i j If I note a1 a2 an by S1 and ai aj for each i j by S2 the answer is N 1 S1 N 1 S2 N By a simplification the answer is S1 S2 N The only problem remained is how to calculate S2 Simple iteration won t enter in time limit Let s think different For each element I need to make sum of differences between it and all smaller elements in the array a As well I need to make sum of all different between bigger elements than it and it I ll focus on the first part I sort increasing array a Suppose I m at position i I know that i 1 elements are smaller than ai The difference is simply i 1 ai sum of elements before position i Sum of elements before position i can be computed when iterating i Let s call the obtained sum Sleft I need to calculate now sum of all differences between an element and bigger elements than it This sum is equal to Sleft As a proof for an element ai calculating the difference aj ai when aj ai is equivalent to calculating differences between aj and a smaller element of it in this case ai That s why Sleft Sright As a conclusion the answer is S1 2 Sleft N For make fraction irreducible you can use Euclid s algorithm The complexity of the presented algorithm is O N logN necessary due of sorting Sorting can be implemented by count sort as well having a complexity of O maximalValue but this is not necessary 
You are given a tree with n nodes In the beginning 0 is written on all edges In one operation you can choose any 2 distinct u v and any number x and add x to values written on all edges on the simple path between u and v For example on the picture below you can see the result of applying two operations to the graph adding 2 on the path from 7 to 6 and then adding 1 on the path from 4 to 5 You are given some configuration of numbers written on the edges For a given configuration determine if it is possible to achieve it with these operations and if it is possible output the sequence of operations that leads to the given configuration Constraints on the operations are listed in the output format section Leave is a node of a tree of degree 1 Simple path is a path that doesn t contain any node twice ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1100;\nint n;\nvector<int> g[N];\nint ed[N][3];\nint ans[10 * N][3];\nint ansSz;\n\nvoid addAns(int v, int u, int x) {\n\tans[ansSz][0] = v + 1;\n\tans[ansSz][1] = u + 1;\n\tans[ansSz][2] = x;\n\tansSz++;\n}\n\nint getLeaf(int v, int par, int u) {\n\tif (v == u) return -1;\n\tif ((int)g[v].size() == 1) return v;\n\tint res = -2;\n\tfor (int w : g[v]) {\n\t\tif (w == par) continue;\n\t\tint z = getLeaf(w, v, u);\n\t\tif (z == -1) return -1;\n\t\tres = z;\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, w;\n\t\tscanf(""%d%d%d"", &v, &u, &w);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\ted[i][2] = w;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tif ((int)g[v].size() == 2) {\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint v = ed[i][0], u = ed[i][1], x = ed[i][2] / 2;\n\t\tvector<int> vv, uu;\n\t\tif ((int)g[v].size() == 1) {\n\t\t\tvv.push_back(v);\n\t\t} else {\n\t\t\tfor (int w : g[v]) {\n\t\t\t\tint z = getLeaf(w, v, u);\n\t\t\t\tif (z != -1)\n\t\t\t\t\tvv.push_back(z);\n\t\t\t\tif ((int)vv.size() == 2) break;\n\t\t\t}\n\t\t}\n\t\tif ((int)g[u].size() == 1) {\n\t\t\tuu.push_back(u);\n\t\t} else {\n\t\t\tfor (int w : g[u]) {\n\t\t\t\tint z = getLeaf(w, u, v);\n\t\t\t\tif (z != -1)\n\t\t\t\t\tuu.push_back(z);\n\t\t\t\tif ((int)uu.size() == 2) break;\n\t\t\t}\n\t\t}\n\t\tif ((int)uu.size() == 1) swap(vv, uu);\n\t\tif ((int)uu.size() == 1) {\n\t\t\taddAns(vv[0], uu[0], 2 * x);\n\t\t} else if ((int)vv.size() == 1) {\n\t\t\taddAns(vv[0], uu[0], x);\n\t\t\taddAns(vv[0], uu[1], x);\n\t\t\taddAns(uu[0], uu[1], -x);\n\t\t} else {\n\t\t\taddAns(vv[0], uu[0], x);\n\t\t\taddAns(vv[1], uu[1], x);\n\t\t\taddAns(vv[0], vv[1], -x);\n\t\t\taddAns(uu[0], uu[1], -x);\n\t\t}\n\t}\n\n\tprintf(""YES\\n"");\n\tprintf(""%d\\n"", ansSz);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(""%d %d %d\\n"", ans[i][0], ans[i][1], ans[i][2]);\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",2500,We claim that the answer is YES iff there is no vertex with degree 2 After this it s easy to get a solution for first subtask in O n Because all numbers are different in the second subtask if we have a vertex with degree 2 then answer is NO If there is no such then construction also follows from proof Indeed if we can add on any path to leaf then we can add on one edge So consider any edge uv and suppose we want to add x on this edge Let s find any leaf in a subtree of vertex u which doesn t contain v let s name it l If l u just add x on path uv Else add x on path vl and x on path ul It s clear that after this two operations we ve added x on edge uv and didn t add anything on other edges Then just add on each edge needed number In the end let s talk about implementation To add on the path to leaf it s sufficient to find a leaf in the subtree We can do it naively in O n then complexity is O n2 Also we can precalculate leaves in each subtree and for example root tree at some leaf Then it s possible to do all operations in O 1 and complexity is O n but it wasn t needed 
Let s denote we will denote it as CME an equation a b c there all integers a b and c are greater than zero For example equations 2 2 4 and 1 2 3 are CME but equations 1 2 4 2 2 3 and 0 1 1 are not Now you have n matches You want to assemble a CME using your matches Unfortunately it is possible that you can t assemble the CME using all matches But you can buy some extra matches and then assemble CME For example if n 2 you can buy two matches and assemble and if n 5 you can buy one match and assemble Calculate the minimum number of matches which you have to buy for assembling CME Note that you have to answer q independent queries ,"['// Code by H~$~C\n//#pragma comment(linker, ""/STACK:1024000000,1024000000"")\n//#pragma GCC optimize(""Ofast"", ""unroll-loops"")\n//#pragma target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#define rint register int\n#define rep(i, n) for (rint i = 0; i < (n); ++i)\n#define rep1(i, n) for (rint i = (1); i <= (n); ++i)\n#define Rep(i, a, b) for (rint i = (a); i <= (b); ++i)\n#define per(i, n) for (rint i = ((n) - 1); ~i; --i)\n#define per1(i, n) for (rint i = (n); i; --i)\n#define Per(i, a, b) for (rint i = (a); i >= (b); --i)\n#define repit(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define eprintf(...) (fprintf(stderr, __VA_ARGS__) & fflush(stderr))\n#define fillset(a, val) memset(a, val, sizeof(a))\n#define All(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n#define fi first\n#define se second\n#define pb push_back\n#define y0 y19260817\n#define y1 y19268107\n#define j0 j19260817\n#define j1 j19268107\n#define x0 x19260817\n#define x1 x19268107\nusing namespace std;\n#ifndef LOCAL_JUDGE\n#define Debug(...)\n#else\ntemplate <typename T> inline void _debug(const char *names, T &&t) {\n(cerr << names << "" = "" << t << endl).flush();}\ntemplate <typename T1, typename ...T>\ninline void _debug(const char *names, T1 &&t1, T &&... t) {\nconst char *comma = strchr(names, \',\');\n(cerr.write(names, comma - names) << "" = "" << t1 << "", "").flush();\n_debug(comma + 1, t ...);}\n#define Debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)\n#endif\nstruct __STARTER_OF_PROGRAM__ { __STARTER_OF_PROGRAM__() {\n#ifndef ONLINE_JUDGE\n  cerr << ""Code by H~$~C: \\n"" << flush;\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr), cout.tie(nullptr);\n  cout << fixed << setprecision(12);\n} } __starter_of_program__;\n#ifdef LOCAL_JUDGE\nstruct __ENDDER_OF_PROGRAM__ { ~__ENDDER_OF_PROGRAM__() {\n  cerr << ""\\n\\nTime elasped: "" << clock() * 1000.0 / CLOCKS_PER_SEC << "" ms\\n"" << flush;\n} } __endder_of_program__;\n#endif\nusing ll = long long; using ull = unsigned long long; using uint = unsigned int;\nusing ld = long double; using pii = pair<int, int>; using pll = pair<ll, ll>;\nusing pli = pair<ll, int>; using pil = pair<int, ll>;\ntemplate <typename T> using min_queue = priority_queue<T, vector <T>, greater <T> >;\ntemplate <typename T> using max_queue = priority_queue<T>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\nstatic uniform_int_distribution<int> __disint__;\ninline int randint(void) { return __disint__(gen); }\ninline int randint(int l, int r) { return __disint__(gen) % (r - l + 1) + l; }\ntemplate <typename T> inline void reinit(T &t) { t.~T(); new (&t) T(); }\ntemplate <typename T> inline T chmax(T &x, T y) { return x = max(x, y); }\ntemplate <typename T> inline T chmin(T &x, T y) { return x = min(x, y); }\ntemplate <typename T> inline T chmax(T &x, initializer_list <T> i) { return x = max(x, max(i)); }\ntemplate <typename T> inline T chmin(T &x, initializer_list <T> i) { return x = min(x, min(i)); }\ninline void read() { } inline void write() { }\ntemplate <typename T> inline void read(T &x) { cin >> x; }\ntemplate <typename T> inline void write(const T &x) { cout << x; }\ntemplate <typename T, typename U>\ninline void write(const pair<T, U> &x) { write(x.first), cout.put(\' \'), write(x.second);}\ntemplate <typename T, typename U>\ninline void read(pair<T, U> &x) { read(x.first), read(x.second);}\ntemplate <typename T, typename ...Ts> inline void read(T &x, Ts &...y) { read(x), read(y...); }\ntemplate <typename T, typename ...Ts> inline void write(const T &x, const Ts &...y) {\nwrite(x), (sizeof...(y) && (cout.put(\' \'), 0)), write(y...); }\n#define writeln(...) (write(__VA_ARGS__), cout.put(\'\\n\'), 0)\ntemplate <typename It> inline void _write(It a, It b) {\nregister char flag = 0; while (a != b) { flag && (cout.put(\' \'), 0); write(*a ++), flag = 1; } }\n#define _writeln(...) (_write(__VA_ARGS__), cout.put(\'\\n\'), 0)\nconst int mod1 = 1000000007, mod2 = 998244353, mod3 = 1000000009;\nconst double EPS = 1e-9, PI = acos(-1.0), _E_ = exp(1.0);\nconst int inf = 0x3f3f3f3f;\nconst ll lnf = 0x3f3f3f3f3f3f3f3f;\n\nsigned main(int argc, const char *argv[]) {\n  int tests;\n  read(tests);\n  while (tests--) {\n    int n;\n    read(n);\n    if (n == 1) writeln(3);\n    else if (n == 2) writeln(2);\n    else if (n == 3) writeln(1);\n    else if (n == 4) writeln(0);\n    else writeln(n % 2);\n  }\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,If n is odd then we have to buy at least one match because integers a b and c a b and c is elements of equation a b c must be of the same parity so integer a b c is always even If n is even then we can assemble an equation 1 n 22 n2 But there is one corner case If n 2 then we have to buy two matches because all integers a b and c must be greater than zero In this way the answer is equal 2 if n 2 1 if n is odd 0 if n is even and greater than 2 
Given an array a of length n and an integer k find the number of indices 1 leq i leq n k such that the subarray a i dots a i k with length k 1 with length k has the following property If you multiply the first element by 2 0 the second element by 2 1 and the k 1 st element by 2 k then this subarray is sorted in strictly increasing order More formally count the number of indices 1 leq i leq n k such that 2 0 cdot a i 2 1 cdot a i 1 2 2 cdot a i 2 dots 2 k cdot a i k ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""G""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        cin >> a;\n        vector<int> ok(n);\n        for(int i = 1; i < n; ++i)\n            ok[i] = (a[i] * 2 > a[i - 1]);\n        vector<int> pref(n + 1, 0);\n        for(int i = 0; i < n; ++i)\n            pref[i + 1] = pref[i] + ok[i];\n        int ans = 0;\n        for(int i = 0; i + k <= n; ++i)\n            ans += (pref[i + k] - pref[i] == k);\n        cout << ans << endl;\n    }\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 1, 0]",1400,Note that is the same as since we can divide by This means that we only need to check whether for each pair of adjacent elements Let s consider as an example Note that and so if you multiply the first element by the second by and the third by the array is sorted So let s make a new array where if and otherwise Then we know that the whole chain of inequalities holds true if all values in a subarray of length in have all their values equal to For example if Say Then works since is sorted We can write this as and This is equivalent to since and since So the problem is equivalent to counting the number of subarrays of length in whose elements are all equal to There are many ways to do this For example you can compute prefix sums and then find the sum of all subarrays of length and count the number whose sum is The model solution uses a sliding window and updates the number of ones in the current subarray as we move from left to right Time complexity is 
Polycarp has a problem his laptop keyboard is broken Now when he presses the key it acts like an unusual backspace it deletes the last rightmost lowercase letter in the typed string If there are no lowercase letters in the typed string then the press is completely ignored Similarly when he presses the key it deletes the last rightmost uppercase letter in the typed string If there are no uppercase letters in the typed string then the press is completely ignored In both cases the letters and are not added to the typed string when these keys are pressed Consider an example where the sequence of key presses was In this case the typed string will change as follows xrightarrow texttt A xrightarrow texttt R xrightarrow texttt a xrightarrow texttt B xrightarrow texttt b xrightarrow texttt b xrightarrow texttt i xrightarrow texttt t xrightarrow texttt B xrightarrow texttt a xrightarrow texttt b xrightarrow texttt y Given a sequence of pressed keys output the typed string after processing all key presses ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<array>\n#include<set>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tstring x;\n\t\tcin >> x;\n\t\tvector<int>p0, p1;\n\t\tvector<bool>del(x.size(), 0);\n\t\tfor (int i = 0; i ^ x.size(); ++i) {\n\t\t\tchar c = x[i];\n\t\t\tif (c == 'b') {\n\t\t\t\tdel[i] = 1;\n\t\t\t\tif (p0.size())\n\t\t\t\t\tdel[p0.back()] = 1, p0.pop_back();\n\t\t\t}\n\t\t\telse if (c == 'B') {\n\t\t\t\tdel[i] = 1;\n\t\t\t\tif (p1.size())\n\t\t\t\t\tdel[p1.back()] = 1, p1.pop_back();\n\t\t\t}\n\t\t\telse if (c >= 'a' && c <= 'z')\n\t\t\t\tp0.emplace_back(i);\n\t\t\telse\n\t\t\t\tp1.emplace_back(i);\n\t\t}\n\t\tfor (int i = 0; i ^ x.size(); ++i) {\n\t\t\tif (del[i])\n\t\t\t\tcontinue;\n\t\t\tcout << x[i];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0]",1000,To solve the problem it was necessary to quickly support deletions For this one could maintain two stacks one with the positions of uppercase letters and one with the positions of lowercase letters Then when deleting one needs to somehow mark that the character at this position should not be output Alternatively one could reverse the original string then instead of deleting characters they would simply need to be skipped 
You are given a tree with n nodes rooted at node 1 In this problem a leaf is a non root node with degree 1 In one operation you can remove a leaf and the edge adjacent to it possibly new leaves appear What is the minimum number of operations that you have to perform to get a tree also rooted at node 1 where all the leaves are at the same distance from the root ,"['#include <bits/stdc++.h>\xa0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\xa0void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        std::vector<int> dep(n), mx(n);    std::vector<int> f(n);    auto dfs = [&](auto &self, int x, int p) -> void {        mx[x] = dep[x];        for (auto y : adj[x]) {            if (y == p) {                continue;            }            dep[y] = dep[x] + 1;            self(self, y, x);            mx[x] = std::max(mx[x], mx[y]);        }        f[0]++;        f[dep[x]]--;        if (mx[x] + 1 < n) {            f[mx[x] + 1]++;        }    };    dfs(dfs, 0, -1);        for (int i = 1; i < n; i++) {        f[i] += f[i - 1];    }    int ans = *std::min_element(f.begin(), f.end());    std::cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']","[1, 0, 0, 0, 0, 1, 0, 0, 1, 0]",1700,Solution If the final depth of the leaves is it s optimal to keep in the tree all the nodes at depth and all their ancestors These nodes are the only ones which satisfy the following two conditions their depth is the maximum depth of a node in their subtree is So every node is alive in the interval of depths The optimal is the one contained in the maximum number of intervals 
Inflation has occurred in Berlandia so the store needs to change the price of goods The current price of good n is given It is allowed to increase the price of the good by k times with 1 le k le m k is an integer Output the roundest possible new price of the good That is the one that has the maximum number of zeros at the end For example the number is more round than the number three zeros at the end of and only one at the end of If there are several possible variants output the one in which the new price is maximal If it is impossible to get a rounder price output n cdot m that is the maximum possible price ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nint cnt(ll x) {\n    int c = 0;\n    while(x % 10 == 0) {\n        x /= 10, ++c;\n    }\n    return c;\n}\n\nvoid solve(){\n    ll n, m;\n    cin >> n >> m;\n    ll sN = n;\n    int c1 = 0, c2 = 0;\n    while(n % 2 == 0) {\n        n /= 2;\n        c1++;\n    }\n    while(n % 5 == 0) {\n        n /= 5;\n        c2++;\n    }\n\n    ll d = 1;\n    while(c1 < c2 and d * 2 <= m) d *= 2, c1++;\n    while(c2 < c1 and d * 5 <= m) d *= 5, c2++;\n    while(d * 10 <= m) d *= 10;\n    ll h = m / d;\n    d *= h;\n    cout << d * sN << endl;\n\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1400,The answer is First count two numbers which denote the degree of occurrence of and in the number respectively that is Where is not divisible by either or Now while we will increase the corresponding value For example if then as long as and at that we will increase by and multiply by times That way we can get the most round number possible by spending the least possible Now we either have or or Then in the first case we will multiply the number by as long as we can That is until Now in either case we have Then Then we multiply by times and get our desired answer In the last step we can no longer get a rounder number but just find the maximal possible number 
You are given three strings a b and c consisting of lowercase Latin letters The string c was obtained in the following way At each step either string a or string b was randomly chosen and the first character of the chosen string was removed from it and appended to the end of string c until one of the strings ran out After that the remaining characters of the non empty string were added to the end of c Then a certain number of characters in string c were randomly changed For example from the strings a color red text abra and b color blue text cada without character replacements the strings color blue text ca color red text ab color blue text d color red text ra color blue text a color red text abra color blue text cada color red text a color blue text cada color red text bra could be obtained Find the minimum number of characters that could have been changed in string c ,"['#include <bits/stdc++.h>using namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(0);    int t;    cin >> t;    while(t--){        string a, b, c;        cin >> a >> b >> c;        int n = a.size();        int m = b.size();        const int INF = 1e9;        vector<vector<int>> dp(n+1, vector<int>(m+1, INF));        dp[0][0] = 0;        for(int i=0; i<=n; i++){            for(int j=0; j<=m; j++){                if(i < n){                    int pos = i + j;                    if(pos < c.size()){                        int cost = dp[i][j] + (a[i] != c[pos] ? 1 : 0);                        if(cost < dp[i+1][j]){                            dp[i+1][j] = cost;                        }                    }                }                if(j < m){                    int pos = i + j;                    if(pos < c.size()){                        int cost = dp[i][j] + (b[j] != c[pos] ? 1 : 0);                        if(cost < dp[i][j+1]){                            dp[i][j+1] = cost;                        }                    }                }            }        }        cout << dp[n][m] << ""\\n"";    }}']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0]",1500,Let s use the idea of dynamic programming Let be the answer to the problem when considering string as its own prefix of length string as its own prefix of length and string as its own prefix of length Then the dynamic programming recurrence is easy we need to iterate over where we took the next th character of string If the character is taken from string the answer is if otherwise since we need to replace character with If it is taken from string the answer is calculated similarly if otherwise Thus to obtain the minimum value of the current dynamic programming state we need to take the minimum of the two obtained values To get the answer we need to take the value of the dynamic programming table at where is the length of string and is the length of string The final time complexity of the solution is per test case 
You are given two arrays of integers and For each element of the second array you should find the number of elements in array that are less than or equal to the value ,"['/*\nMass inclination will fuel my frustration\nAnd keep all redemption at bay\nAll indications prove your all mutations\nAnd you all have nothing to say\n\nHate\nDown on me\nBreak\nDown on me\nSlave\nDown on me\nPlague\nDown on me\n\nI can\'t believe everything you believe perceive\nIs rightfully coming your way\n\nTake me back to where I need to go (Inside me)\nShow me how to question all I know (Excite me)\nYou\'ll come around (And reveal yourself)\nYou come down (In this best education)\nI\'ll fall down (As we kill ourselves)\nWhen it all goes down (Are you ready to suffer it all?)\n\nMy aggravation is manifestation\nOf all of the shit that you say\nThis complication will lead to this damnation\nOf all those who stand in my way\n\nHate\nDown on me\nBreak\nDown on me\nSlave\nDown on me\nPlague\nDown on me\n\nI can\'t believe everything you believe perceive\nIs rightfully coming your way\n\nTake me back to where I need to go (Inside me)\nShow me how to question all I know (Excite me)\nYou\'ll come around (And reveal yourself)\nYou come down (In this best education)\nI\'ll fall down (As we kill ourselves)\nWhen it all goes down (Are you ready to suffer it all?)\n\nTake me back to where I need to go (Inside me)\nShow me how to question all I know (Excite me)\nYou\'ll come around (And reveal yourself)\nYou come down (In this best education)\nI\'ll fall down (As we kill ourselves)\nWhen it all goes down (Are you ready to suffer it all?)\n\nI\'ll be ready to suffer it all\nI\'ll be ready to suffer it all\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 200005;\n\nusing namespace std;\n\nint ar[N];\nint n,m;\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin>>n>>m;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tcin>>ar[i];\n\t}\n\tsort(ar,ar+n);\n\t\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tint val;\n\t\tcin>>val;\n\t\tint cnt=lower_bound(ar,ar+n,val+1)-ar;\n\t\tif (i)\n\t\t\tcout<<"" "";\n\t\tcout<<cnt;\n\t}\n\tcout<<endl;\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 1, 1, 0]",1300,Let s sort all numbers in a Now let s iterate over elements of and for element find the index of lowest number that is greater than We can do that using binary search That index will be the answer for value Complexity 
Vasya has recently learned to type and log on to the Internet He immediately entered a chat room and decided to say hello to everybody Vasya typed the word It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word For example if Vasya types the word it will be considered that he said hello and if he types it will be considered that Vasya got misunderstood and he didn t manage to say hello Determine whether Vasya managed to say hello by the given word ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define MM(a , x) memset(a , x , sizeof(a))\n#define sqr(x) ((x) * (x))\n#define abs(x) ((x > 0) ? (x) : -(x))\n#define REP(i , n) for ((i) = 0; (i) < (n); ++(i))\n#define FOR(i , a , b) for ((i) = (a); (i) <= (b); ++(i))\n#define FORD(i , a , b) for ((i) = (a); (i) >= (b); --(i))\ntypedef long long LL;\n\nstring st , pat;\n\nint main()\n{\n\tcin >> st;\n\tpat += ""hello"";\n\tint i , j , k;\n\tj = 0;\n\tREP (i , st.length())\n\t{\n\t\tif (st[i] == pat[j]) j++;\n\t\tif (j == 5) break;\n\t}\n\tif (j == 5) printf(""YES\\n""); else printf(""NO\\n"");\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000,Solution is greedy algorithm The first thing we do is find in our string the first letter h Then we find letter e which is righter that found h If we find the whole word hello in such way obliviously answer is YES Now let s prove that if answer exists we find it Let see on position of the h in right answer If we move it to the first h in our string nothing changes But now we can say that our greedy algorithm correctly Now let s do such with the second letter and so on We have greedy algorithm with work time O n where n length of the input 
Masha and Grisha like studying sets of positive integers One day Grisha has written a set containing different integers on a blackboard Now he asks Masha to create a set containing different integers such that all integers that can be obtained by summing up and for all possible pairs of and are different Both Masha and Grisha don t like big numbers so all numbers in are from to and all numbers in must also be in the same range Help Masha to create the set that satisfies Grisha s requirement ,"['#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME ""a""\n\nconst int MAX = 1e6;\n\nint n;\nvi a;\n\nbool read() {\n\tif  (scanf(""%d"", &n) < 1) {\n\t\treturn 0;\n\t}\n\ta.resize(n);\n\tforn(i, n) {\n\t\tscanf(""%d"", &a[i]);\n\t}\n\treturn 1;\n}\n\nbool bad[MAX];\n\nbool solve() {\n\tsort(all(a));\n\tconst int mx = a.back();\n\n\tmemset (bad, 0, sizeof(bool) * mx);\n\tforn(i, n) {\n\t\tforn(j, i) {\n\t\t\tbad[abs(a[i] - a[j])] = 1;\n\t\t}\n\t}\n\n\tvi b(n);\n\tint ptr = 0;\n\tfor (int x = 1; x <= MAX && ptr < n; ++x) {\n\t\tbool good = 1;\n\t\tforn(i, ptr) {\n\t\t\tconst int diff = x - b[i];\n\t\t\tif  (diff < mx && bad[diff]) {\n\t\t\t\tgood = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif  (good) {\n\t\t\tb[ptr++] = x;\n\t\t}\n\t}\n\n\tif  (ptr < n) {\n\t\treturn 0;\n\t}\n\n\tputs(""YES"");\n\tforn(i, n) {\n\t\tprintf(""%d "", b[i]);\n\t}\n\tputs("""");\n\treturn 1;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME "".in"", ""r"", stdin);\n\t// freopen(FILE_NAME "".out"", ""w"", stdout);\n#endif\n\n\tint T;\n\tscanf(""%d"", &T);\n\tforn(t, T) {\n\t\tassert(read());\n\n\t\tif  (!solve()) {\n\t\t\tputs(""NO"");\n\t\t}\n\t}\n\n#ifdef LOCAL\n\tcerr.precision(5);\n\tcerr << ""Time: "" << fixed << (double) clock() / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n\n']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 0]",1600,First let us prove that the answer is always YES Let us iterate over bj and check if summing it up with all ai values don t result in values that we already have If no conflict is found add the corresponding bj to B Let us give some estimate for the maximum element of B The reason that we cannot include bj2 to B is the equality ai1 bj1 ai2 bj2 so bj2 bj1 ai2 ai1 Each element of B forbids O n2 values so max B is O n3 That means that the answer always exists for the given constraints Now let us speed up the test that we can add a number to B Let us use an array bad that marks the numbers that we are not able to include to B When trying the value bj we can add it to B if it is not marked in bad Now the numbers that are equal to bj ai1 ai2 are forbidden let us mark them in bad The complexity is O n3 for each test case 
Not so long ago Vlad had a birthday for which he was presented with a package of candies There were n types of candies there are a i candies of the type i 1 le i le n Vlad decided to eat exactly one candy every time choosing any of the candies of a type that is currently the most frequent if there are several such types he can choose of them To get the maximum pleasure from eating Vlad to eat two candies of the same type in a row Help him figure out if he can eat all the candies without eating two identical candies in a row ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i];\n  }\n  A.pb(0);\n  sort(all(A));\n  if (A[n] - A[n - 1] > 1) {\n    cout << ""NO\\n"";\n  } else {\n    cout << ""YES\\n"";\n  }\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,There will be three cases in total let s consider them on two types of candies then we will eat candies in this order then we will eat a candy of the type and then we will eat in this order almost as in the case above then we will eat a candy of the type but there will still be more of them than candies of the type and we will have to eat a candy of the type again So the answer is Now we prove that it is enough to check these conditions on two maximums of the array If the third condition is true the answer is obvious Otherwise we will by turns eat candies of the two maximum types until their number is equal to the third maximum after which we will by turns eat candies of these three types and so on 
In ancient Persia Khayyam a clever merchant and mathematician is playing a game with his prized treasure chest containing n red rubies worth 2 dinars each and m blue sapphires worth 1 dinar each He also has a satchel which starts empty and k scrolls with pairs r 1 b 1 r 2 b 2 ldots r k b k that describe special conditions The game proceeds for n m turns as follows Khayyam draws a gem uniformly at random from the chest He removes the gem from the chest and places it in his satchel If there exists a scroll i 1 leq i leq k such that the chest contains exactly r i red rubies and b i blue sapphires Khayyam receives a royal decree that doubles the value of all the gems in his satchel as a reward for achieving a special configuration Note that the value of some gems might be affected by multiple decrees and in that case the gems value is doubled multiple times Determine the expected value of Khayyam s satchel at the end of the game modulo 998 244 353 Formally let M 998 244 353 It can be shown that the exact answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"[""#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n, m, k;pair<int,int>pr[N];int r[N], b[N];mint ans;mint dp[N];void Main() {\tcin >> n >> m >> k;\tL(i, 1, k) {\t\tcin >> pr[i].first >> pr[i].second;\t\tpr[i].first = n - pr[i].first;\t\tpr[i].second = m - pr[i].second;\t}\tsort(pr + 1, pr + k + 1);\tans = n * 2 + m;\tL(i, 1, k) {\t\tr[i] = pr[i].first;\t\tb[i] = pr[i].second;\t}\tL(i, 0, k) dp[i] = 0;\tL(i, 1, k) {\t\tdp[i] = C(r[i] + b[i], b[i]) * (r[i] * 2 + b[i]);\t\tL(j, 1, i - 1) {\t\t\tdp[i] += dp[j] * C(r[i] - r[j] + b[i] - b[j], b[i] - b[j]);\t\t}\t\t// cout << dp[i].x << endl;\t\tans += dp[i] * C(n - r[i] + m - b[i], m - b[i]) * qpow(C(n + m, n));\t}\tcout << ans.x << '\\n';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tinit(1e6);\tint t; cin >> t; while(t--) Main();\treturn 0;}""]","[0, 1, 0, 1, 0, 0, 0, 0, 1, 0]",2500,Step 1 For simplicity redefine the special conditions for the number of rubies and sapphires in your satchel not chest Add two dummy states and for convenience the first one indexed as and the second one indexed as Note that these dummy states won t involve doubling the value Step 2 Order the redefined conditions in increasing order based on the value of Step 3 Define as the number of ways to move from state to state without passing through any other special condition This can be computed using inclusion exclusion in Step 4 Define the increase in value for moving directly from state to state without intermediate doubling as Step 5 Define as the total sum of the value of your satchel across all ways to reach the state defined by the th condition This can be computed recursively as Step 6 Compute the final answer as the value of divided by the total number of ways to move from to which is 
You are given a string consisting of small english letters In one move you can replace any character of this string to the next character in alphabetical order will be replaced with will be replaced with etc You cannot replace letter with any other letter Your target is to make some number of moves not necessary minimal to get string english alphabet as a subsequence Subsequence of the string is the string that is obtained by deleting characters at some positions You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible ,"['// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored ""-Wunused-result""\n#pragma GCC diagnostic ignored ""-Wunused-function""\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(""%d"", &x); }\nvoid _R(int64_t &x) { scanf(""%"" SCNd64, &x); }\nvoid _R(double &x) { scanf(""%lf"", &x); }\nvoid _R(char &x) { scanf("" %c"", &x); }\nvoid _R(char *x) { scanf(""%s"", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(""%d"", x); }\nvoid _W(const int64_t &x) { printf(""%"" PRId64, x); }\nvoid _W(const double &x) { printf(""%.16f"", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(""%s"", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(\' \'); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? \' \' : \'\\n\'); W(tail...); }\n\n#ifdef SHIK\n#include ""dump.hpp""\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=1e5+10;\nchar s[N];\nvoid main() {\n    R(s);\n    int n=strlen(s);\n    char c=\'a\';\n    REP(i,n) {\n        if ( c>\'z\' || s[i]>c ) continue;\n        s[i]=c++;\n    }\n    if ( c>\'z\' ) W(s);\n    else W(-1);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300,The problem can be solved by the next greedy algorithm At first we need to store the last character of the alphabet we haven t obtained for example in variable initially it will be equal to Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than we just replace it to and increase by 1 If in any moment will be greater than we got the answer And if after iterating over the string will be not greater than the answer is 1 
You are given a bipartite graph with n 1 vertices in the first part n 2 vertices in the second part and m edges The maximum matching in this graph is the maximum possible by size subset of edges of this graph such that no vertex is incident to more than one chosen edge You have to process two types of queries to this graph 1 remove the number of vertices from this graph so that the size of the maximum matching gets reduced and print the vertices that you have removed Then find any maximum matching in this graph and print the sum of indices of edges belonging to this matching 2 query of this type will be asked only after a query of type 1 As the answer to this query you have to print the edges forming the maximum matching you have chosen in the previous query Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Flow {\n    const int n;\n    struct Edge {\n        int to;\n        T cap;\n        Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    \n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    \n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T maxFlow(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int nx, ny, m, q;\n    std::cin >> nx >> ny >> m >> q;\n    const int N = nx + ny;\n    \n    Flow<int> flow(nx + ny + 2);\n    const int S = nx + ny, T = S + 1;\n    std::vector<int> x(m), y(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> x[i] >> y[i];\n        x[i]--, y[i]--;\n        flow.addEdge(x[i], nx + y[i], 2);\n    }\n    for (int i = 0; i < nx; i++) {\n        flow.addEdge(S, i, 1);\n    }\n    for (int i = 0; i < ny; i++) {\n        flow.addEdge(nx + i, T, 1);\n    }\n    \n    int M = flow.maxFlow(S, T);\n    i64 sum = 0;\n    std::vector<int> e(N, -1);\n    for (int i = 0; i < m; i++) {\n        if (flow.e[2 * i].cap == 1) {\n            e[x[i]] = e[y[i] + nx] = i;\n            sum += i + 1;\n        }\n    }\n    \n    std::vector<int> cut(N);\n    std::vector<int> seq;\n    for (int i = 0; i < N; i++) {\n        cut[i] = (flow.h[i] == -1);\n        if ((i < nx && cut[i]) || (i >= nx && !cut[i])) {\n            seq.push_back(i);\n        }\n    }\n    \n    while (q--) {\n        int o;\n        std::cin >> o;\n        \n        if (o == 1) {\n            int u = seq.back();\n            seq.pop_back();\n            \n            std::cout << 1 << ""\\n"";\n            if (u < nx) {\n                std::cout << u + 1 << ""\\n"";\n            } else {\n                std::cout << -(u - nx + 1) << ""\\n"";\n            }\n            int j = e[u];\n            sum -= j + 1;\n            e[x[j]] = e[y[j] + nx] = -1;\n            std::cout << sum << std::endl;\n            M--;\n        } else {\n            std::cout << M << ""\\n"";\n            for (int i = 0; i < nx; i++) {\n                if (e[i] != -1) {\n                    std::cout << e[i] + 1 << "" "";\n                }\n            }\n            std::cout << std::endl;\n        }\n    }\n    \n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 1]",2800,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it 
One day Petya was solving a very interesting problem But although he used many optimization techniques his solution still got Time limit exceeded verdict Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of positive integers was too slow Desperate Petya decided to use a somewhat unexpected optimization using parameter so now his function contains the following code int fast max int n int a int ans 0 int offset 0 for int i 0 i n i if ans a i ans a i offset 0 else offset offset 1 if offset k return ans return ans That way the function iteratively checks array elements storing the intermediate maximum and if after consecutive iterations that maximum has not changed it is returned as the answer Now Petya is interested in fault rate of his function He asked you to find the number of permutations of integers from to such that the return value of his function on those permutations is not equal to Since this number could be very big output the answer modulo ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\n\nll rev(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = rev(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll f[MAXN];\nll fct[MAXN];\nll rfct[MAXN];\n\nll cnk(int x, int y) {\n    return fct[x + y] * rfct[x] % MOD * rfct[y] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    rfct[n] = rev(fct[n]);\n    for (int i = n; i > 0; --i) {\n        rfct[i - 1] = (rfct[i] * i) % MOD;\n    }\n    \n    ll mulall = 1;\n    ll ans = fct[n - 1];\n\n\n    ll sum = 0;\n    f[0] = 1;\n    sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        sum = (sum + f[i - 1]) % MOD;\n        ll cf = sum * mulall % MOD;\n        ans += cf * fct[n - 1] % MOD * rfct[i] % MOD;\n        ans %= MOD;\n        mulall = (mulall * i) % MOD;\n        f[i] = (rev(mulall) * cf) % MOD;\n        if (i >= k) {\n            sum = (sum - f[i - k] + MOD) % MOD;\n        }\n    }\n\n    cout << (fct[n] - ans + MOD) % MOD;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2400,You asked to find the number of permutations p of length n such that exists index i such that pi n pi is greater than any pj for j in 1 i 1 and greater then any pj for j in i 1 i k We will call such permutations good Define D n as number of good permutations that have pn n Notice that if k n then D n 0 Let w be a permutations such that wn n If index of element n 1 is lesser than n k then w is good Otherwise if n 1 index is j j n k then because there are less then k elements between n 1 and n w could be good only if i from the definition would be lesser than j In that case permutation w1 wj would form a good permutation of length j of some numbers with wj being the maximum Therefore the following equation is correct Which can be computed in O n2 or in O n rewritten in the form and using prefix sums for values The answer is than calculated as follows Complexity O n 
On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length k k ge 3 Nastya was very confused by this present so she decided to break the door throwing it on the mountains Mountains are described by a sequence of heights a 1 a 2 dots a n in order from left to right k le n It is guaranteed that neighboring heights are not equal to each other that is a i ne a i 1 for all i from 1 to n 1 Peaks of mountains on the segment l r from l to r are called indexes i such that l i r a i 1 a i and a i a i 1 It is worth noting that the boundary indexes l and r for the segment For example if n 8 and a 3 1 4 1 5 9 2 6 then the segment 1 8 has only two peaks with indexes 3 and 6 and there are no peaks on the segment 3 6 To break the door Nastya throws it to a segment l l k 1 of consecutive mountains of length k 1 le l le n k 1 When the door touches the peaks of the mountains it breaks into two parts after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains and so on Formally the number of parts that the door will break into will be equal to p 1 where p is the number of peaks on the segment l l k 1 Nastya wants to break it into as many pieces as possible Help her choose such a segment of mountains l l k 1 that the number of peaks on it is maximum If there are several optimal segments Nastya wants to find one for which the value l is minimal Formally you need to choose a segment of mountains l l k 1 that has the maximum number of peaks Among all such segments you need to find the segment that has the minimum possible value l ,"['#include <bits/stdc++.h>\n\nint A[210000];\nint P[210000];\nint pre[210000];\n\nint main() {\n    int T; scanf(""%d"", &T);\n    while (T--) {\n        int N, K;\n        scanf(""%d%d"", &N, &K);\n        for (int i = 0; i < N; ++i)\n            scanf(""%d"", &A[i]);\n        for (int i = 1; i < N - 1; ++i)\n            P[i] = (A[i] > A[i - 1] && A[i] > A[i + 1]);\n        for (int i = 1; i <= N; ++i) pre[i] = pre[i - 1] + P[i - 1];\n        int maxi = 0;\n        for (int i = 0; i + K - 1 < N; ++i)\n            if (pre[maxi + K - 1] - pre[maxi + 1] < pre[i + K - 1] - pre[i + 1])\n                maxi = i;\n        printf(""%d %d\\n"", pre[maxi + K - 1] - pre[maxi + 1] + 1, maxi + 1);\n    }\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,Let s make an array consisting of and such that it shows whether the position is a peak on the whole segment To do this we will go through the indices from to and if the conditions and are true then we write in a new array at position After that we calculate the prefix sum in the new array Now the number of peaks in the segment is calculated as so we find out how many peaks in the desired segment not including the boundaries of the segment It remains only to go through all from to and find the leftmost such that as much as possible 
Little Maxim loves interesting problems He decided to share one such problem with you Initially there is an array consisting of zeroes The elements of the array are indexed starting from 1 Then follow queries to change array Each query is characterized by two integers In the answer to the query we should make the th array element equal Maxim thinks that some pairs of integers are good and some are not Maxim thinks that array consisting of integers is lucky if for all integer the pair of integers is good Note that the order of numbers in the pairs is important that is specifically After each query to change array Maxim wants to know how many ways there are to replace all zeroes in array with integers from one to three so as to make the resulting array without zeroes lucky Of course distinct zeroes can be replaced by distinct integers Maxim told you the sequence of queries and all pairs of integers he considers lucky Help Maxim solve this problem for him ,"['/*\n * cd2.cpp\n *\n *  Created on: 2012-12-17\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 77777 + 10;\nconst int MOD = 777777777;\n\nint n, nQ;\nint w[3][3];\n\ntypedef long long int64;\n\nstruct Tree {\n\tint c[3][3];\n\tTree*pl, *pr;\n\tint l, r;\n\n\tvoid update() {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tint64 k = 0;\n\t\t\t\tfor (int pi = 0; pi < 3; ++pi) {\n\t\t\t\t\tfor (int pj = 0; pj < 3; ++pj)\n\t\t\t\t\t\tif (w[pi][pj]) {\n\t\t\t\t\t\t\tk += 1LL * pl->c[i][pi] * pr->c[pj][j];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i][j] = k % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tTree(int l, int r) :\n\t\t\tl(l), r(r) {\n\t\tmemset(c, 0, sizeof c);\n\t\tif (l + 1 == r) {\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tc[i][i] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl = new Tree(l, l + r >> 1);\n\t\tpr = new Tree(l + r >> 1, r);\n\t\tupdate();\n\t}\n\n\tvoid change(int i, int x) {\n\t\tif (i < l || i >= r)\n\t\t\treturn;\n\t\tif (l + 1 == r) {\n\t\t\tif (x == 0) {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\tc[j][j] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tc[x - 1][x - 1] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl->change(i, x);\n\t\tpr->change(i, x);\n\t\tupdate();\n\t}\n}*root;\n\nint main() {\n\tcin >> n >> nQ;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tcin >> w[i][j];\n\t\t}\n\t}\n\troot = new Tree(0, n);\n\tfor (int i = 0; i < nQ; ++i) {\n\t\tint a, x;\n\t\tscanf(""%d%d"", &a, &x);\n\t\t--a;\n\t\troot->change(a, x);\n\t\tint ans = 0;\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tans += root->c[j][k];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2400,Solution is interval tree We will save dynamic programming f i j in each vertex this dp means in how many ways we can change all 0 to some numbers on interval such that it will be valid and first element will be i and last will be j With normal implementation its easy to pass system tests 
Li Hua has a pattern of size n times n each cell is either blue or red He can perform operations In each operation he chooses a cell and changes its color from red to blue or from blue to red Each cell can be chosen as many times as he wants Is it possible to make the pattern that matches its rotation by 180 circ Suppose you were Li Hua please solve this problem ,"['// LUOGU_RID: 110066180\n#include<bits/stdc++.h>\n#define int long long\nconst int N=1e5+5,M=1005;\nusing namespace std;\nint n,a[M][M],k,sum;\nvoid solve()\n{\n\tcin>>n>>k;sum=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tcin>>a[i][j];\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(a[i][j]!=a[n-i+1][n-j+1]){sum++;a[n-i+1][n-j+1]=a[i][j];}\n\tif(sum>k||(((k-sum)&1)&&n%2==0))cout<<""No\\n"";\nelse cout<<""Yes\\n"";\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1100,We can calculate the minimum needed operations easily by enumerating through the cells and performing an operation if the color of the cell is different from the targeted cell Obviously if the problem has no solution Otherwise there are two cases If the solution exists if and only if as we must perform two operations each time to meet the requirement If the solution always exists as we can perform the remaining operations at the center of the pattern Time complexity 
Have you ever played Hanabi If not then you ve got to try it out This problem deals with a simplified version of the game Overall the game has 25 types of cards 5 distinct colors and 5 distinct values Borya is holding cards The game is somewhat complicated by the fact that everybody sees Borya s cards except for Borya himself Borya knows which cards he has but he knows nothing about the order they lie in Note that Borya can have multiple identical cards and for each of the 25 types of cards he knows exactly how many cards of this type he has The aim of the other players is to achieve the state when Borya knows the color and number value of each of his cards For that other players can give him hints The hints can be of two types color hints and value hints A color hint goes like that a player names some color and points at all the cards of this color Similarly goes the value hint A player names some value and points at all the cards that contain the value Determine what minimum number of hints the other players should make for Borya to be certain about each card s color and value ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 12345;\n\nint c[N], num[N];\nchar card[N];\nint mask[N];\n\nvector < pair <int, int> > p;\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  p.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%s"", card);\n    c[i] = -1;\n    num[i] = 0;\n    if (card[0] == \'R\') c[i] = 0;\n    if (card[0] == \'G\') c[i] = 1;\n    if (card[0] == \'B\') c[i] = 2;\n    if (card[0] == \'Y\') c[i] = 3;\n    if (card[0] == \'W\') c[i] = 4;\n    num[i] = card[1] - \'1\';\n    p[i] = make_pair(c[i], num[i]);\n  }\n  sort(p.begin(), p.end());\n  p.resize(unique(p.begin(), p.end()) - p.begin());\n  n = p.size();\n  for (int i = 0; i < n; i++) {\n    c[i] = p[i].first;\n    num[i] = p[i].second;\n  }\n  int ans = 42;\n  for (int tn = 0; tn < (1 << 5); tn++) {\n    for (int tc = 0; tc < (1 << 5); tc++) {\n      vector <int> hints;\n      for (int i = 0; i < 5; i++) {\n        if (tn & (1 << i)) {\n          hints.push_back(i);\n        }\n      }\n      for (int i = 0; i < 5; i++) {\n        if (tc & (1 << i)) {\n          hints.push_back(~i);\n        }\n      }\n      int cnt = hints.size();\n      for (int i = 0; i < n; i++) {\n        mask[i] = 0;\n        for (int j = 0; j < cnt; j++) {\n          if (hints[j] >= 0) {\n            if (num[i] == hints[j]) {\n              mask[i] |= (1 << j);\n            }\n          } else {\n            if (c[i] == ~hints[j]) {\n              mask[i] |= (1 << j);\n            }\n          }\n        }\n      }\n      sort(mask, mask + n);\n      bool ok = true;\n      for (int i = 0; i < n - 1; i++) {\n        if (mask[i] == mask[i + 1]) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        if (cnt < ans) {\n          ans = cnt;\n        }\n      }\n    }\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1700,It s obvious that the order of hints doesn t metter There are 10 types of hints so we can try all vartiants of what other players should do Now we need to check if Boris can describe all of his cards He can do it iff he can distinguish all pairs of different cards He can do it if somebody told at least one distinction It can be a hint about color of one of cards if they don t have same one or it can be hint about value of some card 
You are given a permutation p 0 p 1 ldots p n 1 of odd integers from 1 to 2n 1 and a permutation q 0 q 1 ldots q k 1 of integers from 0 to k 1 An array a 0 a 1 ldots a nk 1 of length nk is defined as follows a i cdot k j p i cdot 2 q j for all 0 le i n and all 0 le j k For example if p 3 5 1 and q 0 1 then a 3 6 5 10 1 2 Note that all arrays in the statement are zero indexed Note that each element of the array a is uniquely determined Find the number of inversions in the array a Since this number can be very large you should find only its remainder modulo 998 244 353 An inversion in array a is a pair i j 0 le i j nk such that a i a j ,"[""#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\nusing namespace std;\nconst int maxn=200005;\nconst int mod=998244353;\nint T,n,m,p1[maxn],p2[maxn];\nint lowbit(int x){return x&-x;}\nstruct tl_s{\n\tint mx,data[maxn*2];\n\tvoid clear(int x){\n\t\tfor(int i=1;i<=mx;++i)data[i]=0;\n\t\tmx=x;\n\t}\n\tint add(int x){\n\t\tfor(;x<=mx;x+=lowbit(x))data[x]++;\n\t}\n\tint ask(int x){\n\t\tint res=0;\n\t\tfor(;x;x-=lowbit(x))res+=data[x];\n\t\treturn res;\n\t}\n}t1;\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tint ans=0;\n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=n;++i)cin>>p1[i];\n\t\tfor(int i=1;i<=m;++i)cin>>p2[i],p2[i]++;\n\t\tt1.clear(m);\n\t\tfor(int i=m;i>=1;--i){\n\t\t\tans=(ans+(long long)n*t1.ask(p2[i]))%mod;\n\t\t\tt1.add(p2[i]);\n\t\t}\n\t\tt1.clear(2*n-1);\n\t\tfor(int i=n;i>=1;--i){\n\t\t\tfor(int j=0,tmp=p1[i];j<m;++j,tmp*=2){\n\t\t\t\tif(tmp>2*n-1){\n\t\t\t\t\tans=(ans+(long long)(m-j)*(m-j+1)/2%mod*(n-i))%mod;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans=(ans+(long long)t1.ask(tmp)*(m-j))%mod;\n\t\t\t}\n\t\t\tfor(int j=0,tmp=p1[i];tmp&&j<m;++j,tmp/=2){\n\t\t\t\tif(j)ans=(ans+(long long)t1.ask(tmp)*(m-j))%mod;\n\t\t\t}\n\t\t\tt1.add(p1[i]);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}""]","[0, 1, 1, 1, 1, 0, 0, 0, 0, 0]",2300,Let s split the array into subarrays of the length The relative order of the elements in each of them is the same as in permutation so the number of inversions is the same too You can find the number of invesions in one of them as described in the hint By multiplying this number by you count all the in block inversions All the remaining inversions are formed by pairs of elements from the distinct blocks You may assume that now for simplicity it won t change the number of such inversions Let s fix two elements and of and count the number of inversions such that and for some and It is equivalent to counting the number of inversions in the array Consider merging two arrays and with and are odd into one sorted subarray if then the resulting array would look like if then the resulting array would look like if then the resulting array would look like You can see several blue elements in the beginning followed by alternating blue and red elements which are followed by several red elements The number of blue elements in the beginning is equal to the number of red elements in the end and equal to the largest such that Furthermore this is also limited by because and are both positive integers less than If the situation is similar but the order of colors is reversed Going back to inversions we have some array Inversions are formed by a large blue element and a small red element if then there are inversions if the there are inversions if the there are inversions For the situation is similar but we will start with inversions for and we will add terms instead of substracting them Well now we can solve this problem in enumerate pairs find and add some value to the answer Now let s add the inversion counting algorithm to solve this problem Again let s solve the problem for first Let s enumerate the value of from to the s on the right of should not be counted in now each of the s on the left of such that adds to the answer each of the s on the left of such that adds to the answer each of the s on the left of such that adds to the answer We can maintain a segment tree to compute the sum of the values we should sum up To update this segment tree let s additionally maintain pointers that maintain the largest such that for each from to The solution is similar for pairs You should be careful when implementing this because for small at some moment there becomes elements in the alternating segment of the blue red array and you shouldn t substract anything further 
Tsovak and Narek are playing a game They have an array a and a matrix b of integers with n rows and m columns numbered from 1 The cell in the i th row and the j th column is i j They are looking for the elements of a in turns Tsovak starts first Each time a player looks for a cell in the matrix containing the current element of a Tsovak looks for the first then Narek looks for the second etc Let s say a player has chosen the cell r c The next player has to choose his cell in the submatrix starting at r 1 c 1 and ending in n m the submatrix can be empty if r n or c m If a player cannot find such a cell or the remaining submatrix is empty or the array ends the previous player has chosen the last element then he loses Your task is to determine the winner if the players play optimally For example in C it is enough to use the following lines at the start of the function int main ios base sync with stdio false cin tie NULL cout tie NULL ,"['#include <bits/stdc++.h>using namespace std;\xa0vector < vector < pair <int , int> > > aparitii;vector < vector <int> > matrice;vector <int> sir , maxim;\xa0inline void Solve (){    int lungime , linii , coloane;    cin >> lungime >> linii >> coloane;\xa0    aparitii.resize(linii * coloane + 1);    matrice.resize(linii + 1);    sir.resize(lungime + 1);\xa0    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[indice]; }\xa0    for (int linie = 1 ; linie <= linii ; linie++)     {        matrice[linie].resize(coloane + 1);        for (int coloana = 1 ; coloana <= coloane ; coloana++)            { cin >> matrice[linie][coloana]; }    }            for (int coloana = 1 ; coloana <= coloane ; coloana++) {        for (int linie = 1 ; linie <= linii ; linie++) {            if (!aparitii[matrice[linie][coloana]].empty() && aparitii[matrice[linie][coloana]].back().second == coloana)                { aparitii[matrice[linie][coloana]].back().first = linie; }            else                { aparitii[matrice[linie][coloana]].push_back({linie , coloana}); }        }    }    \xa0    matrice.clear();    maxim.resize(coloane + 2);    for (int indice = lungime ; indice ; indice--)    {        int ramas = 0;        for (auto locatie : aparitii[sir[indice]])         {            while (ramas < locatie.second)                { maxim[++ramas] = 0; }\xa0            if (maxim[locatie.second + 1] <= locatie.first)                { maxim[ramas] = locatie.first; }        }\xa0        while (ramas < coloane)            { maxim[++ramas] = 0; }\xa0        for ( ; ramas ; ramas--)            { maxim[ramas] = max(maxim[ramas] , maxim[ramas + 1]); }    }\xa0    cout << (maxim[1] ? ""T\\n"" : ""N\\n"");\xa0    aparitii.clear();    maxim.clear();    sir.clear();}\xa0int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);\xa0    int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }\xa0    return 0;}']","[1, 0, 1, 1, 1, 0, 0, 0, 0, 0]",2500,Let s define dp0i j as the minimal even index k 1 k l such that dpk i j wins Define dp1i j similarly for odds First fill all of them with Then compute them from the bottom right cell of the matrix to the top left cell of the matrix dp0i j will be the minimal of the following three values dp0i 1 j if i n there will be no submatrix left so dp0i 1 j will be dp0i j 1 Let s define by ind the index of bi j in a there are no duplicates in a and if there is no bi j there assign to ind If dp1i 1 j 1 ind 1 which means that dpind 1 i 1 j 1 loses and ensues the current player s win then the value of this part will be ind Otherwise This is because in other cases the opponent either had a winning position starting from ind 1 or even earlier in the game so we can t win from that index We count dp1 similarly but we count dp0 and dp1 simultaneously for every i j Lastly if dp11 1 1 then Tsovak wins otherwise Narek wins 
In some game by Playrix it takes minutes for an oven to bake carrot cakes all cakes are ready at the same moment minutes after they started baking Arkady needs at least cakes to complete a task but he currently don t have any However he has infinitely many ingredients and one oven Moreover Arkady can build one more similar oven to make the process faster it would take minutes to build the oven While the new oven is being built only old one can bake cakes after the new oven is built both ovens bake simultaneously Arkady can t build more than one oven Determine if it is reasonable to build the second oven i e will it decrease the minimum time needed to get cakes or not If the time needed with the second oven is the same as with one oven then it is unreasonable ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n, t, k, d;\n  scanf(""%d %d %d %d"", &n, &t, &k, &d);\n  int steps = (n + k - 1) / k;\n  int if_no = steps * t;\n  int get = (if_no - 1) / t * k;\n  if (if_no - 1 > d) {\n    get += (if_no - 1 - d) / t * k;\n  }\n  puts(get >= n ? ""YES"" : ""NO"");\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1100,One of possible solutions to simply simulate described process To make it we need two variables and In them we will store the time when each of the ovens will become free In the beginning equals to and equals to After simulating the process we will get a time for which possible to make cakes with ovens this time equals to maximum from and It is only left to compare this time with value a time for which possible to make cakes using only one oven 
You are given a string consisting of lowercase Latin letters Let s denote substring of as a string Obviously and there are exactly such substrings Let s call some string an of a string iff the following conditions are met is an odd number is simultaneously a prefix and a suffix of For evey substring of you have to calculate the maximum length of its odd proper suprefix ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint P[3] = { 359, 1039, 2797 };\nll MO[3] = { MOD, MOD + 2, 1000000087 };\n\nchar in[1000050];\nll po[3][1000050];\nll sum[3][1000050];\nbool isEqual(int s1, int e1, int s2, int e2) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tll v1 = (sum[i][e1] - sum[i][s1 - 1]) % MO[i];\n\t\tv1 = (v1 + MO[i]) % MO[i];\n\t\tv1 = v1 * po[i][1000000 - e1] % MO[i];\n\n\t\tll v2 = (sum[i][e2] - sum[i][s2 - 1]) % MO[i];\n\t\tv2 = (v2 + MO[i]) % MO[i];\n\t\tv2 = v2 * po[i][1000000 - e2] % MO[i];\n\t\tif (v1 != v2) return false;\n\t}\n\treturn true;\n}\nint main() {\n\tint N, i, j;\n\tscanf(""%d"", &N);\n\tscanf(""%s"", in + 1);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tpo[i][0] = P[i];\n\t\tfor (j = 1; j <= 1000000; j++) po[i][j] = po[i][j - 1] * P[i] % MO[i];\n\t\tfor (j = 1; j <= N; j++) sum[i][j] = (sum[i][j - 1] + po[i][j] * in[j]) % MO[i];\n\t}\n\n\tvector <int> Va;\n\tint prv = -1;\n\tfor (i = (N + 1) / 2; i >= 1; i--) {\n\t\tint st = i, en = N + 1 - st;\n\t\tint L = en - st + 1;\n\t\tint mx = min(L - 1, prv + 2);\n\t\tif (mx % 2 == 0) mx--;\n\t\tfor (j = mx; j >= 1; j-=2) {\n\t\t\tif (isEqual(st, st + j - 1, en - j + 1, en)) break;\n\t\t}\n\t\tif (j >= 1) Va.push_back(j);\n\t\telse Va.push_back(-1);\n\t\tprv = j;\n\t}\n\treverse(all(Va));\n\tfor (auto it : Va) printf(""%d "", it);\n\treturn !printf(""\\n"");\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2700,Let s look at suprefix of fixed substring we can t find its maximal length via binary search because this function isn t monotone in general case But by fixing not the left border but the center of the prefix we also fix the center of the corresponding suffix center of a prefix in position is tied with the center of the suffix in position and more important function becomes monotone So solution is next iterate over all valid centers of prefix and try to binary search maximal length of such substring that its center is in position and it s equal to the substing with center in then can be updated with value And don t forget to update each with value Easy way to check substrings for equality is to use hashes Harder way is to use string suffix structures like bundle of Suffix Array LCP Sparse Table or Suffix Tree LCA Note for SuffArray users don t forget about changing sort to stable sort merge sort and breaking if all suffixes are different This optimizations can save you from writing radix or bucket sort 
Pak Chanek is setting up internet connections for the village of Khuntien The village can be represented as a connected simple graph with n houses and m internet cables connecting house u i and house v i each with a latency of w i There are p houses that require internet Pak Chanek can install servers in at most k of the houses The houses that need internet will then be connected to one of the servers However since each cable has its latency the latency experienced by house s i requiring internet will be the latency of the cables between that house and the server it is connected to For each k 1 2 ldots n help Pak Chanek determine the minimum latency that can be achieved for all the houses requiring internet ,"['#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<\'0\'||ch>\'9\') f|=(ch==\'-\'),ch=getchar();\twhile(ch>=\'0\'&&ch<=\'9\') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}struct Edge{int u,v,w;}l[200010];bool operator<(Edge A,Edge B){return A.w<B.w;}int n,m,p;int rt,fa[200010],siz[200010],cnt[200010];int get_fa(int a){return a==fa[a]?a:fa[a]=get_fa(fa[a]);}long long bas[200010],del,tk;vector<long long> S[200010],tmp;void solve(){\tmemset(cnt,0,(n+1)<<2),memset(bas,0,(n+1)<<2);\xa0\tn=Qread(),m=Qread(),p=Qread();\tfor(int i=1;i<=p;i++) cnt[Qread()]=1;\xa0\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=1,S[i].resize(2,0ll);\xa0\tfor(int i=1;i<=m;i++) l[i].u=Qread(),l[i].v=Qread(),l[i].w=Qread();\tsort(l+1,l+m+1);\xa0\tfor(int i=1,u,v;i<=m;i++) if(get_fa(l[i].u)!=get_fa(l[i].v))\t{\t\tu=get_fa(l[i].u),v=get_fa(l[i].v);\t\tif(siz[u]<siz[v]) swap(u,v);\xa0\t\tS[u][0]=1ll*cnt[u]*l[i].w,\t\tS[v][0]=1ll*cnt[v]*l[i].w;\xa0\t\ttmp.resize(siz[u]+siz[v]+1,0x3f3f3f3f3f3f3f3f);\t\tfor(int i=0;i<=siz[u];i++)\t\tfor(int j=0;j<=siz[v];j++)\t\t\ttmp[i+j]=min(tmp[i+j],S[u][i]+S[v][j]);\xa0\t\tfa[v]=u,siz[u]+=siz[v],cnt[u]+=cnt[v],bas[u]+=bas[v];\t\tswap(S[u],tmp);\t\tvector<long long>().swap(tmp);\t\tvector<long long>().swap(S[v]);\t}\trt=get_fa(1);\tfor(int i=1;i<=n;i++)\t\tprintf(""%lld "",S[rt][i]);\tprintf(""\\n"");\xa0\tvector<long long>().swap(S[rt]);}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}']","[1, 1, 1, 1, 1, 1, 0, 0, 0, 1]",2300,Since the cost of a path uses the maximum edge weight in the path we can use a Kruskal like algorithm that is similar to finding the MST Minimum Spanning Tree Initially the graph has no edges and we add each edge one by one starting from the smallest values of wi while maintaining the connected components in the graph using DSU Disjoint Set Union While doing the MST algorithm we simultaneously construct the reachability tree of the graph whose structure represents the sequence of mergings of connected components in the algorithm Each vertex in the reachability tree corresponds to some connected component at some point in time in the algorithm Each non leaf vertex in the reachability tree always has two children which are the two connected components that are merged to form the connected component represented by that vertex so every time two connected components merge in the algorithm we make a new vertex in the reachability tree that is connected to its two corresponding children After doing all that we ve constructed a reachability tree that is a rooted binary tree with 2n 1 vertices n of which are leaves For each non leaf vertex x we write down weight x which is the weight of the edge that forms its connected component For each leaf we mark it as special if and only if it corresponds to a house that needs internet Then for each vertex x we calculate cnt x which is the number of special leaves in the subtree of x These values will be used later Consider a non leaf x in the reachability tree It can be obtained that two vertices in the original graph corresponding to any two leaves in the subtree of x can have a path between them in the original graph with a weight of at most weight x Let s solve for some value of k For each special vertex x we want to choose a target vertex y that s an ancestor of x Then we choose a set of k leaves for the houses with installed servers We want it such that each chosen target has at least one leaf in its subtree that is a member of the set The total path cost of this is the sum of weight y for all chosen targets y Let s say we ve fixed the set of k leaves Then we mark every ancestor of these leaves If we only consider the marked vertices with the edges between them we have a reduced tree For each special leaf we want to choose its nearest ancestor that is in the reduced tree for its target to get the one with the smallest weight Knowing this we can solve the problem in another point of view Initially we have the original reachability tree We want to reduce it into a reduced tree with k leaves We want to do it while maintaining the chosen targets of the special leaves and their costs Initially for each special leaf we choose itself as its target In one operation we can do the following Choose a vertex that s currently a leaf Move every target that s currently in that leaf to its parent Remove that leaf and the edge connecting it to its parent We want to do that until the reduced tree has k leaves For each edge connecting a vertex x to its parent y in the reachability tree calculate weight y weight x cnt x That is the cost to move every target in vertex x to vertex y Define that as the edge s length We want to do operations with the minimum cost so that the reduced tree has k leaves We want to minimize the sum of lengths of the deleted edges If we look at it in a different way we want to choose edges to be in the reduced tree with the maximum sum of lengths For some value of k the edges of the reduced tree can be decomposed into k paths from some vertex to its descendant We want the total sum of lengths of these paths to be as big as possible But how do we solve it for every k from 1 to n Let s say k 1 We can choose the path from the root to its furthest leaf How do we solve for k 2 onwards It turns out that we can use the optimal solution for some value of k to make the optimal solution for k 1 by just adding the longest possible available path That means for each k from 1 to n we just find the current longest available path and add it to our reduced tree What if at some point there are more than one possible longest paths It can be proven that we can choose any of these paths and the optimal solutions for the next values of k will still be optimal The proof for this greedy strategy involves the convexity of the total length as k goes from 1 to n However we won t explain it in detail here So to solve the problem we do DFS in the reachability tree to calculate for each vertex x the furthest leaf and the second furthest leaf in its subtree For each k from 1 to n we add the current longest available path using this precalculation Time complexity O nlogn mlogm 
Kostyanych has chosen a complete undirected graph dagger with n vertices and then removed exactly n 2 edges from it You can ask queries of the following type d Kostyanych tells you the number of vertex v with a degree d Among all possible such vertices he selects the vertex and if there are several such vertices he selects the one with the minimum number He also tells you the number of another vertex in the graph with which v is not connected by an edge if none is found then 0 is reported Among all possible such vertices he selects the one with the minimum number Then he removes the vertex v and all edges coming out of it If the required vertex v is not found then 0 0 is reported Find a Hamiltonian path ddagger in the graph in at most n queries It can be proven that under these constraints a Hamiltonian path always exists dagger A complete undirected graph is a graph in which there is exactly one undirected edge between any pair of distinct vertices Thus a complete undirected graph with n vertices contains frac n n 1 2 edges ddagger A Hamiltonian path in a graph is a path that passes through each vertex exactly once ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));int n,m;deque<int> q;pair<int,int> ask(int x){\tcout<<""? ""<<x<<endl;\tint y;cin>>x>>y;\treturn MP(x,y);}void solve(int x){\tif(x==1){\t\tq.push_back(ask(0).first);\t\treturn;\t}\tauto p=ask(x-2);\tif(p.second==0){\t\tauto t=ask(0);\t\tif(x>2) solve(x-2);\t\tq.push_back(p.first),q.push_back(t.first);\t}else{\t\tsolve(x-1);\t\tif(q.front()!=p.second) q.push_front(p.first);\t\telse q.push_back(p.first);\t}}void solve(){\tcin>>n;\tsolve(n);\tcout<<""! "";\twhile(!q.empty()){\t\tcout<<q.front()<<\' \';\t\tq.pop_front();\t}\tcout<<endl;}int main(){\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 1]",2900,SolutionLet s consider the following recursive algorithm We will store the Hamiltonian path as a double ended queue maintaining the start and end In case there are only or vertices left in the graph the problem is solved trivially Suppose we know that the current graph has vertices and there are at most edges missing Then the total number of edges in such a graph is at least Let all vertices in the graph have a degree of at most then the total number of edges does not exceed which is less than the stated value Hence we conclude that there is at least one vertex with a degree greater than If there exists a vertex with a degree of then it is sufficient to run our recursive algorithm for the remaining graph Since is only not connected by an edge to one vertex is connected either to the start or the end of the maintained path in the remaining graph Thus we can insert the vertex either at the beginning or at the end of the path Otherwise let be the vertex with a degree of There is at least one vertex with a degree not exceeding Remove and from the graph Notice that the number of edges in such a graph does not exceed The invariant is preserved so we can run the algorithm for the remaining graph Then we can arrange the vertices in the following order where the start of the Hamiltonian path in the remaining graph It remains to understand how to use queries Make a query Let be the second number in the response to our query If the degree of vertex is Run our recursive algorithm and then compare the start and end of the obtained path with Otherwise if it means the degree of vertex is In this case ask about any vertex with a low degree this can be done with a query Then simply arrange the vertices in the order mentioned above We will make no more than queries and the final asymptotic will be 
Someone give a strange birthday present to Ivan It is hedgehog connected undirected graph in which one vertex has degree at least 3 we will call it center and all other vertices has degree 1 Ivan thought that hedgehog is too boring and decided to make himself k multihedgehog Let us define k multihedgehog as follows 1 multihedgehog is hedgehog it has one vertex of degree at least 3 and some vertices of degree 1 For all k ge 2 k multihedgehog is k 1 multihedgehog in which the following changes has been made for each vertex v with degree 1 let u be its only neighbor remove vertex v create a new hedgehog with center at vertex w and connect vertices u and w with an edge New hedgehogs can differ from each other and the initial gift Thereby k multihedgehog is a tree Ivan made k multihedgehog but he is not sure that he did not make any mistakes That is why he asked you to check if his tree is indeed k multihedgehog ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nvi graf[nax];\n\nvoid nope()\n{\n\tprintf(""No\\n"");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(""Yes\\n"");\n\texit(0);\n}\n\nint korz=-1;\n\nvi stos;\n\nvoid dfs1(int v, int oj)\n{\n\tstos.push_back(v);\n\tif ((int)stos.size()==2*k+1)\n\t\tkorz=stos[k];\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs1(i, v);\n\tstos.pop_back();\n}\n\nvoid dfs2(int v, int oj, int odl)\n{\n\tif ((int)graf[v].size()==1 && odl!=k)\n\t\tnope();\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs2(i, v, odl+1);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tif (n<=3)\n\t\tnope();\n\tint lis=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif ((int)graf[i].size()==1)\n\t\t\tlis=i;\n\tdfs1(lis, 0);\n\tif (korz==-1)\n\t\tnope();\n\tif ((int)graf[korz].size()<3)\n\t\tnope();\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif ((int)graf[i].size()==1 || i==korz)\n\t\t\tcontinue;\n\t\tif ((int)graf[i].size()<4)\n\t\t\tnope();\n\t}\n\tdfs2(korz, 0, 0);\n\ttak();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1800,Solution 1 Firstly let s find all vertices with degree Now we can delete them and all verticies which were incident to them must became verticies with degree And also for each new veretice with degree we must have already deleted not less then verticies If initial graph was multihedgehog after deleting vertices with degree it would became multihedgehog It could be realised using bfs starting from all initial vertices with degree Complexity is Solution 2 First of all let s find diametr of the graph After that we can find middle vertex in diameter and check if it is a center of multihedgehog using simple dfs Complexity is 
Luba has to do chores today th chore takes units of time to complete It is guaranteed that for every the condition is met so the sequence is sorted Also Luba can work really hard on some chores She can choose not more than any chores and do each of them in units of time instead of Luba is very responsible so she has to do all chores and now she wants to know the minimum time she needs to do everything Luba cannot do two chores simultaneously ,"['#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(""input.txt"");\n\t//ofstream cout(""output.txt"");\n\n\tint n, k, x;\n\tcin >> n >> k >> x;\n\n\tint ans = 0;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\treverse(all(a));\n\n\tfor (int i = 0; i < k; ++i) {\n\t\tans += x;\n\t}\n\tfor (int i = k; i < n; ++i) {\n\t\tans += a[i];\n\t}\n\n\tcout << ans << ""\\n"";\n\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,Since it is better to do exactly chores in time And since we need to minimize total time we need to spend it s better to speed up the longest chores So the answer is 
DZY has a hash table with buckets numbered from to He wants to insert numbers in the order they are given into the hash table For the th number DZY will put it into the bucket numbered where is the hash function In this problem we will assume that Operation denotes taking a remainder after division by However each bucket can contain no more than one element If DZY wants to insert an number into a bucket which is already filled we say a conflict happens Suppose the first conflict happens right after the th insertion you should output If no conflict happens just output ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar ch;\n\nvoid read(int &x)\n{\n\tx=0;\n\tch=getchar();\n\twhile (ch<=32) ch=getchar();\n\twhile (ch>32) x=x*10+ch-48,ch=getchar();\n}\n\nint a[1000];\n\nint main()\n{\n\tint p,n;\n\tread(p);read(n);\n\tint i;\n\tfor (i=1;i<=n;i++) {\n\t\tint x;\n\t\tread(x);\n\t\tif (++a[x%p]>1) break;\n\t}\n\tif (i<=n) {\n\t\tprintf(""%d\\n"",i);\n\t} else {\n\t\tputs(""-1"");\n\t}\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,We just need an array to store the numbers inserted and check whether a conflict happens It s easy 
You are given a long decimal number a consisting of n digits from 1 to 9 You also have a function f that maps every digit from 1 to 9 to some possibly the same digit from 1 to 9 You can perform the following operation choose a non empty of digits in a and replace each digit x from this segment with f x For example if a 1337 f 1 1 f 3 5 f 7 3 and you choose the segment consisting of three rightmost digits you get 1553 as the result What is the maximum possible number you can obtain applying this operation no more than once ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <numeric>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+"".in"").c_str());\n\t\tFout((pname+"".out"").c_str());\n\t#else\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 200010\n\nint n;\nint a[MAXN];\nint to[MAXN];\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) a[i] = In.Readnum()-\'0\';\n\tFor(i,9) Read(to[i]);\n\n\tint flag = 0;\n\tFor(i,n){\n\t\tif( flag == 1 ){\n\t\t\tif( to[a[i]] >= a[i] ) a[i] = to[a[i]];\n\t\t\telse flag = 2;\n\t\t}\n\t\tif( flag == 0 ){\n\t\t\tif( to[a[i]] > a[i] ){\n\t\t\t\ta[i] = to[a[i]];\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\t;\n\t}else{\n\t\t/*\n\t\tbool eq = 0;\n\t\tFor(i,n){\n\t\t\tif( a[i] == to[a[i]] ) eq = 1;\n\t\t}\n\t\tif(!eq) a[n] = to[a[n]];\n\t\t*/\n\t}\n\tFor(i,n)\n\t\tputchar(a[i]+\'0\');\n\tputchar(10);\n\n\tEND();\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300,Let s find the first digit in that becomes greater if we replace it obviously if there is no such digit then the best solution is to leave unchanged In the optimal solution we will replace this digit and maybe some digits after this Why is it so It is impossible to make any of the previous digits greater since we found the first digit that can be replaced with a greater one Then let s analyze all digits to the right of it We should not replace any digit with a lower digit because it is better not to replace it and all digits to the right of it at all but there s nothing wrong with replacing any other digits So the segment we need to replace begins with the first digit that can become greater after replacing and includes this digit and goes to the right until the first digit that becomes less after replacing and this digit is excluded 
Unary is a minimalistic Brainfuck dialect in which programs are written using only one token Brainfuck programs use 8 commands and their meaning is not important for the purposes of this problem Unary programs are created from Brainfuck programs using the following algorithm First replace each command with a corresponding binary code using the following conversion table 1000 1001 1010 1011 1100 1101 1110 1111 Next concatenate the resulting binary codes into one binary number in the same order as in the program Finally write this number using unary numeral system this is the Unary program equivalent to the original Brainfuck one You are given a Brainfuck program Your task is to calculate the size of the equivalent Unary program and print it modulo ,"['#include <cstdio>\n#include <string>\n#include <map>\n#include <cstring>\n#include <bitset>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <memory.h>\n#include <list>\n#include <vector>\n#include <set>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define sqr(n)  (n)*(n)\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define INF 2000000000\n\ntypedef long long ll;\n\nint MOD = 1000003;\n\nint main()\n{\n    string s;\n    cin >> s;\n    int res = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        res *= 16;\n        if(s[i]==\'>\')\n            res+=8;\n        else if(s[i]==\'<\')\n            res+=9;\n        else if(s[i]==\'+\')\n            res+=10;\n        else if(s[i]==\'-\')\n            res+=11;\n        else if(s[i]==\'.\')\n            res+=12;\n        else if(s[i]==\',\')\n            res+=13;\n        else if(s[i]==\'[\')\n            res+=14;\n        else if(s[i]==\']\')\n            res+=15;\n        res %= MOD;\n    }\n    printf(""%d"",res);\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1200,A lovely language Brainfuck has dialects for literally every occasion I guess one could write a whole round about it not Unknown Language Round of course it s too well known for it but this time I used it in one problem only The solution is quite simple all you have to do is to follow the described procedure of transforming code from Brainfuck to Unary If your language has built in long arithmetics the solution is straightforward replace characters of each type with corresponding binary codes convert the resulting string into a long integer and take it modulo 1000003 Having no long arithmetics is not a big deal either The program can be created step by step adding one character at a time from left to right On each step the length of the program is multiplied by 16 the binary code added has length of 4 bits then the code of the current character is added and the result is taken modulo 1000003 so that the result never gets really large 
A permutation of length n is an array p p 1 p 2 dots p n which contains every integer from 1 to n inclusive and moreover each number appears exactly once For example p 3 1 4 2 5 is a permutation of length 5 For a given number n n ge 2 find a permutation p in which absolute difference that is the absolute value of difference of any two neighboring adjacent elements is between 2 and 4 inclusive Formally find such permutation p that 2 le p i p i 1 le 4 for each i 1 le i n Print any such permutation for the given integer n or determine that it does not exist ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n    void solve () {\n       \n       \n         /* --------- */\n       \n    int a;\n    cin>>a;\n    if (a<=3) {cout<<""-1\\n""; return; }\n    if (a==4) {\n        cout<<""3 1 4 2\\n""; return; \n    }\n    int max1=0; \n    for (int i=1;i<=a;i+=2) { max1=i; cout<<i<<"" ""; }\n    if (max1+1>a) {\n        cout<<max1-3<<"" ""<<max1-1<<"" ""; for (int j=max1-5;j>=1;j-=2) cout<<j<<"" ""; cout<<""\\n""; return;  \n    }\n    cout<<max1-3<<"" ""<<max1+1<<"" ""<<max1-1<<"" ""; for (int j=max1-5;j>=1;j-=2) cout<<j<<"" "";cout<<""\\n""; return;  \n        /* --------- */   \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(false);\n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n       \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1600,If then there is no answer You can do some handwork to be sure Otherwise the answer exists and there is one simple way to construct it firstly let s put all odd integers into the answer in decreasing order then put and all other even numbers in increasing order To test that it always works you can run some kind of checker locally you can check all tests very fast in less than one second this may be very helpful sometimes 
Okabe and Super Hacker Daru are stacking and removing boxes There are boxes numbered from to Initially there are no boxes on the stack Okabe being a control freak gives Daru commands of which are to add a box to the top of the stack and of which are to remove a box from the top of the stack and throw it in the trash Okabe wants Daru to throw away the boxes in the order from to Of course this means that it might be impossible for Daru to perform some of Okabe s commands because the required box is not on the top of the stack That s why Daru can decide to wait until Okabe looks away and then reorder the boxes in the stack in any way he wants He can do it at any point of time between Okabe s commands but he can t add or remove boxes while he does it Tell Daru the minimum number of times he needs to reorder the boxes so that he can successfully complete all of Okabe s commands It is guaranteed that every box is added before it is required to be removed ,"['#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 300010\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') ch = getchar();\n\twhile (ch >= \'0\' && ch <= \'9\')\n\t\tx = x * 10 + ch - \'0\', ch = getchar();\n}\nchar s[20];\nint n, sta[maxn], top, x, k, ans;\nint main() {\n\tgn(n);\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tscanf(""%s"", s + 1);\n\t\tif (s[1] == \'a\') {\n\t\t\tscanf(""%d"", &x);\n\t\t\tsta[++top] = x; \n\t\t} else {\n\t\t\t++k;\n\t\t\tif (top && sta[top] == k) {\n\t\t\t\t--top;\n\t\t\t} else {\n\t\t\t\tif (!top) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\t++ans; top = 0; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1500,It looks like Daru should only reorder the boxes when he has to i e he gets a remove operation on a number which isn t at the top of the stack The proof is simple reordering when Daru has more boxes is always not worse than reordering when he has less boxes because Daru can sort more boxes into the optimal arrangement Therefore our greedy algorithm is as follows simulate all the steps until we need to reorder and then we resort the stack in ascending order from top to bottom This has complexity O n2 log n However we can speed this up if we note that whenever we reorder boxes any box currently on the stack can be put in an optimal position and we can pretty much forget about it So whenever we reorder we can just clear the stack as well and continue This gives us O n complexity because every element is added and removed exactly once 
Twilight Sparkle learnt that the evil Nightmare Moon would return during the upcoming Summer Sun Celebration after one thousand years of imprisonment on the moon She tried to warn her mentor Princess Celestia but the princess ignored her and sent her to Ponyville to check on the preparations for the celebration Twilight Sparkle wanted to track the path of Nightmare Moon Unfortunately she didn t know the exact path What she knew is the parity of the number of times that each place Nightmare Moon visited Can you help Twilight Sparkle to restore any path that is consistent with this information Ponyville can be represented as an undirected graph vertices are places edges are roads between places without self loops and multi edges The path can start and end at any place also it can be empty Each place can be visited multiple times The path must not visit more than places ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n// EVEN\n//   ENDS: Degree is 3 + 4k\n//   ELSE: Degree is 4k\n\n// ODD\n//   ENDS: Degree is 1 + 4k\n//   ELSE: Degree is 2 + 4k\n\n#define MAXN 100010\n\nint N;\nvector<int> E[MAXN];\nvector<int> R;\n\nint X[MAXN];\nbool vis[MAXN];\n\nbool dfs(int u) {\n  if(vis[u]) return false;\n  vis[u] = true;\n\n  bool res = X[u] == 1;\n  for(int i = 0; i < E[u].size(); i++) {\n    res |= dfs(E[u][i]);\n  }\n  return res;\n}\n\nvoid dfs2(int u, int p) {\n  vis[u] = true;\n\n  X[u] = 1 - X[u];\n  R.push_back(u);\n\n  for(int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i];\n    if(vis[v]) continue;\n\n    dfs2(v, u);\n\n    X[u] = 1 - X[u];\n    R.push_back(u);\n  }\n\n  if(X[u]) {\n    if(p == -1) {\n      R.resize(R.size() - 1);\n    } else {\n      X[p] = 1 - X[p];\n      R.push_back(p);\n      X[u] = 1 - X[u];\n      R.push_back(u);\n    }\n  }\n}\n\nint main() {\n  int M;\n  cin >> N >> M;\n  for(int i = 0; i < M; i++) {\n    int u, v; cin >> u >> v; u--; v--;\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n\n  int xs = -1;\n  for(int i = 0; i < N; i++) {\n    if(vis[i]) continue;\n\n    if(dfs(i)) {\n      if(xs == -1) {\n        xs = i;\n      } else {\n        cout << ""-1\\n"";\n        return 0;\n      }\n    }\n  }\n  if(xs == -1) {\n    cout << ""0\\n"";\n  } else {\n    memset(vis, 0, sizeof(vis));\n    dfs2(xs, -1);\n\n    cout << R.size() << \'\\n\';\n    for(int i = 0; i < R.size(); i++) {\n      if(i) cout << \' \';\n      cout << R[i] + 1;\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",2200,Brief description Given a undirected graph with n nodes and the parity of the number of times that each place is visited Construct a consistent path Analysis There is no solution if there is more than 1 connected component which have odd node because we can t move between two component otherwise it is always solvable This fact is not obvious let s focus on one component You can select any node to start denoted it as r root Start from r you can go to any other odd node then back Each time you can eliminate one odd node After that if r itself is odd you can simply delete the first or last element in your path it must be r The only spot of the above method is the size of the path can been large as O n2 We need a more local observation Let s check the following dfs function This dfs maintain the following loop invariant before we leave a node u we clear all odd node in the sub tree rooted at u as well as u itself The only u can break the invariant is the root itself So after dfs we use O 1 time to check weather root is still a odd node if yes delete the first or last element of the path it must be r After that all the node will been clear each node can involve at most 4 items in the path So the size of the path will less than or equal to 4n Thus the overall complexity is O n m 
A MIPT student named Misha has a birthday today and he decided to celebrate it in his country house in suburban Moscow friends came by and after a typical party they decided to play blind man s buff The birthday boy gets blindfolded and the other players scatter around the house The game is played in several rounds In each round Misha catches exactly one of his friends and has to guess who it is The probability of catching the th friend does not change between rounds and is equal to percent as we know it is directly proportional to the amount of alcohol consumed by the th friend and holds Misha has no information about who he caught After Misha makes an attempt to guess the caught person the round ends Even then Misha isn t told whether he guessed correctly and a new round begins The game ends when Misha guesses every friend at least once that is there exists such set of rounds that during round number Misha caught the th friend and guessed him Misha wants to minimize the expectation of the number of rounds of the game Despite the fact that at any point in the game Misha has no information about who he has already guessed his friends are honest and if they see that the condition for the end of the game is fulfilled the game ends immediately Find the expectation of the number of rounds in the game if Misha plays optimally ,"['#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 101;\n\nint N;\nint rval[MAXN];\ndouble cprob[MAXN];\npriority_queue <pair <double, int> > pq;\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> rval[i];\n    \n    for (int i = 0; i < N; i++)\n    {\n        pq.push (make_pair (1e9, i));\n        cprob[i] = 0;\n    }\n    \n    double ans = 0, tot = 0;\n    for (int i = 1; i <= 3e6; i++)\n    {\n        pair <double, int> ptop = pq.top();\n        pq.pop();\n        \n        double rrate = ptop.first;\n        int rloc = ptop.second;\n        \n        cprob[rloc] += rval[rloc] / 100. * (1 - cprob[rloc]);\n        \n        if (rrate > 1e8)\n        {\n            tot = 1.;\n            for (int j = 0; j < N; j++)\n                tot *= cprob[j];\n            ans += tot * i;\n        }\n        else\n        {\n            ans += (rrate - 1) * tot * i;\n            tot *= rrate;\n        }\n        \n        double nadd = rval[rloc] / 100. * (1 - cprob[rloc]);\n        pq.push (make_pair (nadd / cprob[rloc] + 1, rloc));\n    }\n    \n    cout << fixed << setprecision(8);\n    cout << ans << ""\\n"";\n    //system (""Pause"");\n    return 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2700,Let s denote Main idea first of all guess each friend once then maximize probability to end game on current step Let s simulate first 300000 steps and calculate where how many times we called th friend Expectation with some precision equals So it is enough to prove that 1 Greedy strategy gives maximum values for all 2 On 300000 step precision error will be less than Proof 1 Suppose that for some there exists set not equal to set produced by greedy algorithm gives the maximum value of Let s take some and it is easy to prove tgat if we change to to then new set of gives bigger value of contradiction 2 Let s take set it gives probability of end of the game not less than optimal Then Precision error does not exceed It could be estimated as sum of geometric progression If precision error doesn t exceed 
In an ICPC contest balloons are distributed as follows Whenever a team solves a problem that team gets a balloon The first team to solve a problem gets an additional balloon A contest has 26 problems labelled textsf A textsf B textsf C textsf Z You are given the order of solved problems in the contest denoted as a string s where the i th character indicates that the problem s i has been solved by some team No team will solve the same problem twice Determine the total number of balloons that the teams received Note that some problems may be solved by none of the teams ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""./debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""./input.txt""); ofstream cout(""output.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n    fstart;\n\n    int T; cin >> T;\n    while (T--) {\n        int n; cin >> n;\n        string s; cin >> s;\n        int res = 0;\n        for (char c = \'A\'; c <= \'Z\'; c++) {\n            int cnt = count(all(s), c);\n            if (cnt) {\n                res += cnt + 1;\n            }\n        }\n        cout << res << ""\\n"";\n\n    }\n\n    finish;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0]",800,Let s keep an array of booleans denoting whether or not some team has solved the th problem already Now we can iterate through the string from left to right and keep a running total If is true the th problem has already been solved increase by otherwise increase by and set to true The time complexity is Bonus the answer is always Can you see why 
Polycarp likes arithmetic progressions A sequence a 1 a 2 dots a n is called an arithmetic progression if for each i 1 le i n the value a i 1 a i is the same For example the sequences 42 5 5 5 2 11 20 29 and 3 2 1 0 are arithmetic progressions but 1 0 1 1 3 9 and 2 3 1 are not It follows from the definition that any sequence of length one or two is an arithmetic progression Polycarp found some sequence of positive integers b 1 b 2 dots b n He agrees to change each element by at most one In the other words for each element there are exactly three options an element can be decreased by 1 an element can be increased by 1 an element can be left unchanged Determine a minimum possible number of elements in b which can be changed by exactly one so that the sequence b becomes an arithmetic progression or report that it is impossible It is possible that the resulting sequence contains element equals 0 ,"['#include <bits/stdc++.h>\n#define DIM 100007\n#define INF 1000000007\nusing namespace std;\n\nlong long n,b[DIM];\nint main()\n{\n    cin>>n;\n    for(int i = 1;i<=n;++i)\n        cin>>b[i];\n\n    long long res = INF;\n\n    for(int k1 = -1; k1<=1;++k1)\n        for(int k2 = -1;k2<=1;++k2)\n    {\n        long long d = b[2]+k2 - b[1] - k1,last = b[2] +k2,curr = 0;\n        if(k1!=0) curr++;\n        if(k2!=0) curr++;\n\n        for(int i = 3;i<=n;++i)\n        {\n            long long need = last + d;\n            if(abs(need - b[i])>1)\n            {\n                curr = INF;\n                break;\n            }\n            if(need != b[i])\n                curr++;\n\n            last = need;\n        }\n\n        res = min(res,curr);\n    }\n\n    if(res == INF) cout<<-1;\n    else cout<<res;\n    return 0;\n}\n']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",1500,If we can print because each such sequence is an arithmetic progression Note that an arithmetic progression is uniquely determined by the first two terms So we should brute from to the change of the first element of the given sequence and from to the change of the second element of the given sequence Then and Also we will store the number of changed elements in the sequence Initially Now we need to iterate through the sequence from the third element to th Let current element in the position It should be equals to If then such arithmetic progression is unreachable Else if we should increase on one After we considered all elements we should update the answer with the value of if for all it was true that 
To get money for a new aeonic blaster ranger Qwerty decided to engage in trade for a while He wants to buy some number of items or probably not to buy anything at all on one of the planets and then sell the bought items on another planet Note that this operation is not repeated that is the buying and the selling are made only once To carry out his plan Qwerty is going to take a bank loan that covers all expenses and to return the loaned money at the end of the operation the money is returned without the interest At the same time Querty wants to get as much profit as possible The system has planets in total On each of them Qwerty can buy or sell items of types such as food medicine weapons alcohol and so on For each planet and each type of items Qwerty knows the following the cost of buying an item the cost of selling an item the number of remaining items It is not allowed to buy more than items of type on planet but it is allowed to sell any number of items of any kind Knowing that the hold of Qwerty s ship has room for no more than items determine the maximum profit which Qwerty can get ,"['#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long i64;\ntypedef unsigned long long ui64;\n\nconst int intINF=999999999;\nconst i64 i64INF=99999999999999999ll;\nconst double doubleINF=9999999999.;\n\nusing namespace std;\n\nstruct good{int pr,q;};\n\nint res=0;\nint n,m,k;\nint p[11][111][4];\n\nint max(int a,int b){\n\tif(a<b) a=b;\n\treturn a;\n}\n\nbool gsort(good a,good b){\n\treturn a.pr>b.pr;\n}\n\nvoid go(int fr,int to){\n\tgood g[111];\n\tfor(int i=1;i<=m;i++){\n\t\tg[i].q=p[fr][i][3];\n\t\tg[i].pr=p[to][i][2]-p[fr][i][1];\n\t}\n\tg[m+1].q=9999999;\n\tg[m+1].pr=0;\n\tsort(g+1,g+m+2,gsort);\n\tint left=k,got=0,cnt=1;\n\twhile(left>0){\n\t\tif(g[cnt].q>left){\n\t\t\tgot+=g[cnt].pr*left;\n\t\t\tleft=0;\n\t\t}\n\t\telse{\n\t\t\tgot+=g[cnt].pr*g[cnt].q;\n\t\t\tleft-=g[cnt].q;\n\t\t\tg[cnt].q=0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tres=max(res,got);\n}\n\nint main(){\n\tchar c;\n\tscanf(""%d%d%d%*c"",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(scanf(""%c"",&c),c!=\'\\n\');\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tfor(int h=1;h<=3;h++)\n\t\t\t\tscanf(""%d"",&p[i][j][h]);\n\t\tscanf(""%*c"");\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tgo(i,j);\n\tprintf(""%d\\n"",res);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200,In this problem some greedy solution expected Let fix 2 planets in planet i we will buy items in planet j we will sell the ones Profit of item of type k will be b jk a ik Every item has size 1 so you should greedy take items in order of decreasing of profits of items while you have place in the hold Scheme of full solution you should iterate over all pairs of planet for every pair greedy take items and find total profit At the end you should find maximal total profit over all pairs and output it 
You are given a directed graph consisting of n vertices Each directed edge or arc labeled with a single character Initially the graph is empty You should process m queries with it Each query is one of three types add arc from u to v with label c It s guaranteed that there is no arc u v in the graph at this moment erase arc from u to v It s guaranteed that the graph contains arc u v at this moment find the sequence of k vertices v 1 v 2 dots v k such that there exist both routes v 1 to v 2 to dots to v k and v k to v k 1 to dots to v 1 and if you write down characters along both routes you ll get the same string You can visit the same vertices any number of times ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nset<pair<int, int>> edges;\n\nmap<pair<int, int>, char> mapka;\n\nset<pair<int, int>> double_edges;\n\nset<pair<int, int>> good_double_edges;\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n, m; cin>>n>>m;\n\n    while (m--)\n    {\n        string op; cin>>op;\n        if (op==""+"")\n        {\n            int u, v; char c; cin>>u>>v>>c;\n            edges.insert(mp(u, v)); mapka[mp(u, v)] = c;\n            if (edges.count(mp(v, u)))\n            {\n                double_edges.insert(mp(min(u, v), max(u, v)));\n                if (mapka[mp(u, v)] == mapka[mp(v, u)]) good_double_edges.insert(mp(min(u, v), max(u, v)));\n            }\n        }\n        if (op==""-"")\n        {\n            int u, v; cin>>u>>v; edges.erase(mp(u, v));\n\n            if (edges.count(mp(v, u)))\n            {\n                double_edges.erase(mp(min(u, v), max(u, v)));\n                if (mapka[mp(u, v)] == mapka[mp(v, u)]) good_double_edges.erase(mp(min(u, v), max(u, v)));\n            }\n\n        }\n        if (op==""?"")\n        {\n            int k; cin>>k;\n            if (k%2)\n            {\n                if (double_edges.size()) cout<<""YES""<<endl; else cout<<""NO""<<endl;\n            }\n            else\n            {\n                if (good_double_edges.size()) cout<<""YES""<<endl; else cout<<""NO""<<endl;\n            }\n        }\n\n        /*cout<<""ITERATION: ""<<endl;\n        for (auto it: double_edges) cout<<it.first<<\' \'<<it.second<<endl;*/\n\n    }\n}']","[0, 0, 0, 0, 1, 0, 1, 0, 0, 1]",2400,At first if there should be both routes and then there are both arcs and i e there should exist at least one pair that both arcs and are present in the graph Now if is odd and we have at least one pair then we can simply create sequence This sequence is a palindrome so obviously both routes generate the same string If is even or we can note that in the sequence there is a middle arc and it should have the same character as arc since it s a middle arc in reverse route i e there should exist at least one pair that both arcs and are present in the graph and have the same label Now if we have at least one such pair then routes and generate the same one letter strings Since each arc is a part of at most one pair we can just maintain two sets with pairs one for pairs with different labels and the other one for pairs with equal labels If is odd we check that at least one of the sets is not empty If is even we check that the second set is not empty 
Suneet and Slavic play a card game The rules of the game are as follows Each card has an integer value between 1 and 10 Each player receives 2 cards which are face down so a player doesn t know their cards The game is turn based and consists In a round both players pick a card and flip it The player who flipped a card with a strictly greater number wins the round In case of equality no one wins the round A player wins a game if he wins the most number of rounds i e strictly greater than the other player In case of equality no one wins the game Since Suneet and Slavic aren t best friends you need to calculate the number of ways the game could happen that Suneet would end up as the winner ,"['#include<bits/stdc++.h>using namespace std;int T;int f(int x){\tif(x>0)return 1;\tif(x==0)return 0;\tif(x<0)return -1;}int main(){\tcin>>T;\twhile(T--){\t\tint a[2],b[2];cin>>a[0]>>a[1]>>b[0]>>b[1];int ans=0;\t\tfor(int i=0;i<2;i++)for(int j=0;j<2;j++){\t\t\tans+=(f(a[i]-b[j])+f(a[1-i]-b[1-j])>0);\t\t}\t\tcout<<ans<<endl;\t}\treturn 0;}']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 0]",1000,For each test case we can brute force through all possible games there are only four of them and calculate who is the winner of the game by simulating the game 
Calculate the value of the sum As the result can be very large you should print the value modulo the remainder when divided by The modulo operator stands for the remainder after dividing by For example ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\nconst ll MOD = 1000000007;\nconst ll SQ = 2000000;\n\nll n, m;\n\n\nint main() {\n\tcin >> n >> m;\n\tll sum = (n % MOD) * (m % MOD);\n\tsum %= MOD;\n\tm = min(n, m);\n\tll lst = m + 1;\n\tfor (int i = 1; i <= min(SQ, n); ++i) {\n\t\tll r = n / i;\n\t\tll l = n / (i + 1) + 1;\n\t\tr = min(r, m);\n\t\tif (l > r)\n\t\t\tcontinue;\n\t\tlst = min(lst, l);\n\t\tll ss = l + r;\n\t\tll cc = r - l + 1;\n\t\tif ((ss & 1) == 0)\n\t\t\tss /= 2;\n\t\telse\n\t\t\tcc /= 2;\n\t\tss %= MOD;\n\t\tcc %= MOD;\n\t\tss = (ss * cc) % MOD;\n\t\tss = (ss * i) % MOD;\n\t\tsum -= ss;\n\t\tif (sum < 0)\n\t\t\tsum += MOD;\n\t}\n\tfor (int i = 1; i < lst; ++i) {\n\t\tsum -= (n - n % i);\n\t\tsum %= MOD;\n\t\tif (sum < 0)\n\t\t\tsum += MOD;\n\t}\n\tcout << sum << ""\\n"";\n\treturn 0;\n}\n\n\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",2200,Unfortunately my solution for this problem had overflow bug It was fixed on contest Even so I hope you enjoyed the problem because I think it s very interesting Let s transform the sum Note that the last sum can be accumulated to only value because for all the values will be equal to Note in the last sum either or Let s carefully accumulate both cases The first sum can be simply calculated by iterating over all We will accumulate the second sum independently for all different values Firstly we should determine for which values we will have the value Easy to see that for the values from the interval Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time it s simply a sum of arithmetic progression So we have solution with complexity solution Complexity 
You are given a string A sequence of strings is called if the concatenation of these strings is string formally and the first characters of these strings are distinct Find any sequence of strings or determine that the sequence doesn t exist ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint k , f[256] , mrk[101] , cnt=0 , done=0 ;\nstring a ;\n\nint main(){\n  memset(f,-1,sizeof(f)) ;\n  cin >> k >> a ;\n  for(int i=0 ; i<a.size() ; i++) if(f[a[i]]==-1) f[a[i]]=i , mrk[i]=1 , cnt++ ; \n  if(cnt<k) { printf(""NO"") ;  return 0 ;}\n\n  printf(""YES"") ; \n  for(int i=0 ; i<a.size() ; i++) {\n    if(mrk[i] && done<k) puts("""") , done++ ;\n    cout << a[i] ;  \n  }   \n\n  return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100,In that task you need to implement what was written in the statements Let s iterate over all characters of string and keep array Also let s keep current string If current character was not used previously then let s put current string to the answer and after that we need to clear current string Otherwise let s append current character to the current string If array that contain answer will have more then elements we will concatenate few last strings The jury solution 11035685 
Nick had received an awesome array of integers a a 1 a 2 dots a n as a gift for his 5 birthday from his mother He was already going to explore its various properties but after unpacking he was disappointed a lot because the product a 1 cdot a 2 cdot dots a n of its elements seemed to him not large enough He was ready to throw out the array but his mother reassured him She told him that array would not be spoiled after the following operation choose any index i 1 le i le n and do a i a i 1 For example he can change array 3 1 4 1 to an array 4 1 3 1 after applying this operation to elements with indices i 1 and i 3 Kolya had immediately understood that sometimes it s possible to increase the product of integers of the array a lot Now he has decided that he wants to get an array with the maximal possible product of integers using only this operation with its elements possibly zero one or more times as many as he wants it is not forbidden to do this operation several times for the same index Help Kolya and print the array with the maximal possible product of elements a 1 cdot a 2 cdot dots a n which can be received using only this operation in some order If there are multiple answers print any of them ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC optimize(3)\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC target(""sse3"",""sse2"",""sse"")\n//#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n//#pragma GCC target(""f16c"")\n//#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n//#pragma GCC diagnostic error ""-fwhole-program""\n//#pragma GCC diagnostic error ""-fcse-skip-blocks""\n//#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n//#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return \'""\' + s + \'""\';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? ""true"" : ""false"");}template <typename A, typename B>string to_string(pair<A, B> p) {return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";}template <typename A>string to_string(A v) {bool first = true;string res = ""{"";for (const auto &x : v) {if (!first) {res += "", "";}first = false;res += to_string(x);}res += ""}"";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << "" "" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == \'-\') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - \'0\';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\n\nnamespace SOLVE {\n    ll f(ll x){\n        return -x-1;\n    }\n    void main(){\n        ll n;in(n);\n        VLL v(n);\n        REP(i,0,n)in(v[i]);\n        REP(i,0,n){\n            if(v[i]>=0)v[i] = f(v[i]);\n        }\n        if(n%2 == 1){\n            if(*min_element(all(v)) == -1){\n                v[0] = 0;\n            }else{\n                int pos = -1;\n                REP(i,0,n){\n                    if(v[i] != -1){\n                        if(pos == -1)pos = i;\n                        else{\n                            if(v[i] < v[pos])pos = i;\n                        }\n                    }\n                }\n                v[pos] = f(v[pos]);\n            }\n        }\n        \n        REP(i,0,n)cout<<v[i]<<"" "";\n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n    //    in(t);\n    while(t--){\n        SOLVE::main();\n        \n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    //    clock_t st = clock();\n    //    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n    //\n    //    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1500,Initially we are going to make a product maximal by absolute value It means that if we are going to apply described operation i e to increase the absolute value Now if the product is already positive it s the answer Else to apply the operation to the minimal number is obviously optimal if we applied the operation to any other number the result would not be greater by absolute value but applying to the minimum we have received non negative product already Thus the solution works in 
Kana was just an ordinary high school girl before a talent scout discovered her Then she became an idol But different from the stereotype she is also a gameholic One day Kana gets interested in a new adventure game called In this game her quest is to beat a dragon The dragon has a of x initially When its goes to 0 or under 0 it will be defeated In order to defeat the dragon Kana can cast the two following types of spells Assume that the dragon s current is h after this spell its will become left lfloor frac h 2 right rfloor 10 Here left lfloor frac h 2 right rfloor denotes h divided by two rounded down This spell will decrease the dragon s by 10 Assume that the dragon s current is h after this spell its will be lowered to h 10 Due to some reasons Kana can only n and m She can cast the spells in any order and cast all the spells Kana isn t good at math so you are going to help her to find out whether it is possible to defeat the dragon ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int x, n, m;\n        cin >> x >> n >> m;\n\n        bool ok = false;\n\n        for(int i = 0; i <= n; i++)\n        {\n            int v = x;\n            for(int j = 0; j < i; j++)\n                v = v / 2 + 10;\n            for(int j = 0; j < m; j++)\n                v -= 10;\n\n            if(v <= 0)\n                ok = true;\n        }\n\n        cout << (ok ? ""YES\\n"" : ""NO\\n"");\n    }\n\n    return 0;\n}']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",900,First it s better not to cast after a Otherwise there will be a right after a Supposing the hit point was before casting these two spells if you cast first after these two spells the hit point will be but if you cast first after these two spells the hit point will be which is smaller So the solution is to cast until the dragon s hit point won t decrease with more casts or you can t cast more then cast all you have We can also use DP to solve this problem Let be possibility of defeating the dragon when the dragon s hit point is at you can cast more and more This is a slow solution but is enough to get accepted You may have to use boolean arrays instead of integer arrays to save memory 
Define the beauty of a permutation of numbers from 1 to n p 1 p 2 dots p n as number of pairs L R such that 1 le L le R le n and numbers p L p L 1 dots p R are consecutive R L 1 numbers in some order For example the beauty of the permutation 1 2 5 3 4 equals 9 and segments corresponding to pairs are 1 2 5 4 3 1 2 3 4 5 3 4 1 2 5 3 4 Answer q independent queries In each query you will be given integers n and k Determine if there exists a permutation of numbers from 1 to n with beauty equal to k and if there exists output one of them ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\npii h[105][105*107/2];\nint q,N[SZ],K[SZ];\nvector<int> aa[SZ];\nvector<int> qry[105][105*107/2];\nvector<int> ch[SZ];\nint an=0,ty[SZ];\nvector<int> op;\nvoid dfs(int w,int d=0)\n{\n//\tcerr<<w<<""!""<<ty[w]<<"":"";\n//\tfor(auto c:ch[w]) cout<<c<<"","";\n//\tcout<<""\\n"";\n\tif(!ch[w].size())\n\t{\n\t\top.pb(w);\n\t\treturn;\n\t}\n\tif(ty[w]==1)\n\t{\n\t\tvector<int> sb;\n\t\tint s=ch[w].size();\n\t\tfor(int t=1;t<s;t+=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tsb.pb(ch[w][0]);\n\t\tfor(int t=(s-1)-((s-1)&1);t>0;t-=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n\telse\n\t{\n\t\tvector<int> sb;\n\t\tfor(auto r:ch[w]) sb.pb(r);\n\t\tif(d) reverse(sb.begin(),sb.end());\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n}\nvector<int> cons(int n,int p)\n{\n//\tcerr<<n<<"",""<<p<<""\\n"";\n\tan=n;\n\tvector<int> st;\n\tfor(int i=1;i<=n;++i) ty[i]=0,ch[i].clear(),st.pb(i);\n\tint X=1,Y=p;\n\twhile(X!=n)\n\t{\n\t\tpii g=h[X][Y];\n\t\tassert(g.fi!=-1);\n\t\tint y=g.se%2; g.se/=2;\n\t\tint c=g.fi-X+1;\n\t\ttie(X,Y)=g;\n\t\t++an; ty[an]=y; ch[an].clear();\n\t\tfor(int j=1;j<=c;++j)\n\t\t\tch[an].pb(st.back()),st.pop_back();\n\t\treverse(ch[an].begin(),ch[an].end());\n\t\tst.pb(an);\n\t}\n\tassert(Y==n&&st.size()==1);\n\top.clear();\n\tdfs(an);\n\t#ifdef LOCAL\n\t#warning ""LOCAL ON""\n\tassert(op.size()==n);\n\tint sb=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tvector<int> g;\n\t\tfor(int j=i;j<n;++j)\n\t\t{\n\t\t\tg.pb(op[j]);\n\t\t\tsort(g.begin(),g.end());\n\t\t\tbool ok=1;\n\t\t\tfor(int w=0;w<g.size();++w)\n\t\t\t\tok&=g[w]==g[0]+w;\n\t\t\tif(ok) ++sb;\n\t\t}\n\t}\n//\tcerr<<sb<<""?\\n"";\n\tassert(sb==p);\n\t#endif\n\treturn op;\n}\nint main()\n{\n\tscanf(""%d"",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(""%d%d"",N+i,K+i),\n\t\tqry[N[i]][K[i]].pb(i);\n\tfor(int n=1;n<=100;++n)\n\t{\n\tmemset(h,-1,sizeof h);\n\th[n][n]=pii(0,0);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tfor(int j=n*(n+1)/2;j>=0;--j) if(~h[i][j].fi)\n\t\t{\n\t\t\tfor(int c=2;c<=i;++c)\n\t\t\t{\n\t\t\t\th[i-c+1][j+c*(c-1)/2]=pii(i,j*2);\n\t\t\t\tif(c>=4) h[i-c+1][j+1]=pii(i,j*2+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=n*(n+1)/2;j>=0;--j)\n\t\tif(h[1][j].fi!=-1&&qry[n][j].size())\n\t\t{\n\t\t\tauto u=cons(n,j);\n\t\t\tfor(auto r:qry[n][j]) aa[r]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tif(aa[i].size())\n\t\t{\n\t\t\tputs(""YES"");\n\t\t\tfor(auto x:aa[i])\n\t\t\t\tprintf(""%d "",x);\n\t\t\tputs("""");\n\t\t}\n\t\telse\n\t\t\tputs(""NO"");\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",3400,We will denote if there exists a permutation of length with beauty equal to To begin with it is obvious that the beauty of a permutation of length is at least for indeed you can take each element individually and the entire permutation completely Statement 1 if and then Let be a permutation of length whose beauty is and be a permutation of length whose beauty is equal to Let us build from them a permutation of length whose beauty is We expand in the permutation to and to the rest of the elements greater than add We got a permutation of length Denote it by If is not between then we reverse the first elements and this will be done in a new permutation Now let be between Then what good pairs do we have in There are good pairs among the first elements there are good pairs if you count the first elements in one and we counted the interval from the first elements twice so we counted pairs At the same time this is all pairs because if some good segment contains and then it must contain as well Thus this statement is proved Statement 2 if then either or or exist such that and Show it We will call subsegments consisting of several consecutive numbers in some order Consider some kind of permutation of length of beauty Suppose that We want to show that in the permutation there is some good subsegment of length not equal to or with the following property for any other good subsegment if and intersect then one of them contains the second In this case by analogy with the proof of Proposition 1 we can squeeze the segment into one element obtaining some kind of permutation Then the number of good segments in the entire permutation will be equal to the number of good sub segments on the segment the number of good segments in since we counted the segment twice We will call such a segment Thus if in each permutation there is then the statement is true Suppose that then in the permutation there is a good segment of length not equal to or Let s say he s not very good Then there is another We denote if there exists a permutation of length with beauty equal to To begin with it is obvious that the beauty of a permutation of length is at least for indeed you can take each element individually and the entire permutation completely Statement 1 if and then Let mdash a permutation of length whose beauty is and mdash a permutation of length whose beauty is equal to Let us build from them a permutation of length whose beauty is We expand in the permutation to and to the rest of the elements greater than add We got a permutation of length Denote it by If is not between then we reverse the first elements and this will be done in a new permutation Now let be between Then what good pairs do we have in There are good pairs among the first elements there are good pairs if you count the first elements in one and we counted the interval from the first elements twice so we counted pairs At the same time this is all pairs because if some good segment contains and then it must contain as well Thus this statement is proved Statement 2 if then either or or such that and Show it We will call subsegments consisting of several consecutive numbers in some order Consider some kind of permutation of length of beauty Suppose that We want to show that in the permutation there is some good subsegment of length not equal to or with the following property for any other good subsegment if and intersect then one of them contains the second In this case by analogy with the proof of Proposition 1 we can squeeze the segment into one element obtaining some kind of permutation Then the number of good segments in the entire permutation will be equal to the number of good sub segments on the segment the number of good segments in since we counted the segment twice We will call such a segment Thus if in each permutation there is then the statement is true Let be a good segment that is not very good Then there is a good segment which intersects with but does not contain and is not contained in it The segments and form together segment It is easy to show that each of them is good and the numbers in the segments go monotonously Let us demonstrate this with an example the first segment is the second is Then together they will give the union of three segments As we can see each of these segments is good and also all numbers in the second segment are larger than all numbers in the first all numbers in the third segment are larger than all numbers in the second Let at the moment we have lined up a chain of good segments going consecutively where the union of any several consecutive ones is a good segment as well as all the numbers in more than all the numbers in or vice versa As long as is not equal to the whole segment we will do this since is very good there is a segment that intersects with it but is not contained in it does not contain It is easy to see that thanks to the segment our chain of good segments is extended Now suppose that is the whole segment While there is a segment of length greater than among the segments we will do the same if then we will find the necessary for it then will be split into two smaller good segments At the end of the process we get good segments of length each and the numbers are sorted monotonously Hence the numbers in the permutation were initially sorted monotonously whence the number of good segments is The statement is proved Now the left is easy for each from to we calculate what beauty values can be in a permutation of length using statement storing the corresponding values After that it is easy to answer the request by building a permutation of the desired beauty according to the algorithm with the approval of Asymptotics of With an incredibly small constant up to on this works for 300 ms Challenge improve the asymptotics to works in less than 30 ms 
You are given a tree of n nodes rooted at 1 Every node has a value of either 0 or 1 at time t 0 At any integer time t 0 the value of a node becomes the bitwise XOR of the values of its children at time t 1 the values of leaves become 0 since they don t have any children Let S t denote the sum of values of all nodes at time t Let F A denote the sum of S t across all values of t such that 0 le t le 10 100 where A is the initial assignment of 0s and 1s in the tree The task is to find the sum of F A for all 2 n initial configurations of 0s and 1s in the tree Print the sum modulo 10 9 7 ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef unsigned long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nnamespace _fac\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll p=1e9+7;\n\tll fac[N];\n\tll ifac[N];\n\tll inv[N];\n\tll ksm(ll x,int y)\n\t{\n\t\tll r=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) r=(ll)r*x%p;\n\t\t\tx=(ll)x*x%p;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll C(int n,int m)\n\t{\n\t\tif (n<m||m<0) return 0;\n\t\treturn (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;\n\t}\n\tvoid init_fac()\n\t{\n\t\tint i;\n\t\tfac[0]=1;\n\t\tfor (i=1; i<N; i++) fac[i]=(ll)fac[i-1]*i%p;\n\n\t\tifac[N-1]=ksm(fac[N-1],p-2);\n\t\tfor (i=N-1; i; i--) ifac[i-1]=(ll)ifac[i]*i%p;\n\n\t\tll x; inv[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tx=p/i;\n\t\t\tinv[i]=(ll)x*(p-inv[p-x*i])%p;\n\t\t}\n\t}\n}\nusing _fac::init_fac; using _fac::fac; using _fac::ifac; using _fac::inv;\nusing _fac::ksm; using _fac::C; using _fac::p;\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector e(n+1,vector<int>());\n\t\tfor (i=1; i<n; i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tcin>>u>>v;\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tvector<int> dep(n+1),md(n+1);\n\t\tll ans=0;\n\t\tfunction<void(int)> dfs=[&](int u)\n\t\t{\n\t\t\tmd[u]=dep[u];\n\t\t\tfor (int v:e[u]) if (!dep[v]) dep[v]=dep[u]+1,dfs(v),cmax(md[u],md[v]);\n\t\t\tans=(ans+md[u]-dep[u]+1)%p;\n\t\t};\n\t\tdfs(dep[1]=1);\n\t\tcout<<ans*ksm(2,n-1)%p<<\'\\n\';\n\t}\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1900,We will focus on computing the expected value of rather than the sum as the sum is just Let denote the sum of all values at node from time to if the initial configuration is Clearly With linearity of expectations Define as the value of node at time if the initial configuration is Observe that is simply if there is no node in s subtree at a distance of from otherwise the value is the bitwise xor of the initial values of all nodes in the subtree of at a distance of from Thus define as the length of the longest path from to a leaf in s subtree Now is half if is less than or equal to otherwise it s This is because the expected value of xor of boolean values is is is zero otherwise it s half This fact has multiple combinatorial proofs For example one can simply count the number of ways of choosing odd number of boolean values among the values as to get We use this to get All the values can be computed by a single traversal of the tree Our final result is Time complexity 
What joy Petya s parents went on a business trip for the whole year and the playful kid is left all by himself Petya got absolutely happy He jumped on the bed and threw pillows all day long until Today Petya opened the cupboard and found a scary note there His parents had left him with duties he should water their favourite flower all year each day in the morning in the afternoon and in the evening Wait a second thought Petya He know for a fact that if he fulfills the parents task in the th month of the year then the flower will grow by centimeters and if he doesn t water the flower in the th month then the flower won t grow this month Petya also knows that try as he might his parents won t believe that he has been watering the flower if it grows strictly less than by centimeters Help Petya choose the minimum number of months when he will water the flower given that the flower should grow no less than by centimeters ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 1024\n\nusing namespace std;\nFILE *in; FILE *out;\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(""A.in"", ""rt""); out = fopen(""A.out"", ""wt"");\n\t\n\tint k;\n\tint a[12];\n\tfscanf(in, ""%d"", &k);\n\tfor (int i = 0; i < 12; i++)\n\t\tfscanf(in, ""%d"", &a[i]);\n\t\n\tint ans = 13;\n\tfor (int mask = 0; mask < (1 << 12); mask++)\n\t{\n\t\tint cnt = 0, sum = 0;\n\t\tfor (int i = 0; i < 12; i++) if (mask & (1 << i))\n\t\t{\n\t\t\tcnt++;\n\t\t\tsum += a[i];\n\t\t}\n\t\tif (sum >= k) ans = min(ans, cnt);\n\t}\n\tfprintf(out, ""%d\\n"", ans > 12 ? -1 : ans);\n\t\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 1, 0]",900,First it is clear that if the sum of all numbers is less than then Peter in any case will not be able to grow a flower to the desired height and you should output 1 Secondly it is easy to see that if we want to choose a one month of two in which we watered the flower it is better to choose one where the number of is more Thus the solution is very simple let s take months in descending order of numbers and in these months water flowers As soon as the sum of the accumulated becomes greater than or equal to should stop the process the answer is found 
Kitahara Haruki has bought apples for Touma Kazusa and Ogiso Setsuna Now he wants to divide all the apples between the friends Each apple weights 100 grams or 200 grams Of course Kitahara Haruki doesn t want to offend any of his friend Therefore the total weight of the apples given to Touma Kazusa must be equal to the total weight of the apples given to Ogiso Setsuna But unfortunately Kitahara Haruki doesn t have a knife right now so he cannot split any apple into some parts Please tell him is it possible to divide all the apples in a fair way between his friends ,"['#include<cstdio>\n#include<cstring>\n\nint f[210], n;\n\nint main(){\n\tscanf(""%d"", &n);\n\tf[0] = 1;\n\tint sum = 0;\n\tfor(int i = 1; i <= n; i ++){\n\t\tint v;\n\t\tscanf(""%d"", &v);\n\t\tv /= 100;\n\t\tfor(int j = (n << 1); j >= 0; j --)\n\t\t\tif(f[j])\n\t\t\t\tf[j + v] = 1;\n\t\tsum += v;\n\t}\n\tif(sum & 1)\n\t\tfputs(""NO\\n"", stdout);\n\telse if(f[sum >> 1])\n\t\tfputs(""YES\\n"", stdout);\n\telse\n\t\tfputs(""NO\\n"", stdout);\n\n\treturn 0;\n}\n\n\n\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1100,Denote as the sum of the weight of the apples If is not an even number then the answer is obviously NO Otherwise we need to check if there is a way of choosing apples so that the sum of the weight of the chosen apples is exactly A simple approach would be to enumerate how many 200 gram apples do we choose and check if we can fill the rest with 100 gram apples We can also solve this problem using a classic knapsack DP Solution 6712942 
There is a string s of length n consisting of the characters and You are walking on this string You start by standing on top of the first character of s and you want to make a sequence of moves such that you end on the n th character In one step you can move one space to the left if you are not standing on the first character or one space to the right if you are not standing on the last character You may not stay in the same place however you may visit any character including the first and last character number of times At each point in time you write down the character you are currently standing on We say the string is if there exists some sequence of moves that take you from the first character to the last character such that the string you write down is a regular bracket sequence A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not You are given q queries Each query flips the value of a character from to or vice versa After each query determine whether the string is walkable Queries are so the effects of each query carry on to future queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n,q; cin>>n>>q;\n    set<int> bl;\n    for (int i = 0; i < n; ++i) {\n        char c; cin>>c;\n        bool b = c == \'(\';\n        if (b ^ (i % 2 == 0)) {\n            bl.insert(i);\n        }\n    }\n    for (int qi = 0; qi < q; ++qi) {\n        int i; cin>>i; --i;\n        if (n % 2 == 1) {\n            cout << ""NO\\n"";\n            continue;\n        }\n        if (bl.count(i)) {\n            bl.erase(i);\n        } else {\n            bl.insert(i);\n        }\n        if (bl.empty() || (*bl.begin() % 2 == 1 && *bl.rbegin() % 2 == 0)) {\n            cout << ""YES\\n"";\n        } else {\n            cout << ""NO\\n"";\n        }\n    }\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2100,For a string to be walkable we need to be even because the parity of the balance factor changes on each move and it has to be zero at the end of the process So if is odd the string is never walkable Now consider the set that contains all indices indexed satisfying one of the below conditions is even and is odd and Now consider a few cases If is empty then is of the form and is therefore trivially walkable by just moving to the right If is odd then is of the form We can show that it is never walkable because for every in the first section when we land on this before leaving this section of the string for the first time the balance factor must be Therefore when we try to move across the the balance factor will go to and the walk will no longer be valid If is even then is of the form and we can show that it is never walkable using a somewhat symmetric argument to the previous case but considering the ending of the walk instead of the beginning Otherwise is even and is odd We will prove that it is walkable In this case s is of the form To form a valid walk keep moving to the right until you hit the then alternate back and forth on the times After this move to the right until you hit the Note that during this process the balance factor can never go negative because it will always be at least Once you reach the alternate back and forth on it until the balance factor hits Because n is even this will happen on the rightmost character of the At this point just walk to the right until you hit the end at which point the balance factor will once again be So we just need to maintain the set across all of the queries and do these simple checks after each query to see if is walkable Complexity 
After rejecting 10 100 data structure problems Errorgorn is very angry at Anton and decided to kill him Anton s DNA can be represented as a string a which only contains the characters there are only 4 distinct characters Errorgorn can change Anton s DNA into string b which must be a of a However Anton s body can defend against this attack In 1 second his body can swap 2 characters of his DNA to transform it back to a Anton s body is smart and will use the minimum number of moves To maximize the chance of Anton dying Errorgorn wants to change Anton s DNA the string that maximizes the time for Anton s body to revert his DNA But since Errorgorn is busy making more data structure problems he needs your help to find the best string B Can you help him ,"['//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>\'9\'||ch<\'0\') {\n\t\t\tch=getchar();\n\t\t\tif(ch==\'-\')fu=1;\n\t\t}\n\t\twhile(ch<=\'9\'&&ch>=\'0\') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>\'9\'||ch<\'0\') {\n\t\t\tch=getchar();\n\t\t\tif(ch==\'-\')fu=1;\n\t\t}\n\t\twhile(ch<=\'9\'&&ch>=\'0\') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0) {\n\t\t\tputchar(\'0\');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar(\'-\') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + \'0\' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\nll n,res;\nchar s[114514];\nstack<int>sta[200];\nint temp[114514];\nint c[114514];\nstring s1,s2,s3,s4,ans;\ninline void add(int pos) {\n\twhile(pos<=n) {\n\t\t++c[pos];\n\t\tpos+=(-pos&pos);\n\t}\n}\ninline int query(int pos) {\n\tint rt=0;\n\twhile(pos) {\n\t\trt+=c[pos];\n\t\tpos-=(-pos&pos);\n\t}\n\treturn rt;\n}\ninline ll ak() {\n\tF(i,1,n)c[i]=0;\n\tll rt=0;\n\tUF(i,n,1) {\n\t\trt+=query(temp[i]);\n\t\tadd(temp[i]);\n\t}\n\treturn rt;\n}\ninline ll check(string b) {\n\tb.insert(0,""#"");\n\tUF(i,n,1) {\n\t\tsta[s[i]].push(i);\n\t}\n\tF(i,1,n) {\n\t\ttemp[i]=sta[b[i]].top();\n\t\tsta[b[i]].pop();\n\t}\n\treturn ak();\n}\nint main() {\n\tF(fdafdas,1,read()) {\n\t\tscanf(""%s"",s+1);\n\t\tn=strlen(s+1);\n\t\tres=-1;\n\t\ts1.clear();\n\t\ts2.clear();\n\t\ts3.clear();\n\t\ts4.clear();\n\t\tF(i,1,n) {\n\t\t\tif(s[i]==\'A\')s1.push_back(\'A\');\n\t\t\tif(s[i]==\'N\')s2.push_back(\'N\');\n\t\t\tif(s[i]==\'O\')s3.push_back(\'O\');\n\t\t\tif(s[i]==\'T\')s4.push_back(\'T\');\n\t\t}\nll sss=check(s1+s2+s3+s4);if(sss>res){res=sss;ans=s1+s2+s3+s4;}\nsss=check(s1+s2+s4+s3);if(sss>res){res=sss;ans=s1+s2+s4+s3;}\nsss=check(s1+s3+s2+s4);if(sss>res){res=sss;ans=s1+s3+s2+s4;}\nsss=check(s1+s3+s4+s2);if(sss>res){res=sss;ans=s1+s3+s4+s2;}\nsss=check(s1+s4+s2+s3);if(sss>res){res=sss;ans=s1+s4+s2+s3;}\nsss=check(s1+s4+s3+s2);if(sss>res){res=sss;ans=s1+s4+s3+s2;}\nsss=check(s2+s1+s3+s4);if(sss>res){res=sss;ans=s2+s1+s3+s4;}\nsss=check(s2+s1+s4+s3);if(sss>res){res=sss;ans=s2+s1+s4+s3;}\nsss=check(s2+s3+s1+s4);if(sss>res){res=sss;ans=s2+s3+s1+s4;}\nsss=check(s2+s3+s4+s1);if(sss>res){res=sss;ans=s2+s3+s4+s1;}\nsss=check(s2+s4+s1+s3);if(sss>res){res=sss;ans=s2+s4+s1+s3;}\nsss=check(s2+s4+s3+s1);if(sss>res){res=sss;ans=s2+s4+s3+s1;}\nsss=check(s3+s1+s2+s4);if(sss>res){res=sss;ans=s3+s1+s2+s4;}\nsss=check(s3+s1+s4+s2);if(sss>res){res=sss;ans=s3+s1+s4+s2;}\nsss=check(s3+s2+s1+s4);if(sss>res){res=sss;ans=s3+s2+s1+s4;}\nsss=check(s3+s2+s4+s1);if(sss>res){res=sss;ans=s3+s2+s4+s1;}\nsss=check(s3+s4+s1+s2);if(sss>res){res=sss;ans=s3+s4+s1+s2;}\nsss=check(s3+s4+s2+s1);if(sss>res){res=sss;ans=s3+s4+s2+s1;}\nsss=check(s4+s1+s2+s3);if(sss>res){res=sss;ans=s4+s1+s2+s3;}\nsss=check(s4+s1+s3+s2);if(sss>res){res=sss;ans=s4+s1+s3+s2;}\nsss=check(s4+s2+s1+s3);if(sss>res){res=sss;ans=s4+s2+s1+s3;}\nsss=check(s4+s2+s3+s1);if(sss>res){res=sss;ans=s4+s2+s3+s1;}\nsss=check(s4+s3+s1+s2);if(sss>res){res=sss;ans=s4+s3+s1+s2;}\nsss=check(s4+s3+s2+s1);if(sss>res){res=sss;ans=s4+s3+s2+s1;}\n\t\tputs(ans.c_str());\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 1, 1, 1, 0, 0, 0]",2200,We claim that in the optimal answer all characters of some type will appear consecutively ProofConsider the character at position in string We define as the position in which that character will be in string For and Then the minimum number of moves to transformed to is given by the inversion index of Suppose we find a substring of where it is where characters can be either one of The square brackets are just for clarity of explanation We will show that it our solution will not be worse if we merge these contiguous segments of Consider transforming the string into and Let the difference in the number of moves be and respectively And let the index of s be and respectively Then and where or rather is the sign function I claim that Suppose that then there exist such that which implies and However this implies that which is clearly a contradiction Since either or WLOG This implies that we turn into without decreasing the number of moves to transform into Now consider the rest of the on the left segment of We can move it too the right also Recall that In this case we know that as it is the cost to move the left back to its original position So Therefore we have merged different segments of without decreasing the number of moves to transform into So we can try all possible strings and check the number of moves Anton s body needs to transform each string The time limit is relaxed enough for a similar to 1430E String Reversal But there is a solution the number of moves Anton s body needs to transform each string is given by the number of inversions in the string But since we know that we only care about strings that have all the same characters appear consecutively we can just keep a count of the number of inversions for each pair of characters 
There are n shovels in the nearby shop The i th shovel costs a i bourles Misha has to buy k shovels Each shovel can be bought Misha can buy shovels by several purchases During one purchase he can choose any subset of remaining non bought shovels and buy this subset There are also m special offers in the shop The j th of them is given as a pair x j y j and it means that if Misha buys x j shovels then y j of them are for free i e he will not pay for y j most cheapest shovels during the current purchase Misha can use any offer any possibly zero number of times but he cannot use offer during but he can buy shovels without using any offers Your task is to calculate the minimum cost of buying k shovels if Misha buys them optimally ,"[""// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nconst size_t N = 2000 + 5;\n\nint main() {\n  int n = read(), m = read(), k = read();\n  vector<int> a(n + 1);\n  generate(a.begin() + 1, a.end(), read);\n  sort(a.begin() + 1, a.end());\n  a.erase(a.begin() + k + 1, a.end());\n  vector<int> sum(a.size());\n  partial_sum(a.begin(), a.end(), sum.begin());\n\n  vector<int> mx(k + 1), dp(k + 1, INT_MAX);\n  for (int i = 0; i < m; ++i) {\n    int x = read(), y = read();\n    if (x <= k && mx[x] < y) mx[x] = y;\n  }\n\n  dp[0] = 0;\n\n  auto chkMin = [](int &dp, int val) {\n    if (val < dp) dp = val;\n  };\n\n  for (int i = 0; i < k; ++i) {\n    for (int j = 1; i + j <= k; ++j) {\n      chkMin(dp[i + j], dp[i] + sum[i + j] - sum[i + mx[j]]);\n    }\n  }\n\n  cout << dp[k] << '\\n';\n  return 0;\n}\n""]","[1, 0, 0, 1, 0, 0, 0, 0, 1, 0]",2100,First of all since we are going to buy exactly shovels we may discard most expensive shovels from the input and set and solve the problem which requires us to buy all the shovels Also let s add an offer which allows us to buy shovel and get cheapest of them for free to simulate that we can buy shovels without using offers Now we claim that if we sort all the shovels by their costs it s optimal to divide the array of costs into some consecutive subarrays and buy each subarray using some offer Why should the sets of shovels for all purchases be consecutive subarrays Suppose it s not so let s pick two purchases such that they are mixed in the array of costs i e there exists at least one shovel bought in the first purchase such that there exists a shovel cheaper than it and a shovel more expensive than it both bought in the second purchase If shovel is for free then we may swap shovels and otherwise we may swap shovels and and the answer won t become worse So we can do it until all purchases correspond to subsegments in the array of costs Then it s easy to see that we can make purchases in such a way that we always buy some amount of cheapest shovels And now the problem can be solved by knapsack like dynamic programming let be the minimum cost to buy exactly cheapest shovels is and for each offer we can update by the value of where is the sum of costs of all shovels in the sorted order from shovel on position to shovel on position inclusive these sums can be calculated in using partial sums method 
You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 The jury picked an integer x not less than 0 and not greater than 2 14 1 You have to guess this integer To do so you may ask no more than 2 queries Each query should consist of 100 integer numbers a 1 a 2 a 100 each integer should be not less than 0 and not greater than 2 14 1 In response to your query the jury will pick one integer i 1 le i le 100 and tell you the value of a i oplus x the bitwise XOR of a i and x There is an additional constraint on the queries all 200 integers you use in the queries should be distinct ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int ans = 0;\n    printf(""?"");\n    for(int i = 0; i < 100; i++) printf("" %d"", i);\n    puts("""");\n    fflush(stdout);\n    scanf(""%d"", &ans);\n    ans ^= ans & 127;\n    printf(""?"");\n    for(int i = 0; i < 100; i++) printf("" %d"", (i << 7) + 101);\n    puts("""");\n    fflush(stdout);\n    int tmp;\n    scanf(""%d"", &tmp);\n    ans += (tmp & 127) ^ 101;\n    return printf(""! %d\\n"", ans), fflush(stdout), 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1900,Suppose all integers we input in some query have the same value in the th bit Then no matter which is chosen by the jury we can always deduce whether the th bit in is or This leads us to a simple solution divide bits of into two groups of size In the first query submit integers having the same values in the bits from the first group and deduce the values of these bits in In the second query do the same for the second group Be careful to avoid submitting the same integer twice 
Little girl Susie accidentally found her elder brother s notebook She has many things to do more important than solving problems but she found this problem too interesting so she wanted to know its solution and decided to ask you about it So the problem statement is as follows Let s assume that we are given a weighted undirected graph here is the set of vertices is the set of edges The shortest path tree from vertex is such graph that is a tree with the set of edges that is the subset of the set of edges of the initial graph and the lengths of the shortest paths from to any vertex to and to are the same You are given a weighted undirected graph and vertex Your task is to find the shortest path tree of the given graph from vertex the total weight of whose edges is minimum possible ,"[""//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1e6 + 9;\ntypedef long long ll;\nconst ll oo = 1e18;\nset<pair<ll,pair<ll,ll> > > st;\nll par[Maxn];\nll dis[Maxn],wei[Maxn],vis[Maxn],len[Maxn];\nvector<pair<ll,ll> > al[Maxn];\nll ans = 0;\nvoid relax(int v){\n\tvis[v] = 1;\n\tfor(int i = 0; i < al[v].size();i++){\n\t\tint u = al[v][i].first,id = al[v][i].second,w = len[id];\n\t\tif(vis[u]) continue;\n\t\tst.erase(make_pair(dis[u],make_pair(wei[u],u)));\n\t\tif(dis[u] > dis[v] + w || dis[u] == dis[v] + w && w < wei[u]){\n\t\t\tpar[u] = id;\n\t\t\twei[u] = w;\n\t\t\tdis[u] = dis[v] + w;\n\t\t}\n\t\tst.insert(make_pair(dis[u],make_pair(wei[u],u)));\n\t}\n\treturn;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tint n,m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n;i++) dis[i] = oo;\n\tfor(int i = 0; i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v >> len[i];\n\t\t--u,--v;\n\t\tal[u].push_back(make_pair(v,i));\n\t\tal[v].push_back(make_pair(u,i));\n\t}\n\tint source;\n\tcin >> source;\n\tsource--;\n\tpar[source] = Maxn;\n\tdis[source] = 0;\n\trelax(source);\n\twhile(st.size()){\n\t\tpair<ll,pair<ll,ll> > cur = *(st.begin());\n\t\tst.erase(cur);\n\t\tll v = cur.second.second,w = cur.second.first;\n\t\tif(vis[v]) continue;\n\t\trelax(v);\n\t\tans += w;\n\t}\n\tcout << ans << endl;\n\tfor(int i = 0; i < n;i++){\n\t\tif(i != source){\n\t\t\tcout << par[i] + 1 << ' ';\n\t\t}\n\t}\n\treturn 0;\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2000,It s true that Dijkstra modification where in case of equal distances we take one with shorter last edge find an answer For prove that let s do some transformation with graph At first find all shortest paths from to other vertices Define as the length of shortest path from to After that we can delete some edges Specifically we can delete an edge with ends in and and weight if because it isn t contained in any shortest path so it isn t contained in shortest path tree After that we can direct all edges from vertices with less distance to vertices with greater distance because of all weight are positive It s easy to prove that if we take one edge that entering each vertex we have a shortest path tree Then we only need to take for each vertex minimal egde that entering this vertex Why Because we have to take at least one edge that entering each vertex to make a graph connected We can t take edges with less weights than minimal And if we take minimal edges that entering each vertex we will have an shortest path tree So that is minimal possible total wieght of shortest path tree You can see that Dijkstra with modification do exactly the same things Time complexity 
You are given a permutation a consisting of n numbers 1 2 n a permutation is an array in which each element from 1 to n occurs exactly once You can perform the following operation choose some subarray contiguous subsegment of a and rearrange the elements in it in any way you want But this operation cannot be applied to the whole array For example if a 2 1 4 5 3 and we want to apply the operation to the subarray a 2 4 the subarray containing all elements from the 2 nd to the 4 th then after the operation the array can become a 2 5 1 4 3 or for example a 2 1 5 4 3 Your task is to calculate the minimum number of operations described above to sort the permutation a in ascending order ,"['/*\n    author:  Maksim1744\n    created: 16.05.2021 11:02:10\n*/\n\n#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp   make_pair\n#define pb   push_back\n#define eb   emplace_back\n\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\n#define mine(a)    (*min_element((a).begin(), (a).end()))\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\n\ntemplate<typename T>             vector<T>& operator--            (vector<T> &v){for (auto& i : v) --i;            return  v;}\ntemplate<typename T>             vector<T>& operator++            (vector<T> &v){for (auto& i : v) ++i;            return  v;}\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T> &v){for (auto& i : v) is >> i;        return is;}\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>  v){for (auto& i : v) os << i << \' \'; return os;}\ntemplate<typename T, typename U> pair<T,U>& operator--           (pair<T, U> &p){--p.first; --p.second;            return  p;}\ntemplate<typename T, typename U> pair<T,U>& operator++           (pair<T, U> &p){++p.first; ++p.second;            return  p;}\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U> &p){is >> p.first >> p.second;        return is;}\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>  p){os << p.first << \' \' << p.second; return os;}\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\n\n#ifdef HOME\n#define SHOW_COLORS\n#include ""C:/C++ libs/print.cpp""\n#else\n#define show(...) void(0)\n#define mclock    void(0)\n#define shows     void(0)\n#define debug  if (false)\n#endif\n\nvoid test_case(int test) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    cin >> a;\n    if (is_sorted(a.begin(), a.end())) {\n        cout << 0 << \'\\n\';\n        return;\n    }\n    if (a[0] == 1 || a.back() == n) {\n        cout << 1 << \'\\n\';\n        return;\n    }\n    if (a[0] != n || a.back() != 1) {\n        cout << 2 << \'\\n\';\n        return;\n    }\n    cout << 3 << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int T;\n    cin >> T;\n    for (int test = 1; test <= T; ++test) {\n        test_case(test);\n    }\n\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",900,To solve the problem it is enough to consider several cases if the array is already sorted the answer is if or then you can sort the array in one operation by selecting the subarray or if and you can perform the sequence of operations and and sort the array on each of them you can t do it faster since you can t move both to position and to position in only operations otherwise the array can be sorted in operations 
This matrix M of size n times n contains only and without quotes The element in the i th row and the j th column i j is defined as M i j where 1 leq i j leq n We define a appearing in the i th row and the j th column 1 i j n if and only if M i j M i 1 j 1 M i 1 j 1 M i 1 j 1 M i 1 j 1 The following figure illustrates a cross appearing at position 2 2 in a 3 times 3 matrix X X X X X Your task is to find out the number of in the given matrix M Two are different if and only if they appear in different rows or columns ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 550;\nchar s[N][N];\n\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> s[i] + 1;\n\tint cn = 0;\n\tfor (int i = 2; i < n; i++)\n\t\tfor (int j = 2; j < n; j++) {\n\t\t\tif (s[i][j] == 'X' && s[i - 1][j - 1] == 'X' && s[i - 1][j + 1] == 'X' && s[i + 1][j - 1] == 'X' && s[i + 1][j + 1] == 'X') cn++;\n\t\t}\n\tcout << cn << endl;\t\t\n\treturn 0;\n}\n\t""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,The solution is simple Just check if can appear in every positions Two nesting for loops will be enough to solve this problem 
Arul has a array text a of length n He will take all subsequences text of length k k is odd of this array and find their median text What is the sum of all these values As this sum can be very large output it modulo 10 9 7 In other words print the remainder of this sum when divided by 10 9 7 text A binary array is an array consisting only of zeros and ones text An array b is a subsequence of an array a if b can be obtained from a by the deletion of several possibly zero or all elements Subsequences have to be contiguous text The median of an array of odd length k is the frac k 1 2 th element when sorted ,"['#include<bits/stdc++.h>using namespace std;int T,a[200005];const int mod=1e9+7;int power(int x,int y){\tint ret=1;\tdo{\t\tif(y&1)ret=1ll*ret*x%mod;\t\tx=1ll*x*x%mod;\t}while(y>>=1);\treturn ret;}int fact[200005],inv[200005];int C(int n,int m){\treturn 1ll*fact[n]*inv[m]%mod*inv[n-m]%mod;}int main(){\tfact[0]=1;inv[0]=1;\tfor(int i=1;i<=2e5;i++){\t\tfact[i]=1ll*fact[i-1]*i%mod;\t\tinv[i]=power(fact[i],mod-2);\t}\tcin>>T;\twhile(T--){\t\tint n,k;cin>>n>>k;\t\tfor(int i=1;i<=n;i++)cin>>a[i];\t\tint cnt=0;\t\tfor(int i=1;i<=n;i++)cnt+=a[i];\t\tint ans=0;\t\tfor(int i=k/2+1;i<=k;i++){\t\t\tif(cnt>=i&&(n-cnt)>=k-i){\t\t\t\tans=(ans+1ll*C(cnt,i)*C(n-cnt,k-i))%mod;\t\t\t}\t\t}\t\tcout<<ans<<endl;\t}\treturn 0;}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1500,Say the array has x ones and y zeroes If the median of a subsequence of length k is 1 then there are at least k2 1 ones in the array Let s iterate over the number of ones in the subsequence from k2 1 to x Suppose there are i ones Then there are k i zeroes The number of ways to choose i ones from x is xi that is x choose i this is the so called binomial coefficient Similarly the number of ways to choose k i zeroes from y of them is yk i Therefore the answer is the sum of xi yk i over all i from k2 1 to x You can compute binomial coefficients in many ways for example precomputing all factorials and then using the formula nk n n k k Depending on your implementation it can take O nlogMOD or O n logMOD time 
While most students still sit their exams the tractor college has completed the summer exam session In fact students study only one subject at this college the Art of Operating a Tractor Therefore at the end of a term a student gets only one mark a three satisfactory a four good or a five excellent Those who score lower marks are unfortunately expelled The college has students and oddly enough each of them can be on scholarship The size of the scholarships varies each term Since the end of the term exam has just ended it s time to determine the size of the scholarship to the end of next term The monthly budget for the scholarships of the Tractor college is rubles To distribute the budget optimally you must follow these rules The students who received the same mark for the exam should receive the same scholarship Let us denote the size of the scholarship in roubles for students who have received marks and for the exam as and respectively The values and must be integers and satisfy the inequalities Let s assume that show how many students received marks and for the exam respectively The budget of the scholarship should be fully spent on them that is Let s introduce function the value that shows how well the scholarships are distributed between students In the optimal distribution function takes the possible value Given the results of the exam and the budget size you have to find the optimal distribution of the scholarship ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <utility>\n\nusing namespace std;\n\nint n,s;\nint c3,c4,c5;\nint k4;\nint g;\nint X4;\n\nint gcd(int a, int b) {\n        while(b) {\n                int t = b;\n                b = a % b;\n                a = t;\n        }\n        return a;\n}\n\n#define mp make_pair\n\ntypedef long long LL;\n\npair<LL,LL> find_soln(LL a,LL b) {\n        if(b==0)return mp(1,0);\n        LL q = a / b;\n        LL r = a % b;\n        pair<LL,LL> temp = find_soln(b,r);\n        return mp(temp.second,temp.first-q*temp.second);\n}\n\nLL inf = (1LL<<40);\n\n#define TOO_HIGH (LLONG_MAX-1)\n#define TOO_LOW (LLONG_MAX-2)\n#define INF (LLONG_MAX-3)\n\nLL calc_value(LL k3, LL k5) {\n        if (k3 < 0) return TOO_HIGH;\n        if (k3 > k4 || k4 > k5) return TOO_LOW;\n        LL X3 = c3;\n        X3 *= k3;\n        LL X5 = c5;\n        X5 *= k5;\n        return llabs(X3-X4)+llabs(X4-X5);\n}\n\nint main() {\n        scanf(""%d %d"",&n,&s);\n        c3=c4=c5=0;\n        for(int i=0;i<n;i++){\n                int mark;\n                scanf(""%d"",&mark);\n                if (mark == 3)c3++;\n                if (mark == 4)c4++;\n                if (mark == 5)c5++;\n        }\n        g = gcd(c3,c5);\n        pair<pair<LL,int>,pair<int,int> > best;\n        best.first.first = INF;\n        for(k4=X4=0;X4<=s;k4++,X4+=c4) {\n                if ((s-X4)%g == 0) {\n                        pair<LL,LL> soln = find_soln(c3,c5);\n                        soln.first *= (s-X4)/g;\n                        soln.second *= (s-X4)/g;\n\n\n                        int t = c3 / g;\n                        int s = c5 / g;\n                        // solutions are soln.first - y * s, soln.second + y * t\n                        LL y = 0;\n                        LL value = calc_value(soln.first, soln.second);\n                        for (int add = 1<<20; add; add >>= 1) {\n                                while (true) {\n                                        LL newy = y - add;\n                                        LL newvalue;\n                                        newvalue=calc_value(soln.first - newy * s, soln.second + newy * t);\n                                        if (newvalue == TOO_HIGH || newvalue < value) {\n                                                value = min(newvalue, INF);\n                                                y = newy;\n                                        } else break;\n                                }\n                                while (true) {\n                                        LL newy = y + add;\n                                        LL newvalue;\n                                        newvalue=calc_value(soln.first - newy * s, soln.second + newy * t);\n                                        if (newvalue == TOO_LOW || newvalue < value) {\n                                                value = min(newvalue, INF);\n                                                y = newy;\n                                        } else break;\n                                }\n                        }\n                        best = min(best, mp(mp(value,int(soln.first-y*s)),mp(k4,int(soln.second+y*t))));\n                }\n        }\n        if (best.first.first >= INF) {\n                printf(""-1\\n"");\n        } else {\n                printf(""%d %d %d\\n"",best.first.second,best.second.first,best.second.second);\n        }\n        return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",2400,In this problem were given four integer numbers You had to find such that and is minimal Firstly brute force so that Than look at 4 cases according to the sign of the value in each modulus Lets see the case when and Than we have to minimize Also and Lets see diofant equation It can be that this equation doesn t have solution Lets see the case when equation has solution As than for minimization we have to minimize and maximize All solutions of diofant equation can be described by using one argument Than we have to find such segment that for all from it will fit above constrains such segment that for all from it will fit above constrains find intersection of this segments and if intersection isn t empty choose such that is maximal Similar you have to manage remain 3 cases and choose optimal values and for fixed Also you can note that in all cases minimized function is linear and in segment it has minimal value in one of its ends So we can only find such segments that for all from that segments will fit above constrains and calculate answer in the ends of this segments If for all fixed diofant equation doesn t have solution or intersections of the described segments are empty than answer is else we should find the best So the time complexity is brute force of and solving diofant equation for fixed 
Let text LCP s t be the length of the longest common prefix of strings s and t Also let s x dots y be the substring of s from index x to index y inclusive For example if s then s 1 dots 3 s 2 dots 5 You are given a string s of length n and q queries Each query is a pair of integer sets a 1 a 2 dots a k and b 1 b 2 dots b l Calculate sum limits i 1 i k sum limits j 1 j l text LCP s a i dots n s b j dots n for each query ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <string>\n\nusing namespace std;\n\nstruct SuffixDataStructure {\n  const std::vector<int> &a;\n  std::vector<int> sa;\n  std::vector<int> isa;\n  std::vector<int> lcp;\n  std::vector<int> lg;\n  std::vector<std::vector<int>> rmq;\n\n  // a[i]>=0\n  SuffixDataStructure(const std::vector<int> &a) : a(a) {\n    sa = suffix_array(a);\n    sa.insert(sa.begin(), a.size());\n    build_lcp();\n    build_rmq();\n  }\n\n  int get_lcp(int i, int j) {\n    if (i == j) {\n      return a.size() - std::max(i, j);\n    }\n    i = isa[i];\n    j = isa[j];\n    if (i > j) {\n      std::swap(i, j);\n    }\n    int k = __lg(j - i);\n    return std::min(rmq[k][i], rmq[k][j - (1 << k)]);\n  }\n\n  vector<int> suffix_array(vector<int> a) {\n    const int n = a.size();\n    if (n == 0) return {};\n    const int H = *max_element(begin(a), end(a)) + 1;\n    vector<bool> s(n);\n    vector<int> next(n), ss;\n    for (int i = n - 2; i >= 0; i--) {\n      s[i] = a[i] == a[i + 1] ? s[i + 1] : a[i] < a[i + 1];\n      if (!s[i] && s[i + 1]) ss.push_back(i + 1);\n    }\n    reverse(ss.begin(), ss.end());\n    for (int i = 0; i < ss.size(); i++) {\n      next[ss[i]] = i + 1 < ss.size() ? ss[i + 1] : n;\n    }\n    auto induced_sort = [&]() {\n      vector<int> sa(n, -1), L(H + 1);\n      for (int i = 0; i < n; i++) L[a[i] + 1]++;\n      for (int i = 0; i < H; i++) L[i + 1] += L[i];\n      auto S = L;\n      for (int i = (int)ss.size() - 1; i >= 0; i--) {\n        int j = ss[i];\n        sa[--S[a[j] + 1]] = j;\n      }\n      S = L;\n      sa[L[a[n - 1]]++] = n - 1;\n      for (int i = 0; i < n; i++) {\n        int j = sa[i] - 1;\n        if (j >= 0 && !s[j]) sa[L[a[j]]++] = j;\n      }\n      for (int i = n - 1; i >= 0; i--) {\n        int j = sa[i] - 1;\n        if (j >= 0 && s[j]) sa[--S[a[j] + 1]] = j;\n      }\n      return sa;\n    };\n    vector<int> rank(n);\n    int j = -1;\n    for (int i : induced_sort()) {\n      if (0 < i && s[i] && !s[i - 1]) {\n        if (j != -1) rank[i] = rank[j] + (next[i] - i != next[j] - j || !equal(a.begin() + i, a.begin() + next[i], a.begin() + j));\n        j = i;\n      }\n    }\n    vector<int> b;\n    for (int i : ss) b.push_back(rank[i]);\n    vector<int> tmp(ss);\n    ss.clear();\n    for (int i : suffix_array(b)) ss.push_back(tmp[i]);\n    return induced_sort();\n  }\n\n  void build_lcp() {\n    const int n = a.size();\n    isa.resize(n + 1);\n    lcp.assign(n + 1, 0);\n    for (int i = 0; i <= n; i++) {\n      isa[sa[i]] = i;\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n      int j = sa[isa[i] - 1];\n      k = std::max(0, k - 1);\n      while (i + k < n && j + k < n && a[i + k] == a[j + k]) {\n        k++;\n      }\n      lcp[isa[i] - 1] = k;\n    }\n  }\n\n  void build_rmq() {\n    const int n = lcp.size();\n    lg.resize(n + 1);\n    for (int i = 2; i <= n; i++) {\n      lg[i] = lg[i / 2] + 1;\n    }\n    const int m = lg[n];\n    rmq.assign(m + 1, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      rmq[0][i] = lcp[i];\n    }\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j + (1 << i) < n; j++) {\n        rmq[i + 1][j] = std::min(rmq[i][j], rmq[i][j + (1 << i)]);\n      }\n    }\n  }\n};\n\nconst long long inf = 1e9;\n\nstruct Stack {\n  vector<pair<int, long long>> a;\n  long long sum = 0;\n\n  void push() {\n    sum += inf;\n    a.emplace_back(inf, 1);\n  }\n\n  void cut(int k) {\n    long long s = 0;\n    while (!a.empty() && a.back().first >= k) {\n      s += a.back().second;\n      sum -= a.back().first * a.back().second;\n      a.pop_back();\n    }\n    sum += s * k;\n    a.emplace_back(k, s);\n  }\n\n  int total() {\n    int s = 0;\n    for (auto p : a) s += p.second;\n    return s;\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n  vector<int> a;\n  for (int i = 0; i < n; i++) {\n    a.push_back(s[i] - \'a\');\n  }\n  SuffixDataStructure sa(a);\n\n  while (q--) {\n    int u, v;\n    scanf(""%d %d"", &u, &v);\n    vector<int> a(u);\n    vector<int> b(v);\n    for (int i = 0; i < u; i++) scanf(""%d"", &a[i]), a[i]--, a[i] = sa.isa[a[i]];\n    for (int i = 0; i < v; i++) scanf(""%d"", &b[i]), b[i]--, b[i] = sa.isa[b[i]];\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    int i = 0;\n    int j = 0;\n    Stack A, B;\n    int p = -1;\n    long long ans = 0;\n    while (i < u || j < v) {\n      if (j == v || (i < u && a[i] < b[j])) {\n        int h = p == -1 ? 0 : sa.get_lcp(sa.sa[p], sa.sa[a[i]]);\n        p = a[i];\n        A.cut(h);\n        B.cut(h);\n        ans += B.sum;\n        A.push();\n        i++;\n      } else {\n        int h = p == -1 ? 0 : sa.get_lcp(sa.sa[p], sa.sa[b[j]]);\n        p = b[j];\n        A.cut(h);\n        B.cut(h);\n        ans += A.sum;\n        B.push();\n        j++;\n      }\n    }\n    printf(""%lld\\n"", ans);\n  }\n}\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2600,At first implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough For example it s a Suffix Array linear LCP Sparse Table Now we can compare two suffixes and by finding and comparing with We will process queries online Let current query be a pair of arrays and We will calculate answer in two parts To calculate the first sum we can sort all suffixes in lexicographical order and maintain some information for prefixes of What information we need to maintain We need some Data Structure which will hold of suffixes from When we process some we need just a total sum of all in the DS If we should add to the DS length of th suffix And when we move from to we must recalculate some Since is sorted all we need is to set In fact this Data Structure is just a In this we will hold for each length number of suffixes with we will hold only non zero values When we should add some suffix we manually increase some value by one Setting with can be done with decreasing maximum in while its more than It can be proven that there will be operations with for one query The total sum can be maintained in some global variable which will be recalculated each time changes To calculate the second sum we can just reverse and run the same algorithm So total complexity is 
Given a list of distinct values we denote with and the three smallest values in increasing order A permutation p 1 p 2 dots p n is if the following statement holds for all pairs l r with 1 le l l 2 le r le n If p l p r are not necessarily in this order the first and second minimum of p l p l 1 dots p r then the third minimum of p l p l 1 dots p r is either p l 1 or p r 1 You are given an integer n and a string s of length m consisting of characters and Count the number of permutations p 1 p 2 dots p n such that for all 1 le i le m p i p i 1 if s i p i p i 1 if s i As the result can be very large you should print it modulo 998 244 353 ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define vi vector <int>\n#define sz(a) ((int) (a).size())\n#define me(f, x) memset(f, x, sizeof(f))\n#define uint unsigned int \nusing namespace std;\nconst int mod = 998244353, _G = 3, N = (1 << 19), inv2 = (mod + 1) / 2;\n#define add(a, b) (a + b >= mod ? a + b - mod : a + b)\n#define dec(a, b) (a < b ? a - b + mod : a - b)\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) inv[mod % i] * (mod - mod / i) % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n}\nint C(int x, int y) {\n\treturn y < 0 || x < y ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint rt[N], Lim;\nvoid Pinit(int x) {\n\tfor(Lim = 1; Lim <= x; Lim <<= 1) ;\n\tfor(int i = 1; i < Lim; i <<= 1) {\n\t\tint sG = qpow (_G, (mod - 1) / (i << 1));\n\t\trt[i] = 1;\n\t\tL(j, i + 1, i * 2 - 1) rt[j] = (ll) rt[j - 1] * sG % mod;\n\t}\n}\nstruct poly {\n\tvector<int> a;\n\tint size() { return sz(a); }\n\tint & operator [] (int x) { return a[x]; }\n\tint v(int x) { return x < 0 || x >= sz(a) ? 0 : a[x]; }\n\tvoid clear() { vector<int> ().swap(a); }\n\tvoid rs(int x = 0) { a.resize(x); }\n\tpoly (int n = 0) { rs(n); }\n\tpoly (vector<int> o) { a = o; }\n\tpoly (const poly &o) { a = o.a; }\n\tpoly Rs(int x = 0) { vi res = a; res.resize(x); return res; }\n\tinline void dif() {\n\t\tint n = sz(a);\n\t\tfor (int l = n >> 1; l >= 1; l >>= 1) \n\t\t\tfor(int j = 0; j < n; j += l << 1) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint x = a[j + k], y = a[j + k + l];\n\t\t\t\t\ta[j + k] = add(x, y);\n\t\t\t\t\ta[j + k + l] = (ll) * w * dec(x, y) % mod;\n\t\t\t\t}\n\t}\n\tvoid dit () {\n\t\tint n = sz(a);\n\t\tfor(int i = 2; i <= n; i <<= 1) \n\t\t\tfor(int j = 0, l = (i >> 1); j < n; j += i) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint pa = a[j + k], pb = (ll) a[j + k + l] * *w % mod;\n\t\t\t\t\ta[j + k] = add(pa, pb), a[j + k + l] = dec(pa, pb);\n\t\t\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tfor(int i = 0, iv = qpow(n); i < n; i++) a[i] = (ll) a[i] * iv % mod;\n\t} \n\tfriend poly operator * (poly aa, poly bb) {\n\t\tif(!sz(aa) || !sz(bb)) return {};\n\t\tint lim, all = sz(aa) + sz(bb) - 1;\n\t\tfor(lim = 1; lim < all; lim <<= 1);\n\t\taa.rs(lim), bb.rs(lim), aa.dif(), bb.dif();\n\t\tL(i, 0, lim - 1) aa[i] = (ll) aa[i] * bb[i] % mod;\n\t\taa.dit(), aa.a.resize(all);\n\t\treturn aa;\n\t}\n\tpoly Inv() {\n\t\tpoly res, f, g;\n\t\tres.rs(1), res[0] = qpow(a[0]);\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = m << 1, f = res, g.rs(pn), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (*this).v(i);\n\t\t\tf.dif(), g.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit();\n\t\t\tfor(int i = 0; i < m; i++) g[i] = 0;\n\t\t\tg.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit(), res.rs(pn);\n\t\t\tfor(int i = m; i < min(pn, sz(a)); i++) res[i] = (mod - g[i]) % mod;\n\t\t} \n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly Shift (int x) {\n\t\tpoly zm (sz(a) + x);\n\t\tL(i, 0, sz(a) - 1) zm[i + x] = a[i];\n\t\treturn zm; \n\t}\n\tfriend poly operator * (poly aa, int bb) {\n\t\tpoly res(sz(aa));\n\t\tL(i, 0, sz(aa) - 1) res[i] = (ll) aa[i] * bb % mod;\n\t\treturn res;\n\t}\n\tfriend poly operator + (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = add(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tfriend poly operator - (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = dec(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tpoly & operator += (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator -= (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += mod - o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator *= (poly o) {\n\t\treturn (*this) = (*this) * o;\n\t}\n\tpoly Integ() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) + 1);\n\t\tL(i, 1, sz(a)) res[i] = (ll) a[i - 1] * inv[i] % mod;\n\t\treturn res;\n\t}\n\tpoly Deriv() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) - 1); \n\t\tL(i, 1, sz(a) - 1) res[i - 1] = (ll) a[i] * i % mod;\n\t\treturn res;\n\t}\n\tpoly Ln() {\n\t\tpoly g = ((*this).Inv() * (*this).Deriv()).Integ();\n\t\treturn g.rs(sz(a)), g;\n\t}\n\tpoly Exp() {\n\t\tpoly res(1), f; \n\t\tres[0] = 1;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf -= res.Ln(), (f[0] += 1) %= mod, res *= f, res.rs(pn); \n\t\t}\n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly pow(int x, int rx = -1) { // x : the power % mod; rx : the power % (mod - 1)\n\t\tif(rx == -1) rx = x;\n\t\tint cnt = 0;\n\t\twhile (a[cnt] == 0 && cnt < sz(a)) cnt += 1;\n\t\t\n\t\tpoly res = (*this);\n\t\tL(i, cnt, sz(a) - 1) res[i - cnt] = res[i];\n\t\tL(i, sz(a) - cnt, sz(a) - 1) res[i] = 0;\n\t\tint c = res[0], w = qpow (res[0]);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * w % mod;\n\t\tres = res.Ln();\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * x % mod;\n\t\tres = res.Exp();\n\t\tc = qpow (c, rx);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * c % mod;\n\t\t\n\t\tif((ll) cnt * x > sz(a)) L(i, 0, sz(a) - 1) res[i] = 0;\n\t\telse if(cnt) {\n\t\t\tR(i, sz(a) - cnt * x - 1, 0) res[i + cnt * x] = res[i];\n\t\t\tL(i, 0, cnt * x - 1) res[i] = 0; \n\t\t}\n\t\treturn res;\n\t}\n\tpoly sqrt(int rt = 1) {\n\t\tpoly res(1), f; \n\t\tres[0] = rt;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf += res * res, f.rs(pn), res.rs(pn), res = f * res.Inv(), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) res[i] = (ll) res[i] * inv2 % mod;\n\t\t} \n\t\treturn res;\n\t}\n\tvoid Rev() {\n\t\treverse(a.begin(), a.end());\n\t}\n} ;\n\nint n, m, f[N], g[N], ns;\nchar s[N];\n\nint dp[109][N], pw[N]; \nbool vis[109][N];\n\ninline DP(int l, int r) {\n\tif(r - l == 1) return 1;\n\tif(l > m) return pw[r - l - 2];\n\tif(s[l] == '>' || s[r - 1] == '<') return 0;\n\tif(r - l == 2) return 1;\n\tif(vis[l][r]) return dp[l][r];\n\tvis[l][r] = true;\n\treturn dp[l][r] = (DP(l, r - 1) + DP(l + 1, r)) % mod;\n}\n\nint h[N], tc[N]; \n\nvoid divide(int L, int R) {\n\tif(L == R) \n\t\treturn ;\n\tint mid = (L + R) >> 1;\n\tdivide(L, mid);\n\tpoly F(R - L + 1), G(mid - L + 1); \n\tL(i, 0, R - L) F[i] = tc[i];\n\tL(i, L, mid) G[i - L] = (ll) f[i] * ifac[i - 1] % mod;\n\tF *= G;\n\tL(i, mid + 1, R) (f[i] += (ll) F[i - L] * fac[i - 2] % mod) %= mod;\n\tdivide(mid + 1, R);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> (s + 1);\n\tinit(n << 1 | 1);\n\tPinit(n << 1 | 1);\n\t\n\tf[1] = g[n] = 1;\n\tpw[0] = 1;\n\tL(i, 1, n) pw[i] = (ll) pw[i - 1] * 2 % mod;\n\t\n\tpoly h(n + 1);\n\tL(i, 1, n) h[i] = (ll) pw[max(i - 2, 0)] * ifac[i] % mod; \n\th = h.Exp();\n\tL(i, 0, n) h[i] = (ll) h[i] * fac[i] % mod;\n\t\n\tL(i, 1, n) tc[i] = (ll) pw[max(i - 2, 0)] * ifac[i - 1] % mod; \n\tL(i, 2, n) if(s[i - 1] != '<') {\n\t\tint mn = min(i - 1, m);\n\t\tL(j, 1, mn) \n\t\t\t(f[i] += (ll) f[j] * DP(j, i) % mod * C(i - 2, j - 1) % mod) %= mod;\n\t}\n\tdivide(m + 1, n);\n\tR(i, n - 1, 1) if(s[i] != '>') {\n\t\tif(i <= m) {\n\t\t\tL(j, i + 1, n) \n\t\t\t\t(g[i] += (ll) g[j] * DP(i, j) % mod * C(n - i - 1, n - j) % mod) %= mod;\n\t\t} else g[i] = h[n - i];\n\t}\n\t\t\n\tL(i, 1, n) if(s[i - 1] != '<' && s[i] != '>')\n\t\t(ns += (ll) f[i] * g[i] % mod * C(n - 1, i - 1) % mod) %= mod; \n\tcout << ns << '\\n';\n\treturn 0;\n}""]","[0, 1, 0, 1, 0, 0, 1, 0, 0, 0]",3500,SolutionFirst of all let us state the following lemma which is sufficient to solve the problem in if one ignores the constraints given by the string We omit the proof as it is rather easy compared to the difficulty of the problem as a whole Lemma The following statements hold for a permutation is good if and only if and are good where If then is good if and only if and are good where If and then is good if and only if it is bitonic i e where Given we say that a permutation of is consistent if for any if if Informally speaking a permutation is consistent if it satisfies the constraints given by when it is written in the positions For let be the the number of good permutations which are consistent and respectively No additional conditions Start with End with Start with and end with Start with and end with For and let Informally speaking is if and only if it can be and is if and only if it can be Thanks to the Lemma one has the following relations For Analogous formula for and and For Analogous formula for The problem asks to compute Thanks to the formulas stated above it is straightforward to implement an solution Now we will tackle the hard task of optimizing it to In order to compute we will compute and for all We have the recurrence relation for Setting 1 is equivalent to for and also for This looks very similar to an identify between generating functions a derivative on the left a product on the right but for the fact that depends on two parameters To overcome this issue let us proceed as follows Notice that if we set to any of the functions it holds whenever Hence let us define and analogously With these new definitions 2 becomes for Let and So 3 simplifies to We precompute in the values of and for We can also precompute in the values of for In we compute also for all Thus in we can compute for all the values It is now time to start working with generating functions Let We know and at least the first coefficients and we want to compute Since we know Moreover 4 is equivalent to the ordinary differential equation This ODE is standard and its unique solution is given by Since the product of generating functions and the exponential of a generating function can be computed in we are able to obtain the values of for all and thus the values of Now let us see how to compute Since for all let us first compute for all By repeating verbatim the reasoning above we get that the generating function where is given by in this case So it remains only to compute for This can be done na vely in The overall complexity is 
Madoka as a child was an extremely capricious girl and one of her favorite pranks was drawing on her wall According to Madoka s memories the wall was a table of n rows and m columns consisting only of zeroes and ones The coordinate of the cell in the i th row and the j th column 1 le i le n 1 le j le m is i j One day she saw a picture Mahou Shoujo Madoka Magica and decided to draw it on her wall Initially the Madoka s table is a table of size n times m filled with zeroes Then she applies the following operation any number of times Madoka selects any rectangular subtable of the table and paints it in a chess coloring the upper left corner of the subtable always has the color 0 Note that some cells may be colored several times In this case the final color of the cell is equal to the color obtained during the last repainting For better understanding of the statement we recommend you to read the explanation of the first test Help Madoka and find some sequence of no more than n cdot m operations that allows you to obtain the picture she wants or determine that this is impossible ,"[""#include <bits/stdc++.h>\n\n#define f first\n#define s second\n//#define x first\n//#define y second\n//#define int li\n#define err if(debug_out)cout\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pld = pair<ld, ld>;\n\nconst int INF = 1e9 + 13;\nconst li INF64 = 1e18 + 13;\nconst int N = 3e5 + 13;\nconst int LOGN = 20;\nconst int K = 22;\nconst int M = 998244353;//1e9 + 7;\nconst int A = 26;\nconst ld eps = 1e-8;\n\nmt19937 rnd(45768);\n\n/*\n*/\n\nint sum(int a, int b) {\n    a += b;\n    return (a >= M ? a - M : a);\n}\n\nint mul(int a, int b) {\n    return a * 1ll * b % M;\n}\n\nint dif(int a, int b) {\n    return sum(a, M - b);\n}\n\nint pow2(int n, int k) {\n    if(k == 0)\n        return 1;\n\n    int pw = pow2(n, k / 2);\n    pw = mul(pw, pw);\n\n    return (k % 2 == 0 ? pw : mul(pw, n));\n}\n\n/*\n*/\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<string> a(n);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<vector<int>> res;\n    for(int i = n - 1; i >= 0; i--) {\n        for(int j = m - 1; j >= 0; j--) {\n            if(a[i][j] == '1') {\n                if(i > 0) {\n                    res.push_back({i - 1, j, i, j});\n                } else if(j > 0) {\n                    res.push_back({i, j - 1, i, j});\n                } else {\n                    cout << -1 << '\\n';\n                    return;\n                }\n            }\n        }\n    }\n\n    cout << res.size() << '\\n';\n    for(int i = 0; i < res.size(); i++) {\n        for(int x : res[i])\n            cout << x + 1 << ' ';\n        cout << '\\n';\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n}\n""]","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1300,According to the condition if the upper left cell is painted black then we cannot paint it that way Otherwise it is possible Let s colour the cells in the following order n m n m 1 n 1 n 1 m 1 1 Let the cell i j be colored black then if j 1 then just paint the rectangle i j 1 i j Otherwise if j 1 then we will color the rectangle i 1 j After such an operation no cells that we painted before will be repainted since they have one coordinate larger than ours and the cell itself will be painted black Thus we are able to paint the table for a maximum of n m 1 operations 
Andrewid the Android is a galaxy famous detective In his free time he likes to think about strings containing zeros and ones Once he thought about a string of length consisting of zeroes and ones Consider the following operation we choose any two positions in the string and if one them contains 0 and the other contains 1 then we are allowed to remove these two digits from the string obtaining a string of length as a result Now Andreid thinks about what is the minimum length of the string that can remain after applying the described operation several times possibly zero Help him to calculate this number ,"['#include <cstdio>\n\nint main() {\n  int N;\n  scanf(""%d\\n"", &N);\n  int res = 0;\n  for (int i = 0; i < N; ++i) {\n    char c;\n    scanf(""%c"", &c);\n    if (c == \'0\') res += 1; else res -= 1;\n  }\n  printf(""%d\\n"", res < 0 ? -res : res);\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900,If there still exist at least one and at least one in the string then there obviously exists either substring or substring or both and we can remove it The order in which we remove substrings is unimportant in any case we will make such operations Thus the answer is Time 
You are given an array a 1 a 2 ldots a n Find the number of tuples x y z such that 1 leq x leq y leq z leq n and f x y oplus f y z f x z We define f l r a l oplus a l 1 oplus ldots oplus a r where oplus denotes the bitwise XOR operation ,"['/*在发觉那一天 在那一天潮汛泛上高筑城墙时间请将一切证明*/#include<bits/stdc++.h>using namespace std;const int maxn=500005;int n,m,T,ans,flg;int a[maxn],s[maxn],h[maxn],tot[2][maxn];int main(){\tscanf(""%d"",&T);\twhile(T--){\t\tlong long ans=0;\t\tscanf(""%d"",&n);\t\tfor(int i=0;i<=1;i++)\t\t\tfor(int j=0;j<30;j++)\t\t\t\ttot[i][j]=0;\t\tfor(int i=1;i<=n;i++){\t\t\tscanf(""%d"",&a[i]),s[i]=s[i-1]^a[i];\t\t\th[i]=31-__builtin_clz(a[i]);\t\t\tfor(int j=0;j<30;j++)\t\t\t\tif((s[i]>>j)&1)\t\t\t\t\ttot[1][j]++;\t\t}//\t\t(s[x-1]^s[y])^(s[y-1]^s[z])>s[x-1]^s[z]//\t\ts[x]^a[x]^a[y]^s[z]>s[x-1]^s[z]\t\tfor(int i=1;i<=n;i++){\t\t\tint u=tot[0][h[i]],v=tot[1][h[i]];\t\t\tans+=1ll*u*v+1ll*(i-u)*(n-i+1-v);\t\t\tfor(int j=0;j<30;j++)\t\t\t\tif((s[i]>>j)&1)\t\t\t\t\ttot[0][j]++,tot[1][j]--;\t\t}\t\t/*for(int i=1;i<=n;i++)\t\t\tfor(int j=i;j<=n;j++)\t\t\t\tfor(int k=j;k<=n;k++)\t\t\t\t\tif((((s[i-1]^s[k])>>h[j])&1)==0)\t\t\t\t\t\tans++;*/\t\tprintf(""%lld\\n"",ans);\t}\treturn 0;}']","[0, 1, 0, 1, 0, 1, 0, 0, 0, 0]",1900,Let s start by first solving the problem for and extend the idea to later To solve for we ll find the smallest value that occurs with different frequencies on the two paths We ll solve an easier version by solving for two static arrays instead of solving the problem of two paths To find the smallest value that has a different frequency between the two arrays we can have a segment tree on the frequency array for each static array Then we can store the hash of each segment tree node and perform a descent to find the first point at which the hashes in the two segment trees differ The hash of a node is the polynomial hash of the subarray it corresponds to Now in order to use the same technique on the path we want the frequency array of the path To achieve this we can use persistent segment trees We define to be the segment tree that corresponds to the frequency array of the values on the path With the idea of persistence we can quickly compute for all when we root at To compute we can use this for every node in the segment tree that we want Hence we are able to get the segment tree for the two paths we need to compare in a query In our solution with the static arrays we used the polynomial hash to find the first point of difference between the two frequency arrays So we need a way to quickly compute the hash of the pseudo node we computed for If we have two frequency arrays where the hash of a node is the polynomial hash of the subarray that corresponds to that node Hence we can say Hence we can perform the same descent that we talked about earlier on the derived segment tree Now to solve this for you can perform a dfs on and keep entering nodes of the segment tree which have differing hashes until we find values The total time complexity comes out to 
The price of one yogurt at the Vosmiorochka store is a burles but there is a promotion where you can buy two yogurts for b burles Maxim needs to buy n yogurts When buying two yogurts he can choose to buy them at the regular price or at the promotion price What is the minimum amount of burles Maxim should spend to buy n yogurts ,"['#include<bits/stdc++.h>#define int long longusing namespace std;class Segment_Tree{public:\tstruct tree{\t\tint l,r,sum,maxx,minx,flag;\t}tr[800005];\tvoid pushup(int u){\t\ttr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\t\ttr[u].maxx=max(tr[u<<1].maxx,tr[u<<1|1].maxx);\t\ttr[u].minx=min(tr[u<<1].minx,tr[u<<1|1].minx);\t}\tvoid pushdown(int u){\t\tif(tr[u].flag){\t\t\ttr[u<<1].sum+=tr[u].flag*(tr[u<<1].r-tr[u<<1].l+1),tr[u<<1].maxx+=tr[u].flag,tr[u<<1].minx+=tr[u].flag,tr[u<<1].flag+=tr[u].flag;\t\t\ttr[u<<1|1].sum+=tr[u].flag*(tr[u<<1|1].r-tr[u<<1|1].l+1),tr[u<<1|1].maxx+=tr[u].flag,tr[u<<1|1].minx+=tr[u].flag,tr[u<<1|1].flag+=tr[u].flag;\t\t\ttr[u].flag=0;\t\t}\t}\tvoid build(int u,int l,int r){\t\tif(l==r){\t\t\ttr[u]={l,r,0,0,0,0};\t\t\treturn;\t\t}\t\ttr[u]={l,r};\t\tint mid=l+r>>1;\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\t\tpushup(u);\t}\tvoid change(int u,int l,int r,int k){\t\tif(l>r)return;\t\tif(tr[u].l>=l&&tr[u].r<=r){\t\t\ttr[u].sum+=k*(tr[u].r-tr[u].l+1);\t\t\ttr[u].maxx+=k,tr[u].minx+=k;\t\t\ttr[u].flag+=k;\t\t\treturn;\t\t}\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1;\t\tif(l<=mid)change(u<<1,l,r,k);\t\tif(r>mid)change(u<<1|1,l,r,k);\t\tpushup(u);\t}\tint query_sum(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=0;\t\tif(l<=mid)res+=query_sum(u<<1,l,r);\t\tif(r>mid)res+=query_sum(u<<1|1,l,r);\t\treturn res;\t}\tint query_max(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].maxx;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=-1e18;\t\tif(l<=mid)res=max(res,query_max(u<<1,l,r));\t\tif(r>mid)res=max(res,query_max(u<<1|1,l,r));\t\treturn res;\t}\tint query_min(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].minx;;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=1e18;\t\tif(l<=mid)res=min(res,query_min(u<<1,l,r));\t\tif(r>mid)res=min(res,query_min(u<<1|1,l,r));\t\treturn res;\t}}sgt;int t,n,a,b;signed main(){\tcin>>t;\twhile(t--){\t\tcin>>n>>a>>b;\t\tint ans=1e18;\t\tfor(int i=0;i<=n;i++){\t\t\tif((n-i)&1)continue;\t\t\tans=min(ans,i*a+(n-i)/2*b);\t\t}\t\tcout<<ans<<""\\n"";\t}}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,You can always buy yogurts one by one without using the promotion then the answer is Suppose it is more advantageous to buy yogurts on promotion than one by one that is If is even the answer is otherwise Now you just need to choose whether to buy yogurts one by one or on promotion taking the minimum of the two options 
Polycarpus likes giving presents to Paraskevi He has bought two chocolate bars each of them has the shape of a segmented rectangle The first bar is segments large and the second one is segments large Polycarpus wants to give Paraskevi one of the bars at the lunch break and eat the other one himself Besides he wants to show that Polycarpus s mind and Paraskevi s beauty are equally matched so the two bars must have the same number of squares To make the bars have the same number of squares Polycarpus eats a little piece of chocolate each minute Each minute he does the following he either breaks one bar exactly in half vertically horizontally and of the bar or he chips of exactly one third of a bar vertically or horizontally and of the bar In the first case he is left with a of the bar and in the second case he is left with of the bar Both variants aren t always possible and sometimes Polycarpus cannot chip off a half nor a third For example if the bar is then Polycarpus can chip off a half but not a third If the bar is then Polycarpus can chip off both a half and a third If the bar is then Polycarpus cannot chip off a half nor a third What is the minimum number of minutes Polycarpus needs to make two bars consist of the same number of squares Find not only the required minimum number of minutes but also the possible sizes of the bars after the process ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint n, m, x, c[1000001];\nmap<int, int> a1, a2, v1, v2;\nmap<long long, int> a, v;\n\nint main(){\n     //freopen(""d.in"", ""r"", stdin);\n     //freopen(""d.out"", ""w"", stdout);\n     scanf(""%d"", &x); a1.clear();\n     c[1] = x; a1[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a1[m / 2])\n               a1[m / 2] = a1[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a1[m / 3])\n               a1[m / 3 * 2] = a1[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     \n     scanf(""%d"", &x); a2.clear();\n     c[1] = x; a2[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a2[m / 2])\n               a2[m / 2] = a2[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a2[m / 3])\n               a2[m / 3 * 2] = a2[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     v1 = a1; v2 = a2;\n     \n     scanf(""%d"", &x); a1.clear();\n     c[1] = x; a1[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a1[m / 2])\n               a1[m / 2] = a1[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a1[m / 3])\n               a1[m / 3 * 2] = a1[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     scanf(""%d"", &x); a2.clear();\n     c[1] = x; a2[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a2[m / 2])\n               a2[m / 2] = a2[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a2[m / 3])\n               a2[m / 3 * 2] = a2[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     int ans = 0, x = 0, y = 0, z = 0, k = 0, Min1 = 1 << 30, Min2 = 1 << 30;\n     a.clear(); v.clear();\n     for (map<int, int>::iterator itr = a1.begin(); itr != a1.end(); itr++)\n          for (map<int, int>::iterator itr1 = a2.begin(); itr1 != a2.end(); itr1++)\n          {\n               if (a.find(1LL * itr->first * itr1->first) == a.end() || \n               itr->second + itr1->second - 2 < a[1LL * itr->first * itr1->first])\n               a[1LL * itr->first * itr1->first] = itr->second + itr1->second - 2,\n               v[1LL * itr->first * itr1->first] = itr->first;\n          }\n               \n     for (map<int, int>::iterator itr = v1.begin(); itr != v1.end(); itr++)\n          for (map<int, int>::iterator itr1 = v2.begin(); itr1 != v2.end(); itr1++)\n               if (a.find(1LL * itr->first * itr1->first) != a.end())\n               {\n                    int value = a[1LL * itr->first * itr1->first] + itr->second + \n                        itr1->second - 2;\n                    if (value < Min1) Min1 = value,\n                    x =  v[1LL * itr->first * itr1->first], y = 1LL * itr->first * itr1->first / x,\n                    z = itr->first, k = itr1->first;\n               }\n     if (Min1 == 1 << 30) printf(""-1\\n"");\n     else printf(""%d\\n%d %d\\n%d %d\\n"", Min1, z, k, x, y);\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0]",1900,We can change the numbers by dividing their by two or by dividing their by three and multiply two Firstly remove all 2 and 3 from factorization of chocolate and determine equals their square or not If their squares are not equals answer doesn t exists Otherwise calculate of difference between number of three in factorization we should remove this amount of threes from the some chocolate it depends from the sign and recalculate difference between number of two in factorization and do the same 
Polycarp has n friends the i th of his friends has a i candies Polycarp s friends do not like when they have different numbers of candies In other words they want all a i to be the same To solve this Polycarp performs the following set of actions exactly Polycarp chooses k 0 le k le n arbitrary friends let s say he chooses friends with indices i 1 i 2 ldots i k Polycarp distributes their a i 1 a i 2 ldots a i k candies among all n friends During distribution for each of a i 1 a i 2 ldots a i k candies he chooses new owner That can be any of n friends Note that any candy can be given to the person who has owned that candy before the distribution process Note that the number k is not fixed in advance and can be arbitrary Your task is to find the minimum value of k For example if n 4 and a 4 5 2 5 then Polycarp could make the following distribution of the candies Polycarp chooses k 2 friends with indices i 2 4 and distributes a 2 a 4 10 candies to make a 4 4 4 4 two candies go to person 3 Note that in this example Polycarp cannot choose k 1 friend so that he can redistribute candies so that in the end all a i are equal For the data n and a determine the value k With this value k Polycarp should be able to select k friends and redistribute their candies so that everyone will end up with the same number of candies ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nll n,m,i,j,k,t,t1,u,v,a,b;\nll arr[200001];\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n;\n        u=0;\n        for (i=1;i<=n;i++)\n        {\n            cin>>arr[i];\n            u+=arr[i];\n        }\n        if (u%n)\n        {\n            cout<<-1<<endl;\n        }\n        else\n        {\n            a=0;\n            for (i=0;i<n;i++) if (arr[i+1]>u/n) a++;\n            cout<<a<<endl;\n        }\n    }\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Let s denote for the number of candies all friends have Note that at the end each friend must have of candy If is not completely divisible by then there is no answer How to get the answer if it exists If the th friend has more candies than then he must be chosen by Polycarp otherwise this friend will have more candies than the others If the th friend has no more than then Polycarp may not choose it Then if the answer exists it is equal to the number of 
In a kindergarten the children are being divided into groups The teacher put the children in a line and associated each child with his or her integer charisma value Each child should go to exactly one group Each group should be a nonempty segment of consecutive children of a line A group s is the maximum difference of charisma of two children in the group in particular if the group consists of one child its sociability equals a zero The teacher wants to divide the children into some number of groups in such way that the total of the groups is maximum Help him find this value ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nconst int MAXN = 1000010;\nint a[MAXN];\ni64 dp[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    scanf(""%d"", &N);\n    forn(i, N) scanf(""%d"", &a[i]);\n    dp[0] = dp[1] = 0;\n    int extr = 0;\n    bool ismin = true, ismax = true;\n    for (int i = 1; i < N; ++i) {\n        if (a[i] == a[i - 1]) {\n            extr = i - 1;\n            ismin = ismax = true;\n        }\n        if (a[i] < a[i - 1] && ismin) {\n            extr = i - 1;\n            ismax = true;\n            ismin = false;\n        }\n        if (a[i] > a[i - 1] && ismax) {\n            extr = i - 1;\n            ismin = true;\n            ismax = false;\n        }\n        dp[i + 1] = abs(a[i] - a[extr]) + dp[extr];\n        dp[i + 1] = max(dp[i + 1], abs(a[i] - a[extr + 1]) + dp[extr + 1]);\n    }\n    cout << dp[N] << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[1, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2400,Let us note that in optimal answer any segment that making a group contains their minimum and maximum values on borders Otherwise it will be better to split this segment to two other segments Another note that is every segment in optimal solution is strictly monotonic increasing or decreasing Paying attention to the interesting points in sequence which making local maximums i e local minimums and point adjacent to them Solve the problem by dynamic programming is the answer in the prefix To calculate we need to look at no more than three previous interesting points and to previous Total time complexity is 
Pak Chanek has just bought an empty fish tank and he has been dreaming to fill it with his favourite kind of fish clownfish Pak Chanek likes clownfish because of their ability to change their genders on demand Because of the size of his fish tank Pak Chanek wants to buy exactly k clownfish to fill the tank Pak Chanek goes to the local fish shop The shop provides n clownfish numbered from 1 to n with clownfish i having a size of a i Initially every clownfish in the store does not have an assigned gender but has the ability to be assigned to two possible clownfish genders female or male The store has a procedure which Pak Chanek should follow to buy clownfish The shop owner will point at each clownfish sequentially from 1 to n and for each clownfish she asks Pak Chanek whether to buy it or not Each time Pak Chanek is asked he must declare whether to buy the currently asked clownfish or not before the shop owner moves on to the next clownfish If Pak Chanek declares to buy the currently asked clownfish he must also declare the gender to be assigned to that clownfish immediately When assigning the gender for the currently asked clownfish the following conditions must be satisfied If Pak Chanek assigns it to be female and he has bought a female clownfish before then the size of the current one must be exactly 1 than the last female one If Pak Chanek assigns it to be male and he has bought a male clownfish before then the size of the current one must be exactly 1 than the last male one Pak Chanek wants to buy exactly k clownfish such that There is at least one female clownfish and one male clownfish Among the k clownfish Pak Chanek buys the mean size of the female clownfish is equal to the mean size of the male clownfish Let l and r respectively be the minimum and maximum of a clownfish Pak Chanek buys What is the minimum possible value of r l ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nint tab[nax];\n\nvi jump[nax][2];//0 to w dol, 1 to w gore\nint ost[nax];\n\nint musi[nax][2][2];\n\nint odw[nax][2][2];\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n\texit(0);\n}\n\nint policz(int h, int v)\n{\n\tint ret=0;\n\twhile(!jump[v][h].empty())\n\t{\n\t\tint x=jump[v][h].size();\n\t\tx--;\n\t\tret+=(1<<x);\n\t\tint ter=jump[v][h][x];\n\t\tv=ter;\n\t}\n\treturn ret;\n}\n\nint skocz(int h, int v, int ile)\n{\n\tint ory=v;\n\tfor (int i=0; (1<<i)<=ile; i++)\n\t{\n\t\tif (ile&(1<<i))\n\t\t{\n\t\t\tif ((int)jump[v][h].size()<=i)\n\t\t\t\treturn nax;\n\t\t\tint ter=jump[v][h][i];\n\t\t\tv=ter;\n\t\t}\n\t}\n\treturn ory-v;\n}\n\nvoid mini(int &a, int b)\n{\n\ta=min(a, b);\n}\n\nvoid calc()\n{\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tjump[i][0].clear();\n\t\tjump[i][1].clear();\n\t\tost[i]=0;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tost[tab[i]]=i;\n\t\tif (ost[tab[i]-1])\n\t\t\tjump[i][0].push_back(ost[tab[i]-1]);\n\t\tif (ost[tab[i]+1])\n\t\t\tjump[i][1].push_back(ost[tab[i]+1]);\n\t\tfor (int h=0; h<2; h++)\n\t\t{\n\t\t\tfor (int j=0; 1; j++)\n\t\t\t{\n\t\t\t\tif ((int)jump[i][h].size()<=j)\n\t\t\t\t\tbreak;\n\t\t\t\tint x=jump[i][h][j];\n\t\t\t\tif ((int)jump[x][h].size()<=j)\n\t\t\t\t\tbreak;\n\t\t\t\tint y=jump[x][h][j];\n\t\t\t\tjump[i][h].push_back(y);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int a=0; a<2; a++)\n\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\tmusi[i][a][b]=nax;\n\t\tint p0=policz(0, i);\n\t\tint p1=policz(1, i);\n\t\tif (p0+p1+1<k)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint bsa=0;\n\t\tint bsb=k-1;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb)/2;\n\t\t\tint s0=skocz(0, i, bss);\n\t\t\tint s1=skocz(1, i, k-1-bss);\n\t\t\tif (s0<s1)\n\t\t\t\tbsa=bss+1;\n\t\t\telse\n\t\t\t\tbsb=bss;\n\t\t}\n\t\tassert(skocz(0, i, bsa)>=skocz(1, i, k-1-bsa));\n\t\tfor (int j=max(0, bsa-2); j<=min(k-1, bsa+2); j++)\n\t\t{\n\t\t\tint s0=skocz(0, i, j);\n\t\t\tint s1=skocz(1, i, k-1-j);\n\t\t\tmini(musi[i][j>0][j<k-1], max(s0, s1));\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int a=0; a<2; a++)\n\t\t{\n\t\t\tfor (int b=0; b<2; b++)\n\t\t\t{\n\t\t\t\tmini(musi[i][a][0], musi[i][a][b]);\n\t\t\t\tmini(musi[i][0][b], musi[i][a][b]);\n\t\t\t\tmini(musi[i][0][0], musi[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tif (k&1)\n\t\tnope();\n\tk>>=1;\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\treverse(tab+1, tab+1+n);\n\tcalc();\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int a=0; a<2; a++)\n\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\todw[n+1-i][a][b]=musi[i][a][b];\n\treverse(tab+1, tab+1+n);\n\tcalc();\n\t//~ for (int i=1; i<=n; i++)\n\t//~ {\n\t\t//~ debug() << i;\n\t\t//~ for (int j=0; j<2; j++)\n\t\t\t//~ debug() << range(musi[i][j], musi[i][j]+2);\n\t\t//~ debug();\n\t\t//~ for (int j=0; j<2; j++)\n\t\t\t//~ debug() << range(odw[i][j], odw[i][j]+2);\n\t\t//~ debug();\n\t//~ }\n\tint wyn=nax;\n\tfor (int i=1; i<=n; i++)\n\t\tost[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=tab[i]-1; j<=tab[i]+1; j++)\n\t\t{\n\t\t\tif (!ost[j])\n\t\t\t\tcontinue;\n\t\t\tint g=ost[j];\n\t\t\tif (j<tab[i])\n\t\t\t{\n\t\t\t\tmini(wyn, i-g+musi[g][0][1]+odw[i][0][0]);\n\t\t\t\tmini(wyn, i-g+musi[g][0][0]+odw[i][1][0]);\n\t\t\t}\n\t\t\tif (j>tab[i])\n\t\t\t{\n\t\t\t\tmini(wyn, i-g+musi[g][1][0]+odw[i][0][0]);\n\t\t\t\tmini(wyn, i-g+musi[g][0][0]+odw[i][0][1]);\n\t\t\t}\n\t\t\tif (j==tab[i])\n\t\t\t{\n\t\t\t\tmini(wyn, i-g+musi[g][0][0]+odw[i][0][0]);\n\t\t\t}\n\t\t\t//~ debug() << imie(g) << imie(i) << imie(wyn);\n\t\t}\n\t\tost[tab[i]]=i;\n\t}\n\tif (wyn>=nax/2)\n\t\twyn=-1;\n\tprintf(""%d\\n"", wyn);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 1]",3500,We want to find two subsequences for the females and the males such that The female subsequence contains consecutively increasing values The male subsequence contains consecutively decreasing values The total length is exactly The mean values of both subsequences are the same For a group of consecutive values with minimum value and maximum value the mean is So we must make both values of the same We can obtain that since both means are equal the two subsequences must contain at least one common value And a common value can only occur twice in the entirety of the two subsequences For a way to choose the two subsequences let be a common value of the two subsequences such that the difference in indices of its two occurences is minimum Let and be the indices of the left and right occurences of respectively There are two cases either the is female and is male or vice versa If the is female the following must be true To the left in decreasing indices the chosen subsequence the female one has the values and so on To the right of in increasing indices the chosen subsequence the male one has the values and so on How about the values in the chosen subsequences that are bigger than Would they conflict in the indices between and Well since we choose with the minimum difference in indices of its two occurences then all values bigger than in the chosen subsequences that are located between and are either only from the female subsequence or only from the male subsequence So we only need to consider where for a fixed index that is either or To the left of that index in decreasing indices the chosen subsequence the male one has the values and so on To the right of that index in increasing indices the chosen subsequence the female one has the values and so on That means if is female there are two cases either choosing the index to be or If is male a similar thing also applies but the roles of the values smaller than and the values bigger than are switched so there are also two cases So there are only four cases in total Notice that in each of the four cases we can see it as having a pair of indices with the same value and having four legs of consecutive values coming out of it in four different directions Notice that the elements in different legs can never conflict with each other Each leg is independent Let s group the four legs into two groups the two left legs and the two right legs Next define and as the minimum and maximum value in the female subsequence and define and as the minimum and maximum value in the male subsequence It must hold that So Notice that is the total number of elements in the two left legs and is the total number of elements in the two right legs if we exclude and Since we want to make the number of elements in the two groups the same each group must contain exactly elements This means if is odd it is impossible We obtain that we can handle the two groups independently We just need to make sure the number of elements in one group is exactly We want to minimise the value of This means we want to maximise in the left group and minimise in the right group These two tasks are equivalent just mirrored To solve this let s construct a graph using the array Each element in the array has four parents The rightmost element to the left of it with value The rightmost element to the left of it with value The leftmost element to the right of it with value The leftmost element to the right of it with value For each type of parent construct the binary lifting for it so that for each element we can get its th parent of a certain for any value of in Using this in order to calculate the maximum value of of the left group we can do a binary search to find the optimal number of elements in each of the two left legs We do the same thing for the right group We do this for each of the four cases to finally find the minimum value of for a particular pair of We do that entire process repeatedly for all pairs of adjacent occurences of the same value Time complexity 
For two positive integers l and r l le r let c l r denote the number of integer pairs i j such that l le i le j le r and operatorname gcd i j ge l Here operatorname gcd i j is the greatest common divisor GCD of integers i and j YouKn0wWho has two integers n and k where 1 le k le n Let f n k denote the minimum of sum limits i 1 k c x i 1 x i 1 over all integer sequences 0 x 1 lt x 2 lt ldots lt x k lt x k 1 n Help YouKn0wWho find f n k ,"['/**\n *    author:  tourist\n *    created: 30.10.2021 18:42:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n\n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n\n  inline explicit operator bool() {\n    return cur != -1;\n  }\n\n  inline static bool is_blank(char c) {\n    return c <= \' \';\n  }\n\n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn\'t check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == \'-\') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - \'0\';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), ""%lf"", &n);\n    }\n    return *this;\n  }\n} fast_input;\n\n#define cin fast_input\n\nstatic struct FastOutput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t buf_pos = 0;\n  static constexpr int TMP_SIZE = 1 << 20;\n  char tmp[TMP_SIZE];\n  FILE *out = stdout;\n\n  inline void put_char(char c) {\n    buf[buf_pos++] = c;\n    if (buf_pos == BUF_SIZE) {\n      fwrite(buf, 1, buf_pos, out);\n      buf_pos = 0;\n    }\n  }\n\n  ~FastOutput() {\n    fwrite(buf, 1, buf_pos, out);\n  }\n\n  inline FastOutput& operator<<(char c) {\n    put_char(c);\n    return *this;\n  }\n\n  inline FastOutput& operator<<(const char* s) {\n    while (*s) {\n      put_char(*s++);\n    }\n    return *this;\n  }\n \n  inline FastOutput& operator<<(const string& s) {\n    for (int i = 0; i < (int) s.size(); i++) {\n      put_char(s[i]);\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline char* integer_to_string(T n) {\n    // beware of TMP_SIZE\n    char* p = tmp + TMP_SIZE - 1;\n    if (n == 0) {\n      *--p = \'0\';\n    } else {\n      bool is_negative = false;\n      if (n < 0) {\n        is_negative = true;\n        n = -n;\n      }\n      while (n > 0) {\n        *--p = (char) (\'0\' + n % 10);\n        n /= 10;\n      }\n      if (is_negative) {\n        *--p = \'-\';\n      }\n    }\n    return p;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {\n    return integer_to_string(n);\n  }\n\n  #if !defined(_WIN32) || defined(_WIN64)\n  inline char* stringify(__int128 n) {\n    return integer_to_string(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {\n    sprintf(tmp, ""%.17f"", n);\n    return tmp;\n  }\n\n  template <typename T>\n  inline FastOutput& operator<<(const T& n) {\n    auto p = stringify(n);\n    for (; *p != 0; p++) {\n      put_char(*p);\n    }\n    return *this;\n  }\n} fast_output;\n\n#define cout fast_output\n\nconst long long inf = (long long) 1e12;\n\nclass segtree {\n public:\n  struct node {\n    long long mn = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mn += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mn = min(a.mn, b.mn);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = (int) 1e5;\n  const int K = 16;\n  vector<int> phi(N + 1);\n  iota(phi.begin(), phi.end(), 0);\n  for (int i = 1; i <= N; i++) {\n    for (int j = i + i; j <= N; j += i) {\n      phi[j] -= phi[i];\n    }\n  }\n  vector<vector<int>> divs(N + 1);\n  for (int i = 1; i <= N; i++) {\n    for (int j = i; j <= N; j += i) {\n      divs[j].push_back(i);\n    }\n  }\n  vector<vector<long long>> res(K + 1, vector<long long>(N + 1, inf));\n  res[0][0] = 0;\n  for (int k = 1; k <= K; k++) {\n    segtree st(res[k - 1]);\n    for (int i = 1; i <= N; i++) {\n      for (int j : divs[i]) {\n        st.modify(0, j - 1, phi[i / j]);\n      }\n      res[k][i] = st.get(0, N).mn;\n    }\n  }\n  debug(clock());\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    if (k > K) {\n      cout << n << \'\\n\';\n    } else {\n      cout << res[k][n] << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3000,For now let denote the number of integer pairs such that instead of and So we can add to in the end We can construct a straightforward dp where As a straightforward implementation of takes time the total complexity of finding will be which is quite shameful Let s see how to do better It s easy to see why it holds when Let Following the tiny observation we can split the numbers as without spending a single penny Now we can solve in which is still shameful So we just have to find for and Let s optimize the calculation for Here We can calculate for all in and calculate in So currently we can solve our problem in which is still not to be proud of But notice that there can be at most distinct values in the sequence Check this for a proof So we can calculate in which improves our solution to But notice that as we can precalculate the suffix sums for each to over all distinct values of and then calculate in This preprocessing will take time and memory That means we can solve our problem which is promising satisfies quadrangle inequality that is for Let Here But clearly as So You can learn more about quadrangle inequality and how it is useful from here because I won t describe why it helps us here This suggests that we can solve this problem using Divide and Conquer DP or 1D1D DP which will optimize our part to To solve for multiple queries we can just precalculate for and Overall complexity where This problem can also be solved using Divide and Conquer DP and by calculating in in each level which runs pretty fast in practice for it takes less than 3s but I don t have a rigorous upper bound on the time complexity Check out my solution for more clarity 
Today Johnny wants to increase his contribution His plan assumes writing n blogs One blog covers one topic but one topic can be covered by many blogs Moreover some blogs have references to each other Each pair of blogs that are connected by a reference has to cover different topics because otherwise the readers can notice that they are split just for more contribution Set of blogs and bidirectional references between some pairs of them is called blogs network There are n different topics numbered from 1 to n sorted by Johnny s knowledge The structure of the blogs network is already prepared Now Johnny has to write the blogs in some order He is lazy so each time before writing a blog he looks at it s already written neighbors the blogs referenced to current one and chooses the topic with the smallest number which is not covered by neighbors It s easy to see that this strategy will always allow him to choose a topic because there are at most n 1 neighbors For example if already written neighbors of the current blog have topics number 1 3 1 5 and 2 Johnny will choose the topic number 4 for the current blog because topics number 1 2 and 3 are already covered by neighbors and topic number 4 isn t covered As a good friend you have done some research and predicted the best topic for each blog Can you tell Johnny in which order he has to write the blogs so that his strategy produces the topic assignment chosen by you ,"['/**\n *    author:  tourist\n *    created: 04.06.2020 17:34:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> t(n);\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n    --t[i];\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    return t[i] < t[j];\n  });\n  vector<int> was(n);\n  int T = 0;\n  for (int i : order) {\n    ++T;\n    int cnt = 0;\n    for (int j : g[i]) {\n      if (t[i] == t[j]) {\n        cout << -1 << \'\\n\';\n        return 0;\n      }\n      if (t[j] < t[i] && was[t[j]] != T) {\n        was[t[j]] = T;\n        cnt += 1;\n      }\n    }\n    if (cnt != t[i]) {\n      cout << -1 << \'\\n\';\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << order[i] + 1;\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 1, 1]",1700,We can view blogs as a graph references as edges and topics as colors Now we can reformulate our problem as finding a permutation of vertices such that given in the statement greedy coloring algorithm returns coloring as described in the input Let us start with two observations If there is an edge between vertices with the same color then the answer is If for a vertex with color there exist a color such that has no edge to any vertex with color then the answer is Both observations are rather straightforward to prove so we skip it Let us create permutation where vertices are sorted firstly by desired color and secondly by indices We claim that if there exists any ordering fulfilling given regulations then this permutation fulfills these too Let us prove it Let us analyze vertex with color From observation we know that for each color there exist with color such that and are connected by an edge Because vertices are sorted by colors in our permutation is before in ordering So the greedy algorithm will assign that vertex color From observation we now that does not have an edge to vertex with color so the greedy algorithm has to assign to color Combining both inequalities we reach that greedy must assign color which completes our proof So now the algorithm is rather straightforward sort vertices by colors check if that ordering fulfills given regulations if so then write it down otherwise print This can be implemented in or 
You are given an integer n You have to construct a permutation of size n A is an array where each integer from 1 to s where s is the size of permutation occurs exactly once For example 2 1 4 3 is a permutation of size 4 1 2 4 5 3 is a permutation of size 5 1 4 3 is not a permutation the integer 2 is absent 2 1 3 1 is not a permutation the integer 1 appears twice A of a permutation is a contiguous subsequence of that permutation For example the permutation 2 1 4 3 has 10 subsegments 2 2 1 2 1 4 2 1 4 3 1 1 4 1 4 3 4 4 3 and 3 The of the permutation is the number of its subsegments which are also permutations For example the value of 2 1 4 3 is 3 since the subsegments 2 1 1 and 2 1 4 3 are permutations You have to construct a permutation of size n with among all permutations of size n ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::cout << 1;\n    for (int i = n; i > 1; i--) {\n        std::cout << "" "" << i;\n    }\n    std::cout << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",800,The subsegment as well as the whole permutation will always be a permutation so the value is at least Let s try to find a way to generate a permutation of elements with value equal to Every permutation must contain the number Let s try to construct the answer in such a way that if a subsegment contains the number then it also contains the number if it is so it can only be a permutation if it contains all numbers If we begin our permutation with the numbers and we will reach our goal the only subsegment which does not contain but contains is and the only subsegment which contains and also a permutation is the whole permutation itself So any permutation that begins with can be the answer 
Ehab loves number theory but for some reason he hates the number x Given an array a find the length of its longest subarray such that the sum of its elements divisible by x or determine that such subarray doesn t exist An array a is a subarray of an array b if a can be obtained from b by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    unordered_set<int> rem;\n    int sum = 0;\n    for (auto &i : a) {\n      cin >> i;\n      (sum += i) %= x;\n      rem.insert(i % x);\n    }\n    if (sum != 0) {\n      cout << n << '\\n';\n    } else {\n      int l = 0, r = n - 1;\n      while (a[l] % x == 0 && l < n) {\n        l++;\n      }\n      while (a[r] % x == 0 && r >= 0) {\n        r--;\n      }\n      if (l < r) {\n        cout << max(n - (l + 1), r) << '\\n';\n      } else {\n        cout << -1 << '\\n';\n      }\n    }\n  }\n  return 0;\n}\n""]","[0, 0, 0, 0, 1, 1, 0, 0, 0, 0]",1200,Let s start with the whole array If every element in it is divisible by the answer is if its sum isn t divisible by the answer is Otherwise we must remove some elements The key idea is that removing an element that is divisible by doesn t do us any benefits but once we remove an element that isn t the sum won t be divisible by So let the first non multiple of be at index and the last one be at index We must either remove the prefix all the way up to or the suffix all the way up to and we ll clearly remove whichever shorter Code link https pastebin com j2Y8AJBA Alternatively we can notice that this means the answer is either a prefix or a suffix so we can simply bruteforce them all 
Now Serval is a junior high school student in Japari Middle School and he is still thrilled on math as before As a talented boy in mathematics he likes to play with numbers This time he wants to play with numbers on a rooted tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a node v is the last different from v vertex on the path from the root to the vertex v Children of vertex v are all nodes for which v is the parent A vertex is a leaf if it has no children The rooted tree Serval owns has n nodes node 1 is the root Serval will write some numbers into all nodes of the tree However there are some restrictions Each of the nodes except leaves has an operation max or min written in it indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons respectively Assume that there are k leaves in the tree Serval wants to put integers 1 2 ldots k to the k leaves each number should be used exactly once He loves large numbers so he wants to maximize the number in the root As his best friend can you help him ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 3e5;\n\nint n, f[MAXN], a[MAXN], dp[MAXN];\nvector<int> adj[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> a[i];\n\tfor(int i=1; i<n; ++i)\n\t\tcin >> f[i], --f[i], adj[f[i]].push_back(i);\n\tint nl=0;\n\tfor(int i=n-1; ~i; --i) {\n\t\tif(adj[i].size()==0) {\n\t\t\tdp[i]=1;\n\t\t\tnl++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(a[i]) {\n\t\t\tdp[i]=1e9;\n\t\t\tfor(int j : adj[i])\n\t\t\t\tdp[i]=min(dp[i],dp[j]);\n\t\t} else {\n\t\t\tdp[i]=0;\n\t\t\tfor(int j : adj[i])\n\t\t\t\tdp[i]+=dp[j];\n\t\t}\n\t}\n\n\tcout << nl+1-dp[0];\n\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 1, 0, 0]",1900,If we want to check whether is the answer I didn t say I want to do binary search then we can set all the numbers no less than as and the numbers less than as Then we can use to represent that the maximum number on node is the th smallest number of leaves within subtree of There should be at least ones in the subtree of such that the number on is one Then is the final answer Complexity 
Vasily has recently learned about the amazing properties of number In one of the articles it has been hypothesized that whatever the sequence of numbers we have in some position this sequence is found among the digits of number Thus if you take for example the epic novel War and Peace of famous Russian author Leo Tolstoy and encode it with numbers then we will find the novel among the characters of number Vasily was absolutely delighted with this because it means that all the books songs and programs have already been written and encoded in the digits of Vasily is of course a bit wary that this is only a hypothesis and it hasn t been proved so he decided to check it out To do this Vasily downloaded from the Internet the archive with the sequence of digits of number starting with a certain position and began to check the different strings of digits on the presence in the downloaded archive Vasily quickly found short strings of digits but each time he took a longer string it turned out that it is not in the archive Vasily came up with a definition that a string of length is a if it contains a substring of length of at least which occurs in the archive To complete the investigation Vasily took large numbers with the same number of digits and now he wants to find the number of numbers in the interval from to which are in the archive Help Vasily calculate this value modulo ,"['#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nint nxt[1005*55][10];\nint n;\n\nchar s[1005];\nint ln;\nint loc[1005][1005];\nint dep[1005*55];\n\nchar x[55];\nint d;\nbool alloweq;\n\n#define MOD 1000000007\nint cache[55][1005*55][2][2];\n\nint go(int di, int nd, int md, int ce) {\n    md |= dep[nd] >= d/2;\n    if (di == d) return md && (alloweq || ce == 0);\n    if (cache[di][nd][md][ce] != -1) return cache[di][nd][md][ce];\n    int uv = 9;\n    if (ce) uv = x[di]-\'0\';\n    long long res = 0;\n    FO(v,0,uv+1) res += go(di+1, nxt[nd][v], md, ce && v==uv);\n    return cache[di][nd][md][ce] = res % MOD;\n}\n\nint main() {\n    scanf("" %s"", s);\n    ln = strlen(s);\n    FO(i,0,ln) {\n        int c = 0;\n        FO(j,i,ln) {\n            int v = s[j]-\'0\';\n            if (!nxt[c][v]) {\n                nxt[c][v] = ++n;\n            }\n            c = nxt[c][v];\n            loc[i][j] = c;\n            dep[c] = j-i+1;\n            if (dep[c] > 50) break;\n        }\n    }\n    FO(dij,0,ln+1) FO(i,0,ln) {\n        int j = i+dij;\n        if (j < ln) {\n            FO(v,0,10) {\n                if (!nxt[loc[i][j]][v]) {\n                    nxt[loc[i][j]][v] = nxt[loc[i+1][j]][v];\n                }\n            }\n        }\n    }\n    scanf("" %s"", x);\n    d = strlen(x);\n    memset(cache,-1,sizeof cache);\n    alloweq = false;\n    int tmp = go(0,0,0,1);\n    scanf("" %s"", x);\n    memset(cache,-1,sizeof cache);\n    alloweq = true;\n    int tmp2 = go(0,0,0,1);\n\n    printf(""%d\\n"", (tmp2-tmp+MOD)%MOD);\n}\n\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0]",3200,The problem has been prepared by Edvard Consider all substrings of string with length Let s add them all to trie data structure calculate failure links and build automata by digits We can do that in linear time using Aho Korasik algorithm Now to solve the problem we should calculate dp State of dp is described by five numbers number of digits that we already put to our number in which vertex of trie we are equals to one if the prefix that we built is equals to prefix of equals to one if the prefix that we built is equals to prefix of equals to one if we already have some substring with length on the prexif that we built The value of dp is the number of ways to built prefix with the given set of properties To update dp we should iterate over the digit that we want to add to prefix check that we still is in segment go from vertex to the next vertex in automata So the answer is the sum by all Complexity 
You are given a string consisting of lowercase Latin letters Character is called dominant iff each substring of with length at least contains this character You have to find minimum such that there exists at least one dominant character ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nvoid build(){\n\n}\nchar c[ N ];\nint len;\nvoid init(){\n  cin >> c;\n  len = strlen( c );\n}\nint check( char cc ){\n  vector<int> vv;\n  int pre = -1 , mx = 0;\n  for( int i = 0 ; i < len ; i ++ )\n    if( c[ i ] == cc ){\n      mx = max( mx , i - pre );\n      pre = i;\n    }\n  mx = max( mx , len - pre );\n  return mx;\n}\nvoid solve(){\n  int ans = N;\n  for( int i = 0 ; i < 26 ; i ++ )\n    ans = min( ans , check( i + \'a\' ) );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0]",1400,At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity 
In the beginning of the new year Keivan decided to reverse his name He doesn t like palindromes so he changed Naviek to Navick He is too selfish so for a given he wants to obtain a string of characters each of which is either or with no of length appearing in the string as a substring For example the strings and suit him while the string doesn t He also want the number of letters in his string to be as little as possible ,"[""#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <bitset>\n#define fi first\n#define se second\n#define mkp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define per(i,b,a) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,a,b) for (int i=(a);i<=(b);i++)\n#define PER(i,b,a) for (int i=(b);i>=(a);i--)\nusing namespace std;\ntypedef long long LL;\n\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 1000005; // 1e6;\nint n;\nint main()\n{\n        cin>>n;\n        rep(i,0,n)\n        {\n                if (i%4==0) cout<<'a';\n                else if (i%4==1) cout<<'a';\n                else if (i%4==2) cout<<'b';\n                else if (i%4==3) cout<<'b';\n//                else cout<<'c';\n        }\n        cout<<endl;\n}\n""]","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1000,The answer is constructive as follows It is obvious there is no palindrome as substring and the number of characters is minimum possible equal to zero 
Vlad is planning to hold m rounds next month Each round should contain one problem of difficulty levels and Vlad already has a bank of n problems where the i th problem has a difficulty level of a i There may not be enough of these problems so he may have to come up with a few more problems Vlad wants to come up with as few problems as possible so he asks you to find the minimum number of problems he needs to come up with in order to hold m rounds For example if m 1 n 10 a then he needs to come up with two problems one of difficulty level and one of difficulty level ,"['#include <bits/stdc++.h>using namespace std;\xa0int main() {    int t; cin >> t;    while (t--) {        int n, m; cin >> n >> m;        map<char, int> mp;        string s; cin >> s;        for (char c: s) mp[c]++;        int ans = 0;        for (char c: string(""ABCDEFG"")) {            ans += max(0, m - mp[c]);        }        cout << ans << endl;    }}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,It is necessary to have at least problems of each difficulty level If there are already at least problems of difficulty level then there is no need to come up with more problems of this difficulty level Otherwise it is necessary to come up with problems where is the number of problems of difficulty level if more problems of this difficulty level are created the number will not be minimum 
Sereja placed points on a plane Now Sereja wants to place on the plane two straight lines intersecting at a right angle so that one of the straight lines intersect the axis at an angle of degrees and the maximum distance from the points to the straight lines were minimum In this problem we consider the distance between points and equal The distance between the point and the straight lines is the minimum distance from the point to some point belonging to one of the lines Help Sereja find the maximum distance from the points to the optimally located straight lines ,"['#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MAXN = 1<<18;\n\npair<LL,LL> pts[MAXN];\nLL minYL[MAXN],maxYL[MAXN],minYR[MAXN],maxYR[MAXN];\n\nconst LL INF = 2000000002;\nint main() {\n    int N;\n    scanf(""%d"",&N);\n    REP(i,N) {\n        int a,b;\n        scanf(""%d%d"",&a,&b);\n        pts[i].st = a - b;\n        pts[i].nd = a + b;\n    }\n\n    sort(pts, pts+N);\n    \n    minYL[0] = maxYL[0] = pts[0].nd;\n    FOR(i,1,N) {\n        minYL[i] = min(minYL[i-1], pts[i].nd);\n        maxYL[i] = max(maxYL[i-1], pts[i].nd);        \n    }\n\n    minYR[N-1] = maxYR[N-1] = pts[N-1].nd;\n    FORD(i,N-1,0) {\n        minYR[i] = min(minYR[i+1], pts[i].nd);\n        maxYR[i] = max(maxYR[i+1], pts[i].nd);        \n    }    \n    \n    LL L = 0, R = 4 * INF;\n    while (L < R) {\n        LL S = (L + R) / 2;\n        \n        bool can = false;\n        \n        int j = 0;\n        REP(i,N) {\n            while (j < N - 1 && pts[j+1].st - pts[i].st <= S) ++j;\n            if (i == 0 && j == N-1) can = true;\n            \n            LL minY = INF, maxY = -INF;\n            if (i > 0) {\n                minY = min(minY, minYL[i-1]);\n                maxY = max(maxY, maxYL[i-1]);\n            }\n            if (j < N - 1) {\n                minY = min(minY, minYR[j+1]);\n                maxY = max(maxY, maxYR[j+1]);\n            }\n            if (maxY - minY <= S) can = true;\n            \n            if (can) break;\n        }    \n        \n        if (can) R = S;\n        else L = S + 1;\n    }\n    \n    double result = L * 0.5;\n    printf(""%0.8lf\\n"", result);\n}    ']","[0, 0, 0, 0, 1, 0, 0, 1, 1, 0]",2500,Roll all at 45 degrees using the transformation x y x y x x y y x y Next you need to place two lines parallel to the coordinate axes Sort the points by the first coordinate Next we use a binary search for the answer May we have fixed a number you now need to check whether it is enough or not Note that now we need to put two strips of width 2 fixed amount that they would have to cover all the points Suppose that some point should be close to the left side of the vertical strip then for all points that do not belong to the strip we find the minimum and maximum second coordinate If the difference between the found coordinates no more then 2 fixed quantity the strip can be placed otherwise no 
A lighthouse keeper Peter commands an army of n battle lemmings He ordered his army to stand in a line and numbered the lemmings from 1 to n from left to right Some of the lemmings hold shields Each lemming cannot hold more than one shield The more protected Peter s army is the better To calculate the of the army he finds the number of protected pairs of lemmings that is such pairs that both lemmings in the pair don t hold a shield but there is a lemming with a shield between them Now it s time to prepare for defence and increase the protection of the army To do this Peter can give orders He chooses a lemming with a shield and gives him one of the two orders give the shield to the left neighbor if it exists and doesn t have a shield give the shield to the right neighbor if it exists and doesn t have a shield In one second Peter can give exactly one order It s not clear how much time Peter has before the defence So he decided to determine the maximal value of army protection for each k from 0 to frac n n 1 2 if he gives no more that k orders Help Peter to calculate it ,"['#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch==\'-\') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 80;\nint f[mxN+3][mxN*mxN/2ll+3][mxN+3],ans[mxN+3];\nint a[mxN+3],b[mxN+3];\nint n,m;\n\nvoid updmax(int &x,int y) {x = max(x,y);}\n\nint main()\n{\n\tn = read(); for(int i=1; i<=n; i++) {a[i] = read(); if(a[i]==1) b[++m] = i;}\n\tmemset(f,-1,sizeof(f)); f[0][0][0] = 0;\n\tfor(int i=0; i<m; i++)\n\t{\n\t\tfor(int j=0; j<=i*(n-i); j++)\n\t\t{\n\t\t\tfor(int k=i; k<=n; k++) if(f[i][j][k]>=0)\n\t\t\t{\n\t\t\t\tfor(int l=k+1; l<=n; l++)\n\t\t\t\t{\n\t\t\t\t\tupdmax(f[i+1][j+abs(l-b[i+1])][l],f[i][j][k]+(l-k-1)*(k-i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n*(n-1)/2; i++)\n\t{\n\t\tif(i>0) {ans[i] = ans[i-1];}\n\t\tfor(int j=m; j<=n; j++) if(f[m][i][j]>=0) {ans[i] = max(ans[i],f[m][i][j]+(n-j)*(j-m));}\n\t\tprintf(""%d "",ans[i]);\n\t}\n\tputs("""");\n\treturn 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2500,First let us denote as a conversion of the original sequence of In the beginning we will write down the number of zeros before the the first one Then we write down the number of zeros standing between the first and second ones then between the second and third ones and so on For example because there is one zero before the first one there are no zeros between the first and second ones there are three zeros between the second and third ones etc d It is not difficult to see that the original sequence can be unambiguously recovered with Now let us consider how will change if we change two different adjacent elements in the original sequence In this case two neighboring numbers will change in one of which will decrease by one and the other will increase by one The reversed statement is also true if we choose two neighboring numbers in one of them will increase by one and the other will decrease by one so that they both remain non negative this operation will correspond to an exchange of two neighboring elements in Let us name this operation choosing two neighboring numbers increasing one of them by one and reducing the other by one Let us consider such a task We have two arrays and We have to calculate the minimum amount of pouring operations we can turn into Obviously the sum of the numbers in and in must be the same To solve this let s try to split the array into two barriers standing after th position Then the array is split into two parts the left elements from to and the right elements from to For the left part of the array to have the same number of elements as in you need pouring operations involving and elements To sum up the number of necessary pouring operations for each pair of neighboring elements you have to sum for all from to It can be shown that the sum obtained will be the required number of pouring operations because since it is equal to zero only in case of equal arrays and each pouring operation will reduce it by no more than and there is always a transfusion that reduces this sum by So this subtask has been sorted out let s move on We have to learn how to read security for the sequence knowing It is not difficult to see that it is equal to We already know the value of it is equal to the number of zeroes in So we have to minimize Now we can finally get down to the task To do this let s try to build an optimal sequence of by applying no more than of transfusions Of course we need to use the dynamic programming of This means that we have looked at the first elements in and done with pouring operations so that equals The DP itself will store the minimum possible value of To get the answer we need to refer to where is the number of zeros in the original sequence And to recalculate the dynamics of we have to go through what will be as a result Let it be Then the answer recovery happens in the following way Here denotes in the original sequence The total asymptotic is in time and in memory although with a correct implementation the constant is very small the author s solution works for In this task there are solutions for but I will not describe them here 
You are given a array a with n elements where n is In each operation you can do the following Choose an index 1 le i le n and increase a i 1 by 1 a i by 2 and a i 1 by 1 The element before the first element is the last element because this is a cyclic array A cyclic array is called if all its elements are equal to each other Find any sequence of operations to make this cyclic array balanced or determine that it is impossible Please note that you have to minimize the number of operations ,"['#include <bits/stdc++.h>using namespace std;int t, n;long long a[1000020];long long s[1000020];int main(){\tcin >> t;\tfor (int tt = 0; tt < t; tt++)\t{\t\tcin >> n;\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\tcin >> a[i];\t\t}\t\tfor (int i = 0; i < 2 * n + 10; i++)\t\t{\t\t\ts[i] = 0;\t\t}\t\tfor (int i = 0; i < n - 1; i++)\t\t{\t\t\ts[i + 1] -= a[i];\t\t\ts[i + 2 + n] += a[i];\t\t\ta[i + 1] -= a[i];\t\t\ta[i] = 0;\t\t}\t\tfor (int i = 0; i < n - 1; i += 2)\t\t{\t\t\ts[i + 1] += a[n - 1];\t\t\ts[i + 2 + n] -= a[n - 1];\t\t}\t\tfor (int i = 0; i < 2 * n; i++)\t\t{\t\t\ts[i + 2] += s[i];\t\t}\t\tfor (int i = n; i < 2 * n; i++)\t\t{\t\t\ts[i % n] += s[i];\t\t}\t\tlong long mn = *min_element(s, s + n);\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\ts[i] -= mn;\t\t\tprintf(""%lld "", s[i]);\t\t}\t\tprintf(""\\n"");\t}\treturn 0;}']","[1, 1, 1, 0, 1, 0, 1, 0, 0, 0]",2400,To simplify this problem a little bit before starting we will temporarily allow negative operation choose an index and increase by by and by This is counted as operation on index Should we get negative elements in array in the end we can normalize it just fine by subtracting all with so that the final array is valid it s trivial to prove that applying the same amount of operations in all indices does not change the relative difference between any two values in the array Imagine we have and array where i e a trench This array always has at least one solution try to balance and by adding an amount of operation on either side based on their difference here we have something we ll denote as a balanced trench then add another amount of operations on index to balance them three and due to the cyclic nature of In fact every array with without regards to value intensity can be thought of this form if is higher than both and the act of raising is actually applying a negative amount of operations to index How to make a balanced trench for At least we can balance and in the same fashion as we did for Can we balance and without breaking the balance we achieved between and Assuming we have an array By logic we want to increase the value of index Applying an operation to index won t do as the new array would be We are balancing the inner elements by sacrificing the outer ones Applying an operation to index also won t do as it increases both sides Applying an operation to index will make the array become By applying another operation to index we ll reach our desired goal with array In fact a series of operations in consecutive indices of the same parity would have this effect regardless of how long that series is To be precise without loss of generality a series of operations in indices with will increase and by and all values with indices in range by The catch here is that we mitigate unit of difference between sides with each operation series by adding just unit to the higher side while the corresponding other would be further beyond the lower side If we aim to balance the sides from outwards to inwards that exceeding will either fall into a deeper inwards layer or the center of the array since is odd which will not harm whatever we have achieved at first Take an example with array First we ll balance index and index We can simply apply operations to index The new array would be Then we ll balance index and index From index we ll move to the left until it reaches index and apply operations for every steps In other words apply operations to index and operations to index This array is now a balanced trench Now achieving the desired array we ll call it a plateau from a balanced trench is easy starting from the rightmost element of the left side before the center going leftwards compare the value to its adjacent element to the right and apply a corresponding amount of operations Now take the balanced trench we just acquired First we ll check index Clearly we want to rise index to close the unit gap thus we ll apply operations to index The new array will become Then we ll check index Our objective is to decrease for all elements with indices in range Using the similar operation series as discussed earlier this can be done like this apply operations to index then apply operations to index The final array will be That operation series can be used here because the range of elements changing by units per series has an odd size and since we re growing the plateau from the center point outwards its size is always odd as well With this the non normalized array will be Implementing this method can be separated into two separate steps Step creating the balanced trench for each pair of indices with difference apply operations for each index of the cyclic range with step Step creating the plateau for each pair of indices with difference apply operations for each index of the range with step Some extra notes Each step requires an independent prefix sum structure to quickly maintain the operation updates Notice that the prefix sum here takes account of parity since only the other index in a range is updated not every one of them Remember that after each index considered its value will alter based on the amount of operations just applied on it so keep track of it properly To avoid confusion it s advised to apply the operations of step directly into array before proceeding with step Remember to normalize array before outputting to get rid of negative values Refer to the model solution for more details Time complexity 
You re given an array a You should repeat the following operation k times find the minimum non zero element in the array print it and then subtract it from all the non zero elements of the array If all the elements are 0s just print 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define _ << "" _ "" <<\n#define TRACE(x) cout << #x << "" = "" << x << endl\n\ntypedef long long ll;\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, k;\n    ll a[100010];\n    ll sum = 0;\n\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n\n    int t = 0;\n\n    for (int i = 0; i < k; i++) {\n        while (t < n && a[t] == sum) t++;\n        if (t == n) cout << ""0\\n"";\n        else {\n            cout << a[t] - sum << ""\\n"";\n            sum = a[t];\n        }\n    }\n\n\n\n\n    \n\n    return 0;\n}\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",1000,Let be the set of numbers in input sorted and distinct In the step is subtracted from all bigger or equal elements and all smaller elements are 0 Thus the answer in the step is Code link https pastebin com bpz1YxBe Time complexity 
There is a polyline going through points We know that the polyline passes through the point Find minimum positive value such that it is true or determine that there is no such ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst double INF = 1e18;\n\ndouble solve(ll x, ll y)\n{\n    ll k = x / (2 * y);\n    if (k == 0) return INF;\n    return (double)x / (double)(2 * k);\n}\n\nint main()\n{\n    ll x, y;\n    cin >> x >> y;\n    if (x < y)\n    {\n        printf(""-1\\n"");\n        return 0;\n    }\n    if (x == y)\n    {\n        printf(""%d\\n"", x);\n        return 0;\n    }\n    printf(""%.12lf\\n"", min(solve(x - y, y), solve(x + y, y)));\n\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700,If point a b is located on the up slope down slope of this polyline Then the polyline will pass the point a b 0 a b 0 we call a b or a b as c afterwards And we can derive that c 2 x should be a positive integer Another condition we need to satisfy is that x must be larger than or equal to b It s easy to show that when those two conditions are satisfied then the polyline will pass the point a b Formally speaking in math Let c 2 x y Then we have x c 2 y b and we want to find the maximum integer y After some more math derivation we can get the answer is Besides the only case of no solution is when a b In fact always dosn t exist or larger than 
Marin feels exhausted after a long day of cosplay so Gojou invites her to play a game Marin and Gojou take turns to place one of their tokens on an n times n grid with Marin starting first There are some restrictions and allowances on where to place tokens Apart from the first move the token placed by a player must be more than Manhattan distance k away from the previous token placed on the matrix In other words if a player places a token at x 1 y 1 then the token placed in the next move must be in a cell x 2 y 2 satisfying x 2 x 1 y 2 y 1 k Apart from the previous restriction a token can be placed anywhere on the matrix Whenever a player places a token on cell x y that player gets v x y points All values of v on the grid are You still get points from a cell even if tokens were already placed onto the cell The game finishes when each player makes 10 100 moves Marin and Gojou will play n 2 games For each cell of the grid there will be exactly one game where Marin places a token on that cell on her first move Please answer for each game if Marin and Gojou play optimally after Marin s first move who will have more points at the end Or will the game end in a draw both players have the same points at the end ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nvector <pair<int,int> > v;\nint c[2005][2005];\npair <int,int> a[4000005];\nchar ans[2005][2005];\ninline int D(int x,int y)\n{\n\treturn max(x,y)-min(x,y);\n}\ninline int dis(pair<int,int> a,pair<int,int> b)\n{\n\treturn D(a.first,b.first)+D(a.second,b.second);\n}\ninline void rebuild()\n{\n\tvector <pair<int,int> > V;\n\tpair <int,int> mx;\n\tfor(auto t:v) if(t.first+t.second>mx.first+mx.second) mx=t;\n\tV.push_back(mx);\n\tfor(auto t:v) if(t.first-t.second>mx.first-mx.second) mx=t;\n\tV.push_back(mx);\n\tfor(auto t:v) if(-t.first+t.second>-mx.first+mx.second) mx=t;\n\tV.push_back(mx);\n\tfor(auto t:v) if(-t.first-t.second>-mx.first-mx.second) mx=t;\n\tV.push_back(mx);\n\tswap(v,V);\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n,k;\n\tcin >> n >> k;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcin >> c[i][j];\n\t\t\ta[c[i][j]]={i,j};\n\t\t}\n\t}\n\tfor(int i=n*n;i>=1;i--)\n\t{\n\t\tint flag=1;\n\t\tfor(auto t:v)\n\t\t\tif(dis(t,a[i])>k) flag=0;\n\t\tif(flag)\n\t\t{\n\t\t\tans[a[i].first][a[i].second]=\'M\';\n\t\t\tv.push_back(a[i]),rebuild();\n\t\t}\n\t\telse ans[a[i].first][a[i].second]=\'G\';\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout << ans[i][j];\n\t\tcout << ""\\n"";\n\t}\n\treturn 0;\n}']","[0, 1, 1, 1, 1, 0, 0, 0, 1, 0]",2500,TutorialSuppose that Marin places a token at If Gojou places a token at where then Gojou would not have any advantage as Marin can play at again After a very huge number of turns Marin will have more points than Gojou Generally if a player is forced to play in a cell where they get fewer points than the previous move they would instantly lose Therefore we can rephrase the problem as such Apart from the first move the token placed by a player must be more than Manhattan distance k away from the previous token placed on the matrix Apart from the first move the token placed by a player must be on a cell with more points than the cell with the token placed by the previous player The player who plays the last token is the winner This turns out to be a standard dynamic programming Let return if the player who places a token at wins Let then we have as a base case Then we will fill the values of in decreasing values of if for all such that we have Note that by taking the contrapositive this is equivalent to for all such that we have Let us maintain a set that stores the pairs such that then our operations are adding point to given check if for all in Notice that Checking is very simple as we only need to store the minimum and maximum of all and 
Igor is a post graduate student of chemistry faculty in Berland State University BerSU He needs to conduct a complicated experiment to write his thesis but laboratory of BerSU doesn t contain all the materials required for this experiment Fortunately chemical laws allow material transformations yes chemistry in Berland differs from ours But the rules of transformation are a bit strange Berland chemists are aware of materials numbered in the order they were discovered Each material can be transformed into some other material or vice versa Formally for each there exist two numbers and that denote a possible transformation kilograms of material can be transformed into kilogram of material and kilogram of material can be transformed into kilogram of material Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is For each Igor knows that the experiment requires kilograms of material and the laboratory contains kilograms of this material Is it possible to conduct an experiment after transforming some materials or none ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\ntypedef long long LL;\nLL n , d[ N ] , p[ N ];\nvector< pair<LL,LL> > v[ N ];\nconst LL inf = 100000000000000000LL;\nvoid DP( int now ){\n  for( auto e : v[ now ] ){\n    LL son = e.first;\n    LL ki = e.second;\n    DP( son );\n    if( d[ son ] >= 0 )\n      d[ now ] += d[ son ];\n    else{\n      LL nd = -d[ son ];\n      if( nd >= inf / ki ){\n        puts( ""NO"" );\n        exit(0);\n      }\n      d[ now ] -= nd * ki;\n      if( d[ now ] < -inf ){\n        puts( ""NO"" );\n        exit(0);\n      }\n    }\n  }\n}\nint main(){\n  scanf( ""%lld"" , &n );\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( ""%lld"" , &x );\n    d[ i ] += x;\n  }\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( ""%lld"" , &x );\n    d[ i ] -= x;\n  }\n  for( LL i = 2 , x ; i <= n ; i ++ ){\n    scanf( ""%lld%lld"" , &p[ i ] , &x );\n    v[ p[ i ] ].push_back( { i , x } );\n  }\n  DP( 1 );\n  puts( d[ 1 ] >= 0 ? ""YES"" : ""NO"" );\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300,Since then the transformation graph is a tree Let s solve the problem recursively Suppose that material is a leaf in the tree there is no such that Then if we don t have enough material we have to transform some of material into Let s transform the amount required to set current amount of material to if we don t have the required amount of material then this amount will temporarily be negative And if we have more material than we need to conduct the experiment then we will transform it to The same algorithm can be applied to any non root node but we first need to do this for all its children This algorithm is optimal because each time we take the minimum possible amount from the parent After this the root will be the only node such that is not necessarily equal to current amount of material Since we solved the problem for all other materials and did it optimally now the answer is YES iff current amount of material is not less than This must be implemented carefully Since the total amount of materials never increases then if some material s current amount is less than for example then the answer is already NO Also overflows in multiplication must be avoided to do this we can firstly check if the result of multiplication is not too big by multiplying values as real numbers 
The end of the school year is near and Ms Manana the teacher will soon have to say goodbye to a yet another class She decided to prepare a goodbye present for her students and give each of them a jigsaw puzzle which as wikipedia states is a tiling puzzle that requires the assembly of numerous small often oddly shaped interlocking and tessellating pieces The shop assistant told the teacher that there are puzzles in the shop but they might differ in difficulty and size Specifically the first jigsaw puzzle consists of pieces the second one consists of pieces and so on Ms Manana doesn t want to upset the children so she decided that the difference between the numbers of pieces in her presents must be as small as possible Let be the number of pieces in the largest puzzle that the teacher buys and be the number of pieces in the smallest such puzzle She wants to choose such puzzles that is minimum possible Help the teacher and find the least possible value of ,"['#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nint n,m,Min,i,j,t,b[100],a[100];\nint main(){\n\tscanf(""%d"",&n);\n\tscanf(""%d"",&m);\n\tfor(i=1;i<=m;i++){\n\t\tscanf(""%d"",&a[i]);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=m;j>i;j--){\n\t\t\tif(a[i]>a[j]){ \n\t\t\tt=a[i];\n\t\t\ta[i]=a[j];\n\t\t\ta[j]=t;\n\t\t\t} \n\t\t}\n\t}\n\tfor(i=1;i<=m-n+1;i++){\n\t\tb[i]=a[i+n-1]-a[i];\n\t}\n\tMin=1000;\n\tfor(i=1;i<=m-n+1;i++){\n\t\tif(Min>b[i])\n\t\tMin=b[i];\n\t}\n\tprintf(""%d"",Min);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900,First let s sort the numbers f i in ascending order Now assume that the smallest jigsaw puzzle which the teacher purchases consists of f k pieces Obviously she should buy the smallest n puzzles which are of size f k or greater to minimize the difference These are the puzzles f k f k 1 f k n 1 this is not correct when f i are not distinct and f k f k 1 but such cases can be skipped The difference between the greatest and the least size of the puzzles in such set is f k n 1 f k To choose the optimal f k we can test every k between 1 and m n and pick the one producing the least difference The full algorithm is as follows 
Today Sakurako was studying arrays An array a of length n is considered good if and only if the array a is increasing meaning a i 1 a i for all 2 le i le n the differences between adjacent elements are increasing meaning a i a i 1 a i 1 a i for all 2 le i n Sakurako has come up with boundaries l and r and wants to construct a good array of maximum length where l le a i le r for all a i Help Sakurako find the maximum length of a good array for the given l and r ,"[""#include <bits/stdc++.h>using namespace std;\xa0namespace std {\xa0template <int D, typename T>struct Vec : public vector<Vec<D - 1, T>> {    static_assert(D >= 1);    template <typename... Args>    Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}};\xa0template <typename T>struct Vec<1, T> : public vector<T> {    Vec(int n = 0, T val = T()) : std::vector<T>(n, val) {}};\xa0template <class Fun>class y_combinator_result {    Fun fun_;\xa0   public:    template <class T>    explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\xa0    template <class... Args>    decltype(auto) operator()(Args &&...args) {        return fun_(std::ref(*this), std::forward<Args>(args)...);    }};\xa0template <class Fun>decltype(auto) y_combinator(Fun &&fun) {    return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));}\xa0}  // namespace std\xa0int32_t main() {    ios_base::sync_with_stdio(0);    cin.tie(0);\xa0    int t;    cin >> t;    while (t--) {        int l, r;        cin >> l >> r;        int n = r - l;        int x = sqrt(n * 2);        while (x * (x - 1) / 2 <= n) x++;        while (x * (x - 1) / 2 > n) x--;        cout << x << '\\n';    }}""]","[0, 1, 0, 0, 0, 1, 0, 1, 0, 0]",800,We can solve this problem greedily Let s choose the first element equal to Then the second element should be The third and so on In general the th element is equal to Proof of this solution Assume that array is the array made by our algorithm and is the array with a better answer This means that By the construction of there exists an integer such that for all and because we choose as the smallest possible element WLOG assume that Then So we can append to the array which leads to a contradiction Now the task is to find the biggest such that In fact it can be found by binary search the formula of discriminant or just by brute force 
Monocarp is playing a computer game once again He is a wizard apprentice who only knows a single spell Luckily this spell can damage the monsters The level he s currently on contains n monsters The i th of them appears k i seconds after the start of the level and has h i health points As an additional constraint h i le k i for all 1 le i le n All k i are different Monocarp can cast the spell at moments which are positive integer amounts of second after the start of the level 1 2 3 dots The damage of the spell is calculated as follows If he didn t cast the spell at the previous second the damage is 1 Otherwise let the damage at the previous second be x Then he can choose the damage to be either x 1 or 1 A spell uses mana casting a spell with damage x uses x mana Mana doesn t regenerate To kill the i th monster Monocarp has to cast a spell with damage at least h i at the exact moment the monster appears which is k i Note that Monocarp can cast the spell even when there is no monster at the current second The mana amount required to cast the spells is the sum of mana usages for all cast spells Calculate the least amount of mana required for Monocarp to kill all monsters It can be shown that it s always possible to kill all monsters under the constraints of the problem ,"['#pragma region Macros\n//#pragma GCC target(""avx2"")\n// #pragma GCC optimize(""O3"")\n// #pragma comment(linker, ""/stack:200000000"")\n#ifdef ONLINE_JUDGE\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2"")\n// #pragma GCC target(""avx2"")\n#endif\n#pragma GCC optimize(""Ofast"")\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl \'\\n\'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= b; i -= c)\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define rng(v, l, r) v.begin() + l, v.begin() + r\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {""NO"", ""YES""};\nconst string YesNo[2] = {""No"", ""Yes""};\nconst string yesno[2] = {""no"", ""yes""};\nconst string firstsecond[2] = {""second"", ""first""};\nconst string FirstSecond[2] = {""Second"", ""First""};\nconst string possiblestr[2] = {""impossible"", ""possible""};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\n\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\n// bit 演算系\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - \'0\'; }\n    }\n    if(s[0] == \'-\') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << ""0""); }\n    i128 num = v;\n    if(v < 0) {\n        os << \'-\';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + \'0\'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? "", "" : "" "");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << \'(\'; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << \')\'; }\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << ""("" << p.first << "", "" << p.second << "")""; }\n    return os << p.first << "" "" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << ""["";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? """" : "", "") << y;\n        else\n            os << (f ? """" : "" "") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << ""]"";\n    return os;\n}\n\n#ifdef noimi\n#undef endl\nvoid debug() { cerr << endl; }\nvoid debug(bool) { cerr << endl; }\ntemplate <class Head, class... Tail> void debug(bool is_front, Head head, Tail... tail) {\n    if(!is_front) cerr << "", "";\n    cerr << head;\n    debug(false, tail...);\n}\n\n#define dump(args...)                                                                                                                                          \\\n    {                                                                                                                                                          \\\n        vector<string> _debug = _split(#args, \',\');                                                                                                            \\\n        err(true, begin(_debug), args);                                                                                                                        \\\n    }\n\nvector<string> _split(const string &s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while(getline(ss, x, c)) {\n        if(empty(v))\n            v.eb(x);\n        else {\n            bool flag = false;\n            for(auto [c, d] : {pair(\'(\', \')\'), pair(\'[\', \']\'), pair(\'{\', \'}\')}) {\n                if(count(all(v.back()), c) != count(all(v.back()), d)) flag = true;\n            }\n            if(flag)\n                v.back() += "","" + x;\n            else\n                v.eb(x);\n        }\n    }\n    return move(v);\n}\n\nvoid err(bool, vector<string>::iterator) { cerr << endl; }\ntemplate <typename T, typename... Args> void err(bool is_front, vector<string>::iterator it, T a, Args... args) {\n    if(!is_front) cerr << "", "";\n    cerr << it->substr((*it)[0] == \' \', (*it).size()) << "" = "" << a, err(false, ++it, args...);\n}\n\n// #define dump(...) cerr << #__VA_ARGS__ << "" : "", debug(true, __VA_ARGS__)\n#else\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n#endif\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << \' \';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(std::forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, std::forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nint toint(const char &c, const char start = \'a\') { return c - start; }\nint toint(const char &c, const string &chars) { return find(all(chars), c) - begin(chars); }\nint alphabets_to_int(const char &c) { return (islower(c) ? c - \'a\' : c - \'A\' + 26); }\ntemplate <typename T> auto toint(const T &v, const char &start = \'a\') {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\ntemplate <typename T> auto toint(const T &v, const string &start) {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\n// a -> 0, A -> 26\ntemplate <typename T> auto alphabets_to_int(const T &s) {\n    vector<decltype(alphabets_to_int(s[0]))> res;\n    res.reserve(s.size());\n    for(auto &&e : s) { res.emplace_back(alphabets_to_int(e)); }\n    return res;\n}\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        T mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#pragma endregion\n\nint main() {\n    TEST {\n        INT(n);\n        VEC(int, t, n);\n        VEC(int, a, n);\n        vi b(n);\n        rep(i, n) b[i] = t[i] - a[i] + 1;\n        auto tri = [&](ll l, ll r) { return (l + r) * (r - l + 1) / 2; };\n\n        auto id = iota(b);\n        int M = -1;\n        ll ans = 0;\n        ll now = 0;\n        fore(i, id) {\n            dump(b[i]);\n            if(b[i] > M) {\n                ans += tri(1, a[i]);\n                M = t[i];\n                now = a[i];\n            } else {\n                if(t[i] > M) {\n                    ans += tri(now + 1, now + (t[i] - M));\n                    now += t[i] - M;\n                    M = t[i];\n                }\n            }\n            dump(ans, M, now);\n        }\n        OUT(ans);\n    }\n}']","[1, 1, 1, 1, 1, 0, 0, 1, 0, 0]",1700,Consider the problem with There is a single monster with some health that appears at some second In order to kill it we have to wind up our spell until it has damage So we have to use it from second to second Look at it as a segment on a timeline Actually to avoid handling zero length segments let s instead say that a segment covers the time from non inclusive to inclusive producing a half interval This way the total mana cost will be where is the length of the half interval Now There are two time segments If they don t intersect segments and don t intersect since they are half intervals then it s always better to wind up the spell for the monsters separately instead of saving the damage However if they intersect then we don t have the choice other than to save the damage from the earlier one to the later one Otherwise there won t be enough time to wind up the spell What that means in a mathematic sense The answer is the union of two half intervals If they don t intersect they are left as is Otherwise they become one half interval that covers them both Now add the third monster into the construction The same argument applies While there exists a pair of intersecting half intervals keep uniting them The union of all half intervals can be found in but the constraints allowed slower approaches as well 
In the court of the Blue King Lelle and Flamm are having a performance match The match consists of several rounds In each round either Lelle or Flamm wins Let W L and W F denote the number of wins of Lelle and Flamm respectively The Blue King considers a match to be if and only if after every round gcd W L W F le 1 at the end of the match W L le n W F le m Note that gcd 0 x gcd x 0 x for every non negative integer x Lelle and Flamm can decide to stop the match whenever they want and the final score of the performance is l cdot W L f cdot W F Please help Lelle and Flamm coordinate their wins and losses such that the performance is and the total score of the performance is maximized ,"['#include <bits/stdc++.h>\xa0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\xa0constexpr int N = 2E7;std::vector<int> minp, primes;\xa0void sieve(int n) {    minp.assign(n + 1, 0);    primes.clear();        for (int i = 2; i <= n; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }                for (auto p : primes) {            if (i * p > n) {                break;            }            minp[i * p] = p;            if (p == minp[i]) {                break;            }        }    }}\xa0void solve() {    int n, m, l, f;    std::cin >> n >> m >> l >> f;        int q = m;    while (q > 1 && minp[q] != q) {        q--;    }    int p = std::min(q - 1, n);    while (p > 1 && (minp[p] != p || m / p != q / p)) {        p--;    }        // std::cerr << ""p : "" << p << "", q : "" << q << ""\\n"";    std::vector vis(n - p + 1, std::vector<bool>(m - q + 1));    i64 ans = 0;    for (int i = 0; i <= n - p; i++) {        for (int j = 0; j <= m - q; j++) {            int g = std::gcd(p + i, q + j);            if (i == 0 || j == 0) {                vis[i][j] = (g == 1 && p + i <= q + j);            } else if (g == 1) {                vis[i][j] = vis[i - 1][j] || vis[i][j - 1];            }            if (vis[i][j]) {                // std::cerr << ""("" << p + i << "", "" << q + j << "")\\n"";                ans = std::max(ans, 1LL * l * (p + i) + 1LL * f * (q + j));                if (q + j <= n) {                    ans = std::max(ans, 1LL * f * (p + i) + 1LL * l * (q + j));                }            }        }    }    std::cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        // for (int i = 0; i <= 30; i++) {    //     for (int j = 0; j <= 30; j++) {    //         std::cerr << (std::gcd(i, j) <= 1 ? ""O"" : "" "");    //     }    //     std::cerr << ""\\n"";    // }        sieve(N);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']","[0, 1, 0, 1, 0, 1, 0, 0, 0, 0]",2600,TutorialWe view the problem as a walk on grid starting at WLOG we suppose thus only cells where would be considered Notice that when is large enough the largest prime satisfies As such all cells where will be unblocked and reachable However we ve only bounded one side of the final result We take this a step further let be the second largest prime By the same logic we assume that As such all cells where will be unblocked and reachable Thus we have constructed an area where the optimal solution must be with its dimensions bounded by and We just need to run any brute force solution dfs with memorization or dp on this area to find the result If we assume the asymptotic of prime gap is this yields a solution where the is from taking the gcd of two numbers which differ by This can also be optimized to by preprocessing gcd We added the constraints that s are pairwise distinct to avoid forcing participants to write memorizations In fact under the constraints of the problem the maximum area is and the sum of the largest areas is Time complexity 
Petr wants to make a calendar for current month For this purpose he draws a table in which columns correspond to weeks a week is seven consequent days from Monday to Sunday rows correspond to weekdays and cells contain dates For example a calendar for January 2017 should look like on the picture Petr wants to know how many columns his table should have given the month and the weekday of the first date of that month Assume that the year is non leap ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int c[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcout.tie(0); cin.tie(0);\n\n\tint n, d; cin >> n >> d;\n\tcout << (c[n - 1] + d - 1 + 6) / 7 << endl;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",800,Just implement writing dates one by one and keeping current column and row or use the formula where is the number of days in the month 
You have a horizontal strip of n cells Each cell is either white or black You can choose a segment of cells once and paint them all white After this action all the black cells in this segment will become white and the white ones will remain white What is the minimum length of the segment that needs to be painted white in order for all n cells to become white ,"[""// LUOGU_RID: 146673934\n\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint tt;\n \nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin>>tt;\n\twhile(tt--){\n\t\tint n;cin>>n;\n\t\tint l=-1,r=-1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tchar ch;cin>>ch;\n\t\t\tif(ch=='B'){\n\t\t\t\tif(l==-1) l=i;\n\t\t\t\tr=i;\n\t\t\t}\n\t\t}\n\t\tif(l==-1){\n\t\t\tcout<<0<<'\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<r-l+1<<'\\n';\n\t}\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800,To repaint all the black cells in white it is necessary to select a segment from to that contains all the black cells Let s choose the entire strip as a segment As long as the segment starts with a white cell it can be left unpainted i e can be increased by one Otherwise we cannot exclude the cell from the segment Similarly we can exclude the last cell from the segment until it becomes black After all exclusions the answer will be The selected segment contains all the black cells as we have excluded only white cells The segment is also minimal because reducing the segment from either side will result in one of the black cells remaining black 
You are given a rectangular grid with n rows and m columns The cell located on the i th row from the top and the j th column from the left has a value a ij written in it You can perform the following operation any number of times possibly zero Choose any two adjacent cells and multiply the values in them by 1 Two cells are called adjacent if they share a side Note that you can use a cell more than once in different operations You are interested in X the of all the numbers in the grid What is the maximum X you can achieve with these operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T,N,M;\nint a[110][110];\n\nint solve(vector<int> &v, int d) {\n    sort(v.begin(), v.end());\n    int N = v.size();\n    int max_delta = 0, S = 0;\n    if (d == 1) {\n        S = v[0];\n        max_delta = -2 * v[0];\n    }\n    for (int i=d;i<N;i+=2) {\n        S += v[i];\n        if (i == N - 1) continue;\n        S += v[i + 1];\n        max_delta = max(max_delta, -2 * S);\n    }\n    //printf(""%d %d\\n"",d,max_delta);\n    return S + max_delta;\n}\n\nint main() {\n    scanf(""%d"",&T);\n    while(T--) {\n        scanf(""%d%d"",&N,&M);\n        vector<int>v1,v2;\n        for (int i=1;i<=N;i++) {\n            for (int j=1;j<=M;j++) {\n                scanf(""%d"",&a[i][j]);\n                if ((i + j) % 2 == 1) {\n                    v1.push_back(a[i][j]);\n                } else {\n                    v2.push_back(a[i][j]);\n                }\n            }\n        }\n        printf(""%d\\n"", max(solve(v1, 0) + solve(v2, 0), solve(v1, 1) + solve(v2, 1)));\n    }\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1000,SolutionLet be the number of non zero numbers in the grid and let s see what happens in different scenarios both cells have negative numbers then goes down by both cells have positive numbers then goes up by one cell has a positive number while the other one has a negative number then stays the same It is important to notice that we can apply this operation not only for the two neighboring cells but for any two to achieve this effect we apply this operation on any path between the cells consecutively The parity of never changes So for even the answer is the sum of the absolute value of all numbers Otherwise one element will not be positive in the end so it s best to choose the one with minimum absolute value and subtract from the sum The existence of zeroes doesn t really change anything both formulas output the same value in such a case This gives us a solution in 
You are given a board of size n times n n rows and n colums and two arrays of positive integers a and b of size n Your task is to place the chips on this board so that the following condition is satisfied for every cell i j there exists at least one chip in the same column or in the same row as the cell i j I e there exists a cell x y such that there is a chip in that cell and either x i or y j or both The cost of putting a chip in the cell i j is equal to a i b j For example for n 3 a 1 4 1 and b 3 2 2 One of the possible chip placements is as follows The total cost of that placement is 1 3 1 2 1 2 10 Calculate the minimum possible total cost of putting chips according to the rules above ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    vl A(N), B(N);\n    F0R(i, N) cin >> A[i];\n    F0R(i, N) cin >> B[i];\n    sort(all(A)); sort(all(B));\n    ll ans1 = B[0] * N, ans2 = A[0] * N;\n    F0R(i, N) {\n        ans1 += A[i];\n        ans2 += B[i];\n    }\n    cout << min(ans1, ans2) << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",900,Let s note that to maintain the rule for all cells in a certain row one of two conditions must hold either the row contains at least one chip or each column contains at least one chip Let s apply this observation to all rows of the board If we consider all rows this observation means that the placement of chips satisfies the rule if either each row contains at least one chip or each column contains at least one chip Let s consider the case when each row contains at least one chip Since we want to calculate the minimum total cost of placement each row needs exactly one chip Now we have to determine where exactly in each row the chip is placed Since the cost of a chip in the th row and th column is equal to to minimize the cost we have to choose the minimum value of Applying this to all rows we obtain that the total cost is equal to where is the minimum element in the array Similar reasoning can be applied to the case when there is a chip in each column In this case the total cost is equal to where is the minimum element in the array The answer to the problem is the minimum of the two values described above 
Stanley lives in a country that consists of n cities he lives in city 1 There are bidirectional roads between some of the cities and you know how long it takes to ride through each of them Additionally there is a flight between each pair of cities the flight between cities u and v takes u v 2 time Stanley is quite afraid of flying because of watching Sully Miracle on the Hudson recently so he can take at most k flights Stanley wants to know the minimum time of a journey to each of the n cities from the city 1 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(""%d"",&x);\n\treturn x;\n}\nconst int N=1e5+5;\ntypedef long long ll;\nconst ll inf=1e13;\nint n,m,k;\nint lst[N],to[N<<1],len[N<<1],nxt[N<<1],ec;\ninline void ae(int x,int y,int z){\n\tto[++ec]=y,nxt[ec]=lst[x],len[ec]=z,lst[x]=ec;\t\n}\nll dis[N];\nvoid dijkstra(){\n\tpriority_queue<pair<ll,int> > pq;\n\tfor(int i=1;i<=n;i++)pq.push(make_pair(-dis[i],i));\n\twhile(pq.size()){\n\t\tint x=pq.top().second;\n\t\tll d=-pq.top().first;\n\t\tpq.pop();\n\t\tif(d!=dis[x])continue;\n\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\tint y=to[i];\n\t\t\tif(dis[y]>d+len[i]){\n\t\t\t\tdis[y]=d+len[i];\n\t\t\t\tpq.push(make_pair(-dis[y],y));\n\t\t\t}\n\t\t}\n\t}\n}\nll px[N],py[N];\nint q[N],ql,qr;\nbool check(int a,int b,int c){\n\tll v1=(ll)(py[b]-py[a])*(px[c]-px[a]);\n\tll v2=(ll)(py[c]-py[a])*(px[b]-px[a]);\n\treturn v1>=v2;\n}\nll get(int p,int k){\n\treturn py[p]-2*px[p]*k;\n}\nvoid dp(){\t\n\tql=1,qr=0;\n\tfor(int i=1;i<=n;i++){\n\t\tpx[i]=i,py[i]=dis[i]+(ll)i*i;\n\t\twhile(ql<qr&&check(q[qr-1],q[qr],i))qr--;\n\t\tq[++qr]=i;\n\t\twhile(ql<qr&&get(q[ql],i)>=get(q[ql+1],i))ql++;\n\t\tdis[i]=get(q[ql],i)+(ll)i*i;\n\t}\n}\nint main(){\n\tn=in(),m=in(),k=in();\n\twhile(m--){\n\t\tint x=in(),y=in(),z=in();\n\t\tae(x,y,z),ae(y,x,z);\t\n\t}\n\tfor(int i=2;i<=n;i++)dis[i]=inf;\n\tdijkstra();\n\twhile(k--){\n\t\tdp();\n\t\treverse(dis+1,dis+n+1);\n\t\tdp();\n\t\treverse(dis+1,dis+n+1);\n\t\tdijkstra();\n\t}\n\tfor(int i=1;i<=n;i++)printf(""%lld "",dis[i]);\n\treturn 0;\n}\n']","[1, 0, 0, 1, 1, 0, 0, 0, 0, 1]",2400,Let s assume we know the shortest distances from the first vertex to each if we have added no more than edges air travels Let s learn to recalculate the answer for edges First let s update the answer for all the paths ending in an air travel Then we can run Dijkstra to take into account all the paths ending with a usual edge In order to add an air travel we need to update the distance to with all the paths ending with an air travel to To do so we can use Convex Hull Trick since the recalculation formula has the following form array of distances for edges array of distances if the flight goes exactly to the th vertex After that we need to run Dijkstra to update the distances with all the paths not ending with an air travel The resulting asymptotics is 
Let s be some string consisting of symbols or Let s call a string t a substring of string s if there exists such number 1 leq l leq s t 1 that t s l s l 1 ldots s l t 1 Let s call a substring t of string s unique if there exist only one such l For example let s A string t is an unique substring of s because l 2 is the only one suitable number But for example t isn t a unique substring of s because l 1 and l 3 are suitable And for example t at all isn t a substring of s because there is no suitable l Today Vasya solved the following problem at the informatics lesson given a string consisting of symbols and the task is to find the length of its minimal unique substring He has written a solution to this problem and wants to test it He is asking you to help him You are given 2 positive integers n and k such that n bmod 2 k bmod 2 where x bmod 2 is operation of taking remainder of x by dividing on 2 Find any string s consisting of n symbols or such that the length of its minimal unique substring is equal to k ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, K;\n  cin >> N >> K;\n\n  const int ss = (N - K) / 2;\n\n  string ptn(ss, \'1\');\n  ptn += ""0"";\n\n  string s;\n  while (SZ(s) < N) { s += ptn; }\n  s.resize(N);\n  cout << s << ""\\n"";\n}\n\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",2200,Let s define the value a n k2 We know that kmod2 nmod2 so a is integer number Let s construct this string s a symbols 0 1 symbol 1 a symbols 0 1 symbol 1 Let s prove that this string satisfy the conditions Let s note that it s period is equal to a 1 Let the substring t be unique Let s look at the only l for this substring But if l a 1 then l a 1 satisfy as the left border of the string t occurrence if l n a t then l a 1 satisfy because the period of s is equal to a 1 so shift on a 1 don t change anything So l a 1 and n a t l because in other case l can t be the only So n a t l a 1 so n a t a 1 so n a t a so n 2 a t so k t As the example of the unique substring of length k we can take t sa 1 sn a 
You are given array a 1 a 2 dots a n You need to split it into k subsegments so every element is included in exactly one subsegment The weight of a subsegment a l a l 1 dots a r is equal to r l 1 cdot max limits l le i le r a i The weight of a partition is a total weight of all its segments Find the partition of minimal weight ,"['#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, k;\nconst int maxN = 2 * (int)1e4 + 100;\nvector < pair < ll, ll > > cht[4 * maxN];\nstruct pt{\n    ll x, y;\n    pt(ll _x, ll _y) {\n        x = _x;\n        y = _y;\n    }\n    pt() {}\n};\nvector < pt > all[4 * maxN];\nbool del(const pt& x, const pt& y, const pt& z) {\n    return (y.y - x.y) * (x.x - z.x) <= (z.y - x.y) * (x.x - y.x);\n}\nvoid add(ll x, ll y, vector < pt >& vec) {\n    pt nw(x, y);\n    while (vec.size() >= 2 && del(vec[vec.size() - 1], vec[vec.size() - 2], nw)) {\n        vec.pop_back();\n    }\n    vec.push_back(nw);\n}\nll get(const pt& a, ll y) {\n    return (a.x * y + a.y);\n}\nconst ll INF = 2 * (ll)1e18;\nll get(ll x, vector < pt >& vec) {\n    if (vec.empty()) return -INF;\n    int l = 0;\n    int r = vec.size() - 1;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (get(vec[m], x) > get(vec[m + 1], x)) {\n            r = m;\n        }\n        else l = m;\n    }\n    return max(get(vec[r], x), get(vec[l], x));\n}\nvoid add(int v, int tl, int tr, int l, int r, pair < ll, ll >& who) {\n    if (tl == l &&  tr == r) {\n        cht[v].push_back(who);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) {\n        add(v + v, tl, tm, l, r, who);\n    }\n    else if (l > tm) {\n        add(v + v + 1, tm + 1, tr, l, r, who);\n    }\n    else {\n        add(v + v, tl, tm, l, tm, who);\n        add(v + v + 1, tm + 1, tr, tm + 1, r, who);\n    }\n}\nvoid ch() {\n    for (int i = 1; i <= 4 * n; i++) {\n        cht[i].clear();\n        all[i].clear();\n    }\n}\nvoid build(int v, int tl, int tr) {\n    sort(cht[v].begin(), cht[v].end());\n    reverse(cht[v].begin(), cht[v].end());\n    for (auto t : cht[v]) {\n        add(-t.first, -t.second, all[v]);\n    }\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        build(v + v, tl, tm);\n        build(v + v + 1, tm + 1, tr);\n    }\n}\nll get(int v, int tl, int tr, int pos, ll val) {\n    ll f1 = -get(val, all[v]);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm) f1 = min(f1, get(v + v, tl, tm, pos, val));\n        else f1 = min(f1, get(v + v + 1, tm + 1, tr, pos, val));\n    }\n    return f1;\n}\n\n\nll dp[maxN];\nint a[maxN];\nint nxt[maxN];\nll coefs[maxN];\n\nvector < pt > lines[4 * maxN];\npair < ll, ll > ss[4 * maxN];\nvoid build2(int v, int tl, int tr) {\n    vector < pair < ll, ll > > all;\n    for (int i = tl; i <= tr; i++) {\n        all.push_back(ss[i]);\n    }\n    sort(all.begin(), all.end());\n    reverse(all.begin(), all.end());\n    for (auto it : all) {\n        add(-it.first, -it.second, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (tl != tr) {\n        build2(v + v, tl, tm);\n        build2(v + v + 1, tm + 1, tr);\n    }\n}\nll get_val(int v, int tl, int tr, int l, int r, ll val) {\n    if (tl == l && tr == r) {\n        return -get(val, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) return get_val(v + v, tl, tm, l, r, val);\n    else if (l > tm) return get_val(v + v + 1, tm + 1, tr, l, r, val);\n    else {\n        return min(get_val(v + v, tl, tm, l, tm, val), get_val(v + v + 1, tm + 1, tr, tm + 1, r, val));\n    }\n}\nint en[maxN];\nvoid solve() {\n    vector < pair < int, int > > st;\n    st.push_back(make_pair(1e9, 0));\n    for (int i = 1; i <= 4 * n; i++) lines[i].clear();\n    for (int i = 1; i <= n; i++) {\n        ss[i] = make_pair(-(i - 1), dp[i - 1]);\n    }\n    build2(1, 1, n);\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            st.pop_back();\n        }\n        nxt[i] = st.back().second;\n        st.push_back(make_pair(a[i], i));\n    }\n    for (int i = 1; i <= n; i++) {\n        coefs[i] = get_val(1, 1, n, nxt[i] + 1, i, a[i]);\n    }\n    ch();\n    st.clear();\n    st.push_back(make_pair(1e9, 0));\n    //cout << "" Here"" << endl;\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            en[st.back().second] = i - 1;\n            st  .pop_back();\n        }\n        st.push_back(make_pair(a[i], i));\n    }\n    while (!st.empty()) {\n        en[st.back().second] = n;\n        st.pop_back();\n    }\n    //cout << "" Here"" << endl;\n    for (int i = 1; i <= n; i++) {\n        pair < ll, ll > tt = make_pair(a[i], coefs[i]);\n        add(1, 1, n, i, en[i], tt);\n    }\n    build(1, 1, n);\n    dp[0] = 1e9;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = get(1, 1, n, i, i);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = (ll)1e9;\n    }\n    for (int i = 0; i < k; i++) {\n        solve();\n    }\n    cout << dp[n];\n    return 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",3000,Important note the author solution is using both linear Convex hull trick and persistent Li Chao tree As mentioned in commentaries applying the Divide and Conquer technique can help get rid of Li Chao tree More about both structures you can read in this article Let s try to write standard dp we can come up with arrays will be 0 indexed Let be the minimal weight if we splitted prefix of length in subsegments Then we can calculate it as 1 Maximums on segments are inconvenient let s try to group segments by the value of So we can find such sequence of borders where for each In other words and is the closest from the left position where Note that we can maintain this sequence with stack of maximums Ok then for each interval equation 1 transforms to Why did we use variables and Because there are two problems is needed because we iterate over and can t recalculate everything is needed because sequence is changing over time so do the But what we can already see we can maintain for each segment Convex hull with linear functions so we can take in logarithmic time Moreover we can store values in other Convex hull to take minimum over all segments in logarithmic time The problems arise when we try modificate structures while iterating Fortunately segments change not at random but according to stack of maximums So all we should handle are to merge segment on top of the stack with current segment in case when to erase segment on top of the stack along with its value to insert new segment on top of the stack along with its value To handle the third type is easy since all Convex hulls can insert elements There will be at most such operations on a single layer and we can ask value in and insert a line with To handle the second type is harder but possible since we can make Convex hull persistent and store its versions in the stack Persistent Convex hull persistent Li Chao tree There will be also operations in total and they cost us To handle the first type is trickiest part Note that all line coefficients of one convex hull are strictly lower than all line coefficients of the other So we can use linear Convex hulls to make insertions to back in amortized But to merge efficiently we should use Small to Large technique that s why we should be able also push front in and moreover still be able to ask minimum in And here comes the hack in C which can push pop front back in amortized and also have random access iterator to make binary search possible So each element of every segment will be transfered times with cost of amortized on a single layer In the end result complexity is Space complexity is 
Two little greedy bears have found two pieces of cheese in the forest of weight and grams correspondingly The bears are so greedy that they are ready to fight for the larger piece That s where the fox comes in and starts the dialog Little bears wait a little I want to make your pieces equal Come off it fox how are you going to do that the curious bears asked It s easy said the fox If the mass of a certain piece is divisible by two then I can eat exactly a half of the piece If the mass of a certain piece is divisible by three then I can eat exactly two thirds and if the mass is divisible by five then I can eat four fifths I ll eat a little here and there and make the pieces equal The little bears realize that the fox s proposal contains a catch But at the same time they realize that they can not make the two pieces equal themselves So they agreed to her proposal but on one condition the fox should make the pieces equal as quickly as possible Find the minimum number of operations the fox needs to make pieces equal ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname """"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define sz size()\nint a, b, ans = INF;\n\nvoid _try(int x) {\n\tif (a % x != 0 || b % x != 0) return;\n\tint n1 = a / x, n2 = b / x;\n\tint kol = 0;\n\twhile (n1 % 2 == 0) n1 /= 2, ++kol;\n\twhile (n1 % 3 == 0) n1 /= 3, ++kol;\n\twhile (n1 % 5 == 0) n1 /= 5, ++kol;\n\twhile (n2 % 2 == 0) n2 /= 2, ++kol;\n\twhile (n2 % 3 == 0) n2 /= 3, ++kol;\n\twhile (n2 % 5 == 0) n2 /= 5, ++kol;\n\tif (n1 > 1 || n2 > 1) return;\n\tans = min(ans, kol);\n}\n\nint main ()\n{\t\n\t#ifndef ONLINE_JUDGE\n\tfreopen (fname""in"",""r"",stdin);\n\tfreopen (fname""out"",""w"",stdout);\n\t#endif\n\n\tcin >> a >> b;\n\n\tfor (int i = 1; i * i <= a; i ++ ) {\n\t\tif (a % i == 0) {\n\t\t\t_try(i);\n\t\t\t_try(a / i);\n\t\t}\n\t}\n\n\tfor (int i = 1; i * i <= b; i ++ ) {\n\t\tif (b % i == 0) {\n\t\t\t_try(i);\n\t\t\t_try(b / i);\n\t\t}\n\t}\n\t\n\tif (ans == INF) cout << -1;\n\telse cout << ans;\n\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300,It is easy to see that the fox can do three type of operations divide by 2 divide by 3 and divide by 5 Let s write both given numbers in form Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX 
You are given three integers n l and r You need to construct an array a 1 a 2 dots a n l le a i le r such that gcd i a i are all distinct or report there s no solution Here gcd x y denotes the greatest common divisor GCD of integers x and y ,"['// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == \'-\') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, l, r;\nint a[N];\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\tW(T) {\n\t\tqread(n, l, r);\n\t\tint f = 1;\n\t\trep(i, 1, n) if(i * (l / i) < l && i * (l / i + 1) > r) f = 0;\n\t\tputs(f ? ""YES"" : ""NO"");\n\t\tif(f) {\n\t\t\trep(i, 1, n) if(l % i == 0) cout << l << \' \';\n\t\t\telse cout << i * (l / i + 1) << \' \';\n\t\t\tcout << \'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1100, Because all are different then which means is the multiple of To check if there is such just check if the minimum multiple of that is strictly bigger than is less than Time complexity for each test case 
George woke up and saw the current time on the digital clock Besides George knows that he has slept for time Help George Write a program that will given time and determine the time when George went to bed Note that George could have gone to bed yesterday relatively to the current time see the second test sample ,"['#include<bits/stdc++.h>\n\n\n\nusing namespace std;\n\n\n\nchar s[3][6];\n\nint i, d[3], ans;\n\n\n\nint main(){\n\n\t\n\n\tscanf(""%s%s"", s[1], s[2]);\n\n\t\n\n\tfor(i=1; i<3; i++) d[i]=60*((s[i][0]-\'0\')*10+s[i][1]-\'0\')+(s[i][3]-\'0\')*10+s[i][4]-\'0\';\n\n\t\n\n\tans=d[1]-d[2];\n\n\tif(ans<0) ans+=24*60;\n\n\tif(ans/60<10) printf(""0"");\n\n\tprintf(""%d:"", ans/60);\n\n\tif(ans%60<10) printf(""0"");\n\n\tprintf(""%d\\n"", ans%60);\n\n\treturn 0;\n\n}\n                                ']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,I will describe the simple solution Let George woke up in the hours and minutes and he slept for hours and minutes Let s get the number and If then you should add to minutes and subtract from one hour After that if then add to it hours You can print the answer in C by using the following line The complexity is time and memory Author s solution 5850831 
You are given n points on the x axis at increasing positive integer coordinates x 1 x 2 ldots x n For each pair i j with 1 leq i j leq n you draw the segment x i x j The segments are closed i e a segment a b contains the points a a 1 ldots b You are given q queries In the i th query you are given a positive integer k i and you have to determine how many points with integer coordinates are contained in exactly k i segments ,"['#include<bits/stdc++.h>using namespace std;#define int long longconst int N=1e5+7;int T,n,q,x[N];map<int,int>mp;signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n>>q;\t\tfor(int i=1;i<=n;i++){\t\t\tcin>>x[i];\t\t\tint cnt=(n-1)+(i-1)*(n-i);\t\t\tmp[cnt]++;\t\t}\t\tfor(int i=1;i<n;i++){\t\t\tint cnt=i*(n-i);\t\t\tmp[cnt]+=(x[i+1]-x[i]-1);\t\t}\t\twhile(q--){\t\t\tint x;\t\t\tcin>>x;\t\t\tcout<<mp[x]<<"" "";\t\t\t}\t\tcout<<""\\n"";\t\tmp.clear();\t}\treturn 0;}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1200,SolutionFirst let s focus on determining how many intervals contain some point These intervals are the ones with and So a point satisfies and It means that you have found points contained in exactly intervals because there are possible left endpoints and possible right endpoints Similarly the point is contained in intervals you have to remove interval which you do not draw So you can use a map that stores how many points are contained in exactly intervals and update the map in the positions and Complexity 
Recently Polycarp was given an unusual typewriter as a gift Unfortunately the typewriter was defective and had a rather strange design The typewriter consists of n cells numbered from left to right from 1 to n and a carriage that moves over them The typewriter cells contain n integers from 1 to n and each cell i initially contains the integer p i Before all actions the carriage is at cell number 1 and there is nothing in its buffer storage The cell on which the carriage is located is called the cell The carriage can perform five types of operations Take the integer from the current cell if it is not empty and put it in the carriage buffer if it is empty this buffer can contain integer Put the integer from the carriage buffer if it is not empty into the current cell if it is empty Swap the number in the carriage buffer with the number in the current cell if both the buffer and the cell contain integers Move the carriage from the current cell i to cell i 1 if i n while the integer in the buffer is preserved Reset the carriage i e move it to cell number 1 while the integer in the buffer is preserved Polycarp was very interested in this typewriter so he asks you to help him understand it and will ask you q queries of three types Perform a cyclic shift of the sequence p to the left by k j Perform a cyclic shift of the sequence p to the right by k j Reverse the sequence p Before and after each query Polycarp wants to know what number of carriage resets is needed for the current sequence in order to distribute the numbers to their cells so that the number i ends up in cell number i Note that Polycarp only wants to know the minimum number of carriage resets required to arrange the numbers in their places but Help Polycarp find the answers to his queries ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint a[1000005],n;\nint cal()\n{\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans+=a[i]<i;\n\treturn ans;\n}\nint ans0[1000005],ans1[1000005];\nstruct BIT\n{\n\tint tree[2000005];\n\tvoid init()\n\t{\n\t\tmemset(tree,0,sizeof tree);\n\t}\n\tint lowbit(int x)\n\t{\n\t\treturn x&-x;\n\t}\n\tvoid add(int x,int y)\n\t{\n\t\tfor(x+=1000000;x<=2000000;x+=lowbit(x)) tree[x]+=y;\n\t}\n\tint ask(int x)\n\t{\n\t\tint rtn=0;\n\t\t--x;\n\t\tfor(x+=1000000;x;x^=lowbit(x)) rtn+=tree[x];\n\t\treturn rtn;\n\t}\n}T;\nvoid mermermer()\n{\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) cin >> a[i];\n\tfor(int i=n+1;i<=n+n;i++) a[i]=a[i-n];\n\tfor(int i=1;i<=n;i++) T.add(a[i]-i,1);\n\tans0[0]=T.ask(0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tT.add(a[i+n]-(i+n),1);\n\t\tT.add(a[i]-i,-1);\n\t\tans0[i]=T.ask(-i);\n\t}\n\tT.init();\n\treverse(a+1,a+n+1);\n\tfor(int i=n+1;i<=n+n;i++) a[i]=a[i-n];\n\tfor(int i=1;i<=n;i++) T.add(a[i]-i,1);\n\tans1[0]=T.ask(0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tT.add(a[i+n]-(i+n),1);\n\t\tT.add(a[i]-i,-1);\n\t\tans1[i]=T.ask(-i);\n\t}\n\tint nw=0,f=0;\n\tcout << ans0[0] << ""\\n"";\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint op,x;\n\t\tcin >> op;\n\t\tif(op==3)\n\t\t{\n\t\t\tf^=1,nw=(n-nw)%n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcin >> x;\n\t\t\tif(op==1)\n\t\t\t{\n\t\t\t\tnw+=x;\n\t\t\t}\n\t\t\telse nw+=n-x;\n\t\t}\n\t\tnw=(nw%n+n)%n;\n\t\tif(!f) cout << ans0[nw] << ""\\n"";\n\t\telse cout << ans1[nw] << ""\\n"";\n\t}\n/*\tcout << cal() << ""\\n"";\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint op,x;\n\t\tcin >> op;\n\t\tif(op==3) reverse(a+1,a+n+1);\n\t\telse\n\t\t{\n\t\t\tcin >> x;\n\t\t\tif(op==1) x=n-x;\n\t\t\tint b[1005]={};\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(i+x<=n) b[i+x]=a[i];\n\t\t\t\telse b[i+x-n]=a[i];\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++) a[i]=b[i];\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout << a[i] << "" "";\n\t//\tcout << ""\\n"";\n\t//\tcout << cal() << ""\\n"";\n\t}*/\n\t\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T=1;\n//\tcin >> T;\n\twhile(T--) mermermer();\n\treturn 0;\n}\n//bu pa kun nan!!!']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0]",2500,Let s solve the problem if there are no requests The key object for us will be such cells that the number in them is less than the cell index Note that for one carriage reset we can transfer no more than one such number So we have a lower bound on the answer Let s build a graph with edges Then it will break up into cycles Let s find the first position where take a number from this position shift it to take a number from position and so on Then we will put the whole cycle in its place How many carriage drops will there be Exactly as many edges as there are such that That is the answer is exactly equal to the number of positions where Let s learn how to solve for shifts Let s find for each cell such positions of the beginning of the array that it will satisfy in this configuration It is easy to see that for a particular cell such indexes will form a segment possibly a prefix suffix Let s create a separate array and add one on these segments Then in the i th position there will be an answer if the array starts from the i th cell Now let s solve for an array flip It is easy to see that for this you can simply maintain the entire previous structure but with the inverted original configuration of cells Asymptotic 
Mainak has an array a 1 a 2 ldots a n of n positive integers He will do the following operation to this array Pick a subsegment of this array and cyclically rotate it by any amount Formally he can do the following exactly once Pick two integers l and r such that 1 le l le r le n and any positive integer k Repeat this k times set a l a l 1 a l 1 a l 2 ldots a r 1 a r a r a l all changes happen at the same time Mainak wants to the value of a n a 1 after exactly one such operation Determine the maximum value of a n a 1 that he can obtain ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tints(N);\n\tvi A(N); re(A);\n\tif (N == 1) {\n\t\tps(0);\n\t\treturn;\n\t}\n\tint ans = 0;\n\trep(N) {\n\t\tckmax(ans, A.bk-A.ft);\n\t\trotate(begin(A),1+all(A));\n\t}\n\tckmax(ans, *max_element(1+all(A))-A.ft);\n\tckmax(ans, A.bk-*min_element(all(A)-1));\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",900,There are four candidates of the maximum value of achievable each of which can be found in time No subarray is chosen Answer would be in this case Chosen subarray contains and Answer would be where is same as notice that the previous case is included in this case as well Chosen subarray doesn t contain Answer would be Chosen subarray doesn t contain Answer would be Finally we report the maximum of all of these four values in total time 
For a permutation p of numbers 1 through n we define a a as follows a i is length of the longest segment of permutation which contains position i and is made of consecutive values in sorted order x x 1 ldots y 1 y or y y 1 ldots x 1 x for some x leq y For example for permutation p 4 1 2 3 7 6 5 we have a 1 3 3 3 3 3 3 You are given the stair array a Your task is to calculate the number of permutations which have stair array equal to a Since the number can be big compute it modulo 998 244 353 Note that this number can be equal to zero ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$. \n \t* For XOR convolution ignore \\texttt{m} within \\texttt{fft}. \n * Time: O(N\\log N)\n * Source: \n \t* KACTL (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n \t* https://cp-algorithms.com/algebra/fft.html\n \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n \t* maroonrk\n \t* https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp\n * Verification: \n\t* https://judge.yosupo.jp/problem/convolution_mod\n\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding\n\t* http://codeforces.com/contest/632/problem/E\n */\n\n// #include ""ModInt.h""\n// const int MOD = 998244353;\n\ntemplate<class T> void fft(V<T>& A, bool inv = 0) { // NTT\n\tint n = sz(A); assert((T::mod-1)%n == 0); V<T> B(n);\n\tfor(int b = n/2; b; b /= 2, swap(A,B)) {\n\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1; // n/b\'th root of unity\n\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {\n\t\t\tT u = A[i+j], v = A[i+j+b]*m;\n\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;\n\t\t}\n\t}\n\tif (inv) { reverse(1+all(A)); \n\t\tT z = T(1)/T(n); each(t,A) t *= z; }\n}\ntemplate<class T> V<T> mul(V<T> A, V<T> B) { // only special moduli for NTT\n\tif (!min(sz(A),sz(B))) return {};\n\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);\n\tbool eq = A == B; A.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i,n) A[i] *= B[i];\n\tfft(A,1); A.rsz(s); return A;\n}\ntemplate<class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T>& v) {\n\t\tV<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];\n\t\treturn w; };\n\treturn mul(con(x),con(y));\n}\ntemplate<class T> V<T> MUL(const V<T>& A, const V<T>& B) { // arbitrary moduli\n\tusing m0 = mint<(119<<23)+1,62>; auto c0 = mulMod<m0>(A,B);\n\tusing m1 = mint<(5<<25)+1,  62>; auto c1 = mulMod<m1>(A,B);\n\tusing m2 = mint<(7<<26)+1,  62>; auto c2 = mulMod<m2>(A,B);\n\tint n = sz(c0); V<T> res(n);\n\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);\n\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;\n\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod\n\t}\n\treturn res;\n}\n\n/**\n * Description: Basic poly ops including division. Can replace \\texttt{T} with double, complex.\n * Source: Own. Also see\n\t* https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/PolyInterpolate.h\n\t* https://github.com/ecnerwala/icpc-book/blob/master/content/numerical/fft.cpp\n * Verification: see FFT\n */\n\n// #include ""../../number-theory (11.1)/Modular Arithmetic/ModInt.h""\n\nusing T = mi; using poly = V<T>;\nvoid remz(poly& p) { while (sz(p)&&p.bk==T(0)) p.pop_back(); }\npoly REMZ(poly p) { remz(p); return p; }\npoly rev(poly p) { reverse(all(p)); return p; }\npoly shift(poly p, int x) { \n\tif (x >= 0) p.insert(begin(p),x,0); \n\telse assert(sz(p)+x >= 0), p.erase(begin(p),begin(p)-x);\n\treturn p; \n}\npoly RSZ(const poly& p, int x) { \n\tif (x <= sz(p)) return poly(begin(p),begin(p)+x);\n\tpoly q = p; q.rsz(x); return q;  }\nT eval(const poly& p, T x) { // evaluate at point x\n\tT res = 0; R0F(i,sz(p)) res = x*res+p[i]; \n\treturn res; }\npoly dif(const poly& p) { // differentiate\n\tpoly res; FOR(i,1,sz(p)) res.pb(T(i)*p[i]); \n\treturn res; }\npoly integ(const poly& p) { // integratepoly integ(const poly& p) { // integrate\n\tstatic poly invs{0,1};\n\tfor (int i = sz(invs); i <= sz(p); ++i) \n\t\tinvs.pb(-MOD/i*invs[MOD%i]);\n\tpoly res(sz(p)+1); F0R(i,sz(p)) res[i+1] = p[i]*invs[i+1];\n\treturn res; \n}\n\npoly& operator+=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] += r[i]; \n\treturn l; }\npoly& operator-=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] -= r[i]; \n\treturn l; }\npoly& operator*=(poly& l, const T& r) { each(t,l) t *= r; \n\treturn l;\t }\npoly& operator/=(poly& l, const T& r) { each(t,l) t /= r; \n\treturn l; }\npoly operator+(poly l, const poly& r) { return l += r; }\npoly operator-(poly l, const poly& r) { return l -= r; }\npoly operator-(poly l) { each(t,l) t *= -1; return l; }\npoly operator*(poly l, const T& r) { return l *= r; }\npoly operator*(const T& r, const poly& l) { return l*r; }\npoly operator/(poly l, const T& r) { return l /= r;\t }\npoly operator*(const poly& l, const poly& r) {\n\tif (!min(sz(l),sz(r))) return {};\n\tpoly x(sz(l)+sz(r)-1); \n\tF0R(i,sz(l)) F0R(j,sz(r)) x[i+j] += l[i]*r[j];\n\treturn x;\n}\npoly& operator*=(poly& l, const poly& r) { return l = l*r; }\n\npair<poly,poly> quoRem(poly a, poly b) { \n\tremz(a); remz(b); assert(sz(b));\n\tT lst = b.bk, B = T(1)/lst; each(t,a) t *= B; \n\teach(t,b) t *= B;\n\tpoly q(max(sz(a)-sz(b)+1,0));\n\tfor (int dif; (dif=sz(a)-sz(b)) >= 0; remz(a)) {\n\t\tq[dif] = a.bk; F0R(i,sz(b)) a[i+dif] -= q[dif]*b[i]; }\n\teach(t,a) t *= lst;\n\treturn {q,a}; // quotient, remainder\n}\npoly operator/(const poly& a, const poly& b) { return quoRem(a,b).f; }\npoly operator%(const poly& a, const poly& b) { return quoRem(a,b).s; }\n/**poly a = {1,3,5,8,6,0,0,0,0}, b = {1,5,1};\nps(quoRem(a,b)); a = 2*a, b = 2*b; ps(quoRem(a,b));*/\npoly gcd(poly a, poly b) { return b == poly{} ? a : gcd(b,a%b); }\nT resultant(poly a, poly b) { // R(A,B)\n\t// =b_m^n*prod_{j=1}^mA(mu_j)\n\t// =b_m^na_m^n*prod_{i=1}^nprod_{j=1}^m(mu_j-lambda_i)\n\t// =(-1)^{mn}a_n^m*prod_{i=1}^nB(lambda_i)\n\t// =(-1)^{nm}R(B,A)\n\t// Also, R(A,B)=b_m^{deg(A)-deg(A-CB)}R(A-CB,B)\n\tint ad = sz(a)-1, bd = sz(b)-1; \n\tif (bd <= 0) return bd < 0 ? 0 : pow(b.bk,ad);\n\tint pw = ad; a = a%b; pw -= (ad = sz(a)-1);\n\treturn resultant(b,a)*pow(b.bk,pw)*T((bd&ad&1)?-1:1);\n}\n\n/**\n * Description: Multiply small polys directly, otherwise use FFT.\n * Source: KACTL, https://cp-algorithms.com/algebra/fft.html\n */\n\n// #include ""Poly.h""\n// #include ""FFT.h""\n\nbool small(const poly& a, const poly& b) { // multiply directly\n\treturn min(sz(a),sz(b)) <= 60; }\n// vmi smart(const vmi& a, const vmi& b) { return mul(a,b); }\n// vl smart(const vl& a, const vl& b) {\n// \tauto X = mul(vcd(all(a)),vcd(all(b)));\n// \tvl x(sz(X)); F0R(i,sz(X)) x[i] = round(X[i].real());\n// \treturn x; }\npoly conv(const poly& a, const poly& b) {\n\treturn small(a,b) ? a*b : mul(a,b); } \n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvmi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = mi(-(ll)MOD/i*(int)invs[MOD%i]);\n\tFOR(i,1,SZ) {\n\t\tfac[i] = fac[i-1]*i;\n\t\tifac[i] = ifac[i-1]*invs[i];\n\t}\n}\nmi comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn fac[a]*ifac[b]*ifac[a-b];\n}\n\nvoid fassert(bool b) {\n\tif (!b) {\n\t\tps(0);\n\t\texit(0);\n\t}\n}\n\nvmi stor[100005][2][2];\n\nconst mi i2 = (MOD+1)/2;\nvmi calc(int len, int l, int r) {\n\tif (l > r) swap(l,r);\n\tif (sz(stor[len][l][r])) return stor[len][l][r];\n\tif (len == 0) return stor[len][l][r] = {1};\n\tif (len == 1) return stor[len][l][r] = {1,pow(mi(2),2-l-r)*i2};\n\tif (len == 2) return stor[len][l][r] = {1,4-l-r,pow(mi(2),2-l-r)*i2};\n\tF0R(i,2) {\n\t\tvmi a = calc((len-1)/2,l,i);\n\t\tvmi b = calc(len/2,i,r);\n\t\tvmi res = conv(a,b);\n\t\tif (i == 1) {\n\t\t\tres *= 2;\n\t\t\tres.ins(begin(res),0);\n\t\t}\n\t\tstor[len][l][r] += res;\n\t}\n\treturn stor[len][l][r];\n}\n\nvmi conv_all(const V<vmi>& v, int l, int r) {\n\tif (l == r) return {1};\n\tif (l+1 == r) return v[l];\n\tint m = (l+r)/2;\n\treturn conv(conv_all(v,l,m),conv_all(v,m,r));\n}\n\nstruct Dat {\n\tvmi v;\n\tDat(vmi _v):v(_v){}\n\tfriend bool operator<(const Dat& x, const Dat& y) {\n\t\treturn sz(x.v) > sz(y.v);\n\t}\n};\n\nint main() {\n\tsetIO();\n\tvi segs;\n\tints(N); vi A(N); re(A);\n\tgenFac(N+2);\n\tfor (int i = 0; i < N; ) {\n\t\tint lef = min(N-i,A[i]);\n\t\tvi v; rep(lef) v.pb(A[i++]);\n\t\tfassert(sz(v) == v.ft);\n\t\teach(t,v) fassert(t == v[0]);\n\t\tif (sz(v) > 1) segs.pb(2);\n\t\telse segs.pb(1);\n\t}\n\tV<vmi> all_conv;\n\tpriority_queue<Dat> pq;\n\tfor (int l = 0; l < sz(segs); ++l) {\n\t\tif (segs[l] != 1) continue;\n\t\tint r = l; while (r+1 < sz(segs) && segs[r+1] == 1) ++r;\n\t\tvmi v = calc(r-l + (l != 0) + (r != sz(segs)-1), l != 0, r != sz(segs)-1);\n\t\tl = r;\n\t\tpq.push(Dat(v));\n\t}\n\tint pairs = 0;\n\tF0R(l,sz(segs)-1) if (segs[l] != 1 && segs[l+1] != 1) ++pairs;\n\tvmi tmp(pairs+1);\n\tmi cur_term = 1;\n\tF0R(i,sz(tmp)) {\n\t\ttmp[i] = comb(pairs,i)*cur_term;\n\t\tcur_term *= i2;\n\t}\n\tpq.push(Dat(tmp));\n\twhile (sz(pq) > 1) {\n\t\tDat a = pq.top(); pq.pop();\n\t\tDat b = pq.top(); pq.pop();\n\t\tpq.push(Dat(conv(a.v,b.v)));\n\t}\n\n\t// all_conv.pb(tmp);\n\t// // dbg(""GOT ALL CONV"",all_conv);\n\t// vmi res = conv_all(all_conv,0,sz(all_conv));\n\tmi ans;\n\tvmi res = pq.top().v;\n\tF0R(i,sz(res)) {\n\t\tres[i] *= fac[sz(segs)-i];\n\t\tif (i&1) ans -= res[i];\n\t\telse ans += res[i];\n\t}\n\teach(t,segs) if (t == 2) ans *= 2;\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",3400,First of all we need to transform the stair array into some other structure Let s show that for each number there is only one longest stair covering it and these longest stairs are disjoint Suppose that some number belongs to two different ascending stairs We can easily expand these stairs to the left and to the right and find the longest ascending stair covering the number So it means that the longest ascending stair covering a number is unique The same for descending stairs Now suppose that some number belongs to an ascending stair of length and a descending stair of length It is impossible because it would mean that we have consecutive values or in the permutation but since it is a permutation all values should be distinct So the longest stair covering each number is unique Let s split the stair array into this sequence of longest stairs The first element of the stair array belongs to some stair If then the first elements form a stair Let s check that all these elements are equal to and split them into a stair of length then continue the same algorithm from Okay now we have an array of the lengths of the longest stairs Each stair represents some segment of numbers and all stairs can be enumerated by the index of their value segment So it looks like the number of permutations that yeild this array of longest stairs is where is the number of stairs and is the number of stairs having length The reasoning behind this formula is that each stair gets assigned an index corresponding to the index of its value segment in the sorted order and for stairs of length we can choose whether they are ascending or descending Is that formula right Unfortunately no The fact that we have the array of stairs means that we need to ensure that no pair of adjacent stairs merge And there s no easy way to change this formula unfortunately Let s use inclusion exclusion to eliminate all bad permutations We have constraints that shouldn t be violated stairs and shouldn t merge stairs and shouldn t merge stairs and shouldn t merge For every from to we can calculate the number of ways to choose constraints to be violated and a permutation that violates these constrains and maybe some others like in the usual inclusion exclusion formula applications These values can be calculated with the following dynamic programming is the number of ways to choose this set of violated constraints and a permutation for first stairs and represents the type of the last stair ascending descending or having size What are the transitions in this dynamic programming When placing a new stair we may choose either to explicitly violate the constraint on merging it with the previous one so we transition to a state and maybe multiply divide the value by if we are merging two size stairs or merging two stairs with different types Or we can choose to just make an entirely new stair choosing one of values for it since we already have stairs choosing its type if its length is and transitioning to The main drawback of this solution is that it s Let s find a way to optimize it Let s calculate this dynamic programming in a divide and conquer fashion Let s say that for some segment of stairs we will calculate a three dimensional array the number of ways to violate constraints in this segment so that the leftmost stair in this segment has type and the rightmost stair in this segment has type Suppose we want to merge these two segments We either merge the leftmost stair of the right segment with the rightmost stair of the left segment or don t Let s analyze the case when we don t merge them Let s analyze the value of in the resulting array Suppose we violate constraints in the left segment this leaves us to violate constraints in the right segment So the value of in the resulting merged structure will be the sum of from the left segment multiplied by from the right segment where can represent any type And if we treat the values from the left and the right segment as polynomials where value of or is the coefficient for merging them is exactly polynomial multiplication So we can use FFT so speed up the merging If we want to merge two segments while explicitly violating the constraint that the rightmost stair in the left segment and the leftmost stair in the right segment shouldn t be merged into one it can be done with polynomial multiplication as well but you also have to multiply the result by some coefficient that arises from merging those two stairs if both of them had size then we multiply the result by since we can choose whether the resulting stair is ascending or descending and if both of them had size we divide the result by since we cannot merge an ascending stair with a descending one So this optimization allows us to merge two segments of length in time and as the usual FFT D C combination this results in a complexity of though with a fairly large constant factor 
Two segments l 1 r 1 and l 2 r 2 intersect if there exists at least one x such that l 1 le x le r 1 and l 2 le x le r 2 An array of segments l 1 r 1 l 2 r 2 dots l k r k is called if k is even and is possible to split the elements of this array into frac k 2 pairs in such a way that every element of the array belongs to exactly one of the pairs segments in each pair intersect with each other segments in different pairs do not intersect For example the array 2 4 9 12 2 4 7 7 10 13 6 8 is beautiful since it is possible to form 3 pairs as follows the first element of the array segment 2 4 and the third element of the array segment 2 4 the second element of the array segment 9 12 and the fifth element of the array segment 10 13 the fourth element of the array segment 7 7 and the sixth element of the array segment 6 8 As you can see the segments in each pair intersect and no segments from different pairs intersect You are given an array of n segments l 1 r 1 l 2 r 2 dots l n r n You have to remove the minimum possible number of elements from this array so that the resulting array is beautiful ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << "" ""; cout << v[i];\n    }\n    cout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nint cnt[4005][4005];\nvoid solve() {\n    int n; cin >> n;\n    vector<int> l(n), r(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i]; r[i]++;\n    }\n    vector<int> vx;\n    rep(i, n) {\n        vx.push_back(l[i]);\n        vx.push_back(r[i]);\n    }\n    sort(all(vx));\n    vx.erase(unique(all(vx)), vx.end());\n    rep(i, n) {\n        l[i] = lower_bound(all(vx), l[i]) - vx.begin();\n        r[i] = lower_bound(all(vx), r[i]) - vx.begin();\n    }\n    int sz = vx.size();\n    rep(i, sz)Rep(j, i+1, sz) {\n        cnt[i][j] = 0;\n    }\n    rep(i, n)Rep(j, i + 1, n) {\n        int le = max(l[i], l[j]);\n        int ri = min(r[i], r[j]);\n        if (le < ri) {\n            le = min(l[i], l[j]);\n            ri = max(r[i], r[j]);\n            cnt[le][ri]++;\n            //cout << ""hello\\n"";\n            //cout << le << "" "" << ri << ""\\n"";\n        }\n    }\n    rep(i, sz) {\n        Rep(j, i + 1, sz) {\n            if (j + 1 < sz)cnt[i][j + 1] += cnt[i][j];\n        }\n    }\n    rep(j, sz) {\n        per(i, j) {\n            if (i > 0)cnt[i - 1][j] += cnt[i][j];\n        }\n    }\n    vector<int> dp(sz);\n    rep(i, sz) {\n        Rep(j, i + 1, sz) {\n            int val = dp[i];\n            if (cnt[i][j] > 0)val += 2;\n            chmax(dp[j], val);\n        }\n    }\n    //cout << cnt[0][1] << ""\\n"";\n    //coutarray(dp);\n    int ans = n - dp.back();\n    cout << ans << ""\\n"";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0]",2000,The resulting array should consist of pairs of intersecting segments and no segments from different pairs should intersect Let s suppose that segments and intersect and segments and intersect How to check that no other pair of these four segments intersects Instead of pairs of segments let s work with the union of segments in each pair no point should belong to more than one of these unions Since segments and intersect their union is also a segment and its endpoints are So if we transform each pair into a union then the union segments we got should not intersect Thus we can solve the problem as follows for each pair of intersecting segments in the input generate their union segment and pick the maximum number of unions we can these unions represent the pairs in the answer It s quite easy to see that we won t pick a segment in two pairs simultaneously the corresponding unions will intersect Okay now we have union segments how to pick the maximum number of them without having an intersection This is a somewhat classical problem there are many methods to solve it The one used in the model solution is a greedy algorithm sort the union segments according to their right border in non descending order and pick segments greedily in sorted order maintaining the right border of the last segment we picked If the union segment we consider is fully after the right border of the last union we picked then we add it to the answer otherwise we skip it This approach works in 
Mojtaba and Arpa are playing a game They have a list of numbers in the game In a player s turn he chooses a number where is a prime number and is a positive integer such that divides at least one number in the list For each number in the list divisible by call it the player will delete and add to the list The player who can not make a valid choice of and loses Mojtaba starts the game and the players alternatively make moves Determine which one of players will be the winner if both players play optimally ,"['#include<map>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 100 + 10;\n\nint n;\nint a[N];\nint mex[N];\nmap<int, int> sg;\n\nvoid solve(long long x)\n{\n    if (sg.count(x)) return;\n\n    vector<int> mex(30, 0);\n    for(int i = 0; x >> i; ++ i) {\n        long long nx = ((x >> (i + 1)) | (x & ((1 << i) - 1)));\n        solve(nx);\n        mex[sg[nx]] = 1;\n    }\n    int ret = 0;\n    for( ; mex[ret]; ++ ret);\n    sg[x] = ret;\n}\n\nint main()\n{\n    cin >> n;\n    set<int> primes;\n    for(int i = 0; i < n; ++ i) {\n        cin >> a[i];\n        int t = a[i];\n        for(int j = 2; j * j <= t; ++ j) {\n            if (t % j == 0) {\n                primes.insert(j);\n                while(t % j == 0) t /= j;\n            }\n        }\n        if (t > 1) primes.insert(t);\n    }\n\n    sg[0] = 0;\n    int ret = 0;\n    for(auto e: primes) {\n        int state = 0;\n        for(int i = 0; i < n; ++ i) {\n            int cnt = 0;\n            while(a[i] % e == 0) {\n                a[i] /= e;\n                cnt ++;\n            }\n            if (cnt) state |= (1 << (cnt - 1));\n        }\n        //cout << e << \' \' << state << endl;\n        solve(state);\n        ret ^= sg[state];\n    }\n    //for(int i = 0; i < 5; ++ i) cout << i << \' \' << sg[i] << endl;\n\n    cout << (ret ? ""Mojtaba"" : ""Arpa"") << endl;\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2200,The problem is separate for each prime so we will calculate Grundy number for each prime and xor these number to find the answer Now let s solve the problem for some prime like Let s show the game with a th bit of is true if and only if there is a number in the list such that it is divisible by and it isn t divisible by When some player chooses and some in his turn in fact he converts to So for each there is an edge between state and We can caluclate the grundy numbers by this way 
Modern text editors usually show some information regarding the document being edited For example the number of words the number of pages or the number of characters In this problem you should implement the similar functionality You are given a string which only consists of uppercase and lowercase English letters underscore symbols they are used as separators parentheses both opening and closing It is guaranteed that each opening parenthesis has a succeeding closing parenthesis Similarly each closing parentheses has a preceding opening parentheses matching it For each pair of matching parentheses there are no other parenthesis between them In other words each parenthesis in the string belongs to a matching opening closing pair and such pairs can t be nested For example the following string is valid is a maximal sequence of consecutive letters i e such sequence that the first character to the left and the first character to the right of it is an underscore a parenthesis or it just does not exist For example the string above consists of seven words and Write a program that finds the length of the longest word outside the parentheses print if there is no word outside the parentheses the number of words inside the parentheses print if there is no word inside the parentheses ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tstring st, cur;\n\tcin >> st;\n\tint inp(0);\n\tint ans1(0), ans2(0);\n\tst.push_back('(');\n\tfor(int i(0); i < (int)st.size(); i++) {\n\t\tif(st[i] == '_' || st[i] == '(' || st[i] == ')') {\n\t\t\tif(!cur.empty()) {\n\t\t\t\tif(inp) {\n\t\t\t\t\tans2++;\n\t\t\t\t}else {\n\t\t\t\t\tans1 = max(ans1, (int)cur.size());\n\t\t\t\t}\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t\tif(st[i] == '(') {\n\t\t\t\tinp = true;\n\t\t\t}else if(st[i] == ')') {\n\t\t\t\tinp = false;\n\t\t\t}\n\t\t}else {\n\t\t\tcur.push_back(st[i]);\n\t\t}\n\t}\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100,It is an implementation problem Let s store in the variable the number of words inside brackets and in the variable the maximum length of the word outside brackets You can add the symbol to the end of the given string to correctly process the last word Let s iterate through the given string from the left to the right and store in the variable the current word Also in the variable we need to store balance of the open and close brackets If the current symbol is letter add it to the end of the string and go to the next symbol of the given string If the current symbol is open bracket make If the current symbol is close bracket make After that if is non empty string add 1 to if equals to Else if equals to update with length of the string After that we need to assign to the empty string and go to the next symbol of the given string 
You are given an array a consisting of n integers Indices of the array start from zero i e the first element is a 0 the second one is a 1 and so on You can reverse subarray continuous subsegment of this array Recall that the subarray of a with borders l and r is a l r a l a l 1 dots a r Your task is to reverse such a subarray that the sum of elements on positions of the resulting array is i e the sum of elements a 0 a 2 dots a 2k for integer k lfloor frac n 1 2 rfloor should be maximum possible You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        vl A(N); F0R(i, N) cin >> A[i];\n        ll P = 0;\n        ll pre[N+1];\n        pre[0] = 0;\n        ll lo2 = 0;\n        ll lo1 = 1e15;\n        ll ans = 0;\n        F0R(i, N) {\n            if (i % 2 == 0) {\n                P += A[i];\n                pre[i+1] = pre[i] - A[i];\n            } else {\n                pre[i+1] = pre[i] + A[i];\n            }\n            if ((i+1) % 2) {\n                ckmin(lo1, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo1);\n            } else {\n                ckmin(lo2, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo2);\n            }\n\n        }\n//        cout << P << "" "" << pre[N] << nl;\n\n        cout << ans+P << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0]",1600,Firstly we can notice that the reverse of of odd length subarray does nothing because it doesn t change parities of indices of affected elements Secondly we can consider the reverse of the subarray of length as reverses of subarrays of length i e it doesn t matter for us how exactly the subarray will be reversed we can only consider changing parities Now there are two ways the first one is smart and the second one is dynamic programming Consider the first way Calculate the initial sum of elements on even positions Then let s create two arrays and There is for all from to and is for all from to Elements of the first array deonte the profit if we reverse the subarray tarting from the even position and elemnts of the second array denote the profit if we reverse the subarray starting from the odd position Now we need to find the subarray with the maximum sum in both arrays this will maximize overall profit and add this value to to get the answer This problem can be solved easily consider the sum of the subarray as the difference of two prefix sums To maximize it consider all right borders and minimize the value Iterate over all positions of the array maintaining the current prefix sum and the minimum prefix sum we meet Update then update and then update the answer with the value And the second way is author s solution and it is dynamic programming This idea can be transformed to solve such problems in which you need to apply some function to some small number of subsegments of course under some constraints on functions State of our dynamic programming is where and denotes the answer on the prefix of length if we didn t start reversing the subarray denotes the answer if we started reversing the subarray but didn t end it and denotes the answer if we ended reversing the subarray Transitions are pretty easy The value is just a ternary if statement If is true then return otherwise return The answer is Time complexity with both approaches is 
Levko loves tables that consist of rows and columns very much He especially loves beautiful tables A table is to Levko if the sum of elements in each row and column of the table equals Unfortunately he doesn t know any such table Your task is to help him to find at least one of them ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <memory.h>\n#include <time.h>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nint a[222][222];\n\nint main(){\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    ios_base::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    for (int i = 1; i<=n; i++)\n     for (int j = 1; j<=n; j++) a[i][j]=1;\n    int ans = m - (n-1);\n    for (int i = 1; i<=n; i++) a[i][i]=ans;\n    for (int i = 1; i<=n; i++){\n    for (int j = 1; j<=n; j++) cout << a[i][j] << "" ""; cout << endl;\n    }\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",800,Matrix in which all diagonal elements equal and other elements equal satisfied all conditions For example if n 4 and k 7 our matrix will be 7 0 0 0 0 7 0 0 0 0 7 0 0 0 0 7 
You ve got two rectangular tables with sizes and cells The tables consist of zeroes and ones We will consider the rows and columns of both tables indexed starting from 1 Then we will define the element of the first table located at the intersection of the th row and the th column as we will define the element of the second table located at the intersection of the th row and the th column as We will call the pair of integers a of the second table relative to the first one We ll call the of the shift value where the variables take only such values in which the expression makes sense More formally inequalities must hold If there are no values of variables that satisfy the given inequalities the value of the sum is considered equal to 0 Your task is to find the shift with the maximum overlap factor among all possible shifts ,"['// AntiFate\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define fab(i,a,b) for(int i=(a);i<=(b);++i)\n#define fba(i,b,a) for(int i=(b);i>=(a);--i)\n#define clr(a) memset(a,0,sizeof(a))\n#define fec(i,a) for(__typeof((a).end())i=(a).begin();i!=(a).end();++i)\n#define fpc(i,j,v) for(int i=a[v],j;j=to[i],i;i=nx[i])\n\n#define N 55\n\nchar a[N][N], b[N][N];\nint n, m, p, q;\n\nint main()\n{\n    scanf(""%d%d\\n"", &n, &m);\n    rep(i, n)\n        gets(a[i+1]+1);\n    \n    scanf(""%d%d\\n"", &p, &q);\n    rep(i, p)\n        gets(b[i+1]+1);\n    \n    int xx = 0, yy = 0, ans = 0;\n    fab(x,-(n+p), n+p)\n        fab(y,-(m+q), m+q)\n        {\n            int ret = 0;\n        fab(i,1,n) if (x+i>=1 && x+i<=p)\n        fab(j,1,m) if (y+j>=1 && y+j<=q)\n        if(a[i][j]==b[x+i][y+j] && a[i][j]==\'1\')\n            ++ret;\n        if(ret > ans)\n        {\n            ans = ret;\n            xx=x;\n            yy=y;\n        }\n        }\n        \n    cout << xx << "" "" << yy << endl;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1400,In this problem you should carefully consider every shift count the answer and find the maximum value The complexity of solution is 
ZS the Coder has recently found an interesting concept called the Birthday Paradox It states that given a random set of people there is around chance that some two of them share the same birthday ZS the Coder finds this very interesting and decides to test this with the inhabitants of Udayland In Udayland there are days in a year ZS the Coder wants to interview people from Udayland each of them has birthday in one of days each day with equal probability He is interested in the probability of at least two of them have the birthday at the same day ZS the Coder knows that the answer can be written as an irreducible fraction He wants to find the values of and he does not like to deal with floating point numbers Can you help him ,"['#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int maxn = (int)1e6;\nconst int inf = (int)1e9;\nconst int mod = (int)1e6 + 3;\nconst ll INF = (ll)1e18;\nconst double eps = 1e-9;\n\nll n, k;\n\nll binpow(ll a, ll k) {\n\tif (k == 0) return 1;\n\tll ans = binpow(a, k / 2);\n\tans = 1ll * ans * ans % mod;\n\tif (k % 2) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\n\nll g(ll n, ll k) {\n\tif (k < mod) {\n\t\tll t = binpow(2, n);\n\t\tll ans = 1;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tans *= (t - (2ll * i + 1));\n\t\t\tans %= mod;\n\t\t\tif (ans < 0) ans += mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tll t = binpow(2, n);\n\tll cur = 1;\n\tfor (int i = 0; i < mod; i++) {\n\t\tcur *= (t - (2ll * i + 1));\n\t\tcur %= mod;\n\t\tif (cur < 0) cur += mod;\n\t}\n\tll s = k / mod;\n\tll ans = binpow(cur, s) * g(n, k % mod) % mod;\n\treturn ans;\n}\n\nll f(ll n, ll k) {\n\tif (k == 0) return 1;\n\tll t = (k - 1) / 2;\n\tll ans = g(n, t);\n\treturn ans * 1ll * f(n - 1, k / 2) % mod;\n}\n\nll get(ll n, ll k) {\n\tif (k == 0) return 0;\n\tll t = k / 2;\n\treturn t + get(n, t);\n}\n\nint main()\n{\n\n\tcin >> n >> k;\n\t\n\tif (n <= 60) {\n\t\tll mx = 1;\n\t\tfor (int i = 0; i < n; i++) mx *= 2;\n\t\tif (mx < k) {\n\t\t\tcout << 1 << "" "" << 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tll alpha = get(n, k - 1);\n\tll P = f(n, k - 1);\n\tll t = n % (mod - 1) * 1ll * ((k - 1) % (mod - 1)) % (mod - 1);\n\tt -= alpha;\n\tt %= mod - 1;\n\tt += mod - 1;\n\tt %= mod - 1;\n\tll Q = binpow(2, t);\n\t\n\tP = Q - P;\n\tP %= mod; P += mod; P %= mod;\n\t\n\tcout << P << "" "" << Q << endl;\n\t\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2300,Note that is a prime Firstly if we have then by pigeonhole principle we must have people with the same birthday Thus we can directly output Thus now we suppose Then instead of computing the probability directly we compute the complement i e the probability that all the people have distinct birthdays This probability turns out to be much simpler to calculate as it is just Fix the birthday of the first person the probability that the second person has different birthday is and for the next person it s and so on Now we know that the denominator is just a power of However we still have to reduce the fraction to the lowest terms Note that is in the lowest terms if and only if is in the lowest terms since Also note that the gcd is a power of since the denominator is a power of Thus we need to find the highest power of that divides This is also equal to the sum of the highest power of that divides Now if a power of divides then it must also divides and vice versa So we can actually translate this to finding the sum of highest power of that divides or the highest power of that divides Now this is simple to calculate by Legendre s formula which is quite easy to prove in Now that we find the gcd of the numerator and denominator we can immediately find the reduced denominator by binary exponentiation For the numerator we need a bit more work since we have to deal with However it is not hard either The key fact is that is small so if the product above is equal to modulo because among consecutive integers there must be one that is a multiple of Thus the above product can be calculated in if and otherwise The remaining parts can be calculated using direct binary exponentiation One minor note is that when we re calculating the value of might overflow One way to resolve this is to reduce it modulo since modulo by Fermat s Little Theorem Another way is to just evaluate first then take the result and raise it to the th power Time Complexity 
Nastia has a hidden permutation p of length n consisting of integers from 1 to n You for some reason want to figure out the permutation To do that you can give her an integer t 1 le t le 2 two indices i and j 1 le i j le n i neq j and an integer x 1 le x le n 1 Depending on t she will answer t 1 max min x p i min x 1 p j t 2 min max x p i max x 1 p j You can ask Nastia lfloor frac 3 cdot n 2 rfloor 30 times It is guaranteed that she will change her permutation depending on your queries Can you guess the permutation ,"['#include <bits/stdc++.h>\n#define _FORTIFY_SOURCE 0\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""no-stack-protector"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native"")\n#pragma GCC optimize(""fast-math"")\n#define int long long\n\nusing namespace std;\n\nmt19937 rnd(time(nullptr));\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int pos = -1;\n    for (int i = 0; i < n - 1; i += 2) {\n        cout << ""? 2 "" << i + 1 << "" "" << i + 2 << "" "" << 1 << endl;\n        int res;\n        cin >> res;\n        if (res == 1) {\n            pos = i;\n            break;\n        }\n        if (res == 2) {\n            cout << ""? 2 "" << i + 2 << "" "" << i + 1 << "" "" << 1 << endl;\n            int kek;\n            cin >> kek;\n            if (kek == 1) {\n                pos = i + 1;\n                break;\n            }\n        }\n    }\n    if (pos == -1)\n        pos = n - 1;\n    vector <int> ans(n);\n    ans[pos] = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == pos)\n            continue;\n        cout << ""? 1 "" << pos + 1 << "" "" << i + 1 << "" "" << n - 1 << endl;\n        int res;\n        cin >> res;\n        ans[i] = res;\n    }\n    cout << ""! "";\n    for (int x : ans)\n        cout << x << "" "";\n    cout << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2000,Let s fix indices and Then restore and Let s assume we know the maximum element among and Now we can figure out where exactly the maximum is by asking the following query There are cases it means otherwise it means because If we know where the maximum is located we easily can find the remaining element if then if then We can solve the problem if we know the Let s find it Take a look on the case when Here we cannot be sure that It s possible only if Thus if we spend an extra query to be sure that We will ask So if then the value equlas to otherwise the value equals to the real maximum among and As a result we can restore any elements of the permutation Let s split our permutation into pairs and restore them independently of each other The total queries we perform is We spend operations to restore each of the pair of elements And than extra queries to be sure that is correct Let s find the maximum of the permutation and then restore the element of the permutation by query To find the maximum element let s split the permutation into pairs and perform the following operation to each of them if then is the position with a maximum element if then need to make sure that Let s make the same extra query as we do in the Note that if you don t find the maximum element among the then it s in the remaining element when is odd The total queries we perform is n We ask queries to find the maximum of the permutation and quiries to restore the remaining elements 
You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 You are given a tree on n vertices vertex 1 is the root of the tree For every i in 2 n the parent of the i th vertex is p i and p i i You have to color all edges of the tree using the such that you can win the game on that tree every edge should be painted into exactly one color The game we re going to play will be conducted as follows After you paint the edges and print their colors the jury will place a chip into one of the vertices of the tree except for the root Your goal is to move this chip to the root in exactly d moves where d is the distance from the root to that vertex the distance is equal to the number of edges on the path If the chip reaches the root in d moves you win Otherwise you lose The jury won t tell you where the chip is located You won t even know the value of d in advance However at the start of each move you will be told how many edges of each color are incident to the current vertex this includes both the edge leading up the tree and the edges leading away from the root You have to choose one of these colors and the chip will be moved along the edge of the chosen color if there are multiple edges with that color incident to the current vertex the jury gets to choose one of them After the chip is moved you will be told the same information about the current vertex again and the game continues until you either reach the root or you make d moves without reaching the root It means that both the starting vertex and the current vertex are and may change on the run depending on the output of your program However the state of the game will always be consistent with the information you are given ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    int dep[N]; F0R(i, N) dep[i] = 0;\n    int deg[N]; F0R(i, N) deg[i] = 0;\n    int rt[N]; F0R(i, N) rt[i] = 0;\n    int cap = 0;\n    FOR(i, 1, N) {\n        int X; cin >> X; X--;\n        dep[i] = dep[X] + 1;\n        deg[i]++; deg[X]++;\n        ckmax(cap, dep[i]);\n        if (X == 0) {\n            rt[i] = i;\n        } else rt[i] = rt[X];\n    }\n    if (cap == 1) {\n        cout << 1 << endl;\n        FOR(i, 1, N) {\n            cout << 1 << "" "";\n        }\n        cout << endl;\n        while (true) {\n            int X; cin >> X;\n            if (X != 0) return;\n            cin >> X;\n            cout << 1 << endl;\n        }\n    }\n    map<int, int> pa;\n    bool ok = true;\n    FOR(i, 1, N) {\n        if (deg[i] == 2) {\n            if (!pa.count(rt[i])) pa[rt[i]] = dep[i]%2;\n            if (pa[rt[i]] != dep[i]%2) ok = false;\n        }\n    }\n    if (ok) {\n        cout << 2 << endl;\n        FOR(i, 1, N) {\n            int val = dep[i] % 2;\n            if (val == 0) val = 2;\n            if (pa[rt[i]] == 0) val = 3 - val;\n            cout << val << "" "";\n        }\n        cout << endl;\n        while (true) {\n            int X; cin >> X;\n            if (X != 0) return;\n            int A, B; cin >> A >> B;\n            if (A == 1) {\n                cout << 1 << endl;\n            } else {\n                cout << 2 << endl;\n            }\n        }\n    }\n    cout << 3 << endl;\n    FOR(i, 1, N) {\n        int val = dep[i] % 3;\n        if (val == 0) val = 3;\n        cout << val << "" "";\n    }\n    cout << endl;\n    assert(cap >= 3);\n    while (true) {\n        int X; cin >> X;\n        if (X != 0) return;\n        int A[3]; F0R(i, 3) A[i] = 0;\n        F0R(i, min(cap, 3)) cin >> A[i];\n        int cnt = 0;\n        F0R(i, min(cap, 3)) cnt += A[i];\n        F0R(i, 3) {\n            if (A[i] == cnt) {\n                cout << i+1 << endl;\n                goto done;\n            }\n        }\n        F0R(i, 3) {\n            if (A[i] == 0) {\n                cout << (i+1)%3 + 1 << endl;\n                goto done;\n            }\n        }\n        done:\n        ;\n    }\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 1]",2400,First of all we need to analyze how we can win the game Since we have to reach the root from a vertex with distance in exactly moves every move we make should be towards the root So for each vertex knowing the colors of adjacent edges we need to uniquely determine the color we choose to go up This means that the color of the edge leading up must be different from the colors of the edges going down otherwise the jury might move the chip down when we re trying to go up Let s try to estimate the maximum number of colors we have to use In fact we don t need more than three colors We can use the following recursive coloring strategy for example if an edge connecting with has color then all other edges incident to should have color So if a vertex is adjacent to edges with colors and the edge with color leads up if the colors are and the edge with color leads up and so on So we don t need to use more than colors Let s figure out when we can use less than colors The case is pretty simple it s if and only if all vertices from to are the children of the root because otherwise some vertex will have more than adjacent edge and it s impossible to choose the edge going up for that vertex The case is a bit more challenging If an edge from to has color then all other edges incident to should have color and vice versa So for every vertex which has or children the edge different from all of the other edges leads to the root But for vertices having exactly one child we cannot easily distinguish between the color going up and the color going down So let s make sure that for every such vertex the edge that leads up has the same color So here are the constraints on the edges we need to ensure so that a coloring allows us to win the game for every vertex every edge going down from it must have a different color than the edge going up for every vertex with exactly child the color of the edge leading up must be the same There are a few ways to enforce these two constraints but in my opinion the most straightforward of them is to use bipartite coloring Create a graph where each edge is represented by a vertex The first condition can be modeled if for each vertex of the tree we add edges from the vertex representing the edge going up to vertices representing all other edges The second condition is also quite easy to model create an auxiliary vertex in the graph and for every vertex having exactly one child in the tree connect the vertex representing its parent edge with that auxiliary vertex If the resulting graph is bipartite then its coloring can be used to choose the colors for the edges of the tree 
HQ9 is a joke programming language which has only four one character instructions prints prints the source code of the program itself prints the lyrics of 99 Bottles of Beer song increments the value stored in the internal accumulator Instructions and are case sensitive and must be uppercase The characters of the program which are not instructions are ignored You are given a program written in HQ9 You have to figure out whether executing this program will produce any output ,"['#include <cstdio>\n#include <string>\n#include <map>\n#include <cstring>\n#include <bitset>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <memory.h>\n#include <list>\n#include <vector>\n#include <set>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define sqr(n)  (n)*(n)\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define INF 2000000000\n\ntypedef long long ll;\n\nint main()\n{\n    string s;\n    cin >> s;\n    bool flag = false;\n    for(int i = 0; i < s.size(); i++)\n        if(s[i]==\'H\' || s[i]==\'Q\' || s[i]==\'9\')\n            flag = true;\n    if(flag)\n        printf(""YES"");\n    else\n        printf(""NO"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,The problem described HQ9 programming language and asked whether the given program will print anything Given the extraordinary simplicity of the language it was enough to check whether the program contains at least one of the characters H Q and 9 
There are n people who want to participate in a boat competition The weight of the i th participant is w i Only teams consisting of people can participate in this competition As an organizer you think that it s fair to allow only teams with So if there are k teams a 1 b 1 a 2 b 2 dots a k b k where a i is the weight of the first participant of the i th team and b i is the weight of the second participant of the i th team then the condition a 1 b 1 a 2 b 2 dots a k b k s where s is the total weight of team should be satisfied Your task is to choose such s that the number of teams people can create is the possible Note that each participant can be in team You have to answer t independent test cases ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << \'=\' << x << std::endl\n\nconst int MAXN = 100+5;\nint a[MAXN],n;\nint cnt[MAXN];\n\ninline int chk(int k){\n    FOR(i,1,n) cnt[i] = 0;\n    FOR(i,1,n) cnt[a[i]]++;\n    int res = 0;\n    FOR(x,1,n){\n        int y = k-x;\n        if(y >= 1 && y <= n){\n            if(x == y){\n                res += cnt[x]/2;\n                cnt[x] %= 2;\n            }\n            else{\n                int gx = std::min(cnt[x],cnt[y]);\n                cnt[x] -= gx;cnt[y] -= gx;\n                res += gx;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int T;scanf(""%d"",&T);\n    while(T--){\n        scanf(""%d"",&n);\n        FOR(i,1,n) scanf(""%d"",a+i);int ans = 0;\n        FOR(i,1,2*n) ans = std::max(ans,chk(i));\n        printf(""%d\\n"",ans);\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1200,This is just an implementation problem Firstly let s fix it can be in range find the maximum number of boats we can obtain with this and choose the maximum among all found values To find the number of pairs let s iterate over the smallest weight in the team in range Let this weight be Then because the sum of weights is the biggest weight is And the number of pairs we can obtain with such two weights and the total weight is where is the number of occurrences of in And the additional case if is even we need to add Don t forget that there is a case so you need to assume that these values are zeros 
There is a sequence of colorful stones The color of each stone is one of red green or blue You are given a string The th 1 based character of represents the color of the th stone If the character is or the color of the corresponding stone is red green or blue respectively Initially Squirrel Liss is standing on the first stone You perform instructions one or more times Each instruction is one of the three types or After an instruction if Liss is standing on a stone whose colors is Liss will move one stone forward else she will not move You are given a string The number of instructions is equal to the length of and the th character of represents the th instruction Calculate the final position of Liss the number of the stone she is going to stand on in the end after performing all the instructions and print its 1 based position It is guaranteed that Liss don t move out of the sequence ,"['#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring s, t;\n\nint main()\n{\n\tcin >> s;\n\tcin >> t;\n\tint i = 0, j = 0;\n\twhile (i < s.length() && j < t.length())\n\t{\n\t\tif (s[i] == t[j])\n\t\t{\n\t\t\ti++, j++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << i + 1 << endl;\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,In this problem you just need to implement what is written in the statement Make a variable that holds the position of Liss and simulate the instructions one by one 
k Gildong loves observing animals so he bought two cameras to take videos of wild animals in a forest The color of one camera is red and the other one s color is blue Gildong is going to take videos for n days starting from day 1 to day n The forest can be divided into m areas numbered from 1 to m He ll use the cameras in the following way On every odd day 1 st 3 rd 5 th bring the red camera to the forest and record a video for 2 days On every even day 2 nd 4 th 6 th bring the blue camera to the forest and record a video for 2 days If he starts recording on the n th day with one of the cameras the camera records for only one day Each camera can observe k consecutive areas of the forest For example if m 5 and k 3 he can put a camera to observe one of these three ranges of areas for two days 1 3 2 4 and 3 5 Gildong got information about how many animals will be seen in each area on each day Since he would like to observe as many animals as possible he wants you to find the best way to place the two cameras for n days ,"['#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N , M , K , dp[53][20003] , sum[503][20003];\n\nint main(){\n\tcin>>N>>M>>K;\n\tfor(int i = 1 ; i <= N ; ++i)\n\t\tfor(int j = 1; j <= M ; ++j){\n\t\t\tcin>>sum[i][j]; sum[i][j] += sum[i][j -1 ];\n\t\t}\n\tmemset(dp , -0x1f , sizeof(dp));\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) dp[1][i] = sum[1][i + K - 1] - sum[1][i - 1] + sum[2][i + K - 1] - sum[2][i - 1];\n\tfor(int i = 2 ; i <= N ; ++i){\n\t\tdeque < int > q;\n\t\tfor(int j = 1 ; j <= K && j <= M - K + 1 ; ++j){\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][j] + sum[i][j - 1]) q.pop_back();\n\t\t\tq.push_back(j);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] + sum[i][q.front() - 1] - sum[i][j - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j + K <= M - K + 1){\n\t\t\t\tint t = j + K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][t] + sum[i][t - 1]) q.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tq.clear();\n\t\tfor(int j = 1 ; j <= M - K + 1 && j <= K ; ++j){\n\t\t\tint t = M - K + 2 - j;\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\tq.pop_back();\n\t\t\tq.push_back(t);\n\t\t}\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] - sum[i][q.front() + K - 1] + sum[i][j + K - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j - K > 0){\n\t\t\t\tint t = j - K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\t\tq.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tfor(int j = 1 ; j <= M - K + 1; ++j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j + K <= M - K + 1) dp[i][j + K] = max(dp[i][j + K] , mx + sum[i][j + K + K - 1] - sum[i][j + K - 1]);\n\t\t}\n\t\tmx = 0;\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j - K > 0) dp[i][j - K] = max(dp[i][j - K] , mx + sum[i][j - 1] - sum[i][j - K - 1]);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j)\n\t\t\tdp[i][j] += sum[i + 1][j + K - 1] - sum[i + 1][j - 1];\n\t}\n\tint mx = 0;\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) mx = max(mx , dp[N][i]);\n\tcout << mx;\n\treturn 0;\n}\n']","[1, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2400,We can further advance the idea we used in F1 to reduce the time complexity Let s generalize all three cases we discussed in F1 Let s make a lazy segment tree supporting range addition update and range maximum query Each node represents the maximum value of minus the sum of the animals appearing on the th day in the intersected area in the corresponding interval Then we can add to the maximum value of the segment tree to determine For the th day we insert in the respective index of the segment tree for all initially Now to determine for each we want to subtract from the segment tree for all But it is infeasible to do this and add them back for every single s that has intersected areas Here we can use sliding window technique to improve it To determine we can manually subtract the first elements of from the segment tree like above Let s assume that we re done with determining When we move on to determining we can see that is no longer in the range and thus should be added back to the segment tree Precisely all s where is within range are affected by this and must be added with Similarly is now in the range and thus should be subtracted from all s where is within range Each range update takes time and this happens only two times for determining each The initial work takes time but it happens only once for each day Therefore it takes time for each day and time in total It turns out that it s even possible without the segment tree Of course is intended to pass so you don t really need to implement this to solve the problem Instead of segment tree we ll use monotonic queue structure the core idea for convex hull trick to have the values in decreasing order from front to back If you don t know what monotonic queue is make sure you understand it first You can read about it here We ll do basically the same thing we did for solution but there are two major differences First we ll slide the window two times one from left to right and the other one from right to left Second we ll only consider the values where the range of their indices intersects with the window but only a part of them We ll see how it works when sliding the window from left to right then we can also do it in reverse direction We ll only consider all where is within range In other words we only consider it when the intersected area is a prefix of the window This means when we re about to determine in fact the actual value will be is inserted into the queue and is removed from the queue Now let s see how the real values in the queue are changed while sliding the window Since we ll only add the same value to all elements in the queue every time we slide the window the order of the elements won t be changed thus maintaining the monotone queue structure However we don t actually need to perform the add action simply because we can always calculate it in time by calculating the sum of the animals between the index of that element inclusive and the window exclusive So to the real value at the front of the queue we can add to determine The exact same thing can be done in the reversed way too Now let s take back the prefix and suffix max we discussed in F1 so that we can check the cases when they do not intersect We can see that each of these operations can be done in for each day Therefore the whole process is performed in time 
Sereja has an array consisting of integers The boy cannot sit and do nothing he decided to study an array Sereja took a piece of paper and wrote out integers For each number he wants to know how many distinct numbers are staying on the positions Formally he want to find the number of distinct numbers among Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time Help him find the answer for the described question for each ,"['/*\n * Package: StandardCodeLibrary.Core\n * */\n//引进常用的头文件并使用std名字空间;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//用于减少代码量的宏;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//调试相关的宏;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(""OLE"");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,""r"",stdin)\n#define output(out) freopen(out,""w"",stdout)\n#else\n#define prt(x) cerr<<""第""<<__LINE__<<""行\\t: ""<<#x""\\t=""<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define runtime() cerr<<""Used: ""<<db(clock())/CLOCKS_PER_SEC<<""s""<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//常用数据类型;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//常用常量:int的最大值;lli的最大值;db的误差相关常数;欧拉常数;圆周率;移动向量;取模使用的除数;\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//常用函数:最大最小值更新;数学相关函数;输入和输出;树状数组;并查集;可合并堆;\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ninline lli bin_pow(lli x,lli y){lli z=1;whl(y){if(y&1)z=mod(z*x);x=mod(sqr(x)),y>>=1;}rtn z;}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<"" ""<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?"""":"" "");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));rrep(i,y){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ninline void make_set(vpii& st){rep(i,sz(st))st[i]=mp(i,1);}\ninline int find_set(vpii& st,int x){int y=x,z;whl(y!=st[y].x)y=st[y].x;whl(x!=st[x].x)z=st[x].x,st[x].x=y,x=z;rtn y;}\ninline bool union_set(vpii& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?(st[a].y>st[b].y?st[a].x=b,st[a].y+=st[b].y:st[b].x=a,st[b].y+=st[a].y),true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//初始化;\nstruct Initializer{\n#ifndef DEBUG\nInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n~Initializer(){runtime();}\n#endif\n}initializer;\n\n//非标准;\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx::rope<char> rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tvi a(n);\n\tcin>>a;\n\tsi s;\n\tvi cnt(n);\n\trrep(i,n)\n\t{\n\t\ts.ins(a[i]);\n\t\tcnt[i]=sz(s);\n\t}\n\trep(i,m)\n\t{\n\t\tint l;\n\t\tcin>>l;\n\t\tcout<<cnt[--l]<<endl;\n\t}\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1100,We will count value number of different elements on the suffix from For calculation will walk from the end of the array and we count equals to if element has not yet met and otherwise 
Andrey received a postcard from Irina It contained only the words Hello Andrey and a strange string consisting of lowercase Latin letters snowflakes and candy canes Andrey thought that this string is an encrypted message and decided to decrypt it Andrey noticed that snowflakes and candy canes always stand after the letters so he supposed that the message was encrypted as follows Candy cane means that the letter before it can be removed or can be left A snowflake means that the letter before it can be removed left or repeated several times For example consider the following string This string can encode the message For this candy canes and snowflakes should be used as follows candy cane 1 remove the letter snowflake 1 repeat the letter twice candy cane 2 leave the letter snowflake 2 remove the letter snowflake 3 leave the letter Please note that the same string can encode different messages For example the string above can encode and other messages Andrey knows that messages from Irina usually have a length of k letters Help him to find out if a given string can encode a message of k letters and if so give an example of such a message ,"['#include <bits/stdc++.h>\n#define endl \'\\n\'\n\n//#pragma GCC optimize (""O3"")\n//#pragma GCC target (""sse4"")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nstring s;\nint k;\n\nvoid read()\n{\n\tcin >> s;\n\tcin >> k;\n}\n\nint type[MAXN];\n\nvoid solve()\n{\n\tstring t;\n\tfor(char c: s)\n\t{\n\t\tif(c == \'?\') type[t.size() - 1] = 1;\n\t\telse if(c == \'*\') type[t.size() - 1] = 2;\n\t\telse t.pb(c);\n\t}\n\n\tif(SZ(t) == k)\n\t{\n\t\tcout << t << endl;\n\t\treturn;\n\t}\n\n\tif(SZ(t) < k)\n\t{\n\t\tstring tmp;\n\t\tint additional = k - SZ(t);\n\t\tfor(int i = 0; i < SZ(t); i++)\n\t\t\tif(type[i] == 2)\n\t\t\t{\n\t\t\t\ttmp.pb(t[i]);\n\t\t\t\twhile(additional)\n\t\t\t\t\tadditional--, tmp.pb(t[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.pb(t[i]);\n\t\t\t}\n\n\t\tif(SZ(tmp) < k) cout << ""Impossible"" << endl;\n\t\telse cout << tmp << endl;\n\t\treturn;\n\t}\n\n\tif(SZ(t) > k)\n\t{\n\t\tstring tmp;\n\t\tint need = SZ(t) - k;\n\t\tfor(int i = 0; i < SZ(t); i++)\n\t\t{\n\t\t\tif(need && type[i]) { need--; continue; }\n\t\t\ttmp.pb(t[i]);\n\t\t}\n\n\t\tif(need) cout << ""Impossible"" << endl;\n\t\telse cout << tmp << endl;\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1200,If the string in the postcard does not contain any snowflakes or candy cones must be equal to the length of the string because the only string encoded by such message is the string itself and in this case if is not equal to the length of the string the answer is Let s call the characters of the message if they are not followed by snowflakes or candy cones Clearly should be at least the number of mandatory characters otherwise the answer is In case there a snowflake in the message we can repeat the preceding character enough times to get the length and remove the rest of non mandatory characters If there are no snowflakes but only candy cones we should use the characters followed by candy cones until we get the desired length In case we don t have enough the answer is 
Alice has a cute cat To keep her cat fit Alice wants to design an exercising walk for her cat Initially Alice s cat is located in a cell x y of an infinite grid According to Alice s theory cat needs to move exactly a steps left from u v to u 1 v exactly b steps right from u v to u 1 v exactly c steps down from u v to u v 1 exactly d steps up from u v to u v 1 Note that the moves can be performed in an For example if the cat has to move 1 step left 3 steps right and 2 steps down then the walk right down left right right down is valid Alice however is worrying that her cat might get lost if it moves far away from her So she hopes that her cat is in the area x 1 x 2 times y 1 y 2 i e for every cat s position u v of a walk x 1 le u le x 2 and y 1 le v le y 2 holds Also note that the cat can visit the same cell multiple times Can you help Alice find out if there exists a walk satisfying her wishes Formally the walk should contain exactly a b c d unit moves a to the left b to the right c to the down d to the up Alice can do the moves in order Her current position u v should satisfy the constraints x 1 le u le x 2 y 1 le v le y 2 The staring point is x y You are required to answer t test cases ,"['#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < \'0\' || c > \'9\') && c != \'-\');\n\tif (c == \'-\') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= \'0\' && c <= \'9\')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\nint main()\n{\n\tint T; read(T);\n\twhile (T--)\n\t{\n\t\tint a, b, c, d, X, Y, xl, yl, xr, yr;\n\t\tread(a); read(b); read(c); read(d); read(X); read(Y); read(xl); read(yl);\n\t\tread(xr); read(yr);\n\t\tif (xl == xr && (a || b)) {puts(""no""); continue;}\n\t\tif (yl == yr && (c || d)) {puts(""no""); continue;}\n\t\tX += b - a; Y += d - c;\n\t\tputs(xl <= X && X <= xr && yl <= Y && Y <= yr ? ""yes"" : ""no"");\n\t}\n\treturn 0;\n}']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1100,The key observation is x axis and y axis is independent in this task as the area is a rectangle Therefore we should only consider 1D case x axis for example The optimal path to choose alternates between right and left moves until only one type of move is possible And sometimes there is no place to make even one move which has to handled separately So the verdict is if and only if and or 
John Smith knows that his son Thomas Smith is among the best students in his class and even in his school After the students of the school took the exams in English German Math and History a table of results was formed There are n students each of them has a id from 1 to n Thomas s id is 1 Every student has four scores correspond to his or her English German Math and History scores The students are given in order of increasing of their ids In the table the students will be sorted by the sum of their scores So a student with the largest sum will get the first place If two or more students have the same sum these students will be sorted by their ids Please help John find out the rank of his son ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n; cin >> n;\n    int z;\n    vi v;\n    F0R(i,n) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        v.pb(a+b+c+d);\n        if (i == 0) z = a+b+c+d;\n    }\n    sort(v.rbegin(),v.rend());\n    F0R(i,sz(v)) if (v[i] == z) {\n        cout << i+1;\n        exit(0);\n    }\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,For each student add his her scores together and count how many students have strictly lower scores than Thomas Complexity or 
Since next season are coming you d like to form a team from two or three participants There are n candidates the i th candidate has rank a i But you have weird requirements for your teammates if you have rank v and have chosen the i th and j th candidate then GCD v a i X and LCM v a j Y must be met You are very experienced so you can change your rank to any non negative integer but X and Y are tied with your birthdate so they are fixed Now you want to know how many are there pairs i j such that there exists an integer v meeting the following constraints GCD v a i X and LCM v a j Y It s possible that i j and you form a team of two GCD is the greatest common divisor of two number LCM the least common multiple ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n// n < 4,759,123,141        3 :  2, 7, 61\n// n < 1,122,004,669,633    4 :  2, 13, 23, 1662803\n// n < 3,474,749,660,383          6 :  pirmes <= 13\n// n < 2^64                       7 :\n// 2, 325, 9375, 28178, 450775, 9780504, 1795265022\n// Make sure testing integer is in range [2, n−2] if\n// you want to use magic.\nLL add(LL a, LL b, LL mod){\n  a+=b;\n  return a>=mod?a-mod:a;\n}\nLL mul(LL a, LL b, LL mod){\n  LL ret=0;\n  while(b){\n    if(b&1LL) ret=(ret+a)%mod;\n    a=(a+a)%mod;\n    b>>=1;\n  }\n  return ret;\n}\nLL mypow(LL a, LL b, LL mod){\n  LL ret=1;\n  while(b){\n    if(b&1LL) ret=mul(ret, a, mod);\n    a=mul(a, a, mod);\n    b>>=1;\n  }\n  return ret;\n}\nbool witness(LL a,LL n,LL u,int t){\n\tLL x=mypow(a,u,n);\n\tfor(int i=0;i<t;i++) {\n\t\tLL nx=mul(x,x,n);\n\t\tif(nx==1&&x!=1&&x!=n-1) return 1;\n\t\tx=nx;\n\t}\n\treturn x!=1;\n}\nbool miller_rabin(LL n) {\n\t// iterate s times of witness on n\n\t// return 1 if prime, 0 otherwise\n\tif(n<2) return 0;\n\tif(!(n&1)) return n == 2;\n\tLL u=n-1; int t=0;\n\t// n-1 = u*2^t\n\twhile(!(u&1)) u>>=1, t++;\n  for(LL a: {2, 325, 9375, 28178, 450775, 9780504, 1795265022}){\n    if(a > n-2)\n      continue;\n\t\tif(witness(a,n,u,t))\n      return 0;\n\t}\n\treturn 1;\n}\n// does not work when n is prime\nLL f(LL x, LL mod){ return add(mul(x,x,mod),1,mod); }\nLL myrand(LL n){\n  LL ret=1;\n  for(int i=0; i<4; i++)\n    ret=(ret<<15)|(rand() & ((1LL<<15)-1));\n  return ret%n;\n}\nLL pollard_rho(LL n) {\n\tif(!(n&1)) return 2;\n  while(true){\n    LL y=2, x=myrand(n-1)+1, res=1;\n    for(int sz=2; res==1; sz*=2) {\n      for(int i=0; i<sz && res<=1; i++) {\n        x = f(x, n);\n        res = __gcd(abs(x-y), n);\n      }\n      y = x;\n    }\n    if (res!=0 && res!=n) return res;\n  }\n}\nconst int N=202020;\nLL n, x, y, a[N];\nvector<LL> pris;\nbool factor(LL val, vector<LL>& cc){\n  cc.resize(pris.size());\n  for(size_t i=0; i<pris.size(); i++){\n    cc[i]=0;\n    while(val % pris[i] == 0){\n      val/=pris[i];\n      cc[i]++;\n    }\n  }\n  return val==1;\n}\nvector<LL> cx, cy;\nvector<LL> coe[N];\nbool okay[N];\nLL cnt[1<<19];\nvoid go(){\n  assert(factor(x, cx));\n  assert(factor(y, cy));\n  for(int i=0; i<n; i++)\n    okay[i]=factor(a[i], coe[i]);\n  for(int i=0; i<n; i++){\n    { // as i\n      bool ok=true;\n      int msk=0;\n      for(size_t j=0; j<pris.size(); j++){\n        if(coe[i][j] < cx[j]){\n          ok=false;\n          break;\n        }\n        if(coe[i][j] == cx[j] or cx[j] == cy[j])\n          continue;\n        msk|=(1<<j);\n      }\n      if(not ok) continue;\n      cnt[msk]++;\n    }\n  }\n  for(size_t i=0; i<pris.size(); i++)\n    for(int j=0; j<(1<<(pris.size())); j++)\n      if((j >> i) & 1)\n        cnt[j]+=cnt[j^(1<<i)];\n  LL ans=0;\n  int ALL=(1<<pris.size())-1;\n  for(int i=0; i<n; i++){\n    { // as j\n      if(not okay[i]) continue;\n      bool ok=true;\n      int msk=0;\n      for(size_t j=0; j<pris.size(); j++){\n        if(coe[i][j] > cy[j]){\n          ok=false;\n          break;\n        }\n        if(coe[i][j] == cy[j] or cx[j] == cy[j])\n          continue;\n        msk|=(1<<j);\n      }\n      if(not ok) continue;\n      msk^=ALL;\n      ans+=cnt[msk];\n    }\n  }\n  printf(""%lld\\n"", ans);\n}\nint main(){\n  scanf(""%lld%lld%lld"", &n, &x, &y);\n  for(int i=0; i<n; i++) scanf(""%lld"", &a[i]);\n  if(y%x){\n    puts(""0"");\n    exit(0);\n  }\n  {\n    LL tmpy=y;\n    for(LL i=2; i<=1e6+10; i++){\n      if(tmpy % i) continue;\n      pris.push_back(i);\n      while(tmpy % i == 0) tmpy/=i;\n    }\n    if(tmpy > 1){\n      if(miller_rabin(tmpy))\n        pris.push_back(tmpy);\n      else{\n        LL aa=pollard_rho(tmpy);\n        LL bb=tmpy/aa;\n        pris.push_back(aa);\n        pris.push_back(bb);\n      }\n    }\n    sort(pris.begin(), pris.end());\n    pris.resize(unique(pris.begin(), pris.end())-pris.begin());\n  }\n  go();\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2700,At first must be met since and Now let and From now on let s consider only such that Now let s look at must be met Let Since if then must have to the power of in its factorization otherwise power of can be any non negative integer It leads us to the bitmask of restrictions with size equal to the number of different prime divisors of In the same way let s process Of course and if then must have to the power of in its factorization This is another restriction bitmask So for any pair there exists if and only if Since we look only at where then can t have power of equal to and at the same time For any other it is enough to have power of in equal to the power of in even if it s equal to So for each we need to know the number of such that is a submask of So we just need to calculate sum of submasks for each mask it can be done with or Finally how to factorize number up to Of course Pollard algorithm helps but there is another way which works sometimes Let s factorize with primes up to So after that if there is only three cases or is easy to check helps Otherwise just check with all and if you have found and then and you have found Otherwise you can assume that because this probable mistake doesn t break anything in this task Result complexity is where is the number of prime divisors of 
In late autumn evening robots gathered in the cheerful company of friends Each robot has a unique identifier an integer from to At some moment robots decided to play the game Snowball Below there are the rules of this game First all robots stand in a row Then the first robot says his identifier After that the second robot says the identifier of the first robot and then says his own identifier Then the third robot says the identifier of the first robot then says the identifier of the second robot and after that says his own This process continues from left to right until the th robot says his identifier Your task is to determine the th identifier to be pronounced ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nint main() {\n\n   // freopen(""input.txt"", ""r"", stdin);\n //   freopen(""output.txt"", ""w"", stdout);\n\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector <int> a(n);\n    for (int i =0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    int i = 0;\n    while(k - (i + 1) > 0) {\n        k -= i + 1;\n        i++;\n    }\n    cout << a[k - 1] << \'\\n\';\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1000,To solve this problem we need to brute how many identifiers will called robots in the order from left to right Let s solve this problem in one indexing Let the current robot will call identifiers If let s make and go to the next robot Else we need to print where is the array with robots identifiers and end our algorithm 
You are given an array Some element of this array is a iff it is strictly less than both of its neighbours that is and Also the element can be called iff it is strictly greater than its neighbours that is and Since and have only one neighbour each they are neither local minima nor local maxima An element is called a iff it is either local maximum or local minimum Your task is to calculate the number of local extrema in the given array ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 1021\nint n , a[ N ];\nvoid init(){\n  n = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    a[ i ] = getint();\n}\nvoid solve(){\n  int ans = 0;\n  for( int i = 1 ; i + 1 < n ; i ++ )\n    ans += ( a[ i - 1 ] < a[ i ] and a[ i ] > a[ i + 1 ] ) or\n           ( a[ i - 1 ] > a[ i ] and a[ i ] < a[ i + 1 ] );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",800,Iterate over indices from to and check if at least one of given local extremum conditions holds Overall complexity 
Suppose there is a h times w grid consisting of empty or full cells Let s make some definitions r i is the number of consecutive full cells connected to the left side in the i th row 1 le i le h In particular r i 0 if the leftmost cell of the i th row is empty c j is the number of consecutive full cells connected to the top end in the j th column 1 le j le w In particular c j 0 if the topmost cell of the j th column is empty In other words the i th row starts exactly with r i full cells Similarly the j th column starts exactly with c j full cells You have values of r and c Initially all cells are empty Find the number of ways to fill grid cells to satisfy values of r and c Since the answer can be very large find the answer modulo 1000000007 10 9 7 In other words find the remainder after division of the answer by 1000000007 10 9 7 ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1010, P = 1000000007;\n\nint vis[N][N];\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  int n, m;\n  scanf(""%d%d"", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int r;\n    scanf(""%d"", &r);\n    for (int j = 1; j <= r; ++j)\n      vis[i][j] = 1;\n    vis[i][r + 1] = -1;\n  }\n  for (int j = 1; j <= m; ++j) {\n    int c;\n    scanf(""%d"", &c);\n    for (int i = 1; i <= c; ++i)\n      if (vis[i][j] == -1) {\n        puts(""0"");\n        return 0;\n      } else\n        vis[i][j] = 1;\n    if (vis[c + 1][j] == 1) {\n      puts(""0"");\n      return 0;\n    }\n    vis[c + 1][j] = -1;\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (vis[i][j] == 0)\n        ans = ans * 2 % P;\n  printf(""%d\\n"", ans);\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1400,You can see some observations below and values reserves some cells to be full and some cells to be empty Because they have to satisfy number of consecutive full cells in their row column If some cell is reserved to be full by some values and reserved to be empty by some other values then it is impossible to fill grid Let s call this kind of cell as invalid cell If there is no invalid cell then the answer is where means the number of unreserved cells because setting state of unreserved cells doesn t affect validity of grid For easier understanding please look at the pictures below Black cells are reserved to be full by some or value White cells are reserved to be empty by some or value White cells are unreserved cells Red cells are invalid cells This is the explanation of the first example There is unreserved cell so the answer is This is one of the impossible cases That red cell is reserved to be full by but reserved to be empty by So this is impossible Time complexity is 
Local authorities have heard a lot about combinatorial abilities of Ostap Bender so they decided to ask his help in the question of urbanization There are people who plan to move to the cities The wealth of the of them is equal to Authorities plan to build two cities first for people and second for people Of course each of candidates can settle in only one of the cities Thus first some subset of candidates of size settle in the first city and then some subset of size is chosen among the remaining candidates and the move to the second city All other candidates receive an official refuse and go back home To make the statistic of local region look better in the eyes of their bosses local authorities decided to pick subsets of candidates in such a way that of wealth of people in each of the cities is as large as possible Arithmetic mean of wealth in one city is the sum of wealth among all its residents divided by the number of them or depending on the city The division should be done in real numbers without any rounding Please help authorities find the optimal way to pick residents for two cities ,"['#include <bits/stdc++.h>\n\n#define task ""DBG""\n\nusing namespace std;\n\nconst int N = 100001;\n\ntypedef long long ll;\n\nll a[N], ans;\nint n, n1, n2;\ndouble res;\n\nint main() {\n#ifndef ONLINE_JUDGE\n  assert(freopen(task"".INP"", ""r"", stdin));\n  assert(freopen(task"".OUT"", ""w"", stdout));\n#endif // ONLINE_JUDGE\n\n  cin >> n >> n1 >> n2;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n\n  if (n1 > n2) swap(n1, n2);\n  for (int j = 1; j <= n1; j++) ans += a[n--];\n\n  res = (double) ans / n1;\n  ans = 0;\n\n  for (int j = 1; j <= n2; j++) ans += a[n--];\n  res += (double) ans / n2;\n\n  printf(""%.8f"", res);\n\n  return 0;\n}\n\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1100,First of all note that n1 n2 chosen ones should be people with top n1 n2 coeficients Secondly if the person with intelegence C will be in the first city then he will contribute to our overall IQ with C n1 points So if n1 n2 then top n1 ratings should be in the small city and the top n2 from others in the big city 
In 2013 the writers of Berland State University should prepare problems for Olympiads We will assume that the Olympiads are numbered with consecutive integers from 1 to For each Olympiad we know how many members of the jury must be involved in its preparation as well as the time required to prepare the problems for her Namely the Olympiad number should be prepared by people for days the preparation for the Olympiad should be a continuous period of time and end exactly one day before the Olympiad On the day of the Olympiad the juries who have prepared it already do not work on it For example if the Olympiad is held on December 9th and the preparation takes 7 people and 6 days all seven members of the jury will work on the problems of the Olympiad from December 3rd to December 8th the jury members won t be working on the problems of this Olympiad on December 9th that is some of them can start preparing problems for some other Olympiad And if the Olympiad is held on November 3rd and requires 5 days of training the members of the jury will work from October 29th to November 2nd In order not to overload the jury the following rule was introduced one member of the jury can not work on the same day on the tasks for different Olympiads Write a program that determines what the minimum number of people must be part of the jury so that all Olympiads could be prepared in time ,"['#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[1000];\nint mon[13];\nconst int dt = 366;\nint main()\n{\n\tint n;\n\tfreopen( ""input.txt"", ""r"", stdin);\n\tfreopen( ""output.txt"", ""w"", stdout);\n\tmon[0] = 0;\n\tmon[1] = 31;\n\tmon[2] = 31 + 28;\n\tmon[3] = mon[2] + 31;\n\tmon[4] = mon[3] + 30;\n\tmon[5] = mon[4] + 31;\n\tmon[6] = mon[5] + 30;\n\tmon[7] = mon[6] + 31;\n\tmon[8] = mon[7] + 31;\n\tmon[9] = mon[8] + 30;\n\tmon[10] = mon[9] + 31;\n\tmon[11] = mon[10] + 30;\n\tmon[12] = mon[11] + 31;\n\tscanf( ""%d"", &n );\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tint m,d,r,t,l;\n\t\tscanf( ""%d%d%d%d"", &m, &d, &r, &t );\n\t\t\tl = mon[m - 1] + d - t;\n\t\t\tfor ( int j = 0; j < t; j++ )\n\t\t\t{\n\t\t\t\ta[l+dt+j]+=r;\n//\t\t\t\tprintf( ""%d\\n"", l+dt+j );\n\t\t\t}\n\t}\n\tint m = 0;\n\tfor ( int i = 0; i < 800; i++ )\n\tif ( a[i] > m ) m = a[i];\n\tprintf( ""%d\\n"", m );\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1500,One of the possible solutions is for each Olympiad find the period of the preparation This can be done by iterating the days back from the day of the Olympiad For each day of the preparation add to the number of distinct jury members that have to work on problems on day Then the answer is maximum calculated sum over all days Be careful with the year 2012 
A of length is an array containing each integer from to exactly once For example is a permutation For the permutation the square of permutation is the permutation that for each For example the square of is This problem is about the inverse operation given the permutation you task is to find such permutation that If there are several such find any of them ,"['/*\nWe live for the magic in the sound, distorted guitars are breaking ground\nThe drum pounding faster than my heart, the vocals are screaming extreme art\nThe passion for metal drives us forth, the best heavy metal comes from north\n\nThe powerful tunes, spectacular shows, the audience screams in ecstasy\n\nMetal, Metal\nBack with the vengeance\nMetal, Metal\nAll that I need is heavy metal\nMetal\nScreaming together\nMetal, Metal\nMetal is all that I need\n\nWhile hell bends for leather we stand strong, a rocker can party all night long\nthe school couldn\'t teach us rock\' n roll, the school couldn\'t help us reach our goal\nWe live for the magic in the sound, distorted guitars are breaking ground\n\nThe powerful tunes, spectacular shows, the audience screams in ecstasy\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 1100000;\n\nusing namespace std;\n\nvector<vector<int> >cycles[N];\nint used[N];\nint ans[N];\nint p[N];\nvector<int> cycle;\nint n;\n\nvoid dfs(int v)\n{\n\tcycle.push_back(v);\n\tused[v] = 1;\n\tint to = p[v];\n\tif (used[to])\n\t\treturn;\n\tdfs(to);\n}\n\nvoid update(vector<int> v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tans[v[i]] = v[(i + 1) % v.size()];\n\t}\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(""%d"", &p[i]);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i])\n\t\t\tcontinue;\n\t\tcycle.clear();\n\t\tdfs(i);\n\t\tcycles[cycle.size()].push_back(cycle);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i % 2 == 0 && cycles[i].size() % 2 == 1)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tused[i] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i % 2 == 1)\n\t\t{\n\t\t\tfor (int j = 0; j < cycles[i].size(); j++)\n\t\t\t{\n\t\t\t\tvector<int> V;\n\t\t\t\tfor (int q = 0; q < i / 2; q++)\n\t\t\t\t{\n\t\t\t\t\tV.push_back(cycles[i][j][q]);\n\t\t\t\t\tV.push_back(cycles[i][j][(q+1) + i / 2]);\n\t\t\t\t}\n\t\t\t\tV.push_back(cycles[i][j][i / 2 ]);\n\t\t\t\tupdate(V);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < cycles[i].size(); j += 2)\n\t\t\t{\n\t\t\t\tvector<int> V;\n\t\t\t\tfor (int q = 0; q < cycles[i][j].size(); q++)\n\t\t\t\t{\n\t\t\t\t\tV.push_back(cycles[i][j][q]);\n\t\t\t\t\tV.push_back(cycles[i][j + 1][q]);\n\t\t\t\t}\n\t\t\t\tupdate(V);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tprintf("" "");\n\t\tprintf(""%d"", ans[i]);\n//\t\tcout << ans[i];\n\t}\n\tcout << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 1]",2200,Consider some permutation Let s build by it the oriented graph with edges Easy to see and easy to prove that this graph is the set of disjoint cycles Now let s see what would be with that graph when the permutation will be multiplied by itself all the cycles of odd length would remain so only the order of vertices will change they will be alternated but the cycles of even length will be split to the two cycles of the same length So to get the square root from the permutation we should simply alternate in reverse order all cycles of the odd length and group all the cycles of the same even length to pairs and merge cycles in each pair If it s impossible to group all even cycles to pairs then the answer doesn t exist Complexity 
Polycarp was recently given a set of n number n even dominoes Each domino contains two integers from 1 to n Can he divide all the dominoes into two sets so that all the numbers on the dominoes of each set are different Each domino must go into exactly one of the two sets For example if he has 4 dominoes 1 4 1 3 3 2 and 4 2 then Polycarp will be able to divide them into two sets in the required way The first set can include the first and third dominoes 1 4 and 3 2 and the second set the second and fourth ones 1 3 and 4 2 ,"['/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,k,c,a[N],col[N];\nii p[N];\nstring s;\nvector<ll> ke[N];\nbool ok=1;\nvoid dfs (ll u){\n    rv(v,ke[u]) if (!col[v]) col[v]=3-col[u],dfs(v);\n    else if (col[v]==col[u]) ok=0;\n}\nvoid solo()\n{\n    cin>>n;\n    rep(i,1,n) col[i]=a[i]=0,ke[i].clear();\n    ok=1;\n    rep(i,1,n) cin>>p[i].F>>p[i].S,a[p[i].F]++,a[p[i].S]++;\n    rep(i,1,n) if (a[i]!=2 || p[i].F==p[i].S){\n        cout<<""NO"";\n        return;\n    }\n    rep(i,1,n){\n        ke[p[i].F].pb(p[i].S);\n        ke[p[i].S].pb(p[i].F);\n    }\n    rep(i,1,n) if (!col[i]) col[i]=1,dfs(i);\n    if (ok)\n    cout<<""YES"";\n    else cout<<""NO"";\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1600,Polycarp has dominoes on each domino there are numbers it turns out there will be numbers in total We need to divide numbers each number from to into two sets so that all numbers in each set are different each set will consist of numbers It turns out that all numbers from to must occur exactly times no more and no less Let s imagine it all as a bipartite graph where there are vertices from to and dominoes are edges Since each number occurs exactly times then we have a lot of cycles In which the edges of each number must be included in different sets in other words the cycles must be of even length This can be checked in by a simple enumeration 
Fox Ciel starts to learn programming The first task is drawing a fox However that turns out to be too hard for a beginner so she decides to draw a snake instead A snake is a pattern on a by table Denote th cell of th row as The tail of the snake is located at then it s body extends to then goes down rows to then goes left to and so on Your task is to draw this snake for Fox Ciel the empty cells should be represented as dot characters and the snake cells should be filled with number signs Consider sample tests in order to understand the snake pattern ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tint m;\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tputchar(\'#\');\n\t\t\t} else {\n\t\t\t\tint k = i / 2;\n\t\t\t\tif (k % 2 == 0 && j == m - 1) {\n\t\t\t\t\tputchar(\'#\');\n\t\t\t\t} else if (k % 2 == 1 && j == 0) {\n\t\t\t\t\tputchar(\'#\');\n\t\t\t\t} else {\n\t\t\t\t\tputchar(\'.\');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,There are 2 different ways to solve this kind of task First one is to simulate the movement of the snake head and you draw s on the board The code will look like Another way is to do some observation about the result you can find this pattern 
There is an n times m board divided into cells There are also some dominoes on this board Each domino covers two adjacent cells that is two cells that share a side and no two dominoes overlap Piet thinks that this board is too boring and it needs to be painted He will paint the cells of the dominoes black and white He calls the painting if all of the following conditions hold for each domino one of its cells is painted white and the other is painted black for each row the number of black cells in this row equals the number of white cells in this row for each column the number of black cells in this column equals the number of white cells in this column Note that the cells that are not covered by dominoes are not painted at all they are counted as neither black nor white Help Piet produce a beautiful painting or tell that it is impossible ,"['/**\n *    author:  tourist\n *    created: 30.08.2023 10:41:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<string> s(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n    }\n    bool fail = false;\n    for (int i = 0; i < n - 1; i++) {\n      vector<int> pos;\n      for (int j = 0; j < m; j++) {\n        if (s[i][j] == \'U\') {\n          pos.push_back(j);\n        }\n      }\n      if (pos.size() % 2 == 1) {\n        fail = true;\n        break;\n      }\n      for (int id = 0; id < (int) pos.size(); id++) {\n        int j = pos[id];\n        if (id % 2 == 0) {\n          s[i][j] = \'W\';\n          s[i + 1][j] = \'B\';\n        } else {\n          s[i][j] = \'B\';\n          s[i + 1][j] = \'W\';\n        }\n      }\n    }\n    for (int j = 0; j < m - 1; j++) {\n      vector<int> pos;\n      for (int i = 0; i < n; i++) {\n        if (s[i][j] == \'L\') {\n          pos.push_back(i);\n        }\n      }\n      if (pos.size() % 2 == 1) {\n        fail = true;\n        break;\n      }\n      for (int id = 0; id < (int) pos.size(); id++) {\n        int i = pos[id];\n        if (id % 2 == 0) {\n          s[i][j] = \'W\';\n          s[i][j + 1] = \'B\';\n        } else {\n          s[i][j] = \'B\';\n          s[i][j + 1] = \'W\';\n        }\n      }\n    }\n    if (fail) {\n      cout << -1 << \'\\n\';\n    } else {\n      for (int i = 0; i < n; i++) {\n        cout << s[i] << \'\\n\';\n      }\n    }\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1400,Let s consider the requirement on the rows Clearly all horizontal dominoes since each of them has black and white cell do not influence the black white balance for the rows Thus we are only interested in vertical dominoes Consider the first row and the vertical dominoes that intersect this row Their number has to be even otherwise the first row has an odd number of cells covered by dominoes and the solution is clearly impossible But if there is an even number of such dominoes we have to paint half of them black white and half of them white black What s more it doesn t actually matter the exact order we paint them in because vertical dominoes do not affect the columns balance and we will not influence the balance of the second row anyway So we can freely paint them however we like The same logic applies for rows Now we turn to horizontal dominoes In the first row there once again has to be an even number of dominoes which intersect this column And we can paint half them black white and half of them white black and it doesn t matter which exact way we choose Do the same for columns 
You are given three integers n k and f Consider all binary strings i e all strings consisting of characters 0 and or 1 of length from 1 to n For every such string s you need to choose an integer c s from 0 to k A multiset of binary strings of length n is considered beautiful if for every binary string s with length from 1 to n the number of strings in the multiset such that s is their prefix is not exceeding c s For example let n 2 c 0 3 c 00 1 c 01 2 c 1 1 c 10 2 and c 11 3 The multiset of strings 11 01 00 01 is beautiful since for the string 0 there are 3 strings in the multiset such that 0 is their prefix and 3 le c 0 for the string 00 there is one string in the multiset such that 00 is its prefix and 1 le c 00 for the string 01 there are 2 strings in the multiset such that 01 is their prefix and 2 le c 01 for the string 1 there is one string in the multiset such that 1 is its prefix and 1 le c 1 for the string 10 there are 0 strings in the multiset such that 10 is their prefix and 0 le c 10 for the string 11 there is one string in the multiset such that 11 is its prefix and 1 le c 11 Now for the problem itself You have to calculate the number of ways to choose the integer c s for every binary string s of length from 1 to n in such a way that the possible size of a beautiful multiset is f ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int LOG = 20; // CHECK!!!!\nPowers W;\nvector<int> binRev;\nvoid initFFT() {\n\tbinRev = vector<int>((1 << LOG) + 3, 0);\n\tMint w = 2;\n\twhile(true) {\n\t\tMint x = w;\n\t\tfor (int i = 1; i < LOG; i++)\n\t\t\tx *= x;\n\t\tif (x == -1) break;\n\t\tw += 1;\n\t}\n\tW = Powers(1 << LOG, w);\n\tfor (int mask = 1; mask < (1 << LOG); mask++) {\n\t\tbinRev[mask] = (binRev[mask >> 1] >> 1) ^ ((mask & 1) << (LOG - 1));\n\t}\n}\n\ntemplate<unsigned mod = MOD> struct Poly {\n\tusing Mint = mint<mod>;\n\tvector<Mint> a;\n\n\tPoly() : a() {}\n\tPoly(vector<Mint> _a) {\n\t\ta = _a;\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t}\n\n\tvoid print(int n = -1) {\n\t\tif (n == -1) n = (int)a.size();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(""%u "", at(i).x);\n\t\tprintf(""\\n"");\n\t}\n\tvoid eprint() {\n\t\teprintf(""["");\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\teprintf(""%u "", a[i].x);\n\t\teprintf(""]\\n"");\n\t}\n\n\tstatic void fft(vector<Mint> &A) {\n\t\tint L = (int)A.size();\n\t\tassert((L & (L - 1)) == 0);\n\t\tint k = 0;\n\t\twhile((1 << k) < L) k++;\n\t\tfor (int i = 0; i < L; i++) {\n\t\t\tint x = binRev[i] >> (LOG - k);\n\t\t\tif (i < x) swap(A[i], A[x]);\n\t\t}\n\t\tfor (int lvl = 0; lvl < k; lvl++) {\n\t\t\tint len = 1 << lvl;\n\t\t\tfor (int st = 0; st < L; st += (len << 1))\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tMint x = A[st + i], y = A[st + len + i] * W.pow(i << (LOG - 1 - lvl));\n\t\t\t\t\tA[st + i] = x + y;\n\t\t\t\t\tA[st + len + i] = x - y;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tMint& operator [] (const int i) {\n\t\tassert(0 <= i && i <= deg()); \n\t\treturn a[i];\n\t}\n\tMint at(const int i) const {\n\t\tif (i < 0 || i > deg()) return 0;\n\t\treturn a[i];\n\t}\n\tint deg() const { // deg of polynomial 0 is -1\n\t\treturn (int)a.size() - 1;\n\t}\n\tMint eval(const Mint &x) const {\n\t\tMint res = 0;\n\t\tfor (int i = deg(); i >= 0; i--)\n\t\t\tres = res * x + a[i];\n\t\treturn res;\n\t}\n\tPoly substr(const int &l, const int &r) const {\n\t\tvector<Mint> f(r - l);\n\t\tfor (int i = l; i < r; i++)\n\t\t\tf[i - l] = at(i);\n\t\treturn f;\n\t}\n\n\tPoly& operator += (const Poly &A) {\n\t\tif (deg() < A.deg()) a.resize(A.a.size());\n\t\tfor (int i = 0; i <= A.deg(); i++)\n\t\t\ta[i] += A.a[i];\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t\treturn *this;\n\t}\n\tPoly& operator -= (const Poly &A) {\n\t\tif (deg() < A.deg()) a.resize(A.a.size());\n\t\tfor (int i = 0; i <= A.deg(); i++)\n\t\t\ta[i] -= A.a[i];\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t\treturn *this;\n\t}\n\tPoly& operator *= (const Mint &k) {\n\t\tif (k == 0) a.clear();\n\t\tfor (Mint &x : a) x *= k;\n\t\treturn *this;\n\t}\n\tPoly& operator /= (const Mint &k) {\n\t\tMint ki = k.inv();\n\t\tfor (Mint &x : a) x *= ki;\n\t\treturn *this;\n\t}\n\tPoly operator + (const Poly &A) const {\n\t\treturn Poly(*this) += A;\n\t}\n\tPoly operator - (const Poly &A) const {\n\t\treturn Poly(*this) -= A;\n\t}\n\tPoly operator * (const Mint &k) const {\n\t\treturn Poly(*this) *= k;\n\t}\n\tPoly operator / (const Mint &k) const {\n\t\treturn Poly(*this) /= k;\n\t}\n\t\n\tPoly& operator *= (const Poly &A) {\n\t\tif (a.empty() || A.a.empty()) {\n\t\t\ta.clear();\n\t\t\treturn *this;\n\t\t}\n\t\tint nd = deg() + A.deg();\n\t\t\n\t\tif (deg() < LOG || A.deg() < LOG) {\n\t\t\tvector<Mint> res(nd + 1, 0);\n\t\t\tfor (int i = 0; i <= deg(); i++)\n\t\t\t\tfor (int j = 0; j <= A.deg(); j++)\n\t\t\t\t\tres[i + j] += a[i] * A.a[j];\n\t\t\treturn *this = Poly(res);\n\t\t}\n\t\t\n\t\tint k = 0;\n\t\twhile((1 << k) <= nd) k++;\n\t\tint L = 1 << k;\n\t\tvector<Mint> f = a, g = A.a;\n\t\tf.resize(L, 0);\n\t\tg.resize(L, 0);\n\t\tfft(f);\n\t\tfft(g);\n\t\tfor (int i = 0; i < L; i++)\n\t\t\tf[i] *= g[i];\n\t\tfft(f);\n\t\treverse(f.begin() + 1, f.end());\n\t\treturn *this = (Poly(f) / L);\n\t}\n\tPoly operator * (const Poly &A) const {\n\t\treturn Poly(*this) *= A;\n\t}\n\n\tPoly inv(int n) const {\n\t\tassert(deg() >= 0 && at(0) != 0);\n\t\tif (n <= 0) return Poly();\n\t\tvector<Mint> res(n);\n\t\tres[0] = a[0].inv();\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tfor (int i = 0; i < 2 * L && i <= deg(); i++)\n\t\t\t\tf[i] = a[i];\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tg[i] = res[i];\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tf[i] = 0;\n\t\t\tfor (int i = L; i < 2 * L; i++)\n\t\t\t\tf[i] = Mint() - f[i];\n\t\t\tfft(f);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tLi *= Li;\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic vector<Mint> div_stupid(vector<Mint> A, vector<Mint> B) {\n\t\tint n = (int)A.size(), m = (int)B.size();\n\t\tMint Bi = B.back().inv();\n\t\tfor (auto &x : B) x *= Bi;\n\t\tvector<Mint> C(n - m + 1);\n\t\tfor (int i = n; i >= m; i--) {\n\t\t\tC[i - m] = A[i - 1] * Bi;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tA[i - m + j] -= B[j] * A[i - 1];\n\t\t}\n\t\treturn C;\n\t}\n\tPoly& operator /= (const Poly &A) {\n\t\tint d1 = deg(), d2 = A.deg();\n\t\tassert(d2 >= 0);\n\t\tif (d1 < d2) return *this = Poly();\n\t\tif (d2 < 4 * LOG || d1 - d2 < 4 * LOG)\n\t\t\treturn *this = div_stupid(a, A.a);\n\t\tvector<Mint> f = a, g = A.a;\n\t\treverse(all(f));\n\t\treverse(all(g));\n\t\tPoly H = Poly(vector<Mint>(f.begin(), f.begin() + d1 - d2 + 1)) * Poly(g).inv(d1 - d2 + 1);\n\t\tvector<Mint> t = vector<Mint>(H.a.begin(), H.a.begin() + d1 - d2 + 1);\n\t\treverse(all(t));\n\t\treturn *this = t;\n\t}\n\tPoly operator / (const Poly &A) const {\n\t\treturn Poly(*this) /= A;\n\t}\n\tPoly& operator %= (const Poly &A) {\n\t\tassert(A.deg() >= 0);\n\t\tif (deg() < A.deg()) return *this;\n\t\treturn *this -= A * (*this / A);\n\t}\n\tPoly operator % (const Poly &A) const {\n\t\treturn Poly(*this) %= A;\n\t}\n\n\tPoly derivate() const {\n\t\tint n = deg();\n\t\tif (n <= 0) return Poly();\n\t\tvector<Mint> f(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tf[i] = a[i + 1] * (i + 1);\n\t\treturn f;\n\t}\n\tPoly integrate() const {\n\t\tint n = deg();\n\t\tif (n < 0) return Poly();\n\t\tn += 2;\n\t\tvector<Mint> f(n);\n\t\tInverses I = Inverses(n);\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = a[i - 1] * I.inv(i);\n\t\treturn f;\n\t}\n\tPoly log(int n) const {\n\t\tif (n <= 1) return Poly();\n\t\tassert(deg() >= 0 && at(0) == 1);\n\t\treturn (derivate() * inv(n)).substr(0, n - 1).integrate();\n\t}\n\tPoly exp(int n) const {\n\t\tif (n <= 0) return Poly();\n\t\tif (deg() < 0) return Poly({1});\n\t\tassert(at(0) == 0);\n\t\tvector<Mint> res(n);\n\t\tres[0] = 1;\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tPoly LG = Poly(vector<Mint>(res.begin(), res.begin() + L)).log(2 * L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tassert(at(i) == LG.at(i));\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tf[i] = res[i];\n\t\t\t\tg[i] = at(L + i) - LG.at(L + i);\n\t\t\t}\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i - L] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\tPoly sqr(int n) const {\n\t\treturn (*this * *this).substr(0, n);\n\t}\n\tPoly pow_(Mint k, int n) const { // k can be non-negative rational (k = 1/2 is sqrt), but assert(a[0] == 1);\n\t\tif (deg() < 0 || n <= 0) return Poly();\n\t\treturn (log(n) * k).exp(n);\n\t}\n\tPoly pow(ll k, int n) const { // k is non-negative integer\n\t\tif (n <= 0) return Poly();\n\t\tif (k == 0) return Poly({1});\n\t\tif (k == 1) return substr(0, n);\n\t\tif (k == 2) return sqr(n);\n\t\tif (k < LOG) {\n\t\t\tPoly cur = substr(0, n);\n\t\t\tPoly res = Poly({1});\n\t\t\twhile(k) {\n\t\t\t\tif (k & 1) res = (res * cur).substr(0, n);\n\t\t\t\tcur = cur.sqr(n);\n\t\t\t\tk >>= 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tint z = 0;\n\t\twhile(z * k < n && at(z) == 0) z++;\n\t\tif (z * k >= n) return Poly();\n\t\tPoly A = substr(z, z + n - z * k);\n\t\tMint cf = A[0].pow(k);\n\t\tA /= A[0];\n\t\tA = A.pow_(k, n - z * k) * cf;\n\t\treturn A.substr(-z * k, n - z * k);\n\t}\n\tPoly sqrt_(int n) const {\n\t\tif (deg() < 0 || n <= 0) return Poly();\n\t\tassert(at(0) == 1);\n//\t\treturn pow_(Mint(2).inv(), n);\n\t\tvector<Mint> res(n);\n\t\tres[0] = 1;\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tf[i] = res[i];\n\t\t\tfft(f);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= f[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= Li;\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] = at(i) - f[i];\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tassert(f[i] == 0);\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tf[i] = f[i + L];\n\t\t\t\tf[i + L] = 0;\n\t\t\t}\n\t\t\tPoly Q = Poly(vector<Mint>(res.begin(), res.begin() + L)).inv(L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tg[i] = Q.at(i);\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tLi /= 2;\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i - L] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\tbool sqrt(int n, Poly &R) const {\n\t\tif (deg() < 0) {\n\t\t\tR = Poly();\n\t\t\treturn true;\n\t\t}\n\t\tif (at(0) == 1) {\n\t\t\tR = sqrt_(n);\n\t\t\treturn true;\n\t\t}\n\t\tint z = 0;\n\t\twhile(at(z) == 0) z++;\n\t\tif (z & 1) return false;\n\t\tPoly A = substr(z, n + z / 2);\n\t\tMint cf;\n\t\tif (!A[0].sqrt(cf)) return false;\n\t\tA /= A[0];\n\t\tA = A.sqrt_(n - z / 2) * cf;\n\t\tR = A.substr(-z / 2, n - z / 2);\n\t\treturn true;\n\t}\n\n\tstatic Poly multiply_all(vector<Poly> polys) {\n\t\tif (polys.empty()) return Poly({1});\n\t\tset<pii> setik;\n\t\tfor (int i = 0; i < (int)polys.size(); i++)\n\t\t\tsetik.insert(mp(polys[i].deg(), i));\n\t\twhile((int)setik.size() > 1) {\n\t\t\tint p = setik.begin()->second;\n\t\t\tsetik.erase(setik.begin());\n\t\t\tint q = setik.begin()->second;\n\t\t\tsetik.erase(setik.begin());\n\t\t\tpolys[p] *= polys[q];\n\t\t\tsetik.insert(mp(polys[p].deg(), p));\n\t\t}\n\t\treturn polys[setik.begin()->second];\n\t}\n\tstatic Poly given_roots(const vector<Mint> &xs) {\n\t\tint n = (int)xs.size();\n\t\tvector<Poly> polys(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpolys[i] = Poly({Mint() - xs[i], 1});\n\t\treturn multiply_all(polys);\n\t}\n\n\tvector<Mint> multipoint(const vector<Mint> &xs) const {\n\t\tint n = (int)xs.size();\n\t\tif (n == 0) return {};\n\t\tif (n == 1) return {eval(xs[0])};\n\t\tint L = n;\n\t\twhile(L & (L - 1)) L++;\n\t\tvector<Poly> tree(2 * L);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttree[L + i] = Poly({Mint() - xs[i], 1});\n\t\tfor (int i = n; i < L; i++)\n\t\t\ttree[L + i] = Poly({1});\n\t\tfor (int i = L - 1; i > 0; i--)\n\t\t\ttree[i] = tree[2 * i] * tree[2 * i + 1];\n\t\ttree[1] = *this % tree[1];\n\t\tfor (int i = 2; i < L + n; i++)\n\t\t\ttree[i] = tree[i / 2] % tree[i];\n\t\tvector<Mint> res(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = tree[L + i].at(0);\n\t\treturn res;\n\t}\n\tstatic pair<Poly, Poly> interpolate_(const vector<pair<Mint, Mint>> &vals, int l, int r) {\n\t\tif (r - l == 1) return mp(Poly({vals[l].second}), Poly({Mint() - vals[l].first, 1}));\n\t\tint m = (l + r) / 2;\n\t\tauto L = interpolate_(vals, l, m), R = interpolate_(vals, m, r);\n\t\treturn mp(L.first * R.second + R.first * L.second, L.second * R.second);\n\n\t}\n\tstatic Poly interpolate(vector<pair<Mint, Mint>> vals) {\n\t\tif (vals.empty()) return Poly();\n\t\tint n = (int)vals.size();\n\t\tvector<Mint> xs(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\txs[i] = vals[i].first;\n\t\tPoly P = given_roots(xs);\n\t\tP = P.derivate();\n\t\tvector<Mint> cf = P.multipoint(xs);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvals[i].second /= cf[i];\n\t\treturn interpolate_(vals, 0, (int)vals.size()).first;\n\t}\n\tPoly x_k_mod_this(ll k) const { // x^k % P\n\t\tPoly res = Poly({1});\n\t\tint t = 0;\n\t\twhile((1LL << t) <= k) t++;\n\t\tfor (int i = t - 1; i >= 0; i--) {\n\t\t\tres *= res;\n\t\t\tif ((k >> i) & 1) res = res.substr(-1, res.deg() + 1);\n\t\t\tres %= *this;\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<Mint> chirp_z(Mint z, int n) const { // eval at [z^0, z^1, ..., z^(n-1)]\n\t\tint m = deg();\n\t\tif (m < 0 || n == 0) return vector<Mint>(n);\n\t\tif (z == 0) {\n\t\t\tvector<Mint> res(n, at(0));\n\t\t\tres[0] = eval(1);\n\t\t\treturn res;\n\t\t}\n\t\tMint zi = z.inv();\n\t\tvector<Mint> Z(n + m, 1), Zi(max(m + 1, n), 1);\n\t\tMint w = 1, wi = 1;\n\t\tfor (int i = 1; i < (int)Z.size(); i++) {\n\t\t\tZ[i] = Z[i - 1] * w;\n\t\t\tw *= z;\n\t\t}\n\t\tfor (int i = 1; i < (int)Zi.size(); i++) {\n\t\t\tZi[i] = Zi[i - 1] * wi;\n\t\t\twi *= zi;\n\t\t}\n\t\tvector<Mint> f(m + 1);\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tf[i] = at(i) * Zi[i];\n\t\treverse(all(Z));\n\t\tPoly C = Poly(f) * Z;\n\t\tvector<Mint> res(n);\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tres[k] = C.at(n + m - 1 - k) * Zi[k];\n\t\treturn res;\n\t}\n\n\tPoly shift_c(Mint c) const { // P(x + c)\n\t\tint n = deg();\n\t\tif (n < 0) return Poly();\n\t\tFactorials F(n);\n\t\tPowers P(n, c);\n\t\tvector<Mint> f(n + 1), g(n + 1);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tf[i] = at(i) * F.f[i];\n\t\t\tg[i] = P.pow(i) * F.fi[i];\n\t\t}\n\t\treverse(all(g));\n\t\tPoly C = Poly(f) * g;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tf[i] = C.at(n + i) * F.fi[i];\n\t\treturn f;\n\t}\n};\n\ntemplate<uint mod = MOD>\nvector<mint<mod>> BerlekampMassey(vector<mint<mod>> x) {\n    using Mint = mint<mod>;\n    vector<Mint> ls, cur;\n    int lf;\n    Mint ld;\n    for (int i = 0; i < (int)x.size(); i++) {\n        Mint t = 0;\n        for (int j = 0; j < (int)cur.size(); j++)\n            t += cur[j] * x[i - j - 1];\n        if (t == x[i]) continue;\n        if (cur.empty()) {\n            cur.resize(i + 1);\n            lf = i;\n            ld = t - x[i];\n            continue;\n        }\n        Mint k = (t - x[i]) / ld;\n        vector<Mint> c(i - lf - 1);\n        c.push_back(k);\n        for (auto t : ls) {\n            c.push_back(Mint() - t * k);\n        }\n        if (c.size() < cur.size()) c.resize(cur.size());\n        for (int j = 0; j < (int)cur.size(); j++)\n            c[j] += cur[j];\n        if (i - lf + (int)ls.size() >= (int)cur.size()) {\n            ls = cur;\n            lf = i;\n            ld = t - x[i];\n        }\n        cur = c;\n    }\n    return cur;\n}\n\n// CALL initFFT() and CHECK LOG\n\nconst int N = 200200;\nint n, k, f;\nMint a[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\t\n\tinitFFT();\n\n\tscanf(""%d%d%d"", &n, &k, &f);\n\tfor (int i = 0; i <= k; i++)\n\t\ta[i] = 1;\n\tn--;\n\twhile(n--) {\n\t\tvector<Mint> b(k + 1, 0);\n\t\tfor (int i = 0; i <= k; i++)\n\t\t\tb[i] = a[i];\n\t\tPoly<> C = Poly<>(b) * Poly<>(b);\n\t\tMint sum = 0;\n\t\tfor (int i = C.deg(); i >= 0; i--) {\n\t\t\tsum += C.at(i);\n\t\t\tif (i <= k) {\n\t\t\t\ta[i] = sum;\n\t\t\t\ta[i] += C.at(i) * (k - i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<Mint> b(k + 1, 0);\n\tfor (int i = 0; i <= k; i++)\n\t\tb[i] = a[i];\n\tPoly<> C = Poly<>(b) * Poly<>(b);\n\tprintf(""%u\\n"", C.at(f).x);\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 1, 0, 0, 0, 1]",2500,First of all let s visualize the problem in a different way We have to set some constraints on the number of strings which have some kind of prefix Let s think about a data structure that would allow us to understand it better One of the most common data structures to store strings which works with their prefixes and maintains the number of strings with some prefix is a trie so we can reformulate this problem using tries Now the problem is the following one we have a binary trie of depth the leaves of this trie may store strings and for each vertex except for the root we can set a constraint on the number of strings stored in the subtree what is the number of ways to choose these constraints so that the maximum number of strings possibly with copies the trie can store is exactly To handle it we can use dynamic programming of the form the number of ways to choose the constraints for the vertex and its subtree so that the maximum number of strings which can be stored in the subtree is exactly When calculating we can iterate on the constraint for the vertex let it be and the maximum number of strings in the subtrees of and let these be and and make updates of the form add to the value of This dynamic programming will work in or depending on the implementation which is too slow However we can use the following optimizations to improve the complexity of the solution all vertices on the same depth can be treated as equivalent so we can actually calculate this dynamic programming not for vertices but just for when handling transitions from some node s children to that node let s split these transitions into two steps The first step is iterating on the number of strings which fit into the subtrees of the children the second step is iterating on the constraint for the subtree of the node The first step is actually a convolution if we don t consider the constraint for the node itself then the transitions would be something like add to the value of so it can be improved to with FFT The second step can be improved to as well if we iterate on the minimum between the constraint for the node and the total number of strings which can be stored in the children and maintain the sum on suffix for the values of dynamic programming Overall these optimizations lead to a solution with complexity 
There are n workers and m tasks The workers are numbered from 1 to n Each task i has a value a i the index of worker who is proficient in this task Every task should have a worker assigned to it If a worker is proficient in the task they complete it in 1 hour Otherwise it takes them 2 hours The workers work in parallel independently of each other Each worker can only work on one task at once Assign the workers to all tasks in such a way that the tasks are completed as early as possible The work starts at time 0 What s the minimum time all tasks can be completed by ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:37:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(m);\n    for (int i = 0; i < m; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    vector<int> cnt(n);\n    for (int i = 0; i < m; i++) {\n      cnt[a[i]] += 1;\n    }\n    int low = 0, high = 2 * (m + n + 10);\n    while (low < high) {\n      int mid = (low + high) >> 1;\n      long long extra = 0;\n      long long need = 0;\n      for (int i = 0; i < n; i++) {\n        if (cnt[i] <= mid) {\n          extra += (mid - cnt[i]) / 2;\n        } else {\n          need += cnt[i] - mid;\n        }\n      }\n      if (extra >= need) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    cout << low << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 1, 0, 0]",1400,The statement should instantly scream binary search at you Clearly if you can assign the workers in such a way that the tasks are completed by time you can complete them all by or more as well How to check if the tasks can be completed by some time What that means is that all workers have hours to work on some tasks If all tasks took hours to complete then each of them could complete of them Thus together they would be able to complete tasks How to incorporate the hour tasks into that Well we can redistribute the tasks in such a way that each worker first completes the tasks they are proficient in then some other tasks if they have more time So the general idea is the following Let each worker complete hour tasks where is the number of tasks the th worker is proficient in Then remember how many hour tasks they can complete which is Finally remember how many tasks that they are proficient in they didn t have time to complete which is If the sum of the number of incomplete tasks doesn t exceed the sum of the number of tasks they have time to complete then everything can be completed in time Worst case it can take up to hours to complete everything if you assign all tasks to a single worker and they are not proficient in any of them Overall complexity per testcase 
Given three numbers n a b You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to a and the number of components in its complement is b The matrix must be symmetric and all digits on the main diagonal must be zeroes In an undirected graph loops edges from a vertex to itself are not allowed It can be at most one edge between a pair of vertices The adjacency matrix of an undirected graph is a square matrix of size n consisting only of 0 and 1 where n is the number of vertices of the graph and the i th row and the i th column correspond to the i th vertex of the graph The cell i j of the adjacency matrix contains 1 if and only if the i th and j th vertices in the graph are connected by an edge A connected component is a set of vertices X such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices but adding any other vertex to X violates this rule The complement or inverse of a graph G is a graph H on the same vertices such that two distinct vertices of H are adjacent if and only if they are not adjacent in G ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 1005;\n\nint n, a, b;\nchar B[Maxn][Maxn];\n\nint main()\n{\n\tscanf(""%d %d %d"", &n, &a, &b);\n\tif (a != 1 && b != 1) { printf(""NO\\n""); return 0; }\n\tif ((n == 2 || n == 3) && a == 1 && b == 1) { printf(""NO\\n""); return 0; }\n\tprintf(""YES\\n"");\n\tfor (int i = 0; i < n; i++)\n\t\tB[i][i] = \'0\';\n\tchar cola = \'1\', colb = \'0\';\n\tif (b != 1) { swap(cola, colb); swap(a, b); }\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++) if (i != j)\n\t\t\tB[i][j] = B[j][i] = colb;\n\tfor (int i = a - 1; i + 1 < n; i++)\n\t\tB[i][i + 1] = B[i + 1][i] = cola;\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i][n] = \'\\0\';\n\t\tprintf(""%s\\n"", B[i]);\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 1]",1700,Let s prove that if then Let be the original graph and the complement of the graph Let s look at each pair of vertices If and belong to different components of the graph then there is an edge between them in the graph Otherwise and belong to the same component of the graph but since has more than one component there is vertex in other component of and there are edges and in That s why there is a connected path for any pair of vertices and the graph is connected Similarly the case is proved So if then the answer is NO Otherwise Consider the case where if we can swap and and output complement of the constructed graph To have components in the graph it is enough to connect the vertex with the vertex the vertex with the vertex the vertex with the vertex A particular cases are the tests and There is no suitable graph for them 
Consider the decimal presentation of an integer Let s call a number if digit appears in decimal presentation of the number on even positions and nowhere else For example the numbers are but are not On the other hand the number is is is and is Find the number of numbers in the segment that are multiple of Because the answer can be very huge you should only find its value modulo so you should find the remainder after dividing by ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nconst int p = 1000000007;\n\nint mul32(int x, int y) {\n  return (int64_t(x) * y) % p;\n}\n\nint getRes(int d, int m, std::string& x, std::vector<int>& rem, std::vector<std::vector<int>>& dyn) {\n  int n = x.length();\n  int res = 0;\n  int sum = 0;\n  bool bad = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < x[i] - \'0\'; j++) {\n      if ((i % 2 != 0) ^ (j == d)) {\n        continue;\n      }\n      res = (res + dyn[n - i - 1][(sum + j * rem[n - i - 1]) % m]) % p;\n    }\n    sum = (sum + (x[i] - \'0\') * rem[n - i - 1]) % m;\n    if ((i % 2 != 0) ^ (x[i] - \'0\' == d)) {\n      bad = true;\n      break;\n    }\n  }\n  if (!bad && sum == 0) {\n    res = (res + 1) % p;\n  }\n  return res;\n}\n\nvoid run(std::istream& in, std::ostream& out) {\n  int m, d;\n  in >> m >> d;\n  std::string a, b;\n  in >> a >> b;\n  int n = a.length();\n  std::vector<int> rem(n);\n  int c = 1;\n  for (int i = 0; i < n; i++) {\n    rem[i] = c;\n    c = (c * 10) % m;\n  }\n  std::vector<std::vector<int>> dyn(n, std::vector<int>(m, 0));\n  dyn[0][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int dd = 0; dd < 10; dd++) {\n      if (((n - i) % 2 != 0) ^ (dd == d)) continue;\n      int diff = rem[i - 1] * dd;\n      for (int j = 0; j < m; j++) {\n        dyn[i][j] = (dyn[i][j] + dyn[i - 1][(j + diff) % m]) % p;\n      }\n    }\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    if (a[i] == \'0\') {\n      a[i] = \'9\';\n    } else {\n      a[i]--;\n      break;\n    }\n  }\n  int resB = getRes(d, m, b, rem, dyn);\n  int resA = getRes(d, m, a, rem, dyn);\n  int res = resB - resA;\n  if (res < 0) res += p;\n  out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2200,Kareem Mohamed Kareem Mohamed suggested the simpler version of the problem Denote the answer to the problem Note that or what is the same where equals to one if is a magic number otherwise equals to zero Let s solve the problem for the segment Here is described the standard technique for this kind of problems sometimes it is called dynamic programming by digits It can be realized in a two ways The first way is to iterate over the length of the common prefix with number Next digit should be less than corresponding digit in and other digits can be arbitrary Below is the description of the second approach Let be the number of magic prefixes of length with remainder modulo If than the prefix should be less than the corresponding prefix in and if than the prefix should be equal to the prefix of it can not be greater Let s do forward dynamic programming Let s iterate over digit in position We should check that if the position is even than should be equal to otherwise it cannot be equal to Also we should check for should be not greater than corresponding digit in Now let s see what will be the next state Of course By Horner scheme Easy to see that To update the next state we should increase it Of course all calculations should be done modulo C solution Complexity 
Manao has a monitor The screen of the monitor has horizontal to vertical length ratio Now he is going to watch a movie The movie s frame has horizontal to vertical length ratio Manao adjusts the view in such a way that the movie preserves the original frame ratio but also occupies as much space on the screen as possible and fits within it completely Thus he may have to zoom the movie in or out but Manao will always change the frame proportionally in both dimensions Calculate the ratio of empty screen the part of the screen not occupied by the movie to the total screen size Print the answer as an irreducible fraction ,"['#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define db double\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m,a,b,c,d,A,B;\nint main() {\n    scanf(""%d%d%d%d"",&a,&b,&c,&d);\n    if (b*c<=d*a) A=a*d-b*c,B=a*c,A*=c,B*=d;\n    else A=b*c-a*d,B=b*d,A*=d,B*=c;\n    if (!A) printf(""0/1\\n"");\n    else k=__gcd(A,B),printf(""%d/%d\\n"",A/k,B/k);\n    return 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1400,Suppose that the width and height of the screen are W and H correspondingly Since W H a b we have H W b a Similarly the width and height of the film frame w and h are related as h w d c Imagine that Manao stretches constricts the frame until it fits the screen horizontally or vertically whichever happens first There are three cases to consider the horizontal to vertical ratio of the screen is less equal or more than the corresponding ratio of the frame In the first case a b c d the stretching process ends when the frame reaches the same width as the screen That is the frame will enlarge in W w times and its new width will be W Thus its new height is h W w w c d W w W d c We are interested in the ratio of unoccupied portion of the screen to its full size which is screen height frame height screen height W b a W d c W b a bc ad bc In the second case a b c d the process ends when the frame reaches the same height as the screen Its height will become H and its width will become w H h w W b a w d c W b a c d The unoccupied portion of the screen s horizontal is W W b a c d W ad bc ad In the third case the frame fills the screen entirely and the answer will be 0 All that s left is to print the answer as an irreducible fraction We need to find the greatest common divisor of its nominator and denominator for this It can be done using Euclidean algorithm or just through trial division by every number from 1 to q Since q is no more than a product of two numbers from the input and these numbers are constrained by 1000 we need to try at most million numbers in the worst case 
Ntarsis has been given a set S initially containing integers 1 2 3 ldots 10 1000 in sorted order Every day he will remove the a 1 th a 2 th ldots a n th smallest numbers in S What is the smallest element in S after k days ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n    }\n    \n    i64 ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (ans >= a[i]) {\n            if (ans >= a[i] + 1LL * i * (k - 1)) {\n                ans += k;\n            } else {\n                ans += (ans - a[i]) / i + 1;\n            }\n        }\n    }\n    std::cout << ans + 1 << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1800,Problem Credits nsqrtlog Analysis nsqrtlog buffering AnswerIf is between and it will move to a new position of since positions before it are deleted 
You are given an array a of length n Let s define the operation Let x a n Then array a is partitioned into two parts left and right The left part contains the elements of a that are not greater than x le x The right part contains the elements of a that are strictly greater than x x The order of elements in each part is kept the same as before the operation i e the partition is stable Then the array is replaced with the concatenation of the left and the right parts For example if the array a is 2 4 1 5 3 the eversion goes like this 2 4 1 5 3 to 2 1 3 4 5 to 2 1 3 4 5 We start with the array a and perform eversions on this array We can prove that after several eversions the array a stops changing Output the minimum number k such that the array stops changing after k eversions ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nint n;\nint a[200005];\n\nvoid solve(){\n    n=read();\n    rep(i,1,n)a[i]=read();\n    int las=n,cnt=0;\n    per(i,n-1,1)if(a[i]>a[las])las=i,cnt++;\n    print(cnt,'\\n');\n}\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900,Lemma If x is max element of the array then eversion doesn t change the array Proof In spite of the fact that division is stable all elements will be passed to the left part Their order won t be changed Lemma The lastest element after eversion is the rightest element of the array which is greater than x and lefter than x in the array Proof Look at all elements that are greater than x This is the right part of the division Due to stable division the right element that is greater will be new x There re no elements greater than x and righter than x because of eversion definition Let s build a sequence xa xa 1 x0 where x0 an xi 1 the rightest element lefter than xi and greater than xi The answer is equals to a because xi is a sequence of last elements overall eversions Example 6 10 4 17 9 2 8 1 Sequence xi is 1 8 9 17 Answer is 3 
There are n people living in the town Just now the wealth of the i th person was a i gold But guess what The richest person has found an extra pot of gold More formally find an a j max a 1 a 2 dots a n change a j to a j x where x is a non negative integer number of gold found in the pot If there are multiple maxima it can be any one of them A person is unhappy if their wealth is of the average wealth text If of the total population n are unhappy Robin Hood will appear by popular demand Determine the minimum value of x for Robin Hood to appear or output 1 if it is impossible text The average wealth is defined as the total wealth divided by the total population n that is frac sum a i n the result is a real number ,"[""#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, m, a[N];void solve(){    cin >> n;    for (int i = 1; i <= n; i++)        cin >> a[i];    sort(a + 1, a + 1 + n);    int l = 0, r = 1e18, ans = -1;    auto check = [&](int x)    {        int sum = x;        for (int i = 1; i <= n; i++)            sum += a[i];        a[n] += x;        int cnt = 0;        for (int i = 1; i <= n; i++)            if (a[i] * 2 * n < sum)                cnt++;        a[n] -= x;        return cnt > n / 2;    };    while (l <= r)    {        int mid = l + r >> 1;        if (check(mid))            r = mid - 1, ans = mid;        else            l = mid + 1;    }    cout << ans << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}""]","[1, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1100,If we sort the wealth in increasing order then the j th person must be unhappy for Robin to appear where j n 2 1 if 1 indexing or j n 2 if 0 indexing We need aj s x2 n where s is the original total wealth before x gold from the pot was added Rearranging the equation gives x 2 n aj s Because x is a non negative integer we arrive at the answer max 0 2 n aj s 1 Of course this problem can also be solved by binary search with two caveats First one needs to be careful to avoid comparison between integer and float types as rounding errors could create issues You can always avoid division by 2n by multiplying it out Second one needs to pick the upper limit carefully to ensure it is large enough Note that 2 n max a can serve as the upper limit for the binary search for x because that would push the average to be strictly above 2 max a and everyone except the one with the pot of gold would be unhappy There are 2 edge cases n 1 2 where the condition for Robin can never be reached because the richest person will always be happy at least in this problem though perhaps not IRL ChatGPT struggled to identify these edge cases so it was tempting to leave at least one hidden Following testing we decided to give both in samples to reduce frustration Note Wealth inequality is better measured by the Gini coefficient which is too involved for this problem Our criterion is a crude approximation for the Gini coefficient and is equivalent to setting the mean to median ratio a well known indicator for inequality to 2 For a random distribution this ratio is close to 1 Interestingly this ratio for UK salary distribution is around 1 2 so no Robin yet 
The Saratov State University Olympiad Programmers Training Center SSU OPTC has students For each student you know the number of times he she has participated in the ACM ICPC world programming championship According to the ACM ICPC rules each person can participate in the world championship at most 5 times The head of the SSU OPTC is recently gathering teams to participate in the world championship Each team must consist of exactly three people at that any person cannot be a member of two or more teams What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least times ,"['#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint a, b, c, nom;\n\nint main(){\n    cin >> a >> b;\n    for(int i = 0; i < a; ++i){\n\tcin >> c;\n\tif(5 - b >= c) ++nom;\n    }\n    cout << nom / 3;\n  \n    return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 1, 0]",800,In this problem you should count number of students who can participate in ACM divide it by 3 and round down It could be done like this 
Today on a math lesson the teacher told Vovochka that the Euler function of a positive integer is an arithmetic function that counts the positive integers less than or equal to n that are relatively prime to n The number is coprime to all the positive integers and Now the teacher gave Vovochka an array of positive integers and a task to process queries to calculate and print modulo As it is too hard for a second grade school student you ve decided to help Vovochka ,"['#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=acos(-1);\nvoid gn(int &x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');\n\tif(c==\'-\')sg=-1,x=0;else x=c-\'0\';\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';\n\tx*=sg;\n}\nvoid gn(ll &x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');\n\tif(c==\'-\')sg=-1,x=0;else x=c-\'0\';\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';\n\tx*=sg;\n}\nconst int mo=1000000007;\nconst int inf=1061109567;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint bo[1000005]={0},pr[1000005],tot=0;\nint lo[1111111];\nint inv[1111111];\nvoid sieve(int n){\n\tinv[1]=1;\n\tfor (int i=2;i<=n;i++){\n\t\tif(!bo[i]){\n\t\t\tpr[++tot]=i;\n\t\t\tinv[i]=qp(i,mo-2);\n\t\t\tlo[i]=i;\n\t\t}\n\t\tfor (int j=1;j<=tot && pr[j]*i<=n;j++){\n\t\t\tbo[i*pr[j]]=1;\n\t\t\tinv[i*pr[j]]=1ll*inv[i]*inv[pr[j]]%mo;\n\t\t\tlo[i*pr[j]]=pr[j];\n\t\t\tif(i%pr[j]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nint n;\n\nint a[222222];\nint b[2222222];\nint rig[222222];\nstruct quer{\n\tint l,r,id;\n}qu[222222];\nint cmp(const quer&a,const quer&b){\n\treturn a.r<b.r;\n}\nint ans[222222];\nint las[1222222]={0};\nint bit[2222222];\nint mul[2222222];\n\nvoid bitupd(int x,int d){\n\tfor(;x<=tot;x+=x&-x)bit[x]=1ll*bit[x]*d%mo;\n}\nint bitque(int x){\n\tint ans=1;\n\tfor(;x;x-=x&-x)ans=1ll*ans*bit[x]%mo;\n\treturn ans;\n}\n\nint main()\n{\n\tsieve(1000000);\n\tgn(n);\n\ttot=0;\n\tfor (int i=1;i<=n;i++){\n\t\tint x;\n\t\tgn(x);\n\t\ta[i]=x;\n\t\twhile(x>1){\n\t\t\tint p=lo[x];\n\t\t\twhile(x%p==0)x/=p;\n\t\t\tb[++tot]=p;\n\t\t}\n\t\trig[i]=tot;\n\t}\n\tmul[0]=1;\n\tfor (int i=1;i<=n;i++)mul[i]=1ll*mul[i-1]*a[i]%mo;\n\tint q;gn(q);\n\tfor (int i=1;i<=q;i++){\n\t\tgn(qu[i].l);\n\t\tgn(qu[i].r);\n\t\tqu[i].id=i;\n\t\tans[i]=1ll*mul[qu[i].r]*qp(mul[qu[i].l-1],mo-2)%mo;\n\t\tqu[i].l=rig[qu[i].l-1]+1;\n\t\tqu[i].r=rig[qu[i].r];\n\t}\n\tsort(qu+1,qu+1+q,cmp);\n\tint cur=1;\n\tfor (int i=0;i<=tot;i++)bit[i]=1;\n\tfor (int i=0;i<=tot;i++){\n\t\tif(i){\n\t\t\tif(las[b[i]]==0){\n\t\t\t\tbitupd(i,1ll*(b[i]-1)*inv[b[i]]%mo);\n\t\t\t}else{\n\t\t\t\tbitupd(las[b[i]],1ll*inv[b[i]-1]*b[i]%mo);\n\t\t\t\tbitupd(i,1ll*(b[i]-1)*inv[b[i]]%mo);\n\t\t\t}\n\t\t\tlas[b[i]]=i;\n\t\t}\n\t\twhile(cur!=q+1 && qu[cur].r==i){\n\t\t\tif(qu[cur].l>qu[cur].r){\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ans=bitque(qu[cur].r);\n\t\t\tans=1ll*ans*qp(bitque(qu[cur].l-1),mo-2)%mo;\n\t\t\t/*ans=1ll*mul[qu[cur].r]*ans%mo;\n\t\t\tans=1ll*ans*qp(mul[qu[cur].l-1],mo-2)%mo;*/\n\t\t\t::ans[qu[cur].id]=1ll*::ans[qu[cur].id]*ans%mo;\n\t\t\tcur++;\n\t\t}\n\t}\n\tfor (int i=1;i<=q;i++)printf(""%d\\n"",ans[i]);\n\treturn 0;\n}\n\t\t\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2500,Read input including queries to solve them offline Sort the queries by making sure to keep their original indices Use Sieve of Erastosthenes to precalculate primes up to Use those primes to factorize all the values of this step takes We want to store the results in two data structures Initialize a BIT or segment tree that can calculate range products modulo with the values from Use to find the leftmost index for each prime factor Multiply those positions in by We can now answer queries with using To advance by to eventually answer the rest of the queries Sample 65793661 
Jellyfish loves playing a game called Inscryption which is played on a directed acyclic graph with n vertices and m edges All edges a to b satisfy a b You need to move from vertex 1 to vertex n along the directed edges and then fight with the final boss You will collect and in the process Each has two attributes HP and damage If a HP is a and its damage is b then the power of the is a times b Each has only one attribute power In addition to vertex 1 and vertex n there are some vertices that trigger special events The special events are You will get a with a HP and b damage If you have at least one choose one of your and increase its HP by x If you have at least one choose one of your and increase its damage by y You will get a with w power When you get to vertex n you can choose of your and multiply its damage by 10 9 The final boss is very strong so you want to maximize the sum of the power of all your and Find the maximum possible sum of power of all your and if you play the game optimally ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// slow ...\n\nconst int K = 200;\nint N, M;\nvi type, hp, damage, power;\nvpi card;\nll ans = 0;\nV<vi> in, out;\n\nV<vpi> dp_flash;\nV<V<vi>> F;\n\nconst pi EMP{-1, 0};\nvoid solve_flash() {\n\tdp_flash.rsz(N + 1);\n\tvi max_power(N + 1);\n\t// vpi(N * K + 1, {-1, 0})\n\tROF(x, 1, N + 1) {\n\t\t// dp[x][a]: have a upon entering this\n\t\tdp_flash.at(x) = vpi((N - x) * K + 1, EMP);\n\t\tdp_flash.at(x).at(0) = {0, 0};\n\t\tfor (int y : out[x]) {\n\t\t\tckmax(max_power[x], max_power[y]);\n\t\t\tF0R(a, sz(dp_flash.at(y))) {\n\t\t\t\tckmax(dp_flash.at(x).at(a), dp_flash.at(y).at(a));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\t\t\t// nothing\n\t\t} else if (type[x] == 1) {\n\t\t\tassert(card[x].f);\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.s += card[x].f * card[x].s;\n\t\t} else if (type[x] == 2) {\n\t\t\tassert(hp[x]);\n\t\t\tdp_flash.at(x).ins(begin(dp_flash.at(x)), hp[x], EMP);\n\t\t} else if (type[x] == 3) {\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.f += damage[x];\n\t\t} else if (type[x] == 4) {\n\t\t\tmax_power[x] += power[x];\n\t\t\tassert(power[x]);\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.s += power[x];\n\t\t}\n\t}\n\tckmax(ans, (ll)max_power[1]);\n\t// each(t, dp_flash.at(1)) ckmax(ans, (ll)t.s);  // no cards\n}\n\nvoid finish_slow() {\n\tV<V<vi>> G;\n\tF.rsz(N + 1), G.rsz(N + 1);\n\tFOR(x, 1, N + 1) {\n\t\tF[x] = V<vi>(K + 1, vi(x * K + 1, -1));\n\t\tG[x] = V<vi>(K + 1, vi(x * K + 1, -1));\n\t\tF[x].at(0).at(0) = 0;\n\t\tfor (int y : in.at(x)) {\n\t\t\tF0R(a, sz(F[y])) F0R(b, sz(F[y][a])) {\n\t\t\t\tckmax(F[x].at(a).at(b), F[y].at(a).at(b));\n\t\t\t}\n\t\t\tF0R(a, sz(G[y])) F0R(b, sz(G[y][a])) {\n\t\t\t\tckmax(G[x].at(a).at(b), G[y].at(a).at(b));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\n\t\t} else if (type[x] == 1) {  // add card\n\t\t\tint max_ans = 0;\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) ckmax(max_ans, F[x][a][b]);\n\t\t\tF0R(a, sz(G[x]))\n\t\t\tF0R(b, sz(G[x][a]))\n\t\t\tif (G[x][a][b] != -1) ckmax(max_ans, G[x][a][b] + a * b);\n\t\t\t{  // case: start flash here\n\t\t\t\t// dbg(""BEFORE"", x, ans, max_ans);\n\t\t\t\tF0R(a, sz(dp_flash.at(x))) if (dp_flash.at(x).at(a) != EMP) {\n\t\t\t\t\tconst ll MUL = 1e9;\n\t\t\t\t\tauto [b, extra] = dp_flash.at(x).at(a);\n\t\t\t\t\tckmax(ans, max_ans + extra +\n\t\t\t\t\t               (card[x].f + a) * (card[x].s + b) * MUL -\n\t\t\t\t\t               card[x].f * card[x].s);\n\t\t\t\t\t// dbg(""GOT"", a, b, card[x], ans);\n\t\t\t\t}\n\t\t\t\t// dbg(""AFTER"", x, ans);\n\t\t\t}\n\t\t\t{  // F -> F\n\t\t\t\tF0R(a, sz(F[x]))\n\t\t\t\tF0R(b, sz(F[x][a]))\n\t\t\t\tif (F[x][a][b] != -1) F[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tR0F(a, sz(F[x]))\n\t\t\t\tR0F(b, sz(F[x][a])) {\n\t\t\t\t\tckmax(F[x].at(a).at(card[x].s), F[x][a][b]);\n\t\t\t\t\tckmax(F[x].at(card[x].f).at(b), F[x][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{  // G -> F\n\t\t\t\tF0R(a, sz(G[x]))\n\t\t\t\tF0R(b, sz(G[x][a]))\n\t\t\t\tif (G[x][a][b] != -1) {\n\t\t\t\t\tG[x][a][b] += card[x].f * card[x].s;\n\t\t\t\t\tckmax(F[x][a][card[x].s], G[x][a][b] + a * b);\n\t\t\t\t\tckmax(F[x][card[x].f][b], G[x][a][b] + a * b);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// -> G\n\t\t\tckmax(G[x].at(card[x].f).at(card[x].s), max_ans);\n\t\t} else if (type[x] == 2) {  // increase HP\n\t\t\tassert(hp[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += hp[x] * b;\n\t\t\t}\n\t\t\tR0F(a, sz(G[x]))\n\t\t\tR0F(b, sz(G[x][a])) if (a + hp[x] <= K) {\n\t\t\t\tckmax(G[x][a + hp[x]][b], G[x][a][b]);\n\t\t\t}\n\t\t} else if (type[x] == 3) {  // increase damage\n\t\t\tassert(damage[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += a * damage[x];\n\t\t\t}\n\t\t\tR0F(a, sz(G[x]))\n\t\t\tR0F(b, sz(G[x][a])) if (b + K < sz(G[x][a])) {\n\t\t\t\tckmax(G[x][a][b + damage[x]], G[x][a][b]);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(type[x] == 4);\n\t\t\teach(a, F[x]) each(b, a) if (b != -1) b += power[x];\n\t\t\teach(a, G[x]) each(b, a) if (b != -1) b += power[x];\n\t\t}\n\t}\n}\n\nvoid finish_fast() {\n\tV<V<vi>> G_a;\n\tF.rsz(N + 1), G_a.rsz(N + 1);\n\tFOR(x, 1, N + 1) {\n\t\tF[x] = V<vi>(K + 1, vi(K + 1, -1));\n\t\tG_a[x] = V<vi>(K + 1, vi(K + 1, -1));\n\t\tF[x].at(0).at(0) = 0;\n\t\tfor (int y : in.at(x)) {\n\t\t\tF0R(a, sz(F[y])) F0R(b, sz(F[y][a])) {\n\t\t\t\tckmax(F[x].at(a).at(b), F[y].at(a).at(b));\n\t\t\t}\n\t\t\tF0R(a, sz(G_a[y])) F0R(b, sz(G_a[y][a])) {\n\t\t\t\tckmax(G_a[x].at(a).at(b), G_a[y].at(a).at(b));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\n\t\t} else if (type[x] == 1) {  // add card\n\t\t\t// TODO: fix\n\t\t\tint max_ans = 0;\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) ckmax(max_ans, F[x][a][b]);\n\t\t\t{  // case: start flash here\n\t\t\t\t// dbg(""BEFORE"", x, ans, max_ans);\n\t\t\t\tF0R(a, sz(dp_flash.at(x))) if (dp_flash.at(x).at(a) != EMP) {\n\t\t\t\t\tconst ll MUL = 1e9;\n\t\t\t\t\tauto [b, extra] = dp_flash.at(x).at(a);\n\t\t\t\t\tckmax(ans, max_ans + extra +\n\t\t\t\t\t               (card[x].f + a) * (card[x].s + b) * MUL -\n\t\t\t\t\t               card[x].f * card[x].s);\n\t\t\t\t\t// dbg(""GOT"", a, b, card[x], ans);\n\t\t\t\t}\n\t\t\t\t// dbg(""AFTER"", x, ans);\n\t\t\t}\n\t\t\t{  // F -> F\n\t\t\t\tF0R(a, sz(F[x]))\n\t\t\t\tF0R(b, sz(F[x][a]))\n\t\t\t\tif (F[x][a][b] != -1) F[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tR0F(a, sz(F[x]))\n\t\t\t\tR0F(b, sz(F[x][a])) {\n\t\t\t\t\tckmax(F[x].at(a).at(card[x].s), F[x][a][b]);\n\t\t\t\t\tckmax(F[x].at(card[x].f).at(b), F[x][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{  // G_a: replace a\n\t\t\t\tF0R(a, sz(G_a[x]))\n\t\t\t\tF0R(b, sz(G_a[x][a]))\n\t\t\t\tif (G_a[x][a][b] != -1) G_a[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tF0R(a, sz(G_a[x]))\n\t\t\t\tF0R(b, sz(G_a[x][a])) ckmax(G_a[x][card[x].f][b], G_a[x][a][b]);\n\t\t\t}\n\t\t\t// -> G_a\n\t\t\tF0R(b, K - card[x].f + 1) {\n\t\t\t\tckmax(G_a[x][card[x].f + b][b],\n\t\t\t\t      max_ans + (card[x].f + b) * card[x].s);\n\t\t\t}\n\t\t} else if (type[x] == 2) {  // OK\n\t\t\t                        // increase HP\n\t\t\tassert(hp[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += hp[x] * b;\n\t\t\t}\n\t\t\tR0F(a, sz(G_a[x]))\n\t\t\tF0R(b, sz(G_a[x][a])) if (b >= hp[x] && G_a[x][a][b] != -1) {\n\t\t\t\tckmax(G_a[x][a][b - hp[x]], G_a[x][a][b]);\n\t\t\t}\n\t\t} else if (type[x] == 3) {  // OK\n\t\t\t                        // increase damage\n\t\t\tassert(damage[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += a * damage[x];\n\t\t\t}\n\t\t\tR0F(a, sz(G_a[x]))\n\t\t\tR0F(b, sz(G_a[x][a])) if (G_a[x][a][b] != -1) {\n\t\t\t\tG_a[x][a][b] += a * damage[x];\n\t\t\t\t// ckmax(G[x][a][b + damage[x]], G[x][a][b]);\n\t\t\t}\n\t\t} else {  // OK\n\t\t\tassert(type[x] == 4);\n\t\t\teach(a, F[x]) each(b, a) if (b != -1) b += power[x];\n\t\t\teach(a, G_a[x]) each(b, a) if (b != -1) b += power[x];\n\t\t}\n\t\tFOR(a, 1, sz(G_a[x])) ckmax(F[x][a][0], G_a[x][a][0]);\n\t}\n}\n\nvoid solve() {\n\tsolve_flash();\n\t// finish_slow();\n\tfinish_fast();\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tre(N, M);\n\ttype.rsz(N + 1);\n\thp.rsz(N + 1);\n\tdamage.rsz(N + 1);\n\tcard.rsz(N + 1);\n\tpower.rsz(N + 1);\n\tFOR(i, 1, N + 1) {\n\t\tre(type[i]);\n\t\tif (type[i] == 0) {\n\t\t} else if (type[i] == 1) re(card[i]);\n\t\telse if (type[i] == 2) re(hp[i]);\n\t\telse if (type[i] == 3) re(damage[i]);\n\t\telse {\n\t\t\tassert(type[i] == 4);\n\t\t\tre(power[i]);\n\t\t}\n\t}\n\t// dbg(card[2]);\n\tin.rsz(N + 1);\n\tout.rsz(N + 1);\n\trep(M) {\n\t\tdef(int, u, v);\n\t\tout[u].pb(v), in[v].pb(u);\n\t}\n\tsolve();\n\tdbg(""MID"", ans);\n\teach(t, card) swap(t.f, t.s);\n\tswap(hp, damage);\n\tFOR(i, 1, N + 1) if (2 <= type[i] && type[i] <= 3) type[i] ^= 1;\n\tsolve();\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3500,TutorialFor convenience let s define use operation 1 for You will get a card with HP and damage operation 2 for If you have at least one card choose one of your cards and increase its HP by and operation 3 for If you have at least one card choose one of your cards and increase its damage by operation 4 for You will get a prop with power operation 5 for You can choose at most one of your cards and multiply its damage by the th card for the card we get from vertex It must be operation 1 on vertex do operation 2 3 5 onto card for When we do this operation 2 3 5 we will choose the card and increase his HP or damage Let us consider the problem without the operation 5 what s the maximum possible answer If you want to maximize the the sum of the power of your cards the answer will not exceeding If you you want to maximize the the sum of the power of your props the answer will not exceeding Because so the operation is the most important Let s called the card we wil do the operation 5 onto it the flash card Let s use meet in the middle the problem is divided into two subproblems the game before we get the flash card and the game after we get the flash card 1 The game after we get the flash cardIt s a easy problem we can use dynamic programming to solve this problem Since the most important thing is the HP and damage of the flash card so we define the following dynamic programming state means we are current at vertex the current HP of the flash card is the maximum damage of the flash card means we are current at vertex the current HP of the flash card is the damage of the flash card is the maximum sum of the power of all the other cards and props Since the time complexity of the transition is 2 The game before we get the flash cardThis is the key of the problem and since it s much more difficult we first consider the subproblems of this problem I If the graph is a chain and all the operation 2 and operation 3 is after the operation 1Lemma We will do all the operation 2 onto one of the cards symmetrically we will also do all the operation 3 onto one of the cards Proof We consider a sequence of operations let s consider if we do all the operation 1 on the card with the max damage after doing all the operation 2 the answer won t be worse we can do all the operation 1 onto this card instead then we make a symmetrical adjustment the answer won t be worse and all the operation 2 is done onto one of the cards all the operation 3 is done onto one of the cards II If the graph is a chainIt s similar to the subproblem I If we say subproblem I is like a global max value then subproblem II is like a prefix max value Let s define means we will do the operation 2 3 on vertex onto the th card Lemma1 If there is a operation 2 on vertex and a operation 2 on vertex if we will have Proof Let s consider the final HP and damage of the cards after all the operations Because we do the operation 2 on vertex onto the th card for all the damage of the th card is not larger than the th card So for if we don t do the operation 2 on vertex j onto the th card we can do it onto the th card instead the answer won t be worse Symmetrically Lemma1 is also correct for operation 3 Now we can use dynamic programming to solve the problem we define the following dynamic programming state means we are current at vertex we will do the next several operation 3 onto a card with HP after all the operations and we will do the next several operation 2 onto a card with damage after all the operations and this two cards are not the same means we are current at vertex We will do the next several operation 2 and operation 3 onto a card currently having HP and damage The time complexity is but it s not enough Lemma2 If a card has HP and damage after all the operations and it s not the flash card Proof If we use this card as the flash card instead of the last one and do all the operations done onto the last flash card onto this card the power of the flash card will be larger So it won t exist in this half problem Now the time complexity becomes it s still not enough Lemma3 Let s define as the maximum HP of all the cards except the flash card after all the operations as the maximum damage of all the cards except the flash card after all the operations Proof Let s assume that the th card has HP after all the operations the th card has damage after all the operations and If it conflicts with Lemma 2 If because of the Lemma 2 the HP of the th card after all the operations won t exceed let s use as the HP of the th card after all the operations and so we have done some operation 3 onto the th card But because if we do these operations onto the th card the answer will be better If it s symmetric with But we can make the dynamic programming state better means we are current at vertex we will do the next several operation 3 onto a card with HP after all the operations and we will do the next several operation 2 onto a card with damage after all the operations and this two cards are not the same means we are current at vertex we will do the next several operation 3 onto a card with HP after all the operations we will do the next several operation 2 onto a card and totally increase HP in the next several operations to reach it s HP after all the operations it s symmetric with just swap HP and damage Let s define as the maximum HP of all the cards except the flash card after all the operations as the maximum damage of all the cards except the flash card after all the operations We will find the in is because if using we can get the right answer if using we can get the right answer the time complexity of the transition is The transition is very complex you can see more details in my code In my code I use to make the transition better When or reaches we reaches the vertex and there is a operation 1 on vertex I don t enumerate the value of the next and while transiting I transit it to first and enumerate the value of the next and together III the problem itselfSince the path is a chain and we use dynamic programming to solve the problem There s no difference whether the graph is a chain Time complexity Memory complexity 
Amugae has a sentence consisting of n words He want to compress this sentence into one word Amugae doesn t like repetitions so when he merges two words into one word he removes the longest prefix of the second word that coincides with a suffix of the first word For example he merges and into Amugae will merge his sentence left to right i e first merge the first two words then merge the result with the third word and so on Write a program that prints the compressed word after the merging process ends ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mxN=1e5;\nint n;\nstring ans;\n\nint kmp(string s) {\n\tvector<int> pf(s.size());\n\tfor(int j=1; j<s.size(); ++j) {\n\t\tint k=pf[j-1];\n\t\twhile(s[k]!=s[j]) {\n\t\t\tif(!k) {\n\t\t\t\tk=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk=pf[k-1];\n\t\t}\n\t\tpf[j]=k+1;\n\t}\n\treturn pf.back();\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; ++i) {\n\t\tif(!i) {\n\t\t\tcin >> ans;\n\t\t\tcontinue;\n\t\t}\n\t\tstring s;\n\t\tcin >> s;\n\t\tstring t=s;\n\t\tt+='#';\n\t\tint a=min((int)ans.size(), (int)s.size());\n\t\tt.insert(t.end(), ans.end()-a, ans.end());\n\t\tint x=kmp(t);\n\t\twhile(x--)\n\t\t\tans.pop_back();\n\t\tans.insert(ans.end(), s.begin(), s.end());\n\t}\n\tcout << ans;\n}""]","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2000,Denote the words from left to right as If we define string as the result of merging as described in the problem times we can get by the following process If length of length of Assume the length of is and the length of is Construct the string for string is the substring from index to Get the KMP failure function from string We can get maximum overlapped length of s prefix and s suffix from this function Suppose the last element of the failure function smaller than the length of is Then the longest overlapped length of s suffix and s prefix is Let Then Otherwise Construct as We can get from the same process described in 1 In this process we can get from in time complexity So we can get the answer of this problem in 
Recall that a permutation of length n is an array where each element from 1 to n occurs exactly once For a fixed positive integer d let s define the cost of the permutation p of length n as the number of indices i 1 le i n such that p i cdot d p i 1 For example if d 3 and p 5 2 6 7 1 3 4 then the cost of such a permutation is 2 because p 2 cdot 3 p 3 and p 5 cdot 3 p 6 Your task is the following one for a given value n find the permutation of length n and the value d with maximum possible cost over all ways to choose the permutation and d If there are multiple answers then print any of them ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:36:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a;\n    for (int i = 1; i <= n; i++) {\n      if (i % 2 == 1) {\n        int j = i;\n        while (j <= n) {\n          a.push_back(j);\n          j *= 2;\n        }\n      }\n    }\n    cout << 2 << \'\\n\';\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800,Let s notice that for a fixed value of the answer the cost of permutation does not exceed because only numbers from to can have a pair It turns out that it is always possible to construct a permutation with the cost of exactly It is enough to consider the number chains of the form where It is not difficult to understand that each number is included in exactly one such chain Therefore if we append the chains one after another then in such a permutation the answer will be equal to because all numbers will have a pair except the last element in the chain The number of chains is equal to which means the cost of the permutation is equal to By choosing the permutation will have the maximum possible cost 
Neko is playing with his toys on the backyard of Aki s house Aki decided to play a prank on him by secretly putting catnip into Neko s toys Unfortunately he went overboard and put an entire bag of catnip into the toys It took Neko an entire day to turn back to normal Neko reported to Aki that he saw a lot of weird things including a trie of all correct bracket sequences of length 2n The definition of correct bracket sequence is as follows The empty sequence is a correct bracket sequence If s is a correct bracket sequence then s is a correct bracket sequence If s and t are a correct bracket sequence then st is also a correct bracket sequence For example the strings form a correct bracket sequence while and not Aki then came up with an interesting problem What is the size of the maximum matching the largest set of edges such that there are no two edges with a common vertex in this trie Since the answer can be quite large print it modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000000007 \n#define N 1005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nint n;\npair<int,bool> dp[N][N<<1];\nint vis[N][N<<1];\n\nint add(int x,int y) {\n\n\tx+=y;\n\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n\n\treturn x;\n\n}\n\nvoid dfs(int bal,int rem) {\n\n\tif(bal-rem>0) return ;\n\n\tif(rem==0) {\n\n\t\tdp[bal][rem]={0,1};\n\n\t\treturn ;\n\n\t}\n\n\tif(vis[bal][rem]) return ;\n\n\tvis[bal][rem]=1;\n\n\tdp[bal][rem].nd=1;\n\n\tif(bal) {\n\n\t\tdfs(bal+1,rem-1);\n\t\tdfs(bal-1,rem-1);\n\n\t\tdp[bal][rem].st=add(dp[bal][rem].st,add(dp[bal+1][rem-1].st,dp[bal-1][rem-1].st));\n\n\t\tif(dp[bal-1][rem-1].nd || dp[bal+1][rem-1].nd) {\n\n\t\t\tdp[bal][rem].st=add(dp[bal][rem].st,1);\n\n\t\t\tdp[bal][rem].nd=0;\n\n\t\t}\n\n\t}\n\telse {\n\n\t\tdfs(bal+1,rem-1);\n\n\t\tdp[bal][rem].st=add(dp[bal][rem].st,dp[bal+1][rem-1].st);\n\n\t\tif(dp[bal+1][rem-1].nd) {\n\n\t\t\tdp[bal][rem].st=add(dp[bal][rem].st,1);\n\n\t\t\tdp[bal][rem].nd=0;\n\n\t\t}\n\n\t}\n\n}\n\nint main() {\n\n\tscanf(""%d"",&n);\n\n\tdfs(1,2*n-1);\n\n\tprintf(""%d"",dp[1][2*n-1].st);\n\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2100,Note that many subtrees of the trie are equal Basically if we consider two vertices on the same depth and having the same balance from root to them that is the number of opening brackets minus the number of closing brackets than their subtrees will be entirely same For example the subtrees after following and are all the same We will use this observation to consider the tree in compressed form Clearly this way there are only different vertices types basically a vertex is described by Now let s get back to finding a maximum matching in the tree There are two approaches to this problem One of them is greedy Basically if you find a matching in a tree you can always greedily take the edge between a leaf and its parent since this adds one edge to the answer and destroys at most one edge you would ve chosen This idea can transform into the following algorithm for the problem of the maximum matching in the tree Do a dynamic programming on the subtrees the result of is a pair of number of edges taken in subtree whether the root of this subtree is free so we can start a new edge upwards Combining this with the idea that there are little number of vertex types we get a dp solution 
You are given a connected undirected graph with vertices and edges The vertices are enumerated from to You are given integers each of them is between and inclusive It is also guaranteed that the parity of equals the parity of degree of vertex The degree of a vertex is the number of edges connected to it You are to write a weight between and inclusive on each edge in such a way that for each vertex the sum of weights on edges connected to this vertex is equal to or determine that this is impossible ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nclass edge {\npublic:\n\tint s, e;\n\tedge() {\n\t\t*this = edge(0, 0);\n\t}\n\tedge(int s, int e) : s(s), e(e) {}\n};\nvector <edge> Ve;\nvector <int> conn[300050];\nvoid epush(int s, int e) {\n\tconn[s].push_back(Ve.size());\n\tconn[e].push_back(Ve.size());\n\tVe.emplace_back(s, e);\n}\n\nll in[100050];\nll ans[300050];\n\nint dep[100050];\npii par[100050];\nbool dchk[100050];\nvector <int> Vb;\nvector <int> son[100050];\nvoid DFS(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) {\n\t\tedge &ed = Ve[it];\n\t\tint x = ed.s ^ ed.e ^ n;\n\t\tif (x == par[n].second) continue;\n\t\tif (dchk[x]) Vb.push_back(it);\n\t\telse {\n\t\t\tdep[x] = dep[n] + 1;\n\t\t\tpar[x] = pii(it, n);\n\t\t\tson[n].push_back(x);\n\t\t\tDFS(x);\n\t\t\t\n\t\t}\n\t}\n}\nvoid DFS2(int n) {\n\tfor (auto it : son[n]) {\n\t\tDFS2(it);\n\t\tin[n] -= ans[par[it].first];\n\t}\n\tif (n != 1) ans[par[n].first] = in[n];\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 1; i <= N; i++) scanf(""%lld"", &in[i]);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2;\n\t\tscanf(""%d %d"", &t1, &t2);\n\t\tepush(t1, t2);\n\t}\n\tDFS(1);\n\n\tll s[2] = { 0,0 };\n\tfor (i = 1; i <= N; i++) s[dep[i] % 2] += in[i];\n\n\tif ((s[0] - s[1]) % 2) return !printf(""NO\\n"");\n\n\tsort(all(Vb));\n\tVb.erase(unique(all(Vb)), Vb.end());\n\tfor (auto it : Vb) {\n\t\tint x = Ve[it].s, y = Ve[it].e;\n\t\tif (dep[x] % 2 != dep[y] % 2) continue;\n\n\t\tint z = dep[x] % 2;\n\t\tll a = (s[z] - s[1 - z]) / 2;\n\t\tin[x] -= a, in[y] -= a;\n\t\tans[it] = a;\n\t\ts[z] -= 2 * a;\n\t}\n\tif (s[0] != s[1]) return !printf(""NO\\n"");\n\tDFS2(1);\n\t\n\tprintf(""YES\\n"");\n\tfor (i = 0; i < M; i++) printf(""%lld\\n"", ans[i]);\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",2700,Let s solve two cases First case is when graph is the bipartite graphThen the sum of weights of the left part should be equal to the sum of weights of the right part because each edge will bring an equal contribution to the sums of both part We will leave any spanning tree of this graph then for it the solution is unique take the edges entering the leafs their weights are uniquely determined subtract weights from weights of the second ends of this edges delete the leafs recursively this solution can be found with dfs then in the end the root will has weight 0 because sum of weights of the left part equal to the sum of weights of the right part Thus the answer exists when the sum of the weights of the left part is equal to the sum of the weights of the right part Second case when graph has the odd cycle We find an odd cycle root the tree for any of its vertices solve the tree Then we add to the weights of the edges of the cycle adjacent to the root minus its weight divided by 2 it is even because it is the sum of the weights of all vertices with different signs equal to the sum of the degrees of vertices by modulo 2 and for all others we alternate the signs with which we add this value then for all vertices except the root the sum does not change but for the root we get the required value Example code https pastebin com b2bGp4Bh 
Once upon a time Petya and Gena gathered after another programming competition and decided to play some game As they consider most modern games to be boring they always try to invent their own games They have only stickers and markers but that won t stop them The game they came up with has the following rules Initially there are stickers on the wall arranged in a row Each sticker has some number written on it Now they alternate turn Petya moves first One move happens as follows Lets say there are stickers on the wall The player who makes the current move picks some integer from to and takes leftmost stickers removes them from the wall After that he makes the new sticker puts it to the left end of the row and writes on it the new integer equal to the sum of all stickers he took on this move Game ends when there is only one sticker left on the wall The score of the player is equal to the sum of integers written on all stickers he took during all his moves The goal of each player is to maximize the difference between his score and the score of his opponent Given the integer and the initial sequence of stickers on the wall define the result of the game i e the difference between the Petya s and Gena s score if both players play optimally ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)2e5+5;\nint n,a[N],m,s[N],ans[N];\n\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t\tcin >> a[i];\n\ts[0]=a[0];\n\tfor(int i=1;i<n;i++)\n\t\ts[i]=s[i-1]+a[i];\n\tans[n-2]=s[n-1];\n\tm=s[n-2]-ans[n-2];\n\tfor(int i=n-3;i>=0;i--)\n\t{\n\t\tif(i==0)ans[i]=max(m,s[n-1]); else ans[i]=max(m,s[n-1]-s[i-1]);\n\t\tm=max(m,s[i]-ans[i]);\n\t}\n\tcout << ans[0];\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2200,First of all comment on such type of games In CS the game where two players are willing to maximize the difference between their own score and the score of their opponent is called a zero sum game A useful knowledge is that problems for such a kind of games are usually solved using dynamic programming Note that at any moment the first sticker contains the sum of numbers on some prefix of an original sequence This means that the state of a game is defined by a single number the length of an original sequence prefix that were summed into a single number Let s make two observations First of all for any state the turn that current player will perform doesn t depend on scores of both players Indeed at any moment we may forget about the scores of both players since they add the constant factor to the resulting score difference so we may virtually discard both players current scores So all we need to know about state is what difference there will be between the current player score and his opponent score if the game would have started from the state with zero scores Second observation is that the turn chosen by a player from the state and the final difference of scores at the end does not depend from which player is currently making a turn Petr or Gennady i e the game is symmetric Denote as the difference between the first player score and the second player score if the game would have started from the state with zero scores It is a convenient way to think about this game as if there were no separate scores of two players but only a single balance value difference between them and the first player is adding some numbers to the balance at his turn nd second player subtracts some numbers from the balance In such formulation is a balance change at the end of the game if the current player is willing to maximize it and he is currently in the state The answer for a problem will be as one can see Note that if the current player would be willing to minimize balance then the final balance change from the state would be because the game is symmetric Let s calculate all using dynamic programming At the end of the game i e in the state the value is equal to zero because the players won t be making any turns and so the balance won t change Consider some state Suppose current player will take all the stickers up to the th here th means the index in the original sequence In such case he will change balance by where is the sum of first numbers in an original sequence and game will move to the state After that his opponent will change the balance by note that the balance change value is added with an opposite sign since the opponent will be playing from this state So the final balance change when making such a turn will be In the DP definition we play for a player that is willing to maximize the balance so Such a formula produces a solution in but one may find that that it s enough to keep the maximum value of on suffix recalculating it in when moving from to So we have the solution that works in Question Which data type should be used for and for the answer in particular 
Sasha is taking part in a programming competition In one of the problems she should check if some rooted trees are isomorphic or not She has never seen this problem before but being an experienced participant she guessed that she should match trees to some sequences and then compare these sequences instead of trees Sasha wants to match each tree with a sequence where is the height of the tree and equals to the number of vertices that are at distance of edges from root Unfortunately this time Sasha s intuition was wrong and there could be several trees matching the same sequence To show it you need to write a program that given the sequence builds two non isomorphic rooted trees that match that sequence or determines that there is only one such tree Two rooted trees are isomorphic if you can reenumerate the vertices of the first one in such a way that the index of the root becomes equal the index of the root of the second tree and these two trees become equal The height of a rooted tree is the maximum number of edges on a path from the root to any other vertex ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in[200050];\n\nint sum[200050];\n\nvector <int> Vl[200050];\nint main() {\n\tint N, i, j;\n\tscanf(""%d"", &N);\n\tfor (i = 0; i <= N; i++) scanf(""%d"", &in[i]);\n\n\tfor (i = 1; i < N; i++) if (in[i] > 1 && in[i + 1] > 1) break;\n\tif (i >= N) return !printf(""perfect\\n"");\n\n\tint p = i;\n\tprintf(""ambiguous\\n"");\n\tsum[0] = 1;\n\tfor (i = 1; i <= N; i++) sum[i] = sum[i - 1] + in[i];\n\n\tint st = 2;\n\tprintf(""0 "");\n\tVl[0].push_back(1);\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = st; j <= sum[i]; j++) {\n\t\t\tprintf(""%d "", Vl[i - 1][0]);\n\t\t\tVl[i].push_back(j);\n\t\t}\n\t\tst = sum[i] + 1;\n\t}\n\tprintf(""\\n"");\n\tfor (i = 0; i <= N; i++) Vl[i].clear();\n\n\tst = 2;\n\tprintf(""0 "");\n\tVl[0].push_back(1);\n\tfor (i = 1; i <= N; i++) {\n\t\tif (i != p+1) {\n\t\t\tfor (j = st; j <= sum[i]; j++) {\n\t\t\t\tprintf(""%d "", Vl[i - 1][0]);\n\t\t\t\tVl[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(""%d "", Vl[i - 1][1]);\n\t\t\tVl[i].push_back(st);\n\t\t\tfor (j = st + 1; j <= sum[i]; j++) {\n\t\t\t\tprintf(""%d "", Vl[i - 1][0]);\n\t\t\t\tVl[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\tst = sum[i] + 1;\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1500,There are many ways to solve the problem First of all you should build any single tree To do this you first build the longest path from the root and then attach remained vertices on proper heights Thus each vertex is either on the longest path or has parent on this path To build the second tree you should use different vertices from previous levels during construction to make it different from first tree This is always possible if there are two consecutive Otherwise the tree is determined uniquely by sequence 
Zane the wizard had never loved anyone before until he fell in love with a girl whose name remains unknown to us The girl lives in house of a village There are houses in that village lining in a straight line from left to right house house house The village is also well structured house and house are exactly meters away In this village some houses are occupied and some are not Indeed unoccupied houses can be purchased You will be given integers that denote the availability and the prices of the houses If house is occupied and therefore cannot be bought then equals Otherwise house can be bought and represents the money required to buy it in dollars As Zane has only dollars to spare it becomes a challenge for him to choose the house to purchase so that he could live as near as possible to his crush Help Zane determine the minimum distance from his crush s house to some house he can afford to help him succeed in his love ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, a[10000];\nint main() {\n\tcin >> n >> m >> k;\n\tint ans = n + 1;\n\tm--;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tif (a[i] != 0 && a[i] <= k) {\n\t\t\tans = min(ans, abs(m - i));\n\t\t}\n\t}\n\tcout << ans * 10 << endl;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",800,This is a simple implementation problem Let the be infinity initially Iterate through the houses Suppose we are considering house update the if and only if1 2 and3 The answer is This solution runs in 
Monocarp plays Rage of Empires II Definitive Edition a strategic computer game Right now he s planning to attack his opponent in the game but Monocarp s forces cannot enter the opponent s territory since the opponent has built a wall The wall consists of n sections aligned in a row The i th section initially has durability a i If durability of some section becomes 0 or less this section is considered broken To attack the opponent Monocarp needs to break at least two sections of the wall any two sections possibly adjacent possibly not To do this he plans to use an onager a special siege weapon The onager can be used to shoot any section of the wall the shot deals 2 damage to the target section and 1 damage to adjacent sections In other words if the onager shoots at the section x then the durability of the section x decreases by 2 and the durability of the sections x 1 and x 1 if they exist decreases by 1 each Monocarp can shoot at any sections any number of times Monocarp wants to calculate the minimum number of onager shots needed to break at least two sections Help him ,"['#include ""bits/stdc++.h""\n \nusing namespace std;\n \nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n \n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n \n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n \n#define pb                          push_back\n \n#define pry                         puts(""YES"")\n#define prn                         puts(""NO"")\n#define endl                        \'\\n\'\n \n#define fst                         first\n#define scn                         second\n \n#define int long long\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<int>a(n);\n    forn(i,n)cin>>a[i];\n    vector<int>b=a;\n    sort(all(b));\n    int ans = (b[0]+1)/2+(b[1]+1)/2;\n\n    for(int i=0;i+1<n;i++){\n        int x=a[i],y=a[i+1];\n        if(x>y)swap(x,y);\n        if(y>=2*x){\n            ans=min(ans,(y+1)/2);\n            continue;\n        }\n        int pp = y-x;\n        y-=pp*2;\n        x-=pp;\n        int now = pp+x/3*2+x%3;\n        ans=min(ans,now);\n    }\n    for(int i=0;i+2<n;++i){\n        int x=a[i],y=a[i+2];\n        if(x>y)swap(x,y);\n        int now=x/2+y/2;\n        x%=2,y%=2;\n        if(x || y) ++now;\n        ans=min(ans,now);\n    }\n    cout<<ans<<endl;\n}\n \nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while(t--)\n        solve();\n}']","[1, 1, 0, 0, 0, 1, 1, 1, 0, 0]",2000,Let s analyze three cases based on the distance between two sections we are going to break break two neighboring sections and break two sections with another section between them and break two sections with more than one section between them Why exactly these cases Because the damage from the shots and the possibility to hit both sections with the same shot depends on the distance between them If there is more than one section between the two we want to break then any shot hits only one of these sections so each shot should be aimed at one of those sections and we break them independently Let s pick two sections with minimum durability and calculate the number of shots required to break them if these sections are and then the required number of shots is It actually does not matter if the distance between them is less than if it is so these sections will be analyzed in one of the other cases Okay now let s deal with two sections having exactly one section between them We can iterate on all combinations of these sections iterate on from to and pick sections and Let s analyze how can we damage them If we shoot at the section between them we deal damage to both sections if we shoot at one of those sections we deal damage to it and damage to the other section So each shot distributes damage between these two sections the way we want to distribute it and the number of shots required to break these two sections is The case when we try to break two adjacent sections is the trickiest one Let s say that these sections are and and If we target one of these sections we deal damage to it and damage to the other section Let s try to run the following algorithm shoot at the section with higher durability until both of them break It can be slow but we can see that after the first shots the durabilities of the sections become equal and each pair of shots after that deals damage to both sections So we can model the first shots subtract from and from and then we ll need shots The only case when this doesn t work is if we break both sections before we equalize their durabilities it means that and we need to do only shots 
There are n heaps of stone The i th heap has h i stones You want to change the number of stones in the heap by performing the following process once You go through the heaps from the 3 rd heap to the n th heap in this order Let i be the number of the current heap You can choose a number d 0 le 3 cdot d le h i move d stones from the i th heap to the i 1 th heap and 2 cdot d stones from the i th heap to the i 2 th heap So after that h i is decreased by 3 cdot d h i 1 is increased by d and h i 2 is increased by 2 cdot d You can choose different or same d for different operations Some heaps may become empty but they still count as heaps What is the maximum number of stones in the smallest heap after the process ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n; cin >> n;\n\t\tvector<int> a(n), b(n);\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\t\tint l = 0, r = 1e9, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tfor (int i = 0; i < n; i++) b[i] = 0;\n\t\t\tint ok = 1;\n\t\t\tfor (int i = n - 1; i >= 2; i--) {\n\t\t\t\tif (a[i] + b[i] < mid) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint can = min(a[i] / 3, (a[i] + b[i] - mid) / 3);\n\t\t\t\tb[i - 2] += can * 2; b[i - 1] += can;\n\t\t\t}\n\t\t\tif (ok && a[0] + b[0] >= mid && a[1] + b[1] >= mid) ans = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1600,The answer can be binary searched That is we can find the biggest number such that we can make all heap having at least stones So our job here is to check if we can satisfy the said condition with a number Let s consider a problem we go from to pick a number move and stones from the th heap to the heap and th heap respectively In this problem we can greedily move the stones since is the minimum required stones if at some moment we have then we can not satisfy the condition for anymore Otherwise it is always the best to use as many stones as we can that is choose and move and stones to the and heaps respectively In the end if all the heap are not less than we can conclude that we can make all heaps having not less than stones with this process Going back to our original problem it seems like we can solve it by doing the process in the reversed order as discussed above But there is a catch The number of stones that can be moved the number of the stones in the original heap So if we call the original heap size and the current modified heap size then the number of stones that we should move is at each step 
Given the string s of decimal digits of length n A substring is a sequence of consecutive characters of a string The substring of this string is defined by a pair of indexes with its left and right ends So each pair of indexes l r where 1 le l le r le n corresponds to a substring of the string s We will define as v l r the numeric value of the corresponding substring leading zeros are allowed in it For example if n 7 s then v 1 3 100 v 2 3 0 and v 2 7 3004 You are given n s and an integer w 1 le w n You need to process m queries each of which is characterized by 3 numbers l i r i k i 1 le l i le r i le n 0 le k i le 8 The answer to the ith query is such a pair of substrings of length w that if we denote them as L 1 L 1 w 1 and L 2 L 2 w 1 then L 1 ne L 2 that is the substrings are different the remainder of dividing a number v L 1 L 1 w 1 cdot v l i r i v L 2 L 2 w 1 by 9 is equal to k i If there are many matching substring pairs then find a pair where L 1 is as small as possible If there are many matching pairs in this case then minimize L 2 Note that the answer may not exist ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 9;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\n\n\nstruct mint {\n    int x;\n    mint() : x(0) {}\n    mint(int x) : x((x % mod + mod) % mod) {}\n    mint operator -() const { return mint(0) - *this;}\n    mint operator ~() const { return mint(1) / *this;}\n    mint& operator +=(const mint& a) { if((x += a.x) >= mod) x -= mod; return *this;}\n    mint& operator -=(const mint& a) { if((x += mod - a.x) >= mod) x -= mod; return *this;}\n    mint& operator *=(const mint& a) { x = x * a.x % mod; return *this;}\n    mint& operator /=(const mint& a) { x = x * a.pow(mod-2).x % mod; return *this;}\n    mint operator +(const mint& a) const { return mint(*this) += a;}\n    mint operator -(const mint& a) const { return mint(*this) -= a;}\n    mint operator *(const mint& a) const { return mint(*this) *= a;}\n    mint operator /(const mint& a) const { return mint(*this) /= a;}\n    mint pow(int t) const { mint ret(1), pw = mint(*this); while(t){ if(t & 1) ret *= pw; pw *= pw; t /= 2;} return ret;}\n    bool operator <(const mint& a) const { return x < a.x;}\n    bool operator ==(const mint& a) const { return x == a.x;}\n    bool operator !=(const mint& a) const { return x != a.x;}\n    friend istream& operator >>(istream& is, mint& p) { return is >> p.x; }\n    friend ostream& operator <<(ostream& os, mint p){ return os << p.x; }\n};\n\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n\n    int w, q;\n    cin >> w >> q;\n\n    mint x = 0;\n\n    rep(i,0,w)\n    {\n        x = x * 10 + (s[i] - \'0\');\n    }\n\n    vvi g(9);\n\n    fr(i, 0, n - w)\n    {\n        g[x.x].pb(i);\n\n        if(i + w < n)\n        {\n            x = x * 10 + (s[i + w] - \'0\');\n            x -= mint(s[i] - \'0\') * mint(10).pow(w);\n        }\n    }\n\n\n    vector<mint> pre(n + 1);\n\n    rep(i,0,n)\n    {\n        pre[i + 1] = pre[i] * 10 + (s[i] - \'0\');\n    }\n    \n    \n    while(q--)\n    {\n        int l, r, k;\n        cin >> l >> r >> k;\n\n        mint z = pre[r] - pre[l - 1];\n\n        pii res = {n, n};\n\n        rep(i,0,9)\n        {\n            rep(j,0,9)\n            {\n                if(mint(i) * z + j == mint(k))\n                {\n                    //deb(i, j);\n\n                    if(i == j)\n                    {\n                        if(sz(g[i]) > 1)\n                        {\n                            mini(res, pii(g[i][0], g[i][1]));\n                        }\n                    }\n                    else\n                    {\n                        if(sz(g[i]) && sz(g[j]))\n                        {\n                            mini(res, pii(g[i][0], g[j][0]));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(res.fi == n)\n        {\n            cout << ""-1 -1"" << endl;\n        }\n        else\n        {\n            cout << res.fi + 1 << \' \' << res.se + 1 << endl;\n        }\n    }\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1900,Note that the remainder of dividing a number by is equal to the remainder of dividing its sum of digits by This is easy to check because the number of digits is representable as a polynomial and gives a remainder of when divided by for any Let s count an array of prefix sums of digits for the string Now knowing we can pre calculate for each remainder modulo all possible Also for each query we can easily find the remainder of dividing by using all the same prefix sums Let s iterate over the remainder of the number when dividing by Knowing it we can easily find the remainder of the number when divided by as modulo Now using each pair of remainers let s try to update the answer then the minimum index from the pre calculated array will act as and the next largest will act as if such exist then the minimum indexes from the pre calculated array will act as and This solution works for or for 
A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland The teacher of computer science Sonya s favorite subject invented a task for her Given an array a of length n and the number k the following happens Two numbers i and j are chosen equiprobable such that 1 leq i j leq n The numbers in the i and j positions are swapped Sonya s task is to find the probability that after all the operations are completed the a array will be She turned to you for help Help Sonya solve this problem It can be shown that the desired probability is either 0 or it can be represented as dfrac P Q where P and Q are coprime integers and Q not equiv 0 pmod 10 9 7 ,"['#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nusing modulo = modint<mod>;\nint N, K, A[109]; modulo ans[55][55], mat[55][55], tmp[55][55];\nint main() {\n\tcin >> N >> K;\n\tint zeros = 0, ones = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t\tif (A[i] == 0) ++zeros;\n\t\telse ++ones;\n\t}\n\tint inidiff = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] == 0 && i >= zeros) ++inidiff;\n\t}\n\tmodulo allposs = modulo(N * (N - 1) / 2);\n\tint md = min(zeros, ones);\n\tfor (int i = 0; i <= md; ++i) {\n\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\tif (i - j == 1) {\n\t\t\t\tmat[i][j] = modulo(i * i) * allposs.inv();\n\t\t\t}\n\t\t\tif (i - j == 0) {\n\t\t\t\tmat[i][j] = modulo(allposs - i * i - (zeros - i) * (ones - i)) * allposs.inv();\n\t\t\t}\n\t\t\tif (i - j == -1) {\n\t\t\t\tmat[i][j] = modulo((zeros - i) * (ones - i)) * allposs.inv();\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= md; ++i) {\n\t\tans[i][i] = modulo(1);\n\t}\n\twhile (K > 0) {\n\t\tif (K & 1) {\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\ttmp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\tfor (int k = 0; k <= md; ++k) {\n\t\t\t\t\t\ttmp[i][j] += ans[i][k] * mat[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\tans[i][j] = tmp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\ttmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\tfor (int k = 0; k <= md; ++k) {\n\t\t\t\t\ttmp[i][j] += mat[i][k] * mat[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\tmat[i][j] = tmp[i][j];\n\t\t\t}\n\t\t}\n\t\tK >>= 1;\n\t}\n\tcout << ans[inidiff][0].get() << endl;\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2300,How to solve this problem in Let s find the answer using dynamic programming Denote as the number of zeroes in array and as the number of rearrangements of array after operations and is equal to the number of zeroes on prefix of length Denote as the number of zeroes on prefix of length The initial state will be Notice that the answer will be The transitions are not so hard You must know the following values the number of ones on prefix of length the number of zeroes on prefix of length the number of ones NOT on prefix of length and the number of zeroes NOT on prefix of length For example you can find the number of pairs such that after we swap them the number of zeroes on prefix of length is increased by one the number of ones on prefix of length multiply by the number of zeroes NOT on prefix of length Also there are transitions when the number of zeroes on prefix of length remains the same and when it decreased by one you can find them by yourself To solve the original problem we must create the transition matrix and find the answer using with Also you must know how to find the to find the answer Complexity is 
You are given a string s consisting of lowercase Latin letters and q queries for this string Recall that the substring s l r of the string s is the string s l s l 1 dots s r For example the substrings of are but not and There are two types of queries 1 pos c 1 le pos le s c is lowercase Latin letter replace s pos with c set s pos c 2 l r 1 le l le r le s calculate the number of distinct characters in the substring s l r ,"['#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << ""="" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int MAX_N = (int)1e5 + 777;\nconst int A     = 26;\n\nint tree[2 * MAX_N], n;\n\nvoid solve() {\n\tstring str;\n\tcin >> str;\n\n\tn = len(str);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint code = str[i] - \'a\';\n\t\ttree[i + n] = 1 << code;\n\t}\n\n\tfor(int i = n - 1; i > 0; --i) {\n\t\ttree[i] = tree[2 * i] | tree[2 * i + 1];\n\t}\n\n\tint q;\n\tcin >> q;\n\n\twhile(q--) {\n\t\tint type;\n\t\tcin >> type;\n\n\t\tif(type == 1) {\n\t\t\tint pos;\n\t\t\tchar chr;\n\t\t\tcin >> pos >> chr;\n\t\t\t--pos;\n\t\t\tpos += n;\n\n\t\t\tint code = chr - \'a\';\n\t\t\ttree[pos] = 1 << code;\n\n\t\t\tfor(; pos > 0; pos /= 2)\n\t\t\t\ttree[pos / 2] = tree[pos] | tree[pos ^ 1];\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l, --r;\n\t\t\tl += n, r += n;\n\t\t\t++r;\n\n\t\t\tint msk = 0;\n\n\t\t\twhile(l < r) {\n\t\t\t\tif(l & 1)\n\t\t\t\t\tmsk |= tree[l++];\n\n\t\t\t\tif(r & 1)\n\t\t\t\t\tmsk |= tree[--r];\n\n\t\t\t\tl /= 2;\n\t\t\t\tr /= 2;\n\t\t\t}\n\n\t\t\tint answ = 0;\n\n\t\t\tfor(int j = 0; j < A; ++j) {\n\t\t\t\tansw += (msk >> j) & 1;\n\t\t\t}\n\n\t\t\tcout << answ << \'\\n\';\n\t\t}\n\t}\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1600,Let s store for each letter all positions in which it appears in some data structure We need such a data structure that can add remove and find the next element greater than or equal to our element fast enough Suddenly this data structure is again in C When we meet the first type query let s just modify two elements of corresponding sets one remove one add When we meet the second type query let s iterate over all letters If the current letter is in the segment then the first element greater than or equal to in the corresponding set should exist and be less than or equal to If it is so let s increase the answer by one After iterating over all letters just print the answer Time complexity when is the size of the alphabet 
You ve got an array consisting of integers Moreover there are queries each query can be described by three integers Query means that we should add to each element where Record means the binomial coefficient or the number of combinations from elements into groups of elements You need to fulfil consecutively all queries and then print the final array ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\nconst int N = 100010;\nconst int K = 100;\nconst int K10 = K + 10;\n\nint inv[K10];\nint ans[K10][N];\n\nvoid init() {\n  for (int k = 0; k <= K; k++) {\n    inv[k] = 1;\n    int step = 1 << 30;\n    while (step > 0) {\n      inv[k] = (long long)inv[k] * inv[k] % md;\n      if (step & (md - 2)) inv[k] = (long long)inv[k] * k % md;\n      step >>= 1;\n    }\n  }\n}\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) x -= md;\n}\n\nint nouse[N];\n\nint main() {\n  init();\n  int n, tt;\n  scanf(""%d %d"", &n, &tt);\n  for (int i = 1; i <= n; i++) scanf(""%d"", nouse + i);\n  for (int i = 0; i <= K; i++)\n    for (int j = 0; j <= n + 1; j++) ans[i][j] = 0;\n  while (tt--) {\n    int ll, rr, k;\n    scanf(""%d %d %d"", &ll, &rr, &k);\n    add(ans[K - k][ll], 1);\n    add(ans[K - k][rr + 1], md - 1);\n    int u = 1;\n    for (int i = K - k + 1; i <= K; i++) {\n      int t = i - (K - k);\n      u = (long long)u * (t + rr - ll) % md;\n      u = (long long)u * inv[t] % md;\n      add(ans[i][rr + 1], md - u);\n    }\n  }\n  for (int j = 0; j <= K; j++)\n    for (int i = 1; i <= n; i++) {\n      add(ans[j][i], ans[j][i - 1]);\n      if (j > 0) {\n        add(ans[j][i], ans[j - 1][i]);\n      }\n    }\n  for (int i = 1; i <= n; i++) {\n    add(nouse[i], ans[K][i]);\n    printf(""%d"", nouse[i] % md);\n    if (i < n) printf("" "");\n  }\n  printf(""\\n"");\n  return 0;\n}\n']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",2500,In this problem you had to find how to add binomial coefficients in array offline Let s see how problem changes due to increasing k from small to big values 1 All queries have K 0 Every time you add 1 on subsegment For solve this task you can add 1 at some array b in b L 1 then substract 1 from b R 1 and after doing all queries make array a as array of prefix sums of array b 2 All queries have K 1 Arithmetic progression 1 2 3 4 is added on subsegment For solve this task you can add 1 at some array c in c L 1 then substract 1 from c R 1 and after doing all queries make array b as array of prefix sums of array c Actually you added 1 1 1 on every subsegment at each query If you will substract R L 1 from c R 1 and make array a as array of prefix sums of array b then it will be an answer 1 1 1 became 1 2 3 R L 1 3 K is arbitrary Summaring previous results one can see that if we will do and after that do a i j a i j 1 a i 1 j making a i as array of prefix sums array a i 1 a 0 will be the answer What is C k 1 j r l k 1 j This number is need for each query affect only on segment L R and you can see why is it so in Pascal s Triangle If this explanation is not clear for you you can try to see other participants solutions for example Xellos s one 
The campus has m rooms numbered from 0 to m 1 Also the x mouse lives in the campus The x mouse is not just a mouse each second x mouse moves from room i to the room i cdot x mod m in fact it teleports from one room to another since it doesn t visit any intermediate room Starting position of the x mouse is unknown You are responsible to catch the x mouse in the campus so you are guessing about minimum possible number of traps one trap in one room you need to place You are sure that if the x mouse enters a trapped room it immediately gets caught And the only observation you made is text GCD x m 1 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define mp make_pair\n\nconst ll B = (ll)1e4;\nll mult(ll x, ll y, ll mod) {\n\tif (y == 0) return 0;\n\treturn (mult(x, y / B, mod) * B + x * (y % B)) % mod;\n}\nll bin_pow(ll x, ll p, ll mod) {\n\tif (p == 0) return 1 % mod;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1, mod), mod);\n\treturn bin_pow(mult(x, x, mod), p / 2, mod);\n}\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nll lcm(ll x, ll y) {\n\treturn x * (y / gcd(x, y));\n}\n\nconst int N = 50;\nint n;\nll P[N][2];\nll a[N][N][2];\n\nvector<pll> factorize(ll m) {\n\tvector<pll> res;\n\tfor (ll y = 2; y * y <= m; y++) {\n\t\tif (m % y) continue;\n\t\tres.push_back(mp(y, 0LL));\n\t\twhile(m % y == 0) {\n\t\t\tres.back().second++;\n\t\t\tm /= y;\n\t\t}\n\t\tn++;\n\t}\n\tif (m > 1) {\n\t\tres.push_back(mp(m, 1LL));\n\t}\n\treturn res;\n}\n\nll ans;\nvoid brute(int pos, ll PP, ll Q) {\n//\teprintf(""brute %d %lld %lld\\n"", pos, PP, Q);\n\tif (pos == n) {\n\t\tans += PP / Q;\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= P[pos][1]; i++) {\n\t\tbrute(pos + 1, PP * a[pos][i][0], lcm(Q, a[pos][i][1]));\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tll m, x;\n\tcin >> m >> x;\n\n\tvector<pll> q = factorize(m);\n\tn = (int)q.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP[i][0] = q[i].first;\n\t\tP[i][1] = q[i].second;\n\t}\n\n//\teprintf(""%d\\n"", n);\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(""%lld %lld\\n"", P[i][0], P[i][1]);\n//\treturn 0;\n\n\tans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tll mod = 1;\n\t\tq = factorize(P[i][0] - 1);\n\t\tfor (int pw = 0; pw <= P[i][1]; pw++) {\n\t\t\tif (pw == 0) {\n\t\t\t\ta[i][pw][0] = a[i][pw][1] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmod *= P[i][0];\n\t\t\tll cur = mod - mod / P[i][0];\n\t\t\tfor (int j = 0; j < (int)q.size(); j++) {\n\t\t\t\tfor (int k = 0; k < q[j].second; k++) {\n\t\t\t\t\tll ncur = cur / q[j].first;\n\t\t\t\t\tif (bin_pow(x, ncur, mod) != 1) break;\n\t\t\t\t\tcur = ncur;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < pw - 1; k++) {\n\t\t\t\tll ncur = cur / P[i][0];\n\t\t\t\tif (bin_pow(x, ncur, mod) != 1) break;\n\t\t\t\tcur = ncur;\n\t\t\t}\n\t\t\ta[i][pw][0] = mod - mod / P[i][0];\n\t\t\ta[i][pw][1] = cur;\n\t\t}\n\t}\n\tbrute(0, 1, 1);\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2600,Some notes At first there is since lets define as That means that for each there is exactly one that So if we look at this problem as the graph then it consists of cycles consider loops as cycles of length one So we need to know number of cycles in this graph At second since and and So all can be divided in groups by its And we can calculate number of cylces in each group independently Let fix some equal to All numbers such that can be represented as and Number of such equals to Moreover Here we can shift from and to and In result we need for each calculate number of cycles created by from numbers that and Lets set Next step is to find minimal such that let s name it order of or Then for each if then and so each cycle will have length equal to and number of cycles will be equal to Last step is calculate for each There is a fact that so can try to iterate over all divisors of and check by binary exponentiation It seems as but it s faster and author s version work around 2 seconds It doesn t pass but somebody can write better But we ll speed it up Let So we can independently for each find its minimal power such that We can just iterate over all and since Some words about finding its factorization differs from factorization of just by lowering degrees of primes and adding factorizations of some But we can manually find factorization of with memorization or even without it since So our steps are next factorize recursively iterate over all divisors of find and and add to the answer Result complexity is And the last note is how to multiply modulo You can use binary multiplification which will give you extra what is not critically in this task in C of course Or you can use multiplification from hashes which will work with 64 bit double since it s only 
Berland is going through tough times the dirt price has dropped and that is a blow to the country s economy Everybody knows that Berland is the top world dirt exporter The President of Berland was forced to leave only of the currently existing subway stations The subway stations are located on a straight line one after another the trains consecutively visit the stations as they move You can assume that the stations are on the axis the th station is at point with coordinate In such case the distance between stations and is calculated by a simple formula Currently the Ministry of Transport is choosing which stations to close and which ones to leave Obviously the residents of the capital won t be too enthusiastic about the innovation so it was decided to show the best side to the people The Ministry of Transport wants to choose such stations that minimize the average commute time in the subway Assuming that the train speed is constant it is a fixed value the average commute time in the subway is calculated as the sum of pairwise distances between stations divided by the number of pairs that is and divided by the speed of the train Help the Minister of Transport to solve this difficult problem Write a program that given the location of the stations selects such stations that the average commute time in the subway is minimized ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname """"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define sz size()\nconst int N = 400500;\nstruct node {\n\tll x, id;\n}a[N];\nbool cmp (node a, node b) {\n\treturn a.x < b.x;\n}\nll n, k;\n\nll d[N];\n\nvector <int> ans;\n\nint main ()\n{\t\n\t#ifndef ONLINE_JUDGE\n\tfreopen (fname""in"",""r"",stdin);\n\tfreopen (fname""out"",""w"",stdout);\n\t#endif\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tcin >> a[i].x;\n\t\ta[i].id = i;\n\t}\n\n\tcin >> k;\n\n\tsort(a + 1, a + 1 + n, &cmp);\n\n\tll mn = 0, id = k, sum = 0, now = 0;\n\n\tfor (int i = 1; i <= k; i ++ ) {\n\t\tmn += a[i].x * 1ll * (i - 1) - sum;\n\t\tsum += a[i].x;\n\t}\n\n\tnow = mn;\n\n\tfor (int i = k + 1; i <= n; i ++ ) {\n\t\tsum -= a[i - k].x;\n\t\tnow -= (sum - a[i - k].x * (k - 1));\n\t\tnow += (a[i].x * (k - 1) - sum);\n\t\tsum += a[i].x;\n\t\tif (mn > now) {\n\t\t\tmn = now;\n\t\t\tid = i;\n\t\t}\n\t}\n\n\tfor (int i = id; i >= id - k + 1; i -- ) ans.pb(a[i].id);\n\n\tsort(ans.begin(), ans.end());\n\n\tfor (int i = 0; i < ans.size(); i ++ ) cout << ans[i] << "" "";\n\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2000,It is easy to see that you need to minimize the sum of pairwise distances between stations The main idea to do it is to sort them and the required stations will form a continuous segment It is easy to prove by contradiction Huge constraints do not allow to use straight forward method to find required segment Let s call Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX where means Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Actually we need Unable to parse markup type CF TEX Unable to parse markup type CF TEX To recalculate Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX 
Master Andrey loves trees dagger very much so he has a tree consisting of n vertices But it s not that simple Master Timofey decided to steal one vertex from the tree If Timofey stole vertex v from the tree then vertex v and all edges with one end at vertex v are removed from the tree while the numbers of other vertices remain unchanged To prevent Andrey from getting upset Timofey decided to make the resulting graph a tree again To do this he can add edges between any vertices a and b but when adding such an edge he must pay a b coins to the Master s Assistance Center Note that the resulting tree vertex v Timofey has not yet decided which vertex v he will remove from the tree so he wants to know for each vertex 1 leq v leq n the minimum number of coins needed to be spent to make the graph a tree again after removing vertex v as well as which edges need to be added dagger A tree is an undirected connected graph without cycles ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,ans,sz[N],f[N];\nint gf(int x){while(x!=f[x])x=f[f[f[f[x]]]];return x;}\nvector<int>lk[N];\nint stk[N],tp;\nstruct dat{\n    int l,r;\n    dat operator+(const dat &z)\n    const{return{min(l,z.l),max(r,z.r)};}\n}bc[N],d[N];\nbitset<N>vs;\nvoid mg(int x,int y){\n    x=gf(x),y=gf(y);\n    if(x!=y){\n        if(sz[x]<sz[y])swap(x,y);\n        sz[f[y]=x]+=sz[y];\n        stk[++tp]=y,bc[tp]=d[x],d[x]=d[x]+d[y];\n    }\n}\nvoid rec(){\n    int x=stk[tp];\n    d[f[x]]=bc[tp--];\n    sz[f[x]]-=sz[x],f[x]=x;\n}\nstruct Eg{int x,y;}g[N];\nint gt;\nvoid sol(int l,int r){\n    if(l==r){\n        int i,y,k,lt=tp;\n        gt=0;\n        for(int x:lk[l]){\n            y=gf(x);\n            // printf(""_l:%d y:%d l:%d r:%d\\n"",l,y,d[y].l,d[y].r);\n            if(d[y].l>1&&d[y].l-1!=l){\n                k=gf(d[y].l-1);\n                g[++gt]={d[y].l-1,d[y].l};\n                mg(k,y);\n            }y=gf(x);\n            if(d[y].r<n&&d[y].r+1!=l){\n                k=gf(d[y].r+1);\n                g[++gt]={d[y].r,d[y].r+1};\n                mg(k,y);\n            }\n        }\n        for(int x:lk[l]){\n            y=gf(x);\n            if(d[y].r==l-1&&l<n){\n                g[++gt]={l-1,l+1};\n                break;\n            }\n        }\n        while(tp>lt)rec();\n        for(i=1,k=0;i<=gt;++i)k+=g[i].y-g[i].x;\n        printf(""%d %d\\n"",k,gt);\n        for(i=1;i<=gt;++i)printf(""%d %d\\n"",g[i].x,g[i].y);\n        puts("""");\n    }else{\n        int md=l+r>>1,lt=tp,i,x;\n        for(x=r;x>md;--x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(l,md);\n        for(x=r;x>md;--x)vs[x]=0;\n        while(tp>lt)rec();\n        for(x=l;x<=md;++x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(md+1,r);\n        for(x=l;x<=md;++x)vs[x]=0;\n        while(tp>lt)rec();\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<n;++i){\n            cin>>x>>y;\n            lk[x].push_back(y);\n            lk[y].push_back(x);\n        }\n        for(x=1;x<=n;++x)\n            sz[f[x]=x]=1,d[x]={x,x};\n        sol(1,n);\n        for(x=1;x<=n;++x)lk[x].clear();\n    }\n    return 0;\n}']","[1, 0, 1, 0, 1, 0, 1, 1, 0, 0]",2800,TutorialLet s fix some vertex for which the answer is being calculated Suppose the degree of the vertex in the tree is then it s clear that it s necessary to add edges Consider the components that appear after removing Then the goal is to use the new edges to unite all the components into one using the minimum total cost This is the same as finding the minimum spanning tree in a graph where the vertices are the components that resulted from removing and for every an edge with a weight of is drawn between the components containing and Let s simulate Kruskal s algorithm for this graph Consider all the single weight edges in this graph It s clear that using the single weight edges the vertices with numbers will definitely end up in one component and the vertices with numbers will also end up in one component To unite these two components it would be optimal to add an edge It turns out that it s sufficient to consider only all the single weight edges and the edge Let s limit the number of single weight edges to For this in each component calculate and the minimum and maximum in the component respectively Claim among the single weight edges it s sufficient to consider edges of the form ProofFirst understand when it s necessary to add the edge Note that if there s at least one component such that then the edge won t be needed otherwise it will be This is quite easy to show by simulating Kruskal s algorithm Let We ll show that using edges all components will unite Go through the vertices from to and maintain the invariant that all vertices from to are in one component At this holds When is the minimum in some component then the edge will be added and since is in one component with will now also be When is not the minimum in some component then the minimum in the component will be in one component with the invariant holds meaning will also be in one component with Thus it turns out that all will be in one component Now consider an arbitrary Separately consider the prefix of vertices and the suffix Then similarly to it can be shown that for the prefix of vertices using edges of the form you can unite Similarly for the suffix of vertices using edges of the form you can unite Now if the edge is necessary then add it to the answer Otherwise there s at least one component such that meaning the prefix of vertices and the suffix will unite into one component Finding for each component is straightforward what remains is to determine which components are connected by the edges This can be done with binary search through the Euler tour of the tree After that Kruskal s algorithm can be initiated to calculate the answer Let s estimate the time complexity For a specific vertex the time complexity will be so the total time complexity is Depending on the implementation of the last step the problem can be solved in where is the inverse Ackermann function relative to 
You are creating a level for a video game The level consists of n rooms placed in a circle The rooms are numbered 1 through n Each room contains exactly one exit completing the j th room allows you to go the j 1 th room and completing the n th room allows you to go the 1 st room You are given the description of the multiset of n chests the i th chest has treasure value c i Each chest can be of one of two types regular chest when a player enters a room with this chest he grabs the treasure and proceeds to the next room mimic chest when a player enters a room with this chest the chest eats him alive and he loses The player starts in a random room with each room having an equal probability of being chosen The players earnings is equal to the total value of treasure chests he d collected before he lost You are allowed to choose the order the chests go into the rooms For each k from 1 to n place the chests into the rooms in such a way that each room contains one chest k chests are mimics the expected value of players earnings is possible Please note that for each k the placement is chosen independently It can be shown that it is in the form of frac P Q where P and Q are non negative integers and Q ne 0 Report the values of P cdot Q 1 pmod 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N; cin >> N;\n    vi C(N); F0R(i, N) cin >> C[i];\n\n    mi in = inv(mi(N));\n\n    sort(all(C)); reverse(all(C));\n    mi pre[N+1];\n    pre[0] = 0;\n    F0R(i, N) pre[i+1] = pre[i] + C[i];\n\n    FOR(K, 1, N+1) {\n        mi ans = 0;\n        for (int i = 0; i < N; i += K) {\n            ans += (i / K) * (pre[min(i+K, N)] - pre[i]);\n        }\n        ans *= in;\n        cout << ans << "" "";\n    }\n    cout << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2600,TutorialAt first let s say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by So we can trasition to minimizing the sum Let s learn how to solve the task for some fixed Fix some arrangement and rotate the rooms so that the last room contains a mimic So now you have regular chests then a single mimic regular chests single mimic regular chests single mimic All and Take a look at some of these intervals of length The last chest in the interval is taken from starting positions the second to last is taken times and so on Now let s find the optimal way to choose Fix some values of Take a look at the smallest of these values and the largest of them Let the values be and If they differ by at least then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one ProofConsider two sequences of coefficients for both intervals and However if you remove one chest then they will be equal to and If you only consider the difference between the numbers of both sequences then you can see that only coefficient got removed and coefficient was added So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to becomes assigned to thus decreasing the total value Now we have all set now The only thing left is to assign chests optimally Write down the union of all the coefficient sequences from all the intervals and sort them in the non decreasing order It s easy to show that the chests should be sorted in the non increasing order really classical thing you can try proving that by showing that any other arrangement can easily be improved once again That allows us to write a solution in Sort all the chests in the beginning after that for some multiply the value of the th chest by and sum up the results Finally let s speed this up with prefix sums Notice that the first values are multiplied by the second values by and so on If is not divisible by then the last block just has length smaller than Thus we can calculate the answer for some in And that s equal to Overall complexity 
You are given an undirected graph with weighted edges The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path if some edge is traversed more than once then it is included in bitwise xor the same number of times You have to find the minimum length of path between vertex and vertex ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=100005;\nvector<pair<int,ll> > e[MAXN];\nvector<ll> base;\nvoid add(ll x)\n{\n    for(int i=0;i<(int)base.size();i++)\n        x=min(x,x^base[i]);\n    if(x)base.push_back(x);\n}\nint vis[MAXN];\nll t[MAXN];\nvoid dfs(int u,ll now)\n{\n    vis[u]=1,t[u]=now;\n    for(int i=0;i<(int)e[u].size();i++)\n    {\n        int v=e[u][i].first;\n        if(vis[v])add(now^e[u][i].second^t[v]);\n        else dfs(v,now^e[u][i].second);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(""%d%d"",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;\n        ll w;\n        scanf(""%d%d%lld"",&x,&y,&w);\n        e[x].push_back(make_pair(y,w));\n        e[y].push_back(make_pair(x,w));\n    }\n    dfs(1,0);\n    for(int i=0;i<(int)base.size();i++)\n        t[n]=min(t[n],t[n]^base[i]);\n    return 0*printf(""%lld\\n"",t[n]);\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 1]",2300,Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination 
Homer has two friends Alice and Bob Both of them are string fans One day Alice and Bob decide to play a game on a string s s 1 s 2 dots s n of length n consisting of lowercase English letters They move in turns alternatively and In a move a player choose an index i 1 leq i leq n that has not been chosen before and change s i to any other lowercase English letter c that c neq s i When all indices have been chosen the game ends The goal of Alice is to make the final string lexicographically as small as possible while the goal of Bob is to make the final string lexicographically as large as possible Both of them are game experts so they always play games optimally Homer is not a game expert so he wonders what the final string will be A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,""Running on Line %d in Function %s\\n"",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch==\'-\') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nvoid print(vector<int> x){for(int i=0;i<(int)x.size();i++) printf(""%d%c"",x[i],"" \\n""[i==(int)x.size()-1]);}\nvoid work()\n{\n\tstring s; cin>>s;\n\tfor(int i=0;i<(int)s.length();i++)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tif(s[i]==\'z\') s[i]=\'y\';\n\t\t\telse s[i]=\'z\';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(s[i]==\'a\') s[i]=\'b\';\n\t\t\telse s[i]=\'a\';\n\t\t}\n\t}\n\tcout<<s<<endl;\n}\nsigned main()\n{\n\tint T=read(); while(T--) work();\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800,After some observations we can see that the players should always choose the most significant letter to change because it coordinates the lexicographical order of the final string most Therefore Alice will choose all odd indices while Bob will choose all even indices and then Alice will change all letters she choose to the smallest possible letters while Bob will change all letters he choose to the largest possible letters That is Alice will change letters to a if the original letter is not a and to b otherwise Bob will change letters to z if the original letter is not z and to y otherwise The time complexity is O n 
You are given two integers x and y A sequence a of length n is called if a 1 x and for all 1 i le n the value of a i is either a i 1 y or a i 1 bmod y Here x bmod y denotes the remainder from dividing x by y Determine if there exists a modular sequence of length n with the sum of its elements equal to S and if it exists find any such sequence ,"['#include<bits/stdc++.h>\n\nint main() {\n        std::cin.tie(nullptr)->sync_with_stdio(false);\n\n        int t;\n        std::cin >> t;\n        while (t--) {\n                int n, x, y, s;\n                std::cin >> n >> x >> y >> s;\n                long long st = x / y;\n                if (s < 1ll * (x % y) * n) {\n                        std::cout << ""NO\\n"";\n                        continue;\n                }\n                s -= (x % y) * n;\n                std::vector<int> dp(s + 1, 1e9);\n                std::vector<int> par(s + 1, -1);\n                dp[0] = 0;\n                for (int i = 0; i <= s; ++i) {\n                        for (int j = 1; i + j * (j - 1) / 2 * y <= s; ++j) {\n                                int k = i + j * (j - 1) / 2 * y;\n                                if (dp[k] > dp[i] + j) {\n                                        dp[k] = dp[i] + j;\n                                        par[k] = j;\n                                }\n                        }\n                }\n                bool ok = false;\n                for (int d = 1; (2 * st + d - 1) * d / 2 * y <= s; ++d) {\n                        if (d + dp[s - (2 * st + d - 1) * d / 2 * y] <= n) {\n                                std::cout << ""YES\\n"";\n                                std::vector<int> ans(n, x % y);\n                                int ptr = 0;\n                                for (int i = 0; i < d; ++i, ++ptr) ans[ptr] += (st + i) * y;\n                                int u = s - (2 * st + d - 1) * d / 2 * y;\n                                while (u != 0) {\n                                        int k = par[u];\n                                        u -= k * (k - 1) / 2 * y;\n                                        for (int i = 0; i < k; ++i, ++ptr) ans[ptr] += i * y;\n                                }\n                                for (auto i : ans) std::cout << i << \' \';\n                                std::cout << \'\\n\';\n                                ok = true;\n                                break;\n                        }\n                }\n                if (!ok) std::cout << ""NO\\n"";\n        }\n}']","[1, 1, 0, 1, 0, 1, 1, 0, 0, 1]",2300,SolutionLet s see what the answer will look like first there will be a prefix of the form and then there will be some number of blocks of the form We can subtract the number from all the elements of the sequence and then divide all the elements by all the elements will be divisible by since they initially had a remainder of Let Then our sequence will start with and then there will be blocks of the form Let s calculate these values the minimum length of a sequence of blocks of the form with a sum of This value can be calculated for all numbers from to using dynamic programming If we have processed all values from to then for we have calculated the minimum length and we can update the value of for a total of values not exceeding In this same we can store through which values we were recalculated for the restoration of the answer Now we can iterate over the length of the first block of the form Then we know the sum of the remaining blocks and using the precalculated we can determine whether the desired sequence can be formed or not 
The warehouse in your shop has shoe pairs Each pair is characterized by two integers its price and its size We know that on this very day all numbers are different that is there is no more than one pair of each size The shop has customers who came at the same time The customer number has money and the size of his feet equals The customer number can buy the pair number if and also if or that is it is necessary that he has enough money to pay for the shoes It is also necessary that the size of his feet equals to or is less by than the size of the shoes he chooses Your task is to sell some customers pairs of shoes a pair per person so as to maximize the sum of the sold pairs that is the profit It is guaranteed that each customer buys no more than one pair and each pair will be bought by no more than one customer ,"['#pragma comment(linker, ""/stack:64000000"")\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <utility>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <memory.h>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <deque>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <map>\n#include <deque>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define for1(i, n) for (int i = 1; i <= int(n); i++)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb push_back\n#define pii pair <int, int>\n#define vi vector <int>\n#define mp make_pair\n\ntemplate <typename X> inline X abs (const X &a) {return a < 0? -a: a;}\ntemplate <typename X> inline X sqr (const X &a) {return a * a;}\n\nconst int INF = INT_MAX / 2;\nconst ll INF64 = LLONG_MAX / 2LL;\nconst ld EPS = 1E-9, PI = 3.1415926535897932384626433832795;\n\nconst int N = 2 * 100 * 1000 + 13;\n\nstruct obj\n{\n    int cost, size, num;\n    obj(){}\n    obj (int cost, int size, int num): cost (cost), size (size), num (num) {}\n};\n\ninline bool cmpSize (const obj &a, const obj &b)\n{\n    return a.size < b.size;\n}\n\ninline bool cmpCost(const obj &a, const obj &b)\n{\n    return a.cost > b.cost;\n}\n\nvector <int> g[N];\nint mt[N];\nbool used[N];\n\nbool khun (int v)\n{\n    if (used[v])\n        return false;\n\n    used[v] = true;\n    forn (i, sz (g[v]))\n    {\n        int to = g[v][i];\n        if (mt[to] == -1 || khun (mt[to]))\n        {\n            mt[to] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n\n    int n, m;\n    obj a[N], b[N];\n\n    ll cost[N];\n    \n    cin >> n;\n    forn (i, n)\n    {\n        scanf (""%d%d"", &a[i].cost, &a[i].size);\n        a[i].num = i;\n        cost[i] = a[i].cost;\n    }\n\n    sort (a, a + n, cmpSize);\n\n    cin >> m;\n    forn (i, m)\n    {\n        scanf (""%d%d"", &b[i].cost, &b[i].size);\n        b[i].num = i;\n    }   \n\n    forn (i, m)\n    {\n        int idx = int (lower_bound (a, a + n, obj (-1, b[i].size, -1), cmpSize) - a);\n        \n        while (a[idx].size == b[i].size || a[idx].size == b[i].size + 1)\n        {\n            if (a[idx].cost <= b[i].cost)\n                g[a[idx].num].pb (b[i].num);\n\n            idx++;\n        }\n    }\n\n    sort (a, a + n, cmpCost);\n\n    memset (mt, -1, sizeof mt);\n\n    forn (i, n)\n    {\n        memset (used, false, sizeof used);\n        khun (a[i].num);\n    }\n\n    ll ans = 0LL;\n    vector <pii> res;\n\n    forn (i, m)\n    {\n        if (mt[i] == -1)\n            continue;\n\n        ans += cost[mt[i]];\n        res.pb (mp (i, mt[i]));\n    }\n\n    cout << ans << endl;\n    cout << sz (res) << endl;\n\n    forn (i, sz (res))\n        printf (""%d %d\\n"", res[i].first + 1, res[i].second + 1);\n\n    return 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 1, 0]",2500,Let s sort the people by decreasing of shoes size Observe that when considering the th man we are interested in no more than 2 pairs of shoes with size and It allows solving with dynamics The state will be the number of first unconsidered man is pair of shoes with size available is pair of shoes with size 1 available You have 3 options leave the th man without shoes or sell him a pair of shoes of one of suitable size if available 
As you may know MemSQL has American offices in both San Francisco and Seattle Being a manager in the company you travel a lot between the two cities always by plane You prefer flying from Seattle to San Francisco than in the other direction because it s warmer in San Francisco You are so busy that you don t remember the number of flights you have made in either direction However for each of the last days you know whether you were in San Francisco office or in Seattle office You always fly at nights so you never were at both offices on the same day Given this information determine if you flew more times from Seattle to San Francisco during the last days or not ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\n#include <utility>\n#include <stack>\n#include <cstring>\n#include <bitset>\n#include <deque>\n#include <string>\n#include <list>\n#include <cstdlib>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 100000 + 100;\ntypedef long long ll;\ntypedef long double ld;\n\nint main()\n{\n\tstring s;\n\tint n;\n\twhile (cin >> n >> s)\n\t{\n\tint sf = 0, fs = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (s[i] == \'S\' && s[i - 1] == \'F\')\n\t\t\t{\n\t\t\t\tfs++;\n\t\t\t}\n\t\t\telse if (s[i] == \'F\' && s[i-1] == \'S\')\n\t\t\t{\n\t\t\t\tsf++;\n\t\t\t}\n\t\t}\n\t\tif (sf > fs)\n\t\t{\n\t\t\tcout << ""YES\\n"";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << ""NO\\n"";\n\t\t}\n\t}\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,The answer is if the first character of the given string is and the last character is otherwise it s 
Baby Badawy s first words were AND 0 SUM BIG so he decided to solve the following problem Given two integers n and k count the number of arrays of length n such that all its elements are integers between 0 and 2 k 1 inclusive the bitwise AND of all its elements is 0 the sum of its elements is as large as possible Since the answer can be very large print its remainder when divided by 10 9 7 ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int mod = 1e9 + 7;\n        int n, k;\n        cin >> n >> k;\n        int z = 1;\n        for (int i = 0; i < k; i++) {\n            z = (z * (long long)n) % mod;\n        }\n        cout << z << '\\n';\n    }\n}""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200,Let s start with an array where every single bit in every single element is It clearly doesn t have bitwise and equal to so for each bit we need to turn it off make it in at least one of the elements However we can t turn it off in more than one element since the sum would then decrease for no reason So for every bit we should choose exactly one element and turn it off there Since there are bits and elements the answer is just Unable to parse markup type CF MATHJAX Code link https pastebin com 0D8yL5WW 
You ve been in love with Coronavirus chan for a long time but you didn t know where she lived until now And just now you found out that she lives in a faraway place called Naha You immediately decided to take a vacation and visit Coronavirus chan Your vacation lasts exactly x days and that s the exact number of days you will spend visiting your friend You will spend exactly x consecutive successive days visiting Coronavirus chan They use a very unusual calendar in Naha there are n months in a year i th month lasts exactly d i days Days in the i th month are numbered from 1 to d i There are no leap years in Naha The mood of Coronavirus chan and accordingly her desire to hug you depends on the number of the day in a month In particular you get j hugs if you visit Coronavirus chan on the j th day of the month You know about this feature of your friend and want to plan your trip to get as many hugs as possible and then maybe you can win the heart of Coronavirus chan Please note that your trip should begin and end in the same year ,"['#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int MN = 200005;\n\nint N;\nLL x, a[MN * 2], s[MN * 2], s2[MN * 2], ans;\n\nint main() {\n\tscanf(""%d%lld"", &N, &x);\n\tfor (int i = 1; i <= N; ++i) scanf(""%lld"", &a[i]), a[N + i] = a[i];\n\tfor (int i = 1; i <= 2 * N; ++i)\n\t\ts[i] = s[i - 1] + a[i],\n\t\ts2[i] = s2[i - 1] + a[i] * (a[i] + 1) / 2;\n\tint j = 0;\n\tfor (int i = 1; i <= 2 * N; ++i) {\n\t\twhile (s[i] - s[j] > x) ++j;\n\t\tif (i > N) {\n//\t\t\tprintf(""(i. j) = (%d, %d)\\n"", i, j);\n\t\t\tLL val = s2[i] - s2[j];\n\t\t\tLL left = x - (s[i] - s[j]);\n\t\t\tval += (a[j] - left + 1 + a[j]) * left / 2;\n\t\t\tans = std::max(ans, val);\n\t\t}\n\t}\n\tprintf(""%lld\\n"", ans);\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 1, 0, 1, 0, 0]",1900,We will double the array of days and solve the problem when the day vacation starts and the day it ends is always in the same year Then is an array of number of days in each of the months Consider array Our task is to find a subsection of length with the maximum sum in it Further we will call this segment optimal We will find such an optimal segment that its end coincides with the end of some month Pretend that s not the case Consider the rightmost optimal segment Let its last element be then the next one is otherwise coincides with Note that if we move this segment to the right the sum must be reduced which means that the first element of the segment Then its left neighbor It means that you can move the segment by to the left so that the sum increases So the chosen segment is not optimal Contradiction see picture Solution now we just need to go through all the possible ends of the segment which are only Let s build two arrays of prefix sums is responsible for the number of days before the th month and is responsible for the sum of numbers of all days before the th month For each of the n ends let s make a binsearch to find which month contains its left border days less than the right one You can use array to check whether the left border lies to the left in the block to the right and use array to restore the answer The overall compexity is 
The University where A and B study is a set of rooms connected by corridors Overall the University has rooms connected by corridors so that you can get from any room to any other one by moving along the corridors The rooms are numbered from to Every day and B write contests in some rooms of their university and after each contest they gather together in the same room and discuss problems A and B want the distance from the rooms where problems are discussed to the rooms where contests are written to be equal The distance between two rooms is the number of edges on the shortest path between them As they write contests in new rooms every day they asked you to help them find the number of possible rooms to discuss problems for each of the following days ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint n, m, niv[N], p[19][N], nrnod[N];\nvector<int> v[N];\n\nvoid df(int nod, int pp) {\n\n    nrnod[nod] = 1;\n\n    for(vector<int>::iterator it = v[nod].begin(); it != v[nod].end(); ++it) if(*it != pp) {\n        niv[*it] = niv[nod] + 1;\n        p[0][*it] = nod;\n        df(*it, nod);\n\n        nrnod[nod] += nrnod[*it];\n    }\n}\n\nint lca(int a, int b) {\n    if(niv[a] > niv[b])\n        swap(a, b);\n\n    int k;\n    for(k = 18; k >= 0; --k)\n        if(niv[b] - (1<<k) >= niv[a])\n            b = p[k][b];\n\n    for(k = 18; k >= 0; --k)\n    if(p[k][a] != p[k][b]) {\n        a = p[k][a];\n        b = p[k][b];\n    }\n\n    if(a == b)\n        return a;\n    return p[0][a];\n}\n\nint par(int nr, int nod) {\n    int k;\n\n    for(k = 18; k >= 0; --k)\n    if((1<<k) <= nr) {\n        nr -= (1<<k);\n        nod = p[k][nod];\n    }\n\n    return nod;\n}\n\nint main() {\n    int i, j;\n    //freopen(""ttt"", ""r"", stdin);\n\n    cin >> n;\n    for(i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    df(1, 0);\n    for(i = 1; i < 19; ++i)\n        for(j = 1; j <= n; ++j)\n            p[i][j] = p[i - 1][p[i - 1][j]];\n\n    cin >> m;\n\n    for(i = 1; i <= m; ++i) {\n        int lc, a, b;\n        cin >> a >> b;\n\n        if(a == b) {\n            cout << n << ""\\n"";\n            continue;\n        }\n\n        lc = lca(a, b);\n\n        int sum = niv[a] + niv[b] - 2 * niv[lc];\n\n        if(sum % 2 == 1) {\n            cout << ""0\\n"";\n            continue;\n        }\n        else {\n            sum /= 2;\n            if(niv[a] > niv[b])\n                swap(a, b);\n\n\n            int nod = par(sum, b);\n\n            int nrel = nrnod[nod];\n\n            if(nod == lc) {\n                nrel = n;\n                nrel -= nrnod[par(sum - 1, a)];\n            }\n            nrel -= nrnod[par(sum - 1, b)];\n\n            cout << nrel << ""\\n"";\n        }\n    }\n\n    return 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 1, 0, 0]",2100,In this problem we have to answer to the following queries on tree for given pairs of vertices your program should output number of eqidistand vertices from them Let s denote dist a b as distance between vertices a and b LCA a b as lowest common ancestor of vertices a and b depth a as distance between root of the tree and vertex a size a as size of subtree of vertex a On each picture green nodes are equidistant nodes blue nodes nodes from query Preprocessing Read edges of tree and build data structure for LCA it is more convenient to use binary raise becase we will use it further for other purposes Complexity O NlogN Queries We have to consider several cases for each query 1 a b In that case answer is n 2 dist a b is odd Then answer is 0 3 dist a l dist b l where l LCA a b Find children of l which are ancestors of a and b let s denote them as aa and bb Answer will be n size aa size bb 4 All other cases Assume that depth a depth b Then using binary raise find dist a b 2 th ancestor of a let s denote it as p1 dist a b 2 1 th ancestor of vertex a denote it as p2 Answer will be size p1 size p2 Complexity O logN for each query O MlogN for all queries 
A binary string is a string where every character is texttt 0 or texttt 1 Call a binary string if it has an equal number of texttt 0 s and texttt 1 s Initially you have an infinite binary string t whose characters are all texttt 0 s You are given a sequence a of n updates where a i indicates that the character at index a i will be flipped texttt 0 leftrightarrow texttt 1 You need to keep and modify after each update a set S of ranges such that for each range l r the substring t l dots t r is a decent binary string and for all indices i such that t i texttt 1 there exists l r in S such that l leq i leq r You only need to output the ranges that are added to or removed from S after each update You can only add or remove ranges from S at most mathbf 10 6 times More formally let S i be the set of ranges after the i th update where S 0 varnothing the empty set Define X i to be the set of ranges removed after update i and Y i to be the set of ranges added after update i Then for 1 leq i leq n S i S i 1 setminus X i cup Y i The following should hold for all 1 leq i leq n forall a b in S i a neq b rightarrow a cap b varnothing X i subseteq S i 1 S i 1 setminus X i cap Y i varnothing displaystyle sum i 1 n X i Y i leq 10 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc getchar()\n// #define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=1e6+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint n,m=N-1;\n#define P pair<int,int>\nset<P>mp;\nV input(){\n\tn = getint();\n}\nset<int>one,zero,alen;\nV init(){\n\tFOR(i,1,m)zero.insert(i);\n\tFOR(i,1,m)alen.insert(i);\n}\nstruct node{ // 维护历史最小值\n\tint minn, sum;\n\tnode operator+(const node&o)const{\n\t\tnode out;\n\t\tout.minn = min(minn,sum+o.minn);\n\t\tout.sum = sum+o.sum;\n\t\treturn out;\n\t}\n}t1[N<<2],t2[N<<2];\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,m\n#define lson lc,L,mid\n#define rson rc,mid+1,R\nV build(int p,int L,int R){\n\tt1[p].minn = t2[p].minn = -(R-L+1);\n\tt1[p].sum = t2[p].sum = -(R-L+1);\n\tif(L==R)return;\n\tint mid=L+R>>1;\n\tbuild(lson),build(rson);\n}\nV upd(int p){\n\tt1[p]=t1[lc]+t1[rc];\n\tt2[p]=t2[rc]+t2[lc];\n}\nV change(int p,int L,int R,int x,int w){\n\tif(L==R){\n\t\tif(w){\n\t\t\tt1[p].minn = t2[p].minn = 1;\n\t\t\tt1[p].sum = t2[p].sum = 1;\n\t\t}\n\t\telse{\n\t\t\tt1[p].minn = t2[p].minn = -1;\n\t\t\tt1[p].sum = t2[p].sum = -1;\n\t\t}\n\t\treturn;\n\t}\n\tint mid=L+R>>1;\n\tif(x<=mid)change(lson,x,w);\n\telse change(rson,x,w);\n\tupd(p);\n}\nnode ask1(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t1[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask1(rson,l,r);\n\tif(r<=mid)return ask1(lson,l,r);\n\treturn ask1(lson,l,mid)+ask1(rson,mid+1,r);\n}\nnode ask2(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t2[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask2(rson,l,r);\n\tif(r<=mid)return ask2(lson,l,r);\n\treturn ask2(rson,mid+1,r)+ask2(lson,l,mid);\n}\nV work(){\n\tint x, l, r;\n\tbuild(1,1,m);\n\twhile(n--){\n\t\tx = getint();\n\t\tif(zero.find(x)!=zero.end()){\n\t\t\tl = x, r = *alen.upper_bound(x); // 找一个不被管辖的 0\n\t\t\t// alen.erase(x);\n\t\t\tif(alen.find(x)!=alen.end())\n\t\t\t\talen.erase(x);\n\t\t\telse{\n\t\t\t\talen.erase(r);\n\t\t\t\tr = *alen.upper_bound(x);\n\t\t\t}\n\t\t\talen.erase(r);\n\t\t\tauto it = mp.upper_bound(P(x+1,0));\n\t\t\tif(it != mp.begin()){\n\t\t\t\tauto tmp = it;\n\t\t\t\ttmp --;\n\t\t\t\tif(tmp->first<=x && tmp->second >=x)\n\t\t\t\t\tit --;\n\t\t\t}\n\t\t\tif(it != mp.end()) cmin(l,it->first);\n\t\t\tauto itl = it;\n\t\t\tint cnt = 0;\n\t\t\twhile(it != mp.end() && it->second<=r){\n\t\t\t\tcmax(r, it->second);\n\t\t\t\tit ++, cnt ++;\n\t\t\t}\n\t\t\tauto itr = it;\n\t\t\tcout<<cnt<<\'\\n\';\n\t\t\tfor(it = itl;it!=itr;it++){\n\t\t\t\tcout<<it->first<<\' \'<<it->second<<\'\\n\';\n\t\t\t}\n\t\t\tmp.erase(itl, itr);\n\t\t\tmp.insert(P(l,r));\n\t\t\tcout<<1<<\'\\n\';\n\t\t\tcout<<l<<\' \'<<r<<\'\\n\';\n\t\t\t// auto v = *--mp.lower_bound()\n\t\t\tzero.erase(x);\n\t\t\tone.insert(x);\n\t\t\tchange(root,x,1);\n\t\t}\n\t\telse{\n\t\t\tauto it = --mp.upper_bound(P(x+1,0));\n\t\t\tchange(root,x,0);\n\t\t\tcout<<1<<\'\\n\';\n\t\t\tint l = it->first,r = it->second;\n\t\t\tcout<<l<<\' \'<<r<<\'\\n\';\n\t\t\tmp.erase(it);\n\t\t\tint L, R, mid1, mid2;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid1=L+R>>1,L^R)\n\t\t\t\tif(ask1(root,l,mid1).minn <= -1) R=mid1;\n\t\t\t\telse L=mid1+1;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid2=L+R>>1, L^R)\n\t\t\t\tif(ask2(root,mid2+1,r).minn<=-1)\n\t\t\t\t\tL=mid2+1;\n\t\t\t\telse R= mid2;\n\t\t\t// if(l == x || ask1(root,l,x-1).sum == 0){\n\t\t\t// \tL = x+1, R=r;\n\t\t\t// \twhile(mid=L+R>>1, L^R)\n\t\t\t// \t\tif(ask2(root,mid+1,r).minn<=-1)\n\t\t\t// \t\t\tL=mid+1;\n\t\t\t// \t\telse R= mid;\n\t\t\t// }\n\t\t\t// else{\n\t\t\t// \tL = l, R = x-1;\n\t\t\t// \twhile(mid=L+R>>1,L^R)\n\t\t\t// \t\tif(ask1(root,l,mid).minn <= -1) R=mid;\n\t\t\t// \t\telse L=mid+1;\n\t\t\t// }\n\t\t\tint cnt = (l<=mid1-1) + (mid1+1<=mid2-1)+(mid2+1<=r);\n\t\t\tcout<<cnt<<\'\\n\';\n\t\t\tif(l<=mid1-1){\n\t\t\t\tmp.insert(P(l,mid1-1));\n\t\t\t\tcout<<l<<\' \'<<mid1-1<<\'\\n\';\n\t\t\t}\n\t\t\tif(mid1+1<=mid2-1){\n\t\t\t\tmp.insert(P(mid1+1,mid2-1));\n\t\t\t\tcout<<mid1+1<<\' \'<<mid2-1<<\'\\n\';\n\t\t\t}\n\t\t\tif(mid2+1<=r){\n\t\t\t\tmp.insert(P(mid2+1,r));\n\t\t\t\tcout<<mid2+1<<\' \'<<r<<\'\\n\';\n\t\t\t}\n\t\t\tone.erase(x);\n\t\t\tzero.insert(x);\n\t\t\talen.insert(mid1);\n\t\t\talen.insert(mid2);\n\t\t}\n\t\t// cerr<<""===========================\\n"";\n\t}\n}\nint main(){\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\t// for(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t// }\n\treturn 0;\n}\n\n']","[0, 0, 0, 0, 1, 0, 1, 0, 0, 0]",3000,After each update we want to maintain the invariant that each interval is balanced and additionally that there is a gap containing at least one zero in between each pair of consecutive intervals Since every must be contained in an interval this is equivalent to having non empty gaps between consecutive intervals after an update There are several cases we need to handle Case 1 Bit is changed from to Case 1a Bit is contained in an interval after the previous updateIf we are inside an interval then we want to grow the interval that contains it by 2 zeros to maintain balance If the interval containing is then we can expand it to Since there is at least one after each interval so this contains one of the two zeroes we need If there is another interval then increasing the right bound again by 1 would overlap with this interval In this case We know that as well so we can merge both intervals together into to get a total of two new zeros was also previously balanced so the interval is still balanced In this case we removed two intervals and added one interval so a total of three operations were used If there is no intervals where then so we can simply expand the current interval once more to One interval was removed and one interval was added so a total of two operations were used Case 1b Bit is not contained in an interval If there exists an interval where then we can expand it to This interval is directly after so expanding it by one to the left will include an extra since it is part of the gap between two intervals so including it balances One interval was removed and one interval was added so a total of two operations were used If there is no interval where then Therefore we can simply add which is balanced One interval was added so a total of one operation was used In both cases after adding a new interval to the set we can merge with any adjacent intervals to the left or right This will maintain the invariant that there is a gap between consecutive ranges as mentioned earlier We merge at most once to the left and one to the right Since the maximum number of operations done earlier is 3 the maximum number of operations in total is 5 in this case Case 2 Bit is changed from to Suppose that In this case we want to somehow split the interval into two balanced portions Now suppose we compute the prefix sums of the balance where corresponds to and corresponds to If is the first location where the prefix sum equals then we claim that we can split the interval into and To prove this note that the balance of the empty prefix is 0 so before the prefix sum equals for the first time it must have gone To have two decreases in a row we must have In the interval the final balance prefix sum is so the first interval is balanced Since we changed a to a and removed two s the first interval being balanced implies that the second interval is balanced as well In addition since the original interval satisfied the separation invariant and the new intervals are separated by two s the separation invariant is still satisfied To compute the first time when the balance prefix sum equals 2 we can use binary search on the interval using a lazy segment tree The segment tree represents a global balance prefix sum and we can range query the minimum balance on an interval We can binary search for the lowest index on the interval where the minimum prefix sum is less than 2 In this case we removed one interval and added two new intervals for a total of three operations In both cases we use at most 5 operations in a single step so we in total use at most operations which fits in our bound In practice this upper bound is quite loose Because of the binary search on the lazy segment tree the time complexity for this solution is Note that this can be optimized to by optimizing the binary search but this was not required 
Polygon is a system which allows to create programming tasks in a simple and professional way When you add a test to the problem the corresponding form asks you for the test index As in most cases it is clear which index the next test will have the system suggests the default value of the index It is calculated as the smallest positive integer which is not used as an index for some previously added test You are to implement this feature Create a program which determines the default index of the next test given the indexes of the previously added tests ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<list>\n#include<set>\n#include<queue>\n#include<cassert>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define LET(x,a) \t__typeof(a) x(a)\n#define IFOR(i,a,b) \tfor(LET(i,a);i!=(b);++i)\n#define EACH(it,v)  \tIFOR(it,v.begin(),v.end())\n#define FOR(i,a,b)  \tfor(int i=(int)(a) ; i < (int)(b);++i)\n#define REP(i,n) \tFOR(i,0,n)\n#define PB\t\tpush_back\n#define MP \t\tmake_pair\n#define EPS\t\t1e-9\n#define INF 2000000000\n\ntypedef vector<int>\tVI;\ntypedef long long\tLL;\ntypedef pair<int,int>\tPI;\n\nbool visited[5000];\n\nint main(){\n\tint n;cin>>n;\n\tmemset(visited,false,sizeof(visited));\n\tREP(i,n){\n\t\tint tmp;cin>>tmp;\n\t\tvisited[tmp]=true;\n\t}\n\tint ans;\n\tFOR(i,1,4000){\n\t\tif(!visited[i]){\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",1200,We will create an array of boolean used 1 3001 ans fill it with false values For each of n given number we will assign corresponding used value to true After that the index of first element of used with false value is the answer to the problem 
Wilbur the pig is tinkering with arrays again He has the array initially consisting of zeros At one step he can choose any index and either add to all elements or subtract from all elements His goal is to end up with the array Of course Wilbur wants to achieve this goal in the minimum number of steps and asks you to compute this value ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2e5 + 49;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nll a[maxN], b[maxN];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> b[i];\n\tll x = 0, y = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] += x - y;\n\t\tif (a[i] < b[i])\n\t\t\tx += b[i] - a[i];\n\t\telse\n\t\t\ty += a[i] - b[i];\t\n\t}\n\tcout << x + y << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100,No matter what we make operations to make equal to Once this is done Then no matter what we must make operations to make equal to In general to make we need to make operations so in total we make operations Complexity Code Solution Note that if there is an integer so that the number of equal to differs from the number of the given squares whose weight equals then the answer is automatically NO This can be easily checked by using a map for the and the weights of the squares and checking if the maps are the same This step takes time Let be an integer and let be the set of all so that Let be the set of all special points so that the weight of is Note that and have the same number of elements Suppose that are the elements of Let if or and Suppose that are the elements of Note that the point has to be labeled by for Now each special point is labeled It remains to check if this is a valid labeling This can be done by taking an array of vectors The vector will denote the points with coordinate This vector can be easily made from the points given in time and since the points are already labeled will denote the label for the point Now for all points the point if it is special and the point if it is special must have a greater number than This step takes a total of time Complexity Code Solution Bonus Can you do this problem in time Comments This problem was inspired by the representation theory of the group of permutations Representation theory of the Symmetric Group Essential objects in the study of are Young diagrams and standard Young tableau Young Tableau The weight of a point as defined by the problem is basically the same thing as the content of a square in a standard Young tableaux If you have questions feel free to message me Let us solve this problem using dynamic programming First let us reindex the trees by sorting them by coordinate Let where we would like to consider the problem of if we only have trees standing where indicates that tree falls right and if it falls left and indicates that tree falls right and if it falls left We start with the case that Wilbur chooses the left tree and it falls right The plan is to calculate the expected length in this scenario and multiply by the chance of this case occurring which is We can easily calculate what is the farthest right tree that falls as a result of this and call it Then if this means the entire segment falls from which the length of the ground covered by trees in can be calculated However be careful when as there may be overlapping covered regions when the tree falls right but the tree falls left If only then we just consider adding the length of ground covered by trees falling right and add to the value of the subproblem There is another interesting case where Wilbur chooses the left tree and it falls left In this case we calculate the expected length and multiply by the chance of this occurring which is The expected length of ground covered by the trees here is just the length contributed by tree falling left which we must be careful calculating as there might be overlapping covered regions with the th tree falling left and the th tree falling right Then we also add the value of subproblem Doing this naively would take time but this can be lowered to by precalculating what happens when tree falls left or right We should also consider the cases that Wilbur chooses the right tree but these cases are analogous by symmetry Complexity Code Solution Solution 1 Suppose that is a string in the query Reverse and the direction of all the moves that can be made on the table Note that starting at any point that is part of a cycle there is a loop and then edges that go out of the loop So for every point it can be checked by dfs whether the can be made by starting at that point by storing what is in the cycle Moreover note that in the reversed graph each point can only be a part of one cycle Therefore the total time for the dfs in a query is This is good enough for queries to run in time Complexity where is the number of distinct characters in the table and is the query string for the th query Code Solution Solution 2 Actually too slow see comment by waterfalls below for more details For each string dfs from every node that has in degree equal to in the original graph There will be a path which leads into a cycle after which anything in the cycle can be used any number of times in Only every node with in degree equal to has to be checked because every path which leads to a cycle is part of a larger path which starts with a vertex of in degree that leads into a cycle This solution is slower but it works in practice since it is really hard for a string to match so many times in the table Each query will take time but it is much faster in practice Complexity where is the number of distinct characters in the table and is the query string of the th query 
You have a permutation an array a a 1 a 2 ldots a n of distinct integers from 1 to n The length of the permutation n is odd Consider the following algorithm of sorting the permutation in increasing order A helper procedure of the algorithm f i takes a single argument i 1 le i le n 1 and does the following If a i a i 1 the values of a i and a i 1 are exchanged Otherwise the permutation doesn t change The algorithm consists of iterations numbered with consecutive integers starting with 1 On the i th iteration the algorithm does the following if i is odd call f 1 f 3 ldots f n 2 if i is even call f 2 f 4 ldots f n 1 It can be proven that after a finite number of iterations the permutation will be sorted in increasing order After how many iterations will this happen for the first time ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nint solve(vector<int> a){\n\tint n = (int)a.size();\n\tbool sorted = true;\n\tfor(int i = 0; i < n; i++) if(a[i] != i) sorted = false;\n\tif(sorted){\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i+1 < n; i += 2){\n\t\tif(a[i] > a[i+1]) swap(a[i], a[i+1]);\n\t}\n\tvector<int> loc(n);\n\tfor(int i = 0; i < n; i++) loc[a[i]] = i;\n\tvector<int> r(n+1, 0);\n\tfor(int i = 0; i <= n; i++) r[i] = n-i;\n\tNode segtree(r, 0, n+2);\n\tint ans = 0;\n\tint min1 = n;\n\tint max0 = n-1;\n\tfor(int i = n-1; i > 0; i--){\n\t\tsegtree.add(loc[i]+1, n+2, 1);\n\t\tsegtree.add(0, loc[i]+1, -1);\n\t\tmin1 = min(min1, loc[i]);\n\t\twhile(a[max0] >= i) max0--;\n\t\tans = max(ans, segtree.query(min1, max0+1));\n\t}\n\treturn 1 + max(ans - 1, 0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor(int& x : a){\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\t\tint ans = solve(a);\n\t\tcout << ans << '\\n';\n\t}\n}""]","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0]",3300,Let s draw a wall of towers of cubes with the th tower having height For example for the picture will look as follows stands for a cube When two elements get swapped their corresponding towers get swapped as well Note that applying to the permutation swapping and if is equivalent to applying to each row of the above matrix independently swapping cells and if the th cell is and the th cell is Also note that in the final state when the permutation is each row of the matrix is sorted in non descending order too s go before s and vice versa if each row is sorted the permutation is sorted as well Thus it s enough to find the number of iterations required to sort each row of the matrix and the maximum of these numbers is the answer for the given permutation The rows of the matrix are for How to solve the problem for a sequence of s and s We can assume that the instances of s don t change their relative order and the same for s Let the positions of zeros in the initial sequence be The th zero from the left is moving towards position in the sorted sequence Let be the number of steps it takes the th zero from the left to get to its final position If the th zero is already in position then Otherwise if note that because the th zero can only get to position after the th zero gets to position Moreover let there be ones to the left of the th zero in the initial sequence Then because the has to swap with every to the left of it and also the first iteration is useless if is odd It turns out that the th zero either gets stuck into the th zero and then or consistently swaps with s on each iteration except for maybe the first in which case We are interested in Let the number of s at the start of the initial sequence be It can be seen that and this is exactly the number of iterations required Recall that we need to find the number of iterations for different binary sequences However these binary sequences are very similar to each other Let s maintain the values of for all zeros in a segment tree and say for positions containing ones Start with the sequence for that is a sequence of all ones As we increase by one a single in gets replaced with We can handle these changes using a segment tree with range add and range max The time complexity of the solution is Another equivalent formula is Here is the number of s in is the smallest position such that and is the largest position such that This formula can also be proven using induction In short consider this formula applied to the number of iterations the difference is that instead of we sometimes have depending on the parity of the current iteration number Consider all positions where the value is maximized Then it can be shown that after one iteration the value for all such positions decreases by if the parity is incorrect after one iteration the parity becomes correct otherwise observe that and which get swapped in the next iteration Moreover the value for all other positions has the same parity increases by at most and thus doesn t become too big either 
You are given a permutation p p 1 p 2 ldots p n of integers from 1 to n Let s call the number m 1 le m le n if there exists two indices l r 1 le l le r le n such that the numbers p l p l 1 ldots p r is a permutation of numbers 1 2 ldots m For example let p 4 5 1 3 2 6 In this case the numbers 1 3 5 6 are beautiful and 2 4 are not It is because if l 3 and r 3 we will have a permutation 1 for m 1 if l 3 and r 5 we will have a permutation 1 3 2 for m 3 if l 1 and r 5 we will have a permutation 4 5 1 3 2 for m 5 if l 1 and r 6 we will have a permutation 4 5 1 3 2 6 for m 6 it is impossible to take some l and r such that p l p l 1 ldots p r is a permutation of numbers 1 2 ldots m for m 2 and for m 4 You are given a permutation p p 1 p 2 ldots p n For all m 1 le m le n determine if it is a beautiful number or not ,"[""#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=2e5+5;\nint n,a[maxn],pos[maxn],ans[maxn];\nint main(){\n\tint cas=read();\n\twhile(cas--){\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i]=read();\n\t\t\tpos[a[i]]=i;\n\t\t\tans[i]=0;\n\t\t}\n\t\tint l=n+1,r=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tl=min(l,pos[i]);\n\t\t\tr=max(r,pos[i]);\n\t\t\tif(r-l+1==i)ans[i]=1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)cout<<ans[i];cout<<'\\n';\n\t}\n\treturn 0;\n}\n\n""]","[0, 1, 1, 0, 1, 0, 0, 0, 0, 0]",1300,A number is beautiful if and only if all numbers in range occupies consecutive positions in the given sequence This is equivalent to where are the largest smallest position of in sequence respectively We will consider in increasing order that its For each we will find a way to update so we can tell either is a beautiful number or not in constant time Denote is the position of number in the sequence When we have When the value of can be updated by the following formula So we can update them in constant time The correctness of above formula is based on the definition of Total time comlexity 
Yaroslav likes algorithms We ll describe one of his favorite algorithms The algorithm receives a string as the input We denote this input string as The algorithm consists of some number of command ommand number looks either as or as where and are some possibly empty strings of length at most consisting of digits and characters At each iteration the algorithm looks for a command with the minimum index such that occurs in as a substring If this command is not found the algorithm terminates Let s denote the number of the found command as In string the first occurrence of the string is replaced by string If the found command at that had form then the algorithm continues its execution and proceeds to the next iteration Otherwise the algorithm terminates The value of string after algorithm termination is considered to be the output of the algorithm Yaroslav has a set of positive integers he needs to come up with his favorite algorithm that will increase each of the given numbers by one More formally if we consider each number as a string representing the decimal representation of the number then being run on each of these strings separately the algorithm should receive the output string that is a recording of the corresponding number increased by one Help Yaroslav ,"['#pragma comment(linker, ""/STACK:128777216"")\n\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <string>\n#include <map>\n#include <set>\n#include <iostream>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <exception>\n#include <cassert>\n\ntypedef long long i64;\ntypedef unsigned int u32;\nconst int null = 0;\n\nusing namespace std;\n\ntemplate<class T> int size(const T &a) {\n\treturn int(a.size());\n}\ntemplate<class T> T abs(const T &a) {\n\treturn (a < 0? -a: a);\n}\ntemplate<class T> T sqr(const T &a) {\n\treturn a * a;\n}\n\n#define all(a) a.begin(),a.end()\n\nint main() {\n#ifdef pperm\n\tfreopen(""input.txt"", ""r"", stdin);\n\t//freopen(""input.txt"", ""w"", stdout);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tfor (int i = 0; i < 9; i++) {\n\t\tprintf(""%d??<>%d\\n"", i, i + 1);\n\t}\n\tprintf(""9??>>??0\\n"");\n\tprintf(""??<>1\\n"");\n\tfor (int i = 0; i < 10; i++) {\n\t\tprintf(""?%d>>%d?\\n"", i, i);\n\t}\n\tprintf(""?>>??\\n"");\n\tprintf("">>?\\n"");\n#ifdef pperm\n\tfprintf(stderr, ""\\n%.3lf\\n"", clock() / double(CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2500,We will use as iterator In the begin we will set before the number Then we will move it to the end of the string Then we will change to and we will move it to the begin while we have 9 before If we have another digit we just increase it and finish the algorithm If we have at the begin we change it to 1 and end the algorithm 
Polycarp has decided to decorate his room because the New Year is soon One of the main decorations that Polycarp will install is the garland he is going to solder himself Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp He is going to solder a garland consisting of n lamps and n 1 wires Exactly one lamp will be connected to power grid and power will be transmitted from it to other lamps by the wires Each wire connectes exactly two lamps one lamp is called for this wire the one that gets power from some other wire and transmits it to this wire the other one is called the one that gets power from this wire Obviously each lamp has at most one wire that brings power to it and this lamp is the auxiliary lamp for this wire and the main lamp for all other wires connected directly to it Each lamp has a brightness value associated with it the i th lamp has brightness 2 i We define the of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut and all other wires are still working Polycarp has drawn the scheme of the garland he wants to make the scheme depicts all n lamp and n 1 wires and the lamp that will be connected directly to the grid is marked the wires are placed in such a way that the power can be transmitted to each lamp After that Polycarp calculated the importance of each wire enumerated them from 1 to n 1 in descending order of their importance and then wrote the index of the main lamp for each wire in the order from the first wire to the last one The following day Polycarp bought all required components of the garland and decided to solder it but he could not find the scheme Fortunately Polycarp found the list of indices of main lamps for all wires Can you help him restore the original scheme ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\n\nbool findPath[MAXN];\n\nvector< pii > ans;\n\nint main()\n{\n\tscanf(""%d"",&n);\n\n\tfor(int i = 1 ; i < n ; i++)\n\t\tscanf(""%d"",&v[i]);\n\n\tprintf(""%d\\n"",v[1]);\n\n\tfindPath[ v[1] ] = true;\n\n\tint p = 2;\n\tint last = n;\n\n\twhile( true )\n\t{\n\t\twhile( last > 0 && findPath[last] ) last--;\n\t\tfindPath[last] = true;\n\n\t\tif( last == 0 ) break;\n\n\t\twhile( p < n && !findPath[ v[p] ] )\n\t\t{\n\t\t\tans.push_back( { v[p - 1] , v[p] } );\n\t\t\tfindPath[ v[p] ] = true;\n\t\t\tp++;\n\t\t}\n\n\t\tans.push_back( { last , v[p - 1] } );\n\t\tp++;\n\t}\n\n\tfor(int i = 0 ; i < n - 1 ; i++)\n\t\tprintf(""%d %d\\n"",ans[i].first,ans[i].second);\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200,First of all we don t like the fact that importance values can be integers up to it is kinda hard to work with them Let s rephrase the problem The highest bit set to in the importance value denotes the maximum in the subtree rooted at the auxiliary lamp for the wire So we sort the wires according to the maximums in their subtrees To break ties we could consider the second maximum then the third maximum but that s not convenient We can use something much easier suppose there are two vertices with the same maximum in their subtrees these vertices belong to the path from the root to the maximum in their subtrees and the one which is closer to the root has the greater importance value So to get the order described in the problem statement we could sort the vertices according to the maximum in their subtrees and use depth as the tie breaker What does this imply All vertices of some prefix are ancestors of vertex so some prefix denotes the path from the root to excluding itself Then there are some values describing the path from some already visited vertex to if was not met before then to and so on How can we use this information to restore the original tree is the root obviously Then the sequence can be separated into several subsegments each representing a vertical path in the tree and each vertex is the parent of the next vertex in the sequence if they belong to the same subsegment How can we separate these vertices into subsegments and how to find the parents for vertices which did not appear in the sequence at all Suppose some vertex appears several times in our sequence The first time it appeared in the sequence it was in the middle of some vertical path so the previous vertex is its parent and every time this vertex appears again it means that we start a new path and that s how decomposition into paths is done Determining the parents of vertices that did not appear in the sequence is a bit harder but can also be done Let s recall that our sequence is decomposed into paths from root to from some visited vertex to from some visited vertex to and so on so each time the path changes it means that we have found the maximum vertex among unvisited ones So we should keep track of the maximum vertex that was not introduced in the sequence while we split it into paths and each time a path breaks it means that we found the vertex we were keeping track of Overall this solution can be implemented in 
You are given a connected undirected and unweighted graph with n vertices and m edges Notice m le n 2 Let s say we color some of the edges red and the remaining edges blue Now consider only the red edges and count the number of connected components in the graph Let this value be c 1 Similarly consider only the blue edges and count the number of connected components in the graph Let this value be c 2 Find an assignment of colors to the edges such that the quantity c 1 c 2 is ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: Disjoint Set Union with path compression\n \t* and union by size. Add edges and test connectivity. \n \t* Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e; void init(int N) { e = vi(N,-1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } \n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tbool unite(int x, int y) { // union by size\n\t\tx = get(x), y = get(y); if (x == y) return 0;\n\t\tif (e[x] > e[y]) swap(x,y);\n\t\te[x] += e[y]; e[y] = x; return 1;\n\t}\n};\n\n/**tcT> T kruskal(int N, vector<pair<T,pi>> ed) {\n\tsort(all(ed));\n\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST\n\teach(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; \n\treturn ans;\n}*/\n\nvoid solve(int tc) {\n\tints(N,M);\n\tvpi edges(M); re(edges);\n\tDSU D, D2; D.init(N+1); D2.init(N+1);\n\tV<vpi> adj(N+1);\n\tvb col(M);\n\tvi extra;\n\tF0R(i,M) {\n\t\tauto [u,v] = edges[i];\n\t\tif (D.unite(u,v)) {\n\t\t\tadj[u].pb({v,i}), adj[v].pb({u,i});\n\t\t\tcol[i] = 1;\n\t\t} else if (D2.unite(u,v)) {\n\n\t\t} else {\n\t\t\textra.pb(i);\n\t\t}\n\t}\n\tif (sz(extra)) {\n\t\tdbg(col);\n\t\tdbg(sz(extra));\n\t\tcol[extra[0]] = 1;\n\t\tauto [u,v] = edges[extra[0]];\n\t\tqueue<int> q; q.push(u);\n\t\tvi edge_label(N+1, -1);\n\t\tedge_label.at(u) = -2;\n\t\twhile (sz(q)) {\n\t\t\tint x = q.ft; q.pop();\n\t\t\tfor (auto [y, i]: adj[x]) if (edge_label.at(y) == -1) {\n\t\t\t\tedge_label.at(y) = i;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t\tcol.at(edge_label[v]) = 0;\n\t}\n\tps(ts_sep(col,""""));\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 1]",2000,Let s say for convenience that the set of red edges is called and the set of blue edges is called In at least one optimal configuration or forms a spanning tree Let s say that is not a spanning tree in some optimal configuration If we move an edge connecting two disconnected vertices in from to this edge must exist since the input is a connected graph will increase by at most and will decrease by Also if we have a cycle in we can move this edge from to and won t change But may decrease by So making a spanning tree never makes the answer worse We can swap and in this proof it doesn t matter If is a spanning tree then and we want to minimise Clearly it would be best if there was no cycle in It turns out that we can ensure this Notice that so the number of extra edges is very small Let us build a spanning tree using DFS A DFS tree will only have back edges and no cross edges If there is no cycle taking these back edges in we are done However if there is a cycle and there can be at most cycle since you need at least edges for cycles it looks like edges where is an ancestor of and is an ancestor of It is easy to get rid of this cycle by dropping one back edge ending at and taking the span edge connecting with its parent in the DFS tree Note that remains a spanning tree Hence we are done Time complexity 
Omkar is watching In Okabe Rintarou needs to complete n tasks 1 leq n leq 2 cdot 10 5 Unfortunately he doesn t know when he needs to complete the tasks Initially the time is 0 Time travel will now happen according to the following rules For each k 1 2 ldots n Okabe will realize at time b k that he was supposed to complete the k th task at time a k a k b k When he realizes this if k th task was already completed at time a k Okabe keeps the usual flow of time Otherwise he time travels to time a k then immediately completes the task If Okabe time travels to time a k all tasks completed after this time will become incomplete again That is for every j if a j a k the j th task will become incomplete if it was complete if it was incomplete nothing will change Okabe has bad memory so he can time travel to time a k getting to time b k and learning that he was supposed to complete the k th task at time a k That is even if Okabe already had to perform k th task before he wouldn t remember it before stumbling on the info about this task at time b k again Please refer to the notes for an example of time travelling There is a certain set s of tasks such that the first moment that all of the tasks in s are simultaneously completed regardless of whether any other tasks are currently completed a funny scene will take place Omkar loves this scene and wants to know how many times Okabe will time travel before this scene takes place Find this number modulo 10 9 7 It can be proven that eventually all n tasks will be completed and so the answer always exists ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nstruct fwt\n{\n\tint dat[400005];\n\tvoid add(int id, int val)\n\t{\n\t\tfor(; id > 0; id -= id & -id) dat[id] = (dat[id] + val) % MOD;\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\tfor(; id <= 400000; id += id & -id) ret = (ret + dat[id]) % MOD;\n\t\treturn ret;\n\t}\n}tre;\nint n, t, b[200005], dp[200005];\nPII dat[200005];\nbool nd[200005];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) {\n\t\tscanf(""%d%d"", &dat[i].second, &dat[i].first); b[i] = dat[i].first;\n\t}\n\tsort(dat, dat + n);\n\tscanf(""%d"", &t);\n\trep(i, t) {\n\t\tint x; scanf(""%d"", &x);\n\t\tnd[lower_bound(dat, dat + n, MP(b[x - 1], 0)) - dat] = true;\n\t}\n\t\n\ttre.add(2 * n, 1);\n\trep(i, n) {\n\t\tdp[i] = tre.query(dat[i].second);\n\t\ttre.add(dat[i].second, dp[i]);\n\t}\n\t\n\tint pv = 1, ans = 0;\n\tfor(int i = n - 1; i >= 0; i --) {\n\t\ttre.add(dat[i].second, (MOD - dp[i]) % MOD);\n\t\tif(nd[i] && dat[i].second >= pv) {\n\t\t\tans = (ans + tre.query(pv)) % MOD;\n\t\t\tpv = dat[i].second;\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']","[0, 1, 0, 1, 1, 0, 0, 0, 0, 0]",3000,Each time travel that Okabe performs creates a new set of completed tasks We will take this as given but it can be proven using ideas from the rest of the proof It thus suffices to count the number of distinct sets of task that come before the first one that contains as a subset We should first figure out what kinds of sets will ever appear as a set of completed tasks at all we will call these sets valid We will represent tasks below as intervals First note that clearly not all sets are valid If you have the intervals and clearly the set is not a valid set You can actually see that the same is true for the intervals and is not a valid set by working through Okabe s activities This generalizes in a very important way if there are two intervals and with and then any valid set that contains must also contain This is because if is reached to complete the task then will already have been reached to complete the task since and any time travel that undoes must also undo since The above property is actually equivalent to being a valid set we have already seen that it is necessary and from the next part of the tutorial we will have way to prove that it is sufficient but you should have some intuition for why this is true In order to solve the problem we want to think about how to determine given two valid sets which one Okabe will encounter first First for any two valid sets consider their last interval i e interval with greatest value of If these are different then the one with largest interval having greater will come later This is because for any valid set the largest value of in any interval in that set is equal to the largest value of that Okabe has ever encountered You can see this by noticing that the only way to undo a task is to perform a task with greater value of any task with smaller is either contained inside the first task in which case it won t undo it or also has a smaller value of in which case by the above property of valid sets it must already be completed Since the maximum value of that Okabe has ever encountered will only get larger as his activities continue it follows that the valid set with larger maximum value of must occur later We can further see that for any two valid sets where the interval with largest is equal we can discard that interval and consider the next largest interval from both valid sets This gives us an ordering of the valid sets We can prove that the aformentioned property is sufficient for being a valid set by showing that at any valid set the next valid set encountered is the immediately next one in the ordering The details are left to the reader In order to use this to finally solve the problem it is useful to represent valid sets in a different way Specifically we can represent a valid set as the set of intervals that aren t implied to be in by any other element of By thinking about the above property you can see that is actually a set of recursively containing intervals i e it contains an interval then another interval inside that one then another interval inside one etc We will consider the above representation to be ordered so that the last interval is the one that contains all the others and the first interval is the one inside of all the others We can now solve the problem For the given set first determine its above representation this can be done easily using sorting discarding any redundant interval The valid sets also in their above representation that come before are thus the ones that excluding their common suffix with have a last interval whose is smaller than the for the last interval in excluding the common suffix We can therefore solve this as follows We will count the number of above sets for each possible common suffix For each suffix let the last interval in not included in the suffix be and let the first interval in the suffix be The amount of sets for this suffix is equal to the amount of recursively containing sets that have a largest interval that is contained in whose value of is less than the value of for We can compute this follows We will maintain a range sum query data structure such as binary index tree The data structure will have at each the number of recursively containing subsets whose largest interval is the one with that once that interval has been processed We will process the intervals in increasing order of For each interval to put it into the data structure we can simply perform a range query of literally the interval and add to the result That will be equal to the number of recursively containing sets with as the largest interval so we simply insert that into the data structure at the value of of Before putting into the data structure if it is in the representation of then we can find the answer for the suffix of that contains all intervals to the right of as follows Since the intervals currently in the data structure are precisely the ones with value of less than the answer for that suffix is simply the range query of where is the immediately next interval after in We therefore perform this range query then add it to our answer Note that all of this computation doesn t count itself but it does count the empty set which doesn t need to be counted so our answer is correct The runtime of this solution is 
At first there was a legend related to the name of the problem but now it s just a formal statement You are given n points a 1 a 2 dots a n on the OX axis Now you are asked to find such an integer point x on OX axis that f k x is minimal possible The function f k x can be described in the following way form a list of distances d 1 d 2 dots d n where d i a i x distance between a i and x sort list d in non descending order take d k 1 as a result If there are multiple optimal answers you can print any of them ,"[""#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e18;\n\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\n\tvector<ll> points(n);\n\tfor (int i = 0; i < n; ++i) cin >> points[i];\n\tsort(points.begin(), points.end());\n\n\tll res = INF;\n\tll x = -1;\n\tfor (int i = 0; i+k < n; ++i) {\n\t\tll offer = (points[i+k] - points[i] + 1) / 2;\n\t\tif (offer < res) {\n\t\t\tres = offer;\n\t\t\tx = (points[i+k] + points[i]) / 2;\n\t\t}\n\t}\n\tcout << x << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tcin >> t;\n\tfor (int ti = 0; ti < t; ++ti) {\n\t\tsolve();\n\t}\n}\n""]","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0]",1600,First observation closest points to any point form a contiguous subsegment so Second observation for any contiguous subsegment all points this subsegment closest to also form a contiguous segment And because of the nature of value of is minimal in borders and So all we need is to check all and But what is a value of It s such point that but So it s just in the middle of segment Note that and so it s enough to check only s In result all we need is to find minimal possible value and resulting 
You are given two permutations a and b of length n A permutation is an array of n elements from 1 to n where all elements are distinct For example an array 2 1 3 is a permutation but 0 1 and 1 3 1 aren t You can as many times as you want choose two indices i and j then swap a i with a j and b i with b j simultaneously You hate inversions so you want to minimize the total number of inversions in both permutations An inversion in a permutation p is a pair of indices i j such that i j and p i p j For example if p 3 1 4 2 5 then there are 3 inversions in it the pairs of indices are 1 2 1 4 and 3 4 ,"['#include<bits/stdc++.h>\n#define N 200005\n#define P 1000000007\n#define INF 1061109567\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline ll read(){\n\tll x=0,f=1;char ch=GC;\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=GC;}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=(x<<1)+(x<<3)+(ch^48);ch=GC;}\n\treturn x*f;\n}\nint n;\nPII a[N];\nvoid Solve(){\n\tn=read();\n\tfor(int i=1;i<=n;i++)a[i].first=read();\n\tfor(int i=1;i<=n;i++)a[i].second=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)printf(""%d "",a[i].first);\n\tprintf(""\\n"");\n\tfor(int i=1;i<=n;i++)printf(""%d "",a[i].second);\n\tprintf(""\\n"");\n}\nint main(){\n\tfor(int T=read();T--;)Solve();\n\treturn 0;\n}']","[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]",900,TutorialNotice that by performing operations of the form swap with and with simultaneously we can rearrange the array how we want but the same will correspond to the same because we are changing both and at the same time Let s sort the array using these operations Then the sum of the number of inversions in and will be the number of inversions in since is sorted It is claimed that this is the minimum sum that can be achieved Proof Consider two pairs of elements with and with In each of these pairs there can be either or inversions so among the two pairs there can be or inversions If there were inversions before the operation then there will be after the operation if there was then there will still be if there were then it will become If the permutation is sorted then in each pair of indices and there will be a maximum of 1 inversion so any pair of indices will give no more inversions than if they were swapped Since the number of inversions in each pair is the minimum possible the total number of inversions is also the minimum possible Time complexity per test case 
loves simple strings A string is called simple if every pair of adjacent characters are distinct For example are simple whereas are not simple is given a string He wants to change a minimum number of characters so that the string becomes simple Help him with this task ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nchar wcz[1000007];\n\nint tak[1000007];\n\nint main()\n{\n    scanf(""%s"", wcz);\n    for (int i=0; 1; i++)\n    {\n        if (!wcz[i])\n        break;\n        if (wcz[i]==wcz[i+1])\n        {\n            wcz[i+1]=1;\n            tak[i+1]=1;\n        }\n    }\n    for (int i=0; 1; i++)\n    {\n        if (!wcz[i])\n        break;\n        if (tak[i])\n        {\n            if (wcz[i-1]!=\'a\' && wcz[i+1]!=\'a\')\n            {\n                wcz[i]=\'a\';\n            }\n            else\n            {\n                if (wcz[i-1]!=\'b\' && wcz[i+1]!=\'b\')\n                {\n                    wcz[i]=\'b\';\n                }\n                else\n                {\n                    wcz[i]=\'c\';\n                }\n            }\n        }\n        printf(""%c"", wcz[i]);\n    }\n    printf(""\\n"");\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1300,The problem was suggested by Zi Song Yeoh zscoder There are two ways to solve this problem greedy approach and dynamic programming The first apprroach Considerr some segment of consecutive equal characters Let be the length of that segment Easy to see that we should change at least characters in the segment to remove all the pairs of equal consecutive letters On the other hand we can simply change the second the fourth etc symbols to letter that is not equal to the letters before and after the segment Greedy approach on C 
You are given two strings s and t both of length n Each character in both string is or In one move you can perform one of the following actions choose an occurrence of in s and replace it with choose an occurrence of in s and replace it with You are allowed to perform an arbitrary amount of moves possibly zero Can you change string s to make it equal to string t ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 18:37:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    vector<int> ns(1, 0);\n    vector<int> nt(1, 0);\n    string cs, ct;\n    for (int i = 0; i < n; i++) {\n      if (s[i] != \'b\') {\n        cs += s[i];\n        ns.push_back(0);\n      } else {\n        ns.back() += 1;\n      }\n      if (t[i] != \'b\') {\n        ct += t[i];\n        nt.push_back(0);\n      } else {\n        nt.back() += 1;\n      }\n    }\n    int sum = 0;\n    bool ok = true;\n    if (cs == ct) {\n      for (int i = 0; i < (int) ns.size() - 1; i++) {\n        sum += ns[i] - nt[i];\n        if (sum > 0 && cs[i] == \'a\') {\n          ok = false;\n          break;\n        }\n        if (sum < 0 && cs[i] == \'c\') {\n          ok = false;\n          break;\n        }\n      }\n    }\n    cout << (ok && cs == ct ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 1, 0, 1, 1, 0, 0]",1400,First check that the counts of all letters are the same in both strings Then consider the following restatement of the moves The letters in the string are stationary Letters and however move around the string The move of the first type moves a letter to the right The move of the second type moves a letter to the left Notice that letters and can never swap with each other Thus if you remove all letters from both strings the remaining strings should be the same Again since letters and can never swap with each other you can deduce where each of these letters should end up after the swaps The first letter a in should be on the position of the first letter in and so on After that we recall that s can only move to the right and s can only move to the left Thus we check that the th occurrence of in is to the left or equal to the th occurrences of in and vice versa for s Finally we can see that this is a sufficient condition Easy to show by construction you can just fix the positions one after another left to right Overall complexity per testcase 
People do many crazy things to stand out in a crowd Some of them dance some learn by heart rules of Russian language some try to become an outstanding competitive programmers while others collect funny math objects Alis is among these collectors Right now she wants to get one of special tables In case you forget the table is called special if the following three conditions are satisfied every integer from to appears in the table exactly once in each row numbers are situated in increasing order the sum of numbers in the th column is maximum possible Your goal is to help Alice and find at least one special table of size Both rows and columns are numbered from to with rows numbered from top to bottom and columns numbered from left to right ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int inf = 1001001001;\n\nint n,k,a[1111][1111],q,ans;\n\nint main()\n{\n    //freopen(""input.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n\n    cin >> n >> k;\n    for (int i=1; i<=n; i++){\n        for (int j=1; j<k; j++){\n            q++;\n            a[i][j]=q;\n        }\n    }\n    for (int i=1; i<=n; i++){\n        for (int j=k; j<=n; j++){\n            q++;\n            if (j==k) ans+=q;\n            a[i][j]=q;\n        }\n    }\n    cout << ans << endl;\n    for (int i=1; i<=n; i++){\n        for (int j=1; j<=n; j++){\n            cout << a[i][j] << \' \';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1300,Lets fill our table row by row greedily We want to have maximal possible number on k th place in the first row After it we need at least numbers greater than ours so its maximum value is If we select it then we are fixing all numbers after column in the first row from to On the first lets put smallest possible numbers If we do the same thing in the second row then in the beginning it will have numbers from to and from th position maximum possible values from to And so on we will fill all rows With careful implementation we don t need to store whole matrix and we need only memory Our algorithm works in time 
Vasya works as a watchman in the gallery Unfortunately one of the most expensive paintings was stolen while he was on duty He doesn t want to be fired so he has to quickly restore the painting He remembers some facts about it The painting is a square each cell contains a single integer from to and different cells may contain either different or equal integers The sum of integers in each of four squares is equal to the sum of integers in the top left square Four elements and are known and are located as shown on the picture below Help Vasya find out the number of distinct squares the satisfy all the conditions above Note that this number may be equal to meaning Vasya remembers something wrong Two squares are considered to be different if there exists a cell that contains two different integers in different squares ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ll n, a, b, c, d, ans = 0;\n    cin >> n >> a >> b >> c >> d;\n    for (int i = 1; i <= n; i++)\n    {\n        ll x1, x2, x3, x4, x5;\n        x1 = i;\n        x2 = x1 + b - c;\n        x4 = x1 + a - d;\n        x5 = x4 + b - c;\n        int cnt = 0;\n        if (x1 >= 1 && x1 <= n) cnt++;\n        if (x2 >= 1 && x2 <= n) cnt++;\n        if (x4 >= 1 && x4 <= n) cnt++;\n        if (x5 >= 1 && x5 <= n) cnt++;\n        if (cnt == 4) ans++;\n    }\n    cout << ans * n;\n\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 1, 1, 0, 0, 0]",1400,x a y b m c z d w Number in the center may be any from 1 to because number in the center belongs to all subsquares So let s find answer with fixed number in the center and then multiply answer by Let s iterate over all possible Sums of each subsquare are the same so and Similarly and This square is legal if We should just check it Also we can solve this problem in Code 
There is a hidden array a of n positive integers You know that a is a or in other words for all 1 le i le n a i a n 1 i You are given the sums of all but one of its distinct subarrays in arbitrary order The subarray whose sum is not given can be any of the frac n n 1 2 distinct subarrays of a Recover any possible palindrome a The input is chosen such that there is always at least one array a that satisfies the conditions An array b is a subarray of a if b can be obtained from a by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>\xa0using i64 = long long;template<class T>constexpr T power(T a, i64 b) {    T res {1};    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;}\xa0constexpr i64 mul(i64 a, i64 b, i64 p) {    i64 res = a * b - i64(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;}\xa0template<i64 P>struct MInt {    i64 x;    constexpr MInt() : x {0} {}    constexpr MInt(i64 x) : x {norm(x % getMod())} {}        static i64 Mod;    constexpr static i64 getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(i64 Mod_) {        Mod = Mod_;    }    constexpr i64 norm(i64 x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr i64 val() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        if (getMod() < (1ULL << 31)) {            x = x * rhs.x % int(getMod());        } else {            x = mul(x, rhs.x, getMod());        }        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        i64 v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }    friend constexpr bool operator<(MInt lhs, MInt rhs) {        return lhs.val() < rhs.val();    }};\xa0template<>i64 MInt<0>::Mod = 998244353;\xa0constexpr i64 P = i64(1E18) + 9;using Z = MInt<P>;constexpr Z B = 125796162171LL;\xa0void solve() {    int n;    std::cin >> n;        std::vector<int> s(n * (n + 1) / 2 - 1);        Z sum = 0;    i64 tot = 0;    for (auto &x : s) {        std::cin >> x;        sum += power(B, x);        tot += x;    }        std::vector<int> ans;    int need = ((n + 1) / 2);    std::sort(s.begin(), s.end());    std::vector<int> odd;    for (int i = 0, j = 0; i < s.size(); i = j) {        while (j < s.size() && s[i] == s[j]) {            j++;        }        if ((j - i) % 2 == 1) {            odd.push_back(s[i]);        }    }        auto check = [&](const std::vector<int> &a, int missing) {        Z res = 0;        Z suf = 0;        for (auto x : a) {            suf = (suf + 1) * power(B, x);            res += suf;        }        if (res == sum + power(B, missing)) {            ans = a;        }    };        std::sort(odd.begin(), odd.end());    std::vector<int> a;    a.reserve(n);    if (odd.size() < need) {        std::reverse(odd.begin(), odd.end());        for (int i = 0; i <= odd.size(); i++) {            if (n % 2 == 1 && i == odd.size()) {                continue;            }            i64 sum = 0;            for (int j = 0; j < odd.size(); j++) {                int k = j + (j >= i);                sum += 1LL * (k + 1) * (n - k) * odd[j];                if (k > 0) {                    sum -= 1LL * k * (n - k + 1) * odd[j];                }            }            int coef = (i + 1) * (n - i);            if (i > 0) {                coef -= i * (n - i + 1);            }            assert(coef > 1);            int missing = (tot - sum) / (coef - 1);            if (i > 0 && missing > odd[i - 1]) {                continue;            }            if (i < odd.size() && missing < odd[i]) {                continue;            }            a.clear();            int lst = 0;            for (int j = 0; j < odd.size() + 1; j++) {                int k = odd.size() - j;                int v;                if (i == k) {                    v = missing;                } else {                    v = odd[k - (k > i)];                }                if (lst == 0) {                    a.push_back(n % 2 == 1 ? v : v / 2);                } else {                    a.push_back((v - lst) / 2);                }                lst = v;            }            std::reverse(a.begin(), a.end());            for (int i = a.size(); i < n; i++) {                a.push_back(a[n - 1 - i]);            }            check(a, missing);        }        if (ans.empty()) {            std::multiset mset(s.begin(), s.end());            a.clear();            for (int i = 1; i < odd.size(); i++) {                a.push_back((odd[i - 1] - odd[i]) / 2);            }            for (int i = 0; i < a.size(); i++) {                int s = 0;                for (int j = i; j < a.size(); j++) {                    s += a[j];                    mset.extract(s);                    mset.extract(s);                }            }            int v = *mset.begin();            a.push_back(v);            a.push_back(odd.back() - 2 * v);            for (int i = a.size(); i < n; i++) {                a.push_back(a[n - 1 - i]);            }            check(a, a[(n - 1) / 2]);        }    } else {        for (int i = 0; i < odd.size(); i++) {            int lst = 0;            a.clear();            for (int j = 0; j < odd.size(); j++) {                if (i == j) {                    continue;                }                if (lst == 0) {                    a.push_back(n % 2 == 1 ? odd[j] : odd[j] / 2);                } else {                    a.push_back((odd[j] - lst) / 2);                }                lst = odd[j];            }            std::reverse(a.begin(), a.end());            for (int i = a.size(); i < n; i++) {                a.push_back(a[n - 1 - i]);            }            check(a, odd[i]);        }    }    assert(!ans.empty());    for (int i = 0; i < ans.size(); i++) {        std::cout << ans[i] << "" \\n""[i == ans.size() - 1];    }}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2900,Let s first look at the set of subarray sums of a palindromic array of positive integers Because is a palindrome the sum of the subarray with indices in the range is the same as the sum of the subarray with indices in the range So if we ignore all subarrays where subarrays centered at the center of each sum must appear an even number of times Also every centered subarray must have a unique sum This is because all elements of are strictly positive and if the centered subarrays are ordered by length each one contains all elements in the previous one along with two new elements so its sum must be strictly greater Therefore the set of subarray sums that appear an odd number of times is exactly the set of sums of subarrays centered at the center of For example in the array the sums that appear an odd number of times are Note that they can appear more than once So if we have all subarray sums of we can then use the centered sums to reconstruct itself The smallest centered sum is either the middle element or the sum of the middle two equal elements depending on the parity of and for each centered sum in ascending order after that its difference with the previous sum must be the sum of the next two equal elements closest to the center of Now let s find out how to reconstruct the missing sum We consider two cases If the missing sum is for a centered subarray then there will be exactly sums that appear an odd number of times in the input We can use these sums to construct a palindromic array of size as described above We can then remove all sums of subarrays of from the initial input list and look at what is remaining If we let be the indices of the missing subarray the largest remaining sum in the list must be the sum of in or equivalently Let this sum be and the sum of be If and therefore the missing sum must be because the part includes everything in the missing subarray twice and everything else once and includes everything once initially seems like it will be an edge case but the same equation works there as well since includes everything in the missing array all of once and everything in once and includes everything in once If the missing sum is not for a centered subarray then there will be exactly sums that appear an odd number of times in the input We can use these sums to construct a palindromic array of size as described above In a similar way to the previous case we can then remove all sums from the initial input list from the set of subset sums of If we let be the indices of the extra centered subarray in the largest remaining sum in the list must be the sum of in or equivalently If we let be this largest sum and be the sum of we can use similar logic to the previous case to determine that the missing sum is So we can determine the missing sum using the number of sums that appear an odd number of times in the input to determine which case we are in Once we have found the missing sum we just need to reconstruct using the process above Also notice that by the construction we have followed so far the solution is always unique Complexity 
You have an array a of length n Your task is to answer q queries given x y find the number of pairs i and j 1 le i j le n that both a i a j x and a i cdot a j y That is for the array 1 3 2 and asking for x 3 y 2 the answer is 1 i 1 and j 2 fail because 1 3 4 and not 3 also 1 cdot 3 3 and not 2 i 1 and j 3 satisfies both conditions i 2 and j 3 fail because 3 2 5 and not 3 also 3 cdot 2 6 and not 2 ,"['#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n#define int long long\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr << (#x) << "": "" << x << endl;\n#else\n#define debug(x)\n#endif\nint max(int a, int b) {\n    if (a > b) return a;\n    return b;\n}\nint min(int a, int b) {\n    if (a < b) return a;\n    return b;\n}\nusing ll = long long;\nusing ld = long double;\n\nint bs_sqrt(int x) {\n    int l = 0, r = 3e9;\n    while (r - l > 1) {\n        int m = (r + l) / 2;\n        if (m * m <= x) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    return l;\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    map<int, int> cnt;\n    for (auto c : a) cnt[c]++;\n    int q;\n    cin >> q;\n    vector<int> all_ans;\n    for (int it = 0; it < q; it++) {\n        int x, y;\n        cin >> x >> y;\n        int D = x * x - 4 * y;\n        int must_sg = bs_sqrt(D);\n        int ans = 0;\n        if (must_sg * must_sg == D) {\n            int sum_1 = x + must_sg;\n            if (abs(sum_1) % 2 == 1) continue;\n            int must = sum_1 / 2;\n            int must_1 = x - must;\n            if (must != must_1) ans += cnt[must] * cnt[must_1];\n            if (must == must_1) {\n                int add = (cnt[must] * (cnt[must] - 1)) / 2;\n                ans += add;\n            }\n            int must_2 = (x - must_sg) / 2;\n            int must_3 = x - must_2;\n            if (must > must_1) swap(must_1, must);\n            if (must_2 > must_3) swap(must_2, must_3);\n            int fl = 1;\n            if (must_2 == must || must_3 == must) fl = 0;\n            if (fl) {\n                must = must_2;\n                must_1 = must_3;\n                if (must != must_1) ans += cnt[must] * cnt[must_1];\n                if (must == must_1) {\n                    int add = (cnt[must] * (cnt[must] - 1)) / 2;\n                    ans += add;\n                }\n            }\n        }\n        all_ans.push_back(ans);\n    }\n    for (auto c : all_ans) cout << c << "" "";\n    cout << endl;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    ll t = 1;\n    cin >> t;\n    srand(time(NULL));\n    while (t--) {\n        solve();\n    }\n}']","[0, 1, 0, 0, 1, 0, 0, 1, 0, 0]",1600,The system of equations in the statement resembles Vieta s formula for quadratic equations If we have the quadratic equation will be here and will be its roots To find the roots of the quadratic equation we can use the discriminant formula The roots will then be and Once we have the potential integer values for and we can calculate the number of pairs by multiplying the number of occurrences respectively However remember to consider some special cases If the equation won t have real roots If then the formula for counting pairs in this case is different The complexity of this solution is using maps to store integer occurrences 
Recall the rules of the game Nim There are n piles of stones where the i th pile initially contains some number of stones Two players take turns choosing a non empty pile and removing any positive strictly greater than 0 number of stones from it The player unable to make a move loses the game You are given an array a consisting of n integers Artem and Ruslan decided to play Nim on segments of this array Each of the q rounds is defined by a segment l i r i where the elements a l i a l i 1 dots a r i represent the sizes of the piles of stones Before the game starts Ruslan can remove any number of piles from the chosen segment However at least so in a single round he can remove at most r i l i piles He is allowed to remove 0 piles After the removal the game is played on the remaining piles within the segment the changes made in one round do not affect the original array or any other rounds Ruslan wants to remove as many piles as possible so that Artem who always makes the first move loses For each round determine the maximum number of piles Ruslan can remove the number of ways to choose the number of piles for removal Two ways are considered different if there exists an index i such that the pile at index i is removed in one way but not in the other Since the number of ways can be large output it modulo 998 244 353 If Ruslan cannot ensure Artem s loss in a particular round output for that round ,"['#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(""1.in"", ""r"", stdin);  freopen(""1.out"", ""w"", stdout);}using ll = long long;\xa0const int kInf = 1e9;const int kMod = 998244353;void Add(int& x, int y) { ((x += y) >= kMod) && (x -= kMod); }\xa0const int kN = 1e5 + 5, kV = 64;int n, q;array<int, kN> a;array<array<int, kN>, kV> pre;\xa0struct Info {  int mn, c;  Info() { mn = kInf, c = 0; }  Info(int _mn, int _c) { mn = _mn, c = _c; }};array<array<Info, kV>, kV> dp;\xa0Info operator + (Info x, Info y) {  if(x.mn == y.mn) return Add(x.c, y.c), x;  return (x.mn < y.mn) ? x : y;}\xa0void Query(int l, int r) {  int len = r - l + 1;  array<int, kV> cnt;  for(int i = 0; i < kV; i++) {    cnt[i] = pre[i][r] - pre[i][l - 1];  }  if(cnt[0]) return void(cout << len - 1 << "" "" << cnt[0] << ""\\n"");  if(*max_element(ALL(cnt)) >= 2) {    ll sum = 0;    for(int i = 0; i < kV; i++) {      sum += (ll)cnt[i] * (cnt[i] - 1) / 2;    }    return void(cout << len - 2 << "" "" << sum % kMod << ""\\n"");  }  for(auto& k : dp) k.fill(Info());  for(int i = 1; i < kV; i++) {    if(!cnt[i]) { dp[i] = dp[i - 1]; continue; }    dp[i] = dp[i - 1];    dp[i][i] = dp[i][i] + Info(1, 1);    for(int j = 0; j < kV; j++) dp[i - 1][j].mn++;    for(int j = 0; j < kV; j++) {      dp[i][j] = dp[i][j] + dp[i - 1][i ^ j];    }  }  if(dp[kV - 1][0].mn == kInf) return void(cout << ""-1\\n"");  cout << len - dp[kV - 1][0].mn << "" "" << dp[kV - 1][0].c << ""\\n"";}\xa0void Solve() {  cin >> n >> q;  for(int i = 1; i <= n; i++) cin >> a[i];  for(int i = 0; i < kV; i++) {    for(int j = 1; j <= n; j++) {      pre[i][j] = pre[i][j - 1] + (a[j] == i);    }  }  for(int l, r; q--; ) cin >> l >> r, Query(l, r);}\xa0int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T = 1;  // cin >> T;  while(T--) Solve();  return 0;}']","[1, 0, 1, 1, 0, 1, 0, 0, 0, 0]",2700,Let s recall the condition for the second player to win in the game of Nim The XOR of the sizes of the piles must be equal to That is we are asked to remove as many piles as possible so that the XOR becomes Notice the following fact Suppose there are piles of size on a segment If we remove an even number of piles the XOR does not change If we remove an odd number it changes by Therefore there is no point in keeping more than piles If we keep piles we can remove another piles and it will not change anything at all We will answer the queries independently Let s find the count of each of the elements in the given segment For example we can precompute how many times each element appears in each prefix Now we can write the following dynamic programming solution represents a pair of maximum amount of removed elements number of ways to remove that amount where we have considered the first of the values the current XOR among the non removed values is and if at least one element is not removed and otherwise Let the amount of the current value be From each state there are at most three transitions remove all elements with that value way keep element ways keep elements ways The base case is the rest are filled with for example The final state is If it s equal to there s no answer Since the XOR cannot exceed the number of states in the dynamic programming solution is From each state there are three transitions which fits within the time constraints 
There is an unknown integer x 1 le x le n You want to find x At first you have a set of integers 1 2 ldots n You can perform the following operations no more than 10000 times a find how many numbers are multiples of a in the current set a find how many numbers are multiples of a in this set and then delete all multiples of a but x will never be deleted even if it is a multiple of a In this operation a must be greater than 1 a it means that you know that x a This operation can be only performed once Remember that in the operation of type a 1 must hold Write a program that will find the value of x ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl \'\\n\'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\nconst int N = 100100;\nvi primes;\nbool mark[N];\n  int n;\nvoid crivo(){\n\n  for(int i=2;i<=n;i++){\n    if(!mark[i]){\n      if(i<=n)primes.pb(i);\n      for(int j=2*i;j<=n;j+=i)mark[j]=1;\n    }\n  }\n\n}\n\nbool saiu[N];\n\nint askB(int p){\n  if(p > n)return 0;\n  cout <<\'B\' << "" ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\nint askA(int p){\n  if(p > n)return 0;\n  cout << ""A ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\n\nint get(int p){\n  int res=0;\n  for(int i=p;i<=n;i+=p){\n    if(saiu[i])continue;\n    res++;\n    saiu[i] = 1;\n  }\n  return res;\n}\nll getlog(ll x,ll mx){\n  ll r = 1;\n  ll p = x;\n  while(p * x<=mx){\n    p*=x;\n    r++;\n  }\n  return r;\n}\nint elevate(int p,int pwr){\n  int r = 1;\n  for(int i=0;i<pwr;i++)r*=p;\n  return r;\n}\n\nconst int sq = 100;\n\nint P=1;\n#define DB 0\nvoid solve(vi cur){\n  //if(DB)cout <<""ENTREI""<<endl;\n  for(int p : cur){\n    int x = askB(p);\n    if(x!=0){\n\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid=(l+r)/2;\n        int per = askA(P * elevate(p,mid));\n        if(per!=0){\n          res = mid,l = mid + 1;\n        }else r = mid - 1;\n      }\n\n      P*=elevate(p,res);\n    }\n  }\n  \n}\n\nint32_t main(){\n  FASTIO;\n  cin>>n;\n  crivo();\n  \n  vi cur;\n  int fora = 0;\n  int i=0;\n  for(i=0;i<=sz(primes);i++){\n    if(i == sz(primes)){\n      \n    //  if(DB)cout<<""AQUI\\n"";\n\n      solve(cur);\n      break;\n    }\n    cur.pb(primes[i]);\n    int x = askB(primes[i]);\n    int s = get(primes[i]);\n    fora+=x;\n    if(s!=x){\n      solve(cur);\n      break;\n    }\n    if(sz(cur) == sq){\n      \n     // if(DB)cout <<""Aqui ... ""<<sz(cur)<<"" ""<<sq<<endl;\n\n      int A = askA(1);\n      if(A != n-fora){\n        solve(cur);\n        break;\n      }\n      cur.clear();\n    }\n  }\n  if(P == 1){\n    cout <<""C ""<<1<<endl;cout.flush();\n    return 0;\n  }\n  i++;\n  for(;i<sz(primes);i++){\n    int p = primes[i];\n    if(p<=1 || p > n)continue;\n    int per = askA(primes[i] * P);\n    if(per!=0){\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid = (l+r)/2;\n        per = askA(elevate(p,mid) * P);\n        if(per!=0){\n          l = mid + 1;\n          res = mid;\n        }else r = mid - 1;\n      }\n\n\n      P *= elevate(p,res);\n    }\n  }\n\n  cout <<""C ""<<P<<endl;\n  cout.flush();\n  return 0;\n\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2600,If we know what prime factors x has we can find just using bruteforce To find the prime factors we can just do for every prime in ascending order meanwhile calculate the numbers there supposed to be without if it differs with the number the interactor gives then contains the prime factor This way we can find every prime factor except for the smallest one Let be the number of primes no greater than Then we can split the prime numbers into groups After finishing asking a group ask and check if the return value same as it supposed to be without If it s the first time finding it different it means the smallest prime number is in the range then just check every prime numbers in the range by asking After finding the prime factors for each factor ask it can be proved this step will be done around times The total number of operations if around the total time complexity is 
You are given a binary array a of n elements a binary array is an array consisting only of 0s and 1s A blank space is a segment of elements consisting of only 0s Your task is to find the length of the longest blank space ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n\nint n;\nint a[N];\n\nvoid solve() {\n    cin >> n;\n    rep(i, 1, n) cin >> a[i];\n\n    int res = 0;\n    for(int i = 1, j = 1; i <= n; ) {\n        while (j <= n && a[i] == a[j]) j++;\n        if (!a[i]) res = max(res, j - i);\n        i = j;\n    }\n    cout << res << ""\\n"";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,We can iterate through the array and keep track of the length of the current blank space Whenever we encounter a we increase the length of the current blank space and whenever we encounter a we check if the current blank space is longer than the previous longest blank space If it is we update the length of the longest blank space Finally we return the length of the longest blank space The time complexity of this algorithm is 
Little Artem is fond of dancing Most of all dances Artem likes rueda Cuban dance that is danced by pairs of boys and girls forming a circle and dancing together More detailed there are pairs of boys and girls standing in a circle Initially boy number dances with a girl number boy number dances with a girl number and so on Girls are numbered in the clockwise order During the dance different moves are announced and all pairs perform this moves While performing moves boys move along the circle while girls always stay at their initial position For the purpose of this problem we consider two different types of moves Value and some direction are announced and all boys move positions in the corresponding direction Boys dancing with even indexed girls swap positions with boys who are dancing with odd indexed girls That is the one who was dancing with the girl swaps with the one who was dancing with the girl number while the one who was dancing with girl number swaps with the one who was dancing with the girl number and so one It s guaranteed that is even Your task is to determine the final position of each boy ,"['#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nint main() {\n\tint n; int q;\n\twhile(~scanf(""%d%d"", &n, &q)) {\n\t\tvector<bool> swapseq;\n\t\tint rot = 0;\n\t\trep(i, q) {\n\t\t\tint ty;\n\t\t\tscanf(""%d"", &ty);\n\t\t\tif(ty == 1) {\n\t\t\t\tint x;\n\t\t\t\tscanf(""%d"", &x);\n\t\t\t\trot = ((rot - x) % n + n) % n;\n\t\t\t} else if(ty == 2) {\n\t\t\t\tswapseq.push_back(rot % 2 != 0);\n\t\t\t\tif(swapseq.size() >= 2 && swapseq.end()[-1] == swapseq.end()[-2])\n\t\t\t\t\tswapseq.resize(swapseq.size() - 2);\n\t\t\t} else abort();\n\t\t}\n\t\tvi ans(n);\n\t\tint t = swapseq.size() % n;\n\t\trep(i, n) {\n\t\t\tint j = (i + (swapseq.empty() ? 0 : swapseq[0])) % 2 == 0 ? i + t : i - t;\n\t\t\tj = (j % n + n) % n;\n\t\t\tans[j] = i + 1;\n\t\t}\n\t\trotate(ans.begin(), ans.begin() + rot, ans.end());\n\t\tfor(int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif(i != 0) putchar(\' \');\n\t\t\tprintf(""%d"", ans[i]);\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1800,The key in this problem is that order of all elements in odd positions and in even positions is the same Let s say we have 2 arrays 1 3 5 and 2 4 odd positions and even positions Now if we call 2nd commands we just swap these 2 arrays but order is the same Obviously 1st command also keeps the order By order I mean cyclic order right neighbor is the same in cycle position Let s just keep the position of 1st boy and 2nd boy Now if we apply 1st operation we move it by X or X Second type of the query just swaps the positions In the end we can construct the answer if we know positions of 1st and 2nd boys 
In the year of 30XX participants of some world programming championship live in a single large hotel The hotel has n floors Each floor has m sections with a single corridor connecting all of them The sections are enumerated from 1 to m along the corridor and all sections with equal numbers on different floors are located exactly one above the other Thus the hotel can be represented as a rectangle of height n and width m We can denote sections with pairs of integers i j where i is the floor and j is the section number on the floor The guests can walk along the corridor on each floor use stairs and elevators Each stairs or elevator occupies all sections 1 x 2 x ldots n x for some x between 1 and m All sections not occupied with stairs or elevators contain guest rooms It takes one time unit to move between neighboring sections on the same floor or to move one floor up or down using stairs It takes one time unit to move up to v floors in any direction using an elevator You can assume you don t have to wait for an elevator and the time needed to enter or exit an elevator is negligible You are to process q queries Each query is a question what is the minimum time needed to go from a room in section x 1 y 1 to a room in section x 2 y 2 ,"['#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,m,q,na,nb,a[100010],b[100010],v,p;\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,sx,sy,tx,ty;\n\tscanf(""%d%d%d%d%d"",&n,&m,&na,&nb,&v);\n\tfor(i=1;i<=na;i++)\n\t  scanf(""%d"",&a[i]);\n\tfor(i=1;i<=nb;i++)\n\t  scanf(""%d"",&b[i]);\n\tsort(a+1,a+na+1);\n\tsort(b+1,b+nb+1);\n\tscanf(""%d"",&q);\n\twhile(q--)\n\t  {\n       scanf(""%d%d%d%d"",&sx,&sy,&tx,&ty);\n       p=1e9;\n       if(na)\n         {\n          i=lower_bound(a+1,a+na+1,sy)-a;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n          i--;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n         }\n       if(nb)\n         {\n          i=lower_bound(b+1,b+nb+1,sy)-b;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n          i--;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n         }\n       if(sx==tx)\n         p=abs(ty-sy);\n       printf(""%d\\n"",p);\n      }\n\treturn 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 1, 0, 0]",1600,First thing to mention is that we can use no more than one stairs or elevator per query Indeed optimal path is always a few sections horizontally then a stair of elevator then a few sections horizontally Then we can note that we can always use one of the nearest stairs elevators to start finish Using this fact we can binary search in the sequence of stairs elevators to find the optimal one and choose the optimum between using a stairs and an elevator Don t forget about the case where you don t have to reach any stairs elevators 
The Berland Forest can be represented as an infinite cell plane Every cell contains a tree That is contained before the recent events A destructive fire raged through the Forest and several trees were damaged by it Precisely speaking you have a n times m rectangle map which represents the damaged part of the Forest The damaged trees were marked as while the remaining ones were marked as The firemen quickly extinguished the fire and now they are investigating the cause of it The main version is that there was an arson at some moment of time let s consider it as 0 some trees were set on fire At the beginning of minute 0 only the trees that were set on fire initially were burning At the end of each minute the fire spread from every burning tree to each of 8 neighboring trees At the beginning of minute T the fire was extinguished The firemen want to find the arsonists as quickly as possible The problem is they know neither the value of T how long the fire has been raging nor the coordinates of the trees that were initially set on fire They want you to find the maximum value of T to know how far could the arsonists escape and a possible set of trees that could be initially set on fire Note that you d like to maximize value T but the set of trees can be arbitrary ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> board(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> board[i];\n  }\n  vector<vector<int>> s(n + 1, vector<int>(m + 1));\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + (board[i][j] == \'X\');\n    }\n  }\n  auto check = [&](int tt) {\n    vector<vector<int>> t(n + 1, vector<int>(m + 1));\n    int r = tt * 2 + 1;\n    for (int i = 0; i <= n - r; ++i) {\n      for (int j = 0; j <= m - r; ++j) {\n        if (s[i + r][j + r] - s[i + r][j] - s[i][j + r] + s[i][j] == r * r) {\n          t[i][j]++;\n          t[i + r][j]--;\n          t[i][j + r]--;\n          t[i + r][j + r]++;\n        }\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        if (i) {\n          t[i][j] += t[i - 1][j];\n        }\n        if (j) {\n          t[i][j] += t[i][j - 1];\n        }\n        if (i && j) {\n          t[i][j] -= t[i - 1][j - 1];\n        }\n        if (board[i][j] == \'X\' && !t[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  int l = 0, r = n;\n  while (l < r) {\n    int mid = (l + r + 1) >> 1;\n    if (check(mid)) {\n      l = mid;\n    } else {\n      r = mid - 1;\n    }\n  }\n  cout << l << ""\\n"";\n  vector<string> ans(n, string(m, \'.\'));\n  r = l * 2 + 1;\n  for (int i = 0; i <= n - r; ++i) {\n    for (int j = 0; j <= m - r; ++j) {\n      if (s[i + r][j + r] - s[i + r][j] - s[i][j + r] + s[i][j] == r * r) {\n        ans[i + l][j + l] = \'X\';\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << ans[i] << ""\\n"";\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 1, 1, 0, 1, 0, 1]",2200,Let s note that if there is a possible configuration in which the forest burnt minutes then there is a configuration when the forest burnt minutes So we can binary search the answer Now we need to check the existence of the configuration for a fixed time Let s find all trees that can be set on fire There are two equivalent conditions for such trees either the square of length with a center in this cell contains only s or a distance between the current cell and any cell with or border is more or equal to We can use any of the conditions The first condition can be checked with prefix sums on 2D we can precalculate them one time and use them to take a sum on a rectangle The second condition can be checked by running bfs from all s or borders or from s which are neighboring to s or to the borders also one time before the binary search The second step is to check that it s possible to cover all burnt trees starting from all set on fire trees We can check it either with add value on a rectangle using prefix sums since each set on fire tree will burn a square with center in it Or alternatively we can run bfs from set on fire trees Anyways both algorithms have complexity And since all damaged trees are shown on the map the answer can t be more than So the total complexity is 
Grandfather Ahmed s School has n 1 students The students are divided into k classes and s i students study in the i th class So s 1 s 2 ldots s k n 1 Due to the upcoming April Fools Day all students will receive gifts Grandfather Ahmed planned to order n 1 boxes of gifts Each box can contain one or more gifts He plans to distribute the boxes between classes so that the following conditions are satisfied Class number i receives s i boxes so that each student can open exactly one box The total number of gifts in the boxes received by the i th class should be a multiple of s i it should be possible to equally distribute the gifts among the s i students of this class Unfortunately Grandfather Ahmed ordered only n boxes with gifts the i th of which contains a i gifts Ahmed has to buy the missing gift box and the number of gifts in the box should be an integer between 1 and 10 6 Help Ahmed to determine how many gifts should the missing box contain and build a suitable distribution of boxes to classes or report that this is impossible ,"['#pragma GCC optimization(""O3"")\n#pragma GCC optimization(""Ofast,unroll-loops"")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline ""\\n""                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<"" ""; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<""{""; _print(p.first);cerr<<"",""; _print(p.second);cerr<<""}"";}\ntemplate<class T>void _print(vector<T> v) {cerr<<"" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(set<T> v) {cerr<<"" [ ""; for (T i:v){_print(i); cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< "" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<"" [ ""; for(auto i:v) {_print(i);cerr<<"" "";} cerr<<""]"";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n,k; cin>>n>>k;\n    vector<ll> a(n+5);\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    vector<ll> s(k+5,0);\n    for(ll i=1;i<=k;i++){\n        cin>>s[i];\n    }\n    vector<ll> skip(n+5,0);\n    vector<vector<ll>> ans;\n    ll already=0;\n    for(ll i=1;i<=k;i++){\n        ll len=s[i];\n        vector<vector<ll>> dp(len+5,vector<ll>(len+5,-1));\n        dp[0][0]=0;\n        for(ll pos=1;pos<=n;pos++){\n            if(skip[pos]){\n                continue;\n            }\n            for(ll freq=len-1;freq>=0;freq--){\n                for(ll rem=len-1;rem>=0;rem--){\n                    if(dp[freq][rem]==-1){\n                        continue; \n                    }\n                    if(dp[freq+1][(rem+a[pos])%len]!=-1){\n                        continue;\n                    }\n                    dp[freq+1][(rem+a[pos])%len]=pos; \n                }\n            }\n        }\n        vector<ll> now;\n        if(dp[len][0]!=-1){\n            ;\n        }\n        else{\n            assert(already==0); \n            for(ll rem=0;rem<len;rem++){\n                if(dp[len-1][rem]!=-1){\n                    dp[len][0]=n+1;\n                    a[n+1]=len-rem;\n                    break;  \n                }  \n            }\n            already=1;\n        }\n        ll rem=0;     \n        for(ll freq=len;freq>=1;freq--){\n            ll cur=dp[freq][rem];\n            now.push_back(a[cur]);\n            rem=(rem-a[cur])%len;\n            rem=(rem+len)%len;\n            skip[cur]=1;\n        }\n        ans.push_back(now);\n    }\n    cout<<a[n+1]<<nline;\n    for(auto it:ans){\n        for(auto i:it){\n            cout<<i<<"" "";\n        }\n        cout<<nline; \n    }\n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(""input.txt"", ""r"", stdin);                                              \n    freopen(""output.txt"", ""w"", stdout);  \n    freopen(""error.txt"", ""w"", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    //cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}  ']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2500,Incredible mathematical fact from any integers you can choose with a sum divisible by Erd s Ginzburg Ziv theorem The proof can be found in the world wide Web Brief idea first prove for primes and then prove that if true for and then true for Sort the class sizes Let s distribute the available boxes into the first classes in order Then considering the class we have boxes at our disposal which means there are at least boxes from which you can always allocate to send to the class And for the last class we can add a box with the necessary number of gifts ourselves to ensure divisibility The question remains how to allocate numbers with a sum divisible by among numbers Restrictions allow you to do this in a straight dynamics for is it possible to choose among the first numbers so that their sum gives the remainder of by the required modulus Restore of the answer is done by the classical method 
There are n segments drawn on a plane the i th segment connects two points x i 1 y i 1 and x i 2 y i 2 Each segment is non degenerate and is either horizontal or vertical formally for every i in 1 n either x i 1 x i 2 or y i 1 y i 2 but only one of these conditions holds Only segments of different types may intersect no pair of horizontal segments shares any common points and no pair of vertical segments shares any common points We say that four segments having indices h 1 h 2 v 1 and v 2 such that h 1 h 2 and v 1 v 2 form a rectangle if the following conditions hold segments h 1 and h 2 are horizontal segments v 1 and v 2 are vertical segment h 1 intersects with segment v 1 segment h 2 intersects with segment v 1 segment h 1 intersects with segment v 2 segment h 2 intersects with segment v 2 Please calculate the number of ways to choose four segments so they form a rectangle Note that the conditions h 1 h 2 and v 1 v 2 should hold ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n \nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<ll, ll> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<ll> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n \n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define F0R(i, a) for (ll i = 0; i < (a); i++)\n#define FORd(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (ll i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \n#define sz(x) (ll)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n \nconst ll MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst ll MX = 100001;\nconst ld PI = 4*atan((ld)1);\n \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n \ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n \nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n \n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n \n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n \nusing namespace input;\n \nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n \n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n \n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; trav(a,x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // prll w/ spaces\n    }\n}\n \nusing namespace output;\n \nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n \nusing namespace io;\n \ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n \ntemplate<class T> struct modll {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n \n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modll(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modll(T v = 0, T m = 0) : val(v) { normalize(); }\n \n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modll& a) { return os << a.val; }\n    friend bool operator==(const modll& a, const modll& b) { return a.val == b.val; }\n    friend bool operator!=(const modll& a, const modll& b) { return !(a == b); }\n \n    friend void check(modll& a, modll& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modll operator+(modll a, modll b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modll operator-(modll a, modll b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modll operator-(const modll& a) { return modll(0)-a; }\n \n    friend modll operator*(modll a, modll b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modll exp(modll a, ll p) {\n        modll ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modll inv(const modll& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modll operator/(modll a, modll b) { \n        check(a,b); return a*inv(b); \n    }\n};\n \ntypedef modll<ll> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n ll ans;\nint main() {\n    setIO();\n    ll n; cin >> n;\n    vector<pair<ll, pi>> horzs; // y, left x, right x\n    vector<pair<pi, ll>> verts; //bottom y, top y, x val\n    for(ll i = 0; i < n; i++){\n    \tll x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    \t/*x1 = x2 = i;\n    \ty1 = 0, y2 = 5000;*/\n    \tif(x1 == x2){ // vert\n    \t\tverts.pb(mp(mp(min(y1, y2), max(y1, y2)), x1));\n    \t}\n    \telse horzs.pb(mp(y1, mp(min(x1, x2), max(x1, x2))));\n    }\n    sort(horzs.begin(), horzs.end());\n    sort(verts.begin(), verts.end());\n    \n\tfor(ll i = sz(horzs)-1; i >= 0; i--){\n\t\tll curtop = horzs[i].f;\n\t\tll curleftx = horzs[i].s.f;\n\t\tll currightx = horzs[i].s.s;\n\t\tTree<ll> xvals;\n\t\tvector<pi> erasers;\n\t\tfor(ll j = sz(verts)-1; j>= 0; j--){\n\t\t\tif(verts[j].f.s < curtop) continue;\n\t\t\tif(verts[j].f.f > curtop) continue;\n\t\t\txvals.insert(verts[j].s);\n\t\t\terasers.pb(mp(verts[j].s, verts[j].f.f));\n\t\t}\n\t\tll ind = 0;\n\t\tfor(ll j = i-1; j >= 0; j--){\n\t\t\tif(horzs[j].s.f >= currightx) continue;\n\t\t\tif(horzs[j].s.s <= curleftx) continue;\n\t\t\tll cury = horzs[j].f;\n\t\t\twhile(ind < erasers.size() && erasers[ind].s > cury){\n\t\t\t\txvals.erase(erasers[ind].f);\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tll nums = (ll)xvals.order_of_key(min(horzs[j].s.s+1, (ll)currightx+1))-(ll)xvals.order_of_key(max(horzs[j].s.f, (ll)curleftx));\n\t\t\tans+=(nums*(nums-1))/2;\n\t\t}\n\t}\n\tcout << ans;\n}\n \n/* stuff you should look for\n    * ll overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n']","[0, 0, 0, 0, 1, 1, 0, 0, 1, 0]",2200,Let s iterate over the lower horizontal segment Denote its coordinates as and where We call vertical segment good if followings conditions holds Now let s use the scanline method At first for each good vertical segment we increment the value of element in position in some data structure for example Fenwick Tree Next we will process two types of queries in order of increasing their y coordinate horizontal segments with coordinates upper point of some vertical segment with coordinates And if two events of different types have the same y coordinate then the event of first type must be processed first For event of first type we need to find sum on range in our data structure Let s denote this sum as Then we need to add to the answer because we have vertical segments which intersect with both fixed horizontal segments and we can choose two of them in so many ways For event of second type we just need decrement the value of element in position in our data structure 
A coordinate line has segments the th segment starts at the position and ends at the position We will denote such a segment as You have suggested that one of the defined segments covers all others In other words there is such segment in the given set which contains all other ones Now you want to test your assumption Find in the given set the segment which covers all other segments and print its number If such a segment doesn t exist print 1 Formally we will assume that segment covers segment if they meet this condition ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint x[111111], y[111111];\n\nint main() {\n\tint n; scanf(""%d"", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(""%d%d"", &x[i], &y[i]);\n\tint minx = x[1], maxx = y[1];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tminx = min(minx, x[i]);\n\t\tmaxx = max(maxx, y[i]);\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (x[i] == minx && y[i] == maxx) {\n\t\t\tprintf(""%d\\n"", i); return 0;\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", -1);\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",1100,At first we must note that the answer is always unique because if segment covers segment that segment can t cover segment It possible if and only if there are coincide segments in the set but it s not permissible by the statement Let s pay attention the answer covers the most left point of all segments and the most right point of all points too Now then we should found and and print index of segment or if there is no such segment in the set The time is 
A widely known among some people Belarusian sport programmer Yura possesses lots of information about cars That is why he has been invited to participate in a game show called Guess That Car The game show takes place on a giant parking lot which is meters long from north to south and meters wide from west to east The lot has dividing lines drawn from west to east and dividing lines drawn from north to south which divide the parking lot into by meter squares There is a car parked strictly inside each square The dividing lines are numbered from to from north to south and from to from west to east Each square has coordinates so that the square in the north west corner has coordinates and the square in the south east corner has coordinates See the picture in the notes for clarifications Before the game show the organizers offer Yura to occupy any of the intersection points of the dividing lines After that he can start guessing the cars After Yura chooses a point he will be prohibited to move along the parking lot before the end of the game show As Yura is a car expert he will always guess all cars he is offered it s just a matter of time Yura knows that to guess each car he needs to spend time equal to the square of the euclidean distance between his point and the center of the square with this car multiplied by some coefficient characterizing the machine s rarity the rarer the car is the harder it is to guess it More formally guessing a car with rarity placed in a square whose center is at distance from Yura takes seconds The time Yura spends on turning his head can be neglected It just so happened that Yura knows the rarity of each car on the parking lot in advance Help him choose his point so that the total time of guessing all cars is the smallest possible ,"[""#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint X,Y;\nint a[1010][1010];\nll sumx[1010],sumy[1010];\nll costx[1010],costy[1010];\n\nint main(void){\n    int i,j;\n    \n    cin >> X >> Y;\n    REP(i,X) REP(j,Y) cin >> a[i][j];\n    REP(i,X) REP(j,Y){\n        sumx[i] += a[i][j];\n        sumy[j] += a[i][j];\n    }\n    \n    REP(i,X+1) REP(j,X) costx[i] += sumx[j] * (2*i-2*j-1) * (2*i-2*j-1);\n    REP(i,Y+1) REP(j,Y) costy[i] += sumy[j] * (2*i-2*j-1) * (2*i-2*j-1);\n    \n    int ansx = 0, ansy = 0;\n    REP(i,X+1) if(costx[i] < costx[ansx]) ansx = i;\n    REP(i,Y+1) if(costy[i] < costy[ansy]) ansy = i;\n    \n    cout << 4 * (costx[ansx] + costy[ansy]) << endl << ansx << ' ' << ansy << endl;;\n    \n    return 0;\n}\n""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1800,We need to find such x and y that the value of is minimum possible This expression can be rewritten as Note that the first part doesn t depend on y and the second part doesn t depend on x so we can minimize these parts separately Here is how to minimize the second part is minimized similarly As the expression in the brackets doesn t depend on j this part can be rewritten as where Now it s enough to calculate the required value for all possible values of x and choose x for which this value is the smallest The optimal value of y can be found similarly The overall complexity of this solution is O n m n2 m2 As the objective function is convex other approaches to this problem are possible for example ternary search gradient descent or analytical approach calculation of derivatives 
You are a warrior fighting against the machine god Thor Thor challenge you to solve the following problem There are n conveyors arranged in a line numbered with integers from 1 to n from left to right Each conveyor has a symbol or The initial state of the conveyor i is equal to the i th character of the string s There are n 1 holes numbered with integers from 0 to n The hole 0 is on the left side of the conveyor 1 and for all i geq 1 the hole i is on the right side of the conveyor i When a ball is on the conveyor i the ball moves by the next rules If the symbol is on the conveyor i then If i 1 the ball falls into the hole 0 If the symbol is on the conveyor i 1 the ball moves to the conveyor i 1 If the symbol is on the conveyor i 1 the ball falls into the hole i 1 If the symbol is on the conveyor i then If i n the ball falls into the hole n If the symbol is on the conveyor i 1 the ball moves to the conveyor i 1 If the symbol is on the conveyor i 1 the ball falls into the hole i You should answer next q queries each query is defined by the pair of integers l r 1 leq l leq r leq n First for all conveyors l l 1 r the symbol changes to and vice versa After that put on each conveyor l l 1 r Then each ball falls into some hole Find the maximum number of balls in one hole ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 1000005;\nint n, m;\nstring str;\nstruct Tree\n{\n\tint lt, rt, ll, lr, rl, rr, lmaxi1, lmaxi2, rmaxi1, rmaxi2, maxi1, maxi2;\n\t/*\n\t\tll : Left \'<\'\n\t\tlr : Left \'>\'\n\t\trl : Right \'<\'\n\t\trr : Right \'>\'\n\t\tlmaxi1 : Left max{a + b} (a * \'>\' + b * \'<\', a, b may be 0)\n\t\trmaxi1 : Right max.....\n\t\tlmaxi2 : Left max{a + b} (a * \'<\' + b * \'>\')\n\t\trmaxi2 : Right max.....\n\t\tmaxi1 : max{a + b} (a * \'>\' + b * \'<\')\n\t\tmaxi2 : max{a + b} (a * \'<\' + b * \'>\')\n\t*/\n\tbool tag;\n} tree[4 * Maxn];\nTree Swap(Tree x)\n{\n\tswap(x.ll, x.lr), swap(x.rr, x.rl), swap(x.lmaxi1, x.lmaxi2), swap(x.rmaxi1, x.rmaxi2), swap(x.maxi1, x.maxi2);\n\treturn x;\n}\nTree merge(Tree x, Tree y)\n{\n\tif (x.tag) x.tag = false, x = Swap(x);\n\tif (y.tag) y.tag = false, y = Swap(y);\n\tTree ans;\n\tans.tag = false;\n\tans.lt = x.lt, ans.rt = y.rt;\n\tif (x.ll == x.rt - x.lt) ans.ll = x.ll + y.ll;\n\telse ans.ll = x.ll;\n\tif (y.rr == y.rt - y.lt) ans.rr = y.rr + x.rr;\n\telse ans.rr = y.rr;\n\tif (x.lr == x.rt - x.lt) ans.lr = x.lr + y.lr;\n\telse ans.lr = x.lr;\n\tif (y.rl == y.rt - y.lt) ans.rl = y.rl + x.rl;\n\telse ans.rl = y.rl;\n\tans.maxi1 = max(x.maxi1, y.maxi1);\n\tans.maxi1 = max(ans.maxi1, max(x.rr + y.lmaxi1, x.rmaxi1 + y.ll));\n\tans.maxi2 = max(x.maxi2, y.maxi2);\n\tans.maxi2 = max(ans.maxi2, max(x.rl + y.lmaxi2, x.rmaxi2 + y.lr));\n\tans.lmaxi1 = max(x.lmaxi1 + (x.lmaxi1 == x.rt - x.lt) * y.ll, (x.lr == x.rt - x.lt) ? x.lr + y.lmaxi1 : 0);\n\tans.rmaxi1 = max(y.rmaxi1 + (y.rmaxi1 == y.rt - y.lt) * x.rr, (y.rl == y.rt - y.lt) ? y.rl + x.rmaxi1 : 0);\n\tans.lmaxi2 = max(x.lmaxi2 + (x.lmaxi2 == x.rt - x.lt) * y.lr, (x.ll == x.rt - x.lt) ? x.ll + y.lmaxi2 : 0);\n\tans.rmaxi2 = max(y.rmaxi2 + (y.rmaxi2 == y.rt - y.lt) * x.rl, (y.rr == y.rt - y.lt) ? y.rr + x.rmaxi2 : 0);\n\treturn ans;\n}\nvoid pushdown(int root)\n{\n\tif (tree[root].tag)\n\t{\n\t\ttree[root].tag = 0;\n\t\ttree[root << 1].tag ^= 1, tree[root << 1 | 1].tag ^= 1;\n\t\ttree[root] = Swap(tree[root]);\n\t}\n}\nvoid build(int root, int lt, int rt)\n{\n\ttree[root] = (Tree){lt, rt};\n\tif (lt + 1 == rt)\n\t{\n\t\tif (str[lt - 1] == \'<\') tree[root].ll = tree[root].rl = tree[root].maxi1 = tree[root].maxi2 = tree[root].lmaxi1 = tree[root].rmaxi2 = tree[root].rmaxi1 = tree[root].lmaxi2 = 1;\n\t\telse tree[root].lr = tree[root].rr = tree[root].maxi1 = tree[root].maxi2 = tree[root].lmaxi1 = tree[root].rmaxi2 = tree[root].rmaxi1 = tree[root].lmaxi2 = 1;\n\t}\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tbuild(root << 1, lt, mid);\n\t\tbuild(root << 1 | 1, mid, rt);\n\t\ttree[root] = merge(tree[root << 1], tree[root << 1 | 1]);\n\t}\n}\nvoid modify(int root, int lt, int rt)\n{\n\tif (lt == tree[root].lt && rt == tree[root].rt)\n\t\ttree[root].tag ^= 1;\n\telse\n\t{\n\t\tpushdown(root);\n\t\tint mid = (tree[root].lt + tree[root].rt) >> 1;\n\t\tif (lt >= mid) modify(root << 1 | 1, lt, rt);\n\t\telse if (rt <= mid) modify(root << 1, lt, rt);\n\t\telse modify(root << 1, lt, mid), modify(root << 1 | 1, mid, rt);\n\t\ttree[root] = merge(tree[root << 1], tree[root << 1 | 1]);\n\t}\n}\nTree ask(int root, int lt, int rt)\n{\n\tif (lt == tree[root].lt && rt == tree[root].rt)\n\t{\n\t\tpushdown(root);\n\t\treturn tree[root];\n\t}\n\telse\n\t{\n\t\tpushdown(root);\n\t\tint mid = (tree[root].lt + tree[root].rt) >> 1;\n\t\tif (lt >= mid) return ask(root << 1 | 1, lt, rt);\n\t\telse if (rt <= mid) return ask(root << 1, lt, rt);\n\t\telse return merge(ask(root << 1, lt, mid), ask(root << 1 | 1, mid, rt));\n\t}\n}\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tcin >> str;\n\tbuild(1, 1, n + 1);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tmodify(1, l, r + 1);\n\t\tTree res = ask(1, l, r + 1);\n\t\tprintf(""%d\\n"", res.tag ? res.maxi2 : res.maxi1);\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0]",2800,First observe where the balls fall When there is a structure the balls on there will fall into one hole So our goal is handling this structure Each query is asking about a segment Then to solve this problem we can use segment tree Each node maintains following Prefix structure Suffix structure The answer for between above structures For example a string will be converted to the following data Prefix structure Suffix structure The answer for between above structures take the answer of or the largest answer is And we need to implement that combining two data left data right data Mainly we should merge left suffix and right prefix and calculate the answer for the segment but notice that there are some exceptions The exceptions are in case of there are only one structure in the merged node like or You may maintain other flags for your implement Then how to handling each queries We also keep above data for when are changed into and vice versa on each node of the segment tree And when a change query actually comes to some nodes swap these data Apply lazy propagation for handling this When calculate the answer for a query don t forget to consider about the prefix or the suffix Total complexity 
You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 There is a city in which Dixit lives In the city there are n houses There is For example consider two houses A and B then there is a directed road either from A to B or from B to A but not both The number of roads leading to the i th house is k i Two houses A and B are if A is reachable from B B is reachable from A We say that house B is reachable from house A when there is a path from house A to house B Dixit wants to buy two houses in the city that is one for living and one for studying Of course he would like to travel from one house to another So he wants to find a pair of bi reachable houses A and B Among all such pairs he wants to choose one with the maximum value of k A k B where k i is the number of roads leading to the house i If more than one optimal pair exists any of them is suitable Since Dixit is busy preparing CodeCraft can you help him find the desired pair of houses or tell him that no such houses exist In the problem input you are given the direction of each road You are given for each house only the number of incoming roads to that house k i You are allowed to ask only one type of query from the judge give two houses A and B and the judge answers whether B is reachable from A There is But Also you cannot ask the same query twice Once you have exhausted all your queries or the judge responds to any of your queries your program must output its guess for the two houses and quit See the Interaction section below for more details ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\nstruct node{\n\tint x,y;\n\tbool operator <(const node s)const{return a[y]-a[x]==a[s.y]-a[s.x]?y>s.y:a[y]-a[x]>a[s.y]-a[s.x];}\n}p[500002];\nchar s[100002];\nsigned main(){\n\tn=read();\n\tfor(re int i=1;i<=n;++i)a[i]=read();\n\tfor(re int i=1;i<=n;++i)for(re int j=i+1;j<=n;++j)p[++cnt]=(node){i,j};\n\tfor(re int i=1;i<=cnt;++i)if(a[p[i].x]>a[p[i].y])swap(p[i].x,p[i].y);\n\tsort(p+1,p+cnt+1);\n\tfor(re int i=1;i<=cnt;++i){\n\t\tprintf(""? %d %d\\n"",p[i].y,p[i].x);\n\t\tfflush(stdout);\n\t\tscanf(""%s"",s+1);\n\t\tif(s[1]==\'Y\'){\n\t\t\tprintf(""! %d %d\\n"",p[i].x,p[i].y);\n\t\tfflush(stdout);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\t\tprintf(""! %d %d\\n"",0,0);\n\t\tfflush(stdout);\n\t\t\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 1, 1]",2200,DescriptionIn this problem we have to output two nodes and such that there is a path from to and to and the absolute value of the difference of the indegree should be maximum First of all let us think of bireachability only i e how to find two nodes and such that they are both reachable from each other How can we verify this from the judge Because if we ask i e whether there is a path from to or not then if the judge answers Yes we can t ask further queries So we have to ask queries for those pairs for which we are sure that there is a path from to So how to ensure whether there is a path from to or not 
You are given a binary matrix A of size n times n Rows are numbered from top to bottom from 1 to n columns are numbered from left to right from 1 to n The element located at the intersection of row i and column j is called A ij Consider a set of 4 operations Cyclically shift all rows up The row with index i will be written in place of the row i 1 2 le i le n the row with index 1 will be written in place of the row n Cyclically shift all rows down The row with index i will be written in place of the row i 1 1 le i le n 1 the row with index n will be written in place of the row 1 Cyclically shift all columns to the left The column with index j will be written in place of the column j 1 2 le j le n the column with index 1 will be written in place of the column n Cyclically shift all columns to the right The column with index j will be written in place of the column j 1 1 le j le n 1 the column with index n will be written in place of the column 1 You can perform an arbitrary possibly zero number of operations on the matrix the operations can be performed in any order After that you can perform an arbitrary possibly zero number of new xor operations Select any element A ij and assign it with new value A ij oplus 1 In other words the value of A ij 1 bmod 2 will have to be written into element A ij Each application of this xor operation costs one burl Note that the 4 shift operations are free These 4 operations can only be performed before xor operations are performed Output the minimum number of burles you would have to pay to make the A matrix unitary A is a matrix with ones on the main diagonal and the rest of its elements are zeros that is A ij 1 if i j and A ij 0 otherwise ,"[""#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<string> f(n);\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n  }\n  vector<int> cnt(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cnt[(n + i - j) % n] += (f[i][j] - '0');\n    }\n  }\n  sort(all(cnt));\n  int ans = 0;\n  for (int i = 0; i < n - 1; i++) {\n    ans += cnt[i];\n  }\n  ans += n - cnt[n - 1];\n  cout << ans << '\\n';\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}""]","[1, 0, 1, 0, 0, 1, 1, 0, 0, 0]",1600,Count to the variable the number of all ones in the matrix Then consider pairs of diagonals one of which starts in cell and the other in cell for Using cyclic shifts we can assemble the main diagonal from this pair Then among all such pairs and the main diagonal find the one that contains the maximal number of ones and store this number in the variable The number of zeros on the main diagonal which should be turned into ones is equal to The number of ones to be turned into zeros because they are not on the main diagonal is calculated as The total answer is calculated as 
You are the owner of a harvesting field which can be modeled as an infinite line whose positions are identified by integers It will rain for the next n days On the i th day the rain will be centered at position x i and it will have intensity p i Due to these rains some rainfall will accumulate let a j be the amount of rainfall accumulated at integer position j Initially a j is 0 and it will increase by max 0 p i x i j after the i th day s rain A flood will hit your field if at any moment there is a position j with accumulated rainfall a j m You can use a magical spell to erase day s rain i e setting p i 0 For each i from 1 to n check whether in case of erasing the i th day s rain there is no flood ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define ll long long int\nint T,n,m,cnt;\nstruct point{\n\tll pos,val;\n}po[600006];\nint X[200000];\nint Y[200000];\nbool comp(point p1,point p2)\n{\n\tif(p1.pos==p2.pos)\n\t\treturn p1.val<p2.val;\n\treturn p1.pos<p2.pos;\n}\nll sum1[600006];\nll minL,maxU;\nvoid modify(ll xA,ll yA,ll xB,ll yB)\n{\n\tif(xA>xB) return;\n\tyA-=m; yB-=m;\n\tif(yA<=0&&yB<=0) return;\n\tif(yA>0) maxU=max(maxU,xA+yA);\n\tif(yB>0) maxU=max(maxU,xB+yB);\n\tif(yA>0) minL=min(minL,xA-yA);\n\tif(yB>0) minL=min(minL,xB-yB);\n\treturn;\n}\n\nint main(void)\n{\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d"",&n,&m);\n\t\tpo[0].val=0;\n\t\tpo[0].pos=1ll<<35;\n\t\tpo[1].val=0;\n\t\tpo[1].pos=-1ll<<35;\n\t\tcnt=2;\n\t\tminL=1ll<<59;\n\t\tmaxU=-1ll<<59;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(""%d%d"",&X[i],&Y[i]);\n\t\t\tpo[cnt].pos=X[i]-Y[i]+1;\n\t\t\tpo[cnt].val=1; cnt++;\n\t\t\tpo[cnt].pos=X[i]+1;\n\t\t\tpo[cnt].val=-2; cnt++;\n\t\t\tpo[cnt].pos=X[i]+Y[i]+1;\n\t\t\tpo[cnt].val=1; cnt++;\n\t\t}\n\t\tsort(po,po+cnt,comp);\n\t\tsum1[0]=0;\n\t\tll sum2=0;\n\t\tfor(int i=1;i<cnt-1;i++){\n\t\t\tsum1[i]=sum1[i-1]+po[i].val;\n\t\t\tmodify(po[i].pos,sum2+sum1[i],po[i+1].pos-1,sum2+sum1[i]*(po[i+1].pos-po[i].pos));\n\t\t\tsum2+=sum1[i]*(po[i+1].pos-po[i].pos);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tputchar(\'0\'+((X[i]+Y[i]>=maxU)&&(X[i]-Y[i]<=minL)));\n\t\tputchar(\'\\n\');\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 1, 0, 1, 1, 0]",2100,Let s call position j a key position if it is the center position of a rain i e there exists i so that xi j You can calculate aj for all key positions j using the difference array Let d1j aj aj 1 d2j d1j d1j 1 then the i th day s rain will change it as follows d2xi pi 1 d2xi pi 1 1 d2xi 1 d2xi 1 2 d2xi pi 1 d2xi pi 1 1 This can be calculated efficiently using prefix sums We say that a position j is valid if aj m Now consider an invalid position j erasing the i th day s rain will make it valid if and only if pi xi j aj m One can check that the region of x p satisfying such an inequality is a quadrant rotated 45 anticlockwise and translated And in particular even the intersections of two such regions have the same structure and can be computed easily to avoid using floating point numbers one can multiply all xi pi by 2 In the end for each i you only need to check whether point xi pi belongs to such region 
Polycarp found the string s and the permutation p Their lengths turned out to be the same and equal to n A permutation of n elements is an array of length n in which every integer from 1 to n occurs exactly once For example 1 2 3 and 4 3 5 1 2 are permutations but 1 2 4 4 3 2 1 2 and 0 1 2 are not In one operation he can multiply s by p so he replaces s with string new in which for any i from 1 to n it is true that new i s p i For example with s wmbe and p 3 1 4 2 after operation the string will turn to s s 3 s 1 s 4 s 2 bwem Polycarp wondered after how many operations the string would become equal to its initial value for the first time Since it may take too long he asks for your help in this matter It can be proved that the required number of operations always exists It can be very large so use a 64 bit integer type ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1\'000\'000\'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nstring perm(string &s, vector<int> &p){\n    int n = s.size();\n    string t(n, \'1\');\n    for(int i = 0;i < n;i++){\n        t[p[i]] = s[i];\n    }\n    return t;\n}\nint lcm(int a, int b){\n    return a / __gcd(a, b) * b;\n}\nstring gt(string &s, vector<int> &d){\n    string t = """";\n    for(int i = 0;i < d.size();i++){\n        t += s[d[i]];\n    }\n    return t;\n}\nvoid solve(){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> p(n);\n    for(int i = 0;i < n;i++){\n        cin >> p[i];\n        p[i]--;\n    }\n    vector<vector<int>> cycles;\n    vector<bool> used(n, false);\n    for(int i = 0;i < n;i++){\n        if(used[i])continue;\n        vector<int> t;\n        int x = i;\n        while(!used[x]){\n            used[x] = true;\n            t.push_back(x);\n            x = p[x];\n        }\n        //sort(t.begin(), t.end());\n        cycles.push_back(t);\n    }\n    vector<string> d;\n    for(int i = 0;i < n + 1;i++){\n        d.push_back(s);\n        s = perm(s, p);\n    }\n    vector<int> need(cycles.size());\n    for(int i = 0;i < need.size();i++){\n        string t = gt(d[0], cycles[i]);\n        need[i] = 1;\n        for(int j = 1;j < d.size();j++){\n            string p = gt(d[j], cycles[i]);\n            if(p == t){\n                need[i] = j;\n                break;\n            }\n        }\n    }\n    int ans = 1;\n    for(int i = 0;i < need.size();i++){\n        ans = lcm(ans, need[i]);\n    }\n    cout << ans << endl;\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 1]",1700,To begin with let s understand why the string will return to its original form In fact the graph that the permutation sets consists of simple cycles and it turns out that after a certain number of operations each character will return to its place Consider each cycle as a string that is cyclically shifted every turn It may seem that the answer is the smallest common multiple of the cycle lengths but to become equal to the initial string it is not necessary to go through the entire cycle The constraints allow us to calculate the length of the minimum suitable shift in where is the length of the cycle so just iterate over the desired shift Note that after operations the cycle will return to its original form and this will happen again after operations The answer will be of all since each cycle individually comes to its original form after the number of operations is a multiple of its 
The store sells n items the price of the i th item is p i The store s management is going to hold a promotion if a customer purchases at least x items y cheapest of them are free The management has not yet decided on the exact values of x and y Therefore they ask you to process q queries for the given values of x and y determine the maximum total value of items received for free if a customer makes Note that all queries are independent they don t affect the store s stock ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 18:36:04       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  vector<long long> pref(n + 1);\n  for (int i = 0; i < n; i++) {\n    pref[i + 1] = pref[i] + a[i];\n  }\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    cout << pref[n - (x - y)] - pref[n - x] << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",900,First of all there is an answer with exactly items bought Suppose items worth were purchased Then by removing from this set the sum of the cheapest items in the set will change by which means the answer will not decrease The second fact that is necessary to solve the problem of the most expensive items should be chosen Otherwise one can remove the minimum price item from the set and add an item with a higher price it can always be found which means the answer will not decrease Using these two facts it is enough to sort the array and use prefix sums 
You are given an array a 1 a 2 dots a n and an array b 1 b 2 dots b n For one operation you can sort in non decreasing order any subarray a l dots r of the array a For example if a 4 2 2 1 3 1 and you choose subbarray a 2 dots 5 then the array turns into 4 1 2 2 3 1 You are asked to determine whether it is possible to obtain the array b by applying this operation any number of times possibly zero to the array a ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1200*1007;\nconst int n1=(1<<19);\n\nint n;\n\nint a[nax];\nint b[nax];\n\nint gdz[nax];\n\nmap <int,int> sta, kon;\n\nvoid nie()\n{\n\tprintf(""NO\\n"");\n}\n\nvoid tak()\n{\n\tprintf(""YES\\n"");\n}\n\nint drz[nax];\n\nvoid zmien(int v, int w)\n{\n\tv+=n1-1;\n\tdrz[v]=w;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=min(drz[v*2], drz[v*2+1]);\n\t\tv>>=1;\n\t}\n}\n\nint czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\treturn drz[v];\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn 1e9;\n\t}\n\treturn min(\n\t\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\t\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\n\t);\n}\n\nvoid test()\n{\n\tsta.clear();\n\tkon.clear();\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &a[i]);\n\t\tsta[a[i]]++;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &b[i]);\n\t\tkon[b[i]]++;\n\t}\n\tif (sta!=kon)\n\t{\n\t\tnie();\n\t\treturn;\n\t}\n\tvector <pii> raz, dwa;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\traz.push_back({a[i], i});\n\t\tdwa.push_back({b[i], i});\n\t}\n\tsort(raz.begin(), raz.end());\n\tsort(dwa.begin(), dwa.end());\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ta[raz[i-1].second]=i;\n\t\tb[dwa[i-1].second]=i;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tgdz[a[i]]=i;\n\t//~ debug() << range(a+1, a+1+n);\n\t//~ debug() << range(b+1, b+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tzmien(i, a[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x=gdz[b[i]];\n\t\t//~ debug() << imie(x) << czyt(1, 1, n1, 1, x);\n\t\tif (czyt(1, 1, n1, 1, x)<b[i])\n\t\t{\n\t\t\tnie();\n\t\t\treturn;\n\t\t}\n\t\tzmien(x, 1e9);\n\t}\n\ttak();\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0]",2400,Let s reformulate this problem in next form we can sort only subarray of length 2 swap two consecutive elements and if It is simular tasks because we can sort any array by sorting subbarray of length 2 for example bubble sort does exactly that Now lets look at elements and If then we will solve this task for arrays and Otherwise lets look at minimum position such that if there is no such position then answer to the problem is We can move element to the beginning of array only if all elements greater then In other words any index such that must be greater then And if this condition holds then we just delete element and solve task for arrays and But instead of deleting this element we will change information about minimum index such that This index will be the minimum index such that and For do this we will maintain stacks such that for any element of stack condition holds and moreover all elements in stacks are sorted in ascending order the top element of stack is minimal For example if then For finding minimum element on top of stacks we can use some data structure for example segment tree 
Iulia has n glasses arranged in a line The i th glass has a i units of juice in it Iulia drinks only from odd numbered glasses while her date drinks only from even numbered glasses To impress her date Iulia wants to find a contiguous subarray of these glasses such that both Iulia and her date will have the same amount of juice in total if only the glasses in this subarray are considered Please help her to do that More formally find out if there exists two indices l r such that 1 leq l leq r leq n and a l a l 2 a l 4 dots a r a l 1 a l 3 dots a r 1 if l and r have the same parity and a l a l 2 a l 4 dots a r 1 a l 1 a l 3 dots a r otherwise ,"['#include ""bits/stdc++.h""\nusing namespace std;       \n\n// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\nusing ll = long long;\nusing ld = long double;\n#define pb push_back\n#define ff first\n#define ss second\n#define sz(x) (ll)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nvoid freopen(string s) { freopen((s+"".in"").c_str(), ""r"", stdin); freopen((s+"".out"").c_str(), ""w"", stdout); }\nvoid IOIGold2024_InshAllah() { ios_base::sync_with_stdio(false); cin.tie(NULL); }\nll binmul(ll a, ll b, ll c) { ll res = 0; while(b) { if(b&1) (res += a) %= c; (a += a) %= c; b >>= 1; } return res; }\nll binpow(ll a, ll b, ll c) { ll res = 1; while(b) { if(b&1) (res *= a) %= c; (a *= a) %= c; b >>= 1; } return res; }\ntemplate<typename T> T gcd(T a, T b) { if(b==0) return a; return gcd(b, a%b); }\ntemplate<typename T> T lcm(T a, T b) { return a/gcd(a, b)*b; }\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nld rnd() { return rng()%INT_MAX*1.0/INT_MAX; }\n\nconst ll inf = 1e18+7, MX = LLONG_MAX, MN = LLONG_MIN;\nconst ll mod = 1e9+7, N = 3e5+5;\nll a[N], even[N], odd[N];\n\nvoid kigash() {\n    ll n;\n    cin>>n;\n    // odd[i] - odd[j] = even[i] - even[j]\n    // odd[i] - even[i] = odd[j] - even[j]\n    map<ll, ll> have;\n    have[0] = 1;\n    ll f = 0;\n    for(ll i=1; i<=n; i++) {\n        cin>>a[i];\n        even[i] = even[i-1], odd[i] = odd[i-1];\n        if(i&1) odd[i] += a[i];\n        else even[i] += a[i];\n        if(have.count(odd[i]-even[i])) f = 1;\n        have[odd[i]-even[i]] = 1;\n    }\n    if(f) cout<<""YES\\n"";\n    else cout<<""NO\\n"";\n    return;\n}\n\nsigned main(/*Kigash Amir*/) {\n    // freopen("""");\n    IOIGold2024_InshAllah();\n    ll tt = 1;\n    cin>>tt;\n    for(ll i=1; i<=tt; i++) {\n        kigash();\n    }\n}']","[1, 1, 0, 0, 1, 0, 0, 0, 0, 0]",1300,Let s rewrite the given equation as From here it s clear that we need to find if there is a subarray with equal to How to check this Let s flip all elements on even indices Then alternating sums of are the same as subarray sums on So we just need to check if there is a subarray with sum This is a standard problem with prefix sums if two prefix sums are equal then the subarray between them has sum otherwise no subarray has sum The complexity is or depending on how you check if two elements of an array are equal Be careful about using hash tables as they can be hacked 
In Summer Informatics School if a student doesn t behave well teachers make a hole in his badge And today one of the teachers caught a group of n students doing yet another trick Let s assume that all these students are numbered from 1 to n The teacher came to student a and put a hole in his badge The student however claimed that the main culprit is some other student p a After that the teacher came to student p a and made a hole in his badge as well The student in reply said that the main culprit was student p p a This process went on for a while but since the number of students was finite eventually the teacher came to the student who already had a hole in his badge After that the teacher put a second hole in the student s badge and decided that he is done with this process and went to the sauna You don t know the first student who was caught by the teacher However you know all the numbers p i Your task is to find out for every student a who would be the student with two holes in the badge if the first caught student was a ,"['#include <bits/stdc++.h>\n#define sz(x) ((int)x.size())\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint n, a[1010];\nbool chk[1010];\nint main() {\n\tscanf(""%d"",&n);\n\tfor(int i=1; i<=n; i++) scanf(""%d"", a+i);\n\tfor(int i=1; i<=n; i++) {\n\t\tmemset(chk,0,sizeof(chk));\n\t\tint j = i;\n\t\twhile(!chk[j]) {\n\t\t\tchk[j] = 1;\n\t\t\tj = a[j];\n\t\t}\n\t\tprintf(""%d "", j);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 1]",1000,In this problem you are given a graph with one outgoing edge from each vertex You are asked which vertex is first to be visited twice if you start in some vertex and go by outgoing edge from current vertex until you visited some vertex twice The problem can be solved by straightforward implementation You choose a starting vertex which student is first to get a hole in their badge and keep the current vertex and for all vertices how many times it was visited After transition to the next vertex you just check if it has been already visited and update visited mark for it This solution works in and is very easy in implementation It can be optimized to but it was not necessary in this problem It an easy and useful exercise left to reader 
Tenzing has a beautiful necklace The necklace consists of n pearls numbered from 1 to n with a string connecting pearls i and i text mod n 1 for all 1 leq i leq n One day Tenzing wants to cut the necklace into several parts by cutting some strings But for each connected part of the necklace there should not be more than k pearls The time needed to cut each string may not be the same Tenzing needs to spend a i minutes cutting the string between pearls i and i text mod n 1 Tenzing wants to know the minimum time in minutes to cut the necklace such that each connected part will not have more than k pearls ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n//fast IO by yosupo\n//sc.read(string) だと append される\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = \'\\0\';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        ref.clear();\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();            \n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == \'-\') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - \'0\');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(vector<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(\' \');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single(\'\\n\');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single(\'0\');\n            return;\n        }\n        if (val < 0) {\n            write_single(\'-\');\n            val = -val;  // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(\'0\' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const vector<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(\' \');\n            write_single(val[i]);\n        }\n    }\n    void write_single(long double d){\n\t\t{\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n\t\twrite_single(\'.\');\n\t\tfor(int _=0;_<8;_++){\n\t\t\td*=10;\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n    }\n};\n\nScanner sc(stdin);\nPrinter pr(stdout);\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS getrev(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\n//f(a,b) が true なら a を削除する\n//less をわたすと slide max が取れる\ntemplate<class t,class u>\nstruct slide{\n\tvc<t> x;\n\tvi y;\n\tu f;\n\tint s,b,e,c,d;\n\tslide(u ff=u()):f(ff){init();}\n\tvoid init(){s=b=e=c=d=0;}\n\tvoid push(t a){\n\t\ts++;\n\t\twhile(b<e&&f(x[e-1],a))e--;\n\t\tif(e==(int)x.size()){\n\t\t\tx.eb();\n\t\t\ty.eb();\n\t\t}\n\t\tx[e]=a;\n\t\ty[e++]=c++;\n\t}\n\tvoid pop(){s--;if(y[b]==d)b++;d++;}\n\tt get(){assert(s);return x[b];}\n\tbool has(){return b<e;}\n\tint size(){return s;}\n};\n\n//use 0\npair<int,vi> sub(int n,int k,vi a){\n\tvc<pi> dp(n);\n\tslide<pi,greater<pi>> s;\n\trep(i,n){\n\t\tpi val=i==0?pi(0,-1):s.get();\n\t\tval.a+=a[i];\n\t\tdp[i]=val;\n\t\ts.push(pi(dp[i].a,i));\n\t\tif(i>=k)s.pop();\n\t}\n\tauto [cost,x]=s.get();\n\tvi pos;\n\twhile(x!=-1){\n\t\tpos.pb(x);\n\t\tx=dp[x].b;\n\t}\n\treverse(all(pos));\n\treturn mp(cost,pos);\n}\n\nint brute(int n,int k,vi a){\n\tint res=inf;\n\trep(i,n){\n\t\tchmin(res,sub(n,k,a).a);\n\t\trotate(a.bg,a.bg+1,a.ed);\n\t}\n\treturn res;\n}\n\nint work(int n,int k,vi a,vi pos,int over){\n\ta.pb(a[0]);\n\tpos.pb(n);\n\t\n\tvvc<int> cs(si(pos)-1);\n\trep(i,si(pos)-1){\n\t\trng(j,pos[i],pos[i+1]+1)\n\t\t\tcs[i].pb(a[j]);\n\t}\n\tint K=si(cs);\n\tvi common(K-1,1);\n\tif(over){\n\t\tvvc<int> ds(K-1);\n\t\trep(i,K-1){\n\t\t\tds[i]=cs[i];\n\t\t\tds[i].insert(ds[i].ed,1+all(cs[i+1]));\n\t\t}\n\t\tif(over==1){\n\t\t\tcommon.clear();\n\t\t\trng(i,1,K-1)common.pb(si(cs[i]));\n\t\t\tK--;\n\t\t}else if(over==2){\n\t\t\tds.insert(ds.bg,cs[0]);\n\t\t\tds.insert(ds.ed,cs[K-1]);\n\t\t\tcommon.clear();\n\t\t\trep(i,K)common.pb(si(cs[i]));\n\t\t\tK++;\n\t\t}\n\t\tcs.swap(ds);\n\t}\n\tcs.pb(cs[0]);\n\tK++;\n\tcommon.pb(1);\n\t\n\tdmp(cs);\n\tdmp(common);\n\n\tvvc<pi> dp(K);\n\trep(i,K)dp[i].resize(si(cs[i]));\n\tvvc<int> pre(K);\n\trep(i,K)pre[i].resize(si(cs[i]));\n\t\n\tint ans=inf;\n\n\tauto solve_single=[&](int ini,const vi&ls,const vi&rs)->vi{\n\t\tassert(inc(ls[0],ini,rs[0]));\n\t\tassert(inc(ls[K-1],ini,rs[K-1]));\n\t\trep(i,K){\n\t\t\trng(j,ls[i],rs[i]+1){\n\t\t\t\tdp[i][j]=pi(inf,-1);\n\t\t\t\tpre[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tdp[0][ini]=pi(0,ini);\n\t\trng(i,1,K){\n\t\t\tgnr(j,ls[i-1],rs[i-1]){\n\t\t\t\tchmin(dp[i-1][j],dp[i-1][j+1]);\n\t\t\t}\n\t\t\trng(j,ls[i],rs[i]+1){\n\t\t\t\tint x=si(cs[i-1])-common[i-1]+j-k;\n\t\t\t\tchmax(x,ls[i-1]);\n\t\t\t\tif(x<=rs[i-1]){\n\t\t\t\t\tdp[i][j]=pi(min(dp[i-1][x].a+cs[i][j],inf),j);\n\t\t\t\t\tpre[i][j]=dp[i-1][x].b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[K-1][ini].a>=inf){\n\t\t\tvi mid=rs;\n\t\t\tmid[0]=mid[K-1]=ini;\n\t\t\treturn mid;\n\t\t}\n\t\tchmin(ans,dp[K-1][ini].a);\n\t\tvi mid(K);\n\t\tint cur=ini;\n\t\tper(i,K){\n\t\t\tmid[i]=cur;\n\t\t\tcur=pre[i][cur];\n\t\t}\n\t\tassert(mid[0]==ini);\n\t\treturn mid;\n\t};\n\t\n\tauto rec=[&](auto self,const vi&ls,const vi&rs)->void{\n\t\tif(ls[0]>rs[0])return;\n\t\tint ini=(ls[0]+rs[0])/2;\n\t\t//dmp2(ls[0],rs[0],ini);\n\t\t\n\t\tvi mid=solve_single(ini,ls,rs);\n\t\tif(mid.empty())return;\n\t\t\n\t\tmid[0]--;\n\t\tself(self,ls,mid);\n\t\tmid[0]+=2;\n\t\tself(self,mid,rs);\n\t};\n\t\n\tvi ls,rs;\n\trep(i,K){\n\t\tls.pb(0);\n\t\trs.pb(si(cs[i])-1);\n\t}\n\trec(rec,ls,rs);\n\tdmp(ans);\n\t\n\treturn ans;\n}\n\nint fast(int n,int k,vi a){\n\trotate(a.bg,min_element(all(a)),a.ed);\n\tvi pos=sub(n,k,a).b;\n\t\n\tint ans=work(n,k,a,pos,0);\n\tif(si(pos)>2){\n\t\tchmin(ans,work(n,k,a,pos,1));\n\t}\n\tchmin(ans,work(n,k,a,pos,2));\n\treturn ans;\n}\n\nvoid slv(){\n\tint n,k;sc.read(n,k);\n\tvi a(n);rep(i,n)sc.read(a[i]);\n\tprint(fast(n,k,a));\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t/*auto test=[&](int n,int k,vi a){\n\t\tint god=brute(n,k,a);\n\t\tint ans=fast(n,k,a);\n\t\t\n\t\tif(god!=ans){\n\t\t\tcerr<<n<<"" ""<<k<<"" ""<<a<<endl;\n\t\t\tcerr<<god<<"" ""<<ans<<endl;\n\t\t}\n\t\tassert(god==ans);\n\t};\n\t\n\ttest(9,3,{1,1,3,2,1,1,2,3,1,});\n\ttest(3,1,{3,1,3,});\n\ttest(4,2,{2,1,3,1,});\n\ttest(4,2,{3,1,2,1,});\n\n\trng(n,3,20){\n\t\tcerr<<n<<endl;\n\t\trep(_,10000){\n\t\t\tvi a(n);\n\t\t\trep(i,n)a[i]=rand_int(1,20);\n\t\t\t\n\t\t\trng(k,1,n){\n\t\t\t\ttest(n,k,a);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\t/*{\n\t\tint n=5*ten(5);\n\t\tint k=1000;\n\t\tvi a(n);\n\t\trep(i,n)a[i]=rand_int(1,1);\n\t\t\n\t\tprint(fast(n,k,a));\n\t\t//test(n,k,a);\n\t\treturn 0;\n\t}*/\n\t\n\tint t;sc.read(t);rep(_,t)\n\tslv();\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3500,TutorialAdd a constraint you must cut off edges Consider enumerating the minimum cut edges from small to large Suppose the minimum cut edge chosen is and the subsequent optimal solution is If another minimum cut edge is selected and the subsequent optimal solution is Assume that 1 It is possible to only adjust so that and the total cost after adjustment remains unchanged The adjustment method is as follows Find the smallest such that and find the first such that after if it does not exist let It can be observed that can be replaced with which is still a valid solution Moreover the solution can also be replaced with because and Since and are both optimal solutions with fixed and Therefore replacing with does not increase the total cost Repeat the above adjustment until there is no Similarly it can be proven that only adjusting is feasible so that and the total cost after adjustment remains unchanged 2 If is already satisfied it is possible to only adjust so that and the total cost after adjustment remains unchanged Assume that The adjustment method is as follows Find the smallest such that and find the first such that after let can be replaced with which is still a valid solution Moreover the solution can also be replaced with because and Since and are both optimal solutions with fixed and Therefore replacing with does not increase the total cost Similarly it can be proven that only adjusting is feasible so that and the total cost after adjustment remains unchanged 3 If it is possible to adjust so that and the total cost does not increase The adjustment method is as follows Find the smallest such that let It can be observed that can be replaced with which is still a valid solution Moreover the solution can also be replaced with because Since is the optimal solution with fixed and Therefore replacing with does not increase the total cost Combining the above conclusions we can obtain a solution that must cut off edges Let find the optimal solution Then it can be assumed that all satisfy A divide and conquer algorithm can be used Let represent the optimal solution for all If then we are done Otherwise let we can use DP to calculate the cost and solution for in time complexity Then recursively calculate and Time complexity analysis If the sum of adjacent parts is it can be merged but it is definitely not the optimal solution Therefore Assuming that the length of the first segment is the time complexity is Finally we need to calculate the solution for all possible and take the as the final answer After pruning the first edge if the optimal solution requires cutting off edges similar to the previous proof other solutions can be adjusted to satisfy and the total cost does not increase 
There are two popular keyboard layouts in Berland they differ only in letters positions All the other keys are the same In Berland they use alphabet with letters which coincides with English alphabet You are given two strings consisting of distinct letters each all keys of the first and the second layouts in the same order You are also given some text consisting of small and capital English letters and digits It is known that it was typed in the first layout but the writer intended to type it in the second layout Print the text if the same keys were pressed in the second layout Since all keys but letters are the same in both layouts the capitalization of the letters should remain the same as well as all other characters ,"['#include<cstdio>\nchar s1[1007],s2[1007],s3[100007],tr[256];\nint main(){\n\tfor(int i=0;i<256;++i)tr[i]=i;\n\tscanf(""%s%s%s"",s1,s2,s3);\n\tfor(int i=0;i<26;++i)tr[s1[i]]=s2[i],tr[s1[i]-32]=s2[i]-32;\n\tfor(int i=0;s3[i];++i)s3[i]=tr[s3[i]];\n\tputs(s3);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,At first we need to support the correspondence of letters on keyboards For example it can be done with help of Let s call it Let the first layout equals to and the second Now we need to iterate through the first string and make Also we need to make where function gives the lowercase letter to the corresponding uppercase letter After that simply iterate through the given text Let the current symbol is If is a digit we need to print it Otherwise is a letter so we need to print 
You get to work and turn on the computer You start coding and give little thought to the RAM role in the whole process In this problem your task is to solve one of the problems you encounter in your computer routine We ll consider the RAM as a sequence of cells that can contain data Some cells already contain some data some are empty The empty cells form the so called Thus a memory cluster is a sequence of some consecutive empty memory cells You have exactly memory clusters the th cluster consists of cells You need to find memory for arrays in your program The th array takes consecutive memory cells There possibly isn t enough memory for all arrays so your task is to determine what maximum number of arrays can be located in the available memory clusters Of course the arrays cannot be divided between the memory clusters Also no cell can belong to two arrays ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\nconst int L = 30;\nint N, M;\nint A[1000010], B[1000010];\n\nint cnt[110];\n\nbool check(int m) {\n\tint i, j, l;\n\tmemset(cnt, 0, L * 4);\n\tfor (j = 0; j < m; ++j) {\n\t\t++cnt[B[j]];\n\t}\n\tfor (i = N; i--; ) {\n\t\tint a = A[i];\n\t\tfor (l = L; l--; ) {\n\t\t\tint tmp = min(cnt[l], a >> l);\n\t\t\tcnt[l] -= tmp;\n\t\t\ta -= tmp << l;\n\t\t}\n\t}\n\tfor (l = 0; l < L; ++l) {\n\t\tif (cnt[l] > 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main() {\n\tint i, j;\n\t\n\tfor (; ~scanf(""%d%d"", &N, &M); ) {\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tA[i] = in();\n\t\t}\n\t\tfor (j = 0; j < M; ++j) {\n\t\t\tB[j] = in();\n\t\t}\n\t\tsort(A, A + N);\n\t\tsort(B, B + M);\n\t\tint lo = 0, ho = M + 1;\n\t\tfor (; lo + 1 < ho; ) {\n\t\t\tint mo = (lo + ho) / 2;\n\t\t\t(check(mo) ? lo : ho) = mo;\n\t\t}\n\t\tprintf(""%d\\n"", lo);\n\t}\n\t\n\treturn 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1900,We were asked to find the maximal number of arrays we can fit into the memory A small observation first let the answer be k then one of the optimal solutions fits the k smallest arrays into the memory We can assume that we have arrays of size 1 and we want to arrange the memory for the maximal arrays as possible Then if we have parts of memory of odd size if we fit array of size 1 at this part we will obtain part of even size From other hand if we put arrays of bigger size we will not change the parity and if we don t fill it with arrays of size one and initially it s of odd size then in the end we will have at least one empty cell So it s reasonable to put the arrays of size one into the memory of odd size Let s do it until we can do it We have three possible situations We don t have memory parts of odd size anymore We don t have arrays of size 1 anymore We don t have neither arrays of size 1 neither memory parts of size 1 Let us start from the first case Suppose that there are some arrays of size 1 left but there are no memory parts of odd size Easy to see then in such case we need to group arrays of size 1 in pairs and then consider them as the same array So we can divide every number by two and reduce the problem to the initial one In the second case if we divide every number by two we will obtain the same problem and that cannot increase the answer The third case is similar to the second one When implementing this we need to remember that first we have to fill the memory with arrays which are build from the maximal numbers of initial arrays 
Anton loves transforming one permutation into another one by swapping elements for money and Ira doesn t like paying for stupid games Help them obtain the required permutation by paying as little money as possible More formally we have two permutations and of numbers from to We can swap and by paying coins for it Find and print the smallest number of coins required to obtain permutation from permutation Also print the sequence of swap operations at which we obtain a solution ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2E3 + 10;\n\nint a[MAXN], b[MAXN];\nint loc[MAXN];\n\nint cnt;\nint out[MAXN * MAXN][2];\n\nint main(){\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(""%d"", &a[i]);\n\t\tloc[a[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(""%d"", &b[i]);\n\t\ta[loc[b[i]]] = i;\n\t}\n\t/*\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(""%d "", a[i]);\n\tputs("""");\n\t*/\n\n\tint cost = 0;\n\tcnt = 0;\n\tfor (int i = 1; i <= n; ++i){\n\t\tint u = 0;\n\t\tfor (u = i; u <= n && a[u] != i; ++u);\n\t\tfor (int j = u - 1; j >= i; --j)\n\t\t\tif (a[j] >= u){\n\t\t\t\tcost += u - j;\n\t\t\t\tout[cnt][0] = u;\n\t\t\t\tout[cnt][1] = j;\n\t\t\t\t++cnt;\n\t\t\t\tswap(a[u], a[j]);\n\t\t\t\tu = j;\n\t\t\t\tj = u;\n\t\t\t}\n\t}\n\tprintf(""%d\\n%d\\n"", cost, cnt);\n\tfor (int i = 0; i < cnt; ++i)\n\t\tprintf(""%d %d\\n"", out[i][0], out[i][1]);\n\t\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0]",2300,We can consider that we pay coins for swap we can divide answer in the end Then we can consider that we pay coins for moving and for moving So if was on position and then came to position then we will pay at least coins Then the answer is at least position in permutation and position in permutation Let s prove that this is the answer by showing the algorithm of making swaps Let s consider that permutation is sorted our task is equal to it Then we will put numbers from to on their positions How we can put on its position Denote Let s prove that there exists a position such that and then we will swap with and both numbers will move to their final positions and will move to the right so we can repeat this process until returns to its position We can note that there are only positions that are bigger than And how many numbers on these positions can be bigger than We can say that answer is but it s incorrect because is bigger than but Now we can use Pigeonhole principle and say that position such that and exists But now our algorithm is How we can put in its position in operations Let s move the pointer to the right while number is bigger than Then swap with found number After we can move pointer from new s position so pointer always moves to the right and will not do more then steps 
Ayush is a cashier at the shopping center Recently his department has started a service which allows users to shop online The store contains items customers have already used the above service Each user paid for items Let denote the th item in the th person s order Due to the space limitations all the items are arranged in one single row When Ayush receives the th order he will find one by one all the items in the row Let denote the position of the item in the row at the moment of its collection Then Ayush takes time equal to for the th customer When Ayush accesses the th element he keeps a new stock in the front of the row and takes away the th element Thus the values are updating Your task is to calculate the total time it takes for Ayush to process all the orders You can assume that the market has endless stock ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\n\nint tab[1007];\n\nint wyn;\n\nint x;\n\nint y;\n\nint main()\n{\n    scanf(""%d%d%d"", &n, &m, &k);\n    for (int i=1; i<=k; i++)\n    scanf(""%d"", &tab[i]);\n    for (int i=1; i<=n*m; i++)\n    {\n        scanf(""%d"", &x);\n        for (int i=1; i<=k; i++)\n        {\n            if (tab[i]==x)\n            {\n                y=i;\n            }\n        }\n        while(y>1)\n        {\n            swap(tab[y], tab[y-1]);\n            y--;\n            wyn++;\n        }\n        wyn++;\n    }\n    printf(""%d\\n"", wyn);\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1400,The problem was suggested by Ayush Anand JeanValjean01 In this problem you should simply do what was written in the problem statement There are no tricks C solution 
On a Cartesian coordinate plane lies a rectangular stage of size represented by a rectangle with corners and It can be seen that no collisions will happen before one enters the stage On the sides of the stage stand dancers The th of them falls into one of the following groups stands at moves in positive direction upwards stands at moves in positive direction rightwards According to choreography the th dancer should stand still for the first milliseconds and then start moving in the specified direction at unit per millisecond until another border is reached It is guaranteed that no two dancers have the same group position and waiting time at the same time When two dancers collide i e are on the same point at some time when both of them are moving they immediately exchange their moving directions and go on Dancers stop when a border of the stage is reached Find out every dancer s stopping position ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nmap <int, int> Mx;\nint ch(int x) {\n\tif (Mx.count(x)) return Mx[x];\n\tint t = Mx.size();\n\treturn Mx[x] = t + 1;\n}\n\nmap <pair<int, pii>, int> Mch;\nvector <pii> Vin[200050];\n\nint ans[200050][2];\nint main() {\n\tint N, W, H, i, j;\n\tscanf(""%d %d %d"", &N, &W, &H);\n\tfor (i = 1; i <= N; i++) {\n\t\tint t1, t2, t3;\n\t\tscanf(""%d %d %d"", &t1, &t2, &t3);\n\t\tint x = ch(t3 - t2);\n\t\tVin[x].emplace_back(t1, t2);\n\n\t\tMch[mp(x, pii(t1, t2))] = i;\n\t}\n\n\tfor (i = 1; i <= Mx.size(); i++) {\n\t\tsort(all(Vin[i]), [](pii a, pii b) {\n\t\t\tif (a.first != b.first) return a.first == 2;\n\t\t\telse if (a.first == 2) return a.second > b.second;\n\t\t\telse return a.second < b.second;\n\t\t});\n\t\t\n\t\tvector <pii> Va;\n\t\tfor (auto it : Vin[i]) if (it.first == 1) Va.emplace_back(it.second, H);\n\t\tfor (auto it : Vin[i]) if (it.first == 2) Va.emplace_back(W, it.second);\n\n\t\tfor (j = 0; j < Vin[i].size(); j++) {\n\t\t\tint x = Mch[mp(i, Vin[i][j])];\n\t\t\tans[x][0] = Va[j].first, ans[x][1] = Va[j].second;\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) printf(""%d %d\\n"", ans[i][0], ans[i][1]);\n\treturn 0;\n}']","[0, 0, 1, 0, 1, 0, 1, 0, 1, 0]",1900,Move every dancer units backwards in the first place that is to for the vertical moving group and for the horizontal moving group Then start the time making everyone start moving immediately Notice that if two dancers collide before any other collision happens then they have the same values for their initial positions Furthermore after a collision the two dancers keep having the same and also with the same relative orders of and Also after a collision the union of all dancers tracks will be the same as if they went through each other and no collision happened at all see the figure for sample 1 to get a general idea on this Therefore divide dancers into groups by and collisions will happen within groups only Dancers in the same group will move on the same line a line of slope and however collisions take place they will keep current relative order of and It s proved before that in each group dancers exiting positions is the same as if no collision happened at all namely for initially vertical dancers and for initially horizontal ones For each group find out all such positions Sort all dancers according to their initial values and sort these positions in the direction of to then Match the sorted dancers to these sorted positions and obtain the answers for all dancers This solution works in 
Li Hua has a tree of n vertices and n 1 edges The vertices are numbered from 1 to n A pair of vertices u v u v is considered if of the following two statements is true u is the vertex with the minimum index among all vertices on the path u v v is the vertex with the maximum index among all vertices on the path u v There will be m operations In each operation he decides an integer k j then inserts a vertex numbered n j to the tree connecting with the vertex numbered k j He wants to calculate the number of pairs before operations and after each operation Suppose you were Li Hua please solve this problem ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n,m;\nvector<int> Emx[1000005],Emn[1000005],E[1000005];\nint fa[1000005],famx[1000005],famn[1000005];\nint getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}\n\ntemplate<int MAXN>struct BIT{\n\tint c[MAXN+5];\n\tint N;\n\tvoid init(int _N=0){\n\t\tN=_N;\n\t\tfor(int i=0;i<=N;++i)\n\t\t\tc[i]=0;\n\t}\n\tint lowbit(int x){return x&(-x);}\n\tvoid add(int x,int k){\n\t\tfor(;x<=N;x+=lowbit(x))\n\t\t\tc[x]+=k;\n\t}\n\tint query(int x){\n\t\tint ret=0;\n\t\tfor(;x;x-=lowbit(x))\n\t\t\tret+=c[x];\n\t\treturn ret;\n\t}\n};\n\nBIT<1000000> bit;\nint dep1[1000005],dep2[1000005],dfn[1000005],sz[1000005],dcnt;\nll A,B,C,ans;\nvoid dfs1(int x){\n\tdfn[x]=++dcnt;\n\tsz[x]=1;\n\tdep1[x]=dep1[famx[x]]+1;\n\tB+=dep1[x]-1;\n\tfor(int y:Emx[x]){\n\t\tdfs1(y);\n\t\tsz[x]+=sz[y];\n\t}\n}\n\nvoid dfs2(int x){\n\tdep2[x]=dep2[famn[x]]+1;\n\tA+=dep2[x]-1;\n\tC+=bit.query(dfn[x]+sz[x]-1)-bit.query(dfn[x]-1);\n\tbit.add(dfn[x],1);\n\tfor(int y:Emn[x])\n\t\tdfs2(y);\n\tbit.add(dfn[x],-1);\n}\n\n\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint ui,vi;\n\t\tscanf(""%d %d"",&ui,&vi);\n\t\tE[ui].push_back(vi);\n\t\tE[vi].push_back(ui);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tsort(E[i].begin(),E[i].end());\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j:E[i]){\n\t\t\tif(j>i)\n\t\t\t\tcontinue;\n\t\t\tj=getfa(j);\n\t\t\tfa[getfa(j)]=getfa(i);\n\t\t\tfamx[j]=i;\n\t\t\tEmx[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j:E[i]){\n\t\t\tif(j<i)\n\t\t\t\tcontinue;\n\t\t\tj=getfa(j);\n\t\t\tfa[getfa(j)]=getfa(i);\n\t\t\tfamn[j]=i;\n\t\t\tEmn[i].push_back(j);\n\t\t}\n\t}\n\tbit.init(n);\n\tdfs1(n);\n\tdfs2(1);\n\tans=A+B-2*C;\n\tprintf(""%lld\\n"",ans);\n\tscanf(""%d"",&m);\n\twhile(m--){\n\t\tint k;\n\t\tscanf(""%d"",&k);\n\t\tdep2[++n]=dep2[k]+1;\n\t\tans+=n-dep2[n];\n\t\tprintf(""%lld\\n"",ans);\n\t}\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",3000,There exists an acceptable solution using centroid decomposition but there is a better solution using reconstruction trees The initial tree is shown in the following picture Consider the following reconstruction trees We will define two reconstruction trees called min RT and max RT where RT means reconstruction tree For the max RT we enumerate vertices in increasing order We create a new vertex in the max RT then find each vertex such that and is adjacent to in the original tree make become the father of the root of on the max RT We can use a dsu to build the max RT The max RT is shown in the following picture The property that on the max RT is the maximum index on the path between on the original tree is satisfied The min RT is similar to the max RT The min RT is shown in the following picture After designing the reconstruction trees I found out that the reconstruction trees are related to Kruskal reconstruction trees KRT to a certain extent Here is another way to understand the two reconstruction trees For the max RT since we want to calculate the maximum index on the path we define the weight of an edge as We build a minimum spanning KRT of the original tree and merge the vertices with the same weight into one vertex For the min RT define the weight of an edge as and use the maximum spanning KRT The max RT and the minimum spanning KRT left maximum valued graph middle KRT right max RT The min RT and the maximum spanning KRT left minimum valued graph middle KRT right min RT We will solve the problem using the two reconstruction trees Let s call the two restrictions in the statement and Denote as the number of pairs satisfying exactly one of and which is the answer as the number of pairs satisfying as the number of pairs satisfying and as the number of pairs satisfying both and It s obvious that We can easily calculate and using the depth of each vertex on two reconstruction trees Due to the property mentioned above is the number of pairs satisfying the condition that is an ancestor of on min RT and is an ancestor of on max RT which can be solved using dfs order and Fenwick tree Finally we calculated the original answer If we add a vertex with the largest index as a leaf paths ending with this vertex will satisfy so we can use min RT to calculate the paths ending with this vertex not satisfying and update the answer Time complexity 
Two boys decided to compete in text typing on the site Key races During the competition they have to type a text consisting of characters The first participant types one character in milliseconds and has ping milliseconds The second participant types one character in milliseconds and has ping milliseconds If connection ping delay is milliseconds the competition passes for a participant as follows Exactly after milliseconds after the start of the competition the participant receives the text to be entered Right after that he starts to type it Exactly milliseconds after he ends typing all the text the site receives information about it The winner is the participant whose information on the success comes earlier If the information comes from both participants at the same time it is considered that there is a draw Given the length of the text and the information about participants determine the result of the game ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint main()\n{\n\tint s,v1,v2,t1,t2;\n\tint s1,s2;\n\tscanf(""%d%d%d%d%d"",&s,&v1,&v2,&t1,&t2);\n\ts1=2*t1+s*v1;\n\ts2=2*t2+s*v2;\n\tif(s1<s2)\n\t\tprintf(""First\\n"");\n\telse if(s2<s1)\n\t\tprintf(""Second\\n"");\n\telse\n\t\tprintf(""Friendship\\n"");\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Information on the success of the first participant will come in milliseconds of the second participant in milliseconds We need to compare these numbers and print the answer depending on the comparison result 
You are given an array of n nonnegative integers a 1 a 2 dots a n Let m be a variable that is initialized to 0 Jellyfish will perform the following operation n times select an index i 1 leq i leq a and delete a i from a add operatorname MEX a dagger to m Now Jellyfish wants to know the minimum possible final value of m if he performs all the operations optimally dagger The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"['#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int P = 0x3f3f3f3f;\nconst ll inff = 1e18 + 10;\nvoid solve()\n{\n    int n, x, ma; ll ans = 0, bas = 1;cin >> n;\n    vector<int>a(n + 1, 0); vector<ll>res(n + 1,inff);\n    for (int i = 1; i <= n; i++) { cin >> x; if (x < n)a[x]++; }\n    while(a[ma])ma++; res[ma] = 0;\n    for (int i = ma - 1; i >= 0; i--)for (int j = i + 1; j <= ma; j++)res[i] = min(res[i], res[j] + 1ll * a[i] * j + i - j);\n    cout << res[0] << ""\\n"";\n}\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    int t = 1; cin >> t;\n    while (t--)solve();\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1600,We only care about the operation before reaches because after that will never change Lemma Before reaches we will choose a positive integer at a time that satisfies and delete all from the will become Proof Because if we can place this operation after the becomes if we don t delete all of won t change we can also put this operation later So before reaches the we delete is non increasing It means we can solve this problem by dynamic programming Let represents when and we haven t delete any satisfying the minimum value of Let represents the number of times appears in the transition is Time complexity per test case Memory complexity per test case 
Given a tree with n nodes numbered from 1 to n Each node i has an associated value V i If the simple path from u 1 to u m consists of m nodes namely u 1 rightarrow u 2 rightarrow u 3 rightarrow dots u m 1 rightarrow u m then its alternating function A u 1 u m is defined as A u 1 u m sum limits i 1 m 1 i 1 cdot V u i A path can also have 0 edges i e u 1 u m Compute the sum of alternating functions of all unique simple paths Note that the paths are directed two paths are considered different if the starting vertices differ or the ending vertices differ The answer may be large so compute it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n,val[N],u,v;\nVI e[N];\nll dp[N],up[N][2],down[N][2],cnt[N][2],ret;\nvoid dfs(int u,int f) {\n\tdp[u]=val[u];\n\tcnt[u][1]=1;\n\tup[u][1]=down[u][1]=val[u];\n\tfor (auto v:e[u]) if(v!=f) {\n\t\tdfs(v,u);\n\t\trep(p1,0,2) rep(p2,0,2) {\n\t\t\t// p1 p2\n\t\t\tdp[u]=(dp[u]+up[u][p1]*cnt[v][p2]+(1-2*p1)*down[v][p2]*cnt[u][p1])%mod;\n\t\t\tdp[u]=(dp[u]+up[v][p1]*cnt[u][p2]+(1-2*p1)*down[u][p2]*cnt[v][p1])%mod;\n\t\t}\n\t\trep(p1,0,2) {\n\t\t\tcnt[u][p1]=(cnt[u][p1]+cnt[v][p1^1])%mod;\n\t\t\tup[u][p1]=(up[u][p1]+up[v][p1^1]+(2*p1-1)*val[u]*cnt[v][p1^1])%mod;\n\t\t\tdown[u][p1]=(down[u][p1]+val[u]*cnt[v][p1^1]-down[v][p1^1])%mod;\n\t\t}\n\t}\n\tret+=dp[u];\n}\n\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",val+i);\n\trep(i,1,n) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tret%=mod;\n\tif (ret<0) ret+=mod;\n\tprintf(""%lld\\n"",ret);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2300,An important observation for the question is if there are even number of nodes on the simple path from to if there are odd number of nodes on the simple path from to Hence for paths with even number of nodes Hence the task has been reduced to finding the total sum of alternating function of paths with odd number of nodes Also we can make use of the fact that but this does not hold true when hence we must handle this case by subtracting from the final answer Now with the help of a single dfs we can calculate the number of paths in the subtree of with odd number of nodes ending at node the number of paths in the subtree of with even number of nodes ending at node In the first part of the solution for each node we calculate its contribution to the alternating function for paths passing through this node but strictly lying within its subtree For doing this we can merge two paths with either both having even or both having odd number of nodes ending at its children to create odd length paths For the case where both the paths have even number of nodes the current node s contribution to the summation is because its position in the sequence of nodes is odd Similarly we add for the other case This can be done using a single dfs in time as we have and for all the nodes Now for the second part of the question we have to consider the paths which end up outside the subtree We have the information and We have to merge these paths with those ending at How do we get this information Note that and just represent paths strictly lying within the subtree of but not the entire tree An important observation for this computation is If node has a total of odd and even length paths ending at it then if is the neighbour of then has a total of odd and even length paths ending at it It is fairly simple to observe We know and and since the subtree of is the entire tree we can use these values for our requirement Now let s represent the total number of odd and even length paths ending at by and respectively From our previous observation if is odd number of nodes away from the node if is even number of nodes away from the node The number of paths ending at but lying strictly outside the subtree of can be calculated odd length paths even length paths Now we have to construct odd length paths by merging paths in the subtree of ending at node with paths ending at but strictly lying outside the subtree of For paths with odd length component ending at we must add to the summation and otherwise Finally the summation of contributions of each node yields you the total summation of alternating functions for all pair of nodes This can be done for each node in time The overall time complexity of the solution is 
Aca and Milovan two fellow competitive programmers decided to give Vasilije a problem to test his skills Vasilije is given three positive integers n k and x and he has to determine if he can choose k distinct integers between 1 and n such that their sum is equal to x Since Vasilije is now in the weirdest city in Serbia where Aca and Milovan live Cacak the problem seems weird to him So he needs your help with this problem ,"['#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tlong long n, k, x;\n\t\tcin >> n >> k >> x;\n\t\tlong long l = k * (1 + k) / 2;\n\t\tlong long r = k * (n - k + 1 + n) / 2;\n\t\tcout << (x >= l && x <= r ? ""YES\\n"" : ""NO\\n"");\n\t}\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",900,It is clear that the minimum sum is obtained for the numbers and its value is the sum of the first natural numbers Furthermore it is evident that the maximum sum is achieved for the numbers and its value is the sum of all numbers from to minus the sum of all numbers from to elements Let s prove that among any numbers whose sum is not maximal there exists a number such that is not among those numbers Let s assume the opposite that is there exist numbers whose sum is not maximal and for each of those numbers is also among those numbers Let be the smallest among them Consequently is also among these numbers Since is in these numbers then is also among these numbers Similarly we can conclude that are all among these numbers However since we have of them these are the numbers that would yield the maximum sum This is a contradiction So among any numbers whose sum is not maximal there exists a number such that is not among those numbers Based on this starting from the minimum sum we can obtain by replacing the number with the sum increases by then from the sum we obtain the sum and so on Therefore by applying the principle of mathematical induction we can obtain any sum that is greater than or equal to minumum sum and less than or equal to maximum sum 
You are given an undirected connected graph with weighted edges The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path if some edge is traversed more than once then it is included in bitwise xor the same number of times There are three types of queries you have to process add an edge connecting vertex to vertex with weight It is guaranteed that there is no edge connecting to before this query remove an edge connecting vertex to vertex It is guaranteed that there was such edge in the graph and the graph stays connected after this query calculate the length of the shortest path possibly non simple from vertex to vertex Print the answers for all queries of type ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <pair<int, pii>> Vx[600000];\nvoid initupdate(int st, int en, int S, int E, int n, pair<int, pii> v) {\n\tif (en < S || E < st) return;\n\tif (st <= S && E <= en) {\n\t\tVx[n].push_back(v);\n\t\treturn;\n\t}\n\n\tint M = (S + E) / 2;\n\tinitupdate(st, en, S, M, 2 * n, v);\n\tinitupdate(st, en, M + 1, E, 2 * n + 1, v);\n}\n\n\nmap <pii, int> Mp;\nmap <pii, int> Mv;\nint Qu[200050][2];\n\nint val[30];\nint r[200050][2];\nint sz[200050];\n\nint cur = 0;\nvector <pair<pii, int>> Vr[600050];\nvector <pair<int, int>> Vsz[600050];\nvector <pair<int, int>> Vval[600050];\n\nvoid updateval(int x) {\n\tint i;\n\tfor (i = 29; i >= 0; i--) {\n\t\tif (x & (1 << i));\n\t\telse continue;\n\n\t\tif (val[i]) x ^= val[i];\n\t\telse {\n\t\t\tVval[cur].emplace_back(i, val[i]);\n\t\t\tval[i] = x;\n\t\t\treturn;\n\t\t}\n\t}\n}\npii root(int x) {\n\tint ro = x, v = 0;\n\twhile (ro != r[ro][0]) {\n\t\tv ^= r[ro][1];\n\t\tro = r[ro][0];\n\t}\n\treturn pii(ro, v);\n}\nvoid mymerge(int a, int b, int c) {\n\tpii u1 = root(a);\n\tpii u2 = root(b);\n\n\tint r1 = u1.first, r2 = u2.first;\n\tc ^= u1.second ^ u2.second;\n\tif (r1 != r2) {\n\t\tif (sz[r1] > sz[r2]) swap(r1, r2);\n\t\tVr[cur].emplace_back(pii(r1, 0), r[r1][0]);\n\t\tVr[cur].emplace_back(pii(r1, 1), r[r1][1]);\n\t\tVsz[cur].emplace_back(r2, sz[r2]);\n\t\tr[r1][0] = r2;\n\t\tr[r1][1] = c;\n\t\tsz[r2] += sz[r1];\n\t}\n\telse updateval(c);\n}\nvoid getans(int st, int en, int S, int E, int n) {\n\tif (en < S || E < st) return;\n\t\n\tcur = n;\n\tfor (auto it : Vx[n]) {\n\t\tint c = it.first, x = it.second.first, y = it.second.second;\n\t\tmymerge(x, y, c);\n\t}\n\tif (S == E) {\n\t\tint x = Qu[S][0], y = Qu[S][1];\n\t\tpii u1 = root(x), u2 = root(y);\n\t\t\n\t\tint c = u1.second ^ u2.second;\n\t\tfor (int i = 29; i >= 0; i--) {\n\t\t\tif (!(c & (1 << i))) continue;\n\t\t\tif (!val[i]) continue;\n\t\t\tc ^= val[i];\n\t\t}\n\t\tprintf(""%d\\n"", c);\n\t}\n\telse {\n\t\tint M = (S + E) / 2;\n\t\tgetans(st, en, S, M, 2 * n);\n\t\tgetans(st, en, M + 1, E, 2 * n + 1);\n\t}\n\treverse(all(Vr[n]));\n\treverse(all(Vsz[n]));\n\treverse(all(Vval[n]));\n\tfor (auto it : Vr[n]) r[it.first.first][it.first.second] = it.second;\n\tfor (auto it : Vsz[n]) sz[it.first] = it.second;\n\tfor (auto it : Vval[n]) val[it.first] = it.second;\n\tVr[n].clear();\n\tVsz[n].clear();\n\tVval[n].clear();\n}\n\nint ux[200050][4];\nint main() {\n\tint N, M, Q, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2, t3;\n\t\tscanf(""%d %d %d"", &t1, &t2, &t3);\n\t\tif (t1 > t2) swap(t1, t2);\n\t\tMp[pii(t1, t2)] = 1;\n\t\tMv[pii(t1, t2)] = t3;\n\t}\n\t\n\tint qc = 0, cc = 0;\n\tscanf(""%d"", &Q);\n\tfor (i = 1; i <= Q; i++) {\n\t\tscanf(""%d %d %d"", &ux[i][0], &ux[i][1], &ux[i][2]);\n\t\tif (ux[i][0] == 1) scanf(""%d"", &ux[i][3]);\n\t\tif (ux[i][0] == 3) cc++;\n\t}\n\tfor (IT_MAX = 2; IT_MAX <= cc; IT_MAX *= 2);\n\tfor(i = 1; i <= Q; i++) {\n\t\tint t1 = ux[i][0], t2 = ux[i][1], t3 = ux[i][2], t4 = ux[i][3];\n\t\tif (t2 > t3) swap(t2, t3);\n\t\tif (t1 == 1) {\n\t\t\tMp[pii(t2, t3)] = qc + 1;\n\t\t\tMv[pii(t2, t3)] = t4;\n\t\t}\n\t\telse if (t1 == 2) {\n\t\t\tint st = Mp[pii(t2, t3)], en = qc;\n\t\t\tinitupdate(st, en, 1, IT_MAX, 1, mp(Mv[pii(t2, t3)], pii(t2, t3)));\n\t\t\tMp.erase(pii(t2, t3));\n\t\t\tMv.erase(pii(t2, t3));\n\t\t}\n\t\telse if (t1 == 3) {\n\t\t\tqc++;\n\t\t\tQu[qc][0] = t2, Qu[qc][1] = t3;\n\t\t}\n\t}\n\tfor (auto it : Mp) initupdate(it.second, qc, 1, IT_MAX, 1, mp(Mv[it.first], it.first));\n\n\tfor (i = 1; i <= N; i++) r[i][0] = i, r[i][1] = 0, sz[i] = 1;\n\tgetans(1, qc, 1, IT_MAX, 1);\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 1]",2900,This is a more complex version of problem G from Educational Round 27 You can find its editorial here To solve the problem we consider now you have to use a technique known as dynamic connectivity Let s build a segment tree over queries each vertex of the segment tree will contain a list of all edges existing in the graph on the corresponding segment of queries If some edge exists from query l to query r then it s like an addition operation on segment l r in segment tree but instead of addition we insert this edge into the list of edges on a segment and we make no pushes Then if we write some data structure that will allow to add an edge and rollback operations we applied to the structure then we will be able to solve the problem by DFS on segment tree when we enter a vertex we add all edges in the list of this vertex when we are in a leaf we calculate the required answer for the corresponding moment of time and when we leave a vertex we rollback all changes we made there What data structure do we need Firstly we will have to use DSU maintaining the distance to the leader to maintain the length of some path between two vertices Don t use path compression this won t work well since we have to do rollbacks Secondly we have to maintain the base of all cycles in the graph since the graph is always connected it doesn t matter that some cycles may be unreachable by the time we get to leaves of the segment tree these cycles will become reachable so there s no need to store a separate base for each component A convenient way to store the base is to make an array of 30 elements initially filled with zeroes we denote this array as a i th element of the array will denote some number in a base such that i th bit is largest in the number Adding some number x to this base is really easy we iterate on bits from 29 th to 0 th and if some bit j is equal to 1 in x and a j 0 then we just set let s call this process reduction we will need it later If we get 0 after doing these operations then the number we tried to add won t affect the base and we don t need to do anything otherwise let k be the highmost bit equal to 1 in x and then we set a k x This method of handling the base of cycles also allows us to answer queries of type 3 easily firstly we pick the length of some path from DSU let it be p and secondly we just apply reduction to p and this will be our answer 
Nastia has 2 positive integers A and B She defines that The integer is good if it is divisible by A cdot B Otherwise the integer is nearly good if it is divisible by A For example if A 6 and B 4 the integers 24 and 72 are good the integers 6 660 and 12 are nearly good the integers 16 7 are neither good nor nearly good Find 3 positive integers x y and z such that of them is good and the 2 are nearly good and x y z ,"['#include <bits/stdc++.h>\n#define _FORTIFY_SOURCE 0\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""no-stack-protector"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native"")\n#pragma GCC optimize(""fast-math"")\n#define int long long\n\nusing namespace std;\n\nmt19937 rnd(time(nullptr));\n\nvoid solve() {\n   int a, b;\n   cin >> a >> b;\n   if (b == 1) {\n        cout << ""NO\\n"";\n        return;\n   }\n   if (b == 2) {\n        cout << ""YES\\n"";\n        cout << a << "" "" << 3 * a << "" "" << 4 * a << ""\\n"";\n        return;\n   }\n   cout << ""YES\\n"";\n   cout << a * (b - 1) << "" "" << a << "" "" << a * b << ""\\n"";\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1000,There are cases if then the answer doesn t exist Here we cannot get the nearly good numbers at all Otherwise we can construct the answer as 
You are given four integers n c 0 c 1 and h and a binary string s of length n A binary string is a string consisting of characters 0 and 1 You can change any character of the string s the string should be still binary after the change You should pay h coins for each change After some changes possibly zero you want to buy the string To buy the string you should buy all its characters To buy the character 0 you should pay c 0 coins to buy the character 1 you should pay c 1 coins Find the minimum number of coins needed to buy the string ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tint n, c0, c1, h;\n\t\tcin >> n >> c0 >> c1 >> h;\n\t\tstring s; cin >> s;\n\n\t\tint o = 0, z = 0;\n\t\tfor (char c: s) {\n\t\t\to += (c == '1');\n\t\t\tz += (c == '0');\n\t\t}\n\n\t\tint ans = o*c1 + z*c0;\n\t\tfor (int one = 0; one <= s.size(); one++) {\n\t\t\tint zero = s.size() - one;\n\t\t\tans = min(ans, one*c1 + zero*c0 + h*abs(o - one));\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\t\n\treturn 0;\n}\n""]","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",800,We will consider each character seperately Look at the th character if it is originally a we can either change it to a and pay coins for this specific character or we can not change it and pay coins for it Since we want to pay as little as possible we take the minimum of these two So if the th character is a we will have to pay coins for it A similar logic can be used for the zeroes if the th character is a we will have to pay coins So we iterate over and for each character we add the required minimum to the sum depending on whether it s a or Time complexity 
Polycarp has an integer n that doesn t contain the digit He can do the following operation with his number several possibly zero times Reverse the prefix of length l in other words l leftmost digits of n So the leftmost digit is swapped with the l th digit from the left the second digit from the left swapped with l 1 th left etc For example if n 123456789 and l 5 then the new value of n will be 543216789 Note that for different operations the values of l can be different The number l can be equal to the length of the number n in this case the whole number n is reversed Polycarp loves even numbers Therefore he wants to make his number even At the same time Polycarp is very impatient He wants to do as few operations as possible Help Polycarp Determine the minimum number of operations he needs to perform with the number n to make it even or determine that this is impossible You need to answer t independent test cases ,"['#include <bits/stdc++.h>\n//Make Even\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        std::string x;\n        std::cin>>x;\n        if(!(x[x.size()-1]&1)){\n            printf(""0\\n"");\n        }else{\n            if(!(x[0]&1)){\n                printf(""1\\n"");\n            }else {\n                for(auto&z:x){\n                    if(!(z&1)){\n                        printf(""2\\n"");\n                        goto prox;\n                    }\n                }\n                printf(""-1\\n"");\n            }\n        }\n        prox:{}\n    }\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",800,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations 
Piggy gave Turtle a dagger with n vertices and a sequence a 1 a 2 ldots a n on his birthday The binary tree is rooted at vertex 1 If a set of paths P x i y i in the tree covers each edge then Turtle will think that the set of paths is Note that a good set of paths can cover a vertex twice or more Turtle defines the of a set of paths as sum limits x y in P f x y where f x y denotes the text MEX ddagger of all a u such that vertex u is on the simple path from x to y in the tree including the starting vertex x and the ending vertex y Turtle wonders the value over all good sets of paths Please help him calculate the answer dagger A binary tree is a tree where every non leaf vertex has at most 2 sons ddagger text MEX of a collection of integers c 1 c 2 ldots c k is defined as the smallest integer x which does not occur in the collection c For example text MEX of 3 3 1 4 is 2 text MEX of 2 3 is 1 ,"[""#include<bits/stdc++.h>#define LL long long#define LLL __int128#define uint unsigned#define ldb long double#define uLL unsigned long longusing namespace std;const int N=2.5e4+5,M=4e3+5,INF=1e9;int n,m,ans,a[N],p[N];vector<int>G[N];int f[N][M];inline void dfs(int u,int fa){\tif(G[u].size()==0){\t\tfill(f[u]+1,f[u]+m+1,0),f[u][a[u]]=INF;\t\tif(!fa)ans=(a[u]==1)+1;\t}\telse if(G[u].size()==1){\t\tdfs(G[u][0],u);\t\tcopy(f[G[u][0]]+1,f[G[u][0]]+m+1,f[u]+1);\t\tf[u][a[u]]=INF;\t\tint z=INF;\t\tfor(int i=1;i<=m;++i)z=min(z,f[u][i]+i);\t\tif(!fa)ans=z;\t\tfor(int i=1;i<=m;++i)if(i!=a[u])f[u][i]=min(f[u][i],z);\t}\telse{\t\tdfs(G[u][0],u),f[G[u][0]][a[u]]=INF;\t\tdfs(G[u][1],u),f[G[u][1]][a[u]]=INF;\t\tint lz=INF,rz=INF,z=INF;\t\tfor(int i=1;i<=m;++i)lz=min(lz,f[G[u][0]][i]+i),rz=min(rz,f[G[u][1]][i]+i);\t\tz=min(z,lz+rz);\t\tfor(int i=1;i<=m;++i)\t\t\tif(i!=a[u])\t\t\t\tf[u][i]=min(f[G[u][0]][i]+rz,lz+f[G[u][1]][i]),\t\t\t\tz=min(z,f[G[u][0]][i]+f[G[u][1]][i]+i);\t\t\telse f[u][i]=INF;\t\tif(!fa)ans=z;\t\tfor(int i=1;i<=m;++i)if(i!=a[u])f[u][i]=min(f[u][i],z);\t}}inline void MAIN(){\tcin>>n,m=min(n+1,4000);\tfor(int i=1;i<=n;++i)cin>>a[i],G[i].clear(),a[i]=min(a[i],m);\tfor(int i=2;i<=n;++i)cin>>p[i],G[p[i]].emplace_back(i);\tdfs(1,0);\tcout<<ans<<'\\n';}signed main(){    cin.tie(0)->sync_with_stdio(0);\tint t=1;cin>>t;while(t--)MAIN();    return 0;}/**/""]","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",3000,Let s consider dp Let denote the path extending upward within the subtree rooted at with the condition that this path does not include the value The value of ranges from In this case we can directly take the MEX of this path as because if the MEX is not then the MEX will be smaller making this dp state suboptimal Let denote the minimum result of the of a path that extends outside the subtree of and is specified to be where is not included in the result Since the of each path does not exceed the values of range from to Consider all the transitions for the dp If is a leaf then If has only one child let the child be Let then If has two children let the children be and Let and There are four possible transitions Continuing the path from the subtree of i e Continuing the path from the subtree of i e Creating a new path and merging the paths from both subtrees i e Creating a new path without merging the paths from the two subtrees i e Let then the transition can be written as follows This results in a time complexity of In fact we can prove that we only need to consider MEX values up to for we only need to consider MEX values up to Therefore the second dimension of the dp only needs to be enumerated up to or Also we have a construction of a chain that can achieve the MEX value of which is enumerating from and listing all the divisors of in descending order such as Time complexity per test case Proof of the upper bound for MEX Let s only consider the case of a chain For a fixed consider a sequence like We can divide it into segments as follows Where segments without have a MEX value and segments with have a MEX value Let be the answer Then satisfies where is the number of occurrences of Expanding we get Furthermore for segments like if then the term above can be reduced to since can be none of So we have Hence This means we need occurrences of and since we have We also have By fixing we can binary search for the largest satisfying the above condition and for we find 
There is a rectangular grid of rows of initially white cells each Arkady performed a certain number possibly zero of operations on it In the th operation a non empty subset of rows and a non empty subset of columns are chosen For each row in and each column in the intersection of row and column is coloured black There s another constraint a row or a column can only be chosen at most once among all operations In other words it means that no pair of exists such that or where denotes intersection of sets and denotes the empty set You are to determine whether a valid sequence of operations exists that produces a given final grid ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 55;\nchar s[N][N];\nbool u1[N], u2[N];\nint n, m;\nbool a[N], b[N];\n\nvoid dfsX(int x);\nvoid dfsY(int y);\n\nvoid dfsX(int x) {\n\tu1[x] = 1;\n\ta[x] = 1;\n\tfor (int y = 0; y < m; y++)\n\t\tif (!u2[y] && s[x][y] == \'#\')\n\t\t\tdfsY(y);\n}\nvoid dfsY(int y) {\n\tu2[y] = 1;\n\tb[y] = 1;\n\tfor (int x = 0; x < n; x++)\n\t\tif (!u1[x] && s[x][y] == \'#\')\n\t\t\tdfsX(x);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%s"", s[i]);\n\tfor (int x = 0; x < n; x++) {\n\t\tif (u1[x]) continue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tb[i] = 0;\n\t\tdfsX(x);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (!a[i] || !b[j]) continue;\n\t\t\t\tif (s[i][j] != \'#\') {\n\t\t\t\t\tprintf(""No\\n"");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(""Yes\\n"");\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,No row or column can be selected more than once hence whenever a row r is selected in an operation all cells in it uniquely determine the set of columns that need to be selected let s call it Sr Let s assume a valid set of operations exists Take out any two rows i and j If rows i and j are selected in the same operation we can deduce that Si Sj if they re in different operations we get Therefore if Si Sj and hold for any pair of rows i j no valid operation sequence can be found Otherwise no pair violates the condition above a valid sequence of operations can be constructed group all rows with the same S s and carry out an operation with each group Thus it s a necessary and sufficient condition for the answer to be Yes that for each pair of rows i j either Si Sj or holds The overall complexity is O n2m It can be divided by the system s word size if you re a bitset enthusiast and a lot more if hashes and hash tables release their full power 
You are given a permutation p consisting of n integers 1 2 dots n a permutation is an array where each element from 1 to n occurs exactly once Let s call an array a if the following undirected graph is bipartite the graph consists of n vertices two vertices i and j are connected by an edge if i j and a i a j Your task is to find a array of integers a of size n such that a i p i or a i p i or report that no such array exists If there are multiple answers print any of them ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T_vector>\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end = int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\n\nconst int INF = int(1e9) + 5;\n\nstruct state {\n    int high = -INF, low = -INF;\n    int previous = -1, a = 0;\n\n    bool operator<(const state &other) const {\n        if (high != other.high)\n            return high < other.high;\n\n        return low < other.low;\n    }\n\n    pair<state, bool> add(int from, int x) {\n        if (x < low)\n            return {state(), false};\n\n        state sum = *this;\n        sum.previous = from;\n        sum.a = x;\n\n        if (x > high)\n            sum.high = x;\n        else\n            sum.low = x;\n\n        return {sum, true};\n    }\n};\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> P(N);\n\n    for (auto &p : P)\n        cin >> p;\n\n    vector<vector<state>> dp(N + 1);\n    dp[0] = {state()};\n\n    for (int i = 0; i < N; i++) {\n        for (int x : {-P[i], P[i]})\n            for (int j = 0; j < int(dp[i].size()); j++) {\n                state s = dp[i][j];\n                pair<state, bool> result = s.add(j, x);\n\n                if (result.second)\n                    dp[i + 1].push_back(result.first);\n            }\n\n        sort(dp[i + 1].begin(), dp[i + 1].end());\n        vector<state> filtered;\n\n        for (state s : dp[i + 1]) {\n            bool bad = false;\n\n            for (state f : filtered)\n                if (f.low <= s.low && f.high <= s.high)\n                    bad = true;\n\n            if (!bad)\n                filtered.push_back(s);\n        }\n\n        dp[i + 1] = filtered;\n    }\n\n    if (dp.back().empty()) {\n        cout << ""NO"" << \'\\n\';\n        return;\n    }\n\n    cout << ""YES"" << \'\\n\';\n    vector<int> A(N);\n    int index = 0;\n\n    for (int i = N - 1; i >= 0; i--) {\n        state s = dp[i + 1][index];\n        A[i] = s.a;\n        index = s.previous;\n    }\n\n    output_vector(A);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2800,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter 
Dasha and NN like playing chess While playing a match they decided that normal chess isn t interesting enough for them so they invented a game described below There are 666 black rooks and 1 white king on the chess board of size 999 times 999 The white king wins if he gets checked by rook or in other words if he moves onto the square which shares either a row or column with a black rook The sides take turns starting with white NN plays as a white king and on each of his turns he moves a king to one of the squares that are adjacent to his current position either by side or diagonally or formally if the king was on the square x y it can move to the square nx ny if and only max nx x ny y 1 1 leq nx ny leq 999 NN is also forbidden from moving onto the squares occupied with black rooks however he can move onto the same row or column as a black rook Dasha however neglects playing by the chess rules and instead of moving rooks normally she moves one of her rooks on any space devoid of other chess pieces It is also possible that the rook would move onto the same square it was before and the position wouldn t change However she can t move the rook on the same row or column with the king Each player makes 2000 turns if the white king wasn t checked by a black rook during those turns black wins NN doesn t like losing but thinks the task is too difficult for him so he asks you to write a program that will always win playing for the white king Note that Dasha can see your king and play depending on its position ,"['#include<bits/stdc++.h>\n#define MAXN 1005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint x,y,k,xx,yy;\nbool rook[MAXN][MAXN];\nP rk[MAXN];\nvoid mov(int dx,int dy)\n{\n    if(dx!=0&&dy!=0&&rook[x+dx][y+dy])\n    {\n        assert(!rook[x][y+dy]);\n        printf(""%d %d\\n"",x,y+dy);\n        y=y+dy;\n        fflush(stdout);\n        scanf(""%d%d%d"",&k,&xx,&yy);\n        assert(k==-1);\n        exit(0);\n    }\n    printf(""%d %d\\n"",x+dx,y+dy);\n    fflush(stdout);\n    x+=dx;y+=dy;\n    scanf(""%d%d%d"",&k,&xx,&yy);\n    if(k==-1) exit(0);\n    rook[rk[k].F][rk[k].S]=false;\n    rook[xx][yy]=true;\n    rk[k]=P(xx,yy);\n}\nint main()\n{\n    scanf(""%d%d"",&x,&y);\n    for(int i=1;i<=666;i++)\n    {\n        scanf(""%d%d"",&xx,&yy);\n        rook[xx][yy]=true;\n        rk[i]=P(xx,yy);\n    }\n    while(x<500) mov(1,0);\n    while(x>500) mov(-1,0);\n    while(y<500) mov(0,1);\n    while(y>500) mov(0,-1);\n    int cnt0=0,cnt1=0,cnt2=0,cnt3=0;\n    for(int i=1;i<=666;i++)\n    {\n        if(rk[i].F>=500||rk[i].S<=500) cnt0++;\n        if(rk[i].F>=500||rk[i].S>=500) cnt1++;\n        if(rk[i].F<=500||rk[i].S>=500) cnt2++;\n        if(rk[i].F<=500||rk[i].S<=500) cnt3++;\n    }\n    if(cnt0>=500) while(true) mov(1,-1);\n    if(cnt1>=500) while(true) mov(1,1);\n    if(cnt2>=500) while(true) mov(-1,1);\n    if(cnt3>=500) while(true) mov(-1,-1);\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2500,One of the possible strategies the king goes to the center then goes to the corner that he has as few rooks as possible behind his back The solution uses the Pigeonhole principle since in the largest corner and in two neighbors to it the sum will be no less than rooks i e rooks and since the king gets to the corner for of moves he will definitely get under check of the rook 
Misha and Vasya participated in a Codeforces contest Unfortunately each of them solved only one problem though successfully submitted it at the first attempt Misha solved the problem that costs points and Vasya solved the problem that costs points Besides Misha submitted the problem minutes after the contest started and Vasya submitted the problem minutes after the contest started As you know on Codeforces the cost of a problem reduces as a round continues That is if you submit a problem that costs points minutes after the contest started you get points Misha and Vasya are having an argument trying to find out who got more points Help them to find out the truth ,"['/*\n    Look at me!\n    Look at me!\n    Look at how large the monster inside me has become!\n*/\n\n#include<fstream>\n#include<iostream>\n#include<cstdio>\n#include<map>\n#include<set>\n#define FIT(a,b) for(vector<int >::iterator a=b.begin();a!=b.end();a++)\n#define FITP(a,b) for(vector<pair<int,int> >::iterator a=b.begin();a!=b.end();a++)\n#define RIT(a,b) for(vector<int>::reverse_iterator a=b.end();a!=b.begin();++a)\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#define REP(a,b) for(register int a=0;a<b;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<ctime>\n#define f cin\n#define g cout\n#include<queue>\n#define debug cerr<<""OK"";\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define ull unsigned long long\n#define mod 666013\n#define inf 1<<30\n#define N 200100\n#define DIM 10000000\nusing namespace std;\n/*int dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};*/\n\ndouble a,b,c,d,x,y;\n\nint main ()\n{\n\n    #ifndef ONLINE_JUDGE\n    freopen(""a.in"",""r"",stdin);\n    freopen(""a.out"",""w"",stdout);\n    #endif\n\n    f>>a>>b>>c>>d;\n\n    x=max(3*a/10,a-a/250*c);\n    y=max(3*b/10,b-b/250*d);\n\n    if(x==y)\n    g<<""Tie"";\n    if(x>y)\n    g<<""Misha"";\n    if(x<y)\n    g<<""Vasya"";\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,In this problem one need to determine the number of points for both guys and find out who got more points Time complexity 
A girl is preparing for her birthday and wants to buy the most beautiful bouquet There are a total of n different types of flowers in the store each of which is characterized by the number of petals and the quantity of this type of flower A flower with k petals costs k coins The girl has decided that the difference in the number of petals between any two flowers she will use to decorate her cake should not exceed one At the same time the girl wants to assemble a bouquet with the maximum possible number of petals Unfortunately she only has m coins and she cannot spend more What is the maximum total number of petals she can assemble in the bouquet ,"['#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/trie_policy.hpp>using namespace std;using namespace __gnu_pbds;typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;#ifndef ONLINE_JUDGE    #include ""debug.h""#else    #define dbg(...) 42    template<typename T>ostream&operator<<(ostream&os,vector<T>&vec){for(signed i=0;i+1<vec.size();++i){os<<vec[i]<<"" "";}if(vec.size()>0)os<<vec.back();return os;}#endif\xa0#define all(x) x.begin(), x.end()#define rall(x) x.rbegin(), x.rend()\xa0template<typename T>istream&operator>>(istream&is,vector<T>&vec){for(T&element:vec){is>>element;}return is;}template<typename T>void chmin(T&x,T y){x=min(x,y);}template<typename T>void chmax(T&x,T y){x=max(x,y);}\xa0#define int int64_t\xa0void test_case(signed ___) {    int64_t n, m;    cin >> n >> m;    vector<int> ar(n);    cin >> ar;\xa0    vector<int> c(n);    cin >> c;\xa0    map<int64_t, int64_t> mp;    for (int i = 0; i < n; ++i) {        mp[ar[i]] = c[i];    }\xa0    int64_t res = 0;\xa0    for (auto [x, y] : mp) {        int64_t can_buy_first = min(y, m/x);        int64_t nxt = x+1;        int64_t can_buy_second = 0;        if (mp.count(nxt)) {            can_buy_second = mp[x+1];        }        int64_t bought_second = min((m-can_buy_first*x)/nxt, can_buy_second);        int64_t need_inc = m - can_buy_first*x - bought_second*nxt;        int64_t can_sub = min(can_buy_first, can_buy_second-bought_second);        can_sub = min(can_sub, need_inc);        int64_t now = can_buy_first*x + bought_second*nxt + can_sub;        res = max(res, now);    }    cout << res << ""\\n"";}\xa0signed main(void) {    cin.tie(0)->sync_with_stdio(false);\xa0    signed tt = 1;    cin >> tt;    while (tt--)     test_case(69420);}']","[1, 1, 0, 0, 1, 0, 0, 1, 1, 0]",1700,SolutionWe already have a list of We can use hash map to be able to check for any by We again will try to assemble the bouquet only with flowers with petals We set Then we have Let s set Then we have Let s substitute flower with petals with flower with petals as many times as we can This can be done times as each operation will require us 1 coin 1 flower in the bouquet with petals and one 1 flower with petals not in the bouquet In total we can get petals This assembling is optimal Here is why Suppose that we have flowers with petals and flowers with petals and greater total value of We already know that by choosing of If then we can undo our operation times sum is still not greater than and we know that now there can t be more than flowers with petals as otherwise we didn t chose optimal If then if then it is just the case when we have only flowers with petals which will be considered in case if then and we already found the maximum So and and is not better than optimal Total time complexity is 
There are n programmers that you want to split into several non empty teams The skill of the i th programmer is a i You want to assemble the maximum number of teams from them There is a restriction for each team the number of programmers in the team multiplied by the minimum skill among all programmers in the team must be at least x Each programmer should belong to at most one team Some programmers may be left without a team Calculate the maximum number of teams that you can assemble ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; ll K; cin >> N >> K;\n        vl A(N); F0R(i, N) cin >> A[i];\n        sort(all(A)); reverse(all(A));\n\n        int cnt = 0;\n        ll ans = 0;\n        F0R(i, N) {\n            ll X = (K + A[i] - 1) / A[i];\n            X--;\n            if (cnt >= X) {\n                cnt -= X; ans++;\n            } else {\n                cnt++;\n            }\n        }\n        cout << ans << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[1, 0, 1, 1, 0, 1, 0, 0, 1, 0]",1400,At first notice that if only programmers are taken then the same or even better answer can be achieved if strongest programmers are taken Now let s sort the programmers in a non increasing order and choose some assignment into the teams For each team only the rightmost taken programmer of that team matters the sorted sequence implies that the rightmost is the weakest Take a look at the team with the strongest weakest member If the number of programmers in it is less than the position of the weakest member then you can safely rearrange the programmers before him in such a way that none of parameters of later teams change and the weakest member in the first one only becomes stronger After that you can get rid of the first team as it takes exactly the prefix of all the programmers and proceed to fix the later teams Thus we can see that there is an optimal solution such that each team is a segment and all the teams together take some prefix of the programmers So we can finally run a greedy solution that takes programmers from left to right and increases the answer if the conditions for the latest team hold Overall complexity 
You are given an array a of n positive integers numbered from 1 to n Let s call an array if for any two not necessarily different numbers x and y from this array x ge y the number left lfloor frac x y right rfloor x divided by y with rounding down is also in this array You are guaranteed that all numbers in a do not exceed c Your task is to check whether this array is integral ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, c;\n    std::cin >> n >> c;\n    \n    std::vector<int> cnt(c + 1), sum(c + 1);\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        cnt[x]++;\n    }\n    for (int i = 1; i <= c; i++) {\n        sum[i] = sum[i - 1] + cnt[i];\n    }\n    \n    for (int y = 1; y <= c; y++) {\n        if (!cnt[y]) {\n            continue;\n        }\n        \n        for (int i = 1; i * y <= c; i++) {\n            int r = std::min(c, i * y + y - 1);\n            if (sum[r] - sum[i * y - 1] > 0) {\n                if (cnt[i] == 0) {\n                    std::cout << ""No\\n"";\n                    return;\n                }\n            }\n        }\n    }\n    \n    std::cout << ""Yes\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 1, 0, 0, 1, 1, 1, 0, 0, 0]",1800,Let s consider and If then but is not in so the answer is No Let s suggest that and are already given We can check if there exists such from the mentioned segment in It is done by considering array the amount of occurrences of in and prefix sums for that array Now we only need to run this check for each and To do that we can iterate through all and in increasing order If then there is definitely no such so we can consider the next This optimization speeds up the process and makes the whole solution work in 
Connected undirected graph without cycles is called a tree Trees is a class of graphs which is interesting not only for people but for ants too An ant stands at the root of some tree He sees that there are vertexes in the tree and they are connected by edges so that there is a path between any pair of vertexes A leaf is a distinct from root vertex which is connected with exactly one other vertex The ant wants to visit every vertex in the tree and return to the root passing every edge twice In addition he wants to visit the leaves in a specific order You are to find some possible route of the ant ,"['/*\nID: espr1t\nLANG: C++\nTASK: Demo\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 1024\n\nusing namespace std;\nFILE *in; FILE *out;\n\n\nint n, idx;\nvector <int> order, ans;\nmap < int, int > level;\nmap < int, vector <int> > v;\nmap < int, set <int> > children;\n\nvoid getLevels(int node, int lvl)\n{\n\tlevel[node] = lvl;\n\tfor (int i = 0; i < (int)v[node].size(); i++)\n\t\tif (level.find(v[node][i]) == level.end())\n\t\t\tgetLevels(v[node][i], lvl + 1);\n}\n\nvoid getChildren(int node)\n{\n\tfor (int i = 0; i < (int)v[node].size(); i++)\n\t{\n\t\tif (level[v[node][i]] > level[node])\n\t\t{\n\t\t\tchildren[node].insert(v[node][i]);\n\t\t\tgetChildren(v[node][i]);\n\t\t\tchildren[node].insert(children[v[node][i]].begin(), children[v[node][i]].end());\n\t\t}\n\t}\n}\n\nvoid recurse(int node)\n{\n\tans.push_back(node);\n\tif (ans.size() > (n - 1) * 2 + 1) return;\n\n//\tcout << ""Currently at node "" << node << endl;\n\twhile (idx < (int)order.size())\n\t{\n\t\tint found = 0;\n\t\tif (ans.size() > (n - 1) * 2 + 1) return;\n\t\tfor (int i = 0; i < (int)v[node].size(); i++) if (level[v[node][i]] > level[node])\n\t\t{\n//\t\t\tcout << ""Trying child "" << v[node][i] << endl;\n\t\t\tif (v[node][i] == order[idx])\n\t\t\t{\n\t\t\t\tans.push_back(v[node][i]);\n\t\t\t\tans.push_back(node);\n\t\t\t\tidx++; found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (children[v[node][i]].find(order[idx]) != children[v[node][i]].end())\n\t\t\t\t{\n\t\t\t\t\tfound = 1;\n\t\t\t\t\trecurse(v[node][i]);\n\t\t\t\t\tans.push_back(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found) break;\n\t}\n}\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(""D.in"", ""rt""); out = fopen(""D.out"", ""wt"");\n\t\n\tfscanf(in, ""%d"", &n);\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint n1, n2;\n\t\tfscanf(in, ""%d %d"", &n1, &n2);\n\t\tv[n1].push_back(n2);\n\t\tv[n2].push_back(n1);\n\t}\n\t\n\tgetLevels(1, 0);\n\tgetChildren(1);\n\t\n\t/*\n\tfor (map <int, set <int> > :: iterator it = children.begin(); it != children.end(); it++)\n\t{\n\t\tcout << ""Children for node "" << it->first << "":"";\n\t\tfor (set <int> :: iterator it2 = it->second.begin(); it2 != it->second.end(); it2++)\n\t\t\tcout << "" "" << *it2;\n\t\tcout << endl; \n\t}\n\tsystem(""pause"");\n\t*/\n\n\tint numLeafs = 0;\n\tfor (map < int, set <int> > :: iterator it = children.begin(); it != children.end(); it++)\n\t\tif (it->second.size() == 0) numLeafs++;\n\n\tfor (int i = 0; i < numLeafs; i++)\n\t{\n\t\tint cur;\n\t\tfscanf(in, ""%d"", &cur);\n\t\torder.push_back(cur);\n\t}\n\tidx = 0;\n\trecurse(1);\n\tif (ans.size() != (n - 1) * 2 + 1)\n\t\tfprintf(out, ""-1\\n"");\n\telse\n\t{\n\t\tfor (int i = 0; i < (int)ans.size(); i++)\n\t\t\tfprintf(out, ""%d%c"", ans[i], i + 1 == (int)ans.size() ? \'\\n\' : \' \');\n\t}\n\t/*\n\tcout << ""Found answer:"";\n\tfor (int i = 0; i < (int)ans.size(); i++)\n\t\tcout << "" "" << ans[i]; cout << endl;\n\tsystem(""pause"");\n\t*/\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2000,First Floyd pretreat the path from I to J and save the path Then get the answer The order is a1 a2 ak K is the number of the leaves we can assume a0 ak 1 1 the root then answer push back the path ai ai 1 if the ans size 2 N 1 cout 1 else cout the answer 
You are given an integer sequence a 1 a 2 dots a n Find the number of pairs of indices l r 1 le l le r le n such that the value of median of a l a l 1 dots a r is exactly the given number m The median of a sequence is the value of an element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if a 4 2 7 5 then its median is 4 since after sorting the sequence it will look like 2 4 5 7 and the left of two middle elements is equal to 4 The median of 7 1 2 9 6 equals 6 since after sorting the value 6 will be in the middle of the sequence Write a program to find the number of pairs of indices l r 1 le l le r le n such that the value of median of a l a l 1 dots a r is exactly the given number m ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n , m;\nint a[400020 + 5];\nconst int MAXN = (2e5 + 20) * 25;\n  struct Node {\n    int val, size;\n    Node *ls, *rs;\n    Node(int _val, int _size, Node *_ls, Node *_rs) : val(_val), size(_size), ls(_ls), rs(_rs) {}\n    Node() {}\n    inline void pushup() {\n      if (!ls->size) return ;\n      val = rs->val, size = ls->size + rs->size;\n    }\n  } pool[MAXN<<1], *st[MAXN<<1], *root, *null;\nstruct LFT {\n  int cnt;\n  inline Node *newNode(int val, int size, Node *ls, Node *rs) {\n    return &(*st[cnt++] = Node(val, size, ls, rs));\n  }\n  inline Node *merge(Node *ls, Node *rs) {\n    return newNode(rs->val, ls->size + rs->size, ls, rs);\n  }\n  inline void maintain(Node *cur) {\n    Node *&ls = cur->ls, *&rs = cur->rs;\n    if (ls->size > rs->size * 4)\n      rs = merge(ls->rs, rs), st[--cnt] = ls, ls = ls->ls;\n    if (rs->size > ls->size * 4)\n      ls = merge(ls, rs->ls), st[--cnt] = rs, rs = rs->rs;\n  }\n  void insert(Node *cur, int x) {\n    if (cur->size == 1)\n      cur->ls = newNode(min(cur->val, x), 1, null, null),\n           cur->rs = newNode(max(cur->val, x), 1, null, null);\n    else insert(x > cur->ls->val ? cur->rs : cur->ls, x);\n    cur->pushup();\n    maintain(cur);\n  }\n  int kth(Node *cur, int x) {\n    if (cur->size == 1) return cur->val;\n    return x > cur->ls->size ? kth(cur->rs, x - cur->ls->size): kth(cur->ls, x);\n  }\n  int Rank(Node *cur, int x) {\n    if (cur->size == 1) return x > cur->val;\n    return x > cur->ls->val ? Rank(cur->rs, x) + cur->ls->size : Rank(cur->ls, x);\n  }\n  LFT(){for(int i = 0; i < (MAXN<<1); ++i) st[i] = &pool[i]; root = new Node(2147483647, 1, null, null); null = new Node(0, 0, 0, 0);}\n}T;\nstruct seg\n{\n    int l , r;\n    Node *rt;\n}node[400020 * 4];\nvoid build(int u,int l,int r)\n{\n    node[u].l = l , node[u].r = r;\n    node[u].rt = NULL;\n    if(l == r) {a[l] = u;return;}\n    build(u<<1 , l , (l + r) >> 1);\n    build(u<<1|1 , ((l + r) >> 1) + 1 , r);\n    return;\n}\nvoid upd(int u,int v)\n{\n    while(u){\n        if(!node[u].rt) node[u].rt = T.newNode(v , 1 , null , null);\n        else T.insert(node[u].rt , v);\n        //printf(""INS %d %d %d\\n"",node[u].l,node[u].r,v);\n        u >>= 1;\n    }\n    return;\n}\nint Query(int u,int l,int r,int v)\n{\n    if(r < l) return 0;\n    if(node[u].l == l && node[u].r == r){\n        //printf(""Q %d %d %d\\n"",l,r,v);\n        if(!node[u].rt) return 0;\n        return T.Rank(node[u].rt , v+1);\n    }\n    if(r <= node[u<<1].r) return Query(u<<1 , l , r , v);\n    else if(l >= node[u<<1|1].l) return Query(u<<1|1 , l , r , v);\n    else return Query(u<<1 , l , node[u<<1].r , v) + Query(u<<1|1 , node[u<<1|1].l , r , v);\n}\nint main()\n{\n    //freopen(""in.txt"",""r"",stdin);\n    scanf(""%d%d"",&n,&m);\n    int x = 0, y = 0, L = 0;\n    build(1 , 1 , n*2 + 6);\n    long long ans = 0;\n    for(int i = 1;i <= n;i++){\n        upd(a[n*2 + 2 - (x*2 - L + n + 1)], n*2 + 2 - (y*2 - L + n + 1));\n        //printf(""  UPD %d %d\\n"",x*2-L+n+1,y*2-L+n+1);\n        int p;scanf(""%d"",&p);\n        if(p < m) x++;\n        else if(p > m) y++;\n        L++;\n        int pp = 0;\n        pp = Query(1 , 1 , n*2 + 2 - (x*2 - L + n + 2) , n*2 + 2 -(y*2 - L + n + 1));\n        ans += pp;\n        //printf(""         AT %d %d\\n"",i,pp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2400,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in 
Calculate the minimum number of characters you need to change in the string so that it contains at least different letters or print that it is impossible String consists only of lowercase Latin letters and it is allowed to change characters only to lowercase Latin letters too ,"['#include<cstdio>\n#include<cstring>\nint l, cnt[128], c,k;\nchar s[1001];\nint main() {\n    scanf(""%s%d"", s, &k);\n    int i = 0;\n    for (; s[i]; i++) if (!cnt[s[i]]++) c++;\n    if (i < k) puts(""impossible"");\n    else printf(""%d\\n"", k>c?k - c:0);\n    return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1000,One could note what in case we should always print Overwise the finding value is equal where is a number of different letters in the original string It is correct because if condition is satisfied and we shouldn t do anything so the answer is zero If we could change duplicated letters to a different letters initially weren t contained in Solution complexity is 
You have a given integer n Find the number of ways to fill all 3 times n tiles with the shape described in the picture below Upon filling no empty spaces are allowed Shapes cannot overlap This picture describes when n 4 The left one is the shape and the right one is 3 times n tiles ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\n\n\nint main()\n{\n\tint n;\n\tscanf(""%d"",&n);\n\tprintf(""%lld\\n"",n&1?0:(1ll<<n/2));\n\treturn 0;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1000,If you want to have no empty spaces on tiles you should fill leftmost bottom tile Then you have only 2 choices Both cases force you to group leftmost tiles and fill By this fact we should group each tiles and fill independently So the answer is if is odd then the answer is impossible otherwise the answer is Time complexity is with bit operation or with iteration 
Seyyed and MoJaK are friends of Sajjad Sajjad likes a permutation Seyyed wants to change the permutation in a way that Sajjad won t like it Seyyed thinks more swaps yield more probability to do that so he makes MoJaK to perform a swap between every pair of positions where exactly once MoJaK doesn t like to upset Sajjad Given the permutation determine whether it is possible to swap all pairs of positions so that the permutation stays the same If it is possible find how to do that ,"['#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nvector<pii> ans4 = {{0, 1}, {0, 2}, {1, 3}, {0, 3}, {1, 2}, {2, 3}};\nvector<pii> ans5 = {{0, 1},\n{0, 2},\n{0, 3},\n{1, 2},\n{1, 4},\n{2, 4},\n{0, 4},\n{2, 3},\n{1, 3},\n{3, 4}};\nint sh44[] = {0, 3, 1, 2};\nvector<pii> ans44;\nvector<pii> ans45;\n\nvector<pii> ans;\n\nvoid sh(vi v, vector<pii> p) {\n    for (pii q: p) ans.pb({v[q.fi], v[q.se]});\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    forn(i, 4) forn(j, 4) ans44.pb({j, 4 + (j + sh44[i]) % 4});\n\n    int n;\n    cin >> n;\n    int m = n % 4;\n    if (m != 0 && m != 1) {\n        cout << ""NO\\n"";\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i += 4) {\n        vi v;\n        forn(j, 4) v.pb(i + j);\n        if (n % 4) v.pb(n - 1);\n        sh(v, n % 4 ? ans5 : ans4);\n        for (int j = 0; j < i; j += 4) {\n            vi u;\n            forn(k, 4) u.pb(i + k);\n            forn(k, 4) u.pb(j + k);\n            sh(u, ans44);\n        }\n    }\n\n    cout << ""YES\\n"";\n    for (pii p: ans) {\n        if (p.fi > p.se) swap(p.fi, p.se);\n        cout << p.fi + 1 << \' \' << p.se + 1 << \'\\n\';\n    }\n\n/*    vi a(n);\n    forn(i, n) a[i] = i;\n    vi c = a;\n    for (pii p: ans) {\n        assert(p.fi != p.se);\n        swap(a[p.fi], a[p.se]);\n    }\n    assert(set<pii>(all(ans)).size() == n * (n - 1) / 2);\n    assert(a == c);*/\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3100,If then it is simply provable the answer is NO So we just need to check There is a constructive solution to do that Assume that Partition numbers to classes each class contains a consecutive numbers We can solve each class itself by these swaps to reach the same permutation We can do swaps between two different classes as follows to reach the same permutation assume that the first element of the first class is and for the second class is Now assume that Do the swaps above with first numbers with these changes in place of swaps in the classes itself to satisfy the last number 
n ships set out to explore the depths of the ocean The ships are numbered from 1 to n and follow each other in ascending order the i th ship has a durability of a i The Kraken attacked the ships k times in a specific order First it attacks the first of the ships then the last then the first again and so on Each attack by the Kraken reduces the durability of the ship by 1 When the durability of the ship drops to 0 it sinks and is no longer subjected to attacks thus the ship ceases to be the first or last and the Kraken only attacks the ships that have not yet sunk If all the ships have sunk the Kraken has nothing to attack and it swims away For example if n 4 k 5 and a 1 2 4 3 the following will happen The Kraken attacks the first ship its durability becomes zero and now a 2 4 3 The Kraken attacks the last ship now a 2 4 2 The Kraken attacks the first ship now a 1 4 2 The Kraken attacks the last ship now a 1 4 1 The Kraken attacks the first ship its durability becomes zero and now a 4 1 How many ships were sunk after the Kraken s attack ,"['#include<bits/stdc++.h>#define int long longusing namespace std;class Segment_Tree{public:\tstruct tree{\t\tint l,r,sum,maxx,minx,flag;\t}tr[800005];\tvoid pushup(int u){\t\ttr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\t\ttr[u].maxx=max(tr[u<<1].maxx,tr[u<<1|1].maxx);\t\ttr[u].minx=min(tr[u<<1].minx,tr[u<<1|1].minx);\t}\tvoid pushdown(int u){\t\tif(tr[u].flag){\t\t\ttr[u<<1].sum+=tr[u].flag*(tr[u<<1].r-tr[u<<1].l+1),tr[u<<1].maxx+=tr[u].flag,tr[u<<1].minx+=tr[u].flag,tr[u<<1].flag+=tr[u].flag;\t\t\ttr[u<<1|1].sum+=tr[u].flag*(tr[u<<1|1].r-tr[u<<1|1].l+1),tr[u<<1|1].maxx+=tr[u].flag,tr[u<<1|1].minx+=tr[u].flag,tr[u<<1|1].flag+=tr[u].flag;\t\t\ttr[u].flag=0;\t\t}\t}\tvoid build(int u,int l,int r){\t\tif(l==r){\t\t\ttr[u]={l,r,0,0,0,0};\t\t\treturn;\t\t}\t\ttr[u]={l,r};\t\tint mid=l+r>>1;\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\t\tpushup(u);\t}\tvoid change(int u,int l,int r,int k){\t\tif(l>r)return;\t\tif(tr[u].l>=l&&tr[u].r<=r){\t\t\ttr[u].sum+=k*(tr[u].r-tr[u].l+1);\t\t\ttr[u].maxx+=k,tr[u].minx+=k;\t\t\ttr[u].flag+=k;\t\t\treturn;\t\t}\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1;\t\tif(l<=mid)change(u<<1,l,r,k);\t\tif(r>mid)change(u<<1|1,l,r,k);\t\tpushup(u);\t}\tint query_sum(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=0;\t\tif(l<=mid)res+=query_sum(u<<1,l,r);\t\tif(r>mid)res+=query_sum(u<<1|1,l,r);\t\treturn res;\t}\tint query_max(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].maxx;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=-1e18;\t\tif(l<=mid)res=max(res,query_max(u<<1,l,r));\t\tif(r>mid)res=max(res,query_max(u<<1|1,l,r));\t\treturn res;\t}\tint query_min(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].minx;;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=1e18;\t\tif(l<=mid)res=min(res,query_min(u<<1,l,r));\t\tif(r>mid)res=min(res,query_min(u<<1|1,l,r));\t\treturn res;\t}}sgt;int t,n,k,a[200005];signed main(){\tcin>>t;\twhile(t--){\t\tcin>>n>>k;\t\tfor(int i=1;i<=n;i++)cin>>a[i];\t\tint l=1,r=n,cnt=0;\t\twhile(k>0&&l<r){\t\t\tint aa=min(a[l],a[r]);\t\t\tif(a[l]==aa&&2*aa==k+1)cnt++,k=0;\t\t\telse if(2*aa>k)k=0;\t\t\telse{\t\t\t\tif(a[l]==aa&&a[r]==aa)cnt+=2,l++,r--;\t\t\t\telse if(a[l]==aa)cnt++,l++,a[r]-=aa;\t\t\t\telse cnt++,r--,a[l]-=aa;\t\t\t\tk-=2*aa;\t\t\t}\t\t}\t\tif(l==r&&k>=0){\t\t\tif(a[l]<=k)cnt++;\t\t}\t\tcout<<cnt<<""\\n"";\t}}']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1300,To solve the problem let s model the behavior of the Kraken Suppose initially there are two or more ships in the sea we will consider the first and last ship denote their durabilities as and and also let initially setting and After two attacks the durability of both ships will decrease by If then we need to subtract from the durabilities of both ships and also reduce the remaining attacks of the Kraken by If then the Kraken will inflict damage to the th ship In this case if is odd the th ship will receive damage otherwise damage After these attacks some ships may have sunk If we increase by if we decrease by and move on to considering the next pair of ships that will be under attack by the Kraken If at some point it means that there is only one ship left in the sea and the Kraken can sink it if A deque is perfect for this problem allowing us to not think about and and simply look at the first and last elements in the queue At each step of considering a pair of ships either the Kraken s attacks end or at least one ship sinks The final complexity of the solution is 
Bizon the Champion has recently finished painting his wood fence The fence consists of a sequence of panels of meter width and of arbitrary height The th panel s height is meters The adjacent planks follow without a gap between them After Bizon painted the fence he decided to put a for sale sign on it The sign will be drawn on a rectangular piece of paper and placed on the fence so that the sides of the sign are parallel to the fence panels and are also aligned with the edges of some panels Bizon the Champion introduced the following constraints for the sign position The width of the sign should be exactly meters The sign must fit into the segment of the fence from the th to the th panels inclusive also it can t exceed the fence s bound in vertical direction The sign will be really pretty So Bizon the Champion wants the sign s height to be as large as possible You are given the description of the fence and several queries for placing sign For each query print the maximum possible height of the sign that can be placed on the corresponding segment of the fence with the given fixed width of the sign ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nstruct TResult {\n    int lx, rx, maxs, l;\n\n    TResult(int lx = 0, int rx = 0, int maxs = 0, int l = 0)\n        : lx(lx)\n        , rx(rx)\n        , maxs(maxs)\n        , l(l)\n    {\n    }\n\n    TResult operator+(const TResult &r) const {\n        TResult res;\n        res.l = l + r.l;\n        if (lx == l) res.lx = lx + r.lx;\n        else res.lx = lx;\n        if (r.rx == r.l) res.rx = r.rx + rx;\n        else res.rx = r.rx;\n        res.maxs = max(max(res.lx, res.rx), max(maxs, r.maxs));\n        res.maxs = max(res.maxs, rx + r.lx);\n        return res;\n//        return TResult(lx, r.rx, max(max(maxs, r.maxs), rx + r.lx));\n    }\n};\n\nstruct TNode {\n    int L, R;\n    int left, right;\n    TResult res;\n\n    TNode(int L = 0, int R = 0)\n        : L(L)\n        , R(R)\n        , left(0)\n        , right(0)\n        , res()\n    {\n    }\n};\n\nconst int MAXT = 4000000;\nTNode tree[MAXT];\nint tc = 0;\n\nint buildTree(int L, int R) {\n    int node = tc++;\n    tree[node] = TNode(L, R);\n    tree[node].res = TResult(0, 0, 0, R - L);\n    if (R - L == 1) {\n        return node;\n    }\n    int M = (L + R) / 2;\n    tree[node].left = buildTree(L, M);\n    tree[node].right = buildTree(M, R);\n    return node;\n}\n\nTResult query(int node, int L, int R) {\n    if (L <= tree[node].L && tree[node].R <= R) return tree[node].res;\n    if (R <= tree[node].L || tree[node].R <= L) return TResult();\n    return query(tree[node].left, L, R) + query(tree[node].right, L, R);\n}\n\nint set1(int node, int i) {\n    if (i < tree[node].L || i >= tree[node].R) return node;\n    int newNode = tc++;\n    tree[newNode] = tree[node];    \n    if (tree[node].R - tree[node].L == 1) {\n        tree[newNode].res = TResult(1, 1, 1, 1);\n        return newNode;\n    }\n    tree[newNode].left = set1(tree[node].left, i);\n    tree[newNode].right = set1(tree[node].right, i);\n    tree[newNode].res = tree[tree[newNode].left].res + tree[tree[newNode].right].res;\n    return newNode;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vector<pii> a(N);\n    forn(i, N) {\n        cin >> a[i].fi;\n        a[i].se = i;\n    }\n    sort(rall(a));\n    vi roots(N + 1);\n    roots[0] = buildTree(0, N);\n    forn(i, N) roots[i + 1] = set1(roots[i], a[i].se);\n    int Q;\n    cin >> Q;\n    forn(q, Q) {\n        int A, B, W;\n        cin >> A >> B >> W;\n        --A;\n        int l = 0, r = N;\n        while (r - l > 1) {\n            int m = (l + r) / 2;\n            if (query(roots[m], A, B).maxs >= W) r = m;\n            else l = m;\n        }\n        cout << a[r - 1].fi << \'\\n\';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 1, 1, 0, 0]",2500,Let us note that we can use binary search to find answer to the one query Suppose at some moment was fixed height and need to know will fit the rectangle with width and height to the segment of fence from th to th panel Let us build data structure that can answer to this question This will be persistent segment tree with unusual function inside maximum number of consecutive ones in segment In leaves of segment tree will be only numbers 0 and 1 To calculate this function need to know some other values specifically length of the segment in vertex of segment tree length of prefix that consists only of ones length of the suffix consist only of ones These functions are computed as follows is equal to equals in case of and otherwise equals in case of and otherwise it is left and right sons of vertex in segment tree As mentioned above tree must be persistent and it must be built as follows First builded empty tree of zeros Next in position of highest plank need to put 1 The same doing for planks in decreasing order For example if fence described with sequence then bottom of segment tree will changed as follows And we need to remember for all their version of tree Now to answer the question we need to make query in our segment tree that corresponding to height on segment If form this query less than then rectangle impossible to put otherwise possible Building of tree will take time and memory Time complexity to the one query will take time 
You are given a multiset A with initial size n whose elements are integers between 1 and m In one operation do the following select a value x from the multiset A then select two integers p and q such that p q 1 and p cdot q x Insert p and q to A delete x from A Note that the size of the multiset A increases by 1 after each operation We define the balance of the multiset A as max a i min a i Find the minimum possible balance after performing any number possible zero of operations ,"['#include <bits/stdc++.h>\nusing namespace std;\nint f[5000005],cnt[5000005],Mn;\nbitset <5000005> vis;\nvector <int> v;\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0); \n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tfor(int i=1;i<=m;i++) cnt[i]=0,f[i]=0,vis[i]=0;\n\t\tint mn=0;\n\t\tint ans=1e8;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif(!vis[x]) ++cnt[0];\n\t\t\tvis[x]=1;\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(vis[i]) --cnt[f[i]];\n\t\t\tf[i]=i;\n\t\t\tif(vis[i]) ++cnt[f[i]];\n\t\t\tfor(int j=1;j*i<=m;j++)\n\t\t\t{\n\t\t\t\tif(vis[i*j]) --cnt[f[i*j]];\n\t\t\t\tf[i*j]=max(f[j],f[j*i]);\n\t\t\t\tif(vis[i*j]) ++cnt[f[i*j]];\n\t\t\t}\n\t\t\twhile(!cnt[mn]) ++mn;\n\t\t\tif(mn) ans=min(ans,i-mn);\n\t\t}\n\t\tcout << ans << ""\\n""; \n\t}\n\treturn 0;\n}']","[1, 1, 0, 1, 1, 0, 0, 0, 0, 0]",2600,SolutionWe can see that in the final multiset each number from the initial multiset will be assigned to a subset of values such that their product is Every such multiset can be created Also let be the maximum value in the initial multiset Consider iterating through the minimum value To get the best maximum value that has this minimum we fixed one can use dynamic programming the best possible maximum if we had number and the minimum value in the product is is a divisor of This dp can be calculated in for all values We can also process all updates when incrementing the minimum and keeping the result with a total effort of Thus we have a total time complexity of However this we hope won t pass Here is a way more elegant solution thanks to ntherner To get things straight we observe that when we decompose a number we just actually write it as a product of numbers We still consider fixing the minimum value used in our multiset call it We will further consider that we iterate from the greatest possible value i e to and as such we try at each iteration to calculate the minimum possible value which will appear in any decomposition as the maximum value in said decomposition We shall now retain for each element the minimal maximum value in a decomposition where the minimum of that decomposition is let s say for element this value will be stored in Naturally after calculating this value for every number we now try to tweak the calculated values as to match the fact that after this iteration concluded we will decrease For further simplicity we denote So we changed the minimum value allowed What changes now Well it is easy to see that any element that is not divisible by won t be affected by this modification as much as it is impossible to include in any decomposition of said number So it remains to modify the multiples of Let s take a such number How can we modify Well we can include in the decomposition as many times as we want and then when we decide to stop including it we remain with a number which needs to be further decomposed The attributed maximum of this value should already be calculated so we can consider it as a new candidate for the update of This idea could be implemented simpler by going through multiples of and for an element updating with by taking the minimum of either We now need for each iteration to keep track of the attributed maximums of each element that actually appears in our initial list This can be done by keeping a frequency of all these elements and after all updates taking the already known maximum of the previous iteration and decreasing it until we find another element that actually appears in our set this can be verified by simply checking the frequency This is correct as much as all the values gradually decrease as decreases so their maximum would have to decrease as well Final time complexity 
Dreamoon is a big fan of the Codeforces contests One day he claimed that he will collect all the places from 1 to 54 after two more rated contests It s amazing Based on this you come up with the following problem There is a person who participated in n Codeforces rounds His place in the first round is a 1 his place in the second round is a 2 his place in the n th round is a n You are given a positive non zero integer x Please find the largest v such that this person can collect all the places from 1 to v after x more rated contests In other words you need to find the largest v such that it is possible that after x more rated contests for each 1 leq i leq v there will exist a contest where this person took the i th place For example if n 6 x 2 and a 3 1 1 5 7 10 then answer is v 5 because if on the next two contest he will take places 2 and 4 then he will collect all places from 1 to 5 so it is possible to get v 5 ,"['#include<cstdio>\nusing namespace std;\nint T,n,x,k,ans;\nbool a[310];\nint main(){\n\tscanf(""%d"",&T);\n\twhile (T--){\n\t\tfor (int i=1;i<=300;i++) a[i]=false;\n\t\tscanf(""%d%d"",&n,&x);\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&k);\n\t\t\ta[k]=true;\n\t\t}\n\t\tans=0;\n\t\tfor (int i=1;i<=300&&x>=0;i++){\n\t\t\tif (!a[i]) x--;\n\t\t\tans=i;\n\t\t}\n\t\tprintf(""%d\\n"",ans-1);\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,The total number of rounds this person participates after more rated contests is So the number of places this person collects cannot exceed Then we can iterate from to In each iteration let be the number of integers from to which doesn t appear in This person can collect all places from to if only if So the answer is the first meeting the condition when iterating The solution can be implemented in time complexity as a reference solution There are also many solutions that can solve this problem But in the experience of author and testers it s easy to make some mistake in the detail when writing solution Please try it by yourself 
The GCD table of size for an array of positive integers of length is defined by formula Let us remind you that the greatest common divisor GCD of two positive integers and is the greatest integer that is divisor of both and it is denoted as For example for array of length 4 the GCD table will look as follows Given all the numbers of the GCD table restore array ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <class T> T gcd(T a, T b) { return a ? gcd( b % a, a ) : b; }\ntemplate <class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\nconst int MAXN = 1e3;\nint N;\nint A[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> N;\n\tpriority_queue<int> vals;\n\tpriority_queue<int> found;\n\tfor(int i = 0; i < N * N; i++) {\n\t\tint v; cin >> v;\n\t\tvals.push(v);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\twhile(!vals.empty() && !found.empty() && vals.top() == found.top()) {\n\t\t\tvals.pop();\n\t\t\tfound.pop();\n\t\t}\n\t\tA[i] = vals.top();\n\t\tvals.pop();\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint g = gcd(A[i], A[j]);\n\t\t\tfound.push(g);\n\t\t\tfound.push(g);\n\t\t}\n\t}\n\tassert(found.size() == vals.size());\n\tfor(int i = 0; i < N; i++) cout << A[i] << ' '; cout << '\\n';\n\treturn 0;\n}\n""]","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1700,Let the answer be a1 a2 an We will use the fact that gcd ai aj amin i j It is true that gcd an an an ai gcd ai aj for every 1 i j n That means that an is equal to maximum element in the table Let set an to maximal element in the table and delete it from table elements set We ve deleted gcd an an so the set now contains all gcd ai aj for every 1 i j n and 1 min i j n 1 By the last two inequalities gcd ai aj amin i j an 1 gcd an 1 an 1 As soon as set contains gcd an 1 an 1 the maximum element in current element set is equal to an 1 As far as we already know an let s delete the gcd an 1 an 1 gcd an 1 an gcd an an 1 from the element set Now set contains all the gcd ai aj for every 1 i j n and 1 min i j n 2 We re repeating that operation for every k from n 2 to 1 setting ak to maximum element in the set and deleting the gcd ak ak gcd ai ak gcd ak ai for every k i n from the set One could prove correctness of this algorithm by mathematical induction For performing deleting and getting maximum element operations one could use multiset or map structure so solution has complexity 
Petya loves lucky numbers Everybody knows that positive integers are if their decimal representation doesn t contain digits other than and For example numbers are lucky and are not One night Petya was sleeping He was dreaming of being the president of some island country The country is represented by islands connected by two way roads Between some islands there is no road way even through other islands that s why the country is divided into several regions More formally each island belongs to exactly one region there is a path between any two islands located in the same region there is no path between any two islands from different regions A region is lucky if the amount of islands in it is a lucky number As a real president Petya first decided to build a presidential palace Being a lucky numbers fan Petya wants to position his palace in one of the lucky regions However it is possible that initially the country has no such regions In this case Petya can build additional roads between different regions thus joining them Find the minimum number of roads needed to build to create a lucky region ,"['#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=100000+10;\nconst int oo=100000000;\n\nvector<int> e[maxn];\nint que[maxn],qid[maxn];\nbool flag[maxn];\nint cnt[maxn];\nint A[maxn],B[maxn];\nint opt[maxn],tmp[maxn];\nint n,m,t;\n\nint main()\n{\n\tscanf(""%d%d"",&n,&m);\n\tfor (int i=0,a,b;i<m;i++)\n\t{\n\t\tscanf(""%d%d"",&a,&b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (!flag[i])\n\t{\n\t\tint l=1,r=1;\n\t\tque[1]=i;flag[i]=1;\n\t\tfor (;l<=r;l++)\n\t\tfor (int j=0;j<e[que[l]].size();j++)\n\t\tif (!flag[e[que[l]][j]])\n\t\t{\n\t\t\tque[++r]=e[que[l]][j];\n\t\t\tflag[que[r]]=1;\n\t\t}\n\t\tcnt[r]++;\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (cnt[i])\n\t{\n\t\tA[++t]=i;B[t]=cnt[i];\n\t}\n\n\tfor (int i=1;i<=77777;i++) opt[i]=oo;\n\tfor (int i=1;i<=t;i++)\n\t{\n\t\tfor (int j=0;j<=77777;j++) tmp[j]=oo;\n\t\tfor (int j=0;j<A[i];j++)\n\t\t{\n\t\t\tint l=1,r=0;\n\t\t\tfor (int k=j,id=0;k<=77777;k+=A[i],id++)\n\t\t\t{\n\t\t\t\twhile (l<=r && id-qid[l]>B[i]) l++;\n\t\t\t\tif (l<=r) tmp[k]=que[l]+id;\n\t\t\t\twhile (l<=r && opt[k]-id<=que[r]) r--;\n\t\t\t\tque[++r]=opt[k]-id;qid[r]=id;\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<=77777;j++) opt[j]=min(opt[j],tmp[j]);\n\t}\n\n\tint res=n+1;\n\tfor (int i=1;i<=77777;i++)\n\tif (opt[i]<res)\n\t{\n\t\tbool ok=1;\n\t\tfor (int k=i;k;k/=10)\n\t\t\tok&=(k%10==4 || k%10==7);\n\t\tif (ok) res=opt[i];\n\t}\n\tif (res==n+1) printf(""-1\\n"");\n\telse printf(""%d\\n"",res-1);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 1]",2500,Let A i sorted array of sizes of different connection components C i number of connection components of size A i Sum for all C i A i is equal to N Size of A will be O sqrt N 
You are given an array of n integers a 0 a 1 a 2 ldots a n 1 Bryap wants to find the longest subsequence in the array An array b b 0 b 1 ldots b m 1 where 0 le b 0 b 1 ldots b m 1 n is a subsequence of length m of the array a Subsequence b b 0 b 1 ldots b m 1 of length m is called if the following condition holds For any p 0 le p m 1 holds a b p oplus b p 1 a b p 1 oplus b p Here a oplus b denotes the bitwise XOR of a and b For example 2 oplus 4 6 and 3 oplus 1 2 Bryap is a simple person so he only wants to know the length of the longest such subsequence Help Bryap and find the answer to his question ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=3e5+5;\nint A[N];\nint f[256];\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j,k,res=0;\n\t\tcin>>n;\n\t\tfor (i=0; i<n; i++) cin>>A[i];\n\t\tint m=n;\n\t\tfor (k=0; k<m; k+=256)\n\t\t{\n\t\t\tint *a=A+k;\n\t\t\tn=min(m-k,256);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tfor (j=0; j<i; j++) if ((a[j]^i)<(a[i]^j)) f[i]=max(f[i],f[j]+1);\n\t\t\t}\n\t\t\tres=max(res,*max_element(f,f+n));\n\t\t}\n\t\tcout<<res<<\'\\n\';\n\t}\n}\n']","[0, 0, 0, 1, 0, 1, 0, 0, 0, 0]",1800,Let s use dynamic programming to solve this task maximum length of good subsequence that ends int th element of than naive solution is Let s observe that changes not more than by This way we can relax not from but because xor operation changes only last 8 bits so for definitely Additional idea It not so hard to proove that we can try from to 
There are n boxers the weight of the i th boxer is a i Each of them can change the weight by no more than 1 before the competition the weight cannot become equal to zero that is it must remain positive Weight is always an integer number It is necessary to choose the largest boxing team in terms of the number of people that all the boxers weights in the team are different i e unique Write a program that for given current values a i will find the maximum possible number of boxers in a team It is possible that after some change the weight of some boxer is 150001 but no more ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\tsort(begin(a), end(a));\n\tint res = 0, last = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] - 1 > last) --a[i];\n\t\tif (a[i] == last) ++a[i];\n\t\tif (a[i] > last) {\n\t\t\t++res;\n\t\t\tlast = a[i];\n\t\t}\n\t}\n\tcout << res << endl;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1500,Let be the last weight of the boxer taken into the team Initially Let s sort all boxers in order of non increasing their weights and iterate over all boxers in order from left to right If the current boxer has the weight then let s try to take him with weight we can do it if If we cannot do it let s try to take him with weight And in case of fault let s try to take him with weight If we cannot take him even with weight then let s skip him And if we take him let s replace with him weight The answer is the number of boxers we took 
You are given a multiset S Initially S 1 2 3 ldots n You will perform the following operation n 1 times Choose the largest number S text max in S and the smallest number S text min in S Remove the two numbers from S and add S text max S text min into S It s easy to show that there will be exactly one number left after n 1 operations Output that number ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconst long double phi = (1 + std::sqrt(5.L)) / 2;\n\ni64 floor_sum(i64 n, i64 m, i64 a, i64 b) {\n    i64 ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\nconstexpr i64 X = 701408733;\nconstexpr i64 Y = 1134903170;\n\nint g(int n) {\n    int ans = 0;\n    ans -= floor_sum(n / 2 + 1, Y, 2 * X, 0);\n    ans += floor_sum((n + 1) / 2, Y, 2 * X, X);\n    return ans;\n}\n\nint get(int n) {\n    int t = (n + 1) * Y / (2 * Y + X);\n    \n    int ans = 0;\n    ans += g(n - 1);\n    ans -= g(t);\n    if (n % 2 == 0) {\n        ans *= -1;\n    }\n    ans += int(n * X / Y) * ((n - t - 1) % 2 == 0 ? -1 : 1);\n    if ((n - t) % 2 == 1) {\n        ans += n;\n    }\n    \n    return ans;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::cout << get(n) << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2900,TutorialAssume that the moment before the th operation but after th the first time we have Let s divide the operation into two part before and equal or after Still at the moment just before the th operation let us sort the elements in the multiset in non decreasing order We will show that the answer is ProofThis lemma is based on the fact that after each operation which is after th to will not change is removed and turn to Which also means always holds At the very beginning obviously holds And we can observe that either or When the new after two operations is equal to the old When the new after two operations is equal to the old minus one So if we write the as an array by time order always holds Thus always holds Let be the value in the th operation Let s prove that before the th operation where ProofWe prove this by Mathematical induction One fact should be known that during these operations always holds for the th operation since For it is true because and Assume for it is true Still use the fact that or The necessary and sufficient condition for is all the numbers greater or equal to is used How many numbers are there We have numbers from the original multiset and some numbers that occurs during the operations which are the number of satisfying Thus is equivalent to Note that is always increasing which means that formula holds for but does not hold for The first equation always holds Because and ofcourse Let s do the research when the second equation does not hold Let and Note that since The topic we are going to research is when hold which also means Then let s focus on if when will hold It s easy to find when holds And since we can tell Thus we proved the topic for all before the th operation Then by solve we can get Now let s prove for also holds ProofUsing the similar idea as lemma 2 find out when holds However at this time only will contribute since for those according to lemma 1 they become the minimal one and do not contribute to anything Similarly that is Seems to be different this time but actually they are the same because holds the proving is easy leave it as a exercise This condition holds means that we can use the same method in lemma 2 to prove it Till now the lemmas told us the solving the problem is actually solving something like We can divide them into positive part and negtive part and then solving where range from some to and is a irrational constant Since is not very large we can approximate by where are integers and turn it into a traditional task Maybe it is called floor sum or something like I m not sure about the algorithm s english name The marvelous jiangly told me in long long range is enough But the tester used int128 We can dig more about the Let sorted before the th operation and what we care is We can find that array is actually a consecutive substring of fibonacci string More over let be the starting point of array in the fibonacci string when the initial size is we have the conclusion for where represents a list of numbers Now the only left problem is to find the prefix sum of fibonacci string of even positions or of odd positions This is quite a simple task by using any or solution 
Polycarp was given a row of tiles Each tile contains one lowercase letter of the Latin alphabet The entire sequence of tiles forms the string s In other words you are given a string s consisting of lowercase Latin letters Initially Polycarp is on the tile of the row and wants to get to the tile by jumping on the tiles Jumping from i th tile to j th tile has a cost equal to index s i index s j where index c is the index of the letter c in the alphabet for example index 1 index 2 index 26 Polycarp wants to get to the n th tile for the minimum total cost but at the same time make number of jumps In other words among all possible ways to get to the last tile for the total cost he will choose the one with the number of jumps Polycarp can visit each tile Polycarp asks you to help print the sequence of indices of string s on which he should jump ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n    vvi g(26);\n\n    rep(i,0,n)\n    {\n        g[s[i] - \'a\'].pb(i);\n    }\n\n\n    cout << abs(s[0] - s.back()) << \' \';\n\n    vi res;\n\n    if(s[0] < s.back())\n    {\n        fr(i, s[0] - \'a\', s.back() - \'a\')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    else\n    {\n        frev(i, s.back() - \'a\', s[0] - \'a\')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    \n    \n    cout << sz(res) << endl;\n\n    trav(x, res)\n    {\n        cout << x + 1 << \' \';\n    }\n\n    cout << endl;\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1100,It s worth knowing that ways like and have the same cost That is first you need to understand the letter on the first tile and the last one conditionally the letters and Then you just need to find all such tiles on which the letters are between the letters and inclusive We go through each letter from to and for each letter we visit every tile that has a given letter but we must not forget to start exactly at tile and end at tile 
INTERCAL is the oldest of esoteric programming languages One of its many weird features is the method of character based output known as Turing Tape method It converts an array of unsigned 8 bit integers into a sequence of characters to print using the following method The integers of the array are processed one by one starting from the first Processing th element of the array is done in three steps 1 The 8 bit binary notation of the ASCII code of the previous printed character is reversed When the first element of the array is processed the result of this step is considered to be 0 2 The th element of the array is subtracted from the result of the previous step modulo 256 3 The binary notation of the result of the previous step is reversed again to produce ASCII code of the th character to be printed You are given the text printed using this method Restore the array used to produce this text ,"['#pragma comment(linker, ""/STACK:65777216"")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint getcode(char c){\n\tint q = int(c);\n\tif(q<0) q += 256;\n\treturn q;\n}\n\nint mirror(int code){\n\tint res = 0;\n\tREP(i,8)if(code&(1<<i))\n\t\tres ^= (1<<(7-i));\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n//  freopen(""output.txt"",""w"",stdout);\n#endif\n\t\n\tstring s;\n\tgetline(cin,s);\n\n\tint prev = 0;\n\tREP(i,s.size()){\n\t\tprev = getcode(s[i]);\n\t\tprev = mirror(prev);\n\n\t\tint x = mirror(i?getcode(s[i-1]):0) - prev;\n\t\tx%=256;\n\t\tif(x<0) x+=256;\n\t\tcout<<x<<endl;\n\t}\n\n \n#ifdef LocalHost\n    cout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,This was another implementation problem inspired by another great language INTERCAL Technically it was a bit more complicated than the previous one due to the usage of byte reversal and having to implement not the described procedure but its inverse For i th character of input data reverse it and store in rev i then i th number of the output can be calculated as rev i 1 rev i 256 256 for i 0 rev i 1 0 
You are given three integers x y and n Your task is to construct an array a consisting of n integers which satisfies the following conditions a 1 x a n y a is increasing i e a 1 a 2 ldots a n if we denote b i a i 1 a i for 1 leq i leq n 1 then b is decreasing i e b 1 b 2 ldots b n 1 If there is no such array a print a single integer 1 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n}\n\nint tab[nax];\n\nvoid test()\n{\n\tint x, y, n;\n\tscanf(""%d%d%d"", &x, &y, &n);\n\tif (y<=x)\n\t{\n\t\tnope();\n\t\treturn;\n\t}\n\ttab[n]=y;\n\tfor (int i=n-1; i; i--)\n\t{\n\t\ttab[i]=tab[i+1]-(n-i);\n\t}\n\tif (tab[1]<x)\n\t{\n\t\tnope();\n\t\treturn;\n\t}\n\ttab[1]=x;\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%d "", tab[i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 1, 1, 0, 0, 0, 1, 0, 0, 0]",800,TutorialWe use the following greedy construction For all set If we ve found a solution otherwise there is no solution Proof Assume there s a solution which includes an index such that We can make for all where After several processes like this we get a solution the same as greedy construction gives This leads to a contradiction 
Consider the following equation where sign represents the integer part of number Let s find all integer for which this equation is in positive integers The phrase unsolvable in positive integers means that there are no such positive integers and for which the given above equation holds Let s write out all such in the increasing order and so on Your task is given the number find the number ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\ntypedef long long LL;\nconst int P=1000000007;\nint ff[]={0,2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,\n    2281,3217,4253,4423,9689,9941,11213,19937,21701,23209,\n    44497,86243,110503,132049,216091,756839,859433,1257787,\n    1398269,2976221,3021377,6972593,13466917,20996011,24036583};\nint Pow(int y)\n{\n    int ret=1,x=2;\n    while(y)\n    {\n        if(y&1)ret=(LL)ret*x%P;\n        x=(LL)x*x%P;y/=2;\n    }\n    ret--;\n    if(ret<0)ret+=P;\n    return ret;\n}\nint n;\nint main()\n{\n    while(~scanf(""%d"",&n))\n    {\n        int ret=Pow(ff[n]-1);\n        printf(""%d\\n"",ret);\n    }\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2100,You have z x 2 y xy That is equivalent to z 2k 2 y 2ky where x 2k k 0 or z 2k 1 2 y 2k 1 y where x 2k 1 k 0 z k y 2ky k 0 or z k y 2k 1 y k 0 Still more steps 2z 1 2k 2y 4ky 1 k 0 or z 1 k 2y 2ky 1 k 0 2z 1 2k 1 2y 1 k 0 or z 1 2y 1 k 1 k 0 From the 2nd equation you can see than z should be 2t 1 because otherwise z 1 will have odd divisor and we can build solution From the 1st equation you can see that 2t 1 1 should be prime otherwise we also can build solution If z 2t 1 and 2t 1 1 is prime obliviously there are no solutions Prime numbers like 2a 1 are Mersenne primes Only about 46 such numbers are found now Powers of 2 for the firts 40 numbers you can find for example here 
You are given two integers l and r where l r We will add 1 to l until the result is equal to r Thus there will be exactly r l additions performed For each such addition let s look at the number of digits that will be changed after it For example if l 909 then adding one will result in 910 and 2 digits will be changed if you add one to l 9 the result will be 10 and 2 digits will also be changed if you add one to l 489999 the result will be 490000 and 5 digits will be changed Changed digits always form a suffix of the result written in the decimal system Output the total number of changed digits if you want to get r from l adding 1 each time ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nint n,m,i,j,k,t,t1,u,v,a,b;\nll res=0;\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>a>>b;\n        res=0;\n        u=1;\n        for (i=0;i<10;i++)\n        {\n            res+=b/u-a/u;\n            u*=10;\n        }\n        cout<<res<<endl;\n    }\n}\n']","[0, 1, 0, 1, 0, 0, 0, 1, 0, 0]",1500,For each digit we will count how many times it has changed The number of changes for the first digit the lowest is calculated using the formula The number of changes for the second digit is calculated by the formula That is it is equivalent to the number of first digit changes for numbers from to To calculate the number of changes for the remaining digits you need to apply similar reasoning with dividing the numbers by 
An atom of element X can exist in distinct states with energies Arkady wants to build a laser on this element using a three level scheme Here is a simplified description of the scheme Three distinct states and are selected where After that the following process happens initially the atom is in the state we spend energy to put the atom in the state the atom emits a photon with useful energy and changes its state to the state the atom spontaneously changes its state to the state losing energy the process repeats from step 1 Let s define the energy conversion efficiency as i e the ration between the useful energy of the photon and spent energy Due to some limitations Arkady can only choose such three states that Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 100100;\n\ndouble ans = -1;\nint a[N];\nint n;\nint U;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &U);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\n\tfor (int i = 0; i < n - 2; i++) {\n\t\tint p = upper_bound(a, a + n, a[i] + U) - a - 1;\n\t\tif (p <= i + 1) continue;\n\t\tdouble res = (double)(a[p] - a[i + 1]) / (a[p] - a[i]);\n\t\tans = max(ans, res);\n\t}\n\n\tif (ans < -0.5)\n\t\tprintf(""-1\\n"");\n\telse\n\t\tprintf(""%.12lf\\n"", ans);\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1600,First of all you can note that for fixed i and k setting j i 1 is always the best choice Indeed if X Y then for positive B Then let s fix i Then j i 1 and what is the optimal k We can define the energy loss as As we need to minimize the loss it s obvious that we should maximize Ek so we should choose as large k as possible satisfying Ek Ei U This is a classic problem that can be solved with two pointers approach this leads to O n solution or with binary search approach this leads to solution Both are acceptable 
You are given a rooted tree with vertices The vertices are numbered from to the root is the vertex number Each vertex has a color let s denote the color of vertex by Initially You have to color the tree into the given colors using the smallest possible number of steps On each step you can choose a vertex and a color and then color all vectices in the subtree of including itself in color In other words for every vertex such that the path from root to passes through set It is guaranteed that you have to color each vertex in a color different from You can learn what a rooted tree is using the link https en wikipedia org wiki Tree graph theory ,"['#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\n\n\n\ntemplate <class T>\nvoid upd(T&a,T b) {\n    a = max(a,b);\n}\n\nvector<int>son[100010];\nint n,c[100010];\nint ans = 0;\nvoid dfs(int cur,int color = 0){\n    if(c[cur]!=color){\n        ans++;\n        color = c[cur];\n    }\n    for(auto i:son[cur]){\n        dfs(i,color);\n    }\n}\nint main(){\n    in(n);\n    REP(i,2,n+1){\n        int p;in(p);\n        son[p].PB(i);\n    }\n    REP(i,1,n+1){\n        in(c[i]);\n    }\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200,Consider the process from the end we will delete any subtree from the tree whose color of the ancestor of the highest vertex differs from the color of the highest vertex and the colors of all vertices in the subtree are the same Thus we can show that the answer is the number of edges whose ends have different colors 1 
Valera had an undirected connected graph without self loops and multiple edges consisting of vertices The graph had an interesting property there were at most edges adjacent to each of its vertices For convenience we will assume that the graph vertices were indexed by integers from 1 to One day Valera counted the shortest distances from one of the graph vertices to all other ones and wrote them out in array Thus element of the array shows the shortest distance from the vertex Valera chose to vertex number Then something irreparable terrible happened Valera lost the initial graph However he still has the array Help him restore the lost graph ,"['#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define lx x + x\n#define rx lx + 1\n#define ly y + y\n#define ry ly + 1\ntypedef long long LL;\n\nconst int N = 100005;\nconst int M = 1005;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\ntypedef double DB;\nint n, k, x;\nvector <int> v[N], ans, res;\n\nvoid add(int x, int y){\n    ans.PB(x), res.PB(y);\n}\n\nint main(){\n    scanf(""%d%d"", &n, &k);\n    for (int i = 1; i <= n; i++){\n        scanf(""%d"", &x);\n        v[x].PB(i);\n    }\n    if (v[0].size() != 1){\n        puts(""-1"");\n        return 0;\n    }\n    int cnt = 1;\n    for (int i = 1; i < n; i++){\n        int x = v[i - 1].size();\n        int y = v[i].size();\n        if (!y){\n            puts(""-1"");\n            return 0;\n        }\n        if (i == 1 && y > k){\n            puts(""-1"");\n            return 0;\n        }\n        if (i != 1){\n            if (k == 1 || ((LL)x * (k - 1) < y)){\n                puts(""-1"");\n                return 0;\n            }\n        }\n        for (int j = 0; j < y; j++){\n            if (i == 1) add(v[0][0], v[i][j]); else\n            add(v[i - 1][j / (k - 1)], v[i][j]);\n        }\n        cnt += y;\n        if (cnt == n) break;\n    }\n    cout << ans.size() << endl;\n    for (int i = 0; i < ans.size(); i++)\n        printf(""%d %d\\n"", ans[i], res[i]);\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 1]",1800,First of all let us notice that it must be only one in Also means that is the vertex from which Valera calculated the distance to the other vertices Let s notice that every vertex with must be adjacent only to the vertices such that Besides there is always must be such neighboor of that Let s build sought graph by adding one vertex to the existing graph We will add vertex in order of increasing their distance to Initially we have one vertex with number in our graph When we add vertex with let s consider such vertices that Let s choose the vertex with minimal degree among them If this value is equal to then there is no solution In other case let s add to our graph and add the edge to the answer If there are no vertices with distance to then the answer is also If everything fine we will get the answer which is tree so the number of edges in it equals 
My name is James diGriz I m the most clever robber and treasure hunter in the whole galaxy There are books written about my adventures and songs about my operations though you were able to catch me up in a pretty awkward moment I was able to hide from cameras outsmart all the guards and pass numerous traps but when I finally reached the treasure box and opened it I have accidentally started the clockwork bomb Luckily I have met such kind of bombs before and I know that the clockwork mechanism can be stopped by connecting contacts with wires on the control panel of the bomb in a certain manner I see contacts connected by wires Contacts are numbered with integers from to Bomb has a security mechanism that ensures the following condition if there exist contacts forming a circuit i e there exist wires between contacts and and and then the bomb immediately explodes and my story ends here In particular if two contacts are connected by more than one wire they form a circuit of length It is also prohibited to connect a contact with itself On the other hand if I disconnect more than one wire i e at some moment there will be no more than wires in the scheme then the other security check fails and the bomb also explodes So the only thing I can do is to unplug some wire and plug it into a new place ensuring the fact that no circuits appear I know how I should put the wires in order to stop the clockwork But my time is running out Help me get out of this alive find the sequence of operations each of which consists of unplugging some wire and putting it into another place so that the bomb is defused ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint p[N];\n\ninline int find_set(int x) {\n  if (x != p[x]) {\n    p[x] = find_set(p[x]);\n  }\n  return p[x];\n}\n\nvector < pair <int, int> > edges[N];\n\ninline void unite(int x, int y) {\n  x = find_set(x);\n  y = find_set(y);\n  if (x == y) {\n    return;\n  }\n  p[x] = y;\n  if (edges[x].size() > edges[y].size()) {\n    swap(edges[x], edges[y]);\n  }\n  while (!edges[x].empty()) {\n    edges[y].push_back(edges[x].back());\n    edges[x].pop_back();\n  }\n}\n\nvector < pair <int, int> > g[N];\nbool rem[N], add[N];\nbool done[N];\nint bx[N], by[N];\n\ninline void dfs(int v, int pr) {\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    dfs(u, v);\n    int id = g[v][j].second;\n    if (!rem[id]) {\n      unite(u, v);\n      continue;\n    }\n    pair <int, int> e = edges[u].back();\n    while (done[e.second]) {\n      edges[u].pop_back();\n      e = edges[u].back();\n    }\n    done[e.second] = true;\n    printf(""%d %d %d %d\\n"", u + 1, v + 1, bx[e.second] + 1, by[e.second] + 1);\n    edges[u].pop_back();\n    unite(u, e.first);\n  }\n}\n\nint ax[N], ay[N];\npair < pair <int, int>, int > ev[2 * N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n - 1; i++) {\n    scanf(""%d %d"", ax + i, ay + i);\n    ax[i]--; ay[i]--;\n    if (ax[i] > ay[i]) {\n      swap(ax[i], ay[i]);\n    }\n    ev[i] = make_pair(make_pair(ax[i], ay[i]), i);\n    rem[i] = false;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    scanf(""%d %d"", bx + i, by + i);\n    bx[i]--; by[i]--;\n    if (bx[i] > by[i]) {\n      swap(bx[i], by[i]);\n    }\n    ev[n - 1 + i] = make_pair(make_pair(bx[i], by[i]), ~i);\n    add[i] = false;\n  }\n  sort(ev, ev + n - 1 + n - 1);\n  int ans = 0;\n  for (int i = n - 1 + n - 1 - 1; i >= 0; i--) {\n    if (i > 0 && ev[i].first == ev[i - 1].first) {\n      i--;\n      continue;\n    }\n    int x = ev[i].second;\n    if (x >= 0) {\n      rem[x] = true;\n      ans++;\n    } else {\n      add[~x] = true;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    g[ax[i]].push_back(make_pair(ay[i], i));\n    g[ay[i]].push_back(make_pair(ax[i], i));\n  }\n  for (int i = 0; i < n; i++) {\n    edges[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    if (!add[i]) {\n      continue;\n    }\n    done[i] = false;\n    edges[bx[i]].push_back(make_pair(by[i], i));\n    edges[by[i]].push_back(make_pair(bx[i], i));\n  }\n  for (int i = 0; i < n; i++) {\n    p[i] = i;\n  }\n  printf(""%d\\n"", ans);\n  dfs(0, -1);\n  return 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",3200,First idea is that answer is always equals to the number of edges from the first tree which are not in the second one This means that if we have an edge in both trees we will never touch it So if we have such edge we can remove this edge and merge its two vertices together nothing will change Second idea that if we will take any edge from the first tree there always exists some edge from the second tree which we can swap otherwise second graph is not connected but the tree is always connected So the order of adding edges from the first tree can be arbitrary Third idea is that if we will select leaf node in the first tree then cut its only edge then we can add instead of it any edge going from this vertex in the second tree Overall algorithm we store linked lists of edges in vertices when edge is in both trees we use disjoint set union to merge vertices and join their lists We can simply traverse first tree to get any order of edges in which the current edge will always contain leaf as one of its vertices Complexity is which in practice is almost linear 
Sadly the problem setter couldn t think of an interesting story thus he just asks you to solve the following problem Given an array a consisting of n positive integers count the number of subsequences for which the bitwise mathsf AND of the elements in the subsequence has exactly k set bits in its binary representation The answer may be large so output it modulo 10 9 7 Recall that the subsequence of an array a is a sequence that can be obtained from a by removing some possibly zero elements For example 1 2 3 3 1 3 are subsequences of 1 2 3 but 3 2 and 4 5 6 are not Note that mathsf AND represents the bitwise AND operation ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nconst int mod = 1e9 + 7;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n#define fi first\n#define se second\n\nint n, k, a[N];\nint f[N][70];\n\nvoid solve() {\n    cin >> n >> k;\n    rep(i, 1, n) cin >> a[i];\n\n    f[0][63] = 1;\n    rep(i, 1, n) {\n        rep(j, 0, 63) {\n            int u = (j & a[i]);\n            f[i][u] = (f[i][u] + f[i - 1][j]) % mod;\n        }\n        rep(j, 0, 63) f[i][j] = (f[i][j] + f[i - 1][j]) % mod;\n    }\n\n//    rep(i, 1, n) cout << f[i][1] << "" "";\n\n    int res = 0;\n    if (k == 6) res--;\n    rep(x, 0, 63) {\n        int cnt = __builtin_popcount(x);\n        if (cnt != k) continue;\n        res = (res + f[n][x]) % mod;\n        if (res < 0) res = (res + mod) % mod;\n//        cout << x << "" "";\n    }\n    res = (res + mod) % mod;\n    cout << res << ""\\n"";\n\n    rep(i, 0, n) rep(j, 0, 63) f[i][j] = 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1700,We can notice that the numbers are pretty small up to and the AND values will be up to as well Thus we can count the number of subsequences that have AND value equal to for all from to We can do this using dynamic programming Let s denote as the number of subsequences using the first elements that have a total AND value of The transitions are quite simple We can iterate over all values obtained previously and update the values respectively We have three cases The first case is when we don t use the th value Here we just update the in the following way The second case is when we use the th value Here we update the in the following way The third case is starting a new subsequence with just the th element Thus we update 
You are given an array a of length n and two integers m and k Each element in a satisfies 1 le a i le m In one operation you choose two indices i and j such that 1 le i j le a then append gcd a i a j to the back of the array and delete a i and a j from the array Note that the length of the array decreases by one after this operation Find the maximum possible sum of the array after performing k operations ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\nlong long n, x,m,K;\nint k;\nconst long long MAXEL = 1000LL * 1000LL * 1000LL * 1000LL;\nlong long nwd(long long a, long long b)\n{\n    while (a != 0)\n    {\n        b %= a;\n        std::swap(a, b);\n    }\n    return b;\n}\nvoid work()\n{\n    std::cin >> n>>m>>K;\n\tstd::vector<long long> li, result;\n\tstd::vector<std::pair<long long, int>> kro;\n    result.resize(n + 2);\n    for (int i = 0; i < n; i++)\n    {\n        std::cin >> x;\n        li.emplace_back(x);\n    }\n    sort(li.begin(), li.end());\n    int ile = 0;\n    long long last = li.front();\n    for (auto l : li)\n    {\n        if (l == last)\n        {\n            ile++;\n        }\n        else\n        {\n            kro.emplace_back(last, ile);\n            ile = 1;\n            last = l;\n        }\n    }\n    kro.emplace_back(last, ile);\n    long long nw = 0;\n    long long sum = 0;\n    for (auto x : kro)\n        sum += x.first;\n    for (std::size_t i = 0; i < kro.size(); i++)\n    {\n        long long tmp = nwd(nw, kro[i].first);\n        if (tmp != nw)\n        {\n            long long max = -MAXEL;\n            for (std::size_t j = i; j < kro.size(); j++)\n                max = std::max(max, nwd(nw, kro[j].first) - kro[j].first);\n            long long sum2 = sum + max;\n            int ite = 0;\n            int poz = kro.size() - 1;\n            std::vector<long long> str;\n            while (true)\n            {\n                result[kro.size() - i + ite] = std::max(result[kro.size() - i + ite], sum2);\n                result[kro.size() - i + ite + 1] = std::max(result[kro.size() - i + ite + 1], sum2 - max + nw);\n                while (poz >= int(i) && kro[poz].second == 1)\n                    poz--;\n                if (poz < int(i))\n                    break;\n                kro[poz].second--;\n                str.emplace_back(poz);\n                ite++;\n                sum2 += kro[poz].first;\n            }\n            for (auto x : str)\n                kro[x].second++;\n            nw = tmp;\n        }\n        sum -= kro[i].first;\n    }\n    sum = 0;\n    for (auto x : li)\n        sum += x;\n    nw = 0;\n    for (std::size_t i = 0; i < li.size(); i++)\n    {\n\n        long long tmp = nwd(nw, li[i]);\n        sum -= li[i];\n\n        if (tmp != nw)\n        {\n            long long max = -MAXEL;\n            for (std::size_t j = i; j < li.size(); j++)\n                max = std::max(max, nwd(li[i], nw));\n            result[li.size() - i] = std::max(result[li.size() - i], sum + max);\n        }\n        else\n        {\n            result[li.size() - i] = std::max(result[li.size() - i], sum + nw);\n        }\n\n        nw = tmp;\n    }\n\n    // for (int i = 1; i <= n; i++)\n    // {\n        std::cout << result[n-K] << ""\\n"";\n    // }\n}\nsigned main()\n{\n    std::ios_base::sync_with_stdio(0);\n\tint T=1;\n\tstd::cin>>T;\n\twhile (T--)\n\t{\n\t\twork();\n\t}\n}\n\t']","[1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",2900,Hint 1 There is a easy strategy for dealing with repeated elements Suppose that all elements in a are pairwise distinct in the following hints Hint 2 We will always perform an operation on the minimum element Hint 3 The best way is to choose k 1 elements delete them and add the gcd of them to the sequence Hint 4 After sorting the sequence you may guess that choosing a prefix is optimal But actually it is wrong Try fixing the strategy Solution for F1 First suppose that all elements in a are pairwise distinct The problem can be rewritten as Divide the sequence into n k groups to maximize the sum of the gcd of each group Let Si represent the elements of a group Lemma 1 When k 0 the group which the minimum element of the original sequence belongs to satisfies Sa 1 Proof If Sa 1 we can find a group Sx such that Sx 1 Then replacing the maximum element of Sx with the minimum element of the original sequence makes the answer greater Let a be the minimum of the sequence and b be the maximum of Sx the original answer is a gcd Sx replacing the maximum element of Sx with the minimum element the answer is b gcd Sx b a b gcd Sx maxSx minSx b minSx b a so a gcd Sx a b a b b gcd Sx b a Q E D Tips When maxSx minSx gcd Sx maxSx minSx That s why all elements in a need to be pairwise distinct Lemma 2 When k 0 there s only one Sx such that Sx 1 Proof Let Sa be the group with the minimum element Referring to Lemma 1 we know Sa 1 Then we remove all the elements of Sa from the sequence add gcd Sa to the sequence and subtract Sa 1 from k It s obvious that gcd Sa is the minimum element of the newly formed sequence We can continue the process until k 0 which tells us that only Sa k 1 1 Q E D We can enumerate gcd Sa to solve it in O n mlnm so far How about repeated elements We can find that for those repeated elements the best strategy is to merge them with the same element In other word a repeated element x only decreases the answer by x So it s independent of the previous part We just need to enumerate the number of operations we perform for repeated elements Solution for F2 Still suppose that all elements in a are pairwise distinct Suppose a is sorted Lemma 3 When k 0 we will choose the first k elements and an element from the remaining elements That is S a1 a2 ak ax where k x n is the only group with more than one element Proof Suppose T a1 a2 ap ac1 ac2 act where p 1 c1 c2 ct t 2 and p t k 1 Then we can prove that T a1 a2 ap ap 1 ac1 ac2 act 1 is always a better choice Let g gcd T and g gcd T We have act ap 1 act act 1 g ans T ans T act ap 1 g g g 0 So repeating the process finally we will know that S a1 a2 ak ax where k x n Q E D When there re repeated elements we need to calculate the answer for k prefixes Note that there re only O logm different prefix gcd So we can do it in O nlog2m another O logm comes from calculating gcd Let gi be the prefix gcd When finding the best pair we calculate gcd gi aj which leads to O nlog2m gi gi 1 so gcd gi aj gcd gi gcd gi 1 aj The gcd is non increasing so the total complexity is O nlogm 
At the store the salespeople want to make all prices In this problem a number that is a power of 10 is called a number For example the numbers 10 0 1 10 1 10 10 2 100 are numbers but 20 110 and 256 are not numbers So if an item is worth m bourles the value of the item is not greater than 10 9 the sellers want to change its value to the nearest number that is not greater than m They ask you by how many bourles should you the value of the item to make it worth exactly 10 k bourles where the value of k is the maximum possible k any non negative integer For example let the item have a value of 178 bourles Then the new price of the item will be 100 and the answer will be 178 100 78 ,"['/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,k,c,a[N];\nvoid solo()\n{\n    cin>>n;\n    k=1;\n    while ((k*10)<=n) k*=10;\n    cout<<n-k;\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",800,Note that the number and the nearest round number not exceeding have the same size consist of the same number of digits in the record Denote the size of by Then we can construct the nearest round number It will consist of one and zeros 
Soroush and Keshi each have a labeled and rooted tree on n vertices Both of their trees are rooted from vertex 1 Soroush and Keshi used to be at war After endless decades of fighting they finally became allies to prepare a Codeforces round To celebrate this fortunate event they decided to make a memorial graph on n vertices They add an edge between vertices u and v in the memorial graph if of the following conditions hold One of u or v is the ancestor of the other in Soroush s tree Neither of u or v is the ancestor of the other in Keshi s tree Here vertex u is considered ancestor of vertex v if u lies on the path from 1 the root to the v Popping out of nowhere Mashtali tried to find the maximum clique in the memorial graph for no reason He failed because the graph was too big Help Mashtali by finding the size of the maximum clique in the memorial graph As a reminder clique is a subset of vertices of the graph each two of which are connected by an edge ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -1;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -1;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\n\ntemplate <bool VALS_EDGES> struct HLD {\n\tint N, tim = 0;\n\tvector<vi> adj;\n\tvi par, siz, depth, rt, pos;\n\tNode *tree;\n\tHLD(vector<vi> adj_)\n\t\t: N(sz(adj_)), adj(adj_), par(N, -1), siz(N, 1), depth(N),\n\t\t  rt(N),pos(N),tree(new Node(0, N)){ dfsSz(),dfsHld();}\n\tvoid dfsSz(int v = 0) {\n\t\tif (par[v] != -1) adj[v].erase(find(all(adj[v]), par[v]));\n\t\ttrav(u, adj[v]) {\n\t\t\tpar[u] = v, depth[u] = depth[v] + 1;\n\t\t\tdfsSz(u);\n\t\t\tsiz[v] += siz[u];\n\t\t\tif (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);\n\t\t}\n\t}\n\tvoid dfsHld(int v = 0) {\n\t\tpos[v] = tim++;\n\t\ttrav(u, adj[v]) {\n\t\t\trt[u] = (u == adj[v][0] ? rt[v] : u);\n\t\t\tdfsHld(u);\n\t\t}\n\t}\n\ttemplate <class B> void process(int u, int v, B op) {\n\t\tfor (; rt[u] != rt[v]; v = par[rt[v]]) {\n\t\t\tif (depth[rt[u]] > depth[rt[v]]) swap(u, v);\n\t\t\top(pos[rt[v]], pos[v] + 1);\n\t\t}\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\top(pos[u] + VALS_EDGES, pos[v] + 1);\n\t}\n\tvoid modifyPath(int u, int v, int val) {\n\t\tprocess(u, v, [&](int l, int r) { tree->add(l, r, val); });\n\t}\n\tint queryPath(int u, int v) { // Modify depending on query\n\t\tint res = -1e9;\n\t\tprocess(u, v, [&](int l, int r) {\n\t\t\t\tres = max(res, tree->query(l, r));\n\t\t});\n\t\treturn res;\n\t}\n\tint querySubtree(int v) { // modifySubtree is similar\n\t\treturn tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);\n\t}\n};\n\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<int> par1(n);\n\tvector<vector<int> > ch1(n);\n\tpar1[0] = -1;\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> par1[i];\n\t\tpar1[i]--;\n\t\tch1[par1[i]].push_back(i);\n\t}\n\tvector<int> par2(n);\n\tvector<vector<int> > ch2(n);\n\n\tvector<vector<int> > e2(n);\n\tpar2[0] = -1;\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> par2[i];\n\t\tpar2[i]--;\n\t\tch2[par2[i]].push_back(i);\n\t\te2[i].push_back(par2[i]);\n\t\te2[par2[i]].push_back(i);\n\t}\n\tvector<pair<int,int> > events;\n\ty_combinator([&](auto self, int v) -> void {\n\t\tevents.push_back({0, v});\n\t\tfor(int w : ch1[v]){\n\t\t\tself(w);\n\t\t}\n\t\tevents.push_back({1, v});\n\t})(0);\n\tvector<int> st(n);\n\tvector<int> en(n);\n\tint T = 0;\n\ty_combinator([&](auto self, int v) -> void {\n\t\tst[v] = T;\n\t\tT++;\n\t\tfor(int w : ch2[v]){\n\t\t\tself(w);\n\t\t}\n\t\ten[v] = T-1;\n\t})(0);\n\n\tvector<int> idx(n);\n\tfor(int i = 0; i < n; i++){\n\t\tidx[st[i]] = i;\n\t}\n\n\tHLD<false> hld(e2);\n\tset<int> alive_set;\n\tint ans = 0;\n\tint cnt = 0;\n\tvector<int> used(n, 0);\n\tfor(auto [type, v] : events){\n\t\tif(type == 0){\n\t\t\tint w = hld.queryPath(0, v);\n\t\t\tif(w >= 0){\n\t\t\t\tw = idx[w];\n\t\t\t\tif(used[w]){\n\t\t\t\t\tused[w] = 0;\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t\thld.modifyPath(v, v, 1 + st[v]);\n\t\t\talive_set.insert(st[v]);\n\t\t\tauto f = alive_set.upper_bound(st[v]);\n\t\t\tif(f == alive_set.end() || *f > en[v]){\n\t\t\t\tused[v] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else if(type == 1){\n\t\t\thld.modifyPath(v, v, -(1 + st[v]));\n\t\t\talive_set.erase(st[v]);\n\t\t\tif(used[v]){\n\t\t\t\tused[v] = 0;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tint w = hld.queryPath(0, v);\n\t\t\tif(w >= 0){\n\t\t\t\tw = idx[w];\n\t\t\t\tif(!used[w]){\n\t\t\t\t\tauto f = alive_set.upper_bound(st[w]);\n\t\t\t\t\tif(f == alive_set.end() || *f > en[w]){\n\t\t\t\t\t\tused[w] = 1;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else assert(false);\n\t\tans = max(ans, cnt);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2300,Let s start with some observations Take any clique in the memorial graph Notice that the vertices of are a subset of a path from root to some leaf in Soroush s tree So it s sufficient to solve the task for every leaf in Soroush s tree specifically we should consider subsets of the paths starting from the root and ending in a leaf in Soroush s tree Assume you have a data structure that supports the following operations Insert a vertex Erase a vertex Among the vertices inside it find the biggest set of vertices such that none of them is the ancestor of the other in Keshi s tree To solve the task start doing DFS from the root of Soroush s tree Every time you visit a new vertex add using the st operation Every time you finish doing DFS in a vertex erase using the nd operation It s easy to see that the vertices in the data structure always form a path from root to some vertex in Soroush s tree The answer to the task is the maximum size of in the rd operation for every leaf of Soroush s tree when adding has been the last operation in the data structure In other words where is the size of in the rd operation whenever you reach a leaf while doing DFS in Soroush s tree When adding a vertex to the data structure if no vertex existed such that was in s subtree in Keshi s tree consider the following cases If no ancestor of was in greedily add to Otherwise let that ancestor be erase from and add instead On the other hand if such a vertex already existed in we won t add to based on the greedy solution mentioned above Whatever notation used from here onwards refers to Keshi s tree unless stated Do a DFS on the tree and find the starting time finishing time for each vertex It s widely known that vertex is an ancestor of vertex and Observation for any pair of vertices and segments and either don t share an element or one of them lies completely inside the other To construct the aforementioned data structure Let the set be a maximal set of the vertices that form a clique in the memorial graph For each vertex we store a pair in Now to check whether any vertex in the subtree of vertex exists in Let be the first pair in such that the first element in If s second element s finishing time is less than then s second element is in s subtree otherwise it s not Now to check whether any ancestor of is in or not Let be the first pair in such that s first element is less than it can be proved that if an ancestor of exists in then thus we can check if is in the subtree of s second element by the aforementioned observation Doing the erase operation is also possible by keeping a history of the deleted elements from the set complexity 
You re given a tree consisting of n nodes Every node u has a weight a u It is guaranteed that there is only one node with minimum weight in the tree For every node u except for the node with the minimum weight it must have a neighbor v such that a v a u You should construct a tree to minimize the weight w calculated as follows For every node u deg u cdot a u is added to w deg u is the number of edges containing node u For every edge u v lceil log 2 dist u v rceil cdot min a u a v is added to w where dist u v is the number of edges in the path from u to v in the given tree ,"['#include<iostream>\n#include<cstdio>\n#include<vector>\n#define N (1001010)\n#define LL long long\nusing namespace std;\nint n,A[N],rt,f[N][40];\nvector <int> Vec[N];\nLL ans;\nvoid Dfs(int x){\n\tfor (int i=0;i<Vec[x].size();i++){\n\t\tint y=Vec[x][i];\n\t\tif (y==f[x][0]) continue;\n\t\tf[y][0]=x;\n\t\tDfs(y);\n\t}\n}\nLL Lmin(LL a,LL b){\n\tif (a<b) return a;\n\treturn b;\n}\nint main(){\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++) scanf(""%d"",&A[i]);\n\trt=1;\n\tfor (int i=2;i<=n;i++) if (A[i]<A[rt]) rt=i;\n\tfor (int i=1;i<n;i++){\n\t\tint x,y; scanf(""%d %d"",&x,&y);\n\t\tVec[x].push_back(y);\n\t\tVec[y].push_back(x);\n\t}\n\tDfs(rt);\n\tf[rt][0]=rt;\n\tfor (int j=1;j<=30;j++) for (int i=1;i<=n;i++)\n\t\tf[i][j]=f[f[i][j-1]][j-1];\n\t\n\tfor (int i=1;i<=n;i++) if (i!=rt){\n\t\tLL Min=(LL)A[f[i][0]]+(LL)A[i];\n\t\tfor (int k=1;k<=30;k++)\n\t\t\tMin=Lmin(Min,(LL)k*(LL)min(A[i],A[f[i][k]])+(LL)(A[i]+A[f[i][k]]));\n\t\tans+=Min;\n\t}\n\tcout<<ans;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2800,First let s reduce the problem to ordinary MST We know that each edge adds to In fact it also adds 1 to and Thus the problem is ordinary MST on a complete graph where each edge has weight Let the node with the minimum weight be Let s root the tree at it Lemma for every node and a child In simpler words the weight increase as we go down the tree Proof the proof is by contradiction Assume Then the condition in the problem that every node has an adjacent node with less weight isn t satisfied yet for Therefore must have a child such that However the condition isn t satisfied for so needs another child and the child needs another child etc the tree will be infinite which is clearly a contradiction From that we know that the weights decrease as we go up the tree and increase as we go down Back to the MST problem From Kruskal s algorithm we know that the minimal edge incident to every node will be added to the MST because the edges are sorted by weight Let s analyze the minimal edge incident to every node Let its other end be Except for node will be an ancestor of Why Assume we fix the distance part and just want to minimize We ll keep going up the tree it s never optimal to go down since the weights will increase until we reach the desired distance Now since the minimal edge incident to every node will be added to the MST by Kruskal s algorithm and they re distinct because otherwise you re saying that is an ancestor of and is an ancestor of THEY ARE THE MST Now the problem just reduces to finding the minimal edge incident to every node and summing them up except for To do that we ll fix the let it be and get the ancestor with the well known sparse table binary lifting Code link https pastebin com vzJqh8si Time complexity 
You are given n integers You need to choose a subset and put the chosen numbers in a beautiful rectangle rectangular matrix Each chosen number should occupy one of its rectangle cells each cell must be filled with exactly one chosen number Some of the n numbers may not be chosen A rectangle rectangular matrix is called beautiful if in each row and in each column all values are different What is the largest by the total number of cells beautiful rectangle you can construct Print the rectangle itself ,"['#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define N_ 401000\nusing namespace std;\nint n, w[N_];\n\nstruct AA {\n\tint c, a;\n\tbool operator <(const AA &p)const {\n\t\treturn c < p.c;\n\t}\n}U[N_];\n\nint A, B;\n\nvoid UDT(int x, int y) {\n\tif (A*B<x*y) {\n\t\tA = x, B = y;\n\t}\n}\n\nvoid Solve() {\n\tint i, j;\n\tmap<int, int>Map;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &w[i]);\n\t\tMap[w[i]]++;\n\t}\n\tint cnt = 0;\n\tfor (auto &t : Map) {\n\t\tcnt++;\n\t\tU[cnt] = { t.second,t.first };\n\t}\n\tsort(U + 1, U + cnt + 1);\n\tint pv = 0, s = 0;\n\tfor (i = 1; i*i <= n; i++) {\n\t\twhile (pv + 1 <= cnt && U[pv + 1].c <= i) {\n\t\t\ts += U[pv + 1].c;\n\t\t\tpv++;\n\t\t}\n\t\tint tot = (cnt - pv) * i + s;\n\t\tif (tot >= i * i) {\n\t\t\tUDT(i, tot/i);\n\t\t}\n\t}\n\ts = A * B;\n\tfor (i = 1; i <= cnt; i++) {\n\t\tif (U[i].c > A) U[i].c = A;\n\t\tU[i].c = min(U[i].c, s);\n\t\ts -= U[i].c;\n\t}\n\tprintf(""%d\\n%d %d\\n"", A*B, A, B);\n\tvector<vector<int>>V;\n\tV.resize(A);\n\tfor (i = 0; i < A; i++)V[i].resize(B);\n\tsort(U + 1, U + cnt + 1);\n\tint x = 0, y = 0;\n\tfor (i = cnt; i >= 1; i--) {\n\t\twhile (U[i].c) {\n\t\t\tV[x][y%B] = U[i].a;\n\t\t\tU[i].c--;\n\t\t\tx++, y++;\n\t\t\tif (x >= A) {\n\t\t\t\tx -= A;\n\t\t\t\ty -= A - 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < A; i++) {\n\t\tfor (j = 0; j < B; j++) {\n\t\t\tprintf(""%d "", V[i][j]);\n\t\t}\n\t\tputs("""");\n\t}\n}\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin);\n\tint TC = 1;\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}']","[1, 1, 0, 0, 1, 1, 1, 0, 0, 0]",2300,First let s formulate the criteria that from the given set of numbers x1 x2 xk we can create a beautiful rectangle a b where a b k a b Obviously if some number occurs more than a times then among a rows there will be such row that will contain two or more occurrences of the number pigeonhole principle Let s prove that if all numbers in x 1 k occur no more than a times we can create a beautiful rectangle a b where a b k a b We will numerate cells from the upper left corner in the order from one moving diagonally each time Assume rows are numerated from 0 to a 1 and columns are numerated from 0 to b 1 Let s begin from the cell 0 0 and move right down each time If we face to a border we will move cyclically Thus from the cell i j we will move to the cell i 1 moda j 1 modb each time where pmodq is the remainder when divided p by q If we are going to move to a visited cell before moving let s assign i i 1 moda Example of the numeration for rectangles 3 3 and 4 6 We can also prove that while such numeration each row and each column contain numbers that differ by no less than a 1 if we are on a row column we will make a turn before we will be on the row column again Moreover the difference reaches a 1 not a when we move to the previously visited cell and assign i i 1 moda So we can prove that the lengths of such orbits are equal lcm a b lcm is a least common multiple Consequently they are divided by a It means that if we will arrange the numbers from x in the order from the most common at worst case those that meet a times to the least common each row and each column will always contain different numbers Thus we have a plan of the solution find optimal a and b so that the answer is the largest rectangle a b a b For this we will iterate over all possible candidates in a and for each candidate each number v from x we will use it no more than min cv a times where cv is a number of occurrences v in the given sequence So if we choose a the upper bound of a rectangle area is min cv a for all possible different numbers v from the given sequence Consequently the maximal value of b is min cv a a And let s update the answer if for current iteration a b is larger than previously found answer still consider that a b We can maintain the value min cv a while a is incremented by one For doing this we should each time add geq a to this value where geq a is a number of different numbers in the given sequence which occurs at least a times we can precalculate this array 
Vitya has learned that the answer for The Ultimate Question of Life the Universe and Everything is not the integer 42 but an increasing integer sequence a 1 ldots a n In order to not reveal the secret earlier than needed Vitya encrypted the answer and obtained the sequence b 1 ldots b n using the following rules b 1 a 1 b i a i oplus a i 1 for all i from 2 to n where x oplus y is the bitwise XOR of x and y It is easy to see that the original sequence can be obtained using the rule a i b 1 oplus ldots oplus b i However some time later Vitya discovered that the integers b i in the cypher got shuffled and it can happen that when decrypted using the rule mentioned above it can produce a sequence that is not increasing In order to save his reputation in the scientific community Vasya decided to find some permutation of integers b i so that the sequence a i b 1 oplus ldots oplus b i is strictly increasing Help him find such a permutation or determine that it is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define PB push_back\n#define LL long long\n#define REP(i, x) for( int i = 0; i < x; i++ )\n#define FOR(i, x) for( int i = 1; i <=x; i++ )\n#define FORALL(it, x) for(__typeof(x.begin()) it = x.begin(); it != x.end(); it++ )\n#define BACK(i, x) for( int i = x-1; i >= 0; i-- )\n\nint n;\n\ntypedef vector<long long> VI;\n\nVI worki[61];\nVI wszystkie;\n\nVI perm;\nVI nowy;\n\nvoid wczytaj(){\n    cin >> n;\n    REP(i, n){\n        LL a;\n        cin >> a;\n        wszystkie.PB(a);\n    }\n}\n\ninline LL pow(int k){\n    LL a = 1;\n    a <<= k;\n    return a;\n}\n\nvoid posegreguj(){\n    BACK(i, 60) FORALL(it, wszystkie)\n        if( *it >= pow(i) ){\n            worki[i].PB(*it);\n            *it = -1;\n        }\n}\n\nbool znajdz_perma(){\n    BACK(i, 60){\n        //cout << i << endl;\n        bool akt = 0;\n        nowy.clear();\n        int j = 0;\n        int s = perm.size();\n        FORALL(it, worki[i]){\n            while( akt && j < s ){\n                nowy.PB(perm[j]);\n                if( perm[j] & pow(i) ) akt = 0;\n                j++;\n            }\n            if( akt == 0 ){\n                nowy.PB(*it);\n                akt = 1;\n            }\n            else return 0;\n        }\n        while( j < s ) nowy.PB(perm[j++]);\n        perm.clear();\n        FORALL(it, nowy) perm.PB(*it);\n        //FORALL(it, perm) cout << *it << "" ""; cout << endl;\n    }\n    return 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    wczytaj();\n    posegreguj();\n    if( znajdz_perma() ){\n        cout << ""Yes\\n"";\n        FORALL(it, perm) cout << *it << "" "";\n        cout << endl;\n    }\n    else cout << ""No\\n"";\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",2200,Let s assume that we ve found a suitable permutation of all numbers except all occurences of the number 1 When can we insert the 1 s so that the new arrangement of numbers is again good We can see that the XOR of all numbers before any occurence of the number 1 must be even so there should an even number of odd numbers before it Suppose that there are x 1 s in the input and y odd numbers greater than 1 If x y 1 then in any arrangement there is going to be a pair of 1 s such that there are no odd numbers between them hence the condition above cannot hold for both of them simultaneously On the other hand if x y 1 then it is possible to insert the 1 s into any permutation of greater numbers Indeed we can place one instance of 1 at the start and then place remaining 1 s immediately after greater odd numbers Note that this argument works just as well if we consider numbers in the range 2k 2k 1 as 1 s and numbers in 2k 1 as numbers greater than 1 Note further that it doesn t matter how exactly we insert the 1 s since number of available gaps doesn t depend on that Hence we can go as follows group the numbers by their leading bits Make an empty list for the answer and process the numbers in groups by decreasing of their leading bits Suppose there are x numbers with leading bit k and y greater numbers that have 1 in the k th bit If x y 1 then there is no answer Otherwise insert the numbers from the current group as described above The complexity of this solution is O nlogA where A is the largest value among the numbers in the input 
A very brave explorer Petya once decided to explore Paris catacombs Since Petya is not really experienced his exploration is just walking through the catacombs Catacombs consist of several rooms and bidirectional passages between some pairs of them Some passages can connect a room to itself and since the passages are built on different depths they do not intersect each other Every minute Petya arbitrary chooses a passage from the room he is currently in and then reaches the room on the other end of the passage in exactly one minute When he enters a room at minute he makes a note in his logbook with number If Petya has visited this room before he writes down the minute he was in this room last time Otherwise Petya writes down an arbitrary non negative integer strictly less than current minute Initially Petya was in one of the rooms at minute he didn t write down number At some point during his wandering Petya got tired threw out his logbook and went home Vasya found his logbook and now he is curious what is the minimum possible number of rooms in Paris catacombs according to Petya s logbook ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 200001;\n\nint c[MAXN];\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n;\n    cin >> n;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        if (x <= 0 || c[x] == 1) {\n            ans++;\n        } else {\n            if (x > 0) {\n                c[x] = 1;\n            }\n        }\n    }\n\n    cout << ans << ""\\n"";\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,First we notice that if journal contains two equal notes ti tj i j then at least one of them was made in newly visited room because otherwise tj would be at least i Thus there could be at most one note corresponding to previously visited room among equal notes Let s denote by cnti number of occurrences of i in the journal From the previous statement we deduce that minimum possible number of rooms is at least Also it s easy to see that this value can be achieved we say that first occurrence of each value corresponds to revisiting the previous room and all other correspond to visiting new rooms So the problem can be solved by calculating values cnti for each i between 0 and n and calculating the above sum 
Xenia the mathematician has a sequence consisting of is divisible by 3 positive integers each of them is at most 7 She wants to split the sequence into groups of three so that for each group of three the following conditions held divides divides Naturally Xenia wants each element of the sequence to belong to exactly one group of three Thus if the required partition exists then it has groups of three Help Xenia find the required partition or else say that it doesn t exist ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#define lson step << 1\n#define rson step << 1 | 1\n#define lowbit(x) (x & (-x))\n#define Key_value ch[ch[root][1]][0] \nusing namespace std;\ntypedef long long LL;\nconst int N = 500005;\nconst int inf = 1000000009;\nint n , a[N] , c[10];\nvector<pair<pair<int , int> , int> > v;\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n        // freopen (""output.txt"" , ""w"" , stdout);\n    #endif\n    cin >> n;\n    for (int i = 0 ; i < n ; i ++) {\n        cin >> a[i];\n        c[a[i]] ++;\n    }\n    if (c[5] || c[7]) {\n        puts (""-1"");\n        return 0;\n    }\n    for (int i = 0 ; i < c[4] ; i ++)\n        v.push_back (make_pair(make_pair(1 , 2) , 4));\n    c[2] -= c[4];c[1] -= c[4];\n    for (int i = 0 ; i < c[3] ; i ++)\n        v.push_back (make_pair(make_pair(1 , 3) , 6));\n    c[6] -= c[3];c[1] -= c[3];\n    if (c[1] < 0 || c[2] < 0 || c[6] < 0) {\n        puts (""-1"");\n        return 0;\n    }\n    if (c[1] != c[2] || c[2] != c[6] || c[1] != c[6]) {\n        puts (""-1"");\n        return 0;\n    }\n    for (int i = 0 ; i < v.size() ; i ++)\n        cout << v[i].first.first << "" "" << v[i].first.second << "" "" << v[i].second << endl;\n    for (int i = 0 ; i < c[1] ; i ++)\n        cout << ""1 2 6"" << endl;\n    return 0;\n}       \n\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1200,In this problem you should guess that exists only three valid groups of three 1 1 2 4 2 1 2 6 3 1 3 6 You can see that integers 5 and 7 are bad So we will greedy take these groups of three If some integers will be not used the answer is 1 In other case print found answer 
One day decided to play around with arrays and came up with the following problem You are given an array a which consists of n positive integers The array is numerated 1 through n You execute the following procedure You create a new array b which consists of 2n integers where for each 1 le i le n the condition b 2i 1 b 2i a i holds For example for the array a 6 8 2 you can create b 2 4 4 4 1 1 You merge consecutive equal numbers in b For example b 2 4 4 4 1 1 becomes b 2 4 1 Find and print value of b size of b which can be achieved at the end of the procedure It can be shown that under the given constraints there is at least one way to construct b ,"[""/**\n *    author:  tourist\n *    created: 27.09.2020 18:32:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    const int inf = (int) 1.01e9;\n    long long L = 1;\n    long long R = inf;\n    set<long long> s;\n    long long sign = 1;\n    long long delta = 0;\n    int ans = 0;\n    for (int x : a) {\n      if (x % 2 == 1) {\n        swap(L, R);\n        L = max(x - L, 1LL);\n        R = min(x - R, x - 1LL);\n        sign *= -1;\n        delta *= -1;\n        delta += x;\n        while (!s.empty()) {\n          long long val = (*s.begin()) * sign + delta;\n          if (val < 1 || val >= x) {\n            s.erase(s.begin());\n          } else {\n            break;\n          }\n        }\n        while (!s.empty()) {\n          auto it = prev(s.end());\n          long long val = (*it) * sign + delta;\n          if (val < 1 || val >= x) {\n            s.erase(it);\n          } else {\n            break;\n          }\n        }\n        if (s.empty() && L > R) {\n          sign = 1;\n          delta = 0;\n          L = 1;\n          R = x - 1;\n        } else {\n          ans += 1;\n        }\n      } else {\n        swap(L, R);\n        L = max(x - L, 1LL);\n        R = min(x - R, x - 1LL);\n        sign *= -1;\n        delta *= -1;\n        delta += x;\n        if ((L <= x / 2 && x / 2 <= R) || s.find((x / 2 - delta) * sign) != s.end()) {\n          ans += 2;\n          s.clear();\n          sign = 1;\n          delta = 0;\n          L = x / 2;\n          R = x / 2;\n        } else {\n          while (!s.empty()) {\n            long long val = (*s.begin()) * sign + delta;\n            if (val < 1 || val >= x) {\n              s.erase(s.begin());\n            } else {\n              break;\n            }\n          }\n          while (!s.empty()) {\n            auto it = prev(s.end());\n            long long val = (*it) * sign + delta;\n            if (val < 1 || val >= x) {\n              s.erase(it);\n            } else {\n              break;\n            }\n          }\n          s.insert((x / 2 - delta) * sign);\n          ans += 1;\n        }\n      }\n    }\n    cout << 2 * n + 1 - ans << '\\n';\n  }\n  return 0;\n}\n""]","[1, 0, 0, 1, 1, 0, 0, 1, 0, 0]",3200,Note that minimizing is the same as maximizing the number of consecutive equal pairs We will focus on the second version Let s forget about constraints and consider the most naive solution with dynamic programming will store the answer if we have already considered and our last element is equal to Let s get rid of our dimension and keep our table by layers Suppose that our current th layer is called next layer is called and is called After carefully analyzing our transitions we have the following observations for any since we always have a transition from our maximum since we can add at most two pairs The case may occur only if is even Moreover will be the only maximum element For some suffix upto we always have a transition from to If is even instead of calculating separately we can calculate it as usual and increase its value by at the end Using everything said above we could replace our naive with the following A variable called the value of minimum of our current layer A set called it keeps all indices such that A variable called it is equal to or depending on the parity of and the value of Basically we want to be able to Erase some elements from the prefix suffix of our set Check if some number is in our set Add a segment of values into out set Rotate all elements in our set by a pivot That is a number should turn into We can efficiently process all queries by maintaining as a simple set of non intersecting segments The rotation operation can be done as follows Suppose we had an integer at the beginning We rotate everything by a pivot becomes We rotate everything by a pivot becomes Following the logic We can just maintain the sign of and a global pivot which is the combination of all our rotation operations Time complexity Space complexity 
Everybody knows that the Berland citizens are keen on health especially students Berland students are so tough that all they drink is orange juice Yesterday one student Vasya and his mates made some barbecue and they drank this healthy drink only After they ran out of the first barrel of juice they decided to play a simple game All people who came to the barbecue sat in a circle thus each person received a unique index from 0 to The person number 0 started the game this time it was Vasya All turns in the game were numbered by integers starting from 1 If the th turn was made by the person with index then this person acted like that he pointed at the person with index either with an elbow or with a nod is the remainder after dividing by if and the players who had turns number made during their turns the same moves as player on the current turn then he had drunk a glass of juice the turn went to person number The person who was pointed on the last turn did not make any actions The problem was Vasya s drunk too much juice and can t remember the goal of the game However Vasya s got the recorded sequence of all the participants actions including himself Now Vasya wants to find out the maximum amount of juice he could drink if he played optimally well the other players actions do not change Help him You can assume that in any scenario there is enough juice for everybody ,"['#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#define  MP(x,y) make_pair((x),(y))\n\nusing namespace std;\n\nconst int Maxn=2010;\nint n;\nchar str[Maxn];\n\nint main()\n{\n    int i,j;\n    while(~scanf(""%d"",&n))\n    {\n        int cnt=0;\n        scanf(""%s"",str);\n        int len=strlen(str);\n        for(i=n;i<len;i+=n)\n        {\n            if(str[i-1]==str[i-2] && str[i-2]==str[i-3])\n            cnt++;\n        }\n        printf(""%d\\n"",cnt);\n    }\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,Since one Vasya s turn does not affect his other turns Consequently you should find just the number of positions 0 indexed in the given string which indexes are multiples of and before which there are at least three same symbols Asymptotics of the solution Code 
Vasily the bear has a it has one vertex at point and the opposite vertex at point Of course the sides of Vasya s favorite rectangle are parallel to the coordinate axes Vasya also loves triangles if the triangles have one vertex at point That s why today he asks you to find two points and such that the following conditions hold the coordinates of points are integers Besides the following inequation holds the triangle formed by point and is rectangular and isosceles is right all points of the favorite rectangle are located inside or on the border of triangle the area of triangle is as small as possible Help the bear find the required points It is not so hard to proof that these points are unique ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint x, y, x1, y1, x2, y2;\n\nint main()\n{\n\tscanf(""%d %d"", &x, &y);\n\tif (x > 0)\n\t{\n\t\tif (y > 0)\n\t\t{\n\t\t\tx1 = x + y, y1 = 0;\n\t\t\tx2 = 0, y2 = x + y;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tx1 = x - y, y1 = 0;\n\t\t\tx2 = 0, y2 = 0 - (x - y);\n\t\t}\n\t}\n\n\telse\n\t{\n\t\tif (y < 0)\n\t\t{\n\t\t\tx1 = x + y, y1 = 0;\n\t\t\tx2 = 0, y2 = x + y;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tx1 = x - y, y1 = 0;\n\t\t\tx2 = 0, y2 = 0 - (x - y);\n\t\t}\n\t}\n\t\n\tif (x1 > x2)\n\t\tswap(x1, x2), swap(y1, y2);\n\tprintf(""%d %d %d %d\\n"", x1, y1, x2, y2);\n\treturn 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1000, Then first point is second Swap points if needed according to statement Let s see why this is the answer Conditions and give us that one point is on X axis and the other on Y axis Let s see how it works for and Other cases can be proved in similar way We need to show that belongs to our triangle including it s borders In fact belongs to segment connecting with Line through and is Using coordinates in this equation proves the statement Author s solution 
There are n cdot m unit cubes currently in positions 1 1 1 through n m 1 Each of these cubes is one of k colors You want to add additional cubes at any integer coordinates such that the subset of cubes of each color is connected where two cubes are considered connected if they share a face In other words for every pair of cubes of the same color c it should be possible to travel from one to the other moving only through cubes of color c that share a face The existing cubes are currently in the corner of a room There are colorless cubes completely filling the planes x 0 y 0 and z 0 preventing you from placing additional cubes there or at any negative coordinates Find a solution that uses at most 4 cdot 10 5 additional cubes not including the cubes that are currently present or determine that there is no solution It can be shown that under the given constraints if there is a solution there is one using at most 4 cdot 10 5 additional cubes ,"['//    苔花如米小，也学牡丹开。 //    Zhikun Wang (nocriz)//    2024年4月27日\xa0#include <bits/stdc++.h>using namespace std; using ll = long long; using db = long double; using str = string;using pi = pair<int,int>; using pl = pair<ll,ll>; using pd = pair<db,db>;using vi = vector<int>; using vb = vector<bool>; using vl = vector<ll>;using vd = vector<db>; using vs = vector<str>;using vpi = vector<pi>; using vpl = vector<pl>; using vpd = vector<pd>;\xa0#define tcT template<class T#define tcTU tcT, class UtcT> using V = vector<T>;  tcT, size_t SZ> using AR = array<T,SZ>; tcT> using PR = pair<T,T>;\xa0#define mp make_pair #define f first#define s second#define sz(x) int((x).size())#define bg(x) begin(x)#define all(x) bg(x), end(x)#define rall(x) x.rbegin(), x.rend() #define sor(x) sort(all(x)) #define rsz resize#define ins insert #define ft front()#define bk back()#define pb push_back#define eb emplace_back #define pf push_front#define lb lower_bound#define ub upper_bound\xa0tcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\xa0#define FOR(i,a,b) for (int i = (a); i < (b); ++i)#define F0R(i,a) FOR(i,0,a)#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)#define R0F(i,a) ROF(i,0,a)#define each(a,x) for (auto& a: x)\xa0const int MOD = 1e9+7;const ll INF = 1e18; // not too close to LLONG_MAXconst db PI = acos((db)-1);const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); template<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\xa0constexpr int pct(int x) { return __builtin_popcount(x); } // # of bits setconstexpr int bits(int x) { return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) constexpr int p2(int x) { return 1<<x; }constexpr int msk2(int x) { return p2(x)-1; }ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded upll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded downtcT> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }tcT> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }tcTU> T fstTrue(T lo, T hi, U f) { hi ++; assert(lo <= hi); while (lo < hi) { T mid = lo+(hi-lo)/2; f(mid) ? hi = mid : lo = mid+1; } return lo; }tcTU> T lstTrue(T lo, T hi, U f) { lo --; assert(lo <= hi); while (lo < hi) { T mid = lo+(hi-lo+1)/2; f(mid) ? lo = mid : hi = mid-1; } return lo; }tcT> void remDup(vector<T>& v) { sort(all(v)); v.erase(unique(all(v)),end(v)); }tcTU> void erase(T& t, const U& u) { auto it = t.find(u); assert(it != end(t)); t.erase(it); } #define tcTUU tcT, class ...Uinline namespace Helpers { tcT, class = void> struct is_iterable : false_type {}; tcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>())) > > : true_type {}; tcT> constexpr bool is_iterable_v = is_iterable<T>::value; tcT, class = void> struct is_readable : false_type {}; tcT> struct is_readable<T, typename std::enable_if_t< is_same_v<decltype(cin >> declval<T&>()), istream&> > > : true_type {}; tcT> constexpr bool is_readable_v = is_readable<T>::value; tcT, class = void> struct is_printable : false_type {}; tcT> struct is_printable<T, typename std::enable_if_t< is_same_v<decltype(cout << declval<T>()), ostream&> > > : true_type {}; tcT> constexpr bool is_printable_v = is_printable<T>::value;}inline namespace Input { tcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>; tcTUU> void re(T& t, U&... u); tcTU> void re(pair<T,U>& p); tcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } tcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } tcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); tcTU> void re(pair<T,U>& p) { re(p.f,p.s); } tcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) { each(x,i) re(x); } tcTUU> void re(T& t, U&... u) { re(t); re(u...); }}inline namespace ToString {  tcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;  tcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {   stringstream ss; ss << fixed << setprecision(15) << v;   return ss.str(); }  tcT> str bit_vec(T t) {   str res = ""{""; F0R(i,sz(t)) res += ts(t[i]);   res += ""}""; return res; }  str ts(V<bool> v) { return bit_vec(v); }  template<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); }   tcTU> str ts(pair<T,U> p);  tcT> typename enable_if<needs_output_v<T>,str>::type ts(T v);   tcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }  tcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {   bool fst = 1; str res = """";   for (const auto& x: v) {    if (!fst) res += sep;    fst = 0; res += ts(x);   }   return res;  }  tcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {   return ""{""+ts_sep(v,"", "")+""}""; }  template<int, class T> typename enable_if<!needs_output_v<T>,vs>::type     ts_lev(const T& v) { return {ts(v)}; }  template<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type     ts_lev(const T& v) {   if (lev == 0 || !sz(v)) return {ts(v)};   vs res;   for (const auto& t: v) {    if (sz(res)) res.bk += "","";    vs tmp = ts_lev<lev-1>(t);    res.ins(end(res),all(tmp));   }   F0R(i,sz(res)) {    str bef = "" ""; if (i == 0) bef = ""{"";    res[i] = bef+res[i];   }   res.bk += ""}"";   return res;  } }inline namespace Output { template<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); } template<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {pr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); } template<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } void ps() { cout << ""\\n""; } template<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } template<class ...T> void dbg_out(const T&... t) { pr_sep(cerr,"" | "",t...); cerr << endl; }void loc_info(int line, str names) { cerr << ""Line("" << line << "") -> ["" << names << ""]: ""; } template<int lev, class T> void dbgl_out(const T& t) { cerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; } }#ifdef LOCAL\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)#else \t#define dbg(...) 0\t#define dbgl(lev,x) 0#endifvoid decrement() {} // subtract one from eachtcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\xa0// re(a,b,c,...) reads vectors, arrays of pairs, complex, etc// pr(a,b,c,...) prints with no spaces. ps(a,b,c,...) prints with space and \\n.// All outputs uses ts() to generate string. vectors, bitsets, pairs, OK// dbg() debugs stuff. dbgl() debugs stuff with level.\xa0int n, m, k;\xa0int a[110][110];int main() {\tcin.tie(0)->sync_with_stdio(0);\tre(n, m, k);\tfor(int i=1;i<=n;i++) {\t\tfor(int j=1;j<=m;j++) {\t\t\tre(a[i][j]);\t\t}\t}\tint ct = 0;\tvi fi;\tvector<vi> ans;\tfor(int i= n;i>=1;i--) {\t\tct += 1;\t\tif((n-i)%2 == 0){\t\t\tfi.pb(ct);\t\t\tct += 1;\t\t}\t\tfor(int j=1;j<=m;j++) {\t\t\tint ci = i, ck = 1, cc = a[i][j];\t\t\twhile(ck < ct) {\t\t\t\tck += 1;\t\t\t\tans.pb({ci, j, ck, cc});\t\t\t}\t\t\twhile(ci < n + k) {\t\t\t\tci += 1;\t\t\t\tans.pb({ci, j, ck, cc});\t\t\t}\t\t}\xa0\t}\t//ans.pb({0, 0, 0, 0});\tct += 1;\tfi.pb(ct);\tfor(int c=1;c<=k;c++) {\t\tfor(auto ck: fi) {\t\t\tfor(int j=1;j<=m;j++) {\t\t\t\tans.pb({c + n, j, ck, c});\t\t\t}\t\t}\t\tfor(int ck=1;ck<=fi.back();ck++) {\t\t\tans.pb({c + n, m+1, ck, c});\t\t}\xa0\t//ans.pb({0, 0, 0, 0});\t}\tps(ans.size());\tfor(auto ct:ans){\t\tps(ct[0], ct[1], ct[2], ct[3]);\t}// END OF CODE\treturn 0;}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3100,We can show that a solution always exists This example with will demonstrate the construction we will use First extend each of the even columns up by spaces keeping all cubes in a given vertical column the same color Then for the odd columns do something similar except we use the bottom rows to bend them around so the tops point out to the right After that extend each of these new bent rows each of which corresponds to an input cube in an odd column to the right by Now each initial cube in the by grid corresponds to one of these extended rows or columns each of which is a connected group Fill in the remaining columns between the even columns with rows each The th of these should be color Now do the same for the odd columns At this point each cell of a given color is connected to at least one of the rows columns we added in the last two steps Now we want to connect all of those by color Start by adding these rows Followed by these rows Once again at this point each cube of a given color is connected to one of the rows of that color we added in the last two steps So the last remaining step is to connect them Now all cubes of each color are connected This construction uses exactly additional cubes Since this is at most which fits within the bounds of the problem Complexity 
You are given an array of positive integers of length We know that for any it is true that Find the length of the longest non decreasing sequence of the given array ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nconst int MAXN = 200;\nconst int MAXV = 400;\n\nconst int V = 310;\n\nint N;\nint T;\n\nint A[MAXV];\n\nint dp[MAXV][MAXV];\nint res[MAXV][MAXV];\nint tmp[MAXV][MAXV];\n\nvoid mult(int a[MAXV][MAXV], int b[MAXV][MAXV]) {\n\tfor(int i = 0; i < V; i++) {\n\t\tfor(int j = i; j < V; j++) {\n\t\t\ttmp[i][j] = 0;\n\t\t\tfor(int k = i; k <= j; k++) {\n\t\t\t\ttmp[i][j] = max(tmp[i][j], a[i][k] + b[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < V; i++) {\n\t\tfor(int j = i; j < V; j++) {\n\t\t\ta[i][j] = tmp[i][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> N;\n\tcin >> T;\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(res, 0, sizeof(res));\n\tfor(int t = 0; t < N; t++) {\n\t\tint v; cin >> v;\n\t\tfor(int i = 0; i <= v; i++) {\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = i; j <= v; j++) {\n\t\t\t\tcnt = max(cnt, dp[i][j]);\n\t\t\t}\n\t\t\tdp[i][v] = max(dp[i][v], cnt + 1);\n\t\t}\n\t}\n\twhile(T) {\n\t\tif(T % 2) {\n\t\t\tmult(res, dp);\n\t\t}\n\t\tmult(dp, dp);\n\t\tT /= 2;\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < V; i++) {\n\t\tfor(int j = i; j < V; j++) {\n\t\t\tans = max(ans, res[i][j]);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}\n""]","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0]",1900, I tried observing the state of the matrix after each line for various inputs but still couldn t get the intuition behind this relation Can someone please explain it 
You have a Petri dish with bacteria and you are preparing to dive into the harsh micro world But unfortunately you don t have any microscope nearby so you can t watch them You know that you have n bacteria in the Petri dish and size of the i th bacteria is a i Also you know intergalactic positive integer constant K The i th bacteria can swallow the j th bacteria if and only if a i a j and a i le a j K The j th bacteria disappear but the i th bacteria doesn t change its size The bacteria can perform multiple swallows On each swallow operation any bacteria i can swallow any bacteria j if a i a j and a i le a j K The swallow operations go one after another For example the sequence of bacteria sizes a 101 53 42 102 101 55 54 and K 1 The one of possible sequences of swallows is 101 53 42 102 underline 101 55 54 to 101 underline 53 42 102 55 54 to underline 101 42 102 55 54 to 42 102 55 underline 54 to 42 102 55 In total there are 3 bacteria remained in the Petri dish Since you don t have a microscope you can only guess what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 200005;\n\nint n, k;\nint a[Maxn];\n\nint main()\n{\n\tscanf(""%d %d"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tvector <int> S;\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (!S.empty() && S.back() < a[i] && a[i] <= S.back() + k)\n\t\t\tS.pop_back();\n\t\tS.push_back(a[i]);\n\t}\n\tprintf(""%d\\n"", int(S.size()));\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1200,It can be proved that the optimal answer equals to a number of bacteria which can t be eaten by any other bacteria So for each bacteria you need to check existence of any bacteria satisfying condition There plenty of ways to check this condition One of them is to sort array and for each find minimal with or with two pointers technique Or you can use the fact that and build solution around it Result complexity is 
Being tired of participating in too many Codeforces rounds Gildong decided to take some rest in a park He sat down on a bench and soon he found two rabbits hopping around One of the rabbits was taller than the other He noticed that the two rabbits were hopping The positions of the two rabbits can be represented as integer coordinates on a horizontal line The taller rabbit is currently on position x and the shorter rabbit is currently on position y x lt y Every second each rabbit hops to another position The taller rabbit hops to the positive direction by a and the shorter rabbit hops to the negative direction by b For example let s say x 0 y 10 a 2 and b 3 At the 1 st second each rabbit will be at position 2 and 7 At the 2 nd second both rabbits will be at position 4 Gildong is now wondering Let s find a moment in time in seconds after which the rabbits will be at the same point ,"['#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\nusing namespace std;\n\n\nint main(){\n\tint T , N , M , x , y;\n\tfor(cin >> T ; T ; --T){\n\t\tcin >> N >> M >> x >> y;\n\t\tcout << ((M - N) % (x + y) == 0 ? (M - N) / (x + y) : -1) << endl;\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,We can see that the taller rabbit will be at position and the shorter rabbit will be at position at the th second We want to know when these two values are equal Simplifying the equation we get Since we only consider positive integers for the answer is only if is divisible by Otherwise the answer is Another intuitive approach is to think of it as relative speed In the perspective of the taller rabbit the shorter rabbit will move or more like teleport to the negative direction at speed of per second Therefore the initial distance must be divisible by in order to make the two rabbits meet at time Time complexity for each test case 
 Interplanetary Software Inc together with Robots of Cydonia Ltd has developed and released robot cats These electronic pets can meow catch mice and entertain the owner in various ways The developers from Interplanetary Software Inc have recently decided to release a software update for these robots After the update the cats must solve the problems about bracket sequences One of the problems is described below First we need to learn a bit of bracket sequence theory Consider the strings that contain characters and Call a string if it can be transformed to an empty string by one or more operations of removing either single characters or a continuous substring For instance the string is an RBS as it can be transformed to an empty string with the following sequence of removals rightarrow rightarrow rightarrow rightarrow We got an empty string so the initial string was an RBS At the same time the string is not an RBS as it is not possible to apply such removal operations to it An RBS is if this RBS is not empty doesn t start with and doesn t end with Denote the of the string s as its sequential subsegment In particular s l dots r s ls l 1 dots s r where s i is the i th character of the string s Now move on to the problem statement itself You are given a string s initially consisting of characters and You need to answer the following queries Given two indices l and r 1 le l r le n It s that the l th character is equal to the r th character is equal to and the characters between them are equal to Then the l th and the r th characters must be set to Given two indices l and r 1 le l r le n and it s that the substring s l dots r is a You need to find the number of substrings in s l dots r such that they are simple RBS In other words find the number of index pairs i j such that l le i j le r and s i dots j is a simple RBS You are an employee in Interplanetary Software Inc and you were given the task to teach the cats to solve the problem above after the update ,"['#include <bits/stdc++.h>\n#define rep(i,n) for (i=1;i<=(n);i++)\nusing namespace std;\nint n,m,i,mat[300007];\nmap<int,int> id[300007];\nchar s[300007];\nint dfc,nfd[600007],deg[600007],fa[600007],ord[600007];\nint snc;\nlong long r[600007];\nvoid add(int x,long long v){\n\twhile(x<=600006){\n\t\tr[x]+=v;\n\t\tx+=(x&-x);\n\t}\n}\nlong long qsum(int x){\n\tlong long ans=0;\n\twhile(x){\n\t\tans+=r[x];\n\t\tx&=(x-1);\n\t}\n\treturn ans;\n}\nint ex[600007];\nvoid add2(int x,int v){\n\twhile(x<=600006){\n\t\tex[x]+=v;\n\t\tx+=(x&-x);\n\t}\n}\nint qsum2(int x){\n\tint ans=0;\n\twhile(x){\n\t\tans+=ex[x];\n\t\tx&=(x-1);\n\t}\n\treturn ans;\n}\nint solve(int l,int r){\n\tint u=++dfc;\n\tid[l][r]=u;\n\tl++;r--;\n\tif(l>r){\n\t\tnfd[u]=dfc;\n\t\treturn u;\n\t}\n\tvector<int> vson;\n\twhile(l<=r){\n\t\tint son;\n\t\tfa[son=solve(l,mat[l])]=u;\n\t\tl=mat[l]+1;\n\t\tdeg[u]++;\n\t\tvson.push_back(son);\n\t}\n\tfor(int son:vson){\n\t\tord[son]=++snc;\n\t}\n\tadd(u,1ll*deg[u]*(deg[u]+1)/2);\n\tnfd[u]=dfc;\n\treturn u;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tscanf("" %s"",s+1);\n\tstack<int> c;\n\trep(i,n){\n\t\tif(s[i]==\'(\') c.push(i);\n\t\telse if(!c.empty()){\n\t\t\tmat[c.top()]=i;\n\t\t\tmat[i]=c.top();\n\t\t\tc.pop();\n\t\t}\n\t}\n\tvector<int> vson;\n\tfor(int i=1;i<=n;i++){\n\t\tif(mat[i]){\n\t\t\tvson.push_back(solve(i,mat[i]));\n\t\t\ti=mat[i];\n\t\t}\n\t}\n\tfor(int son:vson){\n\t\tord[son]=++snc;\n\t}\n\trep(i,snc) add2(i,1);\n\twhile(m--){\n\t\tint op,l,r;\n\t\tscanf(""%d%d%d"",&op,&l,&r);\n\t\tif(op==2){\n\t\t\tint lid=id[l][mat[l]];\n\t\t\tint rid=id[mat[r]][r];\n\t\t\tprintf(""%lld\\n"",qsum(nfd[rid])-qsum(lid-1)+1ll*(qsum2(ord[rid])-qsum2(ord[lid])+1)*(qsum2(ord[rid])-qsum2(ord[lid])+2)/2);\n\t\t}\n\t\telse{\n\t\t\tint i=id[l][r];\n\t\t\tif(fa[i]){\n\t\t\t\tadd(fa[i],-deg[fa[i]]);\n\t\t\t\tdeg[fa[i]]--;\n\t\t\t}\n\t\t\tadd2(ord[i],-1);\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 1]",2800,Now we need to see how to handle removal queries in this task Build an SQRT decomposition in the following way We will rebuild the entire tree after each queries and recalculate the DP Between the rebuilds we hold a list of removed leaves Now look how we can recalculate the answer if some leaves are removed First suppose that the leaf is not a direct child of the vertex we are interested in Then the removal of this leaf decreases the answer by where is the number of children of this leaf s parent Why so The parent of this leaf had the answer as sum of answers in its children plus The answer in the leaf is equal to zero so the new answer became sum plus thus decreased by When we build the DP the modification of answer in a vertex is passed to its parents unchanged So the answer decreases by on the entire path from this leaf to the root We can easily check if we are affected by this removal It must be applied only if the removed leaf lies strictly inside our query of the second type We also need to handle the case where our leaf is a direct child of the vertex we consider as the removal described above doesn t fully apply to this case This is an exercise left to the reader So we get the solution in There is also a solution in We consider it very shortly Let s hold just in each vertex not the sum over children plus as we did before Then the answer for each vertex is the sum in the subtree We can keep a Fenwick tree as we can calculate sums in the subtree with it using Eulerian tour over the tree It s not hard to see that each update must be applied only once to the direct parent 
Fibonacci numbers are the sequence of integers So every next number is the sum of the previous two Bajtek has developed a nice way to compute Fibonacci numbers on a blackboard First he writes a 0 Then below it he writes a 1 Then he performs the following two operations operation replace the top number with the sum of both numbers operation replace the bottom number with the sum of both numbers If he performs operations starting with and then choosing operations alternately so that the sequence of operations looks like the last number written will be equal to Unfortunately Bajtek sometimes makes mistakes and repeats an operation two or more times in a row For example if Bajtek wanted to compute then he would want to do operations If he instead performs the sequence of operations then he will have made 3 mistakes and he will incorrectly compute that the seventh Fibonacci number is 10 The number of mistakes in the sequence of operations is the number of neighbouring equal operations or You are given the number of operations that Bajtek has made in an attempt to compute and the number that is the result of his computations that is last written number Find the minimum possible number of mistakes that Bajtek must have made and any possible sequence of operations resulting in with that number of mistakes Assume that Bajtek always correctly starts with operation ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define INF (1<<29)\n\nchar buf[2000010];\n\nint func(int t, int b){\n    int ans = 0;\n    \n    while(t > 0 && b > 0){\n        if(t >= b){\n            ans += t/b;\n            t %= b;\n        } else {\n            ans += (b-1)/t;\n            b -= (b-1)/t*t;\n        }\n    }\n    \n    if(t == 0 && b == 1) return ans;\n    return -1;\n}\n\nint func2(int t, int b){\n    int i=0;\n    \n    while(t > 0 && b > 0){\n        if(t >= b){\n            buf[i] = \'T\';\n            t -= b;\n            i++;\n        } else {\n            buf[i] = \'B\';\n            b -= t;\n            i++;\n        }\n    }\n    \n    int len = i;\n    reverse(buf, buf+len);\n    \n    int mistake = 0;\n    REP(i,len-1) if(buf[i] == buf[i+1]) mistake++;\n    if(buf[0] != \'T\') mistake = INF;\n    return mistake;\n}\n\nint main(void){\n    int n,r,i;\n    \n    cin >> n >> r;\n    \n    int x = -1, y = -1, best = INF;\n    \n    REP(i,r+1) if(func(r,i) == n){\n        int tmp = func2(r,i);\n        if(tmp < best){\n            best = tmp;\n            x = r; y = i;\n        }\n    }\n    \n    REP(i,r) if(func(i,r) == n){\n        int tmp = func2(i,r);\n        if(tmp < best){\n            best = tmp;\n            x = i; y = r;\n        }\n    }\n    \n    if(best == INF){\n        cout << ""IMPOSSIBLE"" << endl;\n    } else {\n        func2(x,y);\n        buf[n] = \'\\0\';\n        cout << best << endl;\n        printf(""%s\\n"", buf);\n    }\n    \n    return 0;\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0]",2100,If you look at the described process backwards it resembles the Euclidean algorithm a lot Indeed if you rewinded a recording of Bajtek s actions he always takes the larger out of two numbers say Unable to parse markup type CF TEX and replaces them by a b b Since we know one of the final numbers r we can simply check all numbers between 1 and r and run a faster version of Euclid s algorithm one that replaces a b by for all possibilities for a total runtime of This was one of the expected solutions However with some insight it can be seen that this optimization is in fact not neccessary we can simply simulate the reverse process as described replacing a b by a b b for all candidates between 1 and r and the total runtime of our algorithm will remain The proof of this fact is left to the reader 
You are living on an infinite plane with the Cartesian coordinate system on it In one move you can go to any of the four adjacent points left right up down More formally if you are standing at the point x y you can go left and move to x 1 y or go right and move to x 1 y or go up and move to x y 1 or go down and move to x y 1 There are n boxes on this plane The i th box has coordinates x i y i It is guaranteed that the boxes are either on the x axis or the y axis That is either x i 0 or y i 0 You can collect a box if you and the box are at the same point Find the minimum number of moves you have to perform to collect all of these boxes if you have to at the point 0 0 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\n\nbool solve(int caseN) {\n    int n;\n    cin >> n;\n\n    int minX = 0, maxX = 0, minY = 0, maxY = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n    }\n    cout << 2*(maxX-minX+maxY-minY) << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""complexity.in"", ""r"", stdin);\n    // freopen(""complexity.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(i); /*\n    for (int i = 1; solve(i); i++); /**/\n    cout.flush();\n    return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,Suppose we only have boxes on the axis then the optimal strategy is going in the following way There is no way to do in less than moves What if we have boxes on two axis Let s assume it is suppose we have a strategy to go in the following way In this case it is optimal to fill the three dots with which is just solving each axis independently Therefore the number of axis does not matters For each axis that has at least one box go from to the farthest one then come back to Time complexity Solution 
In order to fly to the Moon Mister B just needs to solve the following problem There is a complete indirected graph with vertices You need to cover it with several simple cycles of length and so that each edge is in exactly cycles We are sure that Mister B will solve the problem soon and will fly to the Moon Will you ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n;\nstruct atom{\n\tvector<int>A;\n\tvoid print(){\n\t\tprintf(""%d "",A.size());\n\t\tfor (int i=0;i<A.size();i++) printf(""%d "",A[i]); printf(""\\n"");\n\t}\n};\nvector<atom>A;\nvoid put(int k1,int k2,int k3){\n\tatom k; k.A.push_back(k1); k.A.push_back(k2); k.A.push_back(k3); A.push_back(k);\n}\nvoid put(int k1,int k2,int k3,int k4){\n\tatom k; k.A.push_back(k1); k.A.push_back(k2); k.A.push_back(k3); k.A.push_back(k4); A.push_back(k);\n}\nint main(){\n\tscanf(""%d"",&n);\n\tif (n%2==0){\n\t\tput(1,2,3);\n\t\tput(1,2,4);\n\t\tput(2,3,4);\n\t\tput(1,3,4);\n\t\tfor (int i=5;i<=n;i+=2){\n\t\t\tput(i,i+1,1);\n\t\t\tput(i,i+1,2);\n\t\t\tput(1,i,2,i+1);\n\t\t\tfor (int j=3;j<i;j+=2)\n\t\t\t\tput(j,i,j+1,i+1),put(j,i,j+1,i+1);\n\t\t}\n\t} else {\n\t\tput(1,2,3); put(1,2,3);\n\t\tfor (int i=4;i<=n;i+=2){\n\t\t\tput(1,i,3,i+1); put(2,i,3,i+1);\n\t\t\tput(i,i+1,1); put(i,i+1,2);\n\t\t\tfor (int j=4;j<i;j+=2)\n\t\t\t\tput(j,i,j+1,i+1),put(j,i,j+1,i+1);\n\t\t}\n\t}\n\tprintf(""%d\\n"",A.size());\n\tfor (int i=0;i<A.size();i++) A[i].print();\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",2800,There are different constructive solutions in this problem Here is one of them Consider odd and even separately Let be even Let s build for each even a solution such that there are triangles and so on For it s easy to construct such a solution Then let s add two vertices at a time and Instead of triangle let s add triangle square and square The same with and so on Only one edge is remaining we should add it twice To do this let s replace the square with triangles and Easy to see that the condition on triangles is satisfied so we can proceed to adding two more vertices and so on To deal with odd let s keep triangles and so on To add two more vertices replace each of these triangles with two squares and one triangle in the same way as for even and also add two triangles 
After some programming contest Roma decided to try himself in tourism His home country Uzhlyandia is a Cartesian plane He wants to walk along each of the Main Straight Lines in Uzhlyandia It is known that each of these lines is a straight line parallel to one of the axes i e it is described with the equation or where is integer called the coordinate of this line Roma lost his own map so he should find out the coordinates of all lines at first Uncle Anton agreed to help him using the following rules Initially Roma doesn t know the number of vertical and horizontal lines and their coordinates Roma can announce integer coordinates of some point in Uzhlandia and Anton then will tell him the minimum among the distances from the chosen point to each of the lines However since the coordinates of the lines don t exceed by absolute value Roma can t choose a point with coordinates exceeding by absolute value Uncle Anton is in a hurry to the UOI Uzhlandian Olympiad in Informatics so he can only answer no more than questions The problem is that Roma doesn t know how to find out the coordinates of the lines Write a program that plays Roma s role and finds the coordinates ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxc = (int) 1e8;\n\nint rot;\nint check(int x, int y) {\n  if (rot) {\n    swap(x, y);\n  }\n  assert(abs(x) <= maxc && abs(y) <= maxc);\n  printf(""0 %d %d\\n"", x, y);\n  fflush(stdout);\n  int res;\n  assert(scanf(""%d"", &res) == 1);\n  assert(res >= 0);\n  return res;\n}\n\nset<int> xs, ys;\n\nset<pair<int, int> > deltay;\n\nconst int K = 9995;\n\nvoid update0(int x, int y) {\n  assert(!xs.count(x));\n  assert(!ys.count(y));\n\n  for (int iter = 0; iter < 3; ++iter) {\n    int cy = rnd(2 * maxc + 1) - maxc;\n    if (check(x, cy)) {\n      auto iter = ys.lower_bound(y);\n      int mx = ((iter == ys.end()) ? maxc : *iter);\n      int mn = -maxc;\n      if (iter != ys.begin()) {\n        --iter;\n        mn = *iter;\n      }\n      deltay.erase(mp(mx - mn, mn));\n      deltay.insert(mp(y - mn, mn));\n      deltay.insert(mp(mx - y, y));\n      ys.insert(y);\n      return;\n    }\n  }\n  xs.insert(x);\n}\n\nvoid update(int x, int y, int got) {\n  assert(got >= 0);\n  if (x - got >= -maxc) {\n    if (check(x - got, y) == 0) {\n      update0(x - got, y);\n      return;\n    }\n  }\n  if (x + got <= maxc) {\n    if (check(x + got, y) == 0) {\n      update0(x + got, y);\n      return;\n    }\n  }\n  if (y - got >= -maxc) {\n    if (check(x, y - got) == 0) {\n      update0(x, y - got);\n      return;\n    }\n  }\n  update0(x, y + got);\n}\n\nvoid solve() {\n  xs.clear(), ys.clear();\n  rot = 0;\n\n  for (int iter = 0; iter < 2; ++iter) {\n    deltay.clear();\n    int lasty = -maxc;\n    for (int y : ys) {\n      deltay.insert(mp(y - lasty, lasty));\n      lasty = y;\n    }\n    deltay.insert(mp(maxc - lasty, lasty));\n\n    int x = -maxc - 1;\n    while (x < maxc) {\n      auto iter = xs.lower_bound(x + 1);\n      if (iter != xs.end() && *iter == x + 1) {\n        ++x;\n        continue;\n      }\n      int delta = K;\n      delta = min(delta, maxc - x);\n      if (iter != xs.end()) {\n        delta = min(delta, (*iter - x) / 2);\n      }\n      assert(delta > 0);\n\n      auto diter = deltay.end();\n      --diter;\n      assert(diter->first >= delta * 2);\n      int y1 = diter->second;\n      int y2 = y1 + diter->first;\n\n      int y = (y1 + y2) / 2;\n\n      int got = check(x + delta, y);\n      if (got >= delta) {\n        x += delta + got - 1;\n        continue;\n      }\n\n      update(x + delta, y, got);\n    }\n\n    swap(xs, ys);\n    rot ^= 1;\n  }\n\n  printf(""1 %d %d\\n"", sz(xs), sz(ys));\n  {\n    bool was = 0;\n    for (int x : xs) {\n      if (was) {\n        printf("" "");\n      }\n      printf(""%d"", x);\n      was = 1;\n    }\n    printf(""\\n"");\n  }\n  {\n    bool was = 0;\n    for (int x : ys) {\n      if (was) {\n        printf("" "");\n      }\n      printf(""%d"", x);\n      was = 1;\n    }\n    printf(""\\n"");\n  }\n}\n\nint main() {\n  precalc();\n\n  solve();\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3000,First we solve another problem Let we have points not straight lines but points on one axis Let that is the maximum coordinate First we find the left and right points The left is and the right one Then we solve the problem recursively There will be a function that finds all points on the segment if and are points We have already found the extreme points so we can call this function The function makes a query at the center point between and that is If the answer is equal to the distance to the extreme points then there are no more points between and If the distance is less then for one more query we can find out the point on the left or right Let this point then we start and We introduce a function that checks if there is a vertical line We can select a random point in the range and make a query if the answer is a straight line If and the maximum then the error probability is if you querys twice then Now we will solve the main task We make a query at the point we can find out whether the minimum distance to the vertical or horizontal line We introduce the function which will find the nearest straight line whose coordinates are greater than or and How is this solved If there are no more lines then for non negative Then we can find a minimal power such that Then we know that this applies to either the vertical line or the horizontal We can find out which one If for example to the vertical one then we solve the problem for Then we find either all horizontal lines or all vertical lines To find out which straight lines we found we need to look at the last function namely our ray If it rests on the vertical straight then we find all the vertical ones And vice versa Now how to find other lines Let s say we found all the vertical ones Then we will find the maximum distance between the neighbors between the first line and between the last line and this distance will be at least That is we search in what position the maximum will be reached if there are no horizontal lines let it be Let this be the coordinate we will make queries on the line starting with ending with with the step We find all the points whose answer is not equal to Then we can divide all these points into segments that is a set of points that go successively For each segment the minimum distance will only apply to horizontal lines that is vertical ones will not affect in any way Therefore each segment can be solved independently by the method already known to us assume that there are no vertical lines 
The cities of Byteland and Berland are located on the axis Ox In addition on this axis there are also disputed cities which belong to each of the countries in their opinion Thus on the line Ox there are three types of cities the cities of Byteland the cities of Berland disputed cities Recently the project BNET has been launched a computer network of a new generation Now the task of the both countries is to connect the cities so that the network of this country is The countries agreed to connect of cities with BNET cables in such a way that If you look at the cities of Byteland and the disputed cities then in the resulting set of cities any city should be reachable from any other one by one or more cables If you look at the cities of Berland and the disputed cities then in the resulting set of cities any city should be reachable from any other one by one or more cables Thus it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously Cables allow bi directional data transfer Each cable connects exactly two distinct cities The cost of laying a cable from one city to another is equal to the distance between them Find the minimum total cost of laying a set of cables so that two subsets of cities Byteland and disputed cities Berland and disputed cities are connected Each city is a point on the line Ox It is technically possible to connect the cities a and b with a cable so that the city c a c b is not connected to this cable where a b and c are simultaneously coordinates of the cities a b and c ,"[""#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\n\nint n;\nll ans = 0;\nvector<ll> b, r, g;\n\nvoid process(bool f = 0) {\n    if (f == 0) {\n        if (sz(g) == 1) {\n            if (sz(r)) ans += g[0]-r[0];\n            if (sz(b)) ans += g[0]-b[0];\n        } else {\n            ll a1 = 2*(g.back()-g[sz(g)-2]);\n            ll a2 = g.back()-g[sz(g)-2];\n            \n            if (sz(r)) {\n                ll mx = max(g.back()-r.back(),r.front()-g[sz(g)-2]);\n                F0R(i,sz(r)-1) mx = max(mx,r[i+1]-r[i]);\n                a2 += g.back()-g[sz(g)-2]-mx;\n            }\n            if (sz(b)) {\n                ll mx = max(g.back()-b.back(),b.front()-g[sz(g)-2]);\n                F0R(i,sz(b)-1) mx = max(mx,b[i+1]-b[i]);\n                a2 += g.back()-g[sz(g)-2]-mx;\n            }\n            ans += min(a1,a2);\n        }\n    } else {\n        if (sz(g) == 0) {\n            if (sz(r)) ans += r.back()-r.front();\n            if (sz(b)) ans += b.back()-b.front();\n        } else {\n            if (sz(r)) ans += r.back()-g.back();\n            if (sz(b)) ans += b.back()-g.back();\n        }\n    }\n    b.clear(), r.clear();\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin >> n;\n\tF0R(i,n) {\n\t    int p; char c; cin >> p >> c;\n\t    if (c == 'P') {\n\t        g.pb(p);\n\t        process();\n\t    } else if (c == 'R') r.pb(p);\n\t    else b.pb(p);\n\t}\n\tprocess(1);\n\tcout << ans;\n}\n\n// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!\n// ll vs. int!""]","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200,We will call the disputed cities purple points the cities of Byteland blue points and the cities of Berland red points If there are no any purple points among the given points you just need to connect all the neighboring red points between each other and all the neighboring blue points with each other Thus the answer is the sum of the distances between the leftmost red point and the rightmost red point and between the leftmost blue point and the rightmost red point Otherwise you firstly should connect all the neighboring purple points with each other Consider what you should do to connect the red points All the red points to the left of the leftmost purple point should be connected as follows first from the left with the second from the left second from the left with the third from the left and so on The rightmost of these red points should be connected to the leftmost purple point All the red points to the right of the rightmost purple point are connected in a similar way Consider all the gaps between the neighboring purple points and all the red and blue points between them They should be connected in one of two ways The first way is to connect the left purple with the leftmost red the rightmost red with the right purple and also connect all the neighboring red dots Similarly we should make for the blue points Let the total length of the edges for such a connection is equal to The second way is to connect the left and right purple point Now consider only the purple points and the red ones All adjacent points need to be connected to each other except those which are on the maximum distance from all other pairs If there are several then we do not connect any pair Similarly we make for the purple and blue points Let the total length of the edges for such a connection is equal to If we should connect points from the current gap in the second way otherwise in the first 
LuoTianyi now lives in a world with n floating islands The floating islands are connected by n 1 undirected air routes and any two of them can reach each other by passing the routes That means the n floating islands form a tree One day LuoTianyi wants to meet her friends Chtholly Nephren William Totally she wants to meet k people She doesn t know the exact positions of them but she knows that they are in islands She define an island is if and only if the sum of the distances dagger from it to the islands with k people is the minimal among all the n islands Now LuoTianyi wants to know that if the k people are randomly set in k distinct of the n islands then what is the expect number of the good islands You just need to tell her the expect number modulo 10 9 7 dagger The distance between two islands is the minimum number of air routes you need to take to get from one island to the other ,"['#include <bits/stdc++.h>\xa0using i64 = long long;template<class T>constexpr T power(T a, i64 b) {    T res = 1;    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;}\xa0constexpr i64 mul(i64 a, i64 b, i64 p) {    i64 res = a * b - i64(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;}template<i64 P>struct MLong {    i64 x;    constexpr MLong() : x{} {}    constexpr MLong(i64 x) : x{norm(x % getMod())} {}        static i64 Mod;    constexpr static i64 getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(i64 Mod_) {        Mod = Mod_;    }    constexpr i64 norm(i64 x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr i64 val() const {        return x;    }    explicit constexpr operator i64() const {        return x;    }    constexpr MLong operator-() const {        MLong res;        res.x = norm(getMod() - x);        return res;    }    constexpr MLong inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MLong &operator*=(MLong rhs) & {        x = mul(x, rhs.x, getMod());        return *this;    }    constexpr MLong &operator+=(MLong rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MLong &operator-=(MLong rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MLong &operator/=(MLong rhs) & {        return *this *= rhs.inv();    }    friend constexpr MLong operator*(MLong lhs, MLong rhs) {        MLong res = lhs;        res *= rhs;        return res;    }    friend constexpr MLong operator+(MLong lhs, MLong rhs) {        MLong res = lhs;        res += rhs;        return res;    }    friend constexpr MLong operator-(MLong lhs, MLong rhs) {        MLong res = lhs;        res -= rhs;        return res;    }    friend constexpr MLong operator/(MLong lhs, MLong rhs) {        MLong res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {        i64 v;        is >> v;        a = MLong(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {        return os << a.val();    }    friend constexpr bool operator==(MLong lhs, MLong rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MLong lhs, MLong rhs) {        return lhs.val() != rhs.val();    }};\xa0template<>i64 MLong<0LL>::Mod = 1;\xa0template<int P>struct MInt {    int x;    constexpr MInt() : x{} {}    constexpr MInt(i64 x) : x{norm(x % getMod())} {}        static int Mod;    constexpr static int getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(int Mod_) {        Mod = Mod_;    }    constexpr int norm(int x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr int val() const {        return x;    }    explicit constexpr operator int() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        x = 1LL * x * rhs.x % getMod();        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        i64 v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }};\xa0template<>int MInt<0>::Mod = 1;\xa0template<int V, int P>constexpr MInt<P> CInv = MInt<P>(V).inv();\xa0constexpr int P = 1000000007;using Z = MInt<P>;\xa0struct Comb {    int n;    std::vector<Z> _fac;    std::vector<Z> _invfac;    std::vector<Z> _inv;        Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}    Comb(int n) : Comb() {        init(n);    }        void init(int m) {        if (m <= n) return;        _fac.resize(m + 1);        _invfac.resize(m + 1);        _inv.resize(m + 1);                for (int i = n + 1; i <= m; i++) {            _fac[i] = _fac[i - 1] * i;        }        _invfac[m] = _fac[m].inv();        for (int i = m; i > n; i--) {            _invfac[i - 1] = _invfac[i] * i;            _inv[i] = _invfac[i] * _fac[i - 1];        }        n = m;    }        Z fac(int m) {        if (m > n) init(2 * m);        return _fac[m];    }    Z invfac(int m) {        if (m > n) init(2 * m);        return _invfac[m];    }    Z inv(int m) {        if (m > n) init(2 * m);        return _inv[m];    }    Z binom(int n, int m) {        if (n < m || m < 0) return 0;        return fac(n) * invfac(m) * invfac(n - m);    }} comb;\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, k;    std::cin >> n >> k;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--, v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        Z ans = 1;        if (k % 2 == 0) {        Z inv = 1 / comb.binom(n, k);        std::vector<int> siz(n);        std::function<void(int, int)> dfs = [&](int x, int p) {            siz[x] = 1;            for (auto y : adj[x]) {                if (y == p) {                    continue;                }                dfs(y, x);                siz[x] += siz[y];                ans += comb.binom(siz[y], k / 2) * comb.binom(n - siz[y], k / 2) * inv;            }        };        dfs(0, -1);    }    std::cout << ans << ""\\n"";        return 0;}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1800,Call a node special if there is a person in it When k is odd we find that there is only one node satisfying the conditions Proof Assume distinct node x and node y are good nodes Let x be the root of the tree Define si as the number of special nodes in subtree i Think about the process we move from x to y If we try to move the chosen node from its father to i the variation of cost is k 2si When move from x to its son i which si is maximal k 2si 0 is held Otherwise x isn t a good node And we can get k 2si 0 further because k is odd and 2si is even Since min1 j nk 2sj k 2si we find k 2sj 0 for all j So y can t be good node Then think about the situation that k is even Choose a node as root arbitrarily With the same method we find that good nodes satisfy 2si k It s also sufficient Define pi as the possibility that si k2 then the answer is 1 ni 1pi Define Si as the size of subtree i When si k2 there are k2 special nodes in subtree i and k2 in the other part The number of ways to place special nodes is nk and Sik2 n Sik2 of them satisfying the condition So pi Sik2 n Sik2 nk 
After his birthday party Timofey went to his favorite tree alley in a park He wants to feed there his favorite birds crows It s widely known that each tree is occupied by a single crow family The trees in the alley form a row and are numbered from to Some families are friends to each other For some reasons two families can be friends only if they live not too far from each other more precisely there is no more than trees between any pair of friend families Formally the family on the th tree and the family on the th tree can be friends only if holds One of the friendship features is that if some family learns that Timofey is feeding crows somewhere it notifies about this all friend families Thus after Timofey starts to feed crows under some tree all the families that are friends to the family living on this tree as well as their friends and so on fly to the feeding place Of course the family living on the tree also comes to the feeding place Today Timofey came to the alley and noticed that all the families that live on trees with numbers strictly less than or strictly greater than have flown away Thus it is not possible to pass the information about feeding through them Moreover there is no need to feed them Help Timofey to learn what is the minimum number of trees under which he has to feed crows so that all the families that have remained will get the information about feeding You are given several situations described by integers and you need to calculate the answer for all of them ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <stack>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=301000,M=1010000;\nstruct node {\n\tnode *s[2],*f,*minv;\n\tint val,d;\n\tPII id;\n\tbool rev;\n\tbool isr() { return !f||(f->s[0]!=this && f->s[1]!=this);}\n\tbool dir() { return f->s[1]==this;}\n\tvoid setc(node *c,int d) { s[d]=c;if (c) c->f=this;}\n\tvoid push() {\n\t\tif (rev) { swap(s[0],s[1]); rep(i,0,2) if (s[i]) s[i]->rev^=1;} rev=0;\n\t}\n\tvoid upd() {\n\t\tminv=this;val=d;\n\t\trep(i,0,2) if (s[i]&&s[i]->val>val) val=s[i]->val,minv=s[i]->minv;\n\t}\n}pool[M],*cur;\nstack<node*> sta;\nvoid rot(node *x) {\n\tnode *p=x->f;bool d=x->dir();\n\tif (!p->isr()) p->f->setc(x,p->dir()); else x->f=p->f;\n\tp->setc(x->s[!d],d);x->setc(p,!d);\n\tp->upd();\n}\nvoid splay(node *x) {\n\tnode *q=x;\n\twhile (1) { sta.push(q);if (q->isr()) break; q=q->f; }\n\twhile (!sta.empty()) sta.top()->push(),sta.pop();\n\twhile (!x->isr()) {\n\t\tif (x->f->isr()) rot(x);\n\t\telse if (x->dir()==x->f->dir()) rot(x->f),rot(x);\n\t\telse rot(x),rot(x);\n\t}\n\tx->upd();\n}\nnode *expose(node *x) {\n\tnode *q=NULL;\n\tfor (;x;x=x->f) splay(x),x->s[1]=q,(q=x)->upd();\n\treturn q;\n}\nvoid evert(node *x) { expose(x); splay(x); x->rev^=1; x->push();}\nvoid expose(node *x,node *y) { evert(x); expose(y); splay(x);}\nvoid link(node *x,node *y) { evert(x); evert(y); x->setc(y,1);}\nvoid cut(node *x,node *y) { expose(x,y); x->s[1]=y->f=NULL;}\n\nint n,m,l,r,Q,ret[N];\nVI e[N];\nvector<PII> q[N];\nint c[N];\nvoid modify(int x,int s) {\n\tfor (;x<=n+1;x+=x&-x) c[x]+=s;\n}\nint query(int x) {\n\tint s=0;\n\tfor (;x;x-=x&-x) s+=c[x];\n\treturn s;\n}\nint main() {\n\tscanf(""%d%*d"",&n);\n\tscanf(""%d"",&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&l,&r);\n\t\tif (l>r) swap(l,r);\n\t\te[l].pb(r);\n\t}\n\tn++;\n\tscanf(""%d"",&Q);\n\trep(i,0,Q) {\n\t\tscanf(""%d%d"",&l,&r);\n\t\tret[i]=r-l+1;\n\t\tq[l].pb(mp(r,i));\n\t}\n\trep(i,1,n+2) pool[i].d=-1;\n\tcur=pool+n+2;\n\trep(i,1,n+1) {\n\t\tnode *u=pool+i,*v=pool+n+1;\n\t\tnode *x=cur++;\n\t\tx->d=n+1;\n\t\tx->id=mp(i,n+1);\n\t\tlink(x,u); link(x,v);\n\t\tmodify(n+1,1);\n\t}\n\tper(x,1,n+1) {\n\t\tfor (auto y:e[x]) {\n\t\t\tnode *u=pool+x,*v=pool+y;\n\t\t\texpose(u,v);\n\t\t\tif (y<u->val) {\n\t\t\t\tnode *w=u->minv;\n\t\t\t\tcut(pool+w->id.fi,w);\n\t\t\t\tcut(pool+w->id.se,w);\n\t\t\t\tmodify(w->d,-1);\n\t\t\t\tw=cur++;\n\t\t\t\tw->d=y;\n\t\t\t\tmodify(w->d,1);\n\t\t\t\tw->id=mp(x,y);\n\t\t\t\tlink(w,pool+x);\n\t\t\t\tlink(w,pool+y);\n\t\t\t}\n\t\t}\n\t\tfor (auto y:q[x]) {\n\t\t\tret[y.se]-=query(y.fi);\n\t\t}\n\t}\n\trep(i,0,Q) printf(""%d\\n"",ret[i]);\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2900,Let s build a segment tree on crow families Let s save DSU in each vertex having information about number of components of connectivity on it In one vertex will be DSU with size In two vertices will be DSU with size In four vertices will be DSU with size It s easy to show that we will store only values Let s understand how we can unite segments Knowing answer number of components for a b and b c we can obtain answer for a c in the following way We can sum answers for for a b and b c and substract number of components which united during the gluing If components become united there is edge between vertex in one and vertex in another We have constraint on edge legth vertex and vertex can be connected only if Then we can easily unite two segments of the segment tree in time we just unite some of the components of families represented in the end of each segment when they are connected by edge Segment tree can split query in already calculated segments So we can answer the query in time Precalc will take nearly Author s solution http pastebin com 1CwUVyME Solve the problem in time for the precalculation and time for the query 
We ll define for positive integer as follows the number of the s digits in the decimal base For example You want to make a consecutive integer sequence starting from number But you need to pay to add the number to the sequence You can spend a cost up to and you want to make the sequence as long as possible Write a program that tells sequence s maximum length ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 100000000000000000LL;\n\nLL w, M, k;\nLL ans;\n\nLL calcS(LL x)\n{\n\tif (x < 10) return x;\n\tLL ret = 0;\n\tLL i = 1, bit = 1;\n\tfor (; i * 10 <= x; i *= 10, ++bit) ret += bit * i * 9;\n\tLL digit = x / i % 10;\n\tret += (digit - 1) * i * bit;\n\tret += (x % i + 1)* bit;\n\treturn ret;\n}\n\nint main()\n{\n\tcin >> w >> M >> k;\n\tfor (LL l = 0, r = INF - M; l <= r;) {\n\t\tLL m = (l + r) / 2;\n\t\tif ((calcS(M + m - 1) - calcS(M - 1)) <= w / k) ans = m, l = m + 1;\n\t\telse r = m - 1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']","[0, 1, 1, 0, 0, 0, 0, 1, 0, 0]",1600,Naive simulation subtracting S i k from w while w 0 won t finish in 2 seconds At first these two facts will make it easier to solve the problem 1 k doesn t matter for solving this problem so you can simply divide w with k at the first point 2 S 10 x S 10 x 1 S 10 x 1 1 9 x 10 x There are many ways to solve this problem and I ll show you 2 ways Binary Search Let s define f n as sum k 1 n S n This problem can be solved by finding largest x that satisfies f x f m 1 w If x satisfies the given inequation also x 1 x 2 satisfies inequation since S x is always positive So it can be solved by using binary search By using fact2 you can quickly simulate the value of f n The answer can be rather large so be careful not to cause overflow by too large upper bound Overall complexity is O log upper bound lower bound Cumulative Sums Let s think to speed up naive solutions that I ve written at first If you use fact 2 the number of simulation will reduce from O answer to O 1 Also simulation will be much easier if you add S 1 S m 1 to w Please see my source code for further detail DEGwer s solution Solution 1 http ideone com cU78oe My solution Solution 2 http ideone com NjxlwP 
Johnny has a new toy As you may guess it is a little bit extraordinary The toy is a permutation P of numbers from 1 to n written in one row next to each other For each i from 1 to n 1 between P i and P i 1 there is a weight W i written and those weights form a permutation of numbers from 1 to n 1 There are also extra weights W 0 W n 0 The instruction defines subsegment L R as good if W L 1 W i and W R W i for any i in L L 1 ldots R 1 For such subsegment it also defines W M as minimum of set W L W L 1 ldots W R 1 Now the fun begins In one move the player can choose one of the good subsegments cut it into L M and M 1 R and swap the two parts More precisely before one move the chosen subsegment of our toy looks like W L 1 P L W L ldots W M 1 P M W M P M 1 W M 1 ldots W R 1 P R W R and afterwards it looks like this W L 1 P M 1 W M 1 ldots W R 1 P R W M P L W L ldots W M 1 P M W R Such a move can be performed multiple times possibly zero and the goal is to achieve the minimum number of inversions in P Johnny s younger sister Megan thinks that the rules are too complicated so she wants to test her brother by choosing some pair of indices X and Y and swapping P X and P Y X might be equal Y After each sister s swap Johnny wonders what is the minimal number of inversions that he can achieve starting with current P and making legal moves You can assume that the input is generated P and W were chosen independently and equiprobably over all permutations also Megan s requests were chosen independently and equiprobably over all pairs of indices ,"['/**\n *    author:  tourist\n *    created: 04.06.2020 18:55:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n\nusing namespace __gnu_pbds;\n\ntypedef int tp;\ntypedef tree<tp,null_type,less<tp>,rb_tree_tag,tree_order_statistics_node_update> pbds;\n// tp a;\n// T.insert(a), T.erase(a), T.size()\n// T.order_of_key(a) -- number of elements strictly less than a\n// *T.find_by_order(k) -- k-th element in increasing order\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstruct Node {\n  int parent;\n  int from;\n  int to;\n  int k;\n  long long inv;\n  long long pairs;\n  pbds L;\n  pbds R;\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> w(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> w[i];\n    --w[i];\n  }\n  vector<int> ids(n - 1);\n  iota(ids.begin(), ids.end(), 0);\n  SparseTable<int> st(ids, [&](int i, int j) { return (w[i] < w[j] ? i : j); });\n  vector<Node> nodes(n - 1);\n  {\n    Node& node = nodes[0];\n    node.parent = -1;\n    node.from = 0;\n    node.to = n - 1;\n    node.k = -1;\n    node.inv = 0;\n    node.pairs = 0;\n  }\n  vector<int> leaf(n);\n  long long ans = 0;\n  long long total = 0;\n  int ptr = 1;\n  for (int b = 0; b < n - 1; b++) {\n    Node& node = nodes[b];\n//    debug(b, node.from, node.to);\n    assert(node.from < node.to);\n    node.k = st.get(node.from, node.to - 1);\n    for (int i = node.k + 1; i <= node.to; i++) {\n      node.R.insert(p[i]);\n    }\n    for (int i = node.from; i <= node.k; i++) {\n      node.inv += node.R.order_of_key(p[i]);\n      node.L.insert(p[i]);\n    }\n    total += (int) node.L.size();\n    total += (int) node.R.size();\n    node.pairs = (long long) (node.to - node.k) * (node.k - node.from + 1);\n//    debug(node.from, node.to, node.k, node.inv, node.pairs);\n    ans += min(node.inv, node.pairs - node.inv);\n    if (node.from == node.k) {\n      leaf[node.from] = b;\n    } else {\n      Node& new_node = nodes[ptr];\n      ptr += 1;\n      new_node.parent = b;\n      new_node.from = node.from;\n      new_node.to = node.k;\n      new_node.k = -1;\n      new_node.inv = 0;\n      new_node.pairs = 0;\n    }\n    if (node.k + 1 == node.to) {\n      leaf[node.to] = b;\n    } else {\n      Node& new_node = nodes[ptr];\n      ptr += 1;\n      new_node.parent = b;\n      new_node.from = node.k + 1;\n      new_node.to = node.to;\n      new_node.k = -1;\n      new_node.inv = 0;\n      new_node.pairs = 0;\n    }\n  }\n//  debug(""done"");\n  debug(ans, clock(), nodes.size(), total);\n//  debug(leaf);\n  auto Modify = [&](int i, int val) {\n    int b = leaf[i];\n    while (b >= 0) {\n      Node& node = nodes[b];\n      ans -= min(node.inv, node.pairs - node.inv);\n      if (i <= node.k) {\n        node.inv -= node.R.order_of_key(p[i]);\n        node.inv += node.R.order_of_key(val);\n        node.L.erase(p[i]);\n        node.L.insert(val);\n      } else {\n        node.inv += node.L.order_of_key(p[i]);\n        node.inv -= node.L.order_of_key(val);\n        node.R.erase(p[i]);\n        node.R.insert(val);\n      }\n      ans += min(node.inv, node.pairs - node.inv);\n      b = node.parent;\n    }\n    p[i] = val;\n  };\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    int px = p[x];\n    int py = p[y];\n    Modify(x, -1);\n    Modify(y, px);\n    Modify(x, py);\n    cout << ans << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']","[0, 1, 1, 0, 1, 0, 0, 0, 0, 0]",3300,Let us start with an analysis of good subsegments for the fixed permutation The whole permutation is a good subsegment itself as for any If we denote the minimal weight in as then we can notice that subsegments and contain all good subsegments except the whole permutation As a result we can recursively find all good subsegments by recursive calls in and We can view the structure of good subsegments as a binary tree Example structure of tree for and Now we want to analyze the possible moves for players It turns out that the player s move is equivalent to choosing a vertex of a tree and swapping its left and right subtree Notice that moves made in different vertices influence disjoint pairs of elements so in some sense these moves are independent if we are interested only in the number of inversions This observation allows us to find a simple method for calculating the result For each vertex calculate the number of inversions between the left and right subtree Using these numbers for each vertex we can find out whether we want to swap its subtrees or not so the result can be calculated by a simple loop over all vertices From randomness of the input we can deduce that the tree we built has height We can calculate the number of inversions easily if in each vertex we keep a structure with elements from permutation contained in that vertex Such structure must support querying the number of elements smaller than some The shortest implementation uses the ordered set but any BST can do it segment tree needs some squeezing to fit into ML The above solution works fast if there are no queries We can view each request as two removals and additions of elements If so we can notice that each query modifies the number of inversions in at most vertices So all we need to do is update the number of inversions in these vertices and recalculate the global result Building a tree and calculating initial number of inversions takes or answering each query cost so the final complexity is 
There is a square field of size n times n in which two cells are marked These cells can be in the same row or column You are to mark two more cells so that they are the corners of a rectangle with sides parallel to the coordinate axes For example if n 4 and a rectangular field looks like this there are asterisks in the marked cells begin matrix end matrix Then you can mark two more cells as follows begin matrix end matrix If there are several possible solutions then print any of them ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=100010;\nconst int mod=1000000007;\nusing namespace std;\n\nbool x[def],y[def];\nint n;\n\nvoid deal(bool *x)\n{\tint num=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(x[i])num++;\n\tif(num==1){\n\t\tif(!x[1])x[1]=true;\n\t\telse x[2]=true;\n\t}\n}\n\nint main()\n{\tint _=1,__=1;\n\tchar c;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)x[i]=y[i]=false;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tscanf("" %c"",&c);\n\t\t\t\tif(c==\'*\')\n\t\t\t\t\tx[i]=y[j]=true;\n\t\t\t}\n\t\tdeal(x);deal(y);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tprintf(""%c"",x[i]&&y[j]?\'*\':\'.\');\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,f two asterisks are in the same row then it is enough to select any other row and place two asterisks in the same columns in it If two asterisks are in the same column then you can do the same If none of the above conditions are met and the asterisks are at positions then you can place two more asterisks at positions 
Little Petya often travels to his grandmother in the countryside The grandmother has a large garden which can be represented as a rectangle in size when viewed from above This rectangle is divided into equal square sections The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section Creating artificial rain is an expensive operation That s why we limit ourselves to creating the artificial rain only above one section At that the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section That is for example the garden can be represented by a rectangle where the section heights are equal to 4 2 3 3 2 Then if we create an artificial rain over any of the sections with the height of 3 the water will flow over all the sections except the ones with the height of 4 See the illustration of this example at the picture As Petya is keen on programming he decided to find such a section that if we create artificial rain above it the number of watered sections will be maximal Help him ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""b""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nint N, a[1005];\n\nvoid Load ()\n{\n    cin >> N;\n\n    for (int i = 0;i < N;i++)\n        cin >> a[i];\n}\n\nvoid Solve ()\n{\n    int ans = 0;\n\n    for (int i = 0;i < N;i++)\n    {\n        int cur = 1;\n        for (int j = i - 1;j >= 0 && a[j] <= a[j + 1];j--) cur++;\n        for (int j = i + 1;j < N && a[j] <= a[j - 1];j++) cur++;\n        ans = max (ans, cur);\n    }\n    cout << ans;\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1100,Try to check all possibilities for creation artificial rain and calculate how many sections contain water The maximal answer from all these possibilities is the answer for the problem To calculate the answer for the given position we should check how many sections are to the left and to the right of the given section receive water The complexity of this algorithm is O N 2 
Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house More specifically there were 2n jars of strawberry and blueberry jam All the 2n jars are arranged in a row The stairs to the basement are exactly in the middle of that row So when Karlsson enters the basement he sees exactly n jars to his left and n jars to his right For example the basement might look like this Being the starightforward man he is he immediately starts eating the jam In one minute he chooses to empty either the first non empty jar to his left or the first non empty jar to his right Finally Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same For example this might be the result Jars are numbered from 1 to 2n from left to right so Karlsson initially stands between jars n and n 1 What is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left Your program should answer t independent test cases ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nint a[200005];\nint pos[200005];\nvoid solve(){\n\tscanf(""%d"",&n);\n\trepn(i,2*n) scanf(""%d"",&a[i]);\n\trep(i,2*n+3) pos[i] = INF;\n\tpos[n] = n;\n\tint cur = n;\n\tfor(int i=2*n;i>=n+1;i--){\n\t\tif(a[i] == 2) cur++; else cur--;\n\t\tpos[cur] = min(pos[cur],i-n-1);\n\t}\n\tint ans = n+pos[n];\n\tcur = n;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i] == 1) cur++; else cur--;\n\t\tans = min(ans,n-i+pos[cur]);\n\t}\n\tprintf(""%d\\n"",ans);\n}\nint main(){\n\tint t; cin >> t;\n\twhile(t--)solve();\n}']","[1, 0, 1, 1, 1, 0, 0, 0, 0, 0]",1700,Let s transit from counting strawberry and blueberry jam jars separately to their difference Let be equal to Then eating one strawberry jar decreases by and eating one blueberry jar increases by The goal is to make equal to Let there be some initial difference Let s eat first jars from the left and first jars from the right Difference of the jars on the left is on the right it s So the goal becomes to find such and that Rewrite that as Now for each unique value of save the smallest to reach that value in a map Finally iterate over the and find the minimum answer Overall complexity 
You re given an array a 1 ldots a n of n non negative integers Let s call it if and only if there exists an integer 1 le k le n such that a 1 a 2 ldots a k and a k a k 1 ldots a n In particular any strictly increasing or strictly decreasing array is For example The arrays 4 0 1 12 10 8 and 3 11 15 9 7 4 are sharpened The arrays 2 8 2 8 6 5 0 1 1 0 and 2 5 6 9 8 8 are sharpened You can do the following operation as many times as you want choose any element of the array and decrease it by one Formally you can choose any i 1 le i le n such that a i 0 and assign a i a i 1 Tell if it s possible to make the given array using some number possibly zero of these operations ,"['/*\nIZ*ONE\n\nLa vie en Rose\n2018.10.29\n\nVioleta\n2019.04.01\n\nFiesta\n2020.02.17\n*/\n\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nint n, w[301000];\n\nvoid Process() {\n\tint i;\n\tscanf(""%d"", &n);\n\tint Mn = 1e9;\n\tint Mx = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &w[i]);\n\t\tif (w[i] < i - 1)Mn = min(Mn, i);\n\t\tif (w[i] < n - i)Mx = max(Mx, i);\n\t}\n\tif (Mx + 1 <= Mn - 1) {\n\t\tputs(""Yes"");\n\t}\n\telse puts(""No"");\n}\n\nint main() {\n\tint Tcase;\n\tscanf(""%d"", &Tcase);\n\twhile (Tcase--) {\n\t\tProcess();\n\t}\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,How to know if we can make the prefix strictly increasing We just have to consider the following simple greedy solution take down values to minimal possible values It s possible if and only if holds in the whole prefix Similarly the suffix can be made strictly decreasing if and only if holds in the whole suffix Using these simple facts we can compute the longest prefix we can make strictly increasing and the longest suffix we can make strictly decreasing in Then we just have to check that their intersection is non empty 
Little Vasya s uncle is a postman The post offices are located on one circular road Besides each post office has its own gas station located next to it Petya s uncle works as follows in the morning he should leave the house and go to some post office In the office he receives a portion of letters and a car Then he must drive in the given car exactly one round along the circular road and return to the starting post office the uncle can drive along the circle in any direction counterclockwise or clockwise Besides since the car belongs to the city post it should also be fuelled with gasoline only at the Post Office stations The total number of stations equals to One can fuel the car at the th station with no more than liters of gasoline Besides one can fuel the car no more than once at each station Also the distance between the st and the nd station is kilometers the distance between the nd and the rd one is kilometers between the th and the th ones the distance is kilometers and between the th and the st one the distance is kilometers Petya s uncle s high tech car uses only one liter of gasoline per kilometer It is known that the stations are located so that the sum of all is equal to the sum of all The th gas station and th post office are very close so the distance between them is kilometers Thus it becomes clear that if we start from some post offices then it is not always possible to drive one round along a circular road The uncle faces the following problem to what stations can he go in the morning to be able to ride exactly one circle along the circular road and visit all the post offices that are on it Petya who used to attend programming classes has volunteered to help his uncle but his knowledge turned out to be not enough so he asks you to help him write the program that will solve the posed problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""e""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nint N, a[100005], b[100005], good[100005];\n\nlong long s[200005];\n\nset <pair <long long, int> > st;\n\nvoid Load ()\n{\n    scanf (""%d"", &N);\n\n    for (int i = 0;i < N;i++)\n        scanf (""%d"", &a[i]);\n    for (int i = 0;i < N;i++)\n        scanf (""%d"", &b[i]);\n}\n\nvoid go (bool rev)\n{\n    st.clear();\n    s[0] = a[0] - b[0];\n    for (int i = 1;i < 2 * N;i++)\n        s[i] = s[i - 1] + a[i%N] - b[i%N];\n\n    for (int i = 0;i < N;i++)\n        st.insert (make_pair (s[i], i));\n\n    for (int i = 0;i < N;i++)\n    {\n        int cur = (*st.begin()).second;\n        if (s[cur] - (i > 0 ? s[i - 1] : 0) >= 0)\n            good[rev ? N - (i % N) - 1 : (i % N)] = 1;\n\n        st.erase (make_pair (s[i], i));\n        st.insert (make_pair (s[i + N], i + N));\n    }\n}\n\nvoid Solve ()\n{\n    go (0);\n    reverse (a, a + N);\n    reverse (b, b + N);\n    int t = b[0];\n    for (int i = 0;i < N - 1;i++)\n        b[i] = b[i + 1];\n    b[N - 1] = t;\n    go (1);\n\n    int ans = 0;\n    for (int i = 0;i < N;i++)\n        if (good[i]) ans++;\n    cout << ans << endl;\n\n    for (int i = 0;i < N;i++)\n        if (good[i]) printf (""%d "", i + 1);\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2000,First of all we divide our problem into 2 parts consider stations from which we can start if we are moving in the clockwise direction and stations from which we can start if we are moving in the counterclockwise direction Obviously if we know the solution of one of these problems we know the solution of another problem So we may assume that stations are located in the counterclockwise order and we are moving in the counterclockwise direction Consider the following differences D1 a1 b1 D2 a1 a2 b1 b2 D3 a1 a2 a3 b1 b2 b3 Dn a1 a2 an b1 b2 bn Obviously if one of Di s is less than a zero then we cannot drive one round along the road Let D min Di we will use it later Obviously if D 0 then the first station cannot be the start station Now we can check with complexity O n whether the first station can be used as the starting point Next we want to show how we can check this for the second station with complexity O 1 To show this consider E1 D1 a1 b1 E2 D2 a1 b1 En Dn a1 b1 Next substitute Di in these equalities We get the following E1 a1 b1 a1 b1 0 a2 a3 an a1 b2 b3 bn b1 a1 an b1 bn X E2 a1 a2 b1 b2 a1 b1 a2 b2 E3 a1 a2 a3 b1 b2 b3 a1 b1 a2 a3 b2 b3 En a1 a2 an b1 b2 bn a1 b1 a2 an b2 bn But it s easy to see that number E1 has the same meaning for the second station as number D1 for the first one So we just have to check min Ei 0 But Ei Di a1 b1 so we have to check min Di a1 b1 0 Now we can see that if min Di Dk then min Di a1 b1 Dk a1 b1 So if we know Dk that we can check whether the second station can be the starting point with complexity O 1 Similarly we can check this for the third the fourth the nth stations 
Find the minimum area of a land on which you can place two identical rectangular a times b houses The sides of the houses should be parallel to the sides of the desired square land Formally You are given two identical rectangles with side lengths a and b 1 le a b le 100 positive integers you are given just the sizes but their positions Find the square of the minimum area that contains both given rectangles Rectangles can be rotated both or just one moved but the sides of the rectangles should be parallel to the sides of the desired square Two rectangles can touch each other side or corner but cannot intersect Rectangles can also touch the sides of the square but must be completely inside it You can rotate the rectangles Take a look at the examples for a better understanding ,"[""#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\n#define maxn 205\nint n, m ; \nsigned main() {\n\tint T = gi() ;\n\twhile( T -- ) {\n\t\tn = gi(), m = gi() ;\n\t\tcout << max(min(n * 2, m * 2), max(n, m)) * max(min(n * 2, m * 2), max(n, m)) << endl ; \n\t}\n\treturn 0 ;\n} ""]","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Obviously that both rectangles should completely touch by one of the sides Otherwise you can move them closer to each other so that the total height or total width decreases and the other dimension does not change Thus there are only two options The rectangles touch by width we get the side of the square equal to The rectangles touch by height we get the side of the square equal to Thus the minimum side of the square is equal to the minimum of these two options Then the answer is 
Alice and Bob play ping pong with simplified rules During the game the player serving the ball commences a play The server strikes the ball then the receiver makes a return by hitting the ball back Thereafter the server and receiver must alternately make a return until one of them doesn t make a return The one who doesn t make a return loses this play The winner of the play commences the next play Alice starts the first play Alice has x stamina and Bob has y To hit the ball while serving or returning each player spends 1 stamina so if they don t have any stamina they can t return the ball and lose the play or can t serve the ball in this case the other player serves the ball instead If both players run out of stamina the game is over Sometimes it s strategically optimal not to return the ball lose the current play but save the stamina On the contrary when the server commences a play they have to hit the ball if they have some stamina left Both Alice and Bob play optimally and want to firstly maximize their number of wins and secondly minimize the number of wins of their opponent Calculate the resulting number of Alice s and Bob s wins ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int X, Y;\n    cin >> X >> Y;\n    cout << X - 1 << \' \' << Y << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1100,Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is 
Recently Maxim has found an array of integers needed by no one He immediately come up with idea of changing it he invented positive integer and decided to add or subtract it from arbitrary array elements Formally by applying single operation Maxim chooses integer and replaces the th element of array either with or with Please note that the operation may be applied more than once to the same position Maxim is a curious minimalis thus he wants to know what is the minimum value that the product of all array elements i e can reach if Maxim would apply no more than operations to it Please help him in that ,"['#include<bits/stdc++.h>\n#define ll long long\n#define N 200005\nusing namespace std;\n\nint n,m,x;\nstruct node{\n\tll x; int y,z;\n}a[N];\nbool operator <(node u,node v){ return u.x>v.x; }\nbool cmp(node u,node v){ return u.y<v.y; }\npriority_queue<node> q;\nint read(){\n\tint x=0; char cr=getchar(); bool flag=0;\n\twhile (cr<\'0\' || cr>\'9\'){ if (cr==\'-\') flag=1; cr=getchar(); }\n\twhile (cr>=\'0\' && cr<=\'9\'){ x=x*10+cr-\'0\'; cr=getchar(); }\n\treturn (flag)?-x:x;\n}\nvoid opt(){\n\tint i;\n\tfor (i=1; i<=n; i++){\n\t\tif ((a[i].z<0) && (a[i].x!=0)) putchar(\'-\');\n\t\tprintf(""%lld "",a[i].x);\n\t}\n}\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&x);\n\tint i,j,k; bool flag=0,flag2=0;\n\tfor (i=1; i<=n; i++){\n\t\ta[i].x=read(); if (a[i].x<0) flag=!flag;\n\t\t\tif (!a[i].x) flag2=1; a[i].y=i; a[i].z=((a[i].x)<0)?-1:1;\n\t}\n\tif (flag2){\n\t\tfor (i=1; i<=n; i++) if (!a[i].x){\n\t\t\tif (!flag) a[i].z=-1; break;\n\t\t}\n\t\tflag=1;\n\t}\n\tfor (i=1; i<=n; i++) a[i].x=abs(a[i].x);\n\tif (!flag){\n\t\tfor (i=2,k=1; i<=n; i++)\n\t\t\tif (a[i].x<a[k].x) k=i;\n\t\tif (a[k].x>=(ll)m*x){\n\t\t\ta[k].x-=(ll)m*x;\n\t\t\topt();return 0;\n\t\t} else{\n\t\t\t//puts(""233"");\n\t\t\tj=(a[k].x/x+1); m-=j;\n\t\t\ta[k].x-=(ll)j*x;\n\t\t\ta[k].z=-a[k].z; a[k].x=-a[k].x;\n\t\t\t//cout<<k<<\' \'<<a[k].z<<endl;\n\t\t}\n\t}\n\tfor (i=1; i<=n; i++) q.push(a[i]);\n\twhile (m--){\n\t\tnode u=q.top(); q.pop();\n\t\tu.x+=x; q.push(u);\n\t}\n\tn=0;\n\twhile (!q.empty()){ a[++n]=q.top(); q.pop(); }\n\tsort(a+1,a+n+1,cmp);\n\topt();\n\treturn 0;\n}']","[1, 1, 0, 0, 1, 0, 1, 0, 0, 0]",2000,Main idea we act greedily trying to make the best possible answer every action each time we choose an action with minimum possible product after it Detailed explanation While we have zeroes in our array we have to get rid of them changing each of them exactly one time Also we keep the quantity of negative numbers we need it to make the product negative after changing the last zero Let be the number of zeroes in the array If then we cannot make the product negative or positive it will always be equal to so any sequence of operations will lead to a correct answer However if then we are able to come to negative product if the number of negative elements was even then we subtract from one zero and add it to all other zeroes if the number of negative elements was odd then we can just add to all zeroes If current product is still positive then we want to change the sign of exactly one element Its absolute value has to be minimal suppose we have two elements and let s prove that if we change s sign then our answer is wrong Let be the minimum number of operations required to change s sign If we perform operations with then the absolute value of won t change and absolute value of will become If on the other hand we perform operations with this may not be optimal but now we need to prove that if we change then the result will be worse then the absolute value of will become the absolute value of won t change The product becomes negative so we need to maximize the product of absolute values And then and so if we change then the product of absolute values will be less than if we change Now until we have performed operations we choose a number with minimum absolute value and enlarge it add if this number if positive subtract if negative Let s prove that the answer will be optimal Suppose that this algorithm chooses on some iteration but we can t get optimal answer if we change This means that we can t change after this iteration at all we can reorder our operations in an arbitrary way and the answer won t change Suppose we have to change instead and Let s consider the sequence of operations leading to the optimal answer when we choose and replace change of with change of and let the product of all remaining numbers the whole array excluding and after all operations be If we change the total product will be and if we change we get is the number of times we change Now so so the absolute value of total product will be greater if we change This proves that we won t come to unoptimal answer if we change Time complexity if we use a data structure similar to or to get the number with minimal absolute value Memory complexity 
You are given a sequence of numbers and a number Check if it is possible to choose a non empty subsequence such that the sum of numbers in this subsequence is divisible by ,"['#include<cstdio>\n\nint S[10000];\nint F[10000];\nint P[10000];\n\nint main()\n{\n    int n1, n2, i, j, l, x, y, z;\n    scanf(""%d%d"", &n1, &n2);\n    for (i = 1 ; i <= n1 ; ++i)\n    {\n        scanf(""%d"", &j);\n        j %= n2;\n        F[j]++;\n    }\n    for (i = 0 ; i < n2 ; ++i)\n    {\n        x = 1;\n        while (F[i] > 0)\n        {\n            y = x < F[i] ? x : F[i];\n            F[i]-=y; x*=2;\n            z = (i*y) % n2;\n            for (l = 0 ; l < n2 ; ++l)\n                if (S[l]) P[(l+z)%n2]=1;\n            for (l = 0 ; l < n2 ; ++l)\n                S[l] += P[l], P[l] = 0;\n            S[z] = 1;\n        }\n        if (S[0]) break;\n    }\n    if (S[0]) printf(""YES\\n"");\n    else printf(""NO\\n"");\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1900,Let s consider two cases n m and n m If n m let s look at prefix sums By pigeonhole principle there are two equals sums modulo m Assume Slmodm Srmodm Then the sum on segment l 1 r equals zero modulo m that means the answer is definitely YES If n m we ll solve this task using dynamic programming in O m2 time Assume can i r means if we can achieve the sum equal to r modulo m using only first i 1 items The updates in this dynamic programming are obvious we either take number ai and go to the state can i 1 r ai mod m or not then we ll get to the state can i 1 r 
Let s say that two strings a and b are if you can get the string b by cyclically shifting string a For example the strings and are equal while and are not You are given a binary string s of length n Its first c characters are s and its last n c characters are s In one operation you can replace one with Calculate the number of unique strings you can get using no more than k operations Since the answer may be too large print it modulo 10 9 7 ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0\xa0\xa0#include <utility>\xa0namespace atcoder {\xa0namespace internal {\xa0// @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;}\xa0// Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;\xa0    // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\xa0    // @return m    unsigned int umod() const { return _m; }\xa0    // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay\xa0        // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }};\xa0// @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;}\xa0// Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n);\xa0// @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};\xa0    // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;\xa0    while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\xa0        // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b\xa0        auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};}\xa0// Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0\xa0#include <cassert>#include <numeric>#include <type_traits>\xa0namespace atcoder {\xa0namespace internal {\xa0#ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>;\xa0template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type;\xa0template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type;\xa0template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type;\xa0#else\xa0template <class T> using is_integral = typename std::is_integral<T>;\xa0template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type;\xa0#endif\xa0template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\xa0template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\xa0template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0#include <cassert>#include <numeric>#include <type_traits>\xa0#ifdef _MSC_VER#include <intrin.h>#endif\xa0namespace atcoder {\xa0namespace internal {\xa0struct modint_base {};struct static_modint_base : modint_base {};\xa0template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\xa0}  // namespace internal\xa0template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;\xa0  public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\xa0    static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\xa0    unsigned int val() const { return _v; }\xa0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\xa0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\xa0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\xa0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }\xa0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\xa0  private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;};\xa0template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;\xa0  public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\xa0    dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\xa0    unsigned int val() const { return _v; }\xa0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\xa0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\xa0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\xa0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }\xa0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\xa0  private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\xa0using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>;\xa0namespace internal {\xa0template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\xa0template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\xa0template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\xa0template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0using namespace atcoder;\xa0//using mint=modint998244353;using mint=modint1000000007;\xa0template<int mod>struct nCr{    vector<static_modint<mod>> fac,inv,ifac;    void calc(int n){        fac.resize(n+1),inv.resize(n+1),ifac.resize(n+1);        fac[0]=inv[1]=ifac[0]=1;        for(int i=1; i<=n; ++i) fac[i]=fac[i-1]*static_modint<mod>::raw(i);        for(int i=2; i<=n; ++i) inv[i]=inv[mod%i]*static_modint<mod>::raw(mod-mod/i);        for(int i=1; i<=n; ++i) ifac[i]=ifac[i-1]*inv[i];    }    static_modint<mod> C(int n, int m){        if(m<0||m>n) return 0;        return fac[n]*ifac[m]*ifac[n-m];    }};\xa0nCr<1000000007> de;\xa0void ahcorz(){    int n,c,k; cin >> n >> c >> k;    de.calc(n+1);    vv(mint,dp,n+1,n+1);    dp[1][1]=1;    rep(i,2,n+1) rep(j,2,n+1){        dp[i][j]=dp[i][j-1]+dp[i-1][j-1];        if(j-1-c>=1) dp[i][j]-=dp[i-1][j-1-c];    }    per(i,n,0) rep(j,1,n+1) dp[i][j]+=dp[i+1][j];    vc<mint> dp2(n+1);    rep(m,1,n+1) if(n%m==0){        rep(m+1) if(i*(n/m)<=c+k) dp2[m]+=de.C(m,i);        rep(i,1,m+1) if(m+1-i<=c) dp2[m]-=(m+1-i)*dp[iceil(n-c-k,n/m)][i];        bug(m,dp2[m].val());    }    rep(m,1,n+1) if(n%m==0){        rep(i,1,m) if(m%i==0) dp2[m]-=dp2[i];    }    mint res;    rep(m,1,n+1) res+=dp2[m]/m;    print(res.val());}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",3100,What s common in all strings we can get each string has no more than ones and at least consecutive ones So let s loosen up our constraints a little and just calculate the number of strings with no more than ones and at least consecutive ones i e this block of ones can be anywhere can even start at the end and continue at the beginning Let s name such strings as Note that the number of unique good strings is exactly equal to the answer of the initial task since we can shift each good string and make it start from the block of ones How to calculate the number of good strings Using Burnside s lemma Since the group of transformations is just a group of cyclic shifts we can calculate the answer as following where is the number of or the number of strings that won t change after a cyclical shift by characters Note that if the string doesn t change while shifting by characters then it means that for all Further investigation reveals that all characters will be split into exactly groups and each group will contain exactly equal characters It means that if then since in both cases we ll get exactly the same group division So we can rewrite the answer as following where is the number of cyclic shifts with and can be easily counted So it s time to calculate for some divisor of It s not hard to see that if then the first characters of will uniquely define the whole string So it s enough to work with only a prefix of length remembering that each character will be copied times Remember that a good string is a string with at most ones and since each character will be copied times we can place at most ones in our prefix or at least zeroes Also since a good string has consecutive ones our prefix should also have consecutive ones including the case where the ones go cyclically starting at the end of the prefix In case if then the whole prefix should consist of ones and it s either possible if or impossible if In case we need to calculate the number of good prefixes that can be described as the cyclic strings of length that has no more than ones and contains consecutive ones Instead of good prefixes let s calculate bad prefixes and subtract them from all possible prefixes prefixes are just strings with at most ones and there are such strings prefixes are cyclic strings with at most ones where all blocks of ones have length less than In order to calculate bad prefixes let s precalc the following dp is the number of strings of length with where all blocks of ones have length less than and the last character of the string is Why did we use the number of zeroes in the state and why did we add the last zero in Because it will help us to calculate dp fast Now if we have value we can add a block of ones and zero to the end of the string and update the value in Note that we are updating a segment of row from to with value we can do it in So we can precalc the whole dp in time Now it s time to calculate the number of bad strings if we iterate over the length of the prefix of ones length of the suffix of ones and the number of zeroes in between we ll get where is the number of ones on prefix is the number of ones on suffix and is the number of zeroes in the middle part Since each bad string will look like ones middle part ending at ones you can place in the middle part at least zeroes and at most zeroes If we play a little with the sum we can simplify it in the following way where is the sum of dp on the row from to and you can take it in if you precalc prefix sums of dp prefixes are just and since can be calculated in the total complexity of is The resulting complexity is that looks like just 
You are given two sequences a 1 a 2 dots a n and b 1 b 2 dots b n Each element of both sequences is either 0 1 or 2 The number of elements 0 1 2 in the sequence a is x 1 y 1 z 1 respectively and the number of elements 0 1 2 in the sequence b is x 2 y 2 z 2 respectively You can rearrange the elements in both sequences a and b however you like After that let s define a sequence c as follows c i begin cases a i b i mbox if a i b i 0 mbox if a i b i a i b i mbox if a i b i end cases You d like to make sum i 1 n c i the sum of all elements of the sequence c as large as possible What is the maximum possible sum ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tint c=min(z1, y2), ans=c;\n\t\tz1-=ans;\n\t\ty2-=ans;\n\t\tc=min(y1, x2);\n\t\ty1-=c;\n\t\tx2-=c;\n\t\tc=min(y1, y2);\n\t\ty1-=c;\n\t\ty2-=c;\n\t\tc=min(z2, x1);\n\t\tz2-=c;\n\t\tx1-=c;\n\t\tc=min(z2, z1);\n\t\tz2-=c;\n\t\tz1-=c;\n\t\tc=min(y1, z2);\n\t\tans-=c;\n\t\tcout << 2*ans << ""\\n"";\n\t}\n\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1100,We can find the kind of the value of is three And is only if is and is and is only if is and is Otherwise is So we have to make pair as little as possible and pair as much as possible To do this first we can make pair pair and pair as much as possible After that pairing the remaining values doesn t affect the sum of It in which value is and in which value is are all left we have to pair them although the sum decreases Time complexity 
Once Vasya and Petya assembled a figure of cubes each of them is associated with a number between and inclusive each number appeared exactly once Let s consider a coordinate system such that the is the ground and the is directed upwards Each cube is associated with the coordinates of its lower left corner these coordinates are integers for each cube The figure turned out to be This means that for any cube that is not on the ground there is at least one cube under it such that those two cubes touch More formally this means that for the cube with coordinates either or there is a cube with coordinates or Now the boys want to disassemble the figure and put all the cubes in a row In one step the cube is removed from the figure and being put to the right of the blocks that have already been laid The guys remove the cubes in such order that the figure remains stable To make the process more interesting the guys decided to play the following game The guys take out the cubes from the figure in turns It is easy to see that after the figure is disassembled the integers written on the cubes form a number written in the ary positional numerical system possibly with a leading zero Vasya wants the resulting number to be maximum possible and Petya on the contrary tries to make it as small as possible Vasya starts the game Your task is to determine what number is formed after the figure is disassembled if the boys play optimally Determine the remainder of the answer modulo ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define mp make_pair\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << ""("" << a.first << "", "" << a.second << "")""; };\ntemplate <typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate <typename T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <typename T> void chmax(T &t, const T &f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\nconst Int MO = 1000000009;\n\nint N;\nint X[100010], Y[100010];\n\nmap<pint, int> tr;\nint nei[100010][5][3];\n\nbool is[100010];\n\nset<int> cands;\nbool on[100010];\n\nbool canRemove(int u) {\n#define has(e,f) is[nei[u][e][f]]\n\tif (has(1, 2) && !has(0, 1) && !has(1, 1)) return false;\n\tif (has(2, 2) && !has(1, 1) && !has(3, 1)) return false;\n\tif (has(3, 2) && !has(3, 1) && !has(4, 1)) return false;\n\treturn true;\n#undef has\n}\n\nint main() {\n\t\n\t\n\tfor (; ~scanf(""%d"", &N); ) {\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\tX[u] = in();\n\t\t\tY[u] = in();\n\t\t}\n\t\ttr.clear();\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\ttr[mp(X[u], Y[u])] = u;\n\t\t}\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\tfor (int e = 0; e < 5; ++e) for (int f = 0; f < 3; ++f) {\n\t\t\t\tauto it = tr.find(mp(X[u] - 2 + e, Y[u] - 1 + f));\n\t\t\t\tnei[u][e][f] = (it != tr.end()) ? it->second : N;\n\t\t\t}\n\t\t}\n\t\tfill(is, is + N, true);\n\t\tis[N] = false;\n\t\t\n\t\tcands.clear();\n\t\tfill(on, on + N, false);\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\tif (canRemove(u)) {\n\t\t\t\tcands.insert(u);\n\t\t\t\ton[u] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tInt ans = 0;\n\t\tfor (int turn = 0; turn < N; ++turn) {\n\t\t\tassert(!cands.empty());\n\t\t\tint u = -1;\n\t\t\tswitch (turn % 2) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tu = *--cands.end();\n\t\t\t\t} break;\n\t\t\t\tcase 1: {\n\t\t\t\t\tu = *cands.begin();\n\t\t\t\t} break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t\tassert(is[u]);\n\t\t\tans = (ans * N + u) % MO;\n\t\t\tcands.erase(u);\n\t\t\ton[u] = false;\n\t\t\tis[u] = false;\n\t\t\tfor (int e = 0; e < 5; ++e) for (int f = 0; f < 3; ++f) {\n\t\t\t\tconst int v = nei[u][e][f];\n\t\t\t\tif (is[v]) {\n\t\t\t\t\tconst bool res = canRemove(v);\n\t\t\t\t\tif (on[v] != res) {\n\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\tcands.insert(v);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcands.erase(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ton[v] = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n']","[1, 0, 1, 0, 1, 0, 0, 0, 0, 0]",2100,Basically the first player should maximize the lexicographical order of numbers and the second player should minimize it Thus at every move the first player should choose the largest available number and the second should choose the minimal one First of all how do we check if the cube can be removed It is impossible only if there is some cube supported by it i e it has coordinates x 1 y 1 x y 1 x 1 y 1 such that our cube is the only one supporting it This can be checked explicitly The large coordinates limitations do not allow us to store a simply array for that so we should use an associative array like a set in C Now we should find the maximal minimal number that can be removed A simple linear search won t work fast enough so we store another data structure containing all numbers available to remove the structure should allow inserting erasing and finding global minimum maximum so the set C structure fits again When we ve made our move some cubes may have become available or unavailable to remove However there is an O 1 amount of cubes we have to recheck and possibly insert erase from our structure the cubes x 1 y and x 2 y may have become unavailable because some higher cube has become dangerous that is there is a single cube supporting it and some of the cubes x 1 y 1 x y 1 and x 1 y 1 may have become available because our cube was the only dangerous cube that it has been supporting Anyway a simple recheck for these cubes will handle all the cases 
2 n teams participate in a playoff tournament The tournament consists of 2 n 1 games They are held as follows in the first phase of the tournament the teams are split into pairs team 1 plays against team 2 team 3 plays against team 4 and so on so 2 n 1 games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only 2 n 1 teams remain If only one team remains it is declared the champion otherwise the second phase begins where 2 n 2 games are played in the first one of them the winner of the game 1 vs 2 plays against the winner of the game 3 vs 4 then the winner of the game 5 vs 6 plays against the winner of the game 7 vs 8 and so on This process repeats until only one team remains The skill level of the i th team is p i where p is a permutation of integers 1 2 2 n a permutation is an array where each element from 1 to 2 n occurs exactly once You are given a string s which consists of n characters These characters denote the results of games in each phase of the tournament as follows if s i is equal to then during the i th phase the phase with 2 n i games in each match the team with the lower skill level wins if s i is equal to then during the i th phase the phase with 2 n i games in each match the team with the higher skill level wins Let s say that an integer x is if it is possible to find a permutation p such that the team with skill x wins the tournament Find all winning integers ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nint n;\nint dp[2][N];\nchar s[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tscanf("" %s"", s);\n\treverse(s, s + n);\n\tdp[0][0] = 1;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i <= (1 << (k + 1)); i++)\n\t\t\tdp[1][i] = 0;\n\t\tfor (int w = 0; w < (1 << k); w++) if (dp[0][w]) {\n\t\t\tint curW = w;\n\t\t\tint curL = (1 << k) - 1 - w;\n\t\t\tint l, r;\n\t\t\tif (s[k] == \'0\') {\n\t\t\t\tl = curL;\n\t\t\t\tr = 2 * curL;\n\t\t\t\tswap(l, r);\n\t\t\t\tl = (1 << (k + 1)) - 1 - l;\n\t\t\t\tr = (1 << (k + 1)) - 1 - r;\n\t\t\t} else {\n\t\t\t\tl = curW;\n\t\t\t\tr = 2 * curW;\n\t\t\t}\n\t\t\tdp[1][l]++;\n\t\t\tdp[1][r + 1]--;\n\t\t}\n\t\tint bal = 0;\n\t\tfor (int i = 0; i < (1 << (k + 1)); i++) {\n\t\t\tbal += dp[1][i];\n\t\t\tdp[0][i] = min(1, bal);\n\t\t}\n\t}\n\tfor (int i = (1 << n) - 1; i >= 0; i--) if (dp[0][i])\n\t\tprintf(""%d "", (1 << n) - i);\n\n\treturn 0;\n}\n']","[1, 1, 0, 1, 0, 0, 1, 0, 0, 0]",1500,Firstly let s prove that the order of characters in is interchangeable Suppose we have a tournament of four teams with skills and such that and this tournament has the form or It s easy to see that and cannot be winners since will be eliminated in the round with type and will be eliminated in the round with type However it s easy to show that both with and with and can be winners Using this argument to matches that go during phases and a group of two matches during phase and a match during phase between the winners of those matches can be considered a tournament with we can show that swapping and does not affect the possible winners of the tournament So suppose all phases of type happen before phases of type there are phases of type and phases of type teams will be eliminated in the first part phases of type and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size Furthermore since the minimum of teams passing through the first half wins the winner should have skill not greater than the winner should have lower skill than at least teams so teams with skills higher than cannot win Okay now all possible winners belong to the segment Let s show that any integer from this segment can be winning Suppose let s construct the tournament in such a way that only team with skill and teams with the highest skill pass through the first part of the tournament obviously then team wins There are independent tournaments of size in the first part let s assign teams with skills from to and also the team to one of those tournaments for all other tournaments let s assign the teams in such a way that exactly one team from the highest ones competes in each of them It s easy to see that the team will win its tournament and every team from the highest ones will win its tournament as well so the second half will contain only teams with skills and and obviously will be the winner of this tournament So the answer to the problem is the segment of integers 
Welcome to Codeforces Stock Exchange We re pretty limited now as we currently allow trading on one stock Codeforces Ltd We hope you ll still be able to make profit from the market In the morning there are n opportunities to buy shares The i th of them allows to buy as many shares as you want each at the price of s i bourles In the evening there are m opportunities to sell shares The i th of them allows to sell as many shares as you want each at the price of b i bourles You can t sell more shares than you have It s morning now and you possess r bourles and no shares What is the maximum number of bourles you can hold after the evening ,"['#include<bits/stdc++.h>\nconst int MAXN=30+5;\nint n,m,r;\nint s[MAXN+5],b[MAXN+5];\nint mins=1000,maxb=1;\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&r);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(""%d"",&s[i]);\n\t\tmins=std::min(mins,s[i]);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(""%d"",&b[i]);\n\t\tmaxb=std::max(maxb,b[i]);\n\t}\n\tif(mins>=maxb){\n\t\tprintf(""%d\\n"",r);\n\t}else{\n\t\tprintf(""%d\\n"",r%mins+r/mins*maxb);\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800,The main observation is that we always want to buy shares as cheaply as possible and sell them as expensively as possible Therefore we should pick the lowest price at which we can buy shares and the highest price at which we can sell the shares Now we have two cases If it s optimal to buy as many shares and possible in the morning and sell them all in the evening We can buy as many as shares and gain bourles profit on each of them Therefore the final balance is If we re not gaining any profit on the shares and therefore we shouldn t care about trading stocks at all The final balance is then The solution can be therefore implemented in time However the constraints even allowed brute forcing the seller the buyer and the amount of stock we re buying in time Note that many programming languages have routines for finding the minima maxima of the collections of integers e g in C in Java or in Python This should make the code shorter and quicker to write 
One day Vasya got hold of a sheet of checkered paper squares in size Our Vasya adores geometrical figures so he painted two rectangles on the paper The rectangles sides are parallel to the coordinates axes also the length of each side of each rectangle is no less than 3 squares and the sides are painted by the grid lines The sides can also be part of the sheet of paper s edge Then Vasya hatched all squares on the rectangles Let s define a rectangle s frame as the set of squares the rectangle that share at least one side with its border A little later Vasya found a sheet of paper of exactly the same size and couldn t guess whether it is the same sheet of paper or a different one So he asked you to check whether the sheet of paper he had found contains two painted frames and nothing besides them Please note that the frames painted by Vasya can arbitrarily intersect overlap or even completely coincide The coordinates on the sheet of paper are introduced in such a way that the axis goes from top to bottom the coordinates of the squares numbers take values from to and the axis goes from the left to the right and the coordinates of the squares numbers take values from to ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nPII p[1100*1100];\nint n, m;\nchar mat[1100][1100];\nint sum[1100][1100];\n\nint get(int x0, int y0, int x1, int y1){\n\treturn sum[x1][y1]-sum[x1][y0-1]-sum[x0-1][y1]+sum[x0-1][y0-1];\n}\n\nbool canRec(int x0, int y0, int x1, int y1){\n\tif( x1<x0+2 || y1<y0+2 ) return false;\n\tif( get(x0, y0, x0, y1)!=(y1-y0+1) ) return false;\n\tif( get(x0, y0, x1, y0)!=(x1-x0+1) ) return false;\n\tif( get(x1, y0, x1, y1)!=(y1-y0+1) ) return false;\n\tif( get(x0, y1, x1, y1)!=(x1-x0+1) ) return false;\n\treturn true;\n}\nbool in(int x0, int y0, int x1, int y1, int x, int y){\n\tif( x>=x0 && x<=x1 && (y==y0 || y==y1) ) return true;\n\tif( y>=y0 && y<=y1 && (x==x0 || x==x1) ) return true;\n\treturn false;\n}\n\nint main(){\n\twhile( scanf(""%d %d"", &n, &m)!=EOF ){\n\t\tint cnt=0;\n\t\trep(i, 1, n+1){\n\t\t\tscanf("" %s"", mat[i]+1);\n\t\t\trep(j, 1, m+1){\n\t\t\t\tsum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+(mat[i][j]==\'#\');\n\t\t\t\tif( mat[i][j]==\'#\' ){\n\t\t\t\t\tp[cnt++]=MP(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( cnt>8100 ){\n\t\t\tputs(""NO"");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(p, p+cnt);\n\t\trep(i, 1, cnt){\n\t\t\tint x0=p[0].ff, y0=p[0].ss;\n\t\t\tint x1=p[i].ff, y1=p[i].ss;\n\t\t\tif( canRec(x0, y0, x1, y1)==false ) continue;\n\t\t\tset<int> stx, sty;\n\t\t\tstx.insert(x0);\n\t\t\tstx.insert(x1);\n\t\t\tsty.insert(y0);\n\t\t\tsty.insert(y1);\n\t\t\tint xma=0, xmi=10000, yma=xma, ymi=xmi;\n\t\t\tint num=0;\n\t\t\trep(j, 0, cnt) if( in(x0, y0, x1, y1, p[j].ff, p[j].ss)==false ){\n\t\t\t\txma=max(xma, p[j].ff);\n\t\t\t\txmi=min(xmi, p[j].ff);\n\t\t\t\tyma=max(yma, p[j].ss);\n\t\t\t\tymi=min(ymi, p[j].ss);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tif( num==0 ){\n\t\t\t\tputs(""YES"");\n\t\t\t\tprintf(""%d %d %d %d\\n"", x0, y0, x1, y1);\n\t\t\t\tprintf(""%d %d %d %d\\n"", x0, y0, x1, y1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstx.insert(xmi);\n\t\t\tif( xmi-1>0 ) stx.insert(xmi-1);\n\t\t\tstx.insert(xma);\n\t\t\tif( xma+1<=n) stx.insert(xma+1);\n\t\t\tsty.insert(ymi);\n\t\t\tif( ymi-1>0 ) sty.insert(ymi-1);\n\t\t\tsty.insert(yma);\n\t\t\tif( yma+1<=m) sty.insert(yma+1);\n\t\t\t\n\t\t\trepi(itx1, stx) repi(itx2, stx) {\n\t\t\t\tif( *itx1+2<=*itx2 ){\n\t\t\t\t\trepi(ity1, sty) repi(ity2, sty){\n\t\t\t\t\t\tif( *ity1+2<=*ity2 ){\n\t\t\t\t\t\t\tint _x0=*itx1, _y0=*ity1;\n\t\t\t\t\t\t\tint _x1=*itx2, _y1=*ity2;\n\t\t\t\t\t\t\tif( canRec(_x0, _y0, _x1, _y1)==false ) continue;\n\t\t\t\t\t\t\tbool suc=true;\n\t\t\t\t\t\t\trep(j, 0, cnt){\n\t\t\t\t\t\t\t\tif( in(x0, y0, x1, y1, p[j].ff, p[j].ss) ) continue;\n\t\t\t\t\t\t\t\tif( in(_x0, _y0, _x1, _y1, p[j].ff, p[j].ss) ) continue;\n\t\t\t\t\t\t\t\tsuc=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( suc ){\n\t\t\t\t\t\t\t\tputs(""YES"");\n\t\t\t\t\t\t\t\tprintf(""%d %d %d %d\\n"", x0, y0, x1, y1);\n\t\t\t\t\t\t\t\tprintf(""%d %d %d %d\\n"", _x0, _y0, _x1, _y1);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(""NO"");\n\t}\n}\n/*\n4 5\n#####\n#...#\n#...#\n#####\n*/\n\n\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2600,It was necessary to understand if there are two borders or not Let s distinguish those and coordinates in which there are at least consecutive symbols becouse the length of each border is no less then It is clear that the coordinates of the corners of borders should be chosen only from those selected and In general the various selected no more then and various selected no more then Except that case when the height or width of the first border is and length of the second side of this border is more than and one side of the second border fills a part of the inside first at least For example The first border The second border There are different coordinates in the example Carefully processed these cases separately it is quite simple Let s choose coordinates minimum maximum second minimum and second maximum Otherwise if the amount selected and coordinates no more then then let s choose opposite corners of the first and second borders and verify that the selected borders the correct borders and there are no other characters Checking is carried out at or using partial sums 
AquaMoon had n strings of length m each n is an number When AquaMoon was gone Cirno tried to pair these n strings together After making frac n 1 2 pairs she found out that there was exactly one string without the pair In her rage she disrupted each pair of strings For each pair she selected some positions at least 1 and at most m and swapped the letters in the two strings of this pair at the selected positions For example if m 6 and two strings and are in one pair and Cirno selected positions 2 3 and 6 she will swap with with and with The resulting strings will be and Cirno then stole away the string without pair and shuffled all remaining strings in arbitrary order AquaMoon found the remaining n 1 strings in complete disarray Also she remembers the initial n strings She wants to know which string was stolen but she is not good at programming Can you help her ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"") \n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n,m;\nstring a[200005];\nint cnt[100005][26];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n >> m;\n        for(int i = 0;i < m;i++) {\n            for(int j = 0;j < 26;j++) cnt[i][j] = 0;\n        }\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            for(int j = 0;j < m;j++) {\n                cnt[j][a[i][j]-\'a\']++;\n            }\n        }\n        for(int i = n+1;i < 2*n;i++) {\n            cin >> a[i];\n            for(int j = 0;j < m;j++) {\n                cnt[j][a[i][j]-\'a\']--;\n            }\n        }\n        for(int i = 0;i < m;i++) {\n            for(int j = 0;j < 26;j++) {\n                if(cnt[i][j]) cout << (char)(j+\'a\');\n            }\n        }\n        cout << \'\\n\';\n    }\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200,We can find that for each letter of the answer must appear an odd number of times in its column Since for other strings they appear twice in total The operation does not change the number of the occurrence of some certain letter in one column So we can consider each position individually There is always exactly one letter that occurs an odd number of times So just take them out and they are the letters of the stolen string 
Ksusha is a beginner coder Today she starts studying arrays She has array consisting of positive integers Her university teacher gave her a task Find such number in the array that all array elements are divisible by it Help her and find the number ,"['//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define fi first\n#define se second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,1,-1};\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << "" = "" << (x) << endl;\n#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;\n\nint n;\nint a[100010];\nint g;\n\nint main(){\n    cin >> n;\n    rep(i, n){\n\tcin >> a[i];\n\tif(!i) g = a[i];\n\telse g = __gcd(g, a[i]);\n    }\n    rep(i, n){\n\tif(g % a[i] == 0){\n\t    cout << a[i] << endl;\n\t    return 0;\n\t}\n    }\n    cout << ""-1"" << endl;\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 1, 0]",1000,If divide than So the number which will divide every other number should be less than or equal to every other number so the only possible candidate it s the minimum in the array So just check whether all elements are divisible by the minimal one 
Hanh is a famous biologist He loves growing trees and doing experiments on his own garden One day he got a tree consisting of n vertices Vertices are numbered from 1 to n A tree with n vertices is an undirected connected graph with n 1 edges Initially Hanh sets the value of every vertex to 0 Now Hanh performs q operations each is either of the following types Type 1 Hanh selects a vertex v and an integer d Then he chooses some vertex r lists all vertices u such that the path from r to u passes through v Hanh then increases the value of all such vertices u by d Type 2 Hanh selects a vertex v and calculates the expected value of v Since Hanh is good at biology but not math he needs your help on these operations ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\nconst ll mod=998244353;\n\nint n, q;\n\nvi graf[nax];\nint pre[nax];\nint post[nax];\nint czas;\n\nint roz[nax];\n\nvector <pair<int,pii> > waz[nax];\n\nll dziel(ll a, ll b)\n{\n\ta%=mod;\n\tb%=mod;\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nll drz[nax];\n\nvoid dod(int a, int b, ll w)\n{\n\tw%=mod;\n\tfor (int i=a; i<=n; i+=(i&(-i)))\n\t\tdrz[i]+=w;\n\tfor (int i=b+1; i<=n; i+=(i&(-i)))\n\t\tdrz[i]-=w;\n}\n\nll czyt(int v)\n{\n\tll ret=0;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret+=drz[i];\n\tret%=mod;\n\tif (ret<0)\n\t\tret+=mod;\n\treturn ret;\n}\n\nvoid dfs1(int v, int oj)\n{\n\troz[v]=1;\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs1(i, v);\n\t\troz[v]+=roz[i];\n\t}\n}\n\nbool mniej(int a, int b)\n{\n\treturn roz[a]<roz[b];\n}\n\nvoid dfs2(int v, int oj)\n{\n\tsort(graf[v].begin(), graf[v].end(), mniej);\n\tif (!graf[v].empty() && graf[v].back()==oj)\n\t\tgraf[v].pop_back();\n\tczas++;\n\tpre[v]=czas;\n\tfor (int i : graf[v])\n\t\tdfs2(i, v);\n\tpost[v]=czas;\n\t\n\tif (v!=1)\n\t{\n\t\twaz[v].push_back({n-roz[v], {1, pre[v]-1}});\n\t\twaz[v].push_back({n-roz[v], {post[v]+1, n}});\n\t}\n\tint g;\n\tfor (int i=0; i<(int)graf[v].size(); i=g)\n\t{\n\t\tg=i;\n\t\twhile(g<(int)graf[v].size() && roz[graf[v][i]]==roz[graf[v][g]])\n\t\t\tg++;\n\t\twaz[v].push_back({roz[graf[v][i]], {pre[graf[v][i]], post[graf[v][g-1]]}});\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tdfs1(1, 0);\n\tdfs2(1, 0);\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ debug() << pre[i] << "" "" << waz[i];\n\tll dzn=dziel(1, n);\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(""%d"", &typ);\n\t\tif (typ==1)\n\t\t{\n\t\t\tint v;\n\t\t\tll d;\n\t\t\tscanf(""%d%lld"", &v, &d);\n\t\t\tdod(1, n, n*d);\n\t\t\tfor (const auto i : waz[v])\n\t\t\t\tdod(i.second.first, i.second.second, -i.first*d);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(""%d"", &v);\n\t\t\tll x=czyt(pre[v]);\n\t\t\tx%=mod;\n\t\t\tx+=mod;\n\t\t\tx%=mod;\n\t\t\tprintf(""%lld\\n"", (x*dzn)%mod);\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2700,Our other authors and testers have found better solutions our best complexity is However since this solution is the theoretically worst complexity that we intended to accept I decided to write about it Feel free to share your better solution in the comment section Consider two distinct vertices the number of vertices such that the path from to passes through is where is the subtree we get by cutting the first edge on the path from to then keep the part with vertex If then this value will be By linearity of expectation we can see that adding to will add to the expected value of an amount equal to Note that this value is the same for all that lies on the same subtree branch of To update it efficiently we can split the vertices into groups those which has degree greater than there are no more than of them and those which does not When we update a light vertex we iterate over the neighbors of and update the subtrees accordingly When we get the value of a vertex we already have the sum of contributions from all light vertices to hence we can iterate over all heavy vertices and calculate the contribution from each of them to If we use range update point query data structures such as Fenwick Trees then the complexity will be if we choose 
There is an array a consisting of non negative integers You can choose an integer x and denote b i a i oplus x for all 1 le i le n where oplus denotes the bitwise XOR operation Is it possible to choose such a number x that the value of the expression b 1 oplus b 2 oplus ldots oplus b n equals 0 It can be shown that if a valid number x exists then there also exists x such that 0 le x 2 8 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(""YES"");\n\telse\n\t\tputs(""NO"");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(""yes"");\n\telse\n\t\tputs(""no"");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(""Yes"");\n\telse\n\t\tputs(""No"");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<\'0\'||c>\'9\')\n\t{\n\t\tif(c==\'-\')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>=\'0\'&&c<=\'9\')\n\t{\n\t\tx=x*10+c-\'0\';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar(\'-\'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+\'0\');\n//\tputchar(\'\\n\');\n}\ninline void fre()\n{\n\tfreopen("".in"",""r"",stdin);\n\tfreopen("".out"",""w"",stdout);\n}\nvoid work()\n{\n\tint n,s=0,x;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>x;\n\t\ts^=x;\n\t}\n\tif(s&&(~n&1))\n\t\tputs(""-1"");\n\telse\n\t\tcout<<s<<endl;\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n\tcases();\n//\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",800,Note that equals if is even or if is odd Then if the length of the array is odd you must print of the whole array And if the length is even we can t change the value of the expression with our operation It turns out that if of the whole array is we can output any number but otherwise there is no answer 
Amr has got a large array of size Amr doesn t like large arrays so he intends to make it smaller Amr doesn t care about anything in the array except the beauty of it The beauty of the array is defined to be the maximum number of times that some number occurs in this array He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array Help Amr by choosing the smallest subsegment possible ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\nint i, j, k, n, m, x, cnt[N], l[N], r[N], ans, le, ri, aaa = inf;;\n\nint main(){\n\t\n\tscanf(""%d"",&n);\n\n\tmemset(l, 12, sizeof l);\n\n\tFOR(i,1,n) {\n\t\t\n\t\tscanf(""%d"",&x);\n\n\t\tl[x] = min(l[x], i);\n\t\tr[x] = max(r[x], i);\n\t\tcnt[x]++;\n\t\tans = max(cnt[x], ans);\n\n\t}\n\n\tFOR(i,1,N-1)\n\t\tif(cnt[i] == ans && r[i]-l[i]+1 < aaa) {\n\t\t\taaa = r[i] - l[i] + 1;\n\t\t\tle = l[i]; \n\t\t\tri = r[i];\n\t\t}\n\t\n\tcout << le << \' \' << ri << endl;\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300,First observation in this problem is that if the subarray chosen has as a value that has the maximum number of occurrences among other elements then the subarray should be Because if the subarray begins or ends with another element we can delete it and make the subarray smaller So Let s save for every distinct element in the array three numbers the smallest index such that the largest index such that and the number of times it appears in the array And between all the elements that has maximum number of occurrences we want to minimize i e the size of the subarray Time complexity Implementation 
Zeyad wants to commit crimes in Egypt and not be punished at the end There are several types of crimes For example bribery is a crime but is not considered such when repeated twice Therefore bribery is not considered a crime when repeated an even number of times Speeding is a crime but is not considered such when repeated a number of times which is a multiple of five More specifically conditions on crime repetitions are known Each condition describes the crime type and its multiplicity If the number of times Zeyad committed the crime is a multiple of Zeyad will not be punished for crime Some crimes may be listed more than once In this case fulfilling at least one condition for this crime is enough to not be punished for it Of course if for certain crime the number of times Zeyad committed it is zero he is innocent with respect to this crime Now Zeyad is interested in a number of ways he can commit exactly crimes without any punishment The order of commiting the crimes matters More formally two ways sequences and of committing crimes are equal if for all ,"['/*\n * d.cpp\n *\n *  Created on: 2011-8-23\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\ntypedef vector<vector<int> > mat;\nconst int MOD = 12345;\nint N;\n\nmat zero() {\n\treturn mat(N, vector<int>(N, 0));\n}\n\nmat unit() {\n\tmat a = zero();\n\tfor (int i = 0; i < N; ++i) {\n\t\ta[i][i] = 1;\n\t}\n\treturn a;\n}\n\nmat operator*(mat a, mat b) {\n\tmat c = zero();\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint tmp = 0;\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\ttmp += a[i][k] * b[k][j];\n\t\t\t\tif (k % 10 == 0)\n\t\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t\tc[i][j] = tmp % MOD;\n\t\t}\n\t}\n\treturn c;\n}\n\ntypedef long long int64;\n\nmat matPow(mat a, int64 e) {\n\tif (!e)\n\t\treturn unit();\n\treturn e & 1 ? matPow(a, e - 1) * a : matPow(a * a, e >> 1);\n}\nint64 n;\nint c;\n\nint w[1000], mod[1000];\nbool has[26] = { };\n\nint main() {\n\tcin >> n >> c;\n\tN = 1;\n\tfor (int i = 0; i < c; ++i) {\n\t\tchar a;\n\t\tscanf("" "");\n\t\tcin >> a;\n\t\tw[i] = a - \'A\';\n\t\thas[w[i]] = true;\n\t\tcin >> mod[i];\n\t\tN *= mod[i];\n\t}\n\tmat m = zero();\n\tfor (int i = 0; i < N; ++i) {\n\t\tstatic int cur[1000];\n\t\tint x = i;\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tcur[j] = x % mod[j];\n\t\t\tx /= mod[j];\n\t\t}\n\t\tfor (int nxt = 0; nxt < 26; ++nxt)\n\t\t\tif (has[nxt]) {\n\t\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\t\tif (w[j] == nxt) {\n\t\t\t\t\t\t++cur[j];\n\t\t\t\t\t\tif (cur[j] >= mod[j])\n\t\t\t\t\t\t\tcur[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ni = 0;\n\t\t\t\tfor (int j = c - 1; j >= 0; --j) {\n\t\t\t\t\tni = ni * mod[j] + cur[j];\n\t\t\t\t}\n\t\t\t\tm[i][ni]++;\n\t\t\t\tif (m[i][ni] >= MOD)\n\t\t\t\t\tm[i][ni] -= MOD;\n\t\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\t\tif (w[j] == nxt) {\n\t\t\t\t\t\t--cur[j];\n\t\t\t\t\t\tif (cur[j] < 0)\n\t\t\t\t\t\t\tcur[j] += mod[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tmat r = matPow(m, n);\n\tint ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x = i;\n\t\tbool ok[26] = { };\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint cur = x % mod[j];\n\t\t\tx /= mod[j];\n\t\t\tif (cur == 0) {\n\t\t\t\tok[w[j]] = true;\n\t\t\t}\n\t\t}\n\t\tbool check = true;\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (has[i] && !ok[i]) {\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check) {\n\t\t\t(ans += r[0][i]) %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 1]",2400,At the first glance the upper limit for n being 1018 looks huge But in fact combined with the fact that the answer should be output modulo 12345 it s should not scare you but rather hint that the problem has a DP approach Like all DP problems the way to approach it is to split the problem into sub problems and figure out what extra information should be carried between the sub problems in order to combine them into the solution to the whole problem Say n is 11 and we solved the problem for the first 10 crimes Clearly just the number of ways to commit the first 10 crimes is not enough to solve the full problem with n 11 The extra information to be carried along with the number of ways to commit n crimes and be innocent is the following the number of ways to commit the first n crimes and have remaining multiplicities d1 d2 d26 respectively The fact that the product of the multiplicities does not exceed 123 makes this a solvable task as the set of all possible remainders contains not more elements than the product of multiplicities To illustrate the idea from the first paragraph consider the first example case It has two constraints A with multiplicity 1 and B with multiplicity 2 The remainder of the number of crimes of type A is always zero and committing crimes of type A may not yield any punishment The remainder of the number of crimes of type B is zero or one Therefore while solving the sub problems for the first n2 n crimes it s enough to keep track of only two numbers number of ways to commit n2 crimes and be completely innocent and number of ways to commit n2 crimes and have committed one extra crime of type B The key step to solve the problem now is to notice that each transition from the solution for the first k crimes to the solution for the first k 1 crimes can be seen as multiplying the vector of the current state by the transition matrix Once all possible transitions are converted to the matrix form the problem can be solved by raising the matrix into n th power Raising the matrix into large power can be done efficiently using matrix exponentiation on some steps instead of computing Ai 1 Ai A0 one can compute A2i Ai Ai The last trick of this problem is to deal with multiple allowed multiplicities If they were not allowed the remainders per each crime type could have been kept with the modulo being equal to the multiplicity for this crime type Moreover if no crime type is listed more than once the only valid final state is the state where the remainders are zero across all the crime types With multiple allowed multiplicities for each crime type the remainder modulo the product of the multiplicities of crimes for this type should be kept Strictly speaking LCM is enough but the constraints allow to use the plain product instead Then at the stage of printing the output instead of treating the counter for the state with zero remainders as the only contributor to the output one would have to iterate through all possible states and verify if each set of remainders conducts a valid final state 
A new innovative ticketing systems for public transport is introduced in Bytesburg Now there is a single travel card for all transport To make a trip a passenger scan his card and then he is charged according to the fare The fare is constructed in the following manner There are three types of tickets a ticket for one trip costs byteland rubles a ticket for minutes costs byteland rubles a ticket for one day minutes costs byteland rubles Note that a ticket for minutes activated at time can be used for trips started in time range from to inclusive Assume that all trips take exactly one minute To simplify the choice for the passenger the system automatically chooses the optimal tickets After each trip starts the system analyses all the previous trips and the current trip and chooses a set of tickets for these trips with a minimum total cost Let the minimum total cost of tickets to cover all trips from the first to the current is and the total sum charged before is Then the system charges the passenger the sum You have to write a program that for given trips made by a passenger calculates the sum the passenger is charged after each trip ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100001];\nint d[100001];\n\nint main() {\n\tint i, n;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\td[i] = min(min(d[i - 1] + 20, d[upper_bound(a, a + i, a[i] - 90) - a - 1] + 50), d[upper_bound(a, a + i, a[i] - 1440) - a - 1] + 120);\n\t\tprintf(""%d\\n"", d[i] - d[i - 1]);\n\t}\n}']","[1, 0, 0, 1, 0, 0, 0, 1, 0, 0]",1600,Hint the problem looks difficult because tickets can change however it s can be solved with simple dynamic programming You are asked the difference between neighboring dp s subtasks 
Daniel has a string consisting of lowercase English letters and period signs characters Let s define the operation of as the following sequence of steps find a substring two consecutive periods in string of all occurrences of the substring let s choose the first one and replace this substring with string In other words during the replacement operation the first two consecutive periods are replaced by one If string contains no two consecutive periods then nothing happens Let s define as the minimum number of operations of to perform so that the string does not have any two consecutive periods left You need to process queries the th results in that the character at position of string is assigned value After each operation you have to calculate and output the value of Help Daniel to process all queries ,"['#include <cstdio>\n#include <algorithm>\n\n#define MAXN 300005\n\nint n,m;\n\nstruct data {\n\tint l,r,size;\n};\n\ninline data operator + (const data &a,const data &b) {\n\treturn (data){a.l==a.size ? a.size+b.l : a.l,b.r==b.size ? b.size+a.r : b.r,a.size+b.size};\n}\n\nchar a[MAXN];\n\nstruct segnode {\n\tsegnode *l,*r;\n\tdata x;\n\t\n\tinline void update() {\n\t\tx=l->x+r->x;\n\t}\n};\n\nsegnode seg[MAXN*2],*segtot=seg;\n\ninline segnode * build(int l,int r) {\n\tsegnode *ret=++segtot;\n\tif (l==r) {\n\t\tret->x=(data){0,0,1};\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tret->l=build(l,mid);\n\t\tret->r=build(mid+1,r);\n\t\tret->update();\n\t}\n\treturn ret;\n}\n\ninline data query(segnode *a,int l,int r,int L,int R) {\n\tif (l==L && r==R) return a->x;\n\tint mid=(L+R)>>1;\n\tif (r<=mid) {\n\t\treturn query(a->l,l,r,L,mid);\n\t} else if (l>mid) {\n\t\treturn query(a->r,l,r,mid+1,R);\n\t} else {\n\t\treturn query(a->l,l,mid,L,mid)+query(a->r,mid+1,r,mid+1,R);\n\t}\n}\n\ninline void mod(segnode *a,int pos,data x,int L,int R) {\n\tif (L==R) {\n\t\ta->x=x;\n\t} else {\n\t\tint mid=(L+R)>>1;\n\t\tif (pos<=mid) {\n\t\t\tmod(a->l,pos,x,L,mid);\n\t\t} else {\n\t\t\tmod(a->r,pos,x,mid+1,R);\n\t\t}\n\t\ta->update();\n\t}\n}\n\nint ans;\n\nsegnode *root;\n\ninline void modify(int pos,char x) {\n\tif (x!=\'.\') x=0;\n\tif (x==a[pos]) return;\n\ta[pos]=x;\n\tif (x==\'.\') {\n\t\tdata L,R;\n\t\tL=R=(data){0,0,0};\n\t\tif (pos>1) L=query(root,1,pos-1,1,n);\n\t\tif (pos<n) R=query(root,pos+1,n,1,n);\n\t\tans-=std::max(L.r-1,0)+std::max(R.l-1,0);\n\t\tans+=L.r+R.l;\n\t\tmod(root,pos,(data){1,1,1},1,n);\n\t} else {\n\t\tdata L,R;\n\t\tL=R=(data){0,0,0};\n\t\tif (pos>1) L=query(root,1,pos-1,1,n);\n\t\tif (pos<n) R=query(root,pos+1,n,1,n);\n\t\tans+=std::max(L.r-1,0)+std::max(R.l-1,0);\n\t\tans-=L.r+R.l;\n\t\tmod(root,pos,(data){0,0,1},1,n);\n\t}\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\tscanf(""%s"",a+1);\n\troot=build(1,n);\n\tint i;\n\tfor (i=1;i<=n;i++) {\n\t\tchar t=a[i];\n\t\ta[i]=0;\n\t\tmodify(i,t);\n\t}\n\tfor (i=1;i<=m;i++) {\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tchar ch=getchar();\n\t\twhile (ch<=32) ch=getchar();\n\t\tmodify(x,ch);\n\t\tprintf(""%d\\n"",ans);\n\t}\n}']","[0, 0, 1, 0, 1, 0, 1, 0, 0, 0]",1600,Lets find how replacements occur If we have segment of points with length we need operations and stop replacements for this segment If we sum lenghts of all segments and its quantity then answer will be total length of segments quantity of segments After change of one symbol length changes by 1 Quantity of segments can be supported by array Consider events of merging dividing creation and deletion of segments For merging we need to find if both of neighbors right and left are points then merging occured and quantity of segments reduced by 1 Other cases can be cosidered similarly Solutions 
Mishka wants to buy some food in the nearby shop Initially he has s burles on his card Mishka can perform the following operation any number of times possibly zero choose some 1 le x le s buy food that costs exactly x burles and obtain lfloor frac x 10 rfloor burles as a cashback in other words Mishka spends x burles and obtains lfloor frac x 10 rfloor back The operation lfloor frac a b rfloor means a divided by b rounded down It is guaranteed that you can always buy some food that costs x for any possible value of x Your task is to say the maximum number of burles Mishka can spend if he buys food optimally For example if Mishka has s 19 burles then the maximum number of burles he can spend is 21 Firstly he can spend x 10 burles obtain 1 burle as a cashback Now he has s 10 burles so can spend x 10 burles obtain 1 burle as a cashback and spend it too You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        scanf(""%d"",&n);\n        LL ans=0;\n        while(n>=10){\n            ans+=n/10*10;\n            n=n%10+n/10;\n        }\n        ans+=n;\n        printf(""%lld\\n"",ans);\n\n    }\n    return 0;\n}\n/*\n*/\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",900,Let s do the following greedy solution it is obvious that when we buy food that costs exactly for we don t lose any burles because of rounding Let s take the maximum power of that is not greater than let it be buy food that costs and add this number to the answer and add to Apply this process until and then add to the answer Time complexity per test case 
Vova s house is an array consisting of n elements yeah this is the first problem I think where someone in the array There are heaters in some positions of the array The i th element of the array is 1 if there is a heater in the position i otherwise the i th element of the array is 0 Each heater has a value r r is the same for all heaters This value means that the heater at the position pos can warm up all the elements in range pos r 1 pos r 1 Vova likes to walk through his house while he thinks and he hates cold positions of his house Vova wants to switch some of his heaters on in such a way that each element of his house will be warmed up by at least one heater Vova s target is to warm up the whole house all the elements of the array i e if n 6 r 2 and heaters are at positions 2 and 5 then Vova can warm up the whole house if he switches all the heaters in the house on then the first 3 elements will be warmed up by the first heater and the last 3 elements will be warmed up by the second heater Initially all the heaters are off But from the other hand Vova didn t like to pay much for the electricity So he wants to switch the number of heaters on in such a way that each element of his house is warmed up by at least one heater Your task is to find this number of heaters or say that it is impossible to warm up the whole house ,"['#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << \'=\' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << "" = {""; FOR(_, l, r) cerr << \' \' << a[_]; cerr << ""}\\n""; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl \'\\n\'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname """"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N], dp[N];\nint main() {\n    #ifdef NERO\n    freopen(""test.inp"",""r"",stdin);\n    freopen(""test.out"",""w"",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname"".inp"",""r"",stdin);\n        //freopen(taskname"".out"",""w"",stdout);\n    #endif //NERO\n    IO;\n    int n, r;\n    cin >> n >> r;\n    FOR(i, 1, n) cin >> a[i];\n    FOR(i, 1, n) dp[i] = 1e9;\n    dp[0] = 0;\n    FOR(i, 1, n) if (a[i]) {\n        int MIN = 1e9;\n        FOR(j, i - r, i - 1) if (j >= 0) MIN = min(MIN, dp[j]);\n        FOR(j, i, i + r - 1) dp[j] = min(dp[j], MIN + 1);\n    }\n    if (dp[n] == 1e9) dp[n] = -1;   \n    cout << dp[n];\n    #ifdef NERO\n    double etime = clock();\n    cerr << ""Execution time: "" << (etime - stime) / CLOCKS_PER_SEC * 1000 << "" ms.\\n"";\n    #endif // NERO\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500,Let s solve this problem greedily Let be the last position from the left covered by at least one heater Initially equals While lets repeat the following process firstly we have to find the rightmost heater in range It can be done in time because of given constrains or in using precalculated prefix values for each in range If there is no such heater then the answer is otherwise let s set increase the answer by and repeat the process if There is another one solution to this problem Assume that the initial answer equals to the total number of heaters Let s calculate an array of length where means the number of heaters covering the th element It can be done in This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element Now if for at least holds then the answer is Otherwise let s switch useless heaters off Let s iterate over all heaters from left to right Let the current heater have position We need to check if it is useless or not Let s iterate in range and check if there is at least one element in this segment such that If there is then the current heater is not useless and we cannot switch it off Otherwise we can decrease the answer by switch this heater off decrease for all in range and continue the process 
You are given a directed graph of n vertices and m edges Vertices are numbered from 1 to n There is a token in vertex 1 The following actions are allowed Token movement To move the token from vertex u to vertex v if there is an edge u to v in the graph This action takes 1 second Graph transposition To transpose all the edges in the graph replace each edge u to v by an edge v to u This action takes increasingly more time k th transposition takes 2 k 1 seconds i e the first transposition takes 1 second the second one takes 2 seconds the third one takes 4 seconds and so on The goal is to move the token from vertex 1 to vertex n in the shortest possible time Print this time modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nint N,M;\nint dp[MX][2][21];\npi mn[MX][2];\nvi adj[MX][2];\npi bes[MX];\n\nusing T = pair<pi,pi>; // {transpositions, dist} and {vertex, color} ??\n// priority_queue<T,V<T>,greater<T>> pq;\n\n// BFS minimizing dist for transpositions < 21\n// Dijkstra minimizing {transpositions,dist}\n\n// void ad(pi loc, pi dist) {\n// \tif (dist.f < 21) {\n\n// \t} else {\n// \t\tif ()\n// \t}\n// }\n\nvoid bfs() {\n\tFOR(i,1,N+1) F0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\tdeque<T> todo;\n\tauto upd = [&](pi vertColor, pi info) { // OK\n\t\tif (dp[vertColor.f][vertColor.s][info.f] <= info.s) {\n\t\t\treturn 0;\n\t\t}\n\t\tdp[vertColor.f][vertColor.s][info.f] = info.s;\n\t\treturn 1;\n\t};\n\tauto ad_front = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.push_front({info,vertColor});\n\t};\n\tauto ad_back = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.pb({info,vertColor});\n\t};\n\tad_front({1,0},{0,0});\n\twhile (sz(todo)) { // {transpositions,dist}, {vert,color}\n\t\tT t = todo.ft; todo.pop_front();\n\t\tif (t.f.s > dp[t.s.f][t.s.s][t.f.f]) continue;\n\t\t// dbg(""TRANSPOSITIONS"",""DIST"",""VERT"",""COLOR"",t,adj[t.s.f][t.s.s]);\n\t\tif (t.f.f+1 < 21) ad_front({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad_back({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n}\n\npi dist[MX][2];\n\nvoid dijk() {\n\tdbg(""DIJK"");\n\tFOR(i,1,N+1) F0R(j,2) dist[i][j] = {MOD,MOD}; // transpositions dist\n\tpriority_queue<T,V<T>,greater<T>> todo;\n\tauto ad = [&](pi vertColor, pi info) {\n\t\tif (ckmin(dist[vertColor.f][vertColor.s],info)) {\n\t\t\ttodo.push({info,vertColor});\n\t\t}\n\t};\n\tad({1,0},{0,0});\n\twhile (sz(todo)) {\n\t\tauto t = todo.top(); todo.pop();\n\t\tif (t.f > dist[t.s.f][t.s.s]) continue;\n\t\tad({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n\tpi ans = min(dist[N][0],dist[N][1]);\n\tdbg(""HA"",ans);\n\tps(pow(mi(2),ans.f)-1+ans.s);\n\texit(0);\n\t// pi p = {};\n}\n\nint main() {\n\tsetIO(); re(N,M);\n\tF0R(i,M) {\n\t\tint u,v; re(u,v);\n\t\t// dbg(""ED"",u,v);\n\t\tadj[u][0].pb(v);\n\t\tadj[v][1].pb(u);\n\t}\n\tbfs();\n\tint ans = MOD;\n\tF0R(j,2) F0R(k,21) if (dp[N][j][k] != MOD) {\n\t\t// dbg(""HA"",j,k,dp[N][j][k]);\n\t\tckmin(ans,(1<<k)-1+dp[N][j][k]);\n\t}\n\tif (ans != MOD) {\n\t\tps(ans);\n\t\texit(0);\n\t}\n\tdijk();\n\n\t// FOR(i,1,N+1) {\n\t// \tmn[i] = MOD;\n\t// \tbes[i] = {MOD,MOD};\n\t// \tF0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\t// }\n\t// ad({1,0},{0,0});\n\t// F0R(i,21) {\n\n\t// }\n\t// while (1) {\n\t// \tT p = pq.top(); pq.pop();\n\t// \tif (mn[p.s] < p.f.f && p.f.f >= 21) continue;\n\t// \ttrav(t,adj[][]) {\n\n\t// \t}\n\t// }\n\t// FOR(i,1,N+1) F0R(j,21) dp[i][j] = MOD;\n\t// dp[1][0] = 1;\n\t// F0R(mov,21) {\n\n\t// }\n\t// first get min for each vert\n\t// if some are still not reached\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2400,Consider a sequence of actions that moves the token from vertex to vertex Let us say it has token movements and graph transpositions This sequence takes seconds Note that the optimal path does not visit any edge twice That means we need to consider only paths with Consider another sequence consisting of token movements and graph transpositions Let Note the following If then This is true because the difference between and does not exceed and This gives us the following if there is any sequence of actions with that moves the token from vertex to vertex then optimal path s is less than too Let us check this with the following algorithm and if it is so find the optimal sequence of actions We can now build a new graph that consists of copies of the original graph Reverse all the edges in every even graph copy For every vertex add new edge between th and th copies of vertex with weight for We can find optimal paths from the first copy of vertex to all the copies of vertex using Dijkstra algorithm Shortest of these paths would correspond to the answer movement along a copy of original edge denotes token movement movement along a new edge denotes graph transposition If the algorithm found no paths then the sequence of actions that moves the token to from vertex 1 to vertex consists of at least transpositions Note that if then It means that all sequences of actions can be compared using ordered vector lexicographically Let us build another graph consisting of copies of the original graph Reverse all the edges in the second copy of the graph Assign to weights of all of these edges For every vertex add two new edges between copies of from the first to the second copy and back Weights of both edges is Let us find optimal paths from the first copy of vertex to both copies of vertex using Dijkstra algorithm Let be the length of the shortest one New graph allows us to restore the optimal sequence of actions that moves the token from vertex to vertex that will take seconds 
Monocarp is working on his new site and the current challenge is to make the users pick strong passwords Monocarp decided that strong passwords should satisfy the following conditions password should consist only of lowercase Latin letters and digits there should be no digit that comes after a letter so after each letter there is either another letter or the string ends all digits should be sorted in the non decreasing order all letters should be sorted in the non decreasing order Note that it s allowed for the password to have only letters or only digits Monocarp managed to implement the first condition but he struggles with the remaining ones Can you help him to verify the passwords ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n;    std::cin >> n;        std::string s;    std::cin >> s;        if (std::is_sorted(s.begin(), s.end())) {        std::cout << ""YES\\n"";    } else {        std::cout << ""NO\\n"";    }}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",800,There s no real idea in the problem the main difficulty is the implementation Many programming languages have functions to check if a character is a digit or if it s a letter They can be used to check that no digit follows a letter How does the order check work Well most languages allow you to compare characters with inequality signs so we have to check that for all corresponding separately for digits and letters How does that work Inside the language every character is assigned a code That s called an ASCII table It contains digits letters and lots of other characters And the less or equal check uses that table If you look at the table carefully you ll notice that the digits come before the lowercase Latin letters Digits have codes from 48 to 57 and the lowercase letters have codes from 97 to 122 Thus you can ignore the check that the digits come before the letters and just make sure that all characters of the string regardless of their types and sorted in a non decreasing order For example you can sort the string and compare the result with the original string If they are the same then the answer is Alternatively you can use function if your language has it Overall complexity or per testcase 
 Interplanetary Software Inc together with Robots of Cydonia Ltd has developed and released robot cats These electronic pets can meow catch mice and entertain the owner in various ways The developers from Interplanetary Software Inc have recently decided to release a software update for these robots After the update the cats must solve the problems about bracket sequences One of the problems is described below First we need to learn a bit of bracket sequence theory Consider the strings that contain characters and Call a string if it can be transformed to an empty string by one or more operations of removing either single characters or a continuous substring For instance the string is an RBS as it can be transformed to an empty string with the following sequence of removals rightarrow rightarrow rightarrow rightarrow We got an empty string so the initial string was an RBS At the same time the string is not an RBS as it is not possible to apply such removal operations to it An RBS is if this RBS is not empty doesn t start with and doesn t end with Denote the of the string s as its sequential subsegment In particular s l dots r s ls l 1 dots s r where s i is the i th character of the string s Now move on to the problem statement itself You are given a string s initially consisting of characters and You need to answer the queries of the following kind Given two indices l and r 1 le l r le n and it s that the substring s l dots r is a You need to find the number of substrings in s l dots r such that they are simple RBS In other words find the number of index pairs i j such that l le i j le r and s i dots j is a simple RBS You are an employee in Interplanetary Software Inc and you were given the task to teach the cats to solve the problem above after the update ,"['#include <bits/stdc++.h>\n#define rep(i,n) for (i=1;i<=(n);i++)\nusing namespace std;\nint n,m,i,mat[300007];\nmap<int,int> id[300007];\nchar s[300007];\nint dfc,nfd[600007],deg[600007],fa[600007],ord[600007];\nlong long r[600007];\nvoid add(int x,long long v){\n\twhile(x<=600006){\n\t\tr[x]+=v;\n\t\tx+=(x&-x);\n\t}\n}\nlong long qsum(int x){\n\tlong long ans=0;\n\twhile(x){\n\t\tans+=r[x];\n\t\tx&=(x-1);\n\t}\n\treturn ans;\n}\nint solve(int l,int r){\n\tint u=++dfc;\n\tid[l][r]=u;\n\tl++;r--;\n\tif(l>r){\n\t\tnfd[u]=dfc;\n\t\treturn u;\n\t}\n\twhile(l<=r){\n\t\tint son;\n\t\tfa[son=solve(l,mat[l])]=u;\n\t\tl=mat[l]+1;\n\t\tdeg[u]++;\n\t\tord[son]=deg[u];\n\t}\n\tadd(u,1ll*deg[u]*(deg[u]+1)/2);\n\tnfd[u]=dfc;\n\treturn u;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tscanf("" %s"",s+1);\n\tstack<int> c;\n\trep(i,n){\n\t\tif(s[i]==\'(\') c.push(i);\n\t\telse if(!c.empty()){\n\t\t\tmat[c.top()]=i;\n\t\t\tmat[i]=c.top();\n\t\t\tc.pop();\n\t\t}\n\t}\n\tint tt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(mat[i]){\n\t\t\tord[solve(i,mat[i])]=++tt;\n\t\t\ti=mat[i];\n\t\t}\n\t}\n\twhile(m--){\n\t\tint op,l,r;\n\t\tscanf(""%d%d%d"",&op,&l,&r);\n\t\tif(op==2){\n\t\t\tint lid=id[l][mat[l]];\n\t\t\tint rid=id[mat[r]][r];\n\t\t\tprintf(""%lld\\n"",qsum(nfd[rid])-qsum(lid-1)+1ll*(ord[rid]-ord[lid]+1)*(ord[rid]-ord[lid]+2)/2);\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 1, 1, 0, 0, 0, 1]",2500,First we need to make the input string an RBS Consider one of the possible ways to do it First we keep the stack of all the opening brackets We remove the bracket from the stack if we encounter the corresponding closing bracket If there is an unpaired closing bracket or an opening bracket which is not removed they must be replaced with a dot So the input string becomes an RBS It s not hard to see that there are no queries that pass through dots we put in this step Now build a tree from the brackets We will do it in the following way Initially there is one vertex Then if we encounter an opening bracket we go one level below and create a new vertex and if we encounter a closing bracket then we go to the parent It s now clear that each vertex corresponds to an RBS The root of the tree corresponds to the entire string and leaf nodes correspond to empty RBSes Now note that we can obtain all the RBSes if we take all the subsegments from the children of vertices Each subsegment from the children looks like RBS RBS RBS i e it s a concatenation of RBSes that correspond to children where each one is put into brackets Now we can make a simple DP Indeed the amount of all RBSes in a vertex is the sum of RBSes of its children plus where is the number of children The amount of RBSes on the segment is calculated in a similar way When we calculate such DP and can carefully find a vertex in the tree we can answer the queries on the segment The time complexity is or possibly if we manage to find the vertices corresponding to indices fast 
There is a frog staying to the left of the string s s 1 s 2 ldots s n consisting of n characters to be more precise the frog initially stays at the cell 0 Each character of s is either or It means that if the frog is staying at the i th cell and the i th character is the frog can jump only to the left If the frog is staying at the i th cell and the i th character is the frog can jump only to the right The frog wants to reach the n 1 th cell The frog chooses some value d and cannot change it later and jumps by no more than d cells at once I e if the i th character is then the frog can jump to any cell in a range max 0 i d i 1 and if the i th character is then the frog can jump to any cell in a range i 1 min n 1 i d The frog doesn t want to jump far so your task is to find the minimum possible value of d such that the frog can reach the cell n 1 from the cell 0 if it can jump by no more than d cells at once You have to answer t independent test cases ,"[""#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<ll> m;\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n    \tstring s;\n    \tcin >> s;\n    \tvector<int> bad;\n    \tbad.resize(s.size() + 1, 0);\n    \tfor (int j = 0; j < s.size(); j++)\n    \t\tif (s[j] == 'L')\n    \t\t\tbad[j + 1] = bad[j] + 1;\n    \tint ans = 0;\n    \tfor (int j = 0; j < bad.size(); j++)\n    \t\tans = max(ans, bad[j] + 1);\n    \tcout << ans << endl;\n    }\n\n\n\n\n    return 0;\n}""]","[1, 0, 1, 0, 1, 0, 0, 1, 0, 0]",1100,The only observation we need is that we don t need to jump left at all This only decreases our position so we have less freedom after the jump to the left Then to minimize we only need to jump between the closest cells So if we build the array where is the position of the th cell from left to right indexed then the answer is Time complexity 
You are given a binary string s of length 2n where each element is mathtt 0 or mathtt 1 You can do the following operation Choose a balanced bracket sequence dagger b of length 2n For every index i from 1 to 2n in order where b i is an open bracket let p i denote the minimum index such that b i p i is a balanced bracket sequence Then we perform a range toggle operation ddagger from i to p i on s Note that since a balanced bracket sequence of length 2n will have n open brackets we will do n range toggle operations on s Your task is to find a sequence of no more than 10 operations that changes all elements of s to mathtt 0 or determine that it is impossible to do so Note that you do have to minimize the number of operations Under the given constraints it can be proven that if it is possible to change all elements of s to mathtt 0 there exists a way that requires no more than 10 operations dagger A sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters and 1 For example sequences and are balanced while and are not ddagger If we perform a range toggle operation from l to r on a binary string s then we toggle all values of s i such that l leq i leq r If s i is toggled we will set s i mathtt 0 if s i mathtt 1 or vice versa For example if s mathtt 1000101 and we perform a range toggle operation from 3 to 5 s will be changed to s mathtt 1011001 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\nint tab[nax];\n\nvector<string> wyn;\n\nvoid zrob(string s)\n{\n\twyn.push_back(s);\n\tint gl=0;\n\tfor (int i=0; i<2*n; i++)\n\t{\n\t\tif (s[i]==\'(\')\n\t\t{\n\t\t\tgl++;\n\t\t\tif (gl&1)\n\t\t\t\ttab[i+1]^=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (gl&1)\n\t\t\t\ttab[i+1]^=1;\n\t\t\tgl--;\n\t\t}\n\t}\n}\n\nint musz[nax];\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=2*n; i++)\n\t\ttab[i]=(wcz[i]-\'0\');\n\t{\n\t\tint p=0;\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\tp+=tab[i];\n\t\tif ((p&1) || tab[1]!=tab[2*n])\n\t\t{\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn;\n\t\t}\n\t}\n\twyn.clear();\n\t\n\t\n\tfor (int i=1; i<=2*n+7; i++)\n\t\tmusz[i]=0;\n\t\n\tfor (int i=2; i<2*n; i++)\n\t\tif (tab[i]!=musz[i-1])\n\t\t\tmusz[i]=1;\n\t//~ debug() << range(musz+1, musz+1+2*n);\n\t\n\t{\n\t\tstring s;\n\t\ts.push_back(\'(\');\n\t\tfor (int i=2; i<2*n; i+=2)\n\t\t{\n\t\t\tif (musz[i])\n\t\t\t{\n\t\t\t\ts.push_back(\'(\');\n\t\t\t\ts.push_back(\')\');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts.push_back(\')\');\n\t\t\t\ts.push_back(\'(\');\n\t\t\t}\n\t\t}\n\t\ts.push_back(\')\');\n\t\tzrob(s);\n\t\ts="""";\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\ts.push_back(\'(\');\n\t\t\ts.push_back(\')\');\n\t\t}\n\t\tzrob(s);\n\t}\n\t\n\tif (n>1)\n\t{\n\t\tstring s;\n\t\ts.push_back(\'(\');\n\t\ts.push_back(\'(\');\n\t\tfor (int i=3; i<2*n-1; i+=2)\n\t\t{\n\t\t\tif (musz[i])\n\t\t\t{\n\t\t\t\ts.push_back(\'(\');\n\t\t\t\ts.push_back(\')\');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts.push_back(\')\');\n\t\t\t\ts.push_back(\'(\');\n\t\t\t}\n\t\t}\n\t\ts.push_back(\')\');\n\t\ts.push_back(\')\');\n\t\tzrob(s);\n\t}\n\t\n\tif (tab[1])\n\t{\n\t\tstring s;\n\t\ts.push_back(\'(\');\n\t\tfor (int i=1; i<n; i++)\n\t\t{\n\t\t\ts.push_back(\'(\');\n\t\t\ts.push_back(\')\');\n\t\t}\n\t\ts.push_back(\')\');\n\t\tzrob(s);\n\t}\n\t\n\t\n\tfor (int i=1; i<=2*n; i++)\n\t\tassert(!tab[i]);\n\t\n\tprintf(""%d\\n"", (int)wyn.size());\n\tfor (string i : wyn)\n\t{\n\t\tfor (char j : i)\n\t\t\tprintf(""%c"", j);\n\t\tprintf(""\\n"");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 1, 1, 0, 0, 0, 1, 0, 0, 0]",2600,ProofSuppose there are open brackets and close brackets between positions and Note that by definition of balanced bracket sequences Case 1 is an open bracket Position will be toggled exactly times as of the open brackets will be matched before position and the remaining open brackets will only be matched after position This means that position will be toggled only if is odd and hence must be odd as well Case 2 is a close bracket Position will be toggled exactly times as of the open brackets will be matched before of the open bracket will be matched with position and the remaining open brackets will be matched after position This means that position will be toggled only if is even and hence must be even as well 
Moamen was drawing a grid of n rows and 10 9 columns containing only digits 0 and 1 Ezzat noticed what Moamen was drawing and became interested in the minimum number of rows one needs to remove to make the grid beautiful A grid is beautiful if and only if for every two consecutive rows there is at least one column containing 1 in these two rows Ezzat will give you the number of rows n and m segments of the grid that contain digits 1 Every segment is represented with three integers i l and r where i represents the row number and l and r represent the first and the last column of the segment in that row For example if n 3 m 6 and the segments are 1 1 1 1 7 8 2 7 7 2 15 15 3 1 1 3 15 15 then the grid is Your task is to tell Ezzat the minimum number of rows that should be removed to make the grid beautiful ,"['#include<bits/stdc++.h>\n#include <algorithm>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int,int> pr;\n#define mp make_pair\npr op(pr x,pr y){\n\treturn max(x,y);\n}\npr e(){\n\treturn mp(0,0);\n}\nlazy_segtree<pr,op,e,pr,op,op,e> tr(600005);\nint n,m,b[600005],is[600005];\npr f[600005],ans;\nvector<pr> seg[600005];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1,x,l,r;i<=m;i++){\n\t\tscanf(""%d%d%d"",&x,&l,&r),b[++b[0]]=l,b[++b[0]]=r,seg[x].push_back(mp(l,r));\n\t}\n\tsort(b+1,b+b[0]+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(auto &j:seg[i])j.first=lower_bound(b+1,b+b[0]+1,j.first)-b,j.second=lower_bound(b+1,b+b[0]+1,j.second)-b;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=mp(1,0);\n\t\tfor(auto j:seg[i]){\n\t\t\tpr tmp=tr.prod(j.first,j.second+1);\n\t\t\tf[i]=max(f[i],mp(tmp.first+1,tmp.second));\n\t\t}\n\t\tans=max(ans,mp(f[i].first,i));\n\t\tfor(auto j:seg[i])tr.apply(j.first,j.second+1,mp(f[i].first,i));\n\t\t//cout<<i<<\' \'<<f[i].first<<\'\\n\';\n\t}\n\tcout<<n-ans.first<<\'\\n\';\n\tint p=ans.second;\n\twhile(p)is[p]=1,p=f[p].second;\n\tfor(int i=1;i<=n;i++)if(!is[i])cout<<i<<\' \';\n}']","[1, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2200,We can use dynamic programming to get the maximum number of rows that make a beautiful grid Define the 2d array where maximum number of rows from row to row that make a beautiful grid and has in column at the last row I have in the biggest beautiful grid the last row in the biggest beautiful grid is the not necessary to be Form the definition if Otherwise if then where is that set of columns that contain in row As you know the set contains the intervals so we just search in some intervals for the maximum or update some intervals in the previous layer in We can do it faster using Segment tree So the algorithm will be as follows Define an array where the previous row of in which maximum beautiful grid end with th row We will use it to get the rows that will not be removed Build a segment tree of pairs initially with Then for each from to Get the maximum value in all the ranges that contains at the th row Let s call it Store Update all the ranges of this row like this Finally get the rows that have the maximum value using the array and remove the others The total complexity will be or if you make a coordinate compression to the values 
You are given a sequence of one dimensional segments numbered through Your task is to find two distinct indices and such that segment lies within segment Segment lies within segment iff and Print indices and If there are multiple answers print any of them If no answer exists print ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\npii in[300050];\nint u[300050];\n\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tu[i] = i;\n\t\tscanf(""%d %d"", &in[i].first, &in[i].second);\n\t}\n\tsort(u + 1, u + N + 1, [](int a, int b) {\n\t\tif (in[a].first != in[b].first) return in[a].first < in[b].first;\n\t\telse return in[a].second > in[b].second;\n\t});\n\n\tint mxp = u[1];\n\tfor (i = 2; i <= N; i++) {\n\t\tif (in[u[i]].second <= in[mxp].second) return !printf(""%d %d\\n"", u[i], mxp);\n\t\telse mxp = u[i];\n\t}\n\treturn !printf(""-1 -1\\n"");\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 1, 0]",1500,Let s sort segments firstly by their left border in increasing order and in case of equal by their right border in decreasing order If there is any valid pair then the inner segment will always go after the outer one Now you can go from left to right keep the maximum right border of processed segments and compare it to the current segment Overall complexity 
You are given an array a of n elements You can apply the following operation to it any number of times Select some subarray from a of even size 2k that begins at position l 1 le l le l 2 cdot k 1 le n k ge 1 and for each i between 0 and k 1 inclusive assign the value a l k i to a l i For example if a 2 1 3 4 5 3 then choose l 1 and k 2 applying this operation the array will become a 3 4 3 4 5 3 Find the minimum number of operations possibly zero needed to make all the elements of the array equal ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_n = 2e5 + 5;\n\nint a[max_n];\n\nvoid solve_tc(){\n\tint n; \n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tint operations = 0;\n\twhile (1){\n\t\tint similar_suffix = 0;\n\t\tfor (int i = n; i >= 1; i--){\n\t\t\tif (a[i] != a[n]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsimilar_suffix = n - i + 1;\n\t\t}\n\t\tif (similar_suffix == n){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = max(1, n - 2 * similar_suffix + 1); i <= n; i++){\n\t\t\ta[i] = a[n];\n\t\t}\n\t\toperations++;\n\t}\n\t\n\tcout << operations << ""\\n"";\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint tests;\n\tcin >> tests;\n\twhile (tests--){\n\t\tsolve_tc();\n\t}\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1100,SolutionFor simplicity let let be reversed The operation transforms to select a subarray of length so then for all such that set can not be changed with the given operation That reduces the problem to make all elements equal to Let be the rightmost index such that for all holds The problem will be solved when If an operation is applied with will not change and will remain the same The largest range with is applying an operation to it will lead to so will become at least and there is not any other range that will lead to a bigger value of If it is possible to apply the operation on after applying it and all elements will become equal The problem can now be solved by repeatedly finding and applying the operation on or on if Since will become at least in each operation but the last one the naive implementation will take however it is easy to implement it in Code O nlogn Code O n 
Everyone knows that DNA strands consist of nucleotides There are four types of nucleotides A DNA strand is a sequence of nucleotides Scientists decided to track evolution of a rare species which DNA strand was string initially Evolution of the species is described as a sequence of changes in the DNA Every change is a change of some nucleotide for example the following change can happen in DNA strand the second nucleotide can change to so that the resulting DNA strand is Scientists know that some segments of the DNA strand can be affected by some unknown infections They can represent an infection as a sequence of nucleotides Scientists are interested if there are any changes caused by some infections Thus they sometimes want to know the value of impact of some infection to some segment of the DNA This value is computed as follows Let the infection be represented as a string and let scientists be interested in DNA strand segment starting from position to position inclusive Prefix of the string i e the string that consists of infinitely many repeats of string is written under the string from position to position inclusive The value of impact is the number of positions where letter of string coincided with the letter written under it Being a developer Innokenty is interested in bioinformatics also so the scientists asked him for help Innokenty is busy preparing VK Cup so he decided to delegate the problem to the competitors Help the scientists ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct fenw{\n  VI fw;\n  in n;\n  void ini(in pn){\n    n=pn;\n    fw.clear();\n    fw.resize(n,0);\n  }\n  void ad(in l, in x){\n    while(l<n){\n      fw[l]+=x;\n      l|=(l+1);\n    }\n  }\n  in sm(in l){\n    in r=0;\n    while(l>=0){\n      r+=fw[l];\n      l&=(l+1);\n      --l;\n    }\n    return r;\n  }\n};\nmap<char,in> dcd;\nconst in mx=1e5+9;\nvector<vector<vector<fenw> > > fw; // fw[a][b][c] has 1 at i if letter a is at i*b+c\nvoid adt(in l, in typ, in f){\n  for(in lt=1;lt<=10;++lt){\n    fw[typ][lt][l%lt].ad(l/lt,f);\n  }\n}\nstring s;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  dcd[\'A\']=0;\n  dcd[\'C\']=1;\n  dcd[\'G\']=2;\n  dcd[\'T\']=3;\n  fw.resize(4);\n  forn(i,4){\n    fw[i].resize(11);\n    for(in j=1;j<=10;++j){\n      fw[i][j].resize(j);\n      forn(k,j){\n\tfw[i][j][k].ini(mx/j+9);\n      }\n    }\n  }\n  cin>>s;\n  forv(i,s){\n    adt(i,dcd[s[i]],1);\n  }\n  in q;\n  cin>>q;\n  in typ,x,l,r;\n  char c;\n  string e;\n  in sm;\n  in lt;\n  in loc;\n  forn(z,q){\n    cin>>typ;\n    if(typ==1){\n      cin>>x>>c;\n      --x;\n      adt(x,dcd[s[x]],-1);\n      s[x]=c;\n      adt(x,dcd[s[x]],1);\n    }\n    else{\n      cin>>l>>r>>e;\n      --l;\n      --r;\n      sm=0;\n      lt=sz(e);\n      forv(i,e){\n\tloc=(l+i)%lt;\n\tif(r-loc>=0)\n\t  sm+=fw[dcd[e[i]]][lt][loc].sm((r-loc)/lt);\n\tif(l-1-loc>=0)\n\t  sm-=fw[dcd[e[i]]][lt][loc].sm((l-1-loc)/lt);\n      }\n      cout<<sm<<""\\n"";\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2100,Note that there are only different characters and queries lengths are only up to How does this help Let s make arrays of length for each of the possible letters putting where the letter in is that letter and otherwise We can update these arrays easily with update queries Consider a letter in a query string It appears equidistantly in the string we write down under the string Thus we should count the number of ones in one of our four arrays at positions which indices form an arithmetic progression and bounded by some segment the query segment This sounds hard but we can note that the difference between the indices i e the common difference of the arithmetic progression is not larger than Thus we can store copies of each of four arrays we created above For the th copy of some letter we reorder the elements so that first we put all positions for which then all positions for which and so on This will make possible to change each query on an arithmetic progression to a sum query on a segment Thus we can just sum up answers for each letter in string 
Giga Tower is the tallest and deepest building in Cyberland There are floors numbered from to In particular there is floor between floor and floor Every day thousands of tourists come to this place to enjoy the wonderful view In Cyberland it is believed that the number 8 is a lucky number that s why Giga Tower has floors above the ground and an integer is if and only if its decimal notation contains at least one digit 8 For example are all while are not In the Giga Tower if you write code at a floor with lucky floor number good luck will always be with you Well this round is 278 also lucky huh Tourist Henry goes to the tower to seek good luck Now he is at the floor numbered He wants to find the minimum integer such that if he walks floors higher he will arrive at a floor with a number ,"['#define _CRT_SECURE_NO_WARNINGS\n#if 1\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst LD eps = 1e-9;\nconst LD pi = acos(-1.0);\nconst LL inf = 1e+9;\n\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n\n#define dbg(x) { cerr << #x << "" = "" << x << endl; }\n\n// extended template\n#pragma comment(linker, ""/STACK:36777216"")\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\ntemplate<typename T> istream & operator >> (istream &, vector<T> &);\ntemplate<typename T> ostream & operator << (ostream &, const vector<T> &);\n\n#define START clock_t _clock = clock();\n#define END cerr << endl << ""time: "" << (clock() - _clock) / LD(CLOCKS_PER_SEC) << endl;\n\n#define NAME ""problem""\n\nbool check(int x){\n    while (x){\n        if (abs(x % 10) == 8) return true;\n        x /= 10;\n    }\n    return false;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int res = 1;\n    while (!check(n + res)){\n        res++;\n    }\n    cout << res << endl;\n}\n\nint main()\n{\n    // freopen(NAME "".in"", ""r"", stdin); freopen(NAME "".out"", ""w"", stdout);\n    // freopen(""input.txt"", ""r"", stdin); // freopen(""output.txt"", ""w"", stdout);\n\n    solve();\n\n    return 0;\n}\n/*******************************************\n*******************************************/\n\ntemplate<typename T> istream & operator >> (istream &is, vector<T> &v)\n{\n    forn(i, v.size())\n        is >> v[i];\n    return is;\n}\ntemplate<typename T> ostream & operator << (ostream &os, const vector<T> &v)\n{\n    forn(i, v.size())\n        os << v[i] << "" "";\n    return os;\n}\n#endif']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1100,The answer is very small usually no larger than because one of has its last digit be However can exceed when is negative and close to The worst case is where Anyway is rather small so we can simply try from and check whether has a digit 8 
There is a rectangular grid of size n times m Each cell of the grid is colored black or white The color of the cell i j is c i j You are also given a map of directions for each cell there is a direction s i j which is one of the four characters and If s i j is then there is a transition from the cell i j to the cell i 1 j if s i j is then there is a transition from the cell i j to the cell i j 1 if s i j is then there is a transition from the cell i j to the cell i 1 j if s i j is then there is a transition from the cell i j to the cell i j 1 It is guaranteed that the top row doesn t contain characters the bottom row doesn t contain characters the leftmost column doesn t contain characters and the rightmost column doesn t contain characters You want to place some robots in this field at most one robot in a cell The following conditions should be satisfied Firstly each robot every time i e it cannot skip the move Secondly you have to place robots in such a way that before which two different robots occupy the same cell it also means that you cannot place two robots in the same cell I e if the grid is one row two columns colors does not matter there then you can place two robots in cells 1 1 and 1 2 but if the grid is then you cannot place robots in cells 1 1 and 1 3 because during the first second both robots will occupy the cell 1 2 The robots make an infinite number of moves Your task is to place the maximum number of robots to satisfy all the conditions described above and among all such ways you have to choose one where the number of cells occupied by robots is the maximum possible You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false),cin.tie(NULL)\n#define fi first\n#define se second\n#define  all(d) d.begin(),d.end()\n#define allr(d) d.rbegin(),d.rend()\n#define For(i,d,c) for(int i = d;i <= c;++i)\nstd::mt19937 rgn(std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace io\n{\n\ttemplate<typename T> inline void read(T&a){\n\t\tint c = getchar(),sign = 0;\n\t\ta = 0;\n\t\twhile(c < \'0\' || c >\'9\') sign += (c == \'-\'),c = getchar();\n\t\twhile (c >=\'0\' && c <=\'9\') a = (a << 1) + (a << 3) + c-48,c = getchar();\n\t\tif (sign&1) a = -a;\n\t}\n\ttemplate<typename T,typename... _T>\n\tinline void read(T&a,_T& ...argc)\n\t{\n\t\tread(a);read(argc...);\n\t}\n\ttemplate<typename T>\n\tinline void Write(T a)\n\t{\n\t\tif (a > 9) Write(a/10);\n\t\tputchar(a % 10 + \'0\');\n\t}\n\ttemplate<typename T>\n\tinline void write(T a,char ch = \' \')\n\t{\n\t\tif (a < 0) putchar(\'-\'),a = -a;\n\t\tWrite(a);\n\t\tputchar(ch);\n\t}\n\ttemplate<typename T> inline void Min(T&a,T b){if (a > b) a = b;}\n\ttemplate<typename T> inline void Max(T&a,T b){if (a < b) a = b;}\n\ttemplate<typename T,typename... _T> inline void Min(T&a,T b,_T ...c){Min(a,b);Min(a,c...);}\n\ttemplate<typename T,typename... _T> inline void Max(T&a,T b,_T ...c){Max(a,b);Max(a,c...);}\n}\nusing namespace io;\nconst int maxn= 1e6 + 3;\nconst int N = 4e5 + 3;\nconst int mod= 1e9 + 7 ;\nint n,m,q;\nint dem[N],id[N],chot[N],a[N],b[N];\nint k,h;\nll t[N + 3];\nstring  s;\nbool kt[N];\nmap<long long,int> maps;\nvector<int> edge[N];\nmap<int,int> ::iterator it;\ntemplate<typename T>\nvoid answer(T x) {cout << x;exit(0);}\nvoid putstring(string x,char ch = \' \') {for (char c:x) putchar(c);putchar(ch);}\n\nint dx[] = {-1,0,1,0},dy[] = {0,1,0,-1};\nchar c[] = {\'U\',\'R\',\'D\',\'L\'};\n\nstruct dsu {\n\tvector<int> chot;\n\tint n;\n\tdsu(int n) : n(n) {\n\t\tchot.resize(n,-1);\n\t}\n\tint find(int u) {\n\t\treturn chot[u] < 0 ? u : chot[u] = find(chot[u]);\n\t}\n\tvoid combine(int u,int v) {\n\t\tu = find(u);v = find(v);\n\t\tif (u != v) {\n\t\t\tif (-chot[u] < -chot[v]) swap(u,v);\n\t\t\tchot[u] += chot[v];\n\t\t\tchot[v] = u;\n\t\t}\n\t}\n};\n\nint main() {\n\tIOS;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> n >> m;\n\t\tauto con = [&](int i,int j) {\n\t\t\treturn i * m + j;\n\t\t};\n\t\tvector<int> nxt(n*m);\n\t\tvector<bool> kt(n * m);\n\t\tfor (int i = 0;i < n;i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0;j < m;j++) kt[con(i,j)] = (s[j] == \'0\' ? true : false);\n\t\t}\n\t\tfor (int i = 0;i < n;i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0;j < m;j++) {\n\t\t\t\tfor (int pos = 0;pos < 4;pos++) {\n\t\t\t\t\tif (s[j] == c[pos]) {\n\t\t\t\t\t\tint x = i + dx[pos];\n\t\t\t\t\t\tint y = j + dy[pos];\n\t\t\t\t\t\tnxt[con(i,j)] = (con(x,y));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0,black = 0;\n\t\tvector<int> vis(n * m);\n\t\tvector<vector<int>> time(n * m);\n\t\tvector<int> P(n * m);\n\t\tvector<int> d(n * m);\n\t\tvector<vector<int>> cycle;\n\t\tfor (int i = 0;i < n * m;i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tint u = i;\n\t\t\t\tstack<int> s;\n\t\t\t\twhile (1) {\n\t\t\t\t\ts.emplace(u);\n\t\t\t\t\tif (vis[u] == 1) {\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\tcycle.emplace_back(vector<int>());\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tint v = s.top();s.pop();\n\t\t\t\t\t\t\tcycle.back().emplace_back(v);\n\t\t\t\t\t\t\t++ans;\n\t\t\t\t\t\t\tif (kt[v]) time[v].emplace_back(0);\n\t\t\t\t\t\t\tvis[v] = 2;\n\t\t\t\t\t\t\tP[v] = v;\n\t\t\t\t\t\t\td[v] = 0;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (vis[u] == 2) break;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tu = nxt[u];\n\t\t\t\t}\n\t\t\t\tif (s.empty()) continue;\n\t\t\t\tint root = s.top();\n\t\t\t\twhile ((int)s.size()) {\n\t\t\t\t\tint v = s.top();s.pop();\n\t\t\t\t\tvis[v] = 2;\n\t\t\t\t\tP[v] = P[nxt[root]];\n\t\t\t\t\td[v] = d[nxt[v]] + 1;\n\t\t\t\t\tif (kt[v]) time[P[v]].emplace_back(d[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i < (int)cycle.size();i++) {\n\t\t\tset<int> s;\n\t\t\tint count = 0;\n\t\t\tfor (auto&x : cycle[i]) {\n\t\t\t\tfor (auto&u : time[x]) {\n\t\t\t\t\ts.insert((u + count) % (int)cycle[i].size());\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tblack += (int)s.size();\n\t\t}\n\t\tcout << ans <<"" "" << black <<""\\n"";\n\t}\n}\n\n/*********************************************************************************************************************************************************************************************************\n *ti;.                               .:,:i:          .:,;itt;:      GLDEEGEEEEEEEEEEEEEEEEEEDEEEEEEEEEEE#W#WEKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKKKKKKG.     .::.      f:,...,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:            :,;;iti,    :fDDEEEEEEEEEEEEEEEKEEEEDEEEEEEEEEEEW##WEEEKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWWKKKKKKEG     .::.       .f,::,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:             .,,;iti;.  LDDEEEEEEEEEEKEEEEWEEEDDEEEEEEEEEEE#WWWEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWKKKKKEDj    .::.        .:L;;ijfGDDDDDDDDDEEEEE *\n *ti;.                               .:,:i:              .:,;;iii:LLDEEEEEEEEEEEKEEEEEEEEDEEEEEEEEEEEW#WWEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWKWWWWWWWWWWWWWWKKKKKKKEL    .::.         .:;LijLGGDDDDDDDDEEEEE *\n *ti;.                               .:,:;:                :,;;ittfDEEEEEEEEEEEEEEEEKEEEGEEEEEEEEEEEKWWWEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWKKKKKKKELj   .::.          :,;jffGGDDDDDDDDDEEEE *\n *ti;.                               .:,:i:                 .,;;tGGDEEEEEEEEEEEKEEEKEEEDEEEEEEEEEEEEWWWEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWKWWWWWWKKKKKKKEEL   .::.          .:;itDGGDDDDDDDDDEEEE *\n *ti;.                               .:::;:                   :;ifDEEEEEEEEEEEEKEEEKEEEEEEEEEEEEEEEWWWEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WWWKKKKKKKKEEf   .::.           :,itfGEDDDDDDDDDDDEE *\n *ti;.                               .:::;:                    :GGEEEEEEEEEEEKEKEEKEEEEEEEEEEEEEEEEWWEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKKEEDG  .::.           .,;jfLGKDLDDDDDDEEDD *\n *ti;.                               .:::;:                     fDEEEEEEKKKKKKKKKEKEEEEEEEEEEEEEEE#WEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#KKKKKKKKKKEEf .:::.           .,;tfLGDEDDDDDDDDEEE *\n *ti;.                                :::;:                    fDEEEEEEKKKKKKKKKKWKEEEEEEEEEEEEEEEWKEEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKKKEEft :::.           .,;tfLGDDDKDDDDDDDDD *\n *ti;.                                .::;:                    fDEEEEEEKKKKKKKWKKKKKEEEEEEEEEEEEE#WEEWEEEEEDEEDEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKEEGG :,:.           .,;tfLGGDDDKDDDDDDDD *\n *ti;.                                .:.;:                   tGDEEEEKKKKKKKKKKKKKKKKKEEEEEEEEEEEWEEKWEEEEEEEDEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKKKKKEEDf :::.           .,;tfLGGDDDDEDDDDDDD *\n *ti;.                                .::;:                   fDEEEEEKKKKKKKKKKKWKKKKKKKKEEEEEEEWWEEWEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKEEEft.::.           .,;tfLGGDDDDDDEDDDDD *\n *ti;.                                .:.;:                  tGDEEEKKKKKKKKKKKKKKKKKKKKKKEKEEEEE#EEWWEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKEEEGD:::.           .,;tfLGGDDDDDDDEDDDD *\n *ti;.                                .:.,.                  LDEEEEKKKKKKKKKKWKWKKKKKKKKKKKKEEEKWEKW#EEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKW##KKKKKKEEEEf,,:.           .,;tfLGGDDDDDDDDEDDD *\n *ti;.                               ..:.,.                 LGDEEEEKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEEW#WEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKK##KKKKKEEEEEfi;,.           .,;tfLGGDDDDDDDDDKDD *\n *tt;.                                .:.,:                 jDEEEEKKKKKKKKKKWWKKKKKKKKKKKKKKKKKWKE#WWEEEEEEEEEEEEEEWEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKWWKKKKEEEEDfG;,:           .,;tfLGGDDDDDDDDDDKD *\n *tii,.                               .:.,.                tGDEEEEKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKKWWWKEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKW#KKKKEEEEDGGi;,.          .,;tfLGGDDDDDDDDDDDE *\n *ti;;,:.                             .:.,:                fDEEEEKKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEK#WWKEEEEEEEEEEEEDEEEEEEEEEEEEEEGEEEEEEEEEEEEEEEEEEEKKKKKKKWWKKEEEEEEDDf;;;,.         .,;tfLGGDDDDDDDDDDDD *\n *tii;,,:..                           ...,.               ;LEEEEEKKKKKKWKKKKWKKKKKKKKKKKKKKKKKEKKW#WEEEEEEEEEEEEEjEEEEEEEEEKEEEEGEEEEEEEEEKEEEEEEEEEEEEEEEEE#WKEEEEEEDDf;;;;,:        .,itfLGGDDDDDDDDDDDD *\n *ti;,,,,,:.                          ...,.               LDEEEEKKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKK#W#WEEEEEEEEEEEDDLEEEEEEEEEWEEEEDEEEEEEEEEKEEEEEEEEEEEEEEEEEWWEEEEEEEDDfj,,,,,:.      .,itfGGGDDDDDDDDDDDD *\n *tii,,,,::::.                        ...,:              .fDEEEEKKKKKKWKKKKWWWKKKKKKKKKKKKKKKEKKW#WWEEEEEEEEEEEKiKEEKEEEEEEWEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEEWWEEEEEEEDDLD:::,,,:.     .,ijfGGGDDDDDDDDDDDD *\n *ti;:::::::::..                      .:.,:              LDEEEEKKKKKKKWKKKKWWKKKKKKKKKKKKKKKKtKKWWWWKEEEEEEEEEDiiDEEEEEEEEWWEEEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEWKEEEEEDDDGL:. .:,,,:    .,ijLGGGDDDDDDDDDDDD *\n *tt;. .::::::::..                    ...,:             :fDEEEKKKKKKKKKKKKWW#KKKKKKKKKKKKKKKKfKKWWWWKEEEEEEEEDti,DEKEEEEEEWWEEEDEEEEEEEEEKEEEEEEEEEEEEEDEEEEE#WEEEEEGGDGf:.  .:,;,:.  .,ijLGGDDDDDDDDDDDDD *\n *tt;.   .:::::::..                   ...,:             GDEEEKKKKKKKKWKKKKWWWKKKWKKKKKKKWWWKDEKLWWWWKKEEEEEEDEi,LDEEEEEEEEWWEEEEEEEEEEEEEEEEEEEEEEEEEDEDEEEEEW#EEEEDDDDGf,.    :,,,:...,ijLGGGDDDDDDDDDDDD *\n *tt;.    .....::::..                 ...,:             fDEEEKKKKKKKKWKKKKWWWWKKKWKKKKKKKKKKfWKiWWW#KKEEEEEEEi;.EDfEEEDEEiWWEEEEEEEEEEEEDGKEEEEEEEEEEDEEEEEEEWWEEEEDDDGGLi.     .,;,:::,ijLGGGDDDDDDDDDDDD *\n *tt;.      ....:::::.                ...,.            iDEEEEKKKKKKKKWKKWKWWWWWKKWWWKKKKKKKKtWKt#WWWKKEEEEEDji..DDKDDEDEGiWKEEEEEEEEEEDDEjEEEEEEEEEEEDEEEEEEEKWKEEDDDDGGff.      .:,;,,;ijLGGGDDDDDDDDDDDD *\n *tt;.        ....::::..              .:.,:           .LDEEEKKKKKKKKKKKKWWWWKWWWWWWWWWWKKKKWtKKiDWWWKKKEEEEKi:..DEDDDDDDiiWKEEEEEEEEEEDDEijDEEEEEKEEEEEEEEEEEEWWEEGDDDGGLG.       .:,;;iijLGGGDDDDDDDDDDDD *\n *tt;.          .....:::..            ...,.           .fEEEEKKKKKKKKWKKKKWWWWWWWWWWWWWWKWKKKiKDiLWWWWKEEEEEi,..fD:DDDDDti;WEEEEEEEEEEKDDi:iDDEEEEWEEEEEEEEEEEE#WEEGDDDDGGG.         :,iitjLGGGDDDDDDDDDDDD *\n *tti.            .....:::..          ...,.           GDEEEKKKKKKKKKWKKKWWW#WWWWWWWWWWWKWKKjiEjitWWWKKWEEEDi...DDLDDDDji;;WEEEEEEEEEEEDEj.iDDEEEEWEEEEEEEEEEEEWWEEDDDDDDGf.          .,;tjfLGGDDDDDDDDDDDD *\n *tti.              ....::::..        ...,.           fEEEKKKKKKKKKKKKKKKW#WWWWWWWWWWWWWWWWtiEiiiWWWKKEWKEi....D.EDDDEi;.fWEEEEEEEEEEDDfL.;EDDEEEWEEEEEEEEEEEEWWEEEDDDDDGf.           :;ijfLGGDDDDDDDDDDDD *\n *tti.                ....::::..      ...,.          LDEEEKKKKKKKKKKKKKKWWWWWWWWWWWWWWWW####WKiiiWWWKKKEEK,...:E:DDDEii..GWEEEEEEEEDWDDiL.,KDDEEEWEEEEEEEEEEEEWWKEEDDDDDGf:           .,itfLGGDDDDDDDDDDDD *\n *tti.                 .....:::..     ...,.          fDEEEKKKKKKKKKWKKKKWWWWWWWWWWWWW########WLiiWWWKKKEEjD...G,DDDDi;...EWEEEEEEEEDKDEii..LDDEEEWEEEEEEEEEEEEWWWEEDDDDDGfi           .,;tfLGGGDDDDDDDDDDD *\n *tti.                   .....:::..   ...,.         iGEEEKKKKKKKKKKWKKKKWWWWWWWWWWWW###########KiWWWKKEEE,.D..D.DDDii:...KKEEEEEEEEEDDj:...tEDEEEWEEEEEEEEEEEEWWWEEEDDDDDLL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                     ....::::......:.         LEEEKKKKKKKKKKWWKKKWWW#KWWWWWWWW#####W####W##KWWKKEEL..:D.jjDDi;,....KKEEEEEEEDfDDi...:iKDEEEWKEEEEEEEEEEEWWWEEEEDDDDLG           .,;tjLLGGDDDDDDDDDDD *\n *tti.                        ...::::::..,.        :GEEEKKKKKKKKKKKKWWWWW##WWWWWWWWW##WKWK#W#W####WWKEEK.....G.DDti,.....KKEEEEEEDWGDf.,...iKDEEEWWEEEEEEEEEEEW#WEEEEEDDDGL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                         ....::::::,.        GDEEKKKKKKKKKKKKKWWWW###WWWWWWWWWW#WWWK###W#####WKEKK.....jDDL;;......KKEEEEEEEEEDi.f...;KDEEEWWEEEEEEEEEEEWWWWEEEEEDDGf           .,;tjLLGGDDDDDDDDDDD *\n *tti.                           ....:::,,.       .LEEEKKKKKWKKKKKWWWWWW###WWWWWWWWWW#WWKW#WW##W#WWWKEKD:....:DD:;......;KEEEEEEEKiDD..f...,KKEEEWWEEEEEEEEEEEWWWWEEEEEDDDf           .:;tjLLGGGDDDDDDDDDD *\n *tti.                             ...::,,,:.     GDEEKKKKKKKKKKKKWWWWWWW#WWWWWWWWWWW#KjKWWWWWWWWWWWWEK.j,..;fD.;.......fKEEEEEDKG:Di..,....DKEEEWWEEEEEEKEKKKWWWWEEEEEEDDf           .:;tjLLGGDDDDDDDDDDD *\n *jti.                              ...::,,,,:.  .fEEEKKKKKWKKKKKKWWWWWWW#WWWWWWWWWWK#KKKWWWWWWWWWWWWWK..f:.:G.,:.......EKEEEEEKK;:E:.......fKEEEWWKEKEKKKKKKKW#WWEEEEEEDDf:          .,;tfLLGGDDDDDDDDDDD *\n *tti.                               ...:,,,;;,: iDEEKKKKKWKKKKKKKWWWWWWW#WWWWWWWWWWK#WDKWWKKWWWWWWWWWE..;G:G..,........KKEEEEEKi.Gi..:.....tKEEKWWWKKKKKKKKKKW##WKEEEEEEDfi          .,;tfLLGGGDDDDDDDDDD *\n *tti.                               ....::,,;;;,LEEKKKKKKWKKKKKWWWWWWW###WWWWWWWWWWKWWDKWEEEWKKWWWWWKKj.:LG..;.........EKEEEEKG;.G...;.....;KKEKWWWKKKKKKKKKKW##WWKEEEEEDfL          .,;tfLGGGDDDDDDDDDDD *\n *jti.                                ...::::,;ijDEEKKKKKWKKKKKKWKWWWWW##WWWWWWWWWWWKK#KKGDGDWEEWKKWKKGE,.i;.:.........:EKEEEKE;.:L...j.....,KWEKWWWKKKKKKKKKK####WKKEEEEDLG          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:...,,;GEEKKKKKWWKKKKKWWWWWWWW###WWWWWWWWWKKKWWKiLGGEDEDEKGKKiEG..;...........jKEEEKK;:.G....,.....:KKEWWWWKKKKKKKWKK####WKKKKEEEGL          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:.  .:,GEEKKKKKWKKKKKWWWWWWWW####WWWWWWWWWKKKWWKii;fDLGDK: EEi:E:.............EKEEKK;;..L...........KKKWWWWKKKKKKKWKK####WKKKWKEEDf          .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    ,EEKKKKKWWKKKKKWWWWWWWWW###WWWWWWWWKKKKfWWLt;i,. fi  EG..D:.............EKEKK;;..t....:.......KWKWWWWKKKKKKKWKK####WKKKWEEEDf:.        .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEEKKKKKWKKKKKWWWWWWWWW####WWWWWWWKKKKKt;KKEfff     .;t.................KKKKi;:..GtGGfG.......KWWWWWWKKKKKKKWKK###WWWKKKKEEEf,,:       .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEKKKKKWWKKKKKWWWWWWWWWW##WWWWWWWKKKKKKt;EiKKKK,   ...t................jEKKG;;..,.....,LGi....KWWWWWWKKKKKKWKKKW####WKKKKKEEL,,,:.     .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  .GEEKKKKKWKKKKKWWWWWWWWWW###WWWWWWWKKKKKKtiE::tGG........................EEEj;;...,.........:D..DKWWWWWWKKKKK#KKW###W#WKKKKKEEfj:,,,:.   .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.   DEKKKKKWWKKKKKWWWWWWWWW####WWWWWWWKKKKKKiiE:::.::.......................EEi;;...j.....f......:iDKWWWWWWKKKKK#WW######WKKKKKEELG :,,,,:. .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  fEEKKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKK;tE::..........................DD;.;,.::......;........EWWWWWWWKKKKW#WW#####WWKKKWKKELG  .:,,,:::,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. .DEKEKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKE,iD::..........................D..,;.,;tLffi...........DWDWWWW#KKKWWWWW#####W#KKKWKEEGL    .:,;,,,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. ;EEKKKKWWKKKKKWWWWWW#WWWW####WWWWWWKKKKKEL:iD:..........................j ..;..;;:.....i,........DKtWWWWWKKWWWWWW#####WWWKKKEKEDf     .:,;;;itfGGGDDDDDDDDDDDD *\n *jti.                                ...:. DEKKKKKWWKKKKWWWWWWW#WWWW####WWWWWWKKKKKEj:iG...............................:....................GKiWWWWWKKWW#WWW######WWKKKKKEEf       .,;iitfGGGDDDDDDDDDDDD *\n *jti.                                ...:.:EKKKKKWWKKKKKWWWWWWW#WWW#####WWWWWKWKKKKEi:if:.................................iEKEKKKKKKDj......DKiWWWWWKWK##WW#######WWKKK:KEEL        .:;itfGGGDDDDDDDDDDDD *\n *jji.                                ...:,DEEKKKWWWKWKKWWWWWWWWWWWW#####WWWWWWWKKKKEi:it..................................j.  KKKKKKKKKKKf..DKiWWWWWKWW##WW#######WWKKK,KEEf         .,;tfGGGDDDDDDDDDDDD *\n *jji.                                ..L:iDEEKKKWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKKi.i;..................................  . KKKWWWWWWWWK..DGiWWWWWKK##WWW#####W#WWKKKjEKEL,        .:;tfGGGDDDDDDDDDDDD *\n *jji.                               .f:::EEEKKKWWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKK;.i,.................................::  KKEKWWWWWWfWK..EiiWWWWWKWW#WW##########KKKD,KELj        .:;tfGGDDDDDDDDDDDDD *\n *jji.                             .t::::,DEEKKKWWKKKKWWWWWWWWW#WWWW#####WWWWKKWKKKEK;.i:.................................GDDEEEKKKWWWWWtWWD.E;iWWWWWW###WW#########WWKKK.EEDG        .:;tfGGGDDDDDDDDDDDD *\n *jji.                          . j..::::EKEKKKWWWKKKKWWWWWWWWW#WWW######WWWWKKWKKKEK;.t:.................................ELLEDDEEEWWWWEtWK,.KiiWWWWWW###W##########WWKKK:EEEG     .;tjfLLGDDDDDDDDDDDDDDD *\n *jji.                          i.::::::,EEEKKWWWKKKKKWWWWWWWWW#WWW#####WWWWWKWKKKKEE,.t..................................DfiEGDDDEEKKKttKWG.KiiWWWWW##WWW##########WWKKK:fEEL  ,fGGGDDDDDDDDEEEDDDDDDDDDD *\n *jji.                        .;:..:::::DEEEKKWWWKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKED,.t..................................ifjDDGGEGDKK.ttKKE.DiWWWWW###WW##########WWWKKK:.KELiLGGGGDDDDDDDDDDDDEEEDDDDDDD *\n *jji.                       i.:.::::::,KEEKKWWWKKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKEL:.j..................................GGf,;ifLLED .iiKKi:fWWWWWW##W#W##########WWWKKK:.KKLGGDDDDDDDDDDDDDDDDEDDEEDDDDD *\n *jji.                     .j:.::::::::EEEKKKWWWKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKf:.f..................................:EEfftf .,. ;iE,..jWWWWWWW###W############WWKKK,:KKGDDDDDDDDDDDDDDDDDDDDDDDEDDDD *\n *jji.                    .:.::::::::,,EEEKKWWWKKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKt..G....................................EEELL;   .j....tKWWWWWWW################WWWKKtfGKGEDDDDDDDDDDDDDDDDDDDDDDDEEDD *\n *jji.                   :...:::::::,,jEEKKWWWWKKKKKKWWWWWWWWW##KWW#####KWWWWWWKKKKEi..D....................................:jEEE.........;KKWWWWWWWW#WW##W##########WWKKDLGKEKDDDDDDDDDDDDDDDDDDDDDDDDDED *\n *jji.                  i:.::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWW##WWW#####WWWWWWWKKKKKi..D......................................:::::......,KKKWWWWWWWWW#####W########WWWKKKGGKKEGGGGGGGGDDDDDDDDDDDDDDDDDDE *\n *jji.                 i..:::::::::,,tEEKKWWWWKKKKKWWWWWWWWWWW##WW######WWWWWWWKKKKKi..D......................................::::......:EKKKWWWWWWWWWWW##WW########W#WKKWGGKKGGGGGGGGGGGGGGGDDDDDDDDDDDDD *\n *jji.                .:::::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWWW##WW#####WWWWWWWWKKKKKi..D....................................:::::::::..tELii;KWWWWWWWWWW##WW######WWWWWWKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGDG *\n *jjt.                :.::::::::,,,,fEEKKWWWWKKKKKKWWWWWWWWWW###WW####WWWWWWW#WKKKKKi..D....................................:::::::.:.,;;;;;;,KKWWWWWWWWW#WW########WWWKKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *jji.               ;.::::::::,,,,;EEEKWWWWWKKKKKWWWWWWWWWWWW##WW###WKWWWWWK#WKKKKKi..G......................................:::::::,;;;;:...KKKWWWWWWWWWKWW#######WWWWKKGLGKDGGGGGGLLGGGGGGGGGGGGGGGGGGG *\n *jjt.              f.:::::::::,,,,fEEKKWWWWWKKKKKWWWWWWWWWWW###WW##WKKWWWWWW#WKKKKK;.jt........i.............................:::::::;j;;....:E.KKKWWWWWWWKWW#####W#WWWWKKLLGWEEGGGGGLGGGGGGGGGGGGGGGGGGGG *\n *jjt.             ...:::::::,,,,,;DEEKWWWWWKKKKKWWWWWWWWWWWW####WWWKKKWWWWWWWWKKKKK;.E;.........t.............................:::::ii;;.....D...KKWWWWWWWKWW#####WWEWWWKKGGGEKKGGGGGLGGGGGGGGGGGGGLGGGGGG *\n *fji.             ;.:::::::,,,,,;LEEKKWWWWWKKKKKWWWWWWWWWWWW####KWKKKKWWWWWWWWKKKKKi.D;..........j.............................:::tt;,.....:.....KKWWWWWWKWWWW##WWWGWWWKKGGGGKEGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fji.            t::::::::,,,,,,;EEEKWWWWWKKKKKKKWWWWWWWWWWW##WKWKKKKKWWWWWWWWKKKKKi:D;............j...........................::LL;,.............KKWWWWWKWWWWWWWWWGWWWKKGGGGKGGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fjt:            .:::::::,,,,,,,DEEKWWWWWWKKKKKKKWWWWWWWWWWWWKKWKKKKKKWWWWK#WWKKKKWitE;........... ............................:G;;:...............KKKWWKKWWWWWWWWWGWWWKKGGGGWGGGGGGGGGGGGGGGGGGGGGGGGGGL *\n *fjji;:.       .f:::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWWKKKKKKKKKKKWWKWWWWWKKKKWGKD;........................................L;;..................DKKWKKWWWWWWWWWGWWWKKDGGGKDGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *fjjtii;,:.     :::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWKKKKKKKKKKKKWWWWWW#WWKKKKWiEj;......................................:i,;....,...............;KKEKWWWWWWWWWGKWWKKDDGGDEGGGDGGGGGDGGGGGGGGGGGGGGGG *\n *fjtiiiii;;:.  j::::::,,,,,,,;;EEEKWWWWW#KKKKKWWWWWWWWWKKKKKKWKKKKKKKWWWWWWWWWKKKKWtEL;:....................................;;;:...,;j................:KEEWWWWWWWWWDDWWKKDDDDDKDDDDDDDDDDDDDDDGGGGGGGGGGG *\n *fjti;;iiii;;,:::::::,,,,,,,,;EEEKWWWWWWWKKKKWWWWWWWWKKKKKKKWKKKKKKKWWWWWWW#W#KKKKWEEii;...................................f;:....,;L...................EEKWWWWWWWWDDWWKKDDDDDKEDDDDDDDDDDDDDDDDDDDDDGGGG *\n *fjt,,,;;;;ii;f::::::,,,,,,,;;EEKWWWWWWWKKKKKWWWKWWKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWKEij;:...............................:G;,.....,;f....................:tKKWWWWWWWDDWWKKDDDDDKKDDDDDDDDDDDDDDDDDDDDDDDDD *\n *jjt. ..:,;;;;,::::,,,,,,,,;;GEEWWWWWWWWKKKKWKKWKKKKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWEDi;j;............................,Li;L;;;..,;;f........................KKKKWWWKDDWWKKDDDGDKKGGGGGGGGDGDDDDDDDDDDDDDDD *\n *fjt.    .:,,,:::::,,,,,,,;;;EEKWWWWWWWKKKKKKWKKKKKKKKKKKKKKKKKKKKKWKKKWKW##W#KKKKWEti;;G;........................tEEEL;;;;;;;;;;L..........................DKKKKKEDDWWKEDGftiLE;;;;itjLGGGGGGDDDDDDDDDDD *\n *fjt.       .j::::,,,,,,,;;;DEEWWWWWWWWKKKKWKKKKKKKKKKKKKKKKKKKKKKKWKKWWWK##W#KKKKKEii;;;L;...................iDEEEEEEKKi;j;;;;jD.....:......................,KKKKDGGEKKE:::::;E::::::::::,tLGGDDDDDDDDDD *\n *fjt.       .;:::,,,,,,,;;;;EEKWWWWWWWWKWKKKKKKKKKKKKKKKWKKKKKKKKKKWKKWWWW#WW#KKKKKKii;;;;f;.............:tDEEEEEKKKKKKKKEti;;;L...............................EEKf;:iKKE::::::E::::::::::::::ifDDDDDDDDD *\n *fjt:        :::,,,,,,,,;;;DEEWWWWWWWWWEKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####KKKKKEiii;;;;f,.........iDEEEEKKKKKKKKKKKKKKKf;iG......i..........................fK::::KKE::::::E::::::::::::::::,tGGDDDDD *\n *fjt:       t:::,,,,,,;;;;iDEKWWWWWWKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####WKKKKLiii;;;;;L,....,Li;EDEEEEKKKKKKKKKKKKKKKKiG......;:...........................:i:::KKE:::::,E,::::::::::::::::::iGDDDD *\n *jjt.       f::,,,,,,,;;;;GEEWWWWKEEKEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKWWWWW###WWKKKKiii;;;;;;;G,;L;;iiEEEEEEEKKKKKKKKKKKKKWWKE......;t.........:....................j::KEE:,::,,D,,::::,,,,,,:::::::::tDDD *\n *fjt:.      ,::,,,,,,,;;;;EEWWKEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKKWWWWW#W#KKKKKKiiiiii;;;;;i;;iiiEEKEEKKWKKKKKKKWKKKKKWWWGi;...;t......,;;;;,....................:,EEE,,,,,,D,,,,,,,,,,,,,,,,::,::::tG *\n *fjt:.     ,::,,,,,,,;;;;DEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWW#W#KKKKKKiiiii;;i;;;;;iiiKKKEKKKKWWKWWWWWWKKKKWWWWW;;;:;L.....;;;;;;;;;....................,KEE,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,; *\n *fjt:.     f:,,,,,,,;;;;jEDEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWW#W##KKKKKKiiiiiiii;i;;iiiEKKKKKKKKWKWWWWWWWWKKKWWWWWKi;;i.....,jEEfGi;;;;;...................EED,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.    .f::,,,,,,;;jEEDEEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWKWWWWW###KKKKKLiiiiiiiiiiiiiiEEKKKKKKKKWWWWWWWWWWWWKWWWWWWGi;i;,..;jDDDKEGi;;;;;;:................EED,,,,,,D,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.  .. ;::,,,,,;;EDDEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKW#WW####KWKKKiiiiiiiiiiiiijKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWt;i;;;;i;DDDDDDGi;;;;;;;;:.............EDf;,,,;,G;;;;;;;;;;;;;;;,,,,,,,,,, *\n *fjt:......:,,,,,,;LDDDEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWWKWWWW####KKKKKiiiiiiiiiiijKEKKWKKKKKKKWWWWWWWWWWWWWWWWWWWWWWiLiii;i;DEEEEDDE;i;;;;;;;;;:..........EDi,;;;;;L;;;;;;;;;;;;;;;;;;,,,,,,, *\n *fjt:......:,,,,,;EDDDEEKEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKWWWWKKWWW##W#KWKKWEiiiiiijGKKKKKWWKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKi;iiiiDDEEEEEEDEi;;;;;;;;;;;;;,:.....ED;;;;;;;j;;;;;;;;;;;;;;;;;;;;;;;,, *\n *fjt:.....t,,,,,;DDDDEEEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKWWWW##WKWKKWKiiiKKKKKKKKKWWKKKKKKKKWWWWWWWWWWWWWWW#WWWWWWWWWiiiiifLEEEEEEEEDi;i;;;;;;;;;;;;.....DD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....G,,,,,GDDDEEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKKWWWKKKWWW###WKWKKWKitKKKKKKKKKWKKKKKKKKKKWWWWWWWWWWWWWW###WWWWWWWWEiiiiiiiEEEEEEEEDGiiii;;;;;;;;;.....GD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....L,,,,;GDDDEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWDGWWW###KKWWKWKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWW####WWWWWWWWWiiiiiiiiEEEEEEEEEEDi;i;;;;;;;;.....Lj;;;;;;i;iiiiii;;;;;;ii;;;;;;;;;;; *\n ***********************************************************************************************************************************************************************************************************/\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 1]",2200,First of all I want to say about solution You can extract cycles in the graph do some dynamic programming on trees use some hard formulas and so on but it is a way harder to implement than the other solution that only has an additional log so I ll describe the one which is easier to understand and much easier to implement Firstly consider the problem from the other side What is this grid It is a functional graph such a directed graph that each its vertex has exactly one outgoing edge This graph seems like a set of cycles and ordered trees going into these cycles How can it help us Let s notice that if two robots meet after some move then they ll go together infinitely from this moment It means that if we try to make at least moves from each possible cell we will obtain some equivalence classes it means that if endpoints of two cells coincide after moves then you cannot place robots in both cells at once So if we could calculate such endpoints then we can take for each possible endpoint the robot starting from the black cell if such exists and otherwise the robot starting from the white cell if such exists How can we calculate such endpoints Let s number all cells from to where the number of the cell is Let the next cell after is i e if you make a move from you go to Also let s create the two dimensional array where means the number of the cell in which you will be if you start in the cell number and make moves What is the upper bound of It is exactly Well we need to calculate this matrix somehow It is obvious that if the number of the cell is and the number of the next cell is then Then let s iterate over all degrees from to and for each vertex set The logic behind this expresion is very simple if we want to jump times from and we have all values for calculated then let s just jump times from and times from the obtained vertex This technique is called binary lifting Now we can jump from every cell times in time just iterate over all degrees from to and if has the th bit on just jump from the current vertex times set The rest of solution is described above Time complexity 
IT City administration has no rest because of the fame of the Pyramids in Egypt There is a project of construction of pyramid complex near the city in the place called Emerald Walley The distinction of the complex is that its pyramids will be not only quadrangular as in Egypt but also triangular and pentagonal Of course the amount of the city budget funds for the construction depends on the pyramids volume Your task is to calculate the volume of the pilot project consisting of three pyramids one triangular one quadrangular and one pentagonal The first pyramid has equilateral triangle as its base and all 6 edges of the pyramid have equal length The second pyramid has a square as its base and all 8 edges of the pyramid have equal length The third pyramid has a regular pentagon as its base and all 10 edges of the pyramid have equal length ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 18:55:42       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\nconst dbl PI = acos(-1);\n\n\ndbl get(dbl l, int n)\n{\n    dbl alp = 2 * PI / n;\n    dbl bet = PI / 2 - alp / 2;\n    dbl x = sin(bet) / sin(alp) * l;\n    dbl S = x * x * sin(alp) / 2;\n    dbl h = sqrt(l * l - x * x);\n    dbl V = S * n * h / 3;\n    return V;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    dbl l3, l4, l5;\n    cin >> l3 >> l4 >> l5;\n    dbl res = get(l3, 3) + get(l4, 4) + get(l5, 5);\n    printf(""%.10f\\n"", res);    \n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700,The volume of a pyramid can be calculated as where v is the volume s is the area of the base and h is the height from the base to the apex Let s calculate s and h The area of a regular polygon having n sides of length ln can be found the following way A pentagon On the figure above a regular polygon is shown O is the center of the polygon all sides are equal to ln OB is the altitude of AOC triangle As the polygon is a regular one OA OC AOC triangle is a isosceles one and then and AB BC also AOB and COB triangles are right angled ones Also because the polygon is a regular one and can be seen as a union of 2n triangles equal to AOB triangle then AOB triangle is right angled one so Also So and The area of AOB is equal to The area of the polygon is A triangle On the figure above a triangle formed by the pyramid apex H the center of the base O and some vertex of the base A is shown It is a right angled one As all edges of the pyramid are equal AH ln and from calculations above According to Pythagorean theorem OA2 OH2 AH2 So The volume of one piramid is And the final formula is 
ATMs of a well known bank of a small country are arranged so that they can not give any amount of money requested by the user Due to the limited size of the bill dispenser the device that is directly giving money from an ATM and some peculiarities of the ATM structure you can get at most bills from it and the bills may be of at most two distinct denominations For example if a country uses bills with denominations and burles then at such ATM can give sums burles and burles but it cannot give sums and burles Let s suppose that the country uses bills of distinct denominations and the ATM that you are using has an unlimited number of bills of each type You know that during the day you will need to withdraw a certain amount of cash times You know that when the ATM has multiple ways to give money it chooses the one which requires the minimum number of bills or displays an error message if it cannot be done Determine the result of each of the of requests for cash withdrawal ,"['#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << "" = "" << x << endl\n#define _ << "" _ "" <<\n\ntypedef long long llint;\n\nconst int MAX = 1e7 + 100;\nconst int MAXN = 5050;\n\nint a[MAXN];\nbool ima[MAX];\n\nint main(void) {\n  int n, k;\n  scanf(""%d %d"", &n, &k);\n  REP(i, n) {\n    scanf(""%d"", &a[i]);\n    ima[a[i]] = true;\n  }\n\n  int q;\n  scanf(""%d"", &q);\n  while (q--) {\n    int v;\n    scanf(""%d"",  &v);\n    \n    int ans = k+1;\n    REP(i, n) REP(x, k+1) {\n      int rem = v - x * a[i];\n      if (rem < 0) break;\n      \n      if (rem == 0) {\n        ans = min(ans, x);\n        continue;\n      }\n\n      FOR(y, 1, k+1-x)\n        if (rem % y == 0 && rem/y < MAX && ima[rem / y]) {\n          ans = min(ans, x + y);\n          break;\n        }\n    }\n\n    if (ans > k) ans = -1;\n    printf(""%d\\n"", ans);\n  }\n\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1900,Intended solution has the complexity or For each possible value x that we can get write a pair x m where m is number of bills to achieve this value Sort this array in ascending order of x and leave only the best possible number of bills for each value of x Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O 1 time Check that we used no more than k bills totally and relax the answer if needed 
Eric is the teacher of graph theory class Today Eric teaches independent set and edge induced subgraph Given a graph G V E an is a subset of vertices V subset V such that for every pair u v in V u v not in E i e no edge in E connects two vertices from V An consists of a subset of edges E subset E and all the vertices in the original graph that are incident on at least one edge in the subgraph Given E subset E denote G E the edge induced subgraph such that E is the edge set of the subgraph Here is an illustration of those definitions In order to help his students get familiar with those definitions he leaves the following problem as an exercise Given a tree G V E calculate the sum of w H over all except null edge induced subgraph H of G where w H is the number of independent sets in H Formally calculate sum limits emptyset not E subset E w G E Show Eric that you are smarter than his students by providing the correct answer as quickly as possible Note that the answer might be large you should output the answer modulo 998 244 353 ,"[""#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\nconst int N = 3e5 + 5, M = N << 1, djq = 998244353;\n\nint n, ecnt, nxt[M], adj[N], go[M], f[N][2][2];\n\nvoid add_edge(int u, int v)\n{\n\tnxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;\n\tnxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;\n}\n\nvoid dfs(int u, int fu)\n{\n\tfor (int a = 0; a < 2; a++) for (int b = 0; b < 2; b++)\n\t\tf[u][a][b] = 1;\n\tint delta = 1;\n\tfor (int e = adj[u], v; e; e = nxt[e])\n\t\tif ((v = go[e]) != fu)\n\t\t{\n\t\t\tdfs(v, u);\n\t\t\tf[u][0][0] = 1ll * f[u][0][0] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0] + f[v][1][1]) % djq;\n\t\t\tf[u][1][0] = 1ll * f[u][1][0] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0] + f[v][1][1]) % djq;\n\t\t\tf[u][0][1] = 1ll * f[u][0][1] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0]) % djq;\n\t\t\tf[u][1][1] = 1ll * f[u][1][1] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0]) % djq;\n\t\t\tdelta = 1ll * delta * (f[v][0][0] + f[v][0][1]) % djq;\n\t\t}\n\tf[u][0][1] = (f[u][0][1] - delta + djq) % djq;\n}\n\nint main()\n{\n\tint x, y;\n\tread(n);\n\tfor (int i = 1; i < n; i++) read(x), read(y), add_edge(x, y);\n\tdfs(1, 0);\n\treturn std::cout << (1ll * f[1][0][0] + f[1][0][1] + djq - 1) % djq << std::endl, 0;\n}""]","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2500,We will call one vertice is colored if and only if it is in the independent set And a coloring is valid if and only if no two adjacent vertices are both colored Therefore we are asked to calculate the sum of number of valid colorings over all edge induced subgraphs To deal with the task one should notice that for a edge induced subgraph and one valid coloring we may add those vertices which are removed due to the generation of edge induced subgraph and remain it uncolored Therefore for a coloring on the original graph we could consider removing edges such that it will behave the same with above procedure In fact given a coloring we can define edge removing is valid if and only if there is no adjacent colored vertice and We can actually show that there is almost a one to one corresponding relation betweeen those two procedure except for the case where all vertices remains uncolored and all edges are removed Therefore we can actually solve the following task Given a tree for any given coloring define a edge removal is valid if it satisfies above constrains And it will suddenly becoming something easy to solve with tree dp Define be the answer for subtree rooted at with additional constraint such that is not colored be the answer where is colored and be the answer where edges from to its children are removed Therefore the dp formula should be The answer is easily calculated with those three states 
While tracking Diavolo s origins Giorno receives a secret code from Polnareff The code can be represented as an infinite sequence of positive integers a 1 a 2 dots Giorno immediately sees the pattern behind the code The first n numbers a 1 a 2 dots a n are For i n the value of a i is a i n a i n 1 where denotes the bitwise OR operator Pieces of information about Diavolo are hidden in q questions Each question has a positive integer v associated with it and its answer is the smallest index i such that a i v If no such i exists the answer is 1 Help Giorno in answering the questions ,"[""#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define N 200'005\n\nint n, q, a[N << 1], val[N];\nvector<pair<int, int>> mx[N];\nvector<int> bit[31];\nvoid solve()\n{\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], a[i + n] = a[i];\n    for (int i = 1; i <= n * 2; i++)\n    {\n        for (int j = 30; j >= 0; j--)\n        {\n            if (a[i] >> j & 1)\n                bit[j].push_back(i);\n        }\n    }\n    for (int i = n + 1; i <= n * 2; i++)\n    {\n        vector<int> zerobit;\n        for (int j = 30; j >= 0; j--)\n        {\n            if (!(a[i] >> j & 1))\n                zerobit.push_back(j);\n        }\n        vector<int> pos{i};\n        if (i != n + 1)\n        {\n            for (int j : zerobit)\n            {\n                auto it = lower_bound(bit[j].begin(), bit[j].end(), i);\n                if (it != bit[j].begin())\n                    it--;\n                if (it != bit[j].end() && *it + n > i)\n                    pos.push_back(*it);\n            }\n        }\n        sort(pos.begin(), pos.end(), greater<>());\n        int xval = 0;\n        for (int j : pos)\n        {\n            xval |= a[j];\n            int x = i - j + 1;\n            if (xval > val[x])\n            {\n                mx[x].push_back({xval, i - n});\n                val[x] = xval;\n            }\n        }\n    }\n\n    for (int i = 2; i <= n; i++)\n        val[i] = max(val[i - 1], val[i]);\n\n    while (q--)\n    {\n        int x;\n        cin >> x;\n        x++;\n        if (val[n] < x)\n        {\n            cout << -1 << '\\n';\n            continue;\n        }\n        int l = 1, r = n, mid;\n        while (l < r)\n        {\n            mid = l + r >> 1;\n            if (val[mid] < x)\n                l = mid + 1;\n            else\n                r = mid;\n        }\n\n        auto cal = [&](int x, int val) -> i64\n        {\n            if (x == 1)\n            {\n                auto it = lower_bound(mx[x].begin(), mx[x].end(), pair<int, int>{val, 0});\n                return it->second;\n            }\n            i64 res = n;\n            res += (i64)(x - 2) * (n - 1);\n            auto it = lower_bound(mx[x].begin(), mx[x].end(), pair<int, int>{val, 0});\n            res += it->second - 1;\n            return res;\n        };\n\n        cout << cal(r, x) << '\\n';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        val[i] = 0;\n        mx[i].clear();\n    }\n    for (int i = 0; i <= 30; i++)\n        bit[i].clear();\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}""]","[1, 1, 0, 0, 1, 0, 0, 1, 1, 0]",2500,Lets start with an example of Let where and are variables First elements of will be By removing and rearranging some elements we can get Here you can observe that each group will have a size of The next group will be the previous group or ed with the element the first element circularly So we have the rule Now let s solve the problem in binary that is every element is Let s take a look at the element in the rearranged version the highlighted ones If is it won t contribute anything to the subsequent groups so we can ignore it Otherwise it will contribute by keeping moving to the right This will end when it meets a cell in the group that is already And after that we can drop the act of moving This algorithm can actually help us construct the whole array sparsely and incrementally We can maintain the list of in the initial array and then update the array by moving all of them to the right That is if we have one group we can obtain the next group by moving the After that we can drop moving some if it meets another The whole action is as there are at most zeros to be updated So for the original problem first of all we can repeat the above algorithm times that is repeat the algorithm for each bit Secondly there are at most unique numbers for each position so we can just find all last positions of all numbers and put them in a array You can either find all unique positions in ascending order and or in random order and sort the array Then using binary search we can answer each query Time complexity of the former version is and the latter version is 
Rudolf is going to visit Bernard and he decided to take the metro to get to him The ticket can be purchased at a machine that accepts exactly two coins the sum of which does not exceed k Rudolf has two pockets with coins In the left pocket there are n coins with denominations b 1 b 2 dots b n In the right pocket there are m coins with denominations c 1 c 2 dots c m He wants to choose exactly one coin from the left pocket and exactly one coin from the right pocket two coins in total Help Rudolf determine how many ways there are to select indices f and s such that b f c s le k ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n , m , k ;\n    cin >> n >> m >> k ;\n    int a[ n ] , b[ m ] ;\n    FOR( i , n ) cin >> a[ i ] ;\n    FOR( i , m ) cin >> b[ i ] ;\n    int ans = 0 ; \n    FOR( i , n ){\n    \tFOR( j , m ){\n    \t\tif( a[ i ] + b[ j ] <= k ) ans ++ ;\n\t\t}\n\t}\n    cout << ans << ""\\n"" ;\n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0]",800,For each test case we calculate all elements from the first array Then we iterate through the elements in the second array and in a loop we calculate each sum If this sum is less than or equal to we add to the answer 
Given a natural number x You can perform the following operation choose a positive integer k and round x to the k th digit Note that the positions are numbered from right to left starting from zero If the number has k digits it is considered that the digit at the k th position is equal to 0 The rounding is done as follows if the digit at the k 1 th position is greater than or equal to 5 then the digit at the k th position is increased by 1 otherwise the digit at the k th position remains unchanged mathematical rounding is used if before the operations the digit at the k th position was 9 and it should be increased by 1 then we search for the least position k k k where the digit at the k th position is less than 9 and add 1 to the digit at the k th position Then we assign k k after that all digits which positions are less than k are replaced with zeros Your task is to make x as large as possible if you can perform the operation as many times as you want For example if x is equal to 3451 then if you choose consecutively k 1 then after the operation x will become 3450 k 2 then after the operation x will become 3500 k 3 then after the operation x will become 4000 k 4 then after the operation x will become 0 To maximize the answer you need to choose k 2 first and then k 3 then the number will become 4000 ,"[""#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n\nusing ll = long long;\nusing ld = long double;\n\n#define int long long\n\nvoid solve() {\n    string s;\n    cin >> s;\n    vector <int> a;\n    for (int i = 0; i < s.size(); ++i) {\n        a.push_back(s[s.size() - 1 - i] - '0');\n    }\n    a.push_back(0);\n    int f = 0, mp = -1;\n    for (int i = 0; i < a.size(); ++i) {\n        if (f) {\n            if (a[i] == 9) {\n                mp = i;\n                a[i] = 0;\n                continue;\n            }\n            a[i]++;\n            f = 0;\n        }\n        if (a[i] > 4) {\n            mp = i;\n            a[i] = 0;\n            f = 1;\n        }\n    }\n    for (int i = 0; i <= mp; ++i) a[i] = 0;\n    if (a.back() == 0) a.pop_back();\n    reverse(all(a));\n    for (auto& e : a) cout << e;\n    cout << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n}""]","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1100,First sorry for the unclear statement We have rewritten it for several times and have chosen the best one Let s define as the length of the Notice that after applying the rounding to all the digits to the right of become If the th digit is less than after the rounding it ll only worsen the answer On the other side if the th digit is not less than than rounding to the th digit always leads to better answer because after the operation will increase From these observations we can come up with the following greedy algorithm look through all from to and if the th digit is not less than we use the rounding operation adding one to the th digit And don t worry if that digit which must be increased by one is because in such case we always use the rounding operation on the next step 
For his birthday recently Fedya was given an array a of n integers arranged in a circle For each pair of neighboring numbers a 1 and a 2 a 2 and a 3 ldots a n 1 and a n a n and a 1 the absolute difference between them is equal to 1 Let s call a an element which is greater than both of its neighboring elements Also call a an element which is less than both of its neighboring elements Note that elements a 1 and a n are neighboring elements Unfortunately Fedya lost an array but he remembered in it the sum of local maximums x and the sum of local minimums y Given x and y help Fedya find any matching array of length ,"[""#include<bits/stdC++.h>\nusing namespace std;\nint T;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>T;\n\twhile(T--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tcout<<(x-y)*2<<'\\n';\n\t\tfor(int i=y;i<x;i++)cout<<i<<' ';\n\t\tfor(int i=x;i>y;i--)cout<<i<<' ';\n\t\tcout<<'\\n';\n\t}\n}\n""]","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1100,Note that the local minimums and maximums will alternate and there will be the same number of them Let s call the th local maximum by the th local minimum by Without loss of generality consider that goes before To get from we need to write out numbers to get from we need to write out numbers Thus The array will satisfy the condition Code 
 Homer likes arrays a lot and he wants to play a game with you Homer has hidden from you a permutation a 1 a 2 dots a n of integers 1 to n You are asked to find any index k 1 leq k leq n which is a local minimum For an array a 1 a 2 dots a n an index i 1 leq i leq n is said to be a if a i min a i 1 a i 1 where a 0 a n 1 infty An array is said to be a permutation of integers 1 to n if it contains all integers from 1 to n exactly once Initially you are only given the value of n without any other information about this permutation At each interactive step you are allowed to choose any i 1 leq i leq n and make a query with it As a response you will be given the value of a i You are asked to find any index k which is a local minimum ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass ASearchingLocalMinimum {\n public:\n  void solveOne() {\n    int n;\n    cin >> n;\n    if (n == 1) {\n      cout << ""! 1\\n"";\n      cout.flush();\n      return;\n    }\n    cout << ""? 1\\n"";\n    cout.flush();\n    int a0;\n    cin >> a0;\n    cout << ""? 2\\n"";\n    cout.flush();\n    int a1;\n    cin >> a1;\n    if (a0 < a1) {\n      cout << ""! 1\\n"";\n      cout.flush();\n      return;\n    }\n    cout << ""? "" << (n - 1) << ""\\n"";\n    cout.flush();\n    int a2;\n    cin >> a2;\n    cout << ""? "" << n << ""\\n"";\n    cout.flush();\n    int a3;\n    cin >> a3;\n    if (a2 > a3) {\n      cout << ""! "" << n << ""\\n"";\n      cout.flush();\n      return;\n    }\n    int left = 1;\n    int right = n - 2;\n    while (true) {\n      if (left == right) {\n        cout << ""! "" << (left + 1) << ""\\n"";\n        cout.flush();\n        return;\n      }\n      int m1 = (left + right) / 2;\n      int m2 = m1 + 1;\n      cout << ""? "" << (m1 + 1) << ""\\n"";\n      cout.flush();\n      int b0;\n      cin >> b0;\n      cout << ""? "" << (m2 + 1) << ""\\n"";\n      cout.flush();\n      int b1;\n      cin >> b1;\n      if (b0 < b1) {\n        right = m1;\n      } else {\n        left = m2;\n      }\n    }\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ASearchingLocalMinimum solver;\n\n\n    solver.solve();\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1700,We maintain by binary search a range which has a local minimum Moreover we assume that and Initially In each iteration let be the midpoint of and If then the range becomes If then the range becomes When we have found a local minimum The number of queries to is at most 
Recently Pari and Arya did some research about NP Hard problems and they found the problem very interesting Suppose the graph is given Subset of its vertices is called a of this graph if for each edge there is at least one endpoint of it in this set i e or or both Pari and Arya have won a great undirected graph as an award in a team contest Now they have to split it in two parts but both of them want their parts of the graph to be a vertex cover They have agreed to give you their graph and you need to find two subsets of its vertices and such that both and are vertex cover or claim it s impossible Each vertex should be given to no more than one of the friends or you can even keep it for yourself ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\n\nint n,m,u,v,col[N];\nVI e[N],vec[10];\nvoid dfs(int u) {\n\tfor (auto v:e[u]) {\n\t\tif (col[v]==0) {\n\t\t\tcol[v]=3-col[u];\n\t\t\tdfs(v);\n\t\t} else if (col[u]+col[v]!=3) {\n\t\t\tputs(""-1"");\n\t\t\texit(0);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\trep(i,1,n+1) if (col[i]==0) {\n\t\tcol[i]=1;\n\t\tdfs(i);\n\t}\n\trep(i,1,n+1) vec[col[i]].pb(i);\n\tprintf(""%d\\n"",SZ(vec[1]));\n\tfor (auto p:vec[1]) printf(""%d "",p);\n\tputs("""");\n\tprintf(""%d\\n"",SZ(vec[2]));\n\tfor (auto p:vec[2]) printf(""%d "",p);\n\tputs("""");\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1500,Hint Try to use all of the vertices Then look at the two vertex covers together in the graph and see how it looks like Solution Looking at the two vertex covers in the graph you see there must be no edge uv that u and v are in the same vertex cover So the two vertex covers form a bipartition of the graph so the graph have to be bipartite And being bipartite is also sufficient you can use each part as a vertex cover Bipartition can be found using your favorite graph traversing algorithm BFS or DFS Here is a tutorial for bipartition of undirected graphs 
In Absurdistan there are towns numbered through and bidirectional railways There is also an absurdly simple road network for each pair of different towns and there is a bidirectional road between towns and there is no railway between them Travelling to a different town using one railway or one road always takes exactly one hour A train and a bus leave town at the same time They both have the same destination town and don t make any stops on the way but they can wait in town The train can move only along railways and the bus can move only along roads You ve been asked to plan out routes for the vehicles each route can use any road railway multiple times One of the most important aspects to consider is safety in order to avoid accidents at railway crossings the train and the bus must not arrive at the same town except town simultaneously Under these constraints what is the minimum number of hours needed for both vehicles to reach town the maximum of arrival times of the bus and the train Note that bus and train are not required to arrive to the town at the same moment of time but are allowed to do so ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\n#include <queue>\nconst int N=410;\ndeque<pair<int,PII> > q;\nint dis[N][N][2],vis[N][N][2];\nint n,m,u,v,g[N][N],f[N][N];;\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\tg[u][v]=g[v][u]=1;\n\t}\n\tg[n][n]=1;\n\trep(i,1,n+1) rep(j,1,n+1) if (g[i][j]==0&&i!=j) f[i][j]=1; f[n][n]=1;\n\tmemset(dis,0x20,sizeof(dis));\n\tdis[1][1][0]=0;\n\tq.push_back(mp(1,mp(1,0)));\n\twhile (!q.empty()) {\n\t\tint u=q.front().fi,v=q.front().se.fi,dir=q.front().se.se;\n\t\tq.pop_front();\n\t\tif (vis[u][v][dir]) continue;\n\t\tvis[u][v][dir]=1;\n\t//\tprintf(""%d %d %d %d\\n"",u,v,dir,dis[u][v][dir]);\n\t\tif (dir==0) {\n\t\t\trep(w,1,n+1) if (g[v][w]&&dis[u][w][1]>dis[u][v][0]+1) {\n\t\t\t\tdis[u][w][1]=dis[u][v][0]+1;\n\t\t\t\tq.push_back(mp(u,mp(w,1)));\n\t\t\t}\n\t\t} else {\n\t\t\trep(w,1,n+1) if (f[u][w]&&(w==n||w!=u)&&dis[w][v][0]>dis[u][v][1]) {\n\t\t\t\tdis[w][v][0]=dis[u][v][1];\n\t\t\t\tq.push_front(mp(w,mp(v,0)));\n\t\t\t}\n\t\t}\n\t}\n\tint r=min(dis[n][n][0],dis[n][n][1]);\n\tif (r>=10000000) puts(""-1""); else printf(""%d\\n"",r);\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1600,The condition that the train and bus can t meet at one vertex except the final one is just trolling If there s a railway then the train can take it and wait in town N If there s no such railway then there s a road the bus can take it and wait in N instead There s nothing forbidding this D The route of one vehicle is clear How about the other one Well it can move as it wants so the answer is the length of its shortest path from 1 to N or 1 if no such path exists It can be found by BFS in time O N M O N2 In order to avoid casework we can just compute the answer as the maximum of the train s and the bus s shortest distance from 1 to N That way we compute since the answer is 1 it works well In summary time and memory complexity O N2 Bonus Assume that there are M1 roads and M2 railways given on the input all of them pairwise distinct Bonus 2 Additionally assume that the edges are weighted The speed of both vehicles is still the same traversing an edge of length l takes l hours 
Let s say you are standing on the XY plane at point 0 0 and you want to reach point n n You can move only in two directions to the i e horizontally and in the direction that increase your x coordinate or i e vertically and in the direction that increase your y coordinate In other words your path will have the following structure initially you choose to go to the right or up then you go some distance in the chosen direction distances can be chosen independently after that you change your direction from right to up or from up to right and repeat the process You don t like to change your direction too much so you will make no more than n 1 direction changes As a result your path will be a polygonal chain from 0 0 to n n consisting of n line segments where each segment has positive integer length and vertical and horizontal segments alternate Not all paths are equal You have n integers c 1 c 2 dots c n where c i is the cost of the i th segment Using these costs we can define the as the sum of lengths of the segments of this path multiplied by their cost i e if the path consists of k segments k le n then the cost of the path is equal to sum limits i 1 k c i cdot length i segments are numbered from 1 to k in the order they are in the path Find the path of the minimum cost and print its cost ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll C[101010];\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%d"", &N);\n\t\tfor(int i = 1; i <= N; i++) scanf(""%lld"", &C[i]);\n\t\tll s0 = C[1], mn0 = C[1];\n\t\tll s1 = C[2], mn1 = C[2];\n\t\tll ans = (C[1] + C[2]) * N;\n\n\t\tfor(int i = 3; i <= N; i++) {\n\t\t\tif(i & 1) {\n\t\t\t\ts0 += C[i]; mn0 = min(mn0, C[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 += C[i]; mn1 = min(mn1, C[i]);\n\t\t\t}\n\t\t\tans = min(ans, s0 + mn0 * (N - (i + 1) / 2) + s1 + mn1 * (N - i / 2));\n\t\t}\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 1, 1, 0, 0, 0, 0]",1500,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is 
While resting on the ship after the Russian Code Cup a boy named Misha invented an interesting game He promised to give his quadrocopter to whoever will be the first one to make a rectangular table of size consisting of positive integers such that the sum of the squares of numbers for each row and each column was also a square Since checking the correctness of the table manually is difficult Misha asks you to make each number in the table to not exceed ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nvector <int> gen(int n) {\n  vector <int> ret(n);\n  if (n == 1) {\n    ret[0] = 1;\n  } else\n  if (n == 2) {\n    ret[0] = 3;\n    ret[1] = 4;\n  } else\n  if (n % 2 == 0) {\n    for (int i = 0; i < n - 1; i++) ret[i] = 1;\n    ret[n - 1] = n / 2 - 1;\n  } else {\n    for (int i = 0; i < n - 2; i++) ret[i] = 1;\n    ret[n - 2] = 2;\n    ret[n - 1] = n / 2 + 1;\n  }\n  return ret;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector <int> a = gen(n);\n  vector <int> b = gen(m);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      printf(""%d"", a[i] * b[j]);\n      if (j < m - 1) printf("" "");\n    }\n    printf(""\\n"");\n  }\n  return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 1, 0, 0, 0]",2400,Let s build array of the length for each that the sum of the squares of its elements is the square We are given two numbers and Let array corresponds to and array corresponds to The we will build the answer array as follows Solution 6396358 
Giant chess is quite common in Geraldion We will not delve into the rules of the game we ll just say that the game takes place on an field and it is painted in two colors but not like in chess Almost all cells of the field are white and only some of them are black Currently Gerald is finishing a game of giant chess against his friend Pollard Gerald has almost won and the only thing he needs to win is to bring the pawn from the upper left corner of the board where it is now standing to the lower right corner Gerald is so confident of victory that he became interested in how many ways can he win The pawn which Gerald has got left can go in two ways one cell down or one cell to the right In addition it can not go to the black cells otherwise the Gerald still loses There are no other pawns or pieces left on the field so that according to the rules of giant chess Gerald moves his pawn until the game is over and Pollard is just watching this process ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nPII p[2010];\nll dp[2010],f[201000];\nint h,w,n;\nll go(ll x,ll y) {\n\tassert(x>=0&&y>=0);\n\treturn f[x+y]*powmod(f[x]*f[y],mod-2)%mod;\n}\nint main() {\n\tscanf(""%d%d%d"",&h,&w,&n);\n\tf[0]=1;\n\trep(i,1,200001) f[i]=f[i-1]*i%mod;\n\trep(i,0,n) scanf(""%d%d"",&p[i].fi,&p[i].se);\n\tp[n]=mp(h,w); p[n+1]=mp(1,1); n+=2;\n\tsort(p,p+n); \n\tdp[0]=1;\n\trep(i,1,n) {\n\t\tdp[i]=go(p[i].fi-1,p[i].se-1);\n\t\trep(j,1,i) if (p[j].fi<=p[i].fi&&p[j].se<=p[i].se)\n\t\t\tdp[i]=(dp[i]-go(p[i].fi-p[j].fi,p[i].se-p[j].se)*dp[j])%mod;\n\t}\n\t(dp[n-1]+=mod)%=mod;\n\tprintf(""%I64d\\n"",dp[n-1]);\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2200,Let s denote black cells ad First of all we have to sort black cells in increasing order of row column If cell available from cell stands after in this order Let Now we have to find number of paths from to avoiding Let is number of paths from to avoiding It s easy to see that is answer for the problem Number of all paths from to is We should subtract from that value all paths containing at least one of previous black cells We should enumerate first black cell on the path It could be one of previous cell that is not below or righter than For each such cell we have to subtract number of paths from to avoiding black cells multiplied by number of all paths from to We have to calculate factorials of numbers from to and inverse elements of them modulo for calculating binomial coefficients 
A few years ago Hitagi encountered a giant crab who stole the whole of her body weight Ever since she tried to avoid contact with others for fear that this secret might be noticed To get rid of the oddity and recover her weight a special integer sequence is needed Hitagi s sequence has been broken for a long time but now Kaiki provides an opportunity Hitagi s sequence has a length of Lost elements in it are denoted by zeros Kaiki provides another sequence whose length equals the number of lost elements in i e the number of zeros Hitagi is to replace each zero in with an element from so that Hitagi knows however that If the resulting sequence is an increasing sequence then it has the power to recover Hitagi from the oddity You are to determine whether this is possible or Kaiki s sequence is just another fake In other words you should detect whether it is possible to replace each zero in with an integer from so that each integer from is used exactly once and the resulting sequence is increasing ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint n, k;\n\nint a[maxn];\n\nint pos;\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> k;\n    if (k > 1){\n        cout << ""Yes"";\n        return 0;\n    }\n    for (int i = 0; i < n; i++){\n        cin >> a[i];\n        if (a[i] == 0)\n            pos = i;\n        if (i > 0 && a[i] < a[i - 1] && a[i] != 0){\n            cout << ""Yes"";\n            return 0;\n        }\n    }\n    int x;\n    cin >> x;\n    if ((pos == 0 || a[pos - 1] < x) && (pos == n - 1 || a[pos + 1] > x))\n        cout << ""No"";\n    else\n        cout << ""Yes"";\n}\n']","[1, 0, 1, 0, 0, 0, 1, 0, 1, 0]",900,The statement laid emphasis on the constraint that the elements are pairwise distinct How is this important In fact this implies that if the resulting sequence is increasing then swapping any two of its elements will result in another sequence which is not increasing And we re able to perform a swap on any resulting sequence if and only if Thus if the answer would always be Yes For cases where we replace the only zero in sequence with the only element in and check the whole sequence Hackable solutions include those only checking the replaced element and its neighbours and those missing the replaced element Figure out why solution 2 is not hackable 
You are given an integer k Find the largest integer x where 1 le x k such that x x 1 dagger is a multiple of ddagger k or determine that no such x exists dagger y denotes the factorial of y which is defined recursively as y y cdot y 1 for y geq 1 with the base case of 0 1 For example 5 5 cdot 4 cdot 3 cdot 2 cdot 1 cdot 0 120 ddagger If a and b are integers then a is a multiple of b if there exists an integer c such that a b cdot c For example 10 is a multiple of 5 but 9 is not a multiple of 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=2e5+10;\nint a[maxn],m,n,t_case;\nint main(){\n\tscanf(""%d"",&t_case);\n\twhile(t_case--){\n\t\tscanf(""%d"",&n);\n\t\tprintf(""%d\\n"",n-1);\n\t}\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Suppose we can make operations so that elements do not participate in any operation Then these elements in the final array will end up at the beginning in the order in which they were in the initial array And since this must be maximized to minimize the number of operations we need to find the maximal subsequence of the numbers Let this sequence have numbers then the answer is 
Misuki has chosen a secret tree with n nodes indexed from 1 to n and asked you to guess it by using queries of the following type Misuki will tell you which node x minimizes d a x d b x where d x y is the distance between nodes x and y If more than one such node exists Misuki will tell you the one which minimizes d a x Find out the structure of Misuki s secret tree using at most 15n queries ,"['#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<""=""<<x<<""\\n"";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+"".in"").c_str(),""r"",stdin);\tfreopen((s+"".out"").c_str(),""w"",stdout);}int qry(int x,int y){\tcout<<""? ""<<x+1<<"" ""<<y+1<<endl;\tint z;\tcin>>z;\tre z-1;}const int N=1005;int n,ff[N],ok[N],te[N];void run(){\tint n;\tcin>>n;\trep(i,n){\t\tok[i]=0;\t\tff[i]=-1;\t\tte[i]=0;\t}\tok[0]=1;\twhile(1){\t\tint fl=0;\t\trep(i,n)if(!ok[i]&&ok[te[i]]){\t\t\tint rv=qry(te[i],i);\t\t\tif(rv==te[i]){\t\t\t\tff[i]=te[i];\t\t\t\tok[i]=1;\t\t\t}\t\t\telse te[i]=rv;\t\t\tfl=1;\t\t}\t\tif(!fl)break;\t}\trep(i,n)assert(ok[i]);\tcout<<""! "";\trept(i,1,n)cout<<ff[i]+1<<"" ""<<i+1<<"" "";\tcout<<endl;}signed main(){//\tios::sync_with_stdio(0);//\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0]",1500,It s easy to verify that querying a and b will return the midpoint of the path between a and b In case the path has odd length the node closer to a of the two central nodes will be returned We will now construct the tree by expanding a connected component Let A 1 and B 2 ldots n While B is not empty choose any b in B and a in A Let P be the path between a and b By construction P will consist of a prefix contained in A and a suffix contained in B We can binary search for the first i such that P i in B This will take at most lceil log P rceil 2 queries Then P i 1 P i will be an edge of the tree so we will set A A cup P i and B B backslash P i The total number of queries will be smaller than n lceil log n rceil 2n 12000 
Fillomino is a classic logic puzzle You do not need to know Fillomino in order to solve this problem In one classroom in Yunqi town some volunteers are playing a board game variant of it Consider an n by n chessboard Its rows are numbered from 1 to n from the top to the bottom Its columns are numbered from 1 to n from the left to the right A cell on an intersection of x th row and y th column is denoted x y The main diagonal of the chessboard is cells x x for all 1 le x le n A permutation of 1 2 3 dots n is written on the main diagonal of the chessboard There is exactly one number written on each of the cells The problem is to partition the cells under and on the main diagonal there are exactly 1 2 ldots n such cells into n connected regions satisfying the following constraints Every region should be connected That means that we can move from any cell of a region to any other cell of the same region visiting only cells of the same region and moving from a cell to an adjacent cell The x th region should contain cell on the main diagonal with number x for all 1 le x le n The number of cells that belong to the x th region should be equal to x for all 1 le x le n Each cell under and on the main diagonal should belong to exactly one region ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint main() {\n\tsetIO();\n\tints(N);\n\tvi P(N); re(P);\n\tV<vi> ans(N,vi(N));\n\tF0R(i,N) ans[i][i] = P[i];\n\tdbg(""HA"",ans);\n\tF0R(diag,N-1) {\n\t\tpi nex{diag+1,0};\n\t\tF0R(i,N-diag) {\n\t\t\tif (ans[diag+i][i] == 1) continue;\n\t\t\t// dbg(""WUT"",nex,mp(i,diag+i));\n\t\t\tans[nex.f][nex.s] = ans[diag+i][i]-1;\n\t\t\t++nex.f,++nex.s;\n\t\t}\n\t}\n\tF0R(i,N) {\n\t\tF0R(j,i+1) {\n\t\t\tpr(ans[i][j]+i-j,\' \');\n\t\t}\n\t\tps();\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1400,The answer is unique and always exists There are two ways to construct the answer Construction 1 Start with the main diagonal There is one cell with number on it That cell must form a region by itself For each cell on the main diagonal that is above the cell belongs to the same region as We write the number on minus on the cell and make belong to the same region as For each cell on the main diagonal that is below the cell belongs to the same region as We write the number on minus on the cell and make belong to the same region as Then a permutation of are written on the cells We can continue this process on this subdiagonal Then a oermutation of will be written on the cells Repeat until all cells have numbers written on them Note that the numbers written on the cells are not the output Put for the region with size after constructing the regions This construction proves that the solution always exists and is unique Construction 2 Construct the region for in order When starting at we walk from for steps where is the number written on For each step if the cell to the left of your current cell is empty we go to that cell and write on it Otherwise we go down and write there We can prove that the second construction produces exactly the same answer as the first construction They only differ in their orders of processing The regions are always paths 
You are given a four digit pin code consisting of digits from 0 to 9 that needs to be entered Initially the cursor points to the digit 1 In one second you can perform exactly one of the following two actions Press the cursor to display the current digit Move the cursor to any adjacent digit The image above shows the device you are using to enter the pin code For example for the digit 5 the adjacent digits are 4 and 6 and for the digit 0 there is only one adjacent digit 9 Determine the minimum number of seconds required to enter the given four digit pin code ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma"")\n#pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h> \nusing namespace std;\n#define int long long int\ntypedef long long ll;\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n \nvoid solve(){\n    vector<int> a(4);\n    for(int i=0;i<4;i++){\n        char ch;cin>>ch;\n        int c=ch-\'0\';\n        if(c==0){\n            a[i]=10;\n        }\n        else{\n            a[i]=c;\n        }\n    }\n    // for(int i=0;i<4;i++)  cout<<a[i]<<"" "";\n    // cout<<endl;\n    int ans=4;\n    int prev=1;\n    for(int i=0;i<4;i++){\n        ans+=abs(a[i]-prev);\n        prev=a[i];\n    }\n    cout<<ans<<endl;\n}\n \nint32_t main(){\n    // freopen(""input.in"",""r"",stdin);\n    // freopen(""output.out"",""w"",stdout);\n    ll t;cin>>t;\n    while(t--) solve();\n    // 48-57:0-9 / 65-90:A-Z / 97-122:a-z\n    // DECIMAL:       cout<<fixed<<setprecision(8)<<ans;\n    // PREFIX+SUFFIX: exclude a element in the array\n    // PREFIX_SUM:    binary array\n    // DFS/BFS:       states being visited again\n    // BINARY_SEARCH: maximize the minimum possible/minimize the maximum possible\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800,Let s represent our pin code as a set of digits Replace all s with and notice that the answer is equal to 
There are workers in a company each of them has a unique id from to one of them is a chief his id is Each worker except the chief has exactly one immediate superior There was a request to each of the workers to tell how how many superiors not only immediate Worker s superiors are his immediate superior the immediate superior of the his immediate superior and so on For example if there are three workers in the company from which the first is the chief the second worker s immediate superior is the first the third worker s immediate superior is the second then the third worker has two superiors one of them is immediate and one not immediate The chief is a superior to all the workers except himself Some of the workers were in a hurry and made a mistake You are to find the minimum number of workers that could make a mistake ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + "" in line "" + std::to_string(__LINE__) + "" in "" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it\'s reference type is not a reference.\n*\n* It doesn\'t return reference because\n* 1. Anyway it\'ll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It\'ll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it\'s seems to work at least on my implementation.\n*\n* It\'s not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\nusing namespace std;\n\nclass TaskC {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, s;\n\t\tin >> n >> s;\n\t\t--s;\n\t\tvector<int> v(n);\n\t\tint ans = 0, free = 0;\n\t\tvector<int> d;\n\t\tfor (int i: range(n)) {\n\t\t\tin >> v[i];\n\t\t\tif (i == s && v[i] != 0) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t\tif (i == s) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (v[i] == 0) {\n\t\t\t\t++ans;\n\t\t\t\t++free;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\td.push_back(v[i]);\n\t\t}\n\n\t\tsort(d);\n\n\t\tint mxDepth = 0;\n\n\t\tfor (int i = 0; i < (int)d.size();) {\n\t\t\tif (d[i] <= mxDepth + 1) {\n\t\t\t\tmxDepth = max(d[i], mxDepth);\n\t\t\t\t++i;\n\t\t\t} else if (free) {\n\t\t\t\t--free;\n\t\t\t\t++mxDepth;\n\t\t\t} else {\n\t\t\t\td.pop_back();\n\t\t\t\t++ans;\n\t\t\t\t++mxDepth;\n\t\t\t}\n\t\t}\n\n\t\tout << ans << ""\\n"";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskC solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1900,At first if the chief reported that he has one or more superiors let s change as in zero If there are workers who do not chiefs but reported that they have no superiors let assume that they reported a number which more than the other workers for example number n It is necessarily that there must be the worker which has exactly one superior If there is no such worker let s take the worker who reported the maximum number and change this number on 1 Then we need to make the same algorithm for numbers 2 3 and etc while there are workers which have not yet considered After we considered all workers the answer is the number of workers which reported numbers were changed 
You are given four integer values a b c and m Check if there exists a string that contains a letters b letters c letters no other letters exactly m pairs of adjacent equal letters exactly m such positions i that the i th letter is equal to the i 1 th one ,"['/**\n *    author:  tourist\n *    created: 20.09.2021 17:36:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, c, m;\n    cin >> a >> b >> c >> m;\n    int other = a + b + c - max(a, max(b, c));\n    int L = a + b + c - 1 - 2 * other;\n    int R = a - 1 + b - 1 + c - 1;\n    cout << (L <= m && m <= R ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1100,Let s start with a simple assumption For some fixed values the values of that the answers exist for make up a range So there s the smallest possible number of adjacent equal pairs one can construct and the largest one everything in between exists as well The largest number is simple put all A s then all B s then all C s So this value is The smallest number is trickier Let s instead investigate when it s equal to WLOG assume Imagine the following construction There are letters C which separate blocks of letters A and B There are if you consider the ones to the sides of all letters C but we want the smallest value so we shouldn t consider them such blocks thus it s possible that each block contains no more than one letter A and no more than one letter B So letters A and B will never produce adjacent pairs If there are empty blocks then there are adjacent letters C So the condition to still have no empty blocks is to have at least letters A and B in total If then any extra letter C can only be put adjacent to another letter C thus producing an extra pair at least one extra pair but since we are examining the lower bound we can always do exactly one That means that the lower bound is Now for the proof of the fact that every value in between is also achievable Since we have a construction for let s try modifying it Let s reduce the test to the following way While decrease the count of the letter that appears the most by and decrease by Now build the string for with the reduced values After that put the letters back placing them next to the last occurrence of the same letter there is at least one occurrence of each letter the proof is trivial That increases by and the count of this letter by Thus we ll return to the initial test Overall complexity per testcase 
Ivan is going to sleep now and wants to set his alarm clock There will be many necessary events tomorrow the i th of them will start during the x i th minute Ivan doesn t want to skip any of the events so he has to set his alarm clock in such a way that it rings during minutes x 1 x 2 dots x n so he will be awake during each of these minutes Ivan can choose two properties for the alarm clock the first minute it will ring let s denote it as y and the interval between two consecutive signals let s denote it by p After the clock is set it will ring during minutes y y p y 2p y 3p and so on Ivan can choose minute as the first one but he cannot choose any arbitrary value of p He has to pick it among the given values p 1 p 2 dots p m his phone does not support any other options for this setting So Ivan has to choose the first minute y when the alarm clock should start ringing and the interval between two consecutive signals p j in such a way that it will ring during all given minutes x 1 x 2 dots x n and it does not matter if his alarm clock will ring in any other minutes Your task is to tell the first minute y and the index j such that if Ivan sets his alarm clock with properties y and p j it will ring during all given minutes x 1 x 2 dots x n or say that it is impossible to choose such values of the given properties If there are multiple answers you can print any ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nconst ll INF = (ll)1e18 + 55;\n\nint n, m;\nll x, y, z;\nll ans1 = INF;\nint ans2;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\ty = 0;\n\tscanf(""%lld"", &x);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(""%lld"", &z);\n\t\ty = gcd(y, abs(z - x));\n\t}\n\tx = (x - 1) % y + 1;\n\tans2 = -1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%lld"", &z);\n\t\tif (y % z) continue;\n\t\tz = (x - 1) % z + 1;\n\t\tif (z < ans1) {\n\t\t\tans1 = z;\n\t\t\tans2 = i + 1;\n\t\t}\n\t}\n\tif (ans2 == -1)\n\t\tprintf(""NO\\n"");\n\telse\n\t\tprintf(""YES\\n%lld %d\\n"", ans1, ans2);\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300,It is obvious that we can always take as But we don t know which value of we can take Let be for all from to The value of should be divisor of value of The maximum possible divisor of each is greatest common divisor And then it is obvious that the value of should be the divisor of So we have to find divisor of among all values If there is no such value then the answer is Time complexity 
There are n flowers in a row the i th of them initially has a positive height of h i meters Every second the wind will blow from the left causing the height of some flowers to decrease Specifically every second for each i from 1 to n in this order the following happens If i n or h i h i 1 the value of h i changes to max 0 h i 1 How many seconds will pass before h i 0 for all 1 le i le n for the first time ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, ""/stack:200000000"")#pragma GCC optimize(""O3"")//~ #pragma GCC target (""avx2"")//~ #pragma GCC optimize(""Ofast"")//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")//~ #pragma GCC optimize(""unroll-loops"")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>\xa0using namespace __gnu_pbds;using namespace std;\xa0template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\xa0#define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << ""("" << d.first << "", "" << d.second << "")"";}sim dor(rge<c> d) {  *this << ""["";  for (auto it = d.b; it != d.e; ++it)    *this << "", "" + 2 * (it == d.b) << *it;  ris << ""]"";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\xa0#define shandom_ruffle random_shuffle\xa0using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=1000*1007;\xa0int n;ll tab[nax];\xa0void test(){\tscanf(""%d"", &n);\tfor (int i=1; i<=n; i++)\t\tscanf(""%lld"", &tab[i]);\tll wyn=0;\tfor (int i=1; i<=n; i++)\t\twyn=max(wyn, tab[i]+i-1);\tprintf(""%lld\\n"", wyn);}\xa0int main(){\tint t;\tscanf(""%d"", &t);\twhile(t--)\t\ttest();\treturn 0;}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1200,First let s try to find when will first be equal to zero The answer is clearly Suppose for some we know that will first become equal to zero at time If at some point in time was equal to at the start of the second and before they are both equal to zero is equal to Since after that point in time if decreases must decrease in the next second If is never equal to until they hit zero must always be strictly greater than This means that will keep decreasing every second until it hits zero so is equal to in this case Examples The array changes as follows If we focus on the first two elements they change as follows The array changes as follows Let s combine the two cases If initially holds will become equal to at some point in time so Else so Combining the two we get Since we know we can easily calculate all the other values of by iterating from to The answer to the problem is since for all Complexity 
Luke likes to eat There are n piles of food aligned in a straight line in front of him The i th pile contains a i units of food Luke will walk from the 1 st pile towards the n th pile and he wants to eat every pile of food without walking back When Luke reaches the i th pile he can eat that pile if and only if v a i leq x where x is a fixed integer and v is Luke s food affinity Before Luke starts to walk he can set v to any integer Also for each i 1 leq i leq n Luke can his food affinity to any integer he eats the i th pile Find the minimum number of needed to eat every pile of food Note that the initial choice for v is considered as a change ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 17:07:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int ans = 0;\n    int beg = 0;\n    while (beg < n) {\n      int end = beg;\n      int mx = a[beg];\n      int mn = a[beg];\n      while (end + 1 < n) {\n        int new_mx = max(mx, a[end + 1]);\n        int new_mn = min(mn, a[end + 1]);\n        if (new_mx - new_mn > 2 * x) {\n          break;\n        }\n        mx = new_mx;\n        mn = new_mn;\n        end += 1;\n      }\n      ans += 1;\n      beg = end + 1;\n    }\n    cout << ans - 1 << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1000,For if then Then consider using the greedy strategy We will only change when we cannot find any possible to satisfy the current conditions Therefore we can determine the range of Initially set then For change Once which means from the last time that we changed to the current we cannot find any possible to satisfy the all the conditions between the two positions we should change and add to answer 
You are given an array A consisting of n positive integers a 1 a 2 dots a n and an array B consisting of m positive integers b 1 b 2 dots b m Choose some element a of A and some element b of B such that a b doesn t belong to A and doesn t belong to B For example if A 2 1 7 and B 1 3 4 we can choose 1 from A and 4 from B as number 5 1 4 doesn t belong to A and doesn t belong to B However we can t choose 2 from A and 1 from B as 3 2 1 belongs to B It can be shown that such a pair exists If there are multiple answers print any Choose and print any such two numbers ,"['#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n; scanf(""%d"",&n);\n\tint mx1=0,mx2=0;\n\tfor (int i=1,x;i<=n;++i) scanf(""%d"",&x),mx1=max(mx1,x);\n\tscanf(""%d"",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(""%d"",&x),mx2=max(mx2,x);\n\tprintf(""%d %d\\n"",mx1,mx2);\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 1, 0]",800,Let be the largest number in the array be the largest number in the array Then the number isn t present neither in the array nor in the array Indeed and is the largest number in the array so is not included in Similarly is not included in Thus you can select from from The asymptotics is if you find the largest element by sorting which many did or if you find it linearly 
Vasya likes taking part in Codeforces contests When a round is over Vasya follows all submissions in the system testing tab There are n solutions the i th of them should be tested on a i tests testing one solution on one test takes 1 second The solutions are judged in the order from 1 to n There are k testing processes which test solutions simultaneously Each of them can test at most one solution at a time At any time moment t when some testing process is not judging any solution it takes the first solution from the queue and tests it on each test in increasing order of the test ids Let this solution have id i then it is being tested on the first test from time moment t till time moment t 1 then on the second test till time moment t 2 and so on This solution is fully tested at time moment t a i and after that the testing process immediately starts testing another solution Consider some time moment let there be exactly m fully tested solutions by this moment There is a caption System testing d ,"['#include <bits/stdc++.h>                                                                                                                                                                                                                                                                                            \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace std;\n\nint n, k;\nint a[100001];\n\nint cur[100001];\nint last[100001];\n\nint used[100001];\n\nint sz;\n\nint main(){\n    #ifdef DIAS\n        freopen(""input.txt"", ""r"", stdin);\n        //freopen(""output.txt"", ""w"", stdout);\n    #elif NAME \n    \tfreopen(fn"".in"", ""r"", stdin);\n    \tfreopen(fn"".out"", ""w"", stdout);\n    #endif\n    cin >> n >> k;\n    for(int i = 1; i <= n; i++){\n    \tcin >> a[i];\n    }\n    for(int i = 1; i <= k; i++){\n    \tcur[i] = -1;\n    \tlast[i] = -1;\n    }\n    int cnt = 0, ans = 0;\n   \tfor(int i = 0; i <= 150 * n; i++){\n   \t\t\n \t  \tfor(int j = 1; j <= k; j++){\n\t\t\tif(last[j] == i){\n\t\t\t\tcur[j] = -1;\n\t\t\t\tlast[j] = -1;\n\t\t\t\tused[j] = 0;\n\t\t\t\tcnt ++;\n\t\t\t}          \t\n\t\t}\n\n   \t\tfor(int j = 1; j <= k; j++){\n   \t\t\tif(cur[j] == -1 && sz < n){\n   \t\t\t\tcur[j] = ++sz;\n   \t\t\t\tlast[j] = i + a[sz]; \n   \t\t\t}\n\t\t}\n        \n\n\t\tlong double y = 100.0 * cnt / n + 0.5;\n\t\tint x = y;\n\n\t\t\n\t\tfor(int j = 1; j <= k; j++){\n\t\t\tif(cur[j] != -1 && a[cur[j]] - (last[j] - i) + 1 == x && !used[j]){\n\t\t\t\tused[j] = 1;\n\t\t\t\tans ++;\n\t\t\t}\n\t\t}\n\n   \t}\n   \tcout << ans;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1600,Let s determine for each solution when it begins being tested It can be done for example by the following algorithm let s store for each testing process the time when it becomes free to test something initially all these numbers are zeroes then iterate over all solutions in the queue and for each of them we pick a process with minimal time say that it s the time when this solution begins being tested and then update the time when this process stops testing After we determined this we can easily know for each moment the number of solutions which are completely tested before this moment and then for each test of each solution just check the required condition of being interesting on this test 
Kostya is a progamer specializing in the discipline of Dota 2 Valve Corporation the developer of this game has recently released a new patch which turned the balance of the game upside down Kostya as the captain of the team realizes that the greatest responsibility lies on him so he wants to resort to the analysis of innovations patch from the mathematical point of view to choose the best heroes for his team in every game A Dota 2 match involves two teams each of them must choose some heroes that the players of the team are going to play for and it is forbidden to choose the same hero several times even in different teams In large electronic sports competitions where Kostya s team is going to participate the matches are held in the Captains Mode In this mode the captains select the heroes by making one of two possible actions in a certain predetermined order pick or ban To pick a hero for the team After the captain picks the picked hero goes to his team later one of a team members will play it and can no longer be selected by any of the teams To ban a hero After the ban the hero is not sent to any of the teams but it still can no longer be selected by any of the teams The team captain may miss a pick or a ban If he misses a pick a random hero is added to his team from those that were available at that moment and if he misses a ban no hero is banned as if there was no ban Kostya has already identified the strength of all the heroes based on the new patch fixes Of course Kostya knows the order of picks and bans The strength of a team is the sum of the strengths of the team s heroes and both teams that participate in the match seek to maximize the difference in strengths in their favor Help Kostya determine what team the first one or the second one has advantage in the match and how large the advantage is ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nchar c[123];\nint who[123], skill[123];\n\nint f[1234567];\nint kb[1234567];\n\nint main() {\n  int _n;\n  scanf(""%d"", &_n);\n  for (int i = 0; i < _n; i++) scanf(""%d"", skill + i);\n  sort(skill, skill + _n);\n  reverse(skill, skill + _n);\n  int m;\n  scanf(""%d"", &m);\n  for (int i = 0; i < m; i++) {\n    char ch = getchar();\n    while (ch != \'p\' && ch != \'b\') ch = getchar();\n    c[i] = ch;\n    scanf(""%d"", who + i);\n  }\n  kb[0] = 0;\n  for (int t = 1; t < (1 << m); t++) kb[t] = kb[t & (t - 1)] + 1;\n  f[(1 << m) - 1] = 0;\n  for (int t = (1 << m) - 2; t >= 0; t--) {\n    if (who[kb[t]] == 1) {\n      f[t] = -inf;\n      for (int i = 0; i < m; i++)\n        if (!(t & (1 << i))) {\n          int ft = f[t + (1 << i)];\n          if (c[kb[t]] == \'p\') ft += skill[i];\n          if (ft > f[t]) f[t] = ft;\n        }\n    } else {\n      f[t] = inf;\n      for (int i = 0; i < m; i++)\n        if (!(t & (1 << i))) {\n          int ft = f[t + (1 << i)];\n          if (c[kb[t]] == \'p\') ft -= skill[i];\n          if (ft < f[t]) f[t] = ft;\n        }\n    }\n  }\n  printf(""%d\\n"", f[0]);\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2200,There are some observations that do the problem very simple The first one is that we always should pick the strongest hero But we cannot say something similar about the bans in different situations different bans are the best But the most important observation is that we should consider only strongest heroes Indeed in every game where only strongest heroes are picked no hero except strongest can be picked That s why we don t need to ban them and therefore we don t need to consider them So now we have only 20 heroes It means we can solve the problem using the dynamic programming with bitmasks will be the difference between the teams strengths when only those heroes are picked or banned whose bits are set to 1 in the At every state we try to pick or ban every available hero and go to the other state The simpliest way to implement it is the recursion with memoization The answer will be stored in Unfortunately we couldn t estimate the real complexity of this problem despite it has the simple solution this solution is not so easy to think of standard 1500 points for problem C would be better and set too big TL many solutions written in C whose complexity is passed we should have been set TL to 1 second or even to 0 75 seconds So if you solved it in you may assume that you re just lucky and your correct verdict is Time Limit Exceeded Why it can be solved in There is no point of missing a ban if we ban the weakest hero nothing will change since the weakest hero won t be picked Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test 
Alice and Bob are playing a game There are n balls out of which k are special Each ball has a value associated with it The players play turn by turn In each turn the player randomly picks a ball and adds the value of the ball to their score which is 0 at the beginning of the game The selected ball is removed from the game If the ball was special the same player takes the next turn if at least one ball is remaining If the ball picked was not special the next player plays their turn They play this game until no balls are remaining in the game Alice plays first Find the expected score that both the players have at the end of the game modulo 10 9 7 Formally let M 10 9 7 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"['// Problem: E. I Love Balls// Contest: Codeforces - Codeforces Round #956 (Div. 2) and ByteRace 2024// URL: https://mirror.codeforces.com/contest/1983/problem/E// Memory Limit: 256 MB// Time Limit: 2000 ms// // Powered by CP Editor (https://cpeditor.org)\xa0// Author: EnucAI#include <bits/stdc++.h>\xa0#ifdef LOCAL#include ""debug.h""#else#define D(...) ((void)0)#endif\xa0using ll = long long;using ull = unsigned long long;using ld = long double;using vi = std::vector<int>;using pii = std::pair<int, int>;\xa0constexpr int inf = std::numeric_limits<int>::max() / 2;constexpr ll infll = std::numeric_limits<ll>::max() / 2;constexpr ld eps = 1e-8l;\xa0#define all(x) (x).begin(), (x).end()#define sz(x) ((int)((x).size()))#define rep(i, j, k) for (int i = (j); i <= (k); i++)#define per(i, j, k) for (int i = (j); i >= (k); i--)#define fi first#define se second#define mp std::make_pair#define pb push_back#define ppb pop_back#define eb emplace_back\xa0template <class X, class Y> void chkmax(X &x, const Y &y) { if (x < y) x = y; }template <class X, class Y> void chkmin(X &x, const Y &y) { if (x > y) x = y; }\xa0template <int P>class mod_int {  using Z = mod_int;\xa0private:  static int mo(int x) { return x < 0 ? x + P : x; }\xa0public:  int x;  int val() const { return x; }  mod_int() : x(0) {}  template <class T>  mod_int(const T &x_) : x(x_ >= 0 && x_ < P ? static_cast<int>(x_) : mo(static_cast<int>(x_ % P))) {}  bool operator==(const Z &rhs) const { return x == rhs.x; }  bool operator!=(const Z &rhs) const { return x != rhs.x; }  Z operator-() const { return Z(x ? P - x : 0); }  Z pow(ll k) const {    Z res = 1, t = *this;    while (k) {      if (k & 1) res *= t;      if (k >>= 1) t *= t;    }    return res;  }  Z &operator++() {    x < P - 1 ? ++x : x = 0;    return *this;  }  Z &operator--() {    x ? --x : x = P - 1;    return *this;  }  Z operator++(int) {    Z ret = x;    x < P - 1 ? ++x : x = 0;    return ret;  }  Z operator--(int) {    Z ret = x;    x ? --x : x = P - 1;    return ret;  }  Z inv() const { return pow(P - 2); }  Z &operator+=(const Z &rhs) {    (x += rhs.x) >= P && (x -= P);    return *this;  }  Z &operator-=(const Z &rhs) {    (x -= rhs.x) < 0 && (x += P);    return *this;  }  Z &operator*=(const Z &rhs) {    x = 1ULL * x * rhs.x % P;    return *this;  }  Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }#define setO(T, o)                                 \\  friend T operator o(const Z &lhs, const Z &rhs) {\\    Z res = lhs;                                   \\    return res o## = rhs;                          \\  }  setO(Z, +) setO(Z, -) setO(Z, *) setO(Z, /)#undef setO};constexpr int P = 1e9 + 7;using Z = mod_int<P>;\xa0constexpr int maxn = 4e5 + 5;\xa0int n, k, a[maxn];\xa0Z fac[maxn], invfac[maxn];Z c(int n, int m) { return fac[n] * invfac[m] * invfac[n - m]; }Z calc(int n, int m) { return m ? c(n + m - 1, m - 1) : !n; }\xa0void work() {  std::cin >> n >> k;  rep(i, 1, n) std::cin >> a[i];  Z sa = 0, sb = 0;  rep(i, 1, k) sa += a[i];  rep(i, k + 1, n) sb += a[i];  Z ans = sb * ((n - k + 1) / 2) / (n - k);  int m = n - k + 1, cnt = (m + 1) / 2;  fac[0] = 1;  rep(i, 1, n) fac[i] = fac[i - 1] * i;  invfac[n] = fac[n].inv();  per(i, n, 1) invfac[i - 1] = invfac[i] * i;  Z ways = calc(k, m);  rep(i, 0, k) {    Z val = sa * i / k;    ans += calc(i, cnt) * calc(k - i, m - cnt) / ways * val;  }  std::cout << ans.val() << \' \' << (sa + sb - ans).val() << \'\\n\';}\xa0int main() {  std::cin.tie(nullptr)->sync_with_stdio(false);  int t;  std::cin >> t;  while (t--) work();}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2300,When there are no special balls Alice and Bob alternately pick balls starting with Alice This means Alice picks balls if is odd or if is even The total value of all balls is On average Alice s score is With special balls the picking order can be interrupted allowing the same player to pick again We need to distribute special balls into possible positions gaps The expected number of special balls picked by Alice can be derived as the expected number of gaps encountered by Alice times the expected number of special balls per gap The formula is Expected value without special balls Expected special balls for Alice Expected normal balls for Alice when there are non zero special balls Therefore expected score of Alice Similarly expected score of Bob 
To stay woke and attentive during classes Karen needs some coffee Karen a coffee aficionado wants to know the optimal temperature for brewing the perfect cup of coffee Indeed she has spent some time reading several recipe books including the universally acclaimed The Art of the Covfefe She knows coffee recipes The th recipe suggests that coffee should be brewed between and degrees inclusive to achieve the optimal taste Karen thinks that a temperature is if at least recipes recommend it Karen has a rather fickle mind and so she asks questions In each question given that she only wants to prepare coffee with a temperature between and inclusive can you tell her how many admissible integer temperatures fall within the range ,"['//#pragma comment(linker,""/STACK:16777216"") /*16Mb*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <time.h>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\n\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define RFOR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))\n#define MP make_pair\n#define I insert\n#define mod 1000000007\n#define INF 2000000007\n#define PB push_back\n#define x0 sdfhrthrth\n#define x1 fdhttrlhn\n#define y0 kihrbdb\n#define y1 ugvrrtgtrg\n#define eps 1e-5\n#define X first\n#define Y second\n\nconst int MAXN = 300000;\n\nint n, k, q;\nint a[MAXN];\n\nint main()\n{\n    cin >> n >> k >> q;\n    FOR (i,0,n)\n    {\n        int x, y;\n        scanf(""%d%d"",&x,&y);\n        a[x]++;\n        a[y+1]--;\n    }\n    int bal = 0;\n    FOR (i,0,MAXN)\n    {\n        bal += a[i];\n        a[i] = (bal >= k);\n    }\n    FOR (i,1,MAXN) a[i]+=a[i-1];\n    FOR (i,0,q)\n    {\n        int x, y;\n        scanf(""%d%d"",&x,&y);\n        cout << a[y] - a[x-1] <<""\\n"";\n    }\n}']","[0, 0, 1, 0, 1, 0, 0, 1, 0, 0]",1400,There are two separate tasks here Efficiently generate an array where is the number of recipes that recommend temperature Efficiently answer queries how many numbers are at least where is fixed across all queries There are some solutions to this task using advanced data structures or algorithms For example a conceptually straightforward idea is the following create a segment tree We can treat all recipes as range update queries which we can do efficiently in where is the largest or time using lazy propagation After all recipes we replace all by if it s at least and otherwise Afterwards each of the next queries is a basic range sum query which can be done simply in time Other solutions exist too Fenwick trees with range updates event sorting sqrt decomposition with binary search Mo s algorithm and so on These solutions all pass but they are all overkill for this task A very simple solution is as follows Initialize with all zeroes For recipe that recommends temperatures between and we should increment and decrement Cumulate all values That is set to This can be done with one pass through the array Now magically is now the number of recipes that recommend temperature If is at least set it to otherwise set it to Cumulate all values again Now every query that asks for the number of admissible temperatures between and can be answered simply as This runs in which is really fast Note that if your solution does this and still runs quite slow chances are your solution is using slower input methods We raised the time limit to 2 5 seconds in this problem in order to avoid failing slow input solutions 
Patrick calls a substring dagger of a binary string ddagger if this substring contains exactly one Help Patrick count the number of binary strings s such that s contains exactly n good substrings and has no good substring of length strictly greater than k Note that substrings are differentiated by their location in the string so if s you should count both occurrences of dagger A string a is a substring of a string b if a can be obtained from b by the deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ddagger A binary string is a string that only contains the characters and ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int N=2510, mod=998244353;\nint f[N][N], n, k;\n\nvoid add(int &x, int y){\n   x=x+y>=mod?x+y-mod:x+y;\n}\n\nvoid solve(){\n   cin >> n >> k;\n   for (int i=0; i<=n; ++i) f[0][i]=1;\n   for (int i=1; i<=n; ++i){\n      for (int j=0; j<=i; ++j){\n         for (int t=0; t<=n; ++t){\n            int d=i-(j+1)*(t+1);\n            if (d<0 || j+t+1>k) break;\n            add(f[i][j], f[d][t]);\n         }\n      }\n   }\n   int ans=0;\n   for (int i=0; i<=n; ++i) add(ans, f[n][i]);\n   cout << ans << '\\n';\n   for (int i=0; i<=n; ++i) for (int j=0; j<=n; ++j) f[i][j]=0;\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n""]","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2100,Let s first solve the problem where we are given some string s and must count the number of good substrings To do this we use the technique of counting contributions For every 1 in s we find the number of good substrings containing that 1 Consider the following example 00001 a10001 a200000001 a30001 a4000 a5 The number of good substrings in this example is a1a2 a2a3 a3a4 a4a5 We can create such array for any string s and the number of good substrings of s is the sum of the products of adjacent elements of the array This motivates us to reformulate the problem Instead we count the number of arrays a1 a2 am such that every element is positive and the sum of the products of adjacent elements is exactly equal to n Furthermore every pair of adjacent elements should have sum minus 1 be less than or equal to k We can solve this with dynamic programming dpi j number of arrays with sum i and last element j dpi j p 1min ij k j 1 dpi j p p The key observation is that we only have to iterate p up to ij since if p is any greater j p will exceed i At j 1 we will iterate over at most i1 values of p At j 2 we will iterate over at most i2 values of p In total at each i we will iterate over at most i1 i2 ii ilogi values of p Thus the time complexity of our solution is O nklogn 
You are given a permutation p 1 p 2 dots p n A permutation of length n is a sequence such that each integer between 1 and n occurs exactly once in the sequence Find the number of pairs of indices l r 1 le l le r le n such that the value of the median of p l p l 1 dots p r is exactly the given number m The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if a 4 2 7 5 then its median is 4 since after sorting the sequence it will look like 2 4 5 7 and the left of two middle elements is equal to 4 The median of 7 1 2 9 6 equals 6 since after sorting the value 6 will be in the middle of the sequence Write a program to find the number of pairs of indices l r 1 le l le r le n such that the value of the median of p l p l 1 dots p r is exactly the given number m ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, pos;\n    vector<int> A;\n    map<int, int> B;\n    ll sc;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    cin >> n >> m;\n\n    A.assign(n, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        if (A[i] == m) {\n            pos = i;\n        }\n    }\n\n    int cur = 0;\n    B[0]++;\n    for (int i = pos+1; i < n; i++) {\n        if (A[i] > m) {\n            cur++;\n        } else {\n            cur--;\n        }\n        B[cur]++;\n    }\n\n    cur = 0;\n    for (int i = pos-1; i >= 0; i--) {\n        if (A[i] > m) {\n            cur++;\n        } else {\n            cur--;\n        }\n        sc += B[-cur] + B[-cur + 1];\n    }\n\n    sc += B[0];\n    sc += B[1];\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1800,The segment has median equals if and only if belongs to it and or where is number of elements in that strictly less than and is number of elements in that strictly greater than Here we ve used a fact that is a permutation on there is exactly one occurrence of In other words belongs and the value equals or Calculate prefix sums where the value on the prefix of the length i e on the subarray For fixed value it is easy to calculate number of such that is suitable At first check that met on Valid values are such indices that no on and or Let s maintain number of prefix sums to the left of for each value We can use just a map where is number of such indices that and is to the left of So for each that contains do where is the current value Time complexity is if a standard map is used or if classical array for is used remember about possible negative indices just use an offset 
A forest is an undirected graph without cycles not necessarily connected Mocha and Diana are friends in Zhijiang both of them have a forest with nodes numbered from 1 to n and they would like to add edges to their forests such that After adding edges both of their graphs are still forests They add the same edges That is if an edge u v is added to Mocha s forest then an edge u v is added to Diana s forest and vice versa Mocha and Diana want to know the maximum number of edges they can add and which edges to add ,"['#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,ssse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#include <bits/stdc++.h>\n//#define int long long\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define dwn(i, a, b) for(int i = a; i >= b; i--)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nconst int INF = 0x3f3f3f3f;\nconst int NINF = -INF - 1;\nconst int N = 1e3 + 10;\nconst int mod = 1e9+7;\nint n, m1, m2, fa[2][N];\nvoid init(int m) { rep(i, 1, m) fa[0][i] = fa[1][i] = i; }\nint get(int i, int x) { return fa[i][x] == x ? x : fa[i][x] = get(i, fa[i][x]); }\nint solve() {\n    std::vector< std::pair<int, int> > ans;\n    rep(i, 1, n) {\n        rep(j, i+1, n) {\n            if(get(0, i) != get(0, j) && get(1, i) != get(1, j)) {\n                fa[0][get(0, i)] = get(0, j);\n                fa[1][get(1, i)] = get(1, j);\n                ans.eb(i, j);\n            }\n        }\n    }\n    std::cout << ans.size() <<std::endl;\n    for(auto x : ans) std::cout << x.fi << "" "" << x.se << std::endl;\n    return 0;\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n >> m1 >> m2;\n    init(n);\n    rep(i, 1, m1) {\n        int u, v; std::cin >> u >> v;\n        fa[0][get(0, u)] = get(0, v);\n    }\n    rep(i, 1, m2) {\n        int u, v; std::cin >> u >> v;\n        fa[1][get(1, u)] = get(1, v);\n    }\n    return solve();\n}']","[1, 0, 0, 0, 0, 1, 1, 0, 0, 1]",1400,In the final situation if one forest has more than one tree we choose two trees from it such as tree and tree Then we consider node in and node in they must be connected in another forest We can easily find node is connected with all the nodes in and node is connected with all the nodes in So nodes in and are in the same tree in another forest If we consider other trees we can get the same conclusion Hence nodes in another forest form only one tree So we can enumerate every pair and check if this edge can be added When the edge can be added we can just add it This can be done in the complexity of 
An array b 1 b 2 ldots b n of positive integers is good if all the sums of two adjacent elements are equal to the same value More formally the array is good if there exists a k such that b 1 b 2 b 2 b 3 ldots b n 1 b n k Doremy has an array a of length n Now Doremy can permute its elements change their order however she wants Determine if she can make the array good ,"['#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int maxn=100010;\nil int read(){\n\tint x=0;\n\tchar c=getchar();\n\tfor(;!(c>=\'0\'&&c<=\'9\');c=getchar());\n\tfor(;c>=\'0\'&&c<=\'9\';c=getchar())\n\t\tx=(x<<1)+(x<<3)+c-\'0\';\n\treturn x;\n}\nint T,n;\nint a[maxn];\nbool vis[maxn];\nint tap[maxn];\nint st[maxn],top;\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tn=read(); int cnt=0; top=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ta[i]=read();\n\t\tfor(int i=1;i<=n;tap[a[i]]++,i++)\n\t\t\tif(!vis[a[i]]) vis[a[i]]=1,st[++top]=a[i];\n\t\tif(top==1) printf(""Yes\\n"");\n\t\telse if(top==2&&abs(tap[st[1]]-tap[st[2]])<=1) printf(""Yes\\n"");\n\t\telse printf(""No\\n"");\n\t\tfor(int i=1;i<=n;i++) vis[a[i]]=tap[a[i]]=0;\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",800,Statement says Let s write it as This is just which means the positions with the same parity should contain same value We know that there are odd numbers and even numbers in Therefore if and only if we can find same numbers and the remaining are also the same numbers the answer is All cases can be classified into these categories All numbers are the same like The answer is There are two different numbers like The answer is if and only if one of the number appears exactly times For example and are while and is There are three or more different numbers like The answer is Time complexity 
It is a very important day for Katya She has a test in a programming class As always she was given an interesting problem that she solved very fast Can you solve that problem You are given n ordered segments sets Each segment can be represented as a pair of two integers l r where l leq r Each set can contain an arbitrary number of segments even 0 It is possible that some segments are equal You are also given m queries each of them can be represented as four numbers a b x y For each segment find out whether it is true that each set p a leq p leq b contains at least one segment l r that lies entirely on the segment x y that is x leq l leq r leq y Find out the answer to each query Note that you need to solve this problem That is you will get a new query only after you print the answer for the previous query ,"['#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 300050;\nconst int NN = N * 20;\nconst int INF = 2000000000;\n\nint root[N], maxv[NN], lc[NN], rc[NN], cnt = 1;\n\nvoid insert(int &o, int l, int r, int p, int y) {\n  maxv[cnt] = maxv[o];\n  lc[cnt] = lc[o];\n  rc[cnt] = rc[o];\n  o = cnt++;\n  if (l == r) maxv[o] = std::min(maxv[o], y);\n  else {\n    int mid = (l + r) / 2;\n    if (p <= mid) insert(lc[o], l, mid, p, y);\n    else insert(rc[o], mid + 1, r, p, y);\n    maxv[o] = std::max(maxv[lc[o]], maxv[rc[o]]);\n  }\n}\n\nint query(int o, int l, int r, int L, int R) {\n  if (l > R || L > r) return 0;\n  if (!o) return INF;\n  if (L <= l && r <= R) return maxv[o];\n  int mid = (l + r) / 2;\n  return std::max(query(lc[o], l, mid, L, R), query(rc[o], mid + 1, r, L, R));\n}\n\nstruct Interval {\n  int l, r, p;\n  friend bool operator<(const Interval &a, const Interval &b) {\n    return a.l > b.l;\n  }\n} I[N];\n\nint n, m, k;\n\nint main(){\n  maxv[0] = INF;\n  lc[0] = rc[0] = 0;\n  scanf(""%d%d%d"", &n, &m, &k);\n  for (int i = 0; i < k; ++i)\n    scanf(""%d%d%d"", &I[i].l, &I[i].r, &I[i].p);\n  std::sort(I, I + k);\n  root[0] = 0;\n  for (int i = 0; i < k; ++i) {\n    //printf(""  %d %d %d %d\\n"", i, I[i].l, I[i].r, I[i].p);\n    insert(root[i + 1] = root[i], 1, n, I[i].p, I[i].r);\n  }\n  while (m--) {\n    int a, b, x, y;\n    scanf(""%d%d%d%d"", &a, &b, &x, &y);\n    Interval t;\n    t.l = x;\n    int i = std::upper_bound(I, I + k, t) - I;\n    //printf(""  %d "", i);\n    puts(query(root[i], 1, n, a, b) <= y ? ""yes"" : ""no"");\n    fflush(stdout);\n  }\n  return 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0]",2400,Let s have an array in which we will store each segment and the number of the set to which it belongs Sort this array in the non decreasing order of the left border If the left border is equal we sort in random order Now consider any query We should find the first position where the left border of the segment is greater than or equal to If there is no such position then it is obvious that the answer will be since there is no set that contains at least one suitable segment Otherwise we are interested only in the segments from the position that we have found to the last segment in the array We can forget about the rest Now let s among these segments for each set with a number from to find the minimum number such that there exists at least one segment that belongs to this set and its right bound is note that we consider only those segments whose left bound is greater than or equal to If for some segment this number is greater than then the answer is Otherwise the answer is Let s create a persistent segment tree where for each set we keep its number We will update our values in reverse order from the last segment to the first one After hanging the value of the new we will save the current version in our segment tree Then how to respond to requests Let s find the position starting from which all the left borders of our segments will be at least After that take the version of the persistent tree of segments that was added immediately after adding this segment And in this segment tree we take the minimum on the segment from to If our minimum is greater than then the answer is Otherwise the answer is 
LuoTianyi gives you dagger string s and she wants you to find out the length of the longest non empty subsequence ddagger of s which is not a palindrome string If there is no such subsequence output 1 instead dagger A palindrome is a string that reads the same backward as forward For example strings are palindromes but strings are not ddagger A string a is a subsequence of a string b if a can be obtained from b by deletion of several possibly zero or all characters from b For example strings are subsequences of string but strings are not ,"['#pragma GCC optimize(""Ofast,unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")\n#include<bits/stdc++.h>\n#define int long long\nconst int N=2e5+5,M=305;\nusing namespace std;\nint n,f1,f2;\nstring s;\nvoid solve()\n{\n\tcin>>s;f1=f2=0;\n\tfor(int i=1;i<s.size();i++)\n\tif(s[i]!=s[i-1]){f2=1;break;}\n\tif(!f2)cout<<-1<<\'\\n\';\nelse cout<<s.size()-1<<\'\\n\';\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800,Consider the substring of s from the second character to the last or s2s3 sn If it s not palindrome then the answer must be n 1 What if it s palindrome This implies that s2 sn s3 sn 1 and so on Meanwhile the fact that s is palindrome implies s1 sn s2 sn 1 etc So we get s1 sn s2 sn 1 or that all characters in s is the same In this situation every subsequence of s is palindrome of course so the answer should be 1 
Two polar bears Menshykov and Uslada from the St Petersburg zoo and elephant Horace from the Kiev zoo got six sticks to play with and assess the animals creativity Menshykov Uslada and Horace decided to make either an elephant or a bear from those sticks They can make an animal from sticks in the following way Four sticks represent the animal s legs these sticks should have the same length Two remaining sticks represent the animal s head and body The bear s head stick must be shorter than the body stick The elephant however has a long trunk so his head stick must be as long as the body stick Note that there are no limits on the relations between the leg sticks and the head and body sticks Your task is to find out which animal can be made from the given stick set The zoo keeper wants the sticks back after the game so they must never be broken even bears understand it ,"['#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nint main(){\n    map<int,int> S;\n    S.clear();\n    int f[6];\n    for(int i=0;i<6;i++){\n        scanf(""%d"",&f[i]);\n        S[f[i]]++;\n    }\n    bool flag=false;\n    for(int i=0;i<6;i++)\n        if(S[f[i]]>=4){\n            S[f[i]]-=4;\n            flag=true;\n            break;\n        }\n    if(!flag){\n        puts(""Alien"");\n        return 0;\n    }\n    flag=false;\n    for(int i=0;i<6;i++)\n        if(S[f[i]]==2)flag=true;\n    if(flag)puts(""Elephant"");\n    else puts(""Bear"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100,Given six sticks and their lengths we need to decide whether we can make an elephant or a bear using those sticks The only common requirement for both animals is that four leg sticks should have same length This means that the answer Alien should be given only if we can t find four sticks for the legs Otherwise we will be able to make some animal The type of the animal will depend on the relation of the remaining sticks lengths If they are equal then it will an elephant if they are different we will have a bear So this algorithm should solve the problem Find the number which appears at least four times in the input If no such number exist then the answer is Alien Otherwise remove four entries of that number from the input After removing that number you will have two numbers left compare them and decide whether it s an elephant or a bear One shortcut for this problem might be to sort the input array then if it s a bear or an elephant then 3rd and 4th elements in the sorted should be animal s legs So you can assume that one of these numbers is the length of the leg and count how many times you see this number in the input Author s solution 7977022 Since the numbers in the input are very small you can implement brute force solution as well By brute force solution in this case I mean that you can actually check all possible values for leg length head length and body length If in total they give the same set as the input then you found a matching all you need is to check whether it s a bear or an elephant And it s an alien if you checked all possible combinations and found nothing matching to the input Though in this case the brute force solution is not easier than another one Checking all possible lengths solution 7975645 It seems that there were two common mistakes people were making in this problem Not taking into account that legs can be of the same length as body or head So you can t just count the number of distinct numbers in the input to decide which type of animal is that We assumed that people might make such a mistake there was a relevant warning in the statement Trying to sort the input and then check whether some elements in this array are equal to other elements and based on this comparison decide which type of animal is that People were simply making mistakes when deciding which elements to compare The correct way to implement this is Solution 7977214 This solution seems to be shorter but there are many failed solutions like this because people were not paying enough attention to the details So I would prefer implementing more straightforward approach Hope you liked the pictures 
There is a n times m grid You are standing at cell 1 1 and your goal is to finish at cell n m You can move to the neighboring cells to the right or down In other words suppose you are standing at cell x y You can move right to the cell x y 1 it costs x burles move down to the cell x 1 y it costs y burles Can you reach cell n m spending k burles ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int64_t N, M, K;\n    cin >> N >> M >> K;\n    cout << (K == N * M - 1 ? ""YES"" : ""NO"") << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",800,Note that whichever path you choose the total cost will be the same If you know that the cost is the same then it s not hard to calculate it It s equal to So the task is to check is equal to or not The constant cost may be proved by induction on for cost is For a fixed there are only two last steps you can make either from with cost the total cost is or from with cost the total cost is So whichever path you choose the total cost is the same 
You are given n intervals in form l r on a number line You are also given m queries in form x y What is the minimal number of intervals you have to take so that every point from x to y is covered by at least one of them If you can t choose intervals so that every point from x to y is covered then print for that query ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst int INF = (int)1e9 + 7;\n\n// Finds last with value <= val\ntemplate<class T>\nint bins(const vector<T>& vec, T val) {\n\tint low = -1;\n\tint high = (int)vec.size() - 1;\n\twhile(low != high) {\n\t\tint mid = (low + high + 1) >> 1;\n\t\tif (vec[mid] <= val) low = mid;\n\t\telse high = mid - 1;\n\t}\n\treturn low;\n}\n\nconst int H = 18;\nconst int N = 1<<H;\nint nxt[N][H];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t// Optimal to pick interval with a <= x, with maximum b\n\t// Find for every interval the best next interval. Do jump array.\n\t// Remove useless intervals for easy handling\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<pair<int, int>> vec(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tvec[i] = {a, -b};\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int i = 0; i < n; ++i) vec[i].second *= -1;\n\t\n\t// Remove useless intervals\n\tint r = 0;\n\tfor (int i = 0; i+r < n; ++i) {\n\t\tswap(vec[i], vec[i+r]);\n\t\tif (i > 0 && vec[i-1].second >= vec[i].second) {\n\t\t\t++r;\n\t\t\t--i;\n\t\t}\n\t}\n\tn -= r;\n\tvec.resize(n);\n\n\t// for (auto pr : vec) cout << pr.first << \' \' << pr.second << ""; ""; cout << endl;\n\n\t// Find next intervals\n\tfor (int i = 0; i < n; ++i) {\n\t\tnxt[i][0] = bins(vec, {vec[i].second, INF});\n\t}\n\tfor (int h = 1; h < H; ++h) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tnxt[i][h] = nxt[nxt[i][h-1]][h-1];\n\t\t}\n\t}\n\n\tfor (int qi = 0; qi < q; ++qi) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint i = bins(vec, {x, INF});\n\t\tint res = -1;\n\t\tif (i != -1) {\n\t\t\tres = 1;\n\t\t\tfor (int h = H-1; h >= 0; --h) {\n\t\t\t\tint j = nxt[i][h];\n\t\t\t\tif (vec[j].second < y) {\n\t\t\t\t\tres += (1<<h);\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vec[i].second < y) {\n\t\t\t\t++res;\n\t\t\t\ti = nxt[i][0];\n\t\t\t}\n\t\t\tif (vec[i].second < y) res = -1;\n\t\t}\n\t\tcout << res << \'\\n\';\n\t}\n}\n\n\n\n\n\n\n\n\n\n']","[1, 0, 1, 1, 1, 0, 0, 0, 0, 0]",2200,Let s take a look at a naive approach at first That approach is greedy Let s find such an interval which starts to the left or at and ends as much to the right as possible Set to its right border Continue until either no interval can be found or is reached The proof basically goes like this Let there be some smaller set of intervals which cover the query these can be sorted by left border obviously their left borders are pairwise distinct Compare that set to the greedy one take a look at the first position where best set s interval has his less than the greedy set s You can see that choosing interval greedily will still allow to have the rest of best set intervals making the greedy choice optimal Let s implement it in For each position from to you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible To do this sort all intervals by their left border then iterate over positions while maintaining the maximum right border achieved by intervals starting to the left or at the current position The query is now straightforward Now there are two main ways to optimize it You can do it binary lifting style for each interval or position precalculate the index of the interval taken last after taking intervals greedily and use this data to answer queries in You can also do it path compression style Let s process the queries in the increasing order of their right borders Now do greedy algorithm but for each interval you use remember the index of the last reached interval Now the part with answering queries is in total because each interval will be jumped from no more than once Overall complexity 
You are given an integer n Find a sequence of n integers a 1 a 2 dots a n such that 1 leq a i leq 10 9 for all i and max a 1 a 2 dots a n min a 1 a 2 dots a n sqrt a 1 a 2 dots a n It can be proven that there exists a sequence of integers that satisfies all the conditions above ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=4e5+1,mod=998244353;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n,a[N];\nV input(){\n\t// 怎么全是构造题\n\tn = getint();\n\t// 最大减最小为根号？\n\t// ai 还得互不相同\n\t// 吐血\n\t// 居然还保证存在\n\t// \n\t// return 0;\n\tif(n%2==0){\n\t\tFOR(i,1,n/2)\n\t\t\tcout<<n+i<<\' \'<<n-i<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n\telse{\n\t\tint d = n/2;\n\t\tFOR(i,0,d-1)\n\t\t\tcout<<n-i<<\' \';\n\t\tFOR(i,0,d)\n\t\t\tcout<<n+3+i<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n\t// FOR(i,1,10)\n\t// \tFOR(j,i+1,10)\n\t\t\t// FOR(k,1,10)\n\t\t\t// \tFOR(o,k+1,10)\n\t\t\t// \t\tFOR(p,o+1,10){\n\t\t\t// \tif((p-k)*(p-k) == (k+o+p)){\n\t\t\t// \t\tcout<<k<<\' \' <<o<<\' \' <<p<<\'\\n\';\n\t\t\t// \t\t// cout<<i<<\' \'<<j<<\' \'<<k<<\' \' <<o<<\' \' <<p<<\'\\n\';\n\t\t\t// \t\t// return 0;\n\t\t\t// \t}\n\t\t\t\t\t\n\n\t\t\t// }\n\n\t// return 0;\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 1, 1, 1, 0, 0]",1800,Let us consider the cases when is odd and when its even is odd First we can start with the consecutive distinct numbers centered at The minimum maximum difference is and the sum is If we add 2 to each number the minimum maximum difference remains the same and the sum increases to Now we can decrease the minimum by 1 and the increase the maximum by 1 The sum remains at while the difference increases to To make the sum equal we can increase the 2nd last number by 1 which we can do since we previously increased the maximum by 1 As an example this sequence is followed for 3 4 5 6 7 centered at 5 6 7 8 9 increase by 4 6 7 8 10 shift min max 4 6 7 9 10 shift 2nd last is even We can let The difference between the minimum and maximum is and the sum of the numbers equals so this is valid Other solutions exist only one is described here 
Today hedgehog Filya went to school for the very first time Teacher gave him a homework which Filya was unable to complete without your help Filya is given an array of non negative integers First he pick an integer and then he adds to some elements of the array no more than once subtract from some other elements also no more than once and do no change other elements He wants all elements of the array to be equal Now he wonders if it s possible to pick such integer and change some elements of the array using this in order to make all elements equal ,"['#include <cstdio>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    //freopen(""tema.in"", ""r"", stdin);\n    //freopen(""tema.out"", ""w"", stdout);\n    int n, first = -1, second = -1, third = -1;\n    scanf(""%d"", &n);\n    for (int i = 1; i <= n; i++) {\n        int x;\n        scanf(""%d"", &x);\n        if (first == -1)\n            first = x;\n        else\n            if (first != x)\n                if (second == -1)\n                    second = x;\n                else\n                    if (x != second)\n                        if (third == -1)\n                            third = x;\n                        else\n                            if (third != x) {\n                                printf(""NO\\n"");\n                                return 0;\n                            }\n    }\n    if (third == -1 || second == -1) {\n        printf(""YES\\n"");\n        return 0;\n    }\n    int a = first, b = second, c = third;\n    first = min(a, min(b, c));\n    third = max(a, max(b, c));\n    second = a + b + c - first - third;\n    if (second - first != third - second) {\n        printf(""NO\\n"");\n        return 0;\n    }\n    printf(""YES\\n"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",1200,Answer can be calculated according to next options 1 If all numbers are equal answer is Yes 2 If there are two distinct numbers in the array answer is Yes 3 If there are at least four distinct numbers in the array answer is No 4 In other case lets there are three distinct numbers answer is Yes if and only if 
One fall day Joe got bored because he couldn t find himself something interesting to do Marty suggested Joe to generate a string of length n to entertain him somehow It didn t seem particularly difficult but Joe s generated string had to follow these rules the string may only contain characters or the maximum length of a substring of this string that is a palindrome does not exceed k A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end For example strings are substrings of a string while strings are not A string is a palindrome if it reads the same from the left to the right and from the right to the left For example strings and are palindromes while strings and are not Now Joe wants to find any correct string Help him It can be proven that the answer always exists under the given constraints ,"['//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<"" "";cout<<""\\n"";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        int n, k;\n        cin>>n>>k;\n        string ans="""";\n        for(int i=0;i<n;i++)\n        ans+=(char)((i%3)+\'a\');\n        cout<<ans<<""\\n"";\n    }\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",800,Let s note that the string like abcabcabcabc has only palindromes of length 1 what means it is suitable for us in all cases 
For the simplicity let s say that the Death Note is a notebook that kills a person when their name is written in it It s easy to kill with it but it s pretty hard to keep track of people you haven t killed and still plan to You decided to make a Death Database Management System a computer program that provides the easy access to the database of possible victims Let me describe its specifications to you Let s define a victim entity a victim has a name not necessarily unique that consists only of lowercase Latin letters and an integer suspicion value At the start of the program the user enters a list of n victim names into a database each suspicion value is set to 0 Then the user makes queries of two types 1 i x set the suspicion value of the i th victim to x 2 q given a string q find the maximum suspicion value of a victim whose name is a contiguous substring of q Just to remind you this program doesn t kill people it only helps to search for the names to write down in an actual notebook Thus the list of the victims in the database doesn t change throughout the queries What are you waiting for Write that program now ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nstruct SegTreeNode {\n\tint l, r;\n\tint val;\n\n\tSegTreeNode() : l(-1), r(-1), val(-1) {}\n\tSegTreeNode(int _l, int _r) : l(_l), r(_r), val(-1) {}\n};\nstruct SegmentTree {\n\tvector<SegTreeNode> tree;\n\tint L;\n\n\tSegmentTree() : tree(), L(-1) {}\n\tSegmentTree(int _L) {\n\t\tL = _L;\n\t\twhile(L & (L - 1)) L++;\n\t\ttree.resize(2 * L);\n\t\tfor (int i = 0; i < L; i++)\n\t\t\ttree[L + i] = SegTreeNode(i, i + 1);\n\t\tfor (int i = L - 1; i > 0; i--)\n\t\t\ttree[i] = SegTreeNode(tree[2 * i].l, tree[2 * i + 1].r);\n\t}\n\n\tvoid putInPoint(int v, int x) {\n\t\tv += L;\n\t\ttree[v].val = x;\n\t\twhile(v > 1) {\n\t\t\tv >>= 1;\n\t\t\ttree[v].val = max(tree[2 * v].val, tree[2 * v + 1].val);\n\t\t}\n\t}\n\tint getMax(int v, int l, int r) {\n\t\tif (l <= tree[v].l && tree[v].r <= r) return tree[v].val;\n\t\tif (l >= tree[v].r || tree[v].l >= r) return -1;\n\t\treturn max(getMax(2 * v, l, r), getMax(2 * v + 1, l, r));\n\t}\n};\n\nconst int N = 300300;\nconst int A = 26;\nint n, q;\nint go[N][A];\nint suffLink[N];\nint m;\nchar s[N];\nint a[N];\nint myVert[N];\nmultiset<int> setik[N];\nvector<int> g[N];\nint Q[N];\nint topQ;\nint sz[N];\nint info[N][2];\nint treeSz[N];\nint treePar[N];\nSegmentTree trees[N];\n\nvoid dfsSz(int v) {\n\tsz[v] = 1;\n\tfor (int u : g[v]) {\n\t\tdfsSz(u);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nvoid dfsHLD(int v, int id, int p) {\n\tinfo[v][0] = id;\n\tinfo[v][1] = p;\n\ttreeSz[id] = max(treeSz[id], p + 1);\n\tint big = -1;\n\tfor (int u : g[v]) {\n\t\tif (big == -1 || sz[big] < sz[u])\n\t\t\tbig = u;\n\t}\n\tfor (int u : g[v]) {\n\t\tif (u == big) {\n\t\t\tdfsHLD(u, id, p + 1);\n\t\t} else {\n\t\t\ttreePar[m] = v;\n\t\t\tm++;\n\t\t\tdfsHLD(u, m - 1, 0);\n\t\t}\n\t}\n}\n\nvoid prepare() {\n\tdfsSz(0);\n\tm = 1;\n\ttreePar[0] = -1;\n\tdfsHLD(0, 0, 0);\n\tfor (int i = 0; i < m; i++)\n\t\ttrees[i] = SegmentTree(treeSz[i]);\n}\n\nvoid setVertex(int v, int x) {\n\tint id = info[v][0];\n\ttrees[id].putInPoint(info[v][1], x);\n}\nint getVertex(int v) {\n\tint ans = -1;\n\twhile(v != -1) {\n\t\tint id = info[v][0];\n\t\tans = max(ans, trees[id].getMax(1, 0, info[v][1] + 1));\n\t\tv = treePar[id];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &q);\n\tm = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%s"", s);\n\t\tint L = strlen(s);\n\t\tint v = 0;\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tint c = (int)(s[j] - \'a\');\n\t\t\tif (go[v][c] == 0) go[v][c] = m++;\n\t\t\tv = go[v][c];\n\t\t}\n\t\tmyVert[i] = v;\n\t}\n\tQ[topQ++] = 0;\n\tsuffLink[0] = -1;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = Q[i];\n\t\tfor (int c = 0; c < A; c++) {\n\t\t\tif (go[v][c] == 0) continue;\n\t\t\tint u = go[v][c];\n\t\t\tint w = suffLink[v];\n\t\t\twhile(w != -1 && go[w][c] == 0) w = suffLink[w];\n\t\t\tif (w == -1)\n\t\t\t\tw = 0;\n\t\t\telse\n\t\t\t\tw = go[w][c];\n\t\t\tsuffLink[u] = w;\n\t\t\tg[w].push_back(u);\n\t\t\tQ[topQ++] = u;\n\t\t}\n\t}\n\tprepare();\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = myVert[i];\n\t\tsetik[v].insert(0);\n\t\tsetVertex(v, 0);\n\t}\n\twhile(q--) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tif (t == 1) {\n\t\t\tint p, v, x;\n\t\t\tscanf(""%d%d"", &p, &x);\n\t\t\tp--;\n\t\t\tv = myVert[p];\n\t\t\tsetik[v].erase(setik[v].find(a[p]));\n\t\t\ta[p] = x;\n\t\t\tsetik[v].insert(x);\n\t\t\tsetVertex(v, *setik[v].rbegin());\n\t\t} else {\n\t\t\tscanf(""%s"", s);\n\t\t\tint L = strlen(s);\n\t\t\tint v = 0;\n\t\t\tint ans = -1;\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint c = (int)(s[i] - \'a\');\n\t\t\t\twhile(v != -1 && go[v][c] == 0) v = suffLink[v];\n\t\t\t\tif (v == -1)\n\t\t\t\t\tv = 0;\n\t\t\t\telse\n\t\t\t\t\tv = go[v][c];\n\t\t\t\tans = max(ans, getVertex(v));\n\t\t\t}\n\t\t\tprintf(""%d\\n"", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2600,I m feeling extremely amused by the power of Aho Corasick lately so I will describe two solutions of this problem with it Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler I also want to mention I m quite proud of the name I came up with for that task First let s assume that the words in the dictionary are unique Build an Aho Corasick automaton on the dictionary Then build the tree of its suffix links For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position To be exact at most one word per unique word length Thus that s bounded by the square root of the total length For that reason you can iterate over all the words that end in all positions of the queries in How to do that fast For each vertex of the automaton precalculate the closest vertex up the suffix link tree that s a terminal Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root Take the maximum value over all the visited terminals The second solution actually involves an extra data structure on top of that No it s not HLD You are boring for using it Let s abuse the fact that you are allowed to solve the problem fully offline For each word you can save the list of pairs time value of the times the value of the word changed For each vertex of the automaton you can save all the times that vertex has been queried from Now traverse the tree with dfs When you enter the vertex you want to apply all the updates that are saved for the words that are terminals here What are the updates From the list we obtained for a word you can generate such triples that this word had value from query to query Don t forget the value from to the first update to this word Then ask all the queries Then go to children When you exit the vertex you want all the updates to be gone Well there is a trick for these kinds of operations it s called rollbacks Maintain a segment tree over the query times the th leaf should store the maximum value during the th query The update operation updates the range with the new possible maximum How to avoid using lazy propagation with such updates Well on point query you can collect all the values from the segtree nodes you visit on your way down That way you don t have to push the updates all the way to the leaves Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically That solution works in 
Ilya plays a card game by the following rules A player has several cards Each card contains two non negative integers inscribed one at the top of the card and one at the bottom At the beginning of the round the player chooses one of his cards to play it If the top of the card contains number and the bottom contains number then when the player is playing the card he gets points and also gets the opportunity to play additional cards After the playing the card is discarded More formally let s say that there is a counter of the cards that can be played At the beginning of the round the counter equals one When a card is played the counter decreases by one for the played card and increases by the number which is written at the bottom of the card Then the played card is discarded If after that the counter is not equal to zero the player gets the opportunity to play another card from the remaining cards The round ends when the counter reaches zero or the player runs out of cards Of course Ilya wants to get as many points as possible Can you determine the maximum number of points he can score provided that you know his cards ,"['#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    vector<pair<int, int> > v;\n    for (int i=0; i < n; i++) {\n        int a, b; cin >> a >> b;\n        v.push_back(make_pair(b, a));\n    }\n    sort(v.rbegin(), v.rend());\n    int pt = 0, count = 1;\n    for (int i=0; i < n; i++) {\n        int b = v[i].first, a = v[i].second;\n        pt += a;\n        count += b-1;\n        if (count == 0) break;\n    }\n    cout << pt << endl;\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1100,Clearly we can play the cards with 0 first as each of them gives at least one extra move After that the number of extra moves left doesn t depend on the order of playing The left cards all have 0 so we play those of them which have larger Simpler version of this solution sort all the cards by decrease of if equal by decrease of and then go through the sorted array from beginning to end simulate the counter and sum up the points Remember not to fall over the edge of array if the sum of s is larger than the number of cards Complexity O n log n or O n 2 if using bubblesort which is still accepted 
One day early in the morning you decided to buy yourself a bag of chips in the nearby store The store has chips of n different flavors A bag of the i th flavor costs a i burles The store may run out of some flavors so you ll decide which one to buy after arriving there But there are two major flaws in this plan you have only coins of 1 2 and 3 burles since it s morning the store will ask you to pay in exact change i e if you choose the i th flavor you ll have to pay a i burles Coins are heavy so you d like to take the least possible number of coins in total That s why you are wondering what is the minimum total number of coins you should take with you so you can buy a bag of chips of any flavor in exact change ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int INF = int(1e9) + 5;\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    int best = INF;\n\n    for (int ones = 0; ones <= 1; ones++)\n        for (int twos = 0; ones + twos <= 2; twos++) {\n            int threes = 0;\n\n            for (int a : A) {\n                int least = INF;\n\n                for (int x = 0; x <= ones; x++)\n                    for (int y = 0; y <= twos; y++) {\n                        int need = a - x - 2 * y;\n\n                        if (need >= 0 && need % 3 == 0)\n                            least = min(least, need / 3);\n                    }\n\n                threes = max(threes, least);\n            }\n\n            best = min(best, ones + twos + threes);\n        }\n\n    cout << best << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[1, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2000,Let s define then it should be obvious that we need at least coins to buy a bag of chips of cost Now it s not hard to prove that coins is always enough to buy a bag of chips of any cost Proof if we ll take coins of value coin and coin if we ll take coins and two coins if we ll take coins one coin and two coins So the question is how to decide is coins enough The solution is to note that there is no need to take more than coins and more than coins so we can just brute force the number of coins we ll take and the number of coins we ll take Then the number of coins and we can check is it possible to pay exactly using at most and coins respectively There exists casework solution as well but it s quite tricky so brute force is preferable The main problem for case work is the case since there are two different ways to take coins either coins and coin or coins and two coins In the first way you can t gather exactly and in the second one you can gather neither nor 
Allen is hosting a formal dinner party 2n people come to the event in n pairs couples After a night of fun Allen wants to line everyone up for a final picture The 2n people line up but Allen doesn t like the ordering Allen prefers if each pair occupies adjacent positions in the line as this makes the picture more aesthetic Help Allen find the minimum number of swaps of positions he must perform to make it so that each couple occupies adjacent positions in the line ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,p,ans;\nVI v[1010];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,2*n) {\n\t\tscanf(""%d"",&p); --p;\n\t\tv[p].pb(i);\n\t}\n\trep(i,0,n) rep(j,i+1,n) {\n\t\tauto p1=v[i],p2=v[j];\n\t\tif (p1[0]>p2[0]) swap(p1,p2);\n\t\tif (p1[1]<p2[0]) ans+=0;\n\t\telse if (p1[1]>p2[1]) ans+=2;\n\t\telse ans+=1;\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1400,We describe a greedy algorithm that achieves the minimum number of swaps If the leftmost person is in pair swap the other person in pair left to the second position Now the first two people are both in pair and we repeat the process on the remaining pairs of people recursively We now prove that this number of swaps is optimal and we accomplish this by showing that every swap we made is necessary For two pairs numbered and we can consider the number of times people of pair and are swapped by our process There are possible relative orderings and In the case our algorithm will never swap and In the case any correct swap sequence must swap and at least once and our algorithm will swap the second left of the first when is the leftmost person In the case any correct swap sequence must swap and at least twice and our algorithm will swap the second left of both when is the leftmost person Therefore every swap in our greedy algorithm is necessary so it is optimal We can directly simulate this algorithm in time We can also use data structures such as a binary indexed tree or balanced binary search tree to compute the answer in Maybe it can be even done in anyone 
You can t possibly imagine how cold our friends are this winter in Nvodsk Two of them play the following game to warm up initially a piece of paper has an integer During a move a player should write any integer number that is a divisor of the last written number Then he should run this number of circles around the hotel Let us remind you that a number s divisor is called if it is different from one and from the divided number itself The first person who as he continues to lie in his warm bed under three blankets while the other one keeps running Determine which player wins considering that both players play optimally If the first player wins print any winning first move ,"['#pragma comment (linker, ""/STACK:200000000"")\n#define _SECURE_SCL 0\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int INF = (int) 1E9;\nconst int64 INF64 = (int64) 1E18;\nconst double EPS = 1E-9;\nconst double PI = acos((double)0) * 2;\n\n#define forn(i,n)  for (int i=0; i<int(n); ++i)\n#define ford(i,n)  for (int i=int(n)-1; i>=0; --i)\n#define fore(i,l,n)  for (int i=int(l); i<int(n); ++i)\n#define all(a)  a.begin(), a.end()\n#define fs  first\n#define sc  second\n#define pb  push_back\n#define mp  make_pair\n\n\nint64 n;\n\n\nbool read() {\n\treturn !! (cin >> n);\n}\n\n\nint64 mindiv (int64 n) {\n\tfor (int64 i=2; i*i<=n; ++i)\n\t\tif (n % i == 0)\n\t\t\treturn i;\n\treturn -1;\n}\n\nvoid solve() {\n\tint64 p = mindiv (n);\n\n\tif (p == -1) {\n\t\tcout << ""1\\n0\\n"";\n\t\treturn;\n\t}\n\n\tint64 q = mindiv (n / p);\n\tif (q != -1) {\n\t\tcout << ""1\\n"" << p*q << \'\\n\';\n\t\treturn;\n\t}\n\n\tcout << ""2\\n"";\n}\n\n\nint main() {\n#ifdef SU2_PROJ\n\tfreopen (""input.txt"", ""rt"", stdin);\n\tfreopen (""output.txt"", ""wt"", stdout);\n\twhile (read())\n\t\tsolve();\n#else\n\tif (!read())  throw;\n\tsolve();\n#endif\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1400,if is prime or than it s victory We loose if or where and are prime It is quite obvious that it is always possible to move in bad position in any other case That means all other numbers grants us the victory We only have to check if has a divisor of the loose type We can easily do it in time 
Given a cyclic array a of size n where a i is the value of a in the i th position Let us define that a permutation of a is equal to another permutation of a if and only if their values are the same for each position i or we can transform them to each other by performing some cyclic rotation Let us define for a cyclic array b its number of components as the number of connected components in a graph where the vertices are the positions of b and we add an edge between each pair of adjacent positions of b with equal values note that in a cyclic array the first and last position are also adjacents Find the expected value of components of a permutation of a if we select it equiprobably over the set of all the different permutations of a ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = (int)1e6 + 7;\nint cnt[N];\nint n;\nint a[N];\nint m, g;\nMint dp[N][2];\n\nint gcd(int x, int y) {\n\treturn (y == 0 ? x : gcd(y, x % y));\n}\n\nFactorials F(N);\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx--;\n\t\tcnt[x]++;\n\t}\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cnt[i] != 0)\n\t\t\ta[m++] = cnt[i];\n\tif (m == 1) {\n\t\tprintf(""1\\n"");\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[i][0] = dp[i][1] = 0;\n\tg = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tg = gcd(g, a[i]);\n\tfor (int x = g; x > 0; x--) {\n\t\tif (g % x) continue;\n\t\tassert(n % x == 0);\n\t\tint z = n / x;\n\t\tassert(z > 1);\n\t\tdp[x][1] = 0;\n\t\tdp[x][0] = F.f[z];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint f = a[i] / x;\n\t\t\tdp[x][1] -= Mint(f) * Mint(f - 1);\n\t\t\tdp[x][0] *= F.fi[f];\n\t\t}\n\t\tdp[x][1] /= z - 1;\n\t\tdp[x][1] += z;\n\t\tdp[x][1] *= dp[x][0];\n\t\tfor (int y = 2 * x; y <= g; y += x) {\n\t\t\tif (g % y) continue;\n\t\t\tdp[x][0] -= dp[y][0];\n\t\t\tdp[x][1] -= dp[y][1] * (y / x);\n\t\t}\n\t\t//eprintf(""x = %d, cnt = %u, sum = %u\\n"", x, dp[x][0].x, dp[x][1].x);\n\t}\n\tMint P = 0, Q = 0;\n\tfor (int x = 1; x <= g; x++) if (g % x == 0) {\n\t\tP += (dp[x][1] * x) * x;\n\t\tQ += dp[x][0] * x;\n\t}\n\tprintf(""%u\\n"", (P / Q).x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2900,SolutionThe problem can be solved by applying Burnside s lemma The number of different permutations of the cyclic array is equal to the sum of number of fixed points for each permutation function divided by the number of permutations functions Let s focus on two parts First part find the number of different permutations of Let s define a permutation function as the function that cyclically shifts the array by positions In this problem for an array of size we have possible permutations functions and we would need to find the sum of the number of fixed points for each permutation function To find the number of fixed points for a permutation function we have that must be equal to if we add an edge for each position then by number theory we would obtain that cycles would be formed and each one of size then we can note that each position will belong to the th cycle so we can say that the problem can be transformed into counting the number of permutations with repetition in an array of size Let us denote as the number of values equal to in array when we are processing the function and we reduce the problem to an array of size we should also decrease to since each component is made up of values also we must observe that for solving a problem for an array of size then should be a divisor of Let us denote So to count the number of permutations with repetition for that can be formed with the frequency array we can use the formula Let us denote Let us denote as the number of divisors of Let us denote as the number of permutations with repetition for an array of size from what has been said before we have that must be divisible by so we only need to calculate the permutations with repetition for arrays Now suppose that the number of different values of array is then must be at most because the gcd of several numbers is always less than or equal to the smallest of them Now to calculate the permutations with repetition for a we do it in for that we need to precalculate some factorials and modular inverses before and since we need to calculate them times then we have that in total the complexity would be but since is at most and is at most substituting it would be equal to So to find the sum of the number of fixed points we need the sum of for and divides to at the end of all we divide the sum of the number of fixed points by and we would obtain the number of different permutations of To find the for we do it with the Euclid s algorithm in complexity so in total the complexity is Second part find the expected value of components of different permutations of Here we will use the Linear Expectation property and we will focus on calculating the contribution of each component separately the first thing is to realize that the number of components is equal to the number of different adjacent values so we only need to focus on two adjacent values except if it is a single component this would be a special case If we have different values we can use each different pair of them that in total would be pairs we can realize that when we put a pair its contribution would be equal to the number of ways to permute the remaining values which if we are in an array of size and we use the values and it would be equal to because we removing a value and another value from the set so if we have the formula and and are the first two elements then it would be which would be equivalent to Now to calculate the contribution of the pairs we can realize that taking common factor in the previous expression it only remains to find the sum of for all this can be found in easily by keeping the prefix sum and doing some multiplication Then at the end we multiply by since there are possible pairs of adjacent elements in the general array Let us define as the contribution of components of the permutations with repetition for an array of size then Now for each possible permutation with repetition we have by the Burnside s lemma that in the end we divide it by so we should also divide by the contribution of each component Let s define and Let s define as the sum of for and divide to Let s define as the sum of for and divide to The final answer would be The final complexity then is Code 
Dima loves Inna very much He decided to write a song for her Dima has a magic guitar with strings and frets Dima makes the guitar produce sounds like that to play a note he needs to hold one of the strings on one of the frets and then pull the string When Dima pulls the th string holding it on the th fret the guitar produces a note let s denote it as We know that Dima s guitar can produce distinct notes It is possible that some notes can be produced in multiple ways In other words it is possible that at Dima has already written a song a sequence of notes In order to play the song you need to consecutively produce the notes from the song on the guitar You can produce each note in any available way Dima understood that there are many ways to play a song and he wants to play it so as to make the song look as complicated as possible try to act like Cobein We ll represent a way to play a song as a sequence of pairs such that the th string on the th fret produces the th note from the song The complexity of moving between pairs and equals The complexity of a way to play a song is the maximum of complexities of moving between adjacent pairs Help Dima determine the maximum complexity of the way to play his song The guy s gotta look cool ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2300, K = 11, S = int(2e5), inf = ~0u >> 2;\n\nint leftmost[K][N], rightmost[K][N], maxD[K][N][2], maxU[K][N][2], dis[K][K];\nint n, m, kcnt, s, Q[S];\n\ninline int solve (int i, int j, int nk)\n{\n\tif (j < 1 || j > m)\n\t\treturn 0;\n\treturn max(max(i + j + maxD[nk][i][0], i - j + maxD[nk][i][1]),\n\t\t\t   max(-i + j + maxU[nk][i][0], -i - j + maxU[nk][i][1]));\n}\n\nint main ()\n{\n\tscanf(""%d%d%d%d"", &n, &m, &kcnt, &s);\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 1; j <= kcnt; ++j)\n\t\t{\n\t\t\tleftmost[j][i] = inf;\n\t\t\trightmost[j][i] = -inf;\n\t\t}\n\t\tfor (int j = 1, k; j <= m; ++j)\n\t\t{\n\t\t\tscanf(""%d"", &k);\n\t\t\tleftmost[k][i] = min(leftmost[k][i], j);\n\t\t\trightmost[k][i] = max(rightmost[k][i], j);\n\t\t}\n\t}\n\n\tfor (int k = 1; k <= kcnt; ++k)\n\t{\n\t\tmaxD[k][0][0] = maxD[k][0][1] = -inf;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tmaxD[k][i][0] = max(maxD[k][i - 1][0], -i - leftmost[k][i]);\n\t\t\tmaxD[k][i][1] = max(maxD[k][i - 1][1], -i + rightmost[k][i]);\n\t\t}\n\t\tmaxU[k][n + 1][0] = maxU[k][n + 1][1] = -inf;\n\t\tfor (int i = n; i >= 1; --i)\n\t\t{\n\t\t\tmaxU[k][i][0] = max(maxU[k][i + 1][0], i - leftmost[k][i]);\n\t\t\tmaxU[k][i][1] = max(maxU[k][i + 1][1], i + rightmost[k][i]);\n\t\t}\n\t}\n\t\n\tfor (int a = 1; a <= kcnt; ++a)\n\t\tfor (int b = 1; b <= kcnt; ++b)\n\t\t{\n\t\t\tdis[a][b] = 0;\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t{\n\t\t\t\tint cur = max(solve(i, leftmost[a][i], b), solve(i, rightmost[a][i], b));\n\t\t\t\tdis[a][b] = max(dis[a][b], cur);\n\t\t\t}\n\t\t}\n\n\tint res = 0;\n\tfor (int i = 1; i <= s; ++i)\n\t{\n\t\tscanf(""%d"", &Q[i]);\n\t\tif (i > 1)\n\t\t\tres = max(res, dis[Q[i - 1]][Q[i]]);\n\t}\n\tprintf(""%d\\n"", res);\n\treturn 0;\n}\n\n']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",2200,There are many solutions for this task I will describe my you can deal with other by looking participants code To find the answer we should calculate where maximal complexity from note to note Now we should only iterate the song updating answer for each pair of adjacent notes Let s think how we can calculate the matrix For each place on the guitar let s iterate pairs with If distance will be So we should find minimal in submatrix from to If distance will be So we should find maximal in submatrix from We will calculate this values for each note We need too much memory so we should memorize only one previous row for each note For each place we will update dinamics for both variants according to already calculated and for our own note which is in this cell we will also compare or with current value in the cell Complexity 
Chaneka has an array a 1 a 2 ldots a n Initially all elements are white Chaneka will choose one or more different indices and colour the elements at those chosen indices black Then she will choose all white elements whose indices are multiples of the index of black element and colour those elements green After that her score is the value of a i out of all black and green elements There are 2 n 1 ways for Chaneka to choose the black indices Find the sum of scores for all possible ways Chaneka can choose the black indices Since the answer can be very big print the answer modulo 998 244 353 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i; j<=n; j+=i)\n\t\t\ttab[i]=max(tab[i], tab[j]);\n\tsort(tab+1, tab+1+n);\n\tll pot=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twyn=(wyn+tab[i]*pot)%mod;\n\t\tpot=(pot*2)%mod;\n\t}\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1500,For some value let be the number of different ways to choose the black indices such that the score is exactly and let be the number of different ways to choose the black indices such that the score is Then Let s try to calculate First group the elements in into two groups with group 1 containing elements with values greater than and group 2 containing elements with values not greater than Notice that the only requirement we must satisfy is to not make any group 1 element black or green and we can do anything to the group 2 elements In order to make sure that no group 1 element is black or green we must make sure that no black index we choose is a factor of at least one group 1 index This means we just need calculate some value that represents the number of different indices that is a factor at least one group 1 index then the value of is The answer to the original problem is the sum of for all possible values However we just care about the values such that which only happens if is equal to the value of some element of In order to calculate for all desired values of we need to iterate the elements of from the biggest value to the smallest value Each element we iterate we iterate every index that is a factor of the index of the current element and mark those indices as group 1 while we keep track of the value of The total number of iterations is the total number of factors for every index which is Time Complexity 
A batch of Christmas trees has arrived at the largest store in Berland n customers have already come to the store wanting to buy them Before the sales begin the store needs to determine the price for one tree the price is the same for all customers To do this the store has some information about each customer For the i th customer two integers a i and b i are known which define their behavior if the price of the product is at most a i the customer will buy a tree and leave a positive review otherwise if the price of the product is at most b i the customer will buy a tree but leave a negative review otherwise the customer will not buy a tree at all Your task is to calculate the maximum possible earnings for the store given that it can receive no more than k negative reviews ,"['#include <bits/stdc++.h>#define ll long longusing namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\xa0    int t;    cin >> t;\xa0    while(t--){        ll n, k;        cin >> n >> k;\xa0        vector<ll> a(n), b(n);\xa0        for(int i = 0; i < n; i++){            cin >> a[i];        }                for(int i = 0; i < n; i++){            cin >> b[i];        }\xa0        sort(a.begin(), a.end());        sort(b.begin(), b.end());\xa0        vector<ll> arr;        arr.reserve(4 * n);\xa0        for(int i = 0; i < n; i++){            arr.push_back(a[i]);            arr.push_back(a[i] + 1);            arr.push_back(b[i]);            arr.push_back(b[i] + 1);        }\xa0        sort(arr.begin(), arr.end());        arr.erase(unique(arr.begin(), arr.end()), arr.end());\xa0        ll ans = 0;\xa0        for(auto &p : arr){            if(p <= 0) continue;\xa0            int lba = int(lower_bound(a.begin(), a.end(), p) - a.begin());            int lbb = int(lower_bound(b.begin(), b.end(), p) - b.begin());\xa0            ll ncnt = (ll)lba - lbb;            if(ncnt <= k){                ll bs = n - lbb;                ll rv = p * bs;                ans = max(ans, rv);            }        }\xa0        cout << ans << ""\\n"";    }\xa0    return 0;}']","[1, 0, 0, 0, 1, 1, 0, 1, 1, 0]",1600,First let s design a solution in We can solve the problem in if we iterate on the price we use and for every price calculate the number of trees bought and the number of negative reviews However we don t need to check every possible price from to let s instead check every integer in the union of and or check every and then check every Why is it always optimal Suppose some integer price which is not present in the union of and is optimal Then if we use instead of the status of each customer will be the same but we will get more money for each tree we sell So it is enough to check the elements of and the elements of as possible prices This works in we need to speed it up I will explain two different methods that allow to check every price faster Shortly we process all possible prices in ascending order and when we go from one price to the next we update the customers which no longer want to buy a tree with a new price and the customers which will leave a negative review if the price is increased One of the ways to implement it is as follows For every customer create two events of the type when price exceeds the customer will leave a negative review and when price exceeds the customer will no longer buy a tree and leave a negative review These events can be implemented as pairs of integers and Then we can sort the events and process them from left to right in sorted order maintaining the number of trees and negative reviews When we process the event with price the change it makes will come into effect only when the price exceeds so we Furthermore all events with the same price value should be processed at the same time so if there are multiple events with the same price value you don t update the answer after processing only several of them All of this is a bit complicated to implement that s why I would like to show you anFor every price we need to calculate two values the number of trees bought i e the number of customers such that the number of negative reviews i e the number of customers such that The first one can be calculated in with binary search if we sort the array The second one is a bit trickier Let s calculate it as follows take the number of trees bought and then subtract the number of trees bought without a negative review which is the number of customers such that If we sort both arrays and this value can also be processed in with binary search So we spend time to check one possible price and the number of different prices we have to check is up to so this solution works in 
You are given a sequence a 1 a 2 dots a n consisting of n integers You may perform the following operation on this sequence choose any element and either increase or decrease it by one Calculate the minimum possible difference between the maximum element and the minimum element in the sequence if you can perform the aforementioned operation k times ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n, k;\nll a[100010];\nint l, r;\nvoid done() {\n\tputs(""0"");\n\texit(0);\n}\nvoid move_left() {\n\twhile(1) {\n\t\tif(l == r) done();\n\t\tif(a[l] != a[l + 1]) break;\n\t\tl++;\n\t}\n}\nvoid move_right(){\n\twhile(1) {\n\t\tif(r == l) done();\n\t\tif(a[r] != a[r - 1]) break;\n\t\tr--;\n\t}\n}\nint main() {\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tl = 0;\n\tr = n - 1;\n\twhile(k > 0) {\n\t\tmove_left();\n\t\tmove_right();\n\t\tint lc = l + 1;\n\t\tint rc = n - r;\n\t\tif(lc < rc) {\n\t\t\tll c = a[l + 1] - a[l];\n\t\t\tif(k < c * lc){\n\t\t\t\ta[0] += k / lc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk -= c * lc;\n\t\t\ta[0] = a[l] = a[l + 1];\n\t\t}\n\t\telse{\n\t\t\tll c = a[r] - a[r - 1];\n\t\t\tif(k < c * rc){\n\t\t\t\ta[n - 1] -= k / rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk -= c * rc;\n\t\t\ta[n - 1] = a[r] = a[r - 1];\n\t\t}\n\t}\n\tcout << (a[n - 1] - a[0]) << endl;\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 1, 1, 0]",2000,Suppose that the maximum value in the resulting array should be and the minimum value should be Let s estimate the required number of operations to make an array with such properties All elements that are less than should be increased to and all elements that are greater than should be decreased to and we don t have to do any operation with remaining elements Now we claim that either or should belong to the initial array Why so Suppose we constructed an answer such that and If the number of elements we increased to is not less than the number of elements we decreased to then we could construct the answer with minimum equal to and maximum equal to and it would not require more operations And if the number of elements we increased to is less than the number of elements we decreased to then we construct the answer for as minimum and as maximum So we can shift the range so that one of its endpoints belongs to the initial array Now we can solve the problem as follows iterate on the maximum in the resulting array and find the largest minimum we can obtain with binary search and then do it vice versa iterate on the minimum in the resulting array and find the largest maximum we can obtain with binary search To check how many operations we need for example to make all values not less than we can find the number of elements that we have to change with another binary search let the number of such elements be and find their sum with prefix sums let their sum be Then the required number of operations is exactly The same approach can be used to find the number of operations to make all elements not greater than This is the way the problem was supposed to solve but unfortunately we failed to find a much easier greedy solution 
Mashmokh works in a factory At the end of each day he must turn off all of the lights The lights on the factory are indexed from to There are buttons in Mashmokh s room indexed from to as well If Mashmokh pushes button with index then each light with index not less than that is still turned on turns off Mashmokh is not very clever So instead of pushing the first button he pushes some of the buttons randomly each night He pushed distinct buttons the buttons were pushed consecutively in the given order this night Now he wants to know for each light the index of the button that turned this light off Please note that the index of button is actually not Please help Mashmokh print these indices ,"['#include <stdio.h>\nint n, m, a[100], b[100];\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 0; i < m; i++)\n\t\tscanf(""%d"", &b[i]);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = b[i] - 1; j < n; j++)\n\t\t{\n\t\t\tif(!a[j])\n\t\t\t\ta[j] = b[i];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tprintf(""%d "", a[i]);\n\tgetchar(); getchar();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,For this problem for each light you could just iterate over all pressed buttons and find the first button that Then you could output and move to next light 
The of a multiset of points on the line is the largest distance between two points from this set For example the diameter of the multiset is 2 Diameter of multiset consisting of one point is 0 You are given points on the line What is the minimum number of points you have to remove so that the diameter of the multiset of the remaining points will not exceed ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint n, d;\nint a[100005];\nint main(){\n\tscanf(""%d%d"", &n, &d);\n\tfor(int i = 1; i <= n; i ++){\n\t\tscanf(""%d"", &a[i]);\n\t}\n\tsort(a + 1, a + n + 1);\n\tint ans = 100;\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = i; j <= n; j ++){\n\t\t\tif(a[j] - a[i] <= d){\n\t\t\t\tans = min(ans, i - 1 + n - j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n} \n']","[1, 0, 0, 0, 0, 1, 0, 0, 1, 0]",1200,It s clear that diameter of the multiset of points equals to difference of coordinates of point with maximum coordinate and point with minimum coordinate So we can iterate over all possible pairs of maximum and minimum point and check number of remaining points in This solution works in Of course there are faster solutions 
Petya has a polygon consisting of n vertices All sides of the Petya s polygon are parallel to the coordinate axes and each two adjacent sides of the Petya s polygon are perpendicular It is guaranteed that the polygon is simple that is it doesn t have self intersections and self touches All internal area of the polygon borders are not included was painted in black color by Petya Also Petya has a rectangular window defined by its coordinates through which he looks at the polygon A rectangular window can not be moved The sides of the rectangular window are parallel to the coordinate axes Determine the number of black connected areas of Petya s polygon which can be seen through the rectangular window ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ], nex=0;\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n    \n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n    \n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<100001> D;\n\nint n,ans;\npi X,Y;\npi p[15000];\nvpi v[15001];\nset<pair<pi,int>> cur;\n\npair<pi,int> mergeLeft(int ind, pair<pi,int> z) {\n    // last one with second <= z.f \n    auto it = cur.ub(z);\n    if (it != cur.end() && it->f.f == z.f.s) {\n        ans -= D.unite(it->s,z.s);\n        z.f.s = it->f.s;\n        cur.erase(it);\n    }\n    return z;\n}\n\npair<pi,int> mergeRight(int ind, pair<pi,int> z) {\n    auto it = cur.ub(z);\n    if (it != cur.begin() && prev(it)->f.s == z.f.f) {\n        it = prev(it);\n        ans -= D.unite(it->s,z.s);\n        z.f.f = it->f.f;\n        cur.erase(it);\n    }\n    return z;\n}\n\nvoid mod(int ind, pi t) {\n    auto a = cur.ub({{t.f,MOD},MOD});\n    if (a != cur.begin() && prev(a)->f.s >= t.s) {\n        auto A = *prev(a); cur.erase(A);\n        if (A.f.f < t.f) cur.insert({{A.f.f,t.f},A.s});\n        if (t.s < A.f.s) cur.insert({{t.s,A.f.s},A.s});\n    } else {\n        pair<pi,int> z = mp(t,D.nex++); if (ind <= X.s) ans ++;\n        z = mergeLeft(ind,z);\n        z = mergeRight(ind,z);\n        cur.insert(z);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> X.f >> X.s >> Y.f >> Y.s;\n    cin >> n;\n    F0R(i,n) cin >> p[i].f >> p[i].s; // only horizontal\n    F0R(i,n) if (p[i].s == p[(i+1)%n].s) {\n        pi z = {p[i].f,p[(i+1)%n].f};\n        if (z.f > z.s) swap(z.f,z.s);\n        z.f = max(z.f,X.f); z.s = min(z.s,Y.f);\n        if (z.f < z.s) v[p[i].s].pb(z);\n    }\n    F0Rd(i,15001) {\n        if (i == Y.s) {\n            cout << ans;\n            return 0;\n        }\n        for (auto t: v[i]) {\n            mod(i,t);\n        }\n        if (i == X.s) {\n            D = DSU<100001>();\n            ans = 0;\n            \n            set<pair<pi,int>> CUR;\n            for (auto t: cur) {\n                CUR.insert({t.f,D.nex++});\n                ans ++;\n            }\n            cur = CUR;\n            // for (auto a: CUR) cout << a.f.f << "" "" << a.f.s << ""\\n"";\n            // cout << ""HI "" << ans << "" "" << i << ""\\n"";\n        } \n    }\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2800,First lets build a graph that represents only part of the polygon that is inside the window as well as borders of the window Do do this for each segment of the polygon find the intersection of that segment with the window and if it still is a segment with non zero length add it to the graph add both endpoints as vertices and the segment itself as an edge Next add four corners of the window as vertices Last connect all the points on each of the four borders of the window with edges This way we have a planar graph and we can find faces in this graph which will represent all the connected areas inside the window both belonging to the polygon and not To count only those that belong to the polygon one can mark those oriented edges that were created while intersecting polygon s segments with the window as important Only mark an edge if it is directed the same way as the corresponding segment of the polygon This way those faces of the graph that are to the left of important edges are the ones belonging to the polygon But there is one bad case when no segment of the polygon intersects with the window It such case the window is either entirely outside of the polygon or entirely inside of it To check this find number of intersections of the polygon with a ray starting from inside of the window If the number of intersections is even the window is outside of the polygon If it is odd the window is outside 
Finally it is a day when Arthur has enough money for buying an apartment He found a great option close to the center of the city with a nice price Plan of the apartment found by Arthur looks like a rectangle consisting of squares of size Each of those squares contains either a wall such square is denoted by a symbol on the plan or a free space such square is denoted on the plan by a symbol Room in an apartment is a maximal connected area consisting of free squares Squares are considered adjacent if they share a common side The old Arthur dream is to live in an apartment where all rooms are rectangles He asks you to calculate minimum number of walls you need to remove in order to achieve this goal After removing a wall from a square it becomes a free square While removing the walls it is possible that some rooms unite into a single one ,"['#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << "" = "" << ccc << endl;\n\n#define\tctrl( xx,yy )\t( xx>=1 and yy>=1 and xx<=m and yy<=n and s[xx][yy]==\'.\' )\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tm,n;\nchar\ts[3000][3000];\nchar\th[3000][3000];\n\nint\tbozuk( int x,int y ){\n\tif( s[x][y]!=\'*\' )\treturn\t0;\n\tif( ctrl( x-1,y ) and ctrl( x-1,y+1 ) and ctrl( x,y+1 ) )\treturn\t1;\n\tif( ctrl( x,y+1 ) and ctrl( x+1,y+1 ) and ctrl( x+1,y ) )\treturn\t1;\n\tif( ctrl( x+1,y ) and ctrl( x+1,y-1 ) and ctrl( x,y-1 ) )\treturn\t1;\n\tif( ctrl( x,y-1 ) and ctrl( x-1,y-1 ) and ctrl( x-1,y ) )\treturn\t1;\n\treturn\t0;\n}\n\nint main(){\n\tcin >> m >> n;\n\tFP( i,1,m )\n\t\tscanf(""%s"",s[i]+1);\n\tqueue< pair<int,int> >\tQ;\n\tFP( i,1,m )\n\t\tFP( j,1,n )\n\t\t\tif( bozuk( i,j ) )\tQ.push( mp(i,j) ),h[i][j]=1;\n\tint\tx,y,xx,yy;\n\twhile( Q.size() ){\n\t\tx = Q.front().st;\n\t\ty = Q.front().nd;\n\t\tQ.pop();\n\t\ts[x][y] = \'.\';\n\t\th[x][y] = 0;\n\t\tFP( i,-1,1 )\n\t\t\tFP( j,-1,1 ){\n\t\t\t\tif( !i and !j )\tcontinue;\n\t\t\t\txx = x+i;\n\t\t\t\tyy = y+j;\n\t\t\t\tif( xx<1 or xx>m or yy<1 or yy>n or h[xx][yy] or !bozuk( xx,yy ) )\tcontinue;\n\t\t\t\tQ.push( mp(xx,yy) ),h[xx][yy] = 1;\n\t\t\t\ts[xx][yy] = \'.\';\n\t\t\t}\n\t}\n\tFP( i,1,m )\n\t\tprintf(""%s\\n"",s[i]+1);\n}\n']","[1, 0, 0, 0, 1, 0, 1, 0, 0, 1]",2400,To solve this problem we need to observe next fact If in some square whith size 2 2 in given matrix there is exactly one asterisk we must change it on dot That is if in matrix from dots and asterisks is not square 2 2 in which exactly one asterisk and three dots then all maximum size of the area from dots connected by sides represent rectangles Now solve the problem with help of bfs and this fact Iterate on all asterisks in given matrix and if only this asterisk contains in some 2 2 square change this asterisk on dot and put this position in queue Than we need to write standart bfs in which we will change asterisks on dots in all come out 2 2 squares with exactly one asterisk Asymptotic behavior of this solution O n m where n and m sizes of given matrix 
You are given two arrays a and b both of length n Let s define a function f l r sum limits l le i le r a i cdot b i Your task is to reorder the elements choose an arbitrary order of elements of the array b to minimize the value of sum limits 1 le l le r le n f l r Since the answer can be very large you have to print it modulo 998244353 Note that you should ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst LL N=2e6+7,mod=998244353,INF=1e9;\nLL n,m;\nLL a[N],b[N],c[N];\nint main()\n{\n    cin>>n;\n    for(LL i=1;i<=n;i++){\n        scanf(""%lld"",&a[i]);\n    }\n    for(int i=1;i<=n;i++){\n        scanf(""%lld"",&b[i]);\n    }\n    for(LL i=1;i<=n;i++){\n        c[i]=i*(n-i+1ll)*a[i];\n    }\n    sort(c+1,c+1+n);\n    sort(b+1,b+1+n,greater<LL>());\n    LL ans=0;\n    for(int i=1;i<=n;i++){\n        ans+=c[i]%mod*b[i];\n        ans%=mod;\n    }\n    cout<<ans;\n    return 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",1600,Let s use technique to solve this problem How many times the value will occur in the answer It will occur times Okay now we can see that for each position we have the value The only non constant value there is So let We should pair the minimum with the maximum the second minimum with the second maximum and so on So let s sort the array and the array reverse the array and calculate the sum of values don t forget about modulo here 
A lot of frogs want to cross a river A river is w units width but frogs can only jump l units long where l w Frogs can also jump on lengths shorter than l but can t jump longer Hopefully there are some stones in the river to help them The stones are located at integer distances from the banks There are a i stones at the distance of i units from the bank the frogs are currently at Each stone can only be used once by one frog after that it drowns in the water What is the maximum number of frogs that can cross the river given that then can only jump on the stones ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nll w, l;\n\nll a[N];\nll b[N];\n\nset <int> st;\n\nint main() {\n scanf(""%d%d"", &w, &l);\n st.insert(w);\n for (int i = 1; i < w; i++) {\n  scanf(""%d"", &a[i]);\n  if (a[i] > 0) st.insert(i);\n }\n b[0] = int(1e9);\n a[w] = int(1e9);\n for (int i = 0; i < w; i++) {\n  while (b[i] > 0) {\n   set <int>::iterator it = st.upper_bound(i + l);\n   if (it != st.begin()) {\n    it--;\n    int x = min(a[*it], b[i]);\n    b[i] -= x;\n    a[*it] -= x;\n    b[*it] += x;\n    if (!a[*it]) st.erase(it);\n   } else break;\n  }\n }\n cout << b[w];\n return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1900,This problem can be solved using many different approaches most of them are based on different greedy solutions We will discuss a solution with an easy provable greedy First let s do binary search for the answer Let it be Then assume that the stones are given by their positions where is the total number of stones Also assume and the banks Then if for some the condition is not satisfied then frogs can t cross the river Indeed consider the first jump for each frog that ends at a position further than It can t end at or further because of the length of the jump so it has to end at some stone at or But there are only such stones so some stone is used by two frogs which is prohibited Now if is satisfied the frogs can easily cross the river by using the route for the th frog So the solution is to do the binary search for the answer and then compute the maximum distance between stones and This can be done using two pointers technique 
Vasya has an array consisting of positive integer numbers Vasya wants to divide this array into two non empty consecutive parts the prefix and the suffix so that the sum of all elements in the first part equals to the sum of elements in the second part It is not always possible so Vasya will move some element before dividing the array Vasya will erase some element and insert it into an arbitrary position Can Vasya divide the array after choosing the right element to move and its new position ,"['#include<cstdio>\n#include<set>\ntypedef long long i64;\ni64 s[100007];\nint n,a[100007];\nstd::multiset<int>s1,s2;\nint main(){\n\tscanf(""%d"",&n);\n\tif(n==1)return puts(""NO""),0;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(""%d"",a+i);\n\t\ts[i]=a[i]+s[i-1];\n\t\ts2.insert(a[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ti64 v=s[i]*2-s[n];\n\t\tif(!v)return puts(""YES""),0;\n\t\ts1.insert(a[i]);\n\t\ts2.erase(s2.find(a[i]));\n\t\tif(v>0&&v%2==0&&v<=2000000000&&s1.find(v/2)!=s1.end())return puts(""YES""),0;\n\t\tif(v<0&&v%2==0&&v>=-2000000000&&s2.find(-v/2)!=s2.end())return puts(""YES""),0;\n\t}\n\treturn puts(""NO""),0;\n}']","[0, 0, 1, 0, 1, 0, 0, 1, 0, 0]",1900,Suppose we want to move an element from the prefix to the suffix if we need to move an element from the suffix to the prefix we can just reverse the array and do the same thing Suppose the resulting prefix will contain elements Then we need to check that the prefix with elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array and then we can move this element to the suffix To check all the prefixes we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements 
Since Sonya is interested in robotics too she decided to construct robots that will read and recognize numbers Sonya has drawn n numbers in a row a i is located in the i th position She also has put a robot at each end of the row to the left of the first number and to the right of the last number Sonya will give a number to each robot they can be either same or different and run them When a robot is running it is moving toward to another robot reading numbers in the row When a robot is reading a number that is equal to the number that was given to that robot it will turn off and stay in the same position Sonya does not want robots to break so she will give such numbers that robots will stop before they meet That is the girl wants them to stop at different positions so that the first robot is to the left of the second one For example if the numbers 1 5 4 1 3 are written and Sonya gives the number 1 to the first robot and the number 4 to the second one the first robot will stop in the 1 st position while the second one in the 3 rd position In that case robots will not meet each other As a result robots will not be broken But if Sonya gives the number 4 to the first robot and the number 5 to the second one they will meet since the first robot will stop in the 3 rd position while the second one is in the 2 nd position Sonya understands that it does not make sense to give a number that is not written in the row because a robot will not find this number and will meet the other robot Sonya is now interested in finding the number of different pairs that she can give to robots so that they will not meet In other words she wants to know the number of pairs p q where she will give p to the first robot and q to the second one Pairs p i q i and p j q j are different if p i neq p j or q i neq q j Unfortunately Sonya is busy fixing robots that broke after a failed launch That is why she is asking you to find the number of pairs that she can give to robots so that they will not meet ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PA;\ntypedef long long LL;\n\n#define MAXN 200003\n#define MODP 1000000007\n#define FST first\n#define SCD second\n\n\nLL qpow(LL x, int y) {\n\tLL res = 1;\n\tfor (;y>0;y>>=1, x = x*x%MODP) {\n\t\tif (y&1) res = (res*x)%MODP;\n\t}\n\treturn res;\n}\n\nint q[MAXN], f[MAXN];\nbool v[MAXN];\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.txt"", ""r"", stdin);\n\t#endif\n\tint Tn = 1;\n\t// scanf(""%d"", &Tn);\n\tfor (int ci=1;ci<=Tn;++ci) {\n\t\tint n;\n\t\tcin>>n;\n\t\tfor (int i=1;i<=n;++i) {\n\t\t\tscanf(""%d"", q+i);\n\t\t}\n\t\tmemset(v,0,sizeof(v));\n\t\tf[n+1] = 0;\n\t\tfor (int i=n;i>1;--i) {\n\t\t\tf[i] = f[i+1];\n\t\t\tif (v[q[i]]) continue;\n\t\t\tv[q[i]] = true;\n\t\t\t++f[i];\n\t\t}\n\t\tmemset(v,0,sizeof(v));\n\t\tLL ans = 0;\n\t\tfor (int i=1;i<n;++i) {\n\t\t\tif (v[q[i]]) continue;\n\t\t\tv[q[i]] = true;\n\t\t\tans+=f[i+1];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1400,Let s assume that our left robot is located in the position The robot could be there only if the value that is written there did not occur earlier The number of possible locations of the second robot is equal to the number of distinct numbers on the segment Let be the number of different numbers on Let s find these number from right to left If occurs the first time otherwise 
You are given an array You have to answer the following queries You are given two integers and Let be the number of occurrences of in where is the subarray of from th element to th inclusive Find the of You are given two integers to Change to The of a multiset of numbers is the smallest non negative integer the set Note that in this problem all elements of are positive which means that 0 and is never the answer for the query of the second type ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nstruct que{\n\tint l, r, t, id, ans;\n}q[100005];\nstruct modify{\n\tint pos, r, x;\n}mo[100005];\nint n, m, m1, m2;\nint a[100005], tt[100005];\nint tmp[200005], vis[200005], tp;\nint vi2[200005];\nint dk[200005], K;\nint cmp(que x, que y){\n\tif(dk[x.l] != dk[y.l]) return dk[x.l] < dk[y.l];\n\tif(dk[x.r] != dk[y.r]) return dk[x.r] < dk[y.r];\n\treturn x.t < y.t;\n}\nint cmp2(que x, que y){\n\treturn x.id < y.id;\n}\nvoid solve(){\n\tint l = 1, r = 0, t = 0;\n\tfor(int i = 1; i <= m1; i ++){\n\t\twhile(l > q[i].l){\n\t\t\tl--;\n\t\t\tvi2[vis[a[l]]] --;\n\t\t\tvis[a[l]] ++;\n\t\t\tvi2[vis[a[l]]] ++;\n\t\t}\n\t\twhile(r < q[i].r){\n\t\t\tr++;\n\t\t\tvi2[vis[a[r]]] --;\n\t\t\tvis[a[r]] ++;\n\t\t\tvi2[vis[a[r]]] ++;\n\t\t}\n\t\twhile(l < q[i].l){\n\t\t\tvi2[vis[a[l]]] --;\n\t\t\tvis[a[l]] --;\n\t\t\tvi2[vis[a[l]]] ++;\n\t\t\tl++;\n\t\t}\n\t\twhile(r > q[i].r){\n\t\t\tvi2[vis[a[r]]] --;\n\t\t\tvis[a[r]] --;\n\t\t\tvi2[vis[a[r]]] ++;\n\t\t\tr--;\n\t\t}\n\t\twhile(t < q[i].t){\n\t\t\tt++;\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]--;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t\ta[mo[t].pos] = mo[t].x;\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]++;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t}\n\t\twhile(t > q[i].t){\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]--;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t\ta[mo[t].pos] = mo[t].r;\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]++;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t\tt--;\n\t\t}\n\t\tq[i].ans = 1;\n\t\twhile(vi2[q[i].ans]) q[i].ans++;\n\t}\n}\nint main(){\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 1; i <= n; i ++){\n\t\tscanf(""%d"", &a[i]);\n\t\ttmp[++tp] = a[i];\n\t}\n\tfor(int i = 1; i <= m; i ++){\n\t\tint opt, l, r;\n\t\tscanf(""%d%d%d"", &opt, &l, &r);\n\t\tif(opt == 1){\n\t\t\tm1++;\n\t\t\tq[m1].l = l; q[m1].r = r; q[m1].t = m2;\n\t\t\tq[m1].id = i;\n\t\t}\n\t\tif(opt == 2){\n\t\t\tm2++;\n\t\t\tmo[m2].pos = l;\n\t\t\tmo[m2].x = r;\n\t\t\ttmp[++tp] = r;\n\t\t}\n\t}\n\tsort(tmp + 1, tmp + tp + 1);\n\tfor(int i = 1; i <= n; i ++){\n\t\ta[i] = lower_bound(tmp + 1, tmp + tp + 1, a[i]) - tmp;\n\t\ttt[i] = a[i];\n\t}\n\tfor(int i = 1; i <= m2; i ++){\n\t\tmo[i].x = lower_bound(tmp + 1, tmp + tp + 1, mo[i].x) - tmp;\n\t\tmo[i].r = tt[mo[i].pos];\n\t\ttt[mo[i].pos] = mo[i].x;\n\t}\n\tK = max(1, min(n, (int)(pow(n, 2.00 / 3.00))));\n\tfor(int i = 1; i <= n; i ++){\n\t\tdk[i] = (i - 1) / K + 1;\n\t}\n\tsort(q + 1, q + m1 + 1, cmp);\n\tsolve();\n\tsort(q + 1, q + m1 + 1, cmp2);\n\tfor(int i = 1; i <= m1; i ++){\n\t\tprintf(""%d\\n"", q[i].ans);\n\t}\n\treturn 0;\n} \n']","[0, 0, 0, 0, 1, 1, 0, 0, 0, 0]",2600,At first let s find out minimum length of array such that answer for it is For it on this segment there should be a number that has one occurrence some number that has two occurrences etc Length of this segment will be That s why answer won t exceed for any query Let s compress numbers in such a way that numbers from array and from queries will be in range from to Obviously this modification won t change answer but now elements won t exceed Suppose for interval we know number of occurrences of each number and number of occurrences of each number of occurrences Then we can find Mex of this set in Moreover it s easy to update arrays and for segments and in time We will represent each query as tuple of integers where t is a number of change queries before this and segment It s easy to see that can also be changed by one in time Because of will replace to in following part of editorial Let and let s sort queries by triples and will answer queries in this order Border will be increased by for each sqaure of size sum of movements of right border is For each query borders and are moved by not more than sum of movements is Solution has time complexity 
You ve got a table of size We ll consider the table rows numbered from top to bottom 1 through and the columns numbered from left to right 1 through Then we ll denote the cell in row and column as Initially cell contains two similar turtles Both turtles want to get to cell Some cells of the table have obstacles but it is guaranteed that there aren t any obstacles in the upper left and lower right corner A turtle one or the other can go from cell to one of two cells and as long as the required cell doesn t contain an obstacle The turtles have had an argument so they don t want to have any chance of meeting each other along the way Help them find the number of ways in which they can go from cell to cell More formally find the number of pairs of non intersecting ways from cell to cell modulo Two ways are called non intersecting if they have exactly two common points the starting point and the final point ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007\n\nint X,Y;\nchar a[3010][3010];\nint dp[3010][3010];\n\nll func(int sx, int sy, int gx, int gy){\n    int i,j;\n    \n    REP(i,X) REP(j,Y) dp[i][j] = 0;\n    if(a[sx][sy] != \'#\') dp[sx][sy] = 1;\n    for(i=sx;i<X;i++) for(j=sy;j<Y;j++) if(dp[i][j] > 0){\n        if(i+1 < X && a[i+1][j] != \'#\'){\n            dp[i+1][j] += dp[i][j];\n            if(dp[i+1][j] >= MOD) dp[i+1][j] -= MOD;\n        }\n        if(j+1 < Y && a[i][j+1] != \'#\'){\n            dp[i][j+1] += dp[i][j];\n            if(dp[i][j+1] >= MOD) dp[i][j+1] -= MOD;\n        }\n    }\n    \n    return dp[gx][gy];\n}\n\nint main(void){\n    int i,j;\n    \n    cin >> X >> Y;\n    REP(i,X) scanf(""%s"", a[i]);\n    \n    ll A = func(0, 1, X-2, Y-1);\n    ll B = func(0, 1, X-1, Y-2);\n    ll C = func(1, 0, X-2, Y-1);\n    ll D = func(1, 0, X-1, Y-2);\n    ll ans = ((A * D - B * C) % MOD + MOD) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2500,In the problem you re asked to find the number of pairs of non intersecting paths between left upper and right lower corners of the grid You can use following lemma for that Thanks to rng 58 for the link More precisely considering our problem this lemma states that given sets of initial and final points the answer is equal to the following determinant Finally we need to decide what sets of initial and final points we choose You can take and in order to make paths non intersecting even in 2 points 
Sergei B the young coach of Pokemons has found the big house which consists of flats ordered in a row from left to right It is possible to enter each flat from the street It is possible to go out from each flat Also each flat is connected with the flat to the left and the flat to the right Flat number is only connected with the flat number and the flat number is only connected with the flat number There is exactly one Pokemon of some type in each of these flats Sergei B asked residents of the house to let him enter their flats in order to catch Pokemons After consulting the residents of the house decided to let Sergei B enter one flat from the street visit several flats and then go out from some flat But they won t let him visit the same flat more than once Sergei B was very pleased and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house Your task is to help him and determine this minimum number of flats he has to visit ,"['#include<cstdlib>\n#include<cctype>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<numeric>\n#include<iomanip>\n#include<bitset>\n#include<list>\n#include<stdexcept>\n#include<functional>\n#include<utility>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define MP make_pair\n#define PB push_back\n#define AA first\n#define BB second\n#define OP begin()\n#define ED end()\n#define SZ size()\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\n#define cmin(x,y) x=min(x,y)\n#define cmax(x,y) x=max(x,y)\nconst LL MOD = 1000000007;\nconst double PI = acos(-1.);\nconst double eps = 1e-9;\nLL modPow(LL a,LL b,LL MOD){\n\tLL ret=1;for(;b;b>>=1){\n\t\tif(b&1)ret=ret*a%MOD;a=a*a%MOD;\n\t}return ret;\n}\n\nchar s[100005];\nstack<int>S[55];\nvoid solve(){\n\tint n;\n\tscanf(""%d"",&n);\n\tscanf(""%s"",s);\n\trep(i,0,n){\n\t\tif(islower(s[i]))S[ s[i]-\'a\' ].push(i);\n\t\tif(isupper(s[i]))S[ s[i]-\'A\'+26 ].push(i);\n\t}\n\tvector<int>L;\n\trep(i,0,52)if(!S[i].empty())L.PB(i);\n\tint ans=n;\n\tfor(int i=n-1;i>=0;i--){\n\t\tint le=i,re=i;\n\t\tint fail=0;\n\t\tfor(auto id:L){\n\t\t\tif(S[id].empty())\n\t\t\t\tfail=1;\n\t\t\telse {\n\t\t\t\tcmin(le,S[id].top());\n\t\t\t\tif(S[id].top()==re)\n\t\t\t\t\tS[id].pop();\n\t\t\t}\n\t\t}\n\t\tif(fail)break;\n\t\tcmin(ans,re-le+1);\n\t}\n\tprintf(""%d\\n"",ans);\n}\n\nint main(){\n\tint _T=1;\n\trep(CA,0,_T){\n\t\tsolve();\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1500,At first let s find all different letters which exist in the given string It can be done with help of the array with letters or with help of the set Then we need to use the array where equals to minimal length of the substring which ends in the position and contains all different letters from the given string If for some position there is no such a substring we will store in the some big number which more than the length of the given string for example Now we need to iterate through all different letters of the string in any order Let the current letter equals to Let s iterate on the positions of the given string from the left to the right and will store in the variable the last position of the string in which At first Let the current position of the given string equals to If we need to make If for current position the value of the equals to we need to make because there is no substring which ends in the position and contains all different letters of the given string In the other case we need to update The answer is the minimal value from all values of the array after we iterated through all different letters of the given string 
You are given a set S which contains the first n positive integers 1 2 ldots n You can perform the following operation on S any number of times possibly zero Choose a positive integer k where 1 le k le n such that there exists a multiple of k in S Then delete the multiple of k from S This operation requires a cost of k You are given a set T which is a subset of S Find the minimum possible total cost of operations such that S would be transformed into T We can show that such a transformation is always possible ,"['//author: wuge with noi2022 cu\n//https://www.luogu.com.cn/team/48234\n#include<bits/stdc++.h>\nusing namespace std;\n#define M998 const int mod=998244353\n#define M197 const int mod=1e9+7\n#define int long long\n#define genshin getchar\n#define impact isdigit\ninline int read()\n{\n     int shaya=0,wugecu=1;//5 spaces\n  char cirno_9=genshin();//2 spaces\n        while(!impact(cirno_9))//8 spaces\n  {if(cirno_9==\'-\')wugecu=-1;cirno_9=genshin();}//2 spaces\n  while(impact(cirno_9)) shaya=shaya*10+cirno_9-\'0\',cirno_9=genshin();//2 spaces\n return shaya*wugecu;//1 space\n}\nchar a[1000005];\nvoid Meyi()\n{\n\tint n=read();\n\tscanf(""%s"",a+1);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i;j<=n;j+=i)\n\t\t{\n\t\t\tif(a[j]==49)break;\n\t\t\tif(a[j]==48)ans+=i,a[j]=50;\n\t\t}\n\t}\n\tprintf(""%lld\\n"",ans);\n}\nsigned main()\n{\n\tint miHoYo=read();\n\twhile(miHoYo--) Meyi();\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200,One operation should be used to remove every element not belonging to Let be an element not belonging to Suppose a cost operation removes value then must be divisible by Furthermore the multiples must have been already removed from where we write Since removed elements stay removed the above is only possible if all of does not belong to For each let be the smallest integer satisfying the above condition As we can always remove using a cost operation and in particular exists The total cost must be at least We claim that this cost can be achieved To do so we should remove the required elements in ascending order When removing we assume all with have already been removed At this state an cost operation would be able to remove It remains to find the values To do so efficiently we can perform the above process in a bottom up manner similar to the Sieve of Eratosthenes Please refer to the code below for implementation details The overall complexity is Code in C 
You are given an array consisting of elements The of some subsegment of this array is the difference between the maximum and minimum element from this segment The of the array is the sum of of all subsegments of this array For example the of array is because there are different subsegments of this array from index to index is from index to index is from index to index is from index to index is from index to index is from index to index is You have to determine the of the array ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nconst int maxn = 1e6 + 5;\nint n;\nint a[maxn];\nint l[maxn];\nint r[maxn];\nlong long ans;\n\nvoid work() {\n    FOR(i, 0, n) l[i] = r[i] = i;\n    FOR(i, 1, n) {\n        int st = i;\n        while (st && a[i] >= a[st - 1]) st = l[st - 1];\n        l[i] = st;\n    }\n    FORd(i, n - 1, 0) {\n        int st = i;\n        while (st < n - 1 && a[i] > a[st + 1]) st = r[st + 1];\n        r[i] = st;\n    }\n    FOR(i, 0, n) {\n        ans += (long long) a[i] * (i - l[i] + 1) * (r[i] - i + 1);\n    }\n}\n\nvoid solve() {\n   scanf(""%d"", &n);\n   FOR(i, 0, n) scanf(""%d"", a + i);\n   work();\n   FOR(i, 0, n) a[i] *= -1;\n   work();\n   cout << ans << ""\\n"";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        //ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0]",1900,First of all we will calculate the sum of maximum and minimum values on all segments separatedly Then the answer is the difference between the sum of maximum values and minimum values How can we calculate the sum of minimum values for example For each element we will try to find the number of segments where it is the So we will calculate two arrays means that is the maximum index such that and and means that is the minimum index such that and So actually and represent the borders of the largest segment where is the and we need to exclude those borders While knowing these values we can calculate the number of subsegments where is the How can we calculate for example the array We will use a stack where we will store some indices in the array in such a way that if we change all indices to the values in the array they will be in sorted order the maximum element will be at the top of the stack and the minimum at the bottom Let s calculate from the minimum index to the maximum When we calculate we remove all elements such that from the stack since the stack is sorted all these elements will be at the top of the stack and when we encounter the first element such that it is guaranteed that all elements below it don t need to be deleted Then if there s any element on top of the stack it becomes the value of then we push into the stack Since every element will be added and deleted not more than one time the complexity of this algorithm is linear We can apply the same technique to calculate the values of and the sum of maximums 
You are given two integer arrays a and b b i neq 0 and b i leq 10 9 Array a is sorted in order The cost of a subarray a l r is defined as follows If sum limits j l r b j neq 0 then the cost is not defined Otherwise Construct a bipartite flow graph with r l 1 vertices labeled from l to r with all vertices having b i lt 0 on the left and those with b i gt 0 on right For each i j such that l le i j le r b i 0 and b j 0 draw an edge from i to j with infinite capacity and cost of unit flow as a i a j Add two more vertices source S and sink T For each i such that l le i le r and b i 0 add an edge from S to i with cost 0 and capacity b i For each i such that l le i le r and b i 0 add an edge from i to T with cost 0 and capacity b i The cost of the subarray is then defined as the minimum cost of maximum flow from S to T You are given q queries in the form of two integers l and r You have to compute the cost of subarray a l r for each query modulo 10 9 7 If you don t know what the minimum cost of maximum flow means read here ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector> \n#define int long long\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[200005],b[200005],ta[200005],qzh[200005];\nint f1[200005],f2[200005],n;\nvoid insert1(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf1[k]=(f1[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query1(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f1[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nvoid insert2(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf2[k]=(f2[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query2(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f2[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nint pos[200005];\nbool bi(int x,int y)\n{\n\treturn qzh[x]<qzh[y];\n}\nint ql[200005],qr[200005],qans[200005];\nvector<int>v[200005];\nsigned main()\n{\n\tint q;\n\tn=read();\n\tq=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=1;i<=n-1;i++)ta[i]=a[i+1]-a[i];\n\tta[n]=0;\n\tfor(int i=1;i<=n;i++)b[i]=read(),qzh[i]=qzh[i-1]+b[i],pos[i]=i;\n\tsort(pos+1,pos+n+1,bi);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tql[i]=read();\n\t\tqr[i]=read();\n\t\tv[qr[i]].push_back(i);\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t//printf(""vis:%lld %lld %lld\\n"",x,ta[x],(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\t//printf(""%lld %lld %lld %lld\\n"",v[x][j],((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod,((query1(qr[v[x][j]])-query1(ql[v[x][j]]-1))%mod+mod)%mod,qzh[ql[v[x][j]]-1]);\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+mod-1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\t//for(int i=1;i<=q;i++)printf(""%lld\\n"",qans[i]);\n\tfor(int i=1;i<=n;i++)f1[i]=f2[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+mod-((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++)printf(""%lld\\n"",qans[i]);\n\treturn 0;\n} ']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 1]",2700,TutorialLet us suppose we need to calculate the answer for only one query say complete array i e The scary flow structure in the problem can be reduced as Let s replicate each vertex times Then we can see that there will be an equal number of vertices on the left and right side Now the problem reduces that we have to match these vertices with minimum cost such that the cost of matching and is There are only 2 type of elements left side and right side and the following greedy algorithm to match the elements works Algorithm Sort the type and elements independently and match them in the sorted order ProofAssume that two elements from left are matched with two elements from right as and then it can be easily shown that matching and is always more optimal The proof is left as an excercise to reader Since the array is given in sorted order let s use it Let s assume Type elements are those having Type elements are those having Now instead of replicating elements times and sorting them independently let s iterate on array from left to right and add the contribution of each element independently Say we are at index and prefix sum of so far is then the following cases arise There is no unmatched type element on the left so we just add this element s contribution to the answer i e There are more than unmatched type elements on the left so we match of them to adding a contribution of to the answer and There are less than unmatched elements on the left so we match those with equal number of and remaining are propagated further adding a contribution of where the positive term comes from those matching with previous unmatched elements and the negative term comes from those that are going to be left unmatched Similar cases are there for Ok so now we can easily solve the problem for one query in Main idea Let s simulate the above algorithm for every suffix and record the obtained answer in for suffix Note that the value doesn t denote any answer for some suffix because the sum of over that suffix might or might not be zero One important observation here is that Let some subarray for which sum of is then do have a good meaning it s the answer for that query indeed ProofOur answer for would have been the result of simulation on the subarray but how does simulation on suffix looks It greedily matches the subarray first because the sum of is zero so it will surely pair up all elements in that subarray Then it moves further on and continuing the simulation after is equivalent to starting the simulation from itself because so far defined above would be automatically 0 Note that doesn t have any physical meaning because it will add some junk value if elements after are not paired up equally but those junk values are exactly same in and which cancel out giving the correct answer But still we can t simulate for every suffix right It would go again Let s iterate from left to right and for every try calculating it s contribution in suffixes which is easy because it depends only on which are constant for a given and for contribution to suffix This is pretty standard using fenwick trees How to calculate Let s solve and independently say for now Other case is similar Let Consider the contribution of index to for from three cases described above the contribution is different for different with different We can build a fenwick tree on compressed prefix sums Case and above add a constant value to a range of prefix sums that can be maintained in one fenwick tree and Case gives some linear function of to be added in a range that can be maintained in other fenwick tree Add contribution of each from to first and let s start calculating For can be obtained by querying at in both fenwicks Then we remove the contribution of from the two fenwick trees simply the negative of which we added above because won t be contributing to any suffix other than one Similarly we move from left to right and calculate by querying at and then remove the contribution of element 
You are given a rooted tree Each vertex contains a i tons of gold which costs c i per one ton Initially the tree consists only a root numbered 0 with a 0 tons of gold and price c 0 per ton There are q queries Each query has one of two types Add vertex i where i is an index of query as a son to some vertex p i vertex i will have a i tons of gold with c i per ton It s guaranteed that c i c p i For a given vertex v i consider the simple path from v i to the root We need to purchase w i tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy x tons of gold in some vertex v the remaining amount of gold in it decreases by x of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst int LOG = 19;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int q, a0, c0;\n  cin >> q >> a0 >> c0;\n  vector<int> A(1), C(1);\n  A[0] = a0;\n  C[0] = c0;\n  int N = 1;\n  vector<int> d(1, 0);\n  vector<int> P(1, -1);\n  vector<vector<int>> pp(LOG, vector<int>(1, -1));\n  vector<int> id(q + 1, -1);\n  id[0] = 0;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 1){\n      id[i + 1] = N;\n      int p, a, c;\n      cin >> p >> a >> c;\n      p = id[p];\n      P.push_back(p);\n      A.push_back(a);\n      C.push_back(c);\n      int d2 = d[p] + 1;\n      d.push_back(d2);\n      pp[0].push_back(p);\n      for (int j = 0; j < LOG - 1; j++){\n        if (pp[j][N] == -1){\n          pp[j + 1].push_back(-1);\n        } else {\n          pp[j + 1].push_back(pp[j][pp[j][N]]);\n        }\n      }\n      N++;\n    }\n    if (t == 2){\n      int v, w;\n      cin >> v >> w;\n      v = id[v];\n      if (A[v] == 0){\n        cout << 0 << ' ' << 0 << endl;\n      } else {\n        int p = v;\n        for (int j = LOG - 1; j >= 0; j--){\n          int p2 = pp[j][p];\n          if (p2 != -1){\n            if (A[p2] > 0){\n              p = p2;\n            }\n          }\n        }\n        int D = d[v] - d[p];\n        int ans1 = 0;\n        long long ans2 = 0;\n        for (int j = D; j >= 0; j--){\n          int v2 = v;\n          for (int k = 0; k < LOG; k++){\n            if ((j >> k & 1) == 1){\n              v2 = pp[k][v2];\n            }\n          }\n          int a = min(A[v2], w);\n          ans1 += a;\n          ans2 += (long long) C[v2] * a;\n          w -= a;\n          A[v2] -= a;\n          if (w == 0){\n            break;\n          }\n        }\n        cout << ans1 << ' ' << ans2 << endl;\n      }\n    }\n  }\n}""]","[1, 0, 0, 1, 1, 0, 0, 1, 0, 0]",2200,Note that for each vertex So if we consider a path from some vertex to the closer you are to the cheaper the cost In other words it s always optimal to choose the highest vertex on the path with Suppose we can find such vertex for a given How many times we will repeat this search operation If we need to buy tons and has tons then it s optimal to buy tons in After we buy tons either becomes or becomes Since for each vertex can become equal to zero at most once and since after is zero we stop buying then there will be searches in total The next question is how to find efficiently for a given Consider the path from to some vertex Since we prefer to buy from higher vertices all empty vertices on this path will form some prefix of it possibly empty prefix So we can make some sort of binary search to find the first non empty vertex But instead of binary search we will use binary lifting technique If we know for each which vertex on the path from to on distance from then we can efficiently jump up the path Let s firstly jump at distance if then we jump too high let s not jump But if then we can safely jump or Now we know that we don t need a second jump so we try jump and so on In other words using binary lifting we can find the highest vertex with in steps Also we can calculate array for vertex right after we add vertex to the tree since and The resulting complexity is 
A cooperative game is played by m people In the game there are 3m sheets of paper m sheets with letter m sheets with letter and m sheets with letter Initially each person is given three sheets possibly with equal letters The goal of the game is to allow each of the m people to spell the word using their sheets of paper In other words everyone should have one sheet with letter one sheet with letter and one sheet with letter To achieve the goal people can make Two people participate in each exchange Both of them choose exactly one sheet of paper from the three sheets they own and exchange it with each other Find the shortest sequence of exchanges after which everyone has one one and one ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<string> s(N);\n\tfor(string& x : s) cin >> x;\n\tvector<vector<vector<int> > > need(3, vector<vector<int> > (3));\n\tfor(int z = 0; z < N; z++){\n\t\tvector<int> freq(3, -1);\n\t\tfor(char c : s[z]){\n\t\t\tif(c == \'w\') freq[0]++;\n\t\t\tif(c == \'i\') freq[1]++;\n\t\t\tif(c == \'n\') freq[2]++;\n\t\t}\n\t\tvector<int> pos, neg;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(freq[i] > 0) for(int j = 0; j < freq[i]; j++) pos.push_back(i);\n\t\t\tif(freq[i] < 0) for(int j = 0; j < -freq[i]; j++) neg.push_back(i);\n\t\t}\n\t\tassert(pos.size() == neg.size());\n\t\tfor(int j = 0; j < pos.size(); j++){\n\t\t\tneed[pos[j]][neg[j]].push_back(z);\n\t\t}\n\t}\n\tstring win = ""win"";\n\tvector<tuple<int, char, int, char> > ans;\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\twhile(!need[i][j].empty() && !need[j][i].empty()){\n\t\t\t\tint x = need[i][j].back();\n\t\t\t\tneed[i][j].pop_back();\n\t\t\t\tint y = need[j][i].back();\n\t\t\t\tneed[j][i].pop_back();\n\t\t\t\tans.push_back({x, win[i], y, win[j]});\n\t\t\t}\n\t\t}\n\t}\n\twhile(!need[0][1].empty()){\n\t\tint x = need[0][1].back();\n\t\tint y = need[1][2].back();\n\t\tint z = need[2][0].back();\n\t\tans.push_back({x, win[0], y, win[1]});\n\t\tans.push_back({y, win[0], z, win[2]});\n\t\tneed[0][1].pop_back();\n\t\tneed[1][2].pop_back();\n\t\tneed[2][0].pop_back();\n\t}\n\twhile(!need[0][2].empty()){\n\t\tint x = need[0][2].back();\n\t\tint y = need[2][1].back();\n\t\tint z = need[1][0].back();\n\t\tans.push_back({x, win[0], y, win[2]});\n\t\tans.push_back({y, win[0], z, win[1]});\n\t\tneed[0][2].pop_back();\n\t\tneed[2][1].pop_back();\n\t\tneed[1][0].pop_back();\n\t}\n\tcout << ans.size() << \'\\n\';\n\tfor(auto [a, b, c, d] : ans){\n\t\tcout << (a+1) << \' \' << b << \' \' << (c+1) << \' \' << d << \'\\n\';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 1]",1900,For each person there are three essential cases of what they could initially have Three distinct letters No need to take part in any exchanges Two equal letters and another letter e g An extra must be exchanged with someone s Three equal letters e g One must be exchanged with someone s another must be exchanged with someone s Let s create a graph on three vertices Whenever person has an extra letter and is lacking letter create a directed edge marked with Once the graph is built whenever you have a cycle of length that is it means person needs to exchange for while person needs to exchange for Thus both of their needs can be satisfied with just one exchange Finally once there are no cycles of length note that the in degree and the out degree of every vertex are equal If e g there are edges it follows that there are edges and edges It means we can form cycles of length The cycles could also go in the opposite direction In any case each cycle of length can be solved using exchanges 
As we all know Max is the best video game player among her friends Her friends were so jealous of hers that they created an actual game just to prove that she s not the best at games The game is played on a directed acyclic graph a DAG with vertices and edges There s a character written on each edge a lowercase English letter Max and Lucas are playing the game Max goes first then Lucas then Max again and so on Each player has a marble initially located at some vertex Each player in his her turn should move his her marble along some edge a player can move the marble from vertex to vertex if there s an outgoing edge from to If the player moves his her marble from vertex to vertex the character of that round is the character written on the edge from to There s one additional rule the ASCII code of character of round should be to the ASCII code of character of round for The rounds are numbered for both players together i e Max goes in odd numbers Lucas goes in even numbers The player that can t make a move loses the game The marbles may be at the same vertex at the same time Since the game could take a while and Lucas and Max have to focus on finding Dart they don t have time to play So they asked you if they both play optimally who wins the game You have to determine the winner of the game for all initial positions of the marbles ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nchar dp[N][N][28][2];\nint n,m,u,v;\nchar s[10];\nvector<PII> e[N];\nbool dfs(int u,int v,int k,int op) {\n\tif (dp[u][v][k][op]!=0x11) return dp[u][v][k][op];\n\tif (op==0) {\n\t\tbool win=0;\n\t\tfor (auto p:e[u]) if (p.se>=k) {\n\t\t\twin|=dfs(p.fi,v,p.se,op^1);\n\t\t\tif (win==1) break;\n\t\t}\n\t\treturn dp[u][v][k][op]=win;\n\t} else {\n\t\tbool win=1;\n\t\tfor (auto p:e[v]) if (p.se>=k) {\n\t\t\twin&=dfs(u,p.fi,p.se,op^1);\n\t\t\tif (win==0) break;\n\t\t}\n\t\treturn dp[u][v][k][op]=win;\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d%s"",&u,&v,s); --u; --v;\n\t\te[u].pb(mp(v,s[0]-\'a\'+1));\n\t}\n\tmemset(dp,0x11,sizeof(dp));\n\trep(i,0,n) {\n\t\trep(j,0,n) if (dfs(i,j,0,0)) putchar(\'A\'); else putchar(\'B\');\n\t\tputs("""");\n\t}\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 1]",1700,Denote as the winner of the game the person that starts it or the other one a boolean true if first person wins if the first person s marble is initially at vertex and the second one s initially at and our set of letters is if is an integer Denote and as the character written on edge from to Now if there s some in such that and then the first person can move his her marble to vertex and win the game thus otherwise it s false Because the graph is a DAG there s no loop in this dp thus we can use memoization The answer for is Total time complexity 
You are given a matrix consisting of n rows and m columns You can perform two types of actions on it paint the entire column in blue paint the entire row in red In one second you can perform either one action or multiple actions at the same time If you perform one action it will be free If you perform k 1 actions at the same time it will cost k 2 coins When multiple actions are performed at the same time for each cell affected by actions of both types the color can be chosen independently You are asked to process q queries Before each query all cells become colorless Initially there are no restrictions on the color of any cells In the i th query a restriction of the following form is added x i y i c i the cell in row x i in column y i should be painted in color c i Thus after i queries there are i restrictions on the required colors of the matrix cells After each query output the minimum cost of painting the matrix according to the restrictions ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0ll get_val(ll x){    if(x<=1) return 0;    return x*x;}\xa0const int maxn=400005;int par[maxn],siz[maxn];ll tot;int Find(int x){return par[x]==x?x:par[x]=Find(par[x]);}void Union(int x, int y){    x=Find(x),y=Find(y);    if(x==y) return;    if(siz[x]<siz[y]) swap(x,y);    tot-=get_val(siz[x])+get_val(siz[y]);    siz[x]+=siz[y],par[y]=x;    tot+=get_val(siz[x]);}\xa0int n,m,q,scc[maxn];ll res[maxn];vector<int> V,adj[maxn],radj[maxn],ord;bool vis[maxn];\xa0void rdfs(int u){    vis[u]=1;    for(auto v: radj[u]) if(!vis[v]) rdfs(v);    ord.pb(u);}\xa0vector<int> de;\xa0void dfs(int u, int rt){    vis[u]=1,de.pb(u),scc[u]=rt;    for(auto v: adj[u]) if(!vis[v]) dfs(v,rt);}\xa0void solve(int l, int r, vector<array<int,3>> edges){    int mid=l+r>>1;    V.clear();    vector<array<int,3>> L,R;    for(auto& [u,v,i]: edges){        u=Find(u),v=Find(v);        V.pb(u),V.pb(v);    }    sort(all(V)),V.resize(unique(all(V))-V.begin());    for(auto u: V) vis[u]=0,adj[u].clear(),radj[u].clear();    for(auto& [u,v,i]: edges) if(i<=mid) adj[u].pb(v),radj[v].pb(u);    ord.clear();    for(auto u: V) if(!vis[u]) rdfs(u);    for(auto u: V) vis[u]=0;    reverse(all(ord));    vector<pii> tmp;    for(auto u: ord) if(!vis[u]){        de.clear();        dfs(u,u);        if(l==r) for(int i=0; i+1<de.size(); ++i) tmp.pb({de[i],de[i+1]});    }    if(l==r){        for(auto [u,v]: tmp) Union(u,v);        res[l]=tot;        return;    }    for(auto& [u,v,i]: edges){        if(scc[u]==scc[v]){            if(i<=mid) L.pb({u,v,i});        }        else R.pb({u,v,i});    }    solve(l,mid,L),solve(mid+1,r,R);}\xa0void ahcorz(){    cin >> n >> m >> q;    for(int i=0; i<n+m; ++i) par[i]=i,siz[i]=1;    vector<array<int,3>> edges(q);    for(int i=0; i<q; ++i){        //int u,v; cin >> u >> v; u--,v--;        int x,y; char c; cin >> x >> y >> c; x--,y--;        if(c==\'R\'){            edges[i]={x,n+y,i};        }        else{            edges[i]={n+y,x,i};        }        //edges[i]={u,v,i};    }    solve(0,q-1,edges);    for(int i=0; i<q; ++i) cout << res[i] << ""\\n"";}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",3000,The main idea is as follows Consider any constraint on a cell If the cell must be red then the last action on this cell must be coloring the row otherwise it should be the column That is if the operation is applied to both the row and the column of this cell then there is a certain order of performing these operations It is also worth noting that it does not make sense to apply the same operation twice because the second application of the operation will recolor all the cells The word order should immediately bring to mind thoughts of directed graphs and topological sorting Let s try to build a graph of operation execution Create a graph with n m vertices one vertex for each row and column If the cell must be red then draw a directed edge from its column to its row Otherwise draw an edge from its row to its column Now we would like to perform operations simply in the order of topological sorting If this is possible i e there are no cycles in the graph then the answer is just 0 This means that operations can always be applied one by one It is also worth noting that we apply the operations that do not color any cells with constraints Their cost is always 0 so they do not change the answer Otherwise there are some strongly connected components in the graph with size greater than 1 In these components we will always have to perform some operations at the same time Of course operations can be applied to the entire component at once The cost will then be equal to the square of the component s size Doesn t sound optimal but that s one way to satisfy the constraints Let s show that it is not possible to do it cheaper Consider the last set of actions on this component If they do not affect the entire component then within the affected subset there will be a vertex with an outgoing edge outside the subset but inside the component otherwise it would be two different components This means that there must be at least one more operation performed on the vertex to which this edge leads Therefore the set of actions considered will not be the last one Then the solution is as follows After adding each constraint add the previously described edges and find the condensation of the graph The answer will be the sum of the squares of the sizes of strongly connected components with size greater than 1 This solution works in O q n m q To optimize this solution you can use the technique of incremental condensation You can read about it in the blog by Radewoosh Since DSU is used in it you can maintain the sum of the squares of the component sizes on the fly The blog describes a solution with a logarithmic time complexity but the problem did not require an implementation faster than log2 Solutions with a logarithmic memory complexity with a large constant might not pass the author s solution consumes O qlogq memory and fits into 50 megabytes 
Currently XXOC s rap is a string consisting of zeroes ones and question marks Unfortunately haters gonna hate They will write x angry comments for every occurrence of and y angry comments for every occurrence of You should replace all the question marks with or in such a way that the number of angry comments would be as small as possible String b is a subsequence of string a if it can be obtained by removing some characters from a Two occurrences of a subsequence are considered distinct if sets of positions of remaining characters are distinct ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\n\nll x,y,ans;\nll f[MAXN];\nll g[MAXN];\nll pre[MAXN];\nll suf[MAXN];\n\nchar s[MAXN];\n\nint main()\n{\n\tans = 1e18;\n\tscanf(""%s%lld%lld"",s + 1,&x,&y);\n\tn = strlen(s + 1);\n\tf[0] = 0;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tchar cur = (s[i] != \'1\' ? \'0\' : \'1\');\n\t\tpre[i] = pre[i - 1] + (cur == \'0\');\n\t\tf[i] = f[i - 1] + (cur == \'0\' ? y * (i - 1 - pre[i - 1]) : x * pre[i - 1]);\n\t}\n\tfor (int i = n;i >= 1;i--)\n\t{\n\t\tchar cur = (s[i] != \'0\' ? \'1\' : \'0\');\n\t\tsuf[i] = suf[i + 1] + (cur == \'1\');\n\t\tg[i] = g[i + 1] + (cur == \'1\' ? y * (n - i - suf[i + 1]) : x * suf[i + 1]);\n\t}\n\tfor (int i = 0;i <= n;i++)\n\t\tans = min(ans,f[i] + g[i + 1] + x * pre[i] * suf[i + 1] + y * (i - pre[i]) * (n - i - suf[i + 1]));\n\t\t\n\tf[0] = 0;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tchar cur = (s[i] != \'0\' ? \'1\' : \'0\');\n\t\tpre[i] = pre[i - 1] + (cur == \'0\');\n\t\tf[i] = f[i - 1] + (cur == \'0\' ? y * (i - 1 - pre[i - 1]) : x * pre[i - 1]);\n\t}\n\tfor (int i = n;i >= 1;i--)\n\t{\n\t\tchar cur = (s[i] != \'1\' ? \'0\' : \'1\');\n\t\tsuf[i] = suf[i + 1] + (cur == \'1\');\n\t\tg[i] = g[i + 1] + (cur == \'1\' ? y * (n - i - suf[i + 1]) : x * suf[i + 1]);\n\t}\n\tfor (int i = 0;i <= n;i++)\n\t\tans = min(ans,f[i] + g[i + 1] + x * pre[i] * suf[i + 1] + y * (i - pre[i]) * (n - i - suf[i + 1]));\n\t\t\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}']","[1, 0, 1, 0, 1, 1, 0, 0, 0, 0]",2100,Consider two adjacent question marks at positions l and r l r Let c0 zeros and c1 ones be on the interval l r In case sl 0 sr 1 there will be written c1 1 x c0 x out c0 c1 1 x out r l x out comments where out is the number of comments for subsequences at least one element of which is outside l r In the case sl 1 sr 0 we get c0 1 y c1 y out c0 c1 1 y out r l y out comments Subtract the second from the first we get r l x y This means the following if x y it is always better to change 01 to 10 That is there is such an optimal substitution of by 0 and 1 that some prefix of are replaced by 1 and the remaining by 0 In the case of x y similarly there will be some prefix of 0 then suffix of 1 For O n implementation you can count how many ones and zeros on each prefix and iterate over the separation boundary 
Leha like all kinds of strange things Recently he liked the function Consider all possible element subsets of the set For subset find minimal element in it mathematical expectation of the minimal element among all element subsets But only function does not interest him He wants to do interesting things with it Mom brought him two arrays and each consists of integers For all such that the condition holds Help Leha rearrange the numbers in the array so that the sum is maximally possible where is already rearranged array ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n;\n\twhile (~scanf(""%d"", &n)) {\n\t\tvector<int> A(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &A[i]);\n\t\tvector<int> B(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &B[i]);\n\t\tvpii Ais(n), Bis(n);\n\t\trep(i, n) {\n\t\t\tAis[i] = { A[i], i };\n\t\t\tBis[i] = { B[i], i };\n\t\t}\n\t\tsort(Ais.begin(), Ais.end());\n\t\tsort(Bis.begin(), Bis.end());\n\t\tvector<int> ans(n);\n\t\trep(i, n)\n\t\t\tans[Bis[i].second] = Ais[n - 1 - i].first;\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(\' \');\n\t\t\tprintf(""%d"", ans[i]);\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",1300,First of all let s understand what is the value of F N K For any subset of size K say a1 a2 aK we can represent it as a sequence of numbers d1 d2 dK 1 so that d1 a1 d1 d2 a2 We re interested in E d1 expected value of d1 Knowing some basic facts about expected values we can derive the following E d1 dK 1 N 1 E d1 E dK 1 K 1 E d1 And we immediately get that We could also get the formula by using the Hockey Stick Identity as Benq stated in his comment Now according to rearrangement inequality is maximized when A is increasing and B is decreasing 
We saw the little game Marmot made for Mole s lunch Now it s Marmot s dinner time and as we all know Marmot eats flowers At every dinner he eats some red and white flowers Therefore a dinner can be represented as a sequence of several flowers some of them white and some of them red But for a dinner to be tasty there is a rule Marmot wants to eat white flowers only in groups of size Now Marmot wonders in how many ways he can eat between and flowers As the number of ways could be very large print it modulo ,"['#include <cstdio>\n\nconst int kMaxN = 100000;\nconst int kMod = 1000000007;\nint t, k;\nint f[kMaxN + 1], s[kMaxN + 1];\n\n#define UPT(x, y) { \\\n    (x) += (y); \\\n    if ((x) >= kMod) (x) -= kMod; \\\n}\n\nint main() {\n    scanf(""%d%d"", &t, &k);\n    f[0] = 1;\n    for (int i = 0; i < kMaxN; ++ i) {\n        UPT(f[i + 1], f[i]);\n        if (i + k <= kMaxN) {\n            UPT(f[i + k], f[i]);\n        }\n    }\n    for (int i = 1; i <= kMaxN; ++ i) {\n        s[i] = s[i - 1];\n        UPT(s[i], f[i]);\n    }\n    for (int a, b; t --; ) {\n        scanf(""%d%d"", &a, &b);\n        int res = s[b] - s[a - 1];\n        if (res < 0) res += kMod;\n        printf(""%d\\n"", res);\n    }\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1700,We can notate each string as a binary string instead of red and white flowers A string of this type is good only if every maximal contigous subsequence of has the length divisible by We can make dynamic programming this way the number of good strings of length If the th character is then we can have any character before and if the th character is we must have another characters before so for and for Then we compute the partial sums and for each query the result will be This solution has the complexity where is the maximum value of 
You are given three integers n d and k Your task is to construct an undirected tree on n vertices with diameter d and degree of each vertex at most k or say that it is impossible An undirected tree is a connected undirected graph with n 1 edges Diameter of a tree is the maximum length of a simple path a path in which each vertex appears at most once between all pairs of vertices of this tree Degree of a vertex is the number of edges incident to this vertex i e for a vertex u it is the number of edges u v that belong to the tree where v is any other vertex of a tree ,"['#include ""bits/stdc++.h""\n#define MAXN 400009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<""----------------""<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<"" = ""<< x<<endl;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nint deg[MAXN];\nvoid fail(){\n\tputs(""NO"");\n\texit(0);\n}\nint main(){\n    //~ freopen(""file.in"", ""r"", stdin);\n    int n,d,k;\n    scanf(""%d%d%d"",&n,&d,&k);\n    if(n-1<d)\n\t\tfail();\n\tvector<PII>ans;\n\tqueue<PII>q;\n\tfor(int i=1;i<=d;i++){\n\t\tans.pb(mp(i,i+1));\n\t\tdeg[i]++;\n\t\tdeg[i+1]++;\n\t}\n\tfor(int i=1;i<=d+1;i++){\n\t\tint depth=min(i,d+2-i)-1;\n\t\tif(depth)\n\t\t\tq.push(mp(depth,i));\n\t}\n\tint node=d+1;\n\twhile(!q.empty()){\n\t\tPII nd=q.front();q.pop();\n\t\t//~ cout<<nd.ff<<"" ""<<nd.ss<<"" ""<<deg[nd.ss]<<"" ""<<k<<"" ""<<ans.size()<<endl;\n\t\tif((int)ans.size()<n-1){\n\t\t\twhile((int)ans.size()<n-1 and deg[nd.ss]<k){\n\t\t\t\t++node;\n\t\t\t\tdeg[nd.ss]++;deg[node]++;\n\t\t\t\t//~ cout<<nd.ss<<"" ""<<node<<endl;\n\t\t\t\tans.pb(mp(nd.ss,node));\n\t\t\t\tif(nd.ff>1)\n\t\t\t\t\tq.push(mp(nd.ff-1,node));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tif((int)ans.size()<n-1)\n\t\tfail();\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]>k)\n\t\t\tfail();\n\t\t\n\tputs(""YES"");\n\ttr(it,ans)\n\t\tprintf(""%d %d\\n"",it->ff,it->ss);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",2100,Let s construct a tree by the following algorithm if let s print and terminate the program Otherwise let s keep the array of the length which will represent degrees of vertices The first step is to construct the diameter of the tree Let first vertices form it Let s add edges to the answer increase degrees of vertices corresponding to this edges and if some vertex has degree greater than print and terminate the program The second and the last step is to attach the remaining vertices to the tree Let s call the vertex if its degree is less than Also let s keep all vertices forming the diameter in some data structure which allows us to take the vertex with the minimum maximal distance to any other vertex and remove such vertices It can be done by for example set of pairs where is a maximum distance from the vertex to any other vertex Now let s add all vertices from starting from the vertex 0 indexed to the vertex let the current vertex be We get the vertex with the minimum maximal distance to any other vertex let it be Now we increase the degree of vertices and add the edge between they and if still be return it to the data structure otherwise remove it The same with the vertex it is obvious that its maximal distance to any other vertex will be equals If at any step our data structure will be empty or the minimum maximal distance will be equals the answer is Otherwise we can print the answer See my solution to better understanding Overall complexity or depends on implementation 
James Bond Johnny s favorite secret agent has a new mission There are n enemy bases each of them is described by its coordinates so that we can think about them as points in the Cartesian plane The bases can communicate with each other sending a signal which is the ray directed from the chosen point to the origin or in the opposite direction The exception is the central base which lies at the origin and can send a signal in any direction When some two bases want to communicate there are two possible scenarios If they lie on the same line with the origin one of them can send a signal directly to the other one Otherwise the signal is sent from the first base to the central and then the central sends it to the second base We denote the distance between two bases as the total Euclidean distance that a signal sent between them has to travel Bond can damage all but some k bases which he can choose arbitrarily A damaged base can t send or receive the direct signal but still can pass it between two working bases In particular James can damage the central base and the signal between any two undamaged bases as before so the distance between them remains the same What is the maximal sum of the distances between all pairs of remaining bases that 007 can achieve by damaging exactly n k of them ,"[""/**\n *    author:  tourist\n *    created: 04.06.2020 18:33:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> x(n);\n  vector<int> y(n);\n  vector<double> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    d[i] = sqrt((double) ((long long) x[i] * x[i] + (long long) y[i] * y[i]));\n    if (x[i] != 0 || y[i] != 0) {\n      int g = __gcd(abs(x[i]), abs(y[i]));\n      x[i] /= g;\n      y[i] /= g;\n    }\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    if (x[i] != x[j]) {\n      return x[i] < x[j];\n    }\n    if (y[i] != y[j]) {\n      return y[i] < y[j];\n    }\n    return d[i] < d[j];\n  });\n  vector<double> r;\n  int beg = 0;\n  while (beg < n) {\n    int end = beg;\n    int dx = x[order[beg]];\n    int dy = y[order[beg]];\n    while (end + 1 < n && x[order[end + 1]] == dx && y[order[end + 1]] == dy) {\n      end += 1;\n    }\n    int L = beg, R = end;\n    for (int i = 0; i < k / 2 && L <= R; i++) {\n      int coeff = k - 1 - 2 * i;\n      r.push_back(d[order[R]] * coeff);\n      R -= 1;\n    }\n    if (k % 2 == 0) {\n      double sum = 0;\n      while (L <= R) {\n        r.push_back(-(sum + d[order[L]]));\n        sum += 2 * d[order[L]];\n        L += 1;\n      }\n    } else {\n      double sum = 0;\n      while (L <= R) {\n        r.push_back(-sum);\n        sum += 2 * d[order[L]];\n        L += 1;\n      }\n    }\n    beg = end + 1;\n  }\n  sort(r.rbegin(), r.rend());\n  double ans = 0;\n  for (int i = 0; i < k; i++) {\n    ans += r[i];\n  }\n  cout << fixed << setprecision(17) << ans << '\\n';\n  return 0;\n}\n""]","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",2900,We can easily model the way of calculating distances from the problem statement as a tree with vertices each corresponding to a base This tree has the following structure there is only one vertex which can have degree bigger than the one corresponding to the central base I will call it the center of the tree There are also some paths consisting of vertices corresponding to bases lying on the same half line starting at point We will call those arms of the tree Assume that the center does not belong to any arm The task is to choose vertices in a way that maximizes the sum of distances between them Let us start with a lemma If vertices are chosen from an arm at least of them are the ones furthest from the center Say that less than is chosen from the end of the arm counting from the center Then there exists such chosen vertex on the arm that the next counting from the center vertex is not chosen Let the length of the edge between them be and let there be vertices further from the center than If we had chosen instead of the sum of distances would change by the chosen vertex would move closer by to vertices but also it s distance to vertices would increase by But since this value is non negative the sum of distances would not decrease There are two cases which will be solved independently First case there is no arm containing more than vertices chosen By the lemma in every arm only vertices furthest from the center will be selected in an optimal solution If a vertex is chosen all the ones in the same arm further from the center are chosen as well Using this knowledge we can assign weights to vertices in such a way that the result for a set will be the sum of weights Weight for vertex equals where is the number of vertices further from center in the same arm as The weight of the center equals Note that with exception to the center iff taking would violate the condition that at most are chosen from every arm The algorithm for this case is to add the vertices greedily to the set until vertices have been chosen The complexity of the above algorithm is Second case there is an arm in which more than vertices are chosen in the optimal solution From the lemma we know that vertices lying furthest from the center will be chosen It can be proved in a similar manner as the lemma that in an optimal solution all other selected vertices from this arm will be as close to the center as possible Furthermore the center and all the vertices in the other arms will be selected Intuitively when there are chosen vertices on a single arm we will not decrease the sum of distances by moving another selected vertex further from them along an edge There is at most one set of vertices satisfying those conditions so that this part can be implemented in The time complexity of this solution is 
Vasya owns three strings s a and b each of them consists only of first k Latin letters Let a template be such a string of length k that each of the first k Latin letters appears in it exactly once thus there are k distinct templates Application of template p to the string s is the replacement of each character in string s with p i i is the index of this letter in the alphabet For example applying template to a string yields string Vasya wants to know if there exists such a template which yields a string lexicographically greater than or equal to string a and lexicographically less than or equal to string b after applying it to s If there exist multiple suitable templates print any of them String a is lexicographically less than string b if there is some i 1 le i le n that a i b i and for any j 1 le j i a j b j You are required to answer t testcases ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Testcase {\n  string s, a, b;\n  int K;\n  string mapping;\n  vector<bool> taken;\n\n  bool Bt(int pos, bool is_a, bool is_b) {\n    debug(pos, is_a, is_b);\n    if (pos == SZ(s) || (!is_a && !is_b)) {\n      return true;\n    }\n\n    bool new_ch = true;\n    char min_ch = is_a ? a[pos] : \'a\';\n    char max_ch = is_b ? b[pos] : \'a\' + K - 1;\n    if (mapping[s[pos] - \'a\']) {\n      const char val_new_ch = mapping[s[pos] - \'a\'];\n      if (val_new_ch < min_ch || val_new_ch > max_ch) { return false; }\n      min_ch = max_ch = val_new_ch;\n      new_ch = false;\n    }\n    for (char ch = min_ch; ch <= max_ch; ++ch) {\n      if (new_ch) {\n        if (taken[ch - \'a\']) { continue; }\n        taken[ch - \'a\'] = true;\n        mapping[s[pos] - \'a\'] = ch;\n      }\n\n      if (Bt(pos + 1, is_a && ch == a[pos], is_b && ch == b[pos])) {\n        return true;\n      }\n\n      if (new_ch) {\n        taken[ch - \'a\'] = false;\n        mapping[s[pos] - \'a\'] = 0;\n      }\n    }\n\n    return false;\n  }\n\n  void Run() {\n    cin >> K >> s >> a >> b;\n    mapping.resize(K);\n    taken.resize(K);\n\n    if (Bt(0, true, true)) {\n      cout << ""YES\\n"";\n\n      string unused;\n      for (int i = 0; i < K; ++i)\n        if (!taken[i]) {\n          unused += \'a\' + i;\n        }\n\n      for (char &ch : mapping) {\n        if (!ch) {\n          ch = unused.back();\n          unused.pop_back();\n        }\n      }\n      cout << mapping << ""\\n"";\n    } else {\n      cout << ""NO\\n"";\n    }\n  }\n};\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int T;\n  cin >> T;\n  for (int i = 0; i < T; ++i)\n    Testcase().Run();\n}\n\n']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0]",2300,Let s implement the following strategy obtain the minimal string which is greater than or equal to to correspond to at least one template If there exists such a string and it is less than or equal to then the answer exists otherwise it s not Let s iterate over the length of prefix of the answer which equals the prefix of For some fixed length we can restore some part of the template For example let prefix of be and prefix of be template will then look like Also sometimes prefix can have no answer Now we want to expand the prefix with some character at position If that character had appeared already then the substitute is known Also if the substitute is less than then the resulting string will be less than so it will be incorrect If it equals then put it and proceed to position And if it s greater then the resulting string will be greater than so the rest of the string can be filled greedily minimizing the resulting string If character hadn t appeared previously then let s try all possible character to substitute it let it be some character That character should be greater than or equal to and it shouldn t be already taken If is greater then then the rest of the string can be filled greedily minimizing the resulting string Otherwise it s and we proceed to position It s easy to show that the greedy filling will be performed no more than times thus the solution will work in 
Let s call an array a if you can make all its elements the same by using the following operation an arbitrary number of times possibly zero choose an index i 2 le i le a 1 such that a i 1 a i 1 and replace a i with a i 1 You are given a beautiful array a 1 a 2 dots a n What is the minimum number of elements you have to remove from it in order for it to stop being beautiful Swapping elements is prohibited If it is impossible to do so then output ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    int n; cin >> n;    vi a(n); cin >> a;    if(a[0]!=a[n-1]){        print(0);        return;    }    vi vec;    vec.pb(-1);    rep(n) if(a[i]!=a[0]) vec.pb(i);    vec.pb(n);    if(sz(vec)<=2){        print(-1);        return;    }    int mn=1e9;    rep(sz(vec)-1) chmin(mn,vec[i+1]-vec[i]-1);    print(mn);}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1200,As given in the problem statement the definition of a beautiful array is not very interesting to us since checking the beauty of an array is quite complex Let s try to simplify it First of all the first and last elements will never be changed as it is impossible to choose such for operations If they are different then the array is definitely not beautiful Moreover if the array is beautiful then all its elements at the end will be equal to the first and the last elements The second idea is a bit more complicated Notice that each element can be changed at most once Consider an arbitrary operation We choose some for which and change to Now both and will always remain equal to their current values because in any operation involving them will also be involved This means that will also remain equal to the new value The next idea is as follows We know what all the elements should be equal to in the end This means that we need to apply operations to all elements that are not equal to this value According to the previous idea this is possible if and only if there are no two consecutive numbers in the array that are not equal to this value The sufficiency of this condition is obvious and the necessity is left as an exercise to the reader In other words the check looks like this and or or both are equal for all What elements should be removed so that the check does not pass There are two options break the first or second condition So you can do the following remove the entire prefix of numbers equal to remove the entire suffix of numbers equal to or they are equal to each other since the given array is beautiful choose two numbers that are not equal to and remove all the numbers between them so that these two numbers become adjacent The third condition can be simplified If other numbers not equal to are encountered between the selected numbers then another pair can be chosen for which fewer numbers have to be removed Therefore it is only optimal to choose a pair for which all the numbers between them are equal to Then the solution is as follows Find the shortest block of numbers equal to Remove it from the array It can be at the prefix or at the suffix then the first condition will be broken Or it can be somewhere in the middle then the second condition will be broken To find such a block you can go through the array from left to right maintaining the position of the previous element not equal to If the current element is not equal to update the answer with the difference between the saved and current positions and update the saved position The only case when the answer is is when all the elements of the array are the same Otherwise it is always possible to make the array not beautiful Overall complexity for each testcase 
Bessie is out grazing on the farm which consists of n fields connected by m bidirectional roads She is currently at field 1 and will return to her home at field n at the end of the day The Cowfederation of Barns has ordered Farmer John to install one extra bidirectional road The farm has k special fields and he has decided to install the road between two different special fields He may add the road between two special fields that already had a road directly connecting them After the road is added Bessie will return home on the shortest path from field 1 to field n Since Bessie needs more exercise Farmer John must the length of this shortest path Help him ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n \nconst int N=201000;\nint q[N],vis[N],d1[N],d2[N];\nint n,m,k,spe[N],u,v;\nVI e[N];\n \nvoid bfs(int s,int *d) {\n\trep(i,1,n+1) vis[i]=0,d[i]=n+1;\n\tint t=0;\n\tvis[s]=1; d[s]=0;\n\tq[t++]=s;\n\trep(i,0,t) {\n\t\tint u=q[i];\n\t\tfor (auto v:e[u]) if (d[v]>d[u]+1) {\n\t\t\td[v]=d[u]+1;\n\t\t\tq[t++]=v;\n\t\t}\n\t}\n}\n \nint main() {\n\tscanf(""%d%d%d"",&n,&m,&k);\n\trep(i,0,k) scanf(""%d"",spe+i);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tbfs(1,d1);\n\tbfs(n,d2);\n\tsort(spe,spe+k,[&](int a,int b) {\n\t\treturn d1[a]-d2[a]<d1[b]-d2[b];\n\t});\n\tint ans=0;\n\trep(i,1,k) {\n\t\tans=max(ans,d1[spe[i-1]]+d2[spe[i]]+1);\n\t\t//assert(d1[spe[i-1]]+d2[spe[i]]+1<=d2[spe[i-1]]+d1[spe[i]]+1);\n\t}\n\tans=min(ans,d1[n]);\n\tprintf(""%d\\n"",ans);\n}']","[1, 0, 0, 0, 1, 0, 0, 1, 1, 1]",1900,There are a few solutions that involve breadth first search BFS and sorting this is just one of them First let s use BFS to find the distance from fields and to each special field For a special field let denote the distance to node and denote the distance to We want to choose two fields and to maximize Without loss of generality suppose Now we want to maximize subject to This can be done by sorting by and iterating over while keeping a suffix maximum array of to compute Remember that an upper bound of the answer is the distance between field and Time Complexity 
Given an array a of length n Let s construct a square matrix b of size n times n in which the i th row contains the array a cyclically shifted to the right by i 1 For example for the array a 3 4 5 the obtained matrix isb begin bmatrix 3 4 5 5 3 4 4 5 3 end bmatrix Let s construct the following graph The graph contains n 2 vertices each of which corresponds to one of the elements of the matrix Let s denote the vertex corresponding to the element b i j as i j We will draw an edge between vertices i 1 j 1 and i 2 j 2 if i 1 i 2 j 1 j 2 le k and gcd b i 1 j 1 b i 2 j 2 1 where gcd x y denotes the greatest common divisor of integers x and y Your task is to calculate the number of connected components dagger in the obtained graph dagger A connected component of a graph is a set of vertices in which any vertex is reachable from any other via edges and adding any other vertex to the set violates this rule ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));const int MAXN=2e6+5;int n,k,m,a[MAXN],fa[MAXN];int p[MAXN],pr[MAXN],lst[MAXN];bool vis[MAXN];inline int find(int x){\twhile(x^fa[x]) x=fa[x]=fa[fa[x]];\treturn x;}void init(){\tfor(int i=2;i<MAXN;i++){\t\tif(!vis[i]) p[i]=i,pr[++m]=i;\t\tfor(int j=1;j<=m&&pr[j]*i<MAXN;j++){\t\t\tp[pr[j]*i]=pr[j];\t\t\tvis[pr[j]*i]=true;\t\t\tif(i%pr[j]==0) break;\t\t}\t}}void solve(){\tcin>>n>>k;\tll ans=0;\tfor(int i=1;i<=n;i++){\t\tcin>>a[i];\t\tif(a[i]==1) ans+=n-2+(i==1);\t}\treverse(a+1,a+n+1);\tfor(int i=1;i<n;i++) a[n+i]=a[i];\tn=2*n-1;\tfor(int i=1;i<=n;i++) fa[i]=i;\tvector<int> ini;\tfor(int i=1;i<=n;i++){\t\twhile(a[i]>1){\t\t\tint x=p[a[i]];a[i]/=x;ini.push_back(x);\t\t\tif(lst[x]&&i-lst[x]<=k) fa[find(i)]=find(lst[x]);\t\t\tlst[x]=i;\t\t}\t}\tfor(int i=1;i<=n;i++) if(find(i)==i) ans++;\tcout<<ans<<\'\\n\';\tfor(int i:ini) lst[i]=0;}int main(){\tios::sync_with_stdio(false);\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tinit();\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 1]",2400,Notice that since we have cyclic shifts to the right and the diagonals parallel to the main one will be in the same connected component except for the case with ones Diagonals consisting of ones will be counted separately and forgotten After that we can solve the problem for the one dimensional case where each element is a representative of its diagonal By definition if the GCD of some pair of elements is greater than then this means that they are both divisible by some prime number Let s find all the elements of the array diagonals that are divisible by each prime number Let the indices of the current prime number be We will draw edges between and if It is claimed that the connected components in such a graph will coincide with the connected components if we draw edges between all valid pairs Indeed if there is an edge between two elements in the complete graph this means that the distance between them is not greater than and we can reach them in the new graph either by one edge or through elements that are divisible by the same prime number Using the sieve of Eratosthenes we can quickly factorize all numbers into prime divisors after which the number of connected components in the graph can be calculated using DSU or DFS The time complexity of this solution is 
Little Sasha has two friends whom he wants to please with gifts on the Eighth of March To do this he went to the largest shopping center in the city There are n departments in the mall each of which has exactly two stores For convenience we number the departments with integers from 1 to n It is known that gifts in the first store of the i department cost a i rubles and in the second store of the i department b i rubles Entering the mall Sasha will visit each of the n departments of the mall and in each department he will enter exactly one store When Sasha gets into the i th department he will perform exactly one of two actions Buy a gift for the first friend spending a i rubles on it Buy a gift for the second friend spending b i rubles on it Sasha is going to buy at least one gift for each friend Moreover he wants to pick up gifts in such a way that the price difference of the most expensive gifts bought for friends is as small as possible so that no one is offended More formally let m 1 be the maximum price of a gift bought to the first friend and m 2 be the maximum price of a gift bought to the second friend Sasha wants to choose gifts in such a way as to minimize the value of lvert m 1 m 2 rvert ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> ls(n);\n\trep(i,n){\n\t\tint a,b;cin>>a>>b;\n\t\tls[i]=pi(a,b);\n\t}\n\tint ans=inf;\n\trep(k,2){\n\t\tsort(all(ls));\n\t\t\n\t\tset<pi> s;\n\t\trep(i,n)s.emplace(ls[i].b,i);\n\t\tint need=-inf;\n\t\tper(i,n){\n\t\t\tif(ls[i].a<need)break;\n\t\t\ts.erase(pi(ls[i].b,i));\n\t\t\twhile(si(s)){\n\t\t\t\tauto itr=prev(s.ed);\n\t\t\t\tif(ls[i].a<itr->a)s.erase(itr);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tint val=need;\n\t\t\tif(si(s))chmax(val,prev(s.ed)->a);\n\t\t\tchmin(ans,ls[i].a-val);\n\t\t\tchmax(need,ls[i].b);\n\t\t}\n\t\t\n\t\tfor(auto&[a,b]:ls)swap(a,b);\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0]",1800,SolutionTo begin with let s sort all departments in descending order and if is equal in ascending order Now let s go through the department in which the most expensive gift for the second girlfriend will be bought Note that in all departments with numbers Sasha must buy a gift for the first girlfriend otherwise the gift will not have the maximum value among the gifts bought for the second girlfriend Therefore we will immediately find the value of Thus we can already get the answer In all departments with numbers for which Sasha can buy a gift for any of her friends and this will not affect the answer in any way Now consider all departments with numbers for which If you buy a gift for your first girlfriend in some of these departments the value of will increase which means the answer may improve Therefore let s iterate through all these departments and update the response with the value Time Let s optimize this solution To begin with instead of calculating the value of anew at each iteration we will maintain its value in some variable Then when moving from department to department we will update the value of as follows It remains to learn how to quickly find the optimal department number such that as well as is minimal Let s choose on the suffix of the array the minimum such that and also the maximum such that You can notice that the optimal is one of the two selected numbers you also need to remember to check the condition Therefore it is enough to update the answer only with the help of them You can search for these two elements using the texttt set data structure We will support in the set all located on the suffix Then you can find the necessary two elements for When moving from department to department you need to remove the value from the data structure Time 
In the snake exhibition there are n rooms numbered 0 to n 1 arranged in a circle with a snake in each room The rooms are connected by n conveyor belts and the i th conveyor belt connects the rooms i and i 1 bmod n In the other words rooms 0 and 1 1 and 2 ldots n 2 and n 1 n 1 and 0 are connected with conveyor belts The i th conveyor belt is in one of three states If it is clockwise snakes can only go from room i to i 1 bmod n If it is anticlockwise snakes can only go from room i 1 bmod n to i If it is off snakes can travel in either direction Above is an example with 4 rooms where belts 0 and 3 are off 1 is clockwise and 2 is anticlockwise Each snake wants to leave its room and come back to it later A room is if the snake there can leave the room and later come back to it using the conveyor belts How many such rooms are there ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nint ile;\n\nint lew, pra;\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz);\n\tile=0;\n\tfor (int i=0; i<n; i++)\n\t\tif (wcz[i]==\'-\' || wcz[(i+1)%n]==\'-\')\n\t\t\tile++;\n\tlew=pra=0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (wcz[i]==\'<\')\n\t\t\tlew=1;\n\t\tif (wcz[i]==\'>\')\n\t\t\tpra=1;\n\t}\n\tif (!lew || !pra)\n\t\tile=n;\n\tprintf(""%d\\n"", ile);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1]",1200,Let s consider two ways to return to the start point The first is to go one big round around the circle The second is to move 1 step to the side and return back immediately Going one big round is only possible if and only if There are no clockwise belts OR There are no anticlockwise belts If we can go one big round all rooms are returnable If there are both clockwise and anticlockwise belts then we can t go one big round For any room to be returnable it must have an off belt to the left or to the right In summary check if clockwise belts are absent or if anticlockwise belts are absent If either is absent the answer is Otherwise we have to count the number of rooms with an off belt to the left or to the right 
Suppose you have two polynomials and Then polynomial can be uniquely represented in the following way This can be done using long division Here denotes the degree of polynomial is called the remainder of division of polynomial by polynomial it is also denoted as Since there is a way to divide polynomials with remainder we can define Euclid s algorithm of finding the greatest common divisor of two polynomials The algorithm takes two polynomials If the polynomial is zero the result is otherwise the result is the value the algorithm returns for pair On each step the degree of the second argument decreases so the algorithm works in finite number of steps But how large that number could be You are to answer this question You are given an integer You have to build two polynomials with degrees not greater than such that their coefficients are integers not exceeding by their absolute value the leading coefficients ones with the greatest power of are equal to one and the described Euclid s algorithm performs exactly steps finding their greatest common divisor Moreover the degree of the first polynomial should be greater than the degree of the second By a step of the algorithm we mean the transition from pair to pair ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <int> Vl[155];\nint main() {\n\tVl[0].push_back(1);\n\tVl[1].push_back(0);\n\tVl[1].push_back(1);\n\n\tint i, j;\n\tfor (i = 2; i <= 150; i++) {\n\t\tVl[i].push_back(0);\n\t\tfor (auto it : Vl[i - 1]) Vl[i].push_back(it);\n\n\t\tfor (j = 0; j < Vl[i - 2].size(); j++) Vl[i][j] += Vl[i - 2][j];\n\t\tfor (j = 0; j < Vl[i].size(); j++) if (abs(Vl[i][j]) >= 2) break;\n\t\tif (j >= Vl[i].size()) continue;\n\t\tfor (j = 0; j < Vl[i - 2].size(); j++) Vl[i][j] -= 2 * Vl[i - 2][j];\n\t\tfor (j = 0; j < Vl[i].size(); j++) if (abs(Vl[i][j]) >= 2) break;\n\t\tif (j >= Vl[i].size()) continue;\n\t}\n\n\tint N;\n\tscanf(""%d"", &N);\n\tprintf(""%d\\n"", Vl[N].size()-1);\n\tfor (auto it : Vl[N]) printf(""%d "", it);\n\tprintf(""\\n"");\n\tprintf(""%d\\n"", Vl[N - 1].size()-1);\n\tfor (auto it : Vl[N - 1]) printf(""%d "", it);\n\tprintf(""\\n"");\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",2200,As for integers it is well known that worst case are consequent Fibonacci s numbers Solutions to this problem are based on the same idea There were two main intended solutions First of all you should note that sequence Gives us the family of solutions we just have to output and It can be directly checked for given constraints that you can always choose or to satisfy coefficients constraints The other solution is the same sequence but you use instead of and take coefficients modulo That s true because if remainders sequence has steps while you consider numbers by some modulo it will have at least steps in rational numbers So the second intended solution is 
You have c 1 letters c 2 letters c 26 letters You want to build a string of length n from them obviously you cannot use the i th letter more than c i times A string is called if there are no palindromic contiguous substrings of odd length greater than 1 in it For example the string is not beautiful it has several palindromic substrings of odd length greater than 1 for example Another example the string is Calculate the number of different strings you can build and print the answer modulo 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid solve() {\n\n    int N; cin >> N;\n    int A[26]; F0R(i, 26) cin >> A[i];\n    mi dp[N+1][N+1][3][3];\n    mi nxt[N+1][N+1][3][3];\n    dp[0][0][2][2] = 1;\n    F0R(iter, N) {\n        F0R(i, N+1) {\n            F0R(j, N+1) {\n                F0R(k, 3) {\n                    F0R(l, 3) {\n                        if (i < N && k != 0) {\n                            nxt[i+1][j][l][0]+=dp[i][j][k][l];\n                        }\n                        if (j < N && k != 1) {\n                            nxt[i][j+1][l][1] += dp[i][j][k][l];\n                        } \n                        if (k != 2 || iter < 2)  {\n                            nxt[i][j][l][2] += dp[i][j][k][l];\n                        }\n                        nxt[i][j][l][2] += dp[i][j][k][l] * 23;\n                    }\n                }\n            }\n        }\n        F0R(i, N+1) F0R(j, N+1) F0R(k, 3) F0R(l, 3) dp[i][j][k][l] = nxt[i][j][k][l];\n        F0R(i, N+1) F0R(j, N+1) F0R(k, 3) F0R(l, 3) nxt[i][j][k][l] = 0;\n    }\n\n    mi wayOne[N+1], wayTwo[N+1][N+1];\n    F0R(i, N+1) {\n        F0R(j, N+1) {\n            F0R(k, 3) {\n                F0R(l, 3) {\n                    wayOne[i] += dp[i][j][k][l];\n                    wayTwo[i][j] += dp[i][j][k][l];\n                }\n            }\n        }\n    }\n    F0Rd(i, N) wayOne[i] += wayOne[i+1];\n    F0Rd(i, N+1) {\n        F0Rd(j, N+1) {\n            if (i < N) {\n                wayTwo[i][j] += wayTwo[i+1][j];\n            }\n            if (j < N) {\n                wayTwo[i][j] += wayTwo[i][j+1];\n            }\n            if (i < N && j < N) wayTwo[i][j] -= wayTwo[i+1][j+1];\n        }\n    }\n    mi ans = pow(mi(25), N-2) * 26 * 26;\n    F0R(i, 26) {\n        if (A[i] < N) ans -= wayOne[A[i]+1];\n        FOR(j, i+1, 26) {\n            if (A[i] + A[j] + 2 <= N) ans += wayTwo[A[i]+1][A[j]+1];\n        }\n    }\n    cout << ans << nl;\n    \n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2700,Suppose there is no constraint on the number of letters used Then this problem can be solved with the following dynamic programming let be the number of strings of length ending with characters and that don t contain palindromes of odd length greater than obviously each forbidden palindrome contains a subpalindrome of length so we only need to ensure that there are no palindromes of length The thing we are going to use in order to ensure that all the constraints on the number of characters are met is inclusion exclusion Since each at most two characters can violate their constraints in a single string so we will iterate on some character of the alphabet and subtract the number of strings violating the constraint on this character from the answer then iterate on a pair of characters and add the number of strings violating the constraints on these two characters to the answer Okay how to calculate the number of strings violating the constraint on some fixed character Let s use dynamic programming the number of strings such that they contain characters of them have the same type that we fixed the previous to last character is and the last character is The number of states here seems to be something about but in fact and can be optimized to have only two different values since we are interested in two types of characters the ones that coincide with the character we fixed and the ones that don t Okay what about violating the constraints on two characters The same method can be used here let be the number of strings consisting of characters such that the number of occurrences of the first fixed character is the number of occurrences of the second fixed character is the previous to last character is and the last character is Again at first it seems that there are up to states but and can be optimized to have only different values so the number of states is actually It seems that we have to run this dynamic programming for each pair of characters right In fact no the only difference is which states violate the constraints and which don t We can run this dp only once and when we need an answer for the pair of characters we can use two dimensional prefix sums to query the sum over with and in In fact this dynamic programming can also be used for the first and the second part of the solution calculating the strings that don t violate any constraints and the strings that violate the constraints on one character so the hardest part of the solution runs in though with a pretty big constant factor 
A 10 times 10 target is made out of five rings as shown Each ring has a different point value the outermost ring 1 point the next ring 2 points the center ring 5 points Vlad fired several arrows at the target Help him determine how many points he got ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\n\nvoid solve(){\n    vec<vi> ms(10, vi(10, 0));\n    int n = 10;\n    int ans = 0;\n    for(int i = 0; i < 10; ++i){\n        for(int j = 0; j < 10; ++j){\n            char c; cin >> c;\n            if(c != \'X\')continue;\n            int cc = min(i + 1, j + 1);\n            cc = min(cc, n - i);\n            cc = min(cc, n - j);\n            ans += cc;\n        }\n    }\n    cout << ans << ""\\n"";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",800,You can just hardcode the values in the array below and iterate through the grid if it is an we add the value to our total See the implementation for more details The time complexity per testcase 
For an integer array a of length n define f k as the greatest common divisor GCD of the maximum values of all subarrays text of length k For example if the array is 2 1 4 6 2 then f 3 operatorname gcd operatorname max 2 1 4 operatorname max 1 4 6 operatorname max 4 6 2 operatorname gcd 4 6 6 2 An array is good if f i neq f j is satisfied over all pairs 1 le i lt j le n Shohag has an integer m Help him count the number modulo 998 244 353 of non empty good arrays of arbitrary length such that each element of the array is an integer from 1 to m text An array d is a subarray of an array c if d can be obtained from c by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n;mint dp[N]; vi dv[N];mint mut[N];mint mu[N];void Main() {\tcin >> n;\tL(i, 1, n) dp[i] = mut[i] = 0;\tmint ans = 0;\tR(i, n, 1) {\t\t// L(j, 1, n) if(__gcd(i, j) < j) {\t\t// \tdp[__gcd(i, j)] += dp[j] * 2;\t\t// \tans += dp[j] * 2;\t\t// }\t\tfor(int d : dv[i]) {\t\t\tmint qwq = 0;\t\t\tfor(int nd : dv[i / d]) qwq += mu[nd] * mut[d * nd];\t\t\tqwq -= dp[d];\t\t\t// cout << i <<\' \'<<d<<""inc "" << qwq.x << \' \' << mut[d].x << \' \' << mut[d * 2].x << endl;\xa0\t\t\tqwq *= 2;\t\t\tans += qwq;\t\t\tdp[d] += qwq;\t\t\tfor(auto s : dv[d]) {\t\t\t\tmut[s] += qwq;\t\t\t}\t\t}\t\tdp[i] += 1;\t\tans += 1;\t\tfor(auto j : dv[i]) mut[j] += 1;\t\t// L(j, 1, n) cout << dp[j].x << \' \';\t\t// cout << endl;\t}\tcout << ans.x << \'\\n\';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint mx = 1e6;\tL(i, 1, mx)\t\tL(j, 1, mx / i)\t\t\tdv[i * j].pb(i);\tL(i, 1, mx)\t\tmu[i] = (i == 1);\tL(i, 1, mx)\t\tL(j, 2, mx / i)\t\t\tmu[i * j] -= mu[i];\t// cout << ""mu = "" << mu[2].x << endl;\tint t; cin >> t; while(t--) Main();\treturn 0;}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2800,Let be the sequence of length subarray maximums of the array Then is just the adjacent maximum sequence of Also let be the GCD of the elements of Then notice that every element of is also divisible by That is divides For the array to be good must be different for all So and divides This means if the length of the array is then Now consider a non decreasing sequence of integers of length such that for all Then the length subarray maximums of are just the last elements of So is the GCD of the last elements of Then for to be different for all all the elements of must be distinct So the condition for to be good is that the elements are distinct and all suffix GCDs are distinct as well Next the question is how many permutations of this increasing sequence is good as well To count this lets start from is just Now consider We need to put in the sequence such that the adjacent maximum sequence of becomes For this we clearly have ways and Now consider We need to put in the sequence such that the adjacent maximum sequence of becomes For this we again have ways because can be inserted in places before or after Similarly for all other we have ways to insert it putting it before or after So the total number of good permutations of is So our problem reduces to the following Select a length such that Count the number of strictly increasing sequences of length such that all suffix GCDs are distinct Multiply the answer by Sum up the answer for all valid For a fixed let s count the number of strictly increasing sequences of length such that all suffix GCDs are distinct Let be the number of strictly increasing sequences of length such that the starting element is and the GCD of the elements is Now iterate from to Then the transition is to iterate over the next suffix GCD such that divides and and then add to Here is the sum of all for all Another way to look at the transition is that for a fixed we iterate over all and if then we add to But doing everything like this would still be which is too slow Notice that all are the divisors of Here the main difficulty is that we need update at the index over all but it is hard to track the exact gcd but what s easier is to track the multiple of the gcd So for each let s say we know the sum of all over all such that divides So this sums up all such that divides Then using inclusion exclusion on the divisors of we can get the sum of all for all such that is exactly This will take time for each where is the number of divisors of And once we calculate the for some and then before transitioning to we can add the value of to all divisors of to get the value of faster in the future To keep track of this we can use a separate array So for a fixed the time complexity is And we need to do this for all from to So the overall time complexity is We actually allowed this to pass in F1 We can make the time complexity much better with a simple modification in the dp Note that we don t need to use the length of array in the dp state As we need to sum up after multiplying by at the end we can modify the dp to directly store the sum of So we can just multiply the dp by during each transition So the time complexity becomes This is very fast for F1 
You are given an undirected connected graph consisting of vertices and edges There are no loops and no multiple edges in the graph You are also given two distinct vertices and and two values and Your task is to build any spanning tree of the given graph note that the graph is not weighted such that the degree of the vertex doesn t exceed and the degree of the vertex doesn t exceed or determine that there is no such spanning tree The of the graph is a subgraph which is a tree and contains all vertices of the graph In other words it is a connected graph which contains edges and can be obtained by removing some of the edges from The degree of a vertex is the number of edges incident to this vertex ,"['#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n\nconst int N = 4e5 + 7;\ntypedef std::vector<std::pair<int, int> > EdgeList;\n\nint father[N];\nEdgeList edges;\n\nint find(int x) {\n\treturn father[x] == x ? x : father[x] = find(father[x]);\n}\n\nint n, m;\nint s, t, ds, dt;\n\nbool rel_st(std::pair<int, int> p) {\n\treturn (p.first == s || p.first == t ||\n\t\tp.second == s || p.second == t);\n}\n\nEdgeList solve(EdgeList edges) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tEdgeList ret;\n\tfor (int i = 0; i < edges.size(); i++) {\n\t\tint u = edges[i].first, v = edges[i].second;\n\t\tif (find(u) != find(v)) {\n\t\t\tfather[find(u)] = find(v);\n\t\t\tret.push_back({u, v});\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool to_s[N], to_t[N];\nint s2who[N], t2who[N];\n\nvoid get_info(int s, bool to[], int to_who[], EdgeList edges) {\n\tstd::fill(to + 1, to + n + 1, false);\n\tfor (auto e : edges) {\n\t\tif (e.second == s) std::swap(e.first, e.second);\n\t\tif (e.first == s) {\n\t\t\tint v = e.second;\n\t\t\tto[find(v)] = true;\n\t\t\tto_who[find(v)] = v;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(""%d %d"", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(""%d %d"", &u, &v);\n\t\tedges.push_back({u, v});\n\t}\n\tscanf(""%d %d %d %d"", &s, &t, &ds, &dt);\n\tstd::vector<std::pair<int, int> > bak = edges;\n\tedges.clear();\n\tfor (auto p : bak) {\n\t\tif (!rel_st(p)) {\n\t\t\tedges.push_back(p);\n\t\t}\n\t}\n\tfor (auto p : bak) {\n\t\tif (rel_st(p)) {\n\t\t\tedges.push_back(p);\n\t\t}\n\t}\n\tauto vec = solve(edges);\n\tif (vec.size() < n - 1) {\n\t\tputs(""No"");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tEdgeList ans;\n\tfor (auto choosed : vec) {\n\t\tif (!rel_st(choosed)) {\n\t\t\tint u = choosed.first;\n\t\t\tint v = choosed.second;\n\t\t\tfather[find(u)] = father[find(v)];\n\t\t\tans.push_back(choosed);\n\t\t}\n\t}\n\tget_info(s, to_s, s2who, edges);\n\tget_info(t, to_t, t2who, edges);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != s && i != t && i == find(i)) {\n\t\t\tassert(to_s[i] || to_t[i]);\n\t\t\tif (to_s[i] && !to_t[i]) {\n\t\t\t\tds--;\n\t\t\t\tfather[i] = s;\n\t\t\t\tans.push_back({s, s2who[i]});\n\t\t\t} else if (to_t[i] && !to_s[i]) {\n\t\t\t\tdt--;\n\t\t\t\tfather[i] = t;\n\t\t\t\tans.push_back({t, t2who[i]});\n\t\t\t}\n\t\t}\n\t}\n\tint extras = -1, extrat = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != s && i != t && i == find(i)) {\n\t\t\tif (to_s[i] && to_t[i]) {\n\t\t\t\tif (ds > dt) {\n\t\t\t\t\tds--;\n\t\t\t\t\tans.push_back({s, s2who[i]});\n\t\t\t\t\textrat = t2who[i];\n\t\t\t\t} else {\n\t\t\t\t\tdt--;\n\t\t\t\t\tans.push_back({t, t2who[i]});\n\t\t\t\t\textras = s2who[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (extras == -1 && extrat == -1) {\n\t\tans.push_back({s, t});\n\t\tds--;\n\t\tdt--;\n\t} else if ((ds >= dt && extras != -1) || extrat == -1) {\n\t\tans.push_back({s, extras});\n\t\tds--;\n\t} else if ((dt >= ds && extrat != -1) || extras == -1) {\n\t\tans.push_back({t, extrat});\n\t\tdt--;\n\t}\n\tif (ds < 0 || dt < 0 || ans.size() < n - 1) {\n\t\tputs(""No"");\n\t\treturn 0;\n\t} else {\n\t\tputs(""Yes"");\n\t\tfor (auto a : ans) {\n\t\t\tprintf(""%d %d\\n"", a.first, a.second);\n\t\t}\n\t}\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1]",2300,At first lets delete vertices and from the graph find all connected components in the remaining graph and build for every component any spanning trees Now we need to add in spanning tree vertices and At first let add edges from to all components which have no edges to Then let add edges from to all components which have no edges to If after that the degree of became more than or the degree of became more than answer does not exist Now we have components which have edges and to and to Also currently we have two spanning trees which does not connect Let s choose how to connect them with vertex with vertex or with both of them only if we have in the graph an edge For each option we need to greedily connect remaining components if it is possible for current option If we done it for any option we need only to print the answer 
Mihai and Slavic were looking at a group of n frogs numbered from 1 to n all initially located at point 0 Frog i has a hop length of a i Each second frog i hops a i units forward Before any frogs start hopping Slavic and Mihai can place trap in a coordinate in order to catch all frogs that will ever pass through the corresponding coordinate However the children can t go far away from their home so they can only place a trap in the first n points that is in a point with a coordinate between 1 and n and the children can t place a trap in point 0 since they are scared of frogs Can you help Slavic and Mihai find out what is the maximum number of frogs they can catch using a trap ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tll n;  cin >> n;\n\tvector<ll> a(n);\n\tvector<int> cnt(n + 1);\n\tfor (auto &ai: a) {\n\t\tcin >> ai;\n\t\tif (ai > n)  continue;\n\t\tcnt[ai]++;\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tfor (int j = i + i; j <= n; j += i) {\n\t\t\tcnt[j] += cnt[i];\n\t\t}\n\t}\n\n\tcout << *max_element(cnt.begin(), cnt.end()) << ""\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",1300,We disregard any larger than since we can t catch them anyway We keep in how many frogs we have for each hop distance We go through each from to and add to every multiple of smaller or equal to This action is a harmonic series and takes time We go through all from to and take the maximum 
One day a highly important task was commissioned to Vasya writing a program in a night The program consists of lines of code Vasya is already exhausted so he works like that first he writes lines of code drinks a cup of tea then he writes as much as lines drinks another cup of tea then he writes lines and so on The expression is regarded as the integral part from dividing number by number The moment the current value equals 0 Vasya immediately falls asleep and he wakes up only in the morning when the program should already be finished Vasya is wondering what minimum allowable value can take to let him write than lines of code before he falls asleep ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nint main(){\n\tint n, k;\n\twhile( cin>>n>>k ){\n\t\tint l=0, r=n;\n\t\twhile( l+1<r ){\n\t\t\tint mid=(l+r)/2;\n\t\t\tLL sum=0, M=1;\n\t\t\twhile( true ){\n\t\t\t\tsum+=mid/M;\n\t\t\t\tif( mid/M==0 ) break;\n\t\t\t\tM*=k;\n\t\t\t}\n\t\t\tif( sum>=n ) r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tcout<<r<<endl;\n\t}\n}\n\n\n\n\n']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0]",1500,This problem can be solved using binary search for the answer obviously if number is an answer than every number is also the answer because the number of written lines of code could only become more To check some number you can use formula given in the problem because it will have less than positive elements The complexity is 
There are one cat k mice and one hole on a coordinate line The cat is located at the point 0 the hole is located at the point n All mice are located between the cat and the hole the i th mouse is located at the point x i 0 x i n At each point many mice can be located In one second the following happens First mouse moves to the right by 1 If the mouse reaches the hole it hides i e the mouse will not any more move to any point and will not be eaten by the cat Then the mouse has finished its move the cat moves to the right by 1 If at the new cat s position some mice are located the cat eats them they will not be able to move after that The actions are performed until any mouse hasn t been hidden or isn t eaten In other words the first move is made by a mouse If the mouse has reached the hole it s saved Then the cat makes a move The cat eats the mice located at the pointed the cat has reached if the cat has reached the hole it eats nobody Each second you can select a mouse that will make a move What is the maximum number of mice that can reach the hole without being eaten ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=400005;\nint x[N],n,k,t;\nint main() {\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>n>>k;\n        for (int i=1;i<=k;i++) cin>>x[i];\n        sort(x+1,x+k+1);\n        int res=0,pos=0;\n        for (int i=k;i>=1;i--) {\n            if (pos<x[i]) res++,pos+=n-x[i];\n            else break;\n        }\n        cout<<res<<""\\n"";\n    }\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1000,Let s solve the problem using a linear search Let be the number of mice we are trying to save Then it is more efficient to save mice such that they are the closest ones to the hole Let be the distance from the th mouse to the hole Denote Let s prove that these mice will be saved if and only if The necessary condition Suppose we can save the mice and Since only one mouse can be moved in one second the following will happen of mice will already be saved and one mouse will have to be saved When it s been seconds then the distance from the cat to the hole will be equal to and the distance from the mouse to the hole will be equal to since all other mice are already in the hole their distances to the hole are equal to so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse Since the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole But this cannot be because both the mice and the cat move only to the right and all mice met by the cat are eaten So Sufficient condition Suppose If then all the mice are already in the hole i e they are saved Suppose Let s move any mouse then the cat Suppose the cat ate at least one of the mice This mouse is definitely not the one that was moved Then the distance from it to the eaten mouse was equal to i e the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus The distance from the moved mouse to the hole was at least So where is the distance from the eaten mouse to the hole is the distance from the moved mouse to the hole So but it s false Therefore none of the mice will be eaten on the first move Then the distance from the cat to the hole will be equal to the total distance from the mice to the hole will be equal to i e now we have to solve a similar problem for smaller and So will be gradually decreased to while no mouse will be eaten So if all the mice will be saved Thus to solve the problem we need to find the maximum such that the sum of the distances from the nearest mice to the hole is less than 
You are given the current time in hour format Find and print the time after minutes Note that you should find only the time after minutes see the examples to clarify the problem statement You can read more about hour format here https en wikipedia org wiki 24 hour clock ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n\nint main(){\n    int h,m;\n    scanf(""%d : %d"",&h,&m);\n    DRI(x);\n    while(x--){\n        m++;\n        if(m==60){\n            m=0;\n            h++;\n            if(h==24){\n                h=0;\n            }\n        }\n    }\n    printf(""%02d:%02d"",h,m);\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,In this problem we can simply increase times the current time by one minute after each increasing we should check the hours and the minutes for overflow Another solution is to use the next formulas as the answer C solution 1 C solution 2 Complexity or 
A permutation of 1 2 ldots n is a sequence of n integers where each integer from 1 to n appears exactly once For example 2 3 1 4 is a permutation of 1 2 3 4 but 1 4 2 2 isn t because 2 appears twice in it Recall that the number of inversions in a permutation a 1 a 2 ldots a n is the number of pairs of indices i j such that i j and a i a j Let p and q be two permutations of 1 2 ldots n Find the number of permutation pairs p q that satisfy the following conditions p is lexicographically smaller than q the number of inversions in p is greater than the number of inversions in q Print the number of such pairs modulo mod Note that mod may not be a prime ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nint MOD;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=505,MAXM=500005;\n\nint n;\nint s[MAXM],f[MAXN],d[MAXM],g[MAXM],h[MAXM];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\treadint(n),readint(MOD);\n\ts[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=1ll*i*f[i-1]%MOD;\n\t\tg[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)g[j]=(g[j-1]+1ll*s[j]*(j+1))%MOD;\n\t\th[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)h[j]=dmy(h[j-1]+s[j]);\n\t\tfor(int j=0;j<=(i-1)*(i-2)/2;j++)\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tif(j>=2)inc(tmp,g[j-2]),inc(tmp,MOD-1ll*(j-i+MOD)*h[j-2]%MOD);\n\t\t\tif(j-i-1>=0)inc(tmp,MOD-g[j-i-1]),inc(tmp,1ll*(j-i+MOD)*h[j-i-1]%MOD);\n\t\t\tinc(f[i],1ll*d[j]*tmp%MOD);\n\t\t}\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)d[j]=0;\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)\n\t\t{\n\t\t\td[j]=s[j];\n\t\t\tif(j>=i)inc(d[j],MOD-s[j-i]);\n\t\t}\n\t\ts[0]=d[0];\n\t\tfor(int j=1;j<=i*(i+1)/2;j++)s[j]=dmy(s[j-1]+d[j]);\n\t}\n\tprintf(""%d\\n"",f[n]);\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2400,Let s first calculate the number of permutation pair p q s with length i that p1 q1 but inv p inv q inv p is the number of inversions in p Call it ti Let s enumerate p1 j and q1 k then inv p 2 i inv q 2 i k j inv p inv p 2 i j 1 inv q inv q 2 i k 1 with inv p inv q we get the following Precalculate f i j the number of permutation p s of length i such that inv p j Let s i j be k jf i k then ti 1 j i j k i wf i 1 w s i 1 w k j 1 f and s can be calculated in O n4 or O n3 in the following way if you insert i into a permutation of length i 1 after the i 1 p th element 0 p i 1 it will bring p inversions into the permutation So f i j j i 1 k jf i 1 k After calculating t calculating the answer it easy Let ansi be the answer for n i then ansi i ansi 1 ti Consider if p1 q1 If so there are i choices of p1 and ansi 1 choices of the following n 1 numbers Otherwise there are ti choices Total complexity is O n5 but it can be optimized to O n4 if you consider the difference between j k only and can be optimized to O n3logn using FFT with arbitary mod which we hope can t pass E2 
There are boys and girls attending a theatre club To set a play The Big Bang Theory they need to choose a group containing exactly actors containing no less than 4 boys and no less than one girl How many ways are there to choose a group Of course the variants that only differ in the composition of the troupe are considered different Perform all calculations in the 64 bit type for for Delphi and for Java ,"['#include <cstdio>\ntypedef long long ll;\nint c[40][40];\nint main()\n{\n    for (int i=0;i<=30;i++)\n    {\n        c[i][0]=c[i][i]=1;\n        for (int j=1;j<i;j++)\n            c[i][j]=c[i-1][j-1]+c[i-1][j];\n    }\n    int n,m,t;\n    scanf(""%d%d%d"",&n,&m,&t);\n    ll ans=0;\n    for (int i=4;i<=n;i++)\n    {\n        int p=t-i;\n        if (p<1)\n            break;\n        if (p>m)\n            continue;\n        ans+=ll(c[n][i])*c[m][p];\n    }\n    printf(""%I64d\\n"",ans);\n    return(0);\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1400,Since the constraints are small let s just iterate through all possible numbers b of boys in the group and count how many ways we can form the group with b boys First consider only the values where b 4 Given b it s clear that the number of girls in the group must be g t b If g 1 don t consider this case Given the values of b and g there are n b m g ways to form the group since we can combine the boys independently the girls Just sum n b m g for each pair b g Again use 64 bits types to do the math One could precompute all the values of i j using the Pascal triangle but one could also compute it with the traditional formula if its implementation takes care of possible overflow 30 doesn t fit in 64 bit integer type 
Let s call an integer array a 1 a 2 dots a n if a i neq i for each i Let F a be the number of pairs i j 1 le i j le n such that a i a j i j Let s say that an array a 1 a 2 dots a n is if a is l le a i le r for each i F a is the maximum possible among all arrays of size n Given n l and r calculate the number of arrays modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\nconstexpr int P = 1000000007;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, int b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, l, r;\n        std::cin >> n >> l >> r;\n        l--;\n        r--;\n        \n        std::vector<Z> fac(n + 1), invfac(n + 1);\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i;\n        }\n        invfac[n] = fac[n].inv();\n        for (int i = n; i > 0; i--) {\n            invfac[i - 1] = invfac[i] * i;\n        }\n        \n        auto binom = [&](int n, int m) {\n            if (m < 0 || n < m) {\n                return Z(0);\n            }\n            \n            return fac[n] * invfac[m] * invfac[n - m];\n        };\n        \n        int e = std::min(-l, r - (n - 1));\n        \n        Z ans = binom(n, n / 2) * (1 + n % 2) * e;\n        \n        for (int x = e + 1; ; x++) {\n            int a = std::min(n, n - (l + x));\n            int b = std::min(n, r - x + 1);\n            if (a < 0 || b < 0) {\n                break;\n            }\n            \n            ans += binom(a + b - n, n / 2 - (n - b));\n            if (n % 2 == 1) {\n                ans += binom(a + b - n, n / 2 - (n - a));\n            }\n        }\n        \n        std::cout << ans.val() << ""\\n"";\n    }\n    \n    return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 1, 1, 1, 0]",2300,Firstly let s learn the structure of good array with maximum Suppose then In other words we can group by and pairs will appear only inside each group It s easy to prove that if the group has size then it s optimal to split it in half one with and other with Then the number of pairs inside the group will be equal to It s also not hard to prove that in this case it s optimal to place all elements inside one group In other words it s optimal to make a half of all elements as and the other half as for some integer Then To achieve maximum the excellent array should also have this structure Let For a fixed if is even then we should choose exactly positions to set as but if is odd we can choose either or positions Let s analyze what happens with different Obviously While both and are in the segment for any In this case we can choose any as so there are exactly ways for even and ways for odd When then for where there is only one choice to set Analogically for where there is only choice to set What remains is elements without restrictions so there are ways to choose for even or ways for odd Note that it s convenient to say that if or so we don t need extra checks Lastly note that we can process all with one formula and there are only of with non zero number of ways to choose so we can iterate over all such straightforwardly The total complexity is because of precomputation of factorials and inverse factorials to calculate 
Ivan is playing yet another roguelike computer game He controls a single hero in the game The hero has n equipment slots There is a list of c i items for the i th slot the j th of them increases the hero strength by a i j The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase So a i 1 a i 2 dots a i c i For each slot Ivan chooses exactly one item Let the chosen item for the i th slot be the b i th item in the corresponding list The sequence of choices b 1 b 2 dots b n is called The strength of a build is the sum of the strength increases of the items in it Some builds are banned from the game There is a list of m pairwise distinct banned builds It s guaranteed that there s at least one build that s not banned What is the build with the maximum strength that is not banned from the game If there are multiple builds with maximum strength print any of them ,"['/**\n *    author:  tourist\n *    created: 20.09.2021 17:42:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> a(n);\n  vector<int> c(n);\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n    a[i].resize(c[i]);\n    for (int j = 0; j < c[i]; j++) {\n      cin >> a[i][j];\n    }\n  }\n  int m;\n  cin >> m;\n  vector<vector<int>> f(m, vector<int>(n));\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> f[i][j];\n      --f[i][j];\n    }\n  }\n  sort(f.begin(), f.end());\n  set<pair<int, vector<int>>> s;\n  {\n    int sum = 0;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n      sum += a[i].back();\n      v[i] = c[i] - 1;\n    }\n    s.emplace(sum, v);\n  }\n  while (true) {\n    assert(!s.empty());\n    auto it = prev(s.end());\n    int sum = it->first;\n    vector<int> v = it->second;\n    s.erase(it);\n    auto iter = lower_bound(f.begin(), f.end(), v);\n    if (iter == f.end() || *iter != v) {\n      for (int i = 0; i < n; i++) {\n        if (i > 0) {\n          cout << "" "";\n        }\n        cout << v[i] + 1;\n      }\n      cout << endl;\n      break;\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      if (v[i] > 0) {\n        int new_sum = sum - a[i][v[i]] + a[i][v[i] - 1];\n        v[i] -= 1;\n        s.emplace(new_sum, v);\n        v[i] += 1;\n      }\n      if (v[i] < c[i] - 1) {\n        break;\n      }\n    }\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 1, 1, 0, 1, 0, 1]",2000,Consider the bruteforce solution You start with a build that contains the most powerful item for each slot In one move you swap an item in some slot for the one that is the previous one by power If a build is not banned update the answer with its total power banned builds can be stored in a set maybe hashset if you hash carefully enough Notice that if you reach some unbanned build in this bruteforce it never makes sense to go further The answer is already updated with this one and all the lower ones have smaller power If you code that bruteforce in a smart way or just add memorization you won t visit any build twice How many states will you visit though Since you can only proceed if you are standing in a banned build you will check around builds You can code it like that and get accepted However there s another way that s easier to code in my opinion The optimal answer can be one of only two types Either it contains the last item of each slot Or it s some banned build with one item swapped with the previous one It s easy to see from the solution above So you can check the first type then iterate over the banned build and try swapping each slot in it checking if the resulting build is banned or not Overall complexity or 
You are given n arrays of non negative numbers Vasya repeats the following operation k times Selects a non empty array Puts the first element of the selected array in his pocket Removes the first element from the selected array Vasya wants to maximize the sum of the elements in his pocket ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n// some # of whole arrays, then part of an array\n\nint N,K; // n^2logn ...\nvl A[3000];\nll ans = 0;\n\nvoid ad(vl& tmp, int num, ll sum) {\n\tR0F(i,sz(tmp)-num) ckmax(tmp[i+num],tmp[i]+sum);\n}\n\nvoid divi(int L, int R, const vl& bes) {\n\tif (L == R) {\n\t\tF0R(i,K+1) if (K-i < sz(A[L])) ckmax(ans,A[L][K-i]+bes[i]);\n\t\treturn;\n\t}\n\t{\n\t\tvl tmp = bes;\n\t\tint M = (L+R)/2;\n\t\tFOR(i,L,M+1) ad(tmp,sz(A[i])-1,A[i].bk);\n\t\tdivi(M+1,R,tmp);\n\t}\n\t{\n\t\tvl tmp = bes;\n\t\tint M = (L+R)/2;\n\t\tFOR(i,M+1,R+1) ad(tmp,sz(A[i])-1,A[i].bk);\n\t\tdivi(L,M,tmp);\n\t}\n}\n\nint main() {\n\tsetIO(); re(N,K);\n\tF0R(i,N) {\n\t\tint t; re(t);\n\t\tA[i].rsz(t); re(A[i]);\n\t\tA[i].ins(begin(A[i]),0);\n\t\tFOR(j,1,t+1) A[i][j] += A[i][j-1];\n\t}\n\tvl ori(K+1,-INF); ori[0] = 0;\n\tdivi(0,N-1,ori);\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2800,Straightforward dp solution where max possible sum after operations on first arrays and transition in has complexity of or precisely and doesn t fit into the time limit Taking into account the fact that the arrays are sorted helps to optimize it Consider the optimal solution Let s denote as number of operations on th array Let s call the array partially removed if we applied at least one operation to that array but the array is not yet empty Consider two partially removed arrays within the optimal solution and integers and where and Assume without loss of generality Let If we replace operations on th array with operations on th array total sum will increase by but the number of partially removed arrays will lower by 1 We can repeat that substitution until we get a single partially removed array Now we need to identify the single partially removed array in the final solution Every other array can either all be Vasya s pocket or remain as is We can solve the knapsack problem with items with array sizes as weights and sum of array s elements as value For each we need to find max possible total value of items with total weight The only remaining step is to brute force the size of prefix Vasya removed from the single partially removed array and combine it with Solving each knapsack problem independently results in complexity but the similarities between the problems allows to optimize down to using divide and conquer approach Let s split the items into two halves of approximately similar size Before going in recursively into the first half we will relax dp values with each element of the second half just like in usual knapsack problem and undo the changes after This way as soon as we reach the subset with just one piece we have already calculated dp for every other piece Adding each piece into dp takes each relaxation takes final complexity is 
William has a certain sequence of integers a 1 a 2 dots a n in his mind but due to security concerns he does not want to reveal it to you completely William is ready to respond to no more than 2 cdot n of the following questions What is the result of a bitwise AND of two items with indices i and j i neq j What is the result of a bitwise OR of two items with indices i and j i neq j You can ask William these questions and you need to find the k th smallest number of the sequence Formally the k th smallest number is equal to the number at the k th place in a 1 indexed array sorted in non decreasing order For example in array 5 3 3 10 1 4th smallest number is equal to 5 and 2nd and 3rd are 3 ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 10005;\nvi r[maxn], g;\nvi ask(int u, int v) {\n    cout << ""and "" << u << \' \' << v << endl; fflush(stdout);\n    int res; scanf(""%d"", &res);\n    int ed; \n    cout << ""or "" << u << \' \' << v << endl; fflush(stdout);\n    scanf(""%d"", &ed);\n    vi ff(30);\n    for (int i = 0; i < 30; i++) {\n        int u = (res >> i) & 1, v = (ed >> i) & 1;\n        ff[i] = u + v;\n    }\n    return ff;\n}\nint a[maxn];\nint main() {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 2; i <= n; i++)\n        r[i] = ask(1, i);\n    g = ask(2, 3);\n    for (int i = 0; i < 30; i++) {\n        int fx = (r[2][i] + r[3][i] - g[i]) / 2;\n        a[1] += (fx) << i;\n        for (int j = 2; j <= n; j++) {\n            a[j] += (r[j][i] - fx) << i;\n        }\n    }\n    sort(a + 1, a + n + 1);\n    cout << ""finish "" << a[k] << endl; fflush(stdout);\n    return (0-0); //<3\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",1800,To solve this problem we can use the fact that or and Then we can determine the first numbers in operations using the sums and Using the formula and Knowing one of the numbers it is quite simple to find all the other numbers using the same principle by using operations Then we just need to sort the resulting array and output the k th element 
You are given n elements numbered from 1 to n the element i has value a i and color c i initially c i 0 for all i The following operation can be applied Select three elements i j and k 1 leq i j k leq n such that c i c j and c k are all equal to 0 and a i a k then set c j 1 Find the maximum value of sum limits i 1 n c i that can be obtained after applying the given operation any number of times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint b[N][2];\nint ans;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i <= n; i++)\n\t\tb[i][0] = b[i][1] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tif (b[a[i]][0] == -1) b[a[i]][0] = i;\n\t\tb[a[i]][1] = i;\n\t}\n\tans = n;\n\tint l = 0, r = -1;\n\twhile(l < n) {\n\t\teprintf(""[%d %d]\\n"", l, r);\n\t\tif (r == -1) {\n\t\t\tint p = b[a[l]][1];\n\t\t\tif (p > l) {\n\t\t\t\tans--;\n\t\t\t\tl++;\n\t\t\t\tr = p;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t\tans--;\n\t\t\t}\n\t\t} else {\n\t\t\tint mx = r;\n\t\t\twhile(l < r) {\n\t\t\t\tmx = max(mx, b[a[l]][1]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (mx == r) {\n\t\t\t\tans--;\n\t\t\t\tl = r + 1;\n\t\t\t\tr = -1;\n\t\t\t} else {\n\t\t\t\tans--;\n\t\t\t\tl = r + 1;\n\t\t\t\tr = mx;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 1, 0]",2200,Solution For each such that all the elements are different from it is impossible to apply an operation with some indices from the first part and some other from the second one Then it is possible to split the array in subarrays for each such that the previous condition holds and sum the answers from all of them Let s solve the problem independently for one of those subarrays let s denote its length as the values of its elements as and their colors as For every tuple such that and it is possible to apply an operation with indices and Then only the first and last occurrences of each element are important For all pairs such that is the first occurrence and the last occurrence of that value a segment will be created Let s denote the left border of a segment as and the right border as Let s say that a set of segments is connected if the union of its segments is the segment Instead of maximizing it is possible to focus on minimizing Lemma 1 If we have a connected set it is possible to apply some operations to its induced array to end up with at most elements with ProofFor each segment in if there exists a segment such that it is possible to apply the operation with indices and with Otherwise add this segment to a set Then is possible to repeatedly select the leftmost segment of that have not been selected yet and set the color of its right border to this will be always possible until we select the rightmost segment since is connected In the end all the left borders of the segments of will have the same holds for the right border of the rightmost segment of which leads to a total of elements with and Let be a subarray that can be obtained by applying the given operation to the initial subarray any number of times Let be the set of segments that includes all segments such that or or both where is the color of the th segment of the subarray Lemma 2 There is always an optimal solution in which is connected ProofSuppose is not connected if there are only two components of segments and there will always be a segment from to due to the way the subarray was formed If or have some segment such that there exists a segment such that you can erase it by applying the operation with indices and with Then we can assume that and similarly for The solution to before merging is the solution to is if we merge and with a segment we get a component of size and its answer will be using bf lemma 1 the case with more than two components is similar then we can always merge the components without making the answer worse Finally the problem in each subarray can be reduced to find the smallest set in number of segments such that the union of its segments is the whole subarray This can be computed with dp or sweep line DP solutionLet be the minimum size of a set such that the union of its segments is the segment To compute process all the segments in increasing order of and compute the value of Then the solution to the subarray is this can be computed in with segment tree It is possible to compute a similar to solve the problem for the whole array without splitting the array the time complexity is Code Sweep line solutionIt is possible to create an event where a segment starts and an event where a segment ends Then process the events in order and each time a segment ends if it is the rightmost segment added add to the solution the segment with maximum among the segments that is already processed It is possible to modify the sweep line to solve the problem for the whole array without splitting the array the time complexity is or depending on the implementation 
Given a sequence a 1 a 2 ldots a n find the minimum number of elements to remove from the sequence such that after the removal the sum of every 2 consecutive elements is even ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, cnt[2];\n\nvoid solve() {\n\tn = in; cnt[0] = cnt[1] = 0;\n\trep(i, 1, n) cnt[in % 2]++;\n\tcout << n - max(cnt[0], cnt[1]) << endl;\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0]",800,The sum of an odd integer and an even integer is an odd integer So you can t have both even and odd elements in the array for the sum of every two consecutive elements to be even Hence the final array should only contain or elements Hence we will remove either all odd elements or all even elements whichever takes lesser number of operations Therefore the answer is 
Petya loves football very much One day as he was watching a football match he was writing the players current positions on a piece of paper To simplify the situation he depicted it as a string consisting of zeroes and ones A zero corresponds to players of one team a one corresponds to players of another team If there are at least players of some team standing one after another then the situation is considered dangerous For example the situation is dangerous and is not You are given the current situation Determine whether it is dangerous or not ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nstring\tst;\n\n\nint\tmain()\n{\n//\tfreopen(""A.in"", ""r"", stdin);\n//\tfreopen(""A.out"", ""w"", stdout);\n\t\n\tcin >> st;\n\tint\tnow = 1, last = -1, most = 0;\n\tfor (int i = 0; i < st.size(); ++ i)\n\t{\n\t\tif (st[i] - \'0\' == last) now ++; else now = 1;\n\t\tmost = max(most, now);\n\t\tlast = st[i] - \'0\';\n\t}\n\tputs(most >= 7 ? ""YES"" : ""NO"");\n\t\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900,In this problem you must find longest substring consisting of equal characters and compare it with 7 
High school student Vasya got a string of length as a birthday present This string consists of letters and only Vasya denotes of the string as the maximum length of a consecutive subsequence consisting of equal letters Vasya can change no more than characters of the original string What is the maximum beauty of the string he can achieve ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\n\nint Solve(string str) {\n\tint j = -1, countB = 0, ans = 0;\n\tfor(int i = 0; i < str.size(); ++i) {\n\t\tcountB += (str[i] == \'b\');\n\n\t\twhile(j <= i && countB > k) {\n\t\t\t++j;\n\t\t\tcountB -= (str[j] == \'b\');\n\t\t}\n\n\t\tans = max(ans, i - j);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> k;\n\n\tstring str;\n\tcin >> str;\n\n\tint r = Solve(str);\n\tfor(auto &c : str)\n\t\tc = c ^ \'a\' ^ \'b\';\n\tcout << max(r, Solve(str))<<""\\n"";\n\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",1500,This problem can be solved with help of two pointers Let the first pointer is and the second pointer is Then for every position we will move right end until on the substring it is possible to make no more than swaps to make this substring beautiful Then we need to update the answer with length of this substring and move to the right Asymptotic behavior 
You are given an array a of n non negative integers numbered from 1 to n Let s define the of the array a as displaystyle min i neq j a i a j where denotes the bitwise OR operation There are q queries For each query you are given two integers l and r l r For each query you should find the cost of the subarray a l a l 1 ldots a r ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nconst int inf=(1<<30)-1;\nint a[100005],cntid,rt[100005];\nstruct stree\n{\n\tint ls,rs,cnt;\n}t[7000005];\ninline void build()\n{\n\tt[cntid=1]={0,0,0},rt[0]=1;\n}\ninline void pd(int now)\n{\n\tif(!t[now].ls) t[t[now].ls=++cntid]={0,0,0};\n\tif(!t[now].rs) t[t[now].rs=++cntid]={0,0,0};\n}\ninline void ins(int lst,int now,int l,int r,int p)\n{\n\tif(l==r)\n\t{\n\t\tt[now].cnt=t[lst].cnt+1;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(p<=mid)\n\t{\n\t\tpd(lst);\n\t\tt[now].rs=t[lst].rs;\n\t\tpd(now);\n\t\tins(t[lst].ls,t[now].ls,l,mid,p);\n\t}\n\telse\n\t{\n\t\tpd(lst);\n\t\tt[now].ls=t[lst].ls;\n\t\tpd(now);\n\t\tins(t[lst].rs,t[now].rs,mid+1,r,p);\n\t}\n\tt[now].cnt=t[t[now].ls].cnt+t[t[now].rs].cnt;\n}\ninline int ask(int now,int l,int r,int L,int R)\n{\n\tif(!now) return 0;\n\tif(l==L&&r==R) return t[now].cnt;\n\tint mid=(l+r)>>1;\n\tif(mid>=R) return ask(t[now].ls,l,mid,L,R);\n\tif(mid+1<=L) return ask(t[now].rs,mid+1,r,L,R);\n\treturn ask(t[now].ls,l,mid,L,mid)+ask(t[now].rs,mid+1,r,mid+1,R);\n}\n/*inline int ask(int l,int r,int x)\n{\n\tint ans=0;\n\tfor(int i=l;i<=r;i++)\n\t\tans+=a[i]<=x;\n\treturn ans;\n}*/\ninline int query(int lst,int now,int l,int r,int cnt)\n{\n\tif(l==r) return l;\n\tint mid=(l+r)>>1;\n\tif(t[t[now].ls].cnt-t[t[lst].ls].cnt>=cnt) return query(t[lst].ls,t[now].ls,l,mid,cnt);\n\treturn query(t[lst].rs,t[now].rs,mid+1,r,cnt-t[t[now].ls].cnt+t[t[lst].ls].cnt);\n}\n/*inline int query(int l,int r,int x)\n{\n\tint ans=0;\n\tfor(int i=l;i<=r;i++)\n\t\tif(a[i]<=x) ans=max(ans,a[i]);\n\treturn ans;\n}*/\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tbuild();\n\t\tfor(int i=1;i<=n;i++) \n\t\t{\n\t\t\tcin >> a[i];\n\t\t\trt[i]=++cntid;\n\t\t\tt[rt[i]]={0,0,0};\n\t\t\tins(rt[i-1],rt[i],0,inf,a[i]);\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\twhile(q--)\n\t\t{\n\t\t\tint l,r;\n\t\t\tcin >> l >> r;\n\t\t\tvector <int> v;\n\t\t\tint ans=0;\n\t\t\tfor(int i=29;i>=0;i--)\n\t\t\t{\n\t\t\t\tint x=ask(rt[r],0,inf,ans,ans+(1<<i)-1)-ask(rt[l-1],0,inf,ans,ans+(1<<i)-1);\n\t\t\t\tint X=x;\n\t\t\t\tint qwq=(1<<30)-ans-1;\n\t\t\t\tqwq>>=i,qwq<<=i;\n\t\t\t\tfor(auto t:v) if(!(t&qwq)) ++x;\n\t\t\t\tif(x>=2) continue;\n\t\t\t\tans+=(1<<i);\n\t\t\t\tif(!X) continue; \n\t\t\t\tint nw=query(rt[l-1],rt[r],0,inf,ask(rt[r],0,inf,0,ans-1)-ask(rt[l-1],0,inf,0,ans-1)),flag=0;\n\t\t//\t\tcout << ask(rt[r],0,inf,0,ans-1)-ask(rt[l-1],0,inf,0,ans-1) << ""    "";\n\t\t//\t\tcout << l << "" "" << r << "" "" << ans-1 << "" "" << nw << ""\\n"";\n\t\t\t\tfor(auto t:v)\n\t\t\t\t\tif(t==nw) flag=1;\n\t\t\t\tif(!flag) v.push_back(nw);\n\t\t\t}\n\t\t\tcout << ans << ""\\n"";\n\t\t}\n\t}\n\t\n\treturn 0;\n}']","[1, 0, 1, 0, 1, 1, 0, 0, 0, 0]",2500,EditorialThe key idea for the solution is that the answer always lies among no more than 31 minimal numbers According to this idea it is possible to build a segment tree for minimum on a segment After that we only need to find no more than 31 minimums on the segment each time we find one we change it to and finally we can find all ORs pairwise among these 31 numbers It is also possible to use the Merge Sort Tree and the same idea Now let s prove the key idea let s prove by induction that if all numbers are less than then it s enough to consider minimal numbers Base case all numbers are from to and the proof is obvious Inductive step Let s show that for any if for the statement is true then it s true for If all numbers have 1 in th bit then the th bit of the answer is also 1 that s why we only have to minimize the remaining bits For these bits we can apply the induction hypothesis that minimal numbers are enough If at least two numbers have 0 in their th bit then the th bit in the answer is also 0 That s why we only consider only numbers with 0 in th bit and we have to minimize the remaining bits Again applying the induction hypothesis minimal numbers are enough If there is exactly one number with 0 in th bit then the th bit in the answer is 1 and we have to find minimal numbers over bits They are among minimal numbers over bits so minimal numbers are enough 
Ithea and Chtholly want to play a game in order to determine who can use the kitchen tonight Initially Ithea puts clear sheets of paper in a line They are numbered from to from left to right This game will go on for rounds In each round Ithea will give Chtholly an integer between and and Chtholly needs to choose one of the sheets to write down this number if there is already a number before she will erase the original one and replace it with the new one Chtholly wins if at any time all the sheets are filled with a number and the numbers are in non decreasing order looking from left to right from sheet to sheet and if after rounds she still doesn t win she loses the game Chtholly really wants to win the game as she wants to cook something for Willem But she doesn t know how to win the game So Chtholly finds you and your task is to write a program to receive numbers that Ithea gives Chtholly and help her make the decision on which sheet of paper write this number ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#define _CRT_SECURE_NO_WARNINGS\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n\n#ifdef LOCAL\n# include <opencv2/core/core.hpp>\n# include <opencv2/highgui/highgui.hpp>\n# include <opencv2/imgproc/imgproc.hpp>\n#endif\n\nusing namespace std;\n\n// Let\'s define unordered map\n# ifdef __GNUC__\n# if __cplusplus > 199711L\n# include <unordered_set>\n# include <unordered_map>\n# else\n# include <tr1/unordered_map>\n# include <tr1/unordered_set>\nusing namespace tr1;\n# endif\n# else\n# include <unordered_map>\n# include <unordered_set>\n# endif\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define DBN1(a)           cerr<<#a<<""=""<<(a)<<""\\n""\n#define DBN2(a,b)         cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<""\\n""\n#define DBN3(a,b,c)       cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<""\\n""\n#define DBN4(a,b,c,d)     cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<""\\n""\n#define DBN5(a,b,c,d,e)   cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<""\\n""\n#define DBN6(a,b,c,d,e,f) cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<"", ""<<#f<<""=""<<(f)<<""\\n""\n#define DBN(...) macro_dispatcher(DBN, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,n) cerr<<#a<<""=[""; printarray(a,n); cerr<<""]\\n""\n#define DAR(a,n,s) cerr<<#a<<""[""<<s<<""-""<<n-1<<""]=[""; printarray(a,n,s); cerr<<""]\\n""\n\n#ifdef _MSC_VER\n#define PREFETCH(ptr, rw, level) ((void)0)\n#else\n#define PREFETCH(ptr, rw, level) __builtin_prefetch(ptr, rw, level)\n#endif\n\n#ifdef LOCAL\n#define CURTIME() cerr << clock() * 1.0 / CLOCKS_PER_SEC << endl\n#else\n#define CURTIME()\n#endif\n\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef int itn;\n\ntemplate<class T1, class T2, class T3>\nstruct triple{ T1 a; T2 b; T3 c; triple() : a(T1()), b(T2()), c(T3()) {}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };\ntemplate<class T1, class T2, class T3>\nbool operator<(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a<t2.a;else if(t1.b!=t2.b)return t1.b<t2.b;else return t1.c<t2.c;}\ntemplate<class T1, class T2, class T3>\nbool operator>(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a>t2.a;else if(t1.b!=t2.b)return t1.b>t2.b;else return t1.c>t2.c;}\n#define tri triple<int,int,int>\n#define trll triple<ll,ll,ll>\n\n#define FI(n) for(int i=0;i<(n);++i)\n#define FJ(n) for(int j=0;j<(n);++j)\n#define FK(n) for(int k=0;k<(n);++k)\n#define FL(n) for(int l=0;l<(n);++l)\n#define FQ(n) for(int q=0;q<(n);++q)\n#define FOR(i,a,b) for(int i = (a), __e = (int) (b); i < __e; ++i)\n#define all(a) std::begin(a), std::end(a)\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(1.0 * (x))\n#define pow(x, n) pow(1.0 * (x), n)\n\n#define COMPARE(obj) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b)\n#define COMPARE_BY(obj, field) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b) { return a.field < b.field; }\n\n#define checkbit(n, b) (((n) >> (b)) & 1)\n#define setbit(n, b) ((n) | (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define removebit(n, b) ((n) & ~(static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define flipbit(n, b) ((n) ^ (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\ninline int countBits(uint v){v=v-((v>>1)&0x55555555);v=(v&0x33333333)+((v>>2)&0x33333333);return((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24;}\ninline int countBits(ull v){uint t=v>>32;uint p=(v & ((1ULL << 32) - 1)); return countBits(t) + countBits(p); }\ninline int countBits(ll v){return countBits((ull)v); }\ninline int countBits(int v){return countBits((uint)v); }\nunsigned int reverseBits(uint x){ x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }\ntemplate<class T> inline int sign(T x){ return x > 0 ? 1 : x < 0 ? -1 : 0; }\ninline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }\nconstexpr ll power(ll x, int p) { return p == 0 ? 1 : (x * power(x, p - 1)); }\ntemplate<class T1, class T2, class T3> T1 inline clamp(T1 x, const T2& a, const T3& b) { if (x < a) return a; else if (x > b) return b; else return x; }\nunsigned long long rdtsc() { unsigned long long ret = 0;\n#ifdef __clang__\n    return __builtin_readcyclecounter();\n#endif\n#ifndef _MSC_VER\n    asm volatile(""rdtsc"" : ""=A"" (ret) : :);\n#endif\n    return ret; }\n// Fast IO ********************************************************************************************************\nconst int __BS = 4096;\nstatic char __bur[__BS + 16], *__er = __bur + __BS, *__ir = __er;\ntemplate<class T = int> T readInt() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && (*__ir < \'0\' || *__ir > \'9\') && *__ir != \'-\') ++__ir; c();\n    bool m = false; if (*__ir == \'-\') ++__ir, c(), m = true;\n    T r = 0; while (*__ir >= \'0\' && *__ir <= \'9\') r = r * 10 + *__ir - \'0\', ++__ir, c();\n    ++__ir; return m ? -r : r;\n}\nstatic char __buw[__BS + 20], *__iw = __buw, *__ew = __buw + __BS;\ntemplate<class T>\nvoid writeInt(T x, char endc = \'\\n\') {\n    if (x < 0) *__iw++ = \'-\', x = -x; if (x == 0) *__iw++ = \'0\';\n    char* s = __iw;\n    while (x) { T t = x / 10; char c = x - 10 * t + \'0\'; *__iw++ = c; x = t; }\n    char* f = __iw - 1; while (s < f) swap(*s, *f), ++s, --f;\n    if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw;\n    *__iw++ = endc;\n}\ntemplate<class T>\nvoid writeStr(const T& str) {\n    int i = 0; while (str[i]) { *__iw++ = str[i++]; if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw; }\n}\nstruct __FL__ { ~__FL__() { if (__iw != __buw) cout.write(__buw, __iw - __buw); } };\nstatic __FL__ __flushVar__;\n\n//STL output *****************************************************************************************************\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p);\nTT1 ostream& operator << (ostream& os, const vector<T>& v);\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, const multiset<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v);\nTT1T2T3 ostream& operator << (ostream& os, const map<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const multimap<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t);\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<""(""<<p.first<<"", ""<< p.second<<"")""; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << ""[""; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << "", ""; f = 0; os << x; } return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t){ return os << ""("" << t.a << "", "" << t.b << "", "" << t.c << "")""; }\nTT1T2 void printarray(const T1& a, T2 sz, T2 beg = 0){ for (T2 i = beg; i<sz; i++) cout << a[i] << "" ""; cout << endl; }\n\n//STL input *****************************************************************************************************\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t);\nTT1T2 inline istream& operator >> (istream& os, pair<T1, T2>& p) { return os >> p.first >> p.second; }\nTT1 inline istream& operator >> (istream& os, vector<T>& v) {\n    if (v.size()) for (T& t : v) os >> t; else {\n        string s; T obj; while (s.empty()) {getline(os, s); if (!os) return os;}\n        stringstream ss(s); while (ss >> obj) v.push_back(obj);\n    }\n    return os;\n}\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t) { return os >> t.a >> t.b >> t.c; }\n\n//Pair magic *****************************************************************************************************\n#define PT1T2 pair<T1, T2>\nTT1T2 inline PT1T2 operator+(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first + p2.first, p1.second + p2.second); }\nTT1T2 inline PT1T2& operator+=(PT1T2 &p1 , const PT1T2 &p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\nTT1T2 inline PT1T2 operator-(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first - p2.first, p1.second - p2.second); }\nTT1T2 inline PT1T2& operator-=(PT1T2 &p1 , const PT1T2 &p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\n\n#undef TT1\n#undef TT1T2\n#undef TT1T2T3\n\n#define FREIN(FILE) freopen(FILE, ""rt"", stdin)\n#define FREOUT(FILE) freopen(FILE, ""wt"", stdout)\n#ifdef LOCAL\n#define BEGIN_PROFILE(idx, name) int profileIdx = idx; profileName[profileIdx] = name; totalTime[profileIdx] -= rdtsc() / 1e3;\n#define END_PROFILE totalTime[profileIdx] += rdtsc() / 1e3; totalCount[profileIdx]++;\n#else\n#define BEGIN_PROFILE(idx, name)\n#define END_PROFILE\n#endif\n\ntemplate<class T> inline void normmod(T &x, T m) { x %= m; if (x < 0) x += m; }\ntemplate<class T1, class T2> inline T2 summodfast(T1 x, T1 y, T2 m) { T2 res = x + y; if (res >= m) res -= m; return res; }\ntemplate<class T1, class T2, class T3> inline void addmodfast(T1 &x, T2 y, T3 m) { x += y; if (x >= m) x -= m; }\ntemplate<class T1, class T2, class T3> inline void submodfast(T1 &x, T2 y, T3 m) { x -= y; if (x < 0) x += m; }\n#if INTPTR_MAX == INT32_MAX or !defined(__SIZEOF_INT128__)\ninline ll mulmod(ll x, ll n, ll m){ ll r = 0; normmod(x, m); normmod(n, m); while (n) { if (n & 1) r += x; x += x; if (r >= m) r -= m; if (x >= m) x -= m; n /= 2; } return r; }\n#else\nusing int128 = __int128;\ninline ll mulmod(ll x, ll n, ll m){ return __int128(x) * n % m; }\n#endif\ninline ll powmod(ll x, ll n, ll m){ ll r = 1; normmod(x, m); while (n){ if (n & 1)r = (r*x) % m; x = (x*x) % m; n /= 2; }return r; }\ninline ll powmulmod(ll x, ll n, ll m) { ll res = 1; normmod(x, m); while (n){ if (n & 1)res = mulmod(res, x, m); x = mulmod(x, x, m); n /= 2; } return res; }\ntemplate<class T> inline T gcd(T a, T b) { while (b) { a %= b; T t = a; a = b; b = t; } return a; }\ninline ll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntemplate<class T> inline T gcd(T a, T b, T c){ return gcd(gcd(a, b), c); }\nll gcdex(ll a, ll b, ll& x, ll& y) {\n    if (!a) { x = 0; y = 1; return b; }\n    ll y1; ll d = gcdex(b % a, a, y, y1); x = y1 - (b / a) * y;\n    return d;\n}\ntemplate<class T> bool isPrime(T x) { if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n    for (T i = 5; i * i <= x; i += 6) if (x % i == 0 || x % (i + 2) == 0) return 0; return 1; }\nbool millerRabin(long long n) {\n    if (n <= 1000) return isPrime(n);\n    long long s = n - 1; int t = 0; while (s % 2 == 0) s /= 2, ++t;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) { if (!(a %= n)) return true;\n        long long f = powmulmod(a, s, n); if (f == 1 || f == n - 1) continue;\n        for (int i = 1; i < t; ++i) if ((f = mulmod(f, f, n)) == n - 1) goto nextp;\n        return false; nextp:;\n    } return true;\n}\n\n// Useful constants\n\n//int some_primes[7] = {24443, 100271, 1000003, 1000333, 5000321, 98765431, 1000000123};\n#define T9          1000000000\n#define T18         1000000000000000000LL\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define mod         1000000007\n#define EPS         (double)1e-10\n#define PI          3.14159265358979323846264\n#define link        asaxlajrewqwe\n#define rank        wahayawehasdakw\n//*************************************************************************************\n\nint32_t solve();\nint32_t main(int argc, char** argv) {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef LOCAL\n    //    FREIN(""input.txt"");\n    //            FREOUT(""out.txt"");\n#endif\n    return solve();\n}\nint a[10101];\nint solve() {\n    int n, m, c;\n    cin >> n >> m >> c;\n    FI(n) {\n        a[i] = INF;\n    }\n    int b = 0, e = 0;\n    while (m--) {\n//        printarray(a, n);\n        int x;\n        cin >> x;\n        int pos;\n        if (x <= c / 2) {\n            pos = int(upper_bound(a, a + b, x) - a);\n            if (pos == b) {\n                ++b;\n            }\n        } else {\n            pos = int(lower_bound(a + n - e, a + n, x) - a - 1);\n            if (pos == n - 1 - e) {\n                ++e;\n            }\n        }\n//        DBN(b, e);\n        a[pos] = x;\n        cout << pos + 1 << endl;\n        if (b + e == n) return 0;\n    }\n    \n    return 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 1, 1, 0, 0]",2000,As the initial sheet has already in a non decreasing order although it has no numbers what we should do is just maintain this order We use a simple method to do so find the first sheet whose number is strictly greater than the given number or it s an empty sheet and replace it with the new number For each round we either replace an existing number with a strictly smaller one or fill in an empty sheet The first case will happen at most times for each sheet and the second case will happen only once for each sheet Thus in total we will modify a sheet for at most times Thus the total rounds won t be more than To pass all the tests we only need to maintain 2 similar sequences one non decreasing from the first and one non increasing from the last which makes a total round of precisely and use binary search or brute force to complete the finding process 
You are given an integer n You have to calculate the number of binary consisting of characters and or strings s meeting the following constraints For every pair of integers i j such that 1 le i le j le n an integer a i j is given It imposes the following constraint on the string s i s i 1 s i 2 dots s j if a i j 1 all characters in s i s i 1 s i 2 dots s j should be the same if a i j 2 there should be at least two different characters in s i s i 1 s i 2 dots s j if a i j 0 there are no additional constraints on the string s i s i 1 s i 2 dots s j Count the number of binary strings s of length n meeting the aforementioned constraints Since the answer can be large print it modulo 998244353 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 111;\nMint dp[N];\nbool eq[N];\nbool hasDiff[N][N];\nint n;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tint x;\n\t\t\tscanf(""%d"", &x);\n\t\t\tif (x == 0) continue;\n\t\t\tif (x == 1) {\n\t\t\t\tfor (int k = i + 1; k < j; k++)\n\t\t\t\t\teq[k] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thasDiff[i][j] = 1;\n\t\t}\n\tfor (int len = 1; len < n; len++)\n\t\tfor (int l = 0; l + len <= n; l++) if (hasDiff[l][l + len]) {\n\t\t\tif (l > 0) hasDiff[l - 1][l + len] = 1;\n\t\t\tif (l + len < n) hasDiff[l][l + len + 1] = 1;\n\t\t}\n\tdp[0] = 2;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (!eq[j] && !hasDiff[i][j])\n\t\t\t\tdp[j] += dp[i];\n\t\t}\n\tprintf(""%u\\n"", dp[n].x);\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2100,Suppose we build the string from left to right and when we place the th character we ensure that all substrings are valid What do we need to know in order to calculate the number of different characters in the string ending with the th character Suppose the character is Let s try going to the left of it The string from to will have the same characters but if there is at least one character before the th position the string will have two different characters What about the strings in the middle The string will contain different characters if and only if there is at least one in since is so we are actually interested in the position of the last character before The same logic applies if the character is we are only interested in the position of the last before and it is enough to check if all substrings ending with the th character are violated What if when we choose the th character we violate some substring that doesn t end in the th position Well you could also check that or you could just ignore it Actually it doesn t matter if this happens because it means that the substring that is violated ends in some position and we will check it when placing the th character So the solution can be formulated with the following dynamic programming let be the number of ways to choose the first characters of the string so that the last character different from was or if there was no such character and all the constraints on the substrings ending no later than position are satisfied The transitions are simple you either place the same character as the last one going from to or a different character going from to and when you place a character you check all the constraints on the substrings ending with the th position Note that the state is actually represented by two strings and This solution works in although or implementations are also possible 
Student Arseny likes to plan his life for days ahead He visits a canteen every day and he has already decided what he will order in each of the following days Prices in the canteen do not change and that means Arseny will spend rubles during the th day There are ruble coins and ruble notes in circulation At this moment Arseny has coins and a sufficiently large amount of notes you can assume that he has an infinite amount of them Arseny loves modern technologies so he uses his credit card everywhere except the canteen but he has to pay in cash in the canteen because it does not accept cards Cashier always asks the student to pay change free However it s not always possible but Arseny tries to minimize the of the cashier Cashier s dissatisfaction for each of the days is determined by the total amount of notes and coins in the change To be precise if the cashier gives Arseny notes and coins on the th day his dissatisfaction for this day equals Cashier always gives change using as little coins and notes as possible he always has enough of them to be able to do this Arseny wants to pay in such a way that the total dissatisfaction of the cashier for days would be as small as possible Help him to find out how he needs to pay in each of the days Note that Arseny always has enough money to pay because he has an infinite amount of notes Arseny can use notes and coins he received in change during any of the following days ,"['#include<queue>\n#include<cstdio>\nusing namespace std;\n#define ran 1111111\nint n;\nlong long int m;\nlong long int c[ran],w[ran],d[ran];\npriority_queue<pair<long long int,int> > q;\nbool f[ran];\nint main(){\n\tscanf(""%d%I64d"",&n,&m);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(""%I64d"",&c[i]);\n\t\td[i] = c[i] % 100;\n\t\tf[i] = false;\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tscanf(""%I64d"",&w[i]);\n\twhile(!q.empty())q.pop();\n\tlong long int res = 0;\n\tfor(int i=0; i<n; i++){\n\t\tif(d[i] != 0){\n\t\t\tq.push(make_pair(-w[i] * (100 - d[i]),i));\n\t\t}\n\t\tm -= d[i];\n\t\tif(m < 0){\n\t\t\tm += 100;\n\t\t\tres -= q.top().first;\n\t\t\tf[q.top().second] = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n\tprintf(""%I64d\\n"",res);\n\tfor(int i=0; i<n; i++)\n\t\tif(!f[i])\n\t\t\tprintf(""%I64d %I64d\\n"",c[i]/100,c[i]%100);\n\t\telse\n\t\t\tprintf(""%I64d %I64d\\n"",c[i]/100+1,0);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400,The first thing to note is that during day it makes sense to either pay notes coins in this case the cashier s dissatisfaction would be equal to or just notes in that case the cashier s dissatisfaction would be equal to Moreover the second case is impossible if so in that case you just have to pay the required amount of notes In order to solve the problem we have to note the additional fact Let s suppose Arseny paid change free during the th day and gave the cashier coins Then if we change the payment way this day the amount of coins availible to Arseny would increase by regardless of the Indeed Arseny wouldn t spend those coins and he would aso receive coins in change which adds up to exactly coins Let s build the optimal solution day by day beginning from day one trying to pay change free every time to minimize the cashier s dissatisfaction Let th day be the first one when Arseny wouldn t be able to pay change free It means that Arseny has to get some change at least once during days from first to th But regardless of the day after th day he would have the same amount of coins It means that the optimal way is to get change during the day when the cashier s dissatisfaction would be minimal Then let s continue to pay change free whenever we can If Arseny again can t pay change free during day there must be a day from first to th when he got change Using similiar considerations whe should choose the day with the minimal cashier s dissatisfaction except the first one We should do these operations until we process all days The simple implementation of this process works in time and hits TLE But if you use any structure of data which allows you to add or delete element or find minimum in time for example heap or binary seach tree we can save all previous days into it and find a day with the minimal cashier s dissatisfaction faster than The final time is 
One day Vasya was going home when he saw a box lying on the road The box can be represented as a rectangular parallelepiped Vasya needed no time to realize that the box is special as all its edges are parallel to the coordinate axes one of its vertices is at point and the opposite one is at point The six faces of the box contain some numbers exactly one number right in the center of each face The numbers are located on the box like that number is written on the face that lies on the ZOX plane is written on the face parallel to the plane from the previous point is written on the face that lies on the XOY plane is written on the face parallel to the plane from the previous point is written on the face that lies on the YOZ plane is written on the face parallel to the plane from the previous point At the moment Vasya is looking at the box from point Find the sum of numbers that Vasya sees Note that all faces of the box are not transparent and Vasya can t see the numbers through the box The picture contains transparent faces just to make it easier to perceive You can consider that if Vasya is looking from point lying on the plane of some face than he can not see the number that is written on this face It is enough to see the center of a face to see the corresponding number for Vasya Also note that Vasya always reads correctly the numbers that he sees independently of their rotation angle and other factors that is for example if Vasya sees some then he can t mistake this number for and so on ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(""%d "",a[_X]);}puts("""");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(""%d "",a[_X][_Y]);puts("""");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    ll x,y,z;\n    cin >> x >> y >> z;\n    ll x1,y1,z1;\n    cin >> x1 >> y1 >> z1;\n    ll v1,v2,v3,v4,v5,v6;\n    cin >> v1 >> v2 >> v3 >> v4 >> v5 >> v6;\n    ll c1,c2,c3,c4,c5,c6;\n    c1 = c2 = c3 = c4 = c5 = c6 = 1;\n    \n    if( x > x1 ) c6 = 1 , c5 = 0;\n    else if( x < 0 ) c6 = 0 , c5 = 1;\n    else c6 = 0 , c5 = 0;\n    \n    if( y > y1 ) c2 = 1 , c1 = 0;\n    else if( y < 0 ) c2 = 0 , c1 = 1;\n    else c2 = 0 , c1 = 0;\n    \n    if( z > z1 ) c4 = 1 , c3 = 0;\n    else if( z < 0 ) c4 = 0 , c3 = 1;\n    else c4 = 0 , c3 = 0;\n    \n    cout << c1 * v1 + c2 * v2 + c3 * v3 + c4 * v4 + c5 * v5 + c6 * v6 << endl;\n    \n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1600,The main subtask of this problem is to check whether we can observe the center of face of parallelepiped from point Let s see the case when the face belongs to plane For performing all calculations in integer numbers multiply all coordinates by Take the point and normal to plane containing the fixed face which is directed out of interior of parallelepiped that is Also take vector If undirected angle between this vectors is less than degrees we can observe from For checking this we can use scalar product If scalar product of and is strictly greater than zero than that angle is fitting 
Polycarpus has been working in the analytic department of the F R A U D company for as much as days Right now his task is to make a series of reports about the company s performance for the last days We know that the main information in a day report is value the company s profit on the th day If is negative then the company suffered losses on the th day Polycarpus should sort the daily reports into folders Each folder should include data on the company s performance for several consecutive days Of course the information on each of the days should be exactly in one folder Thus Polycarpus puts information on the first few days in the first folder The information on the several following days goes to the second folder and so on It is known that the boss reads one daily report folder per day If one folder has three or more reports for the days in which the company suffered losses he loses his temper and his wrath is terrible Therefore Polycarpus wants to prepare the folders so that none of them contains information on three or more days with the loss and the number of folders is minimal Write a program that given sequence will print the minimum number of folders ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define FOR(it,a) for (__typeof((a).begin()) it=(a).begin();it!=(a).end();++it)\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\nconst double pi\t\t=\tacos(-1.0);\nconst double eps\t=\t1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\ninline int sign(double x)\n{\n\tif (x<-eps) return -1;\n\treturn x>eps;\n}\n\nstruct Tpoint\n{\n\tdouble x,y;\n\tTpoint(){}\n\tTpoint(double x,double y):x(x),y(y){}\n\tinline double norm(){return sqrt(x*x+y*y);}\n\tinline void rotate(double ang)\n\t{\n\t\tdouble co=cos(ang),si=sin(ang);\n\t\tdouble tx=x,ty=y;\n\t\tx=tx*co-ty*si;\n\t\ty=tx*si+ty*co;\n\t}\n};\n\ninline Tpoint operator +(const Tpoint &a,const Tpoint &b){return Tpoint(a.x+b.x,a.y+b.y);}\ninline Tpoint operator -(const Tpoint &a,const Tpoint &b){return Tpoint(a.x-b.x,a.y-b.y);}\ninline Tpoint operator *(const Tpoint &a,const double &b){return Tpoint(a.x*b,a.y*b);}\ninline Tpoint operator /(const Tpoint &a,const double &b){return Tpoint(a.x/b,a.y/b);}\ninline double det(const Tpoint &a,const Tpoint &b){return a.x*b.y-a.y*b.x;}\ninline double dot(const Tpoint &a,const Tpoint &b){return a.x*b.x+a.y*b.y;}\n//================================\n\nint main()\n{\n\tint n;\n\tscanf(""%d"",&n);\n\tint cnt=0;\n\tVI a(1,0);\n\tfor (int i=0;i<n;++i){\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tif (x<0){\n\t\t\t ++cnt;\n\t\t}\n\t\tif (cnt<3){\n\t\t\ta.back()++;\n\t\t}else{\n\t\t\ta.push_back(1);\n\t\t\tcnt=1;\n\t\t}\n\t}\n\tprintf(""%d\\n"",a.size());\n\tFOR (it,a){\n\t\tprintf(""%d "",*it);\n\t}\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000,For every folder you should take reports as much as possible In other words you should stop forming a folder either before the third bad report or in the end of sequence You can easily prove that this strategy is optimal This solution works in O n 
You are given two integers l and r l le r Your task is to calculate the sum of numbers from l to r including l and r such that each number contains k different digits and print this sum modulo 998244353 For example if k 1 then you have to calculate all numbers from l to r such that each number is formed using only one digit For l 10 r 50 the answer is 11 22 33 44 110 ,"[""#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nmint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nmint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nmint dp[20][2][2][2][1 << 10];\nmint dp2[20][2][2][2][1 << 10];\n\nint popcnt(int n) {\n  int res = 0;\n  while (n > 0) {\n    res++;\n    n &= n - 1;\n  }\n  return res;\n}\n\nint main() {\n  string L, R;\n  int K;\n  cin >> L >> R >> K;\n  while (L.size() < R.size()) L = '0' + L;\n  while (L.size() > R.size()) R = '0' + R;\n  int n = L.size();\n  dp[0][0][0][0][0] = 1;\n  dp2[0][0][0][0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 2; l++) {\n          for (int m = 0; m < 1 << 10; m++) {\n            int x = j ? 0 : L[i] - '0';\n            int y = k ? 9 : R[i] - '0';\n            for (int d = x; d <= y; d++) {\n              int mm = l == 0 && d == 0 ? 0 : (m | 1 << d);\n              dp[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp[i][j][k][l][m];\n              dp2[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp2[i][j][k][l][m] * 10 + dp[i][j][k][l][m] * d;\n            }\n          }\n        }\n      }\n    }\n  }\n  mint ans;\n  for (int j = 0; j < 2; j++) {\n    for (int k = 0; k < 2; k++) {\n      for (int m = 0; m < 1 << 10; m++) {\n        if (popcnt(m) <= K) {\n          ans += dp2[n][j][k][1][m];\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n""]","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2300,Let s calculate the answer as the sum of suitable numbers in range minus the sum of suitable numbers in range Now our problem is to calculate the sum of suitable numbers in range The main approach for problem is digit DP Let s calculate two dynamic programmings and means that now we are at the th digit of the number at the digit corresponding to where is the decimal length of a number is a binary mask describing digits we already use and equals if the current prefix of number we trying to obtain is the same as the prefix of number otherwise equals So what means It means the count of numbers in general not numbers but their prefixes in range of length without leading zeroes corresponding to this state So what the point of this DP Its point is helping us to calculate the main DP which means the sum of numbers in general not numbers but their prefixes in range of length without leading zeroes corresponding to this state How do we calculate the answer Firstly let be the length of Let be the function calculating the sum of numbers from to containing at most different digits How to calculate it Let be the sum of numbers from to containing at most different digits and having length exactly Then seems to be pretty easy for each length from to add to the answer And the last step is to add to the answer How to calculate dynamic programmings Initially all states are zeroes excluding which is Firstly let s calculate After calculating it we can calculate in almost the same way Let s iterate over all possible lengths and over all possible masks Let the current state is Then let s iterate over next digit we will place in this number and place it If then otherwise The transition is pretty easy There is the bitwise operation For transitions are almost the same expect the restrictions on digit we place and the state we update If we now at the position with mask and then the current digit of is Then let s iterate over next digit if otherwise The transition is also easy After calculating the previous DP we can calculate All the process is the same as in the previous dynamic programming expect the value we will add in transitions In the previous DP this value was equal in the current DP this value equals to Don t forget to calculate it modulo So after calculating all the values of DPs what is the answer for It is for all masks with at most bits I m pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight forward and simple 
The folk hero Robin Hood has been troubling Sheriff of Nottingham greatly Sheriff knows that Robin Hood is about to attack his camps and he wants to be prepared Sheriff of Nottingham built the camps with strategy in mind and thus there are exactly n camps numbered from 1 to n and n 1 trails each connecting two camps Any camp can be reached from any other camp Each camp i has initially a i gold As it is now all camps would be destroyed by Robin Sheriff can strengthen a camp by subtracting exactly c gold from and use it to build better defenses for that camp Strengthening a camp its gold only its neighbors gold A camp can have negative gold After Robin Hood s attack all camps that have been strengthened survive the attack all others are destroyed What s the maximum gold Sheriff can keep in his surviving camps after Robin Hood s attack if he strengthens his camps optimally Camp a is neighboring camp b if and only if there exists a trail connecting a and b Only strengthened camps count towards the answer as others are destroyed ,"[""#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, m, a[N], dp[N][2];vector<int> e[N];void dfs(int u, int fa){    for (auto to : e[u])        if (to != fa)        {            dfs(to, u);            dp[u][0] += max(dp[to][0], dp[to][1]);            dp[u][1] += max(dp[to][0], dp[to][1] - 2 * m);        }}void solve(){    cin >> n >> m;    for (int i = 1; i <= n; i++)        cin >> a[i], e[i].clear(), dp[i][0] = 0, dp[i][1] = a[i];    for (int i = 1; i < n; i++)    {        int u, v;        cin >> u >> v;        e[u].push_back(v), e[v].push_back(u);    }    dfs(1, 0);    cout << max(dp[1][0], dp[1][1]) << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}""]","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000,An important observation is that strengthening a base only influences its neighbors so we can just keep consider adjacent nodes as later ones are not affected Let s consider induction to solve this problem Let d i 0 denote the most gold from node i and all its children if we don t strengthen node i and d i 1 if we do strengthen the node i Base case If the current node i is a leaf d i 0 0 d i 1 ai Induction step Consider the node i with children 1 m Assume that all nodes 1 m are already calculated If we don t strengthen the node i d i 0 mj 1max d j 0 d j 1 If the node i is strengthened d i 1 ai mj 1max d j 0 d j 1 2 c Time complexity O n 
